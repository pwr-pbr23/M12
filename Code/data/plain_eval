{"https:\/\/github.com\/liatrio\/w3af":{"d92c861c687d66626b1e4a99f1af96906ca49a7a":{"url":"https:\/\/api.github.com\/repos\/liatrio\/w3af\/commits\/d92c861c687d66626b1e4a99f1af96906ca49a7a","html_url":"https:\/\/github.com\/liatrio\/w3af\/commit\/d92c861c687d66626b1e4a99f1af96906ca49a7a","sha":"d92c861c687d66626b1e4a99f1af96906ca49a7a","keyword":"eval injection fix","diff":"diff --git a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\nindex c288ec4f1..6f8e5baa1 100644\n--- a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n+++ b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n@@ -23,6 +23,7 @@\n import copy\n \n from w3af.core.data.dc.utils.token import DataToken\n+from w3af.core.data.misc.encoding import smart_unicode\n \n \n class TestToken(unittest.TestCase):\n@@ -58,4 +59,13 @@ def test_copy_after_change(self):\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file\ndiff --git a\/w3af\/core\/data\/misc\/encoding.py b\/w3af\/core\/data\/misc\/encoding.py\nindex 353b453d0..f65da333d 100644\n--- a\/w3af\/core\/data\/misc\/encoding.py\n+++ b\/w3af\/core\/data\/misc\/encoding.py\n@@ -70,7 +70,7 @@ def _percent_encode(encodingexc):\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n@@ -95,9 +95,20 @@ def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","message":"","files":{"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py":{"changes":[{"diff":"\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file","add":10,"remove":1,"filename":"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py","badparts":["        self.assertEqual(token.get_path(), self.PATH)"],"goodparts":["        self.assertEqual(token.get_path(), self.PATH)","    def test_invalid_utf8(self):","        invalid_utf8 = '\\xf3'","        token = DataToken(self.NAME, invalid_utf8, self.PATH)","        self.assertRaises(UnicodeDecodeError, unicode, token)","        encoded_token = smart_unicode(token)","        self.assertEqual(encoded_token, u'\\xf3')"]}],"source":"\n\"\"\" test_token.py Copyright 2014 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import unittest import copy from w3af.core.data.dc.utils.token import DataToken class TestToken(unittest.TestCase): NAME='name' VALUE='value' PATH='path' PAYLOAD='payload' def test_basic(self): token=DataToken(self.NAME, self.VALUE, self.PATH) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy(self): original=DataToken(self.NAME, self.VALUE, self.PATH) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy_after_change(self): original=DataToken(self.NAME, self.VALUE, self.PATH) original.set_value(self.PAYLOAD) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.PAYLOAD) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) ","sourceWithComments":"\"\"\"\ntest_token.py\n\nCopyright 2014 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport unittest\nimport copy\n\nfrom w3af.core.data.dc.utils.token import DataToken\n\n\nclass TestToken(unittest.TestCase):\n    NAME = 'name'\n    VALUE = 'value'\n    PATH = 'path'\n    PAYLOAD = 'payload'\n\n    def test_basic(self):\n        token = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy_after_change(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n        original.set_value(self.PAYLOAD)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.PAYLOAD)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)"},"\/w3af\/core\/data\/misc\/encoding.py":{"changes":[{"diff":"\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n","add":1,"remove":1,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["    Return the unicode representation of 's'. Decodes bytestrings using"],"goodparts":["    Return the unicode representation of 's'. Decodes byte-strings using"]},{"diff":"\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","add":13,"remove":2,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["            s = unicode(s, encoding, errors)","            s = unicode(str(s), encoding, errors)"],"goodparts":["            try:","                s = unicode(s)","            except UnicodeDecodeError:","                s = str(s)","                s = smart_unicode(s, encoding=encoding, errors=errors,","                                  on_error_guess=on_error_guess)","            s = str(s)","            s = smart_unicode(s, encoding=encoding, errors=errors,","                              on_error_guess=on_error_guess)"]}],"source":"\n\"\"\" encoding.py Copyright 2012 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import codecs import urllib import chardet ESCAPED_CHAR='slash_escape_char' PERCENT_ENCODE='percent_encode' HTML_ENCODE='html_encode_char' def _return_html_encoded(encodingexc): \"\"\" :return: & \"\"\" st=encodingexc.start en=encodingexc.end hex_encoded=\"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en]) return unicode('& def _return_escaped_char(encodingexc): \"\"\" :return: \\\\xff when input is \\xff \"\"\" st=encodingexc.start en=encodingexc.end slash_x_XX=repr(encodingexc.object[st:en])[1:-1] return unicode(slash_x_XX), en def _percent_encode(encodingexc): if not isinstance(encodingexc, UnicodeEncodeError): raise encodingexc st=encodingexc.start en=encodingexc.end return( u'%s' %(urllib.quote(encodingexc.object[st:en].encode('utf8')),), en ) codecs.register_error(ESCAPED_CHAR, _return_escaped_char) codecs.register_error(PERCENT_ENCODE, _percent_encode) codecs.register_error(HTML_ENCODE, _return_html_encoded) def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True): \"\"\" Return the unicode representation of 's'. Decodes bytestrings using the 'encoding' codec. \"\"\" if isinstance(s, unicode): return s if isinstance(s, str): try: s=s.decode(encoding, errors) except UnicodeDecodeError: if not on_error_guess: raise guessed_encoding=chardet.detect(s)['encoding'] if guessed_encoding is None: s=s.decode(encoding, 'ignore') else: try: s=s.decode(guessed_encoding, errors) except UnicodeDecodeError: s=s.decode(encoding, 'ignore') else: if hasattr(s, '__unicode__'): s=unicode(s, encoding, errors) else: s=unicode(str(s), encoding, errors) return s def smart_str(s, encoding='utf-8', errors='strict'): \"\"\" Return a bytestring version of 's', encoded as specified in 'encoding'. \"\"\" if isinstance(s, unicode): s=s.encode(encoding, errors) elif not isinstance(s, str): s=str(s) return s def is_known_encoding(encoding): \"\"\" :return: True if the encoding name is known. >>> is_known_encoding( 'foo') False >>> is_known_encoding( 'utf-8') True \"\"\" try: codecs.lookup(encoding) return True except LookupError: return False ","sourceWithComments":"\"\"\"\nencoding.py\n\nCopyright 2012 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport codecs\nimport urllib\nimport chardet\n\n# Custom error handling schemes registration\nESCAPED_CHAR = 'slash_escape_char'\nPERCENT_ENCODE = 'percent_encode'\nHTML_ENCODE = 'html_encode_char'\n\n\ndef _return_html_encoded(encodingexc):\n    \"\"\"\n    :return: &#xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n    hex_encoded = \"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en])\n\n    return unicode('&#x' + hex_encoded), en\n\n\ndef _return_escaped_char(encodingexc):\n    \"\"\"\n    :return: \\\\xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n\n    slash_x_XX = repr(encodingexc.object[st:en])[1:-1]\n    return unicode(slash_x_XX), en\n\n\ndef _percent_encode(encodingexc):\n    if not isinstance(encodingexc, UnicodeEncodeError):\n        raise encodingexc\n\n    st = encodingexc.start\n    en = encodingexc.end\n\n    return (\n        u'%s' % (urllib.quote(encodingexc.object[st:en].encode('utf8')),),\n        en\n    )\n\ncodecs.register_error(ESCAPED_CHAR, _return_escaped_char)\ncodecs.register_error(PERCENT_ENCODE, _percent_encode)\ncodecs.register_error(HTML_ENCODE, _return_html_encoded)\n\n\ndef smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n    \"\"\"\n    Return the unicode representation of 's'. Decodes bytestrings using\n    the 'encoding' codec.\n    \"\"\"\n    if isinstance(s, unicode):\n        return s\n    \n    if isinstance(s, str):\n        try:\n            s = s.decode(encoding, errors)\n        except UnicodeDecodeError:\n            if not on_error_guess:\n                raise\n\n            guessed_encoding = chardet.detect(s)['encoding']\n\n            if guessed_encoding is None:\n                # Chardet failed to guess the encoding! This is really broken\n                s = s.decode(encoding, 'ignore')\n            else:\n                try:\n                    s = s.decode(guessed_encoding, errors)\n                except UnicodeDecodeError:\n                    s = s.decode(encoding, 'ignore')\n    else:\n        if hasattr(s, '__unicode__'):\n            s = unicode(s, encoding, errors)\n        else:\n            s = unicode(str(s), encoding, errors)\n\n    return s\n\n\ndef smart_str(s, encoding='utf-8', errors='strict'):\n    \"\"\"\n    Return a bytestring version of 's', encoded as specified in 'encoding'.\n    \"\"\"\n    if isinstance(s, unicode):\n        s = s.encode(encoding, errors)\n    elif not isinstance(s, str):\n        s = str(s)\n    return s\n\n\ndef is_known_encoding(encoding):\n    \"\"\"\n    :return: True if the encoding name is known.\n\n    >>> is_known_encoding( 'foo' )\n    False\n    >>> is_known_encoding( 'utf-8' )\n    True\n    \"\"\"\n    try:\n        codecs.lookup(encoding)\n        return True\n    except LookupError:\n        return False\n\n"}},"msg":"Better support for unicode(object) calls in smart_unicode function\nThis leads to a fix of Encoding issue in URL during eval.py injection #4423"}},"https:\/\/github.com\/afeier-felix\/W3AF":{"d92c861c687d66626b1e4a99f1af96906ca49a7a":{"url":"https:\/\/api.github.com\/repos\/afeier-felix\/W3AF\/commits\/d92c861c687d66626b1e4a99f1af96906ca49a7a","html_url":"https:\/\/github.com\/afeier-felix\/W3AF\/commit\/d92c861c687d66626b1e4a99f1af96906ca49a7a","sha":"d92c861c687d66626b1e4a99f1af96906ca49a7a","keyword":"eval injection fix","diff":"diff --git a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\nindex c288ec4f1..6f8e5baa1 100644\n--- a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n+++ b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n@@ -23,6 +23,7 @@\n import copy\n \n from w3af.core.data.dc.utils.token import DataToken\n+from w3af.core.data.misc.encoding import smart_unicode\n \n \n class TestToken(unittest.TestCase):\n@@ -58,4 +59,13 @@ def test_copy_after_change(self):\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file\ndiff --git a\/w3af\/core\/data\/misc\/encoding.py b\/w3af\/core\/data\/misc\/encoding.py\nindex 353b453d0..f65da333d 100644\n--- a\/w3af\/core\/data\/misc\/encoding.py\n+++ b\/w3af\/core\/data\/misc\/encoding.py\n@@ -70,7 +70,7 @@ def _percent_encode(encodingexc):\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n@@ -95,9 +95,20 @@ def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","message":"","files":{"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py":{"changes":[{"diff":"\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file","add":10,"remove":1,"filename":"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py","badparts":["        self.assertEqual(token.get_path(), self.PATH)"],"goodparts":["        self.assertEqual(token.get_path(), self.PATH)","    def test_invalid_utf8(self):","        invalid_utf8 = '\\xf3'","        token = DataToken(self.NAME, invalid_utf8, self.PATH)","        self.assertRaises(UnicodeDecodeError, unicode, token)","        encoded_token = smart_unicode(token)","        self.assertEqual(encoded_token, u'\\xf3')"]}],"source":"\n\"\"\" test_token.py Copyright 2014 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import unittest import copy from w3af.core.data.dc.utils.token import DataToken class TestToken(unittest.TestCase): NAME='name' VALUE='value' PATH='path' PAYLOAD='payload' def test_basic(self): token=DataToken(self.NAME, self.VALUE, self.PATH) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy(self): original=DataToken(self.NAME, self.VALUE, self.PATH) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy_after_change(self): original=DataToken(self.NAME, self.VALUE, self.PATH) original.set_value(self.PAYLOAD) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.PAYLOAD) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) ","sourceWithComments":"\"\"\"\ntest_token.py\n\nCopyright 2014 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport unittest\nimport copy\n\nfrom w3af.core.data.dc.utils.token import DataToken\n\n\nclass TestToken(unittest.TestCase):\n    NAME = 'name'\n    VALUE = 'value'\n    PATH = 'path'\n    PAYLOAD = 'payload'\n\n    def test_basic(self):\n        token = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy_after_change(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n        original.set_value(self.PAYLOAD)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.PAYLOAD)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)"},"\/w3af\/core\/data\/misc\/encoding.py":{"changes":[{"diff":"\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n","add":1,"remove":1,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["    Return the unicode representation of 's'. Decodes bytestrings using"],"goodparts":["    Return the unicode representation of 's'. Decodes byte-strings using"]},{"diff":"\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","add":13,"remove":2,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["            s = unicode(s, encoding, errors)","            s = unicode(str(s), encoding, errors)"],"goodparts":["            try:","                s = unicode(s)","            except UnicodeDecodeError:","                s = str(s)","                s = smart_unicode(s, encoding=encoding, errors=errors,","                                  on_error_guess=on_error_guess)","            s = str(s)","            s = smart_unicode(s, encoding=encoding, errors=errors,","                              on_error_guess=on_error_guess)"]}],"source":"\n\"\"\" encoding.py Copyright 2012 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import codecs import urllib import chardet ESCAPED_CHAR='slash_escape_char' PERCENT_ENCODE='percent_encode' HTML_ENCODE='html_encode_char' def _return_html_encoded(encodingexc): \"\"\" :return: & \"\"\" st=encodingexc.start en=encodingexc.end hex_encoded=\"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en]) return unicode('& def _return_escaped_char(encodingexc): \"\"\" :return: \\\\xff when input is \\xff \"\"\" st=encodingexc.start en=encodingexc.end slash_x_XX=repr(encodingexc.object[st:en])[1:-1] return unicode(slash_x_XX), en def _percent_encode(encodingexc): if not isinstance(encodingexc, UnicodeEncodeError): raise encodingexc st=encodingexc.start en=encodingexc.end return( u'%s' %(urllib.quote(encodingexc.object[st:en].encode('utf8')),), en ) codecs.register_error(ESCAPED_CHAR, _return_escaped_char) codecs.register_error(PERCENT_ENCODE, _percent_encode) codecs.register_error(HTML_ENCODE, _return_html_encoded) def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True): \"\"\" Return the unicode representation of 's'. Decodes bytestrings using the 'encoding' codec. \"\"\" if isinstance(s, unicode): return s if isinstance(s, str): try: s=s.decode(encoding, errors) except UnicodeDecodeError: if not on_error_guess: raise guessed_encoding=chardet.detect(s)['encoding'] if guessed_encoding is None: s=s.decode(encoding, 'ignore') else: try: s=s.decode(guessed_encoding, errors) except UnicodeDecodeError: s=s.decode(encoding, 'ignore') else: if hasattr(s, '__unicode__'): s=unicode(s, encoding, errors) else: s=unicode(str(s), encoding, errors) return s def smart_str(s, encoding='utf-8', errors='strict'): \"\"\" Return a bytestring version of 's', encoded as specified in 'encoding'. \"\"\" if isinstance(s, unicode): s=s.encode(encoding, errors) elif not isinstance(s, str): s=str(s) return s def is_known_encoding(encoding): \"\"\" :return: True if the encoding name is known. >>> is_known_encoding( 'foo') False >>> is_known_encoding( 'utf-8') True \"\"\" try: codecs.lookup(encoding) return True except LookupError: return False ","sourceWithComments":"\"\"\"\nencoding.py\n\nCopyright 2012 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport codecs\nimport urllib\nimport chardet\n\n# Custom error handling schemes registration\nESCAPED_CHAR = 'slash_escape_char'\nPERCENT_ENCODE = 'percent_encode'\nHTML_ENCODE = 'html_encode_char'\n\n\ndef _return_html_encoded(encodingexc):\n    \"\"\"\n    :return: &#xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n    hex_encoded = \"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en])\n\n    return unicode('&#x' + hex_encoded), en\n\n\ndef _return_escaped_char(encodingexc):\n    \"\"\"\n    :return: \\\\xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n\n    slash_x_XX = repr(encodingexc.object[st:en])[1:-1]\n    return unicode(slash_x_XX), en\n\n\ndef _percent_encode(encodingexc):\n    if not isinstance(encodingexc, UnicodeEncodeError):\n        raise encodingexc\n\n    st = encodingexc.start\n    en = encodingexc.end\n\n    return (\n        u'%s' % (urllib.quote(encodingexc.object[st:en].encode('utf8')),),\n        en\n    )\n\ncodecs.register_error(ESCAPED_CHAR, _return_escaped_char)\ncodecs.register_error(PERCENT_ENCODE, _percent_encode)\ncodecs.register_error(HTML_ENCODE, _return_html_encoded)\n\n\ndef smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n    \"\"\"\n    Return the unicode representation of 's'. Decodes bytestrings using\n    the 'encoding' codec.\n    \"\"\"\n    if isinstance(s, unicode):\n        return s\n    \n    if isinstance(s, str):\n        try:\n            s = s.decode(encoding, errors)\n        except UnicodeDecodeError:\n            if not on_error_guess:\n                raise\n\n            guessed_encoding = chardet.detect(s)['encoding']\n\n            if guessed_encoding is None:\n                # Chardet failed to guess the encoding! This is really broken\n                s = s.decode(encoding, 'ignore')\n            else:\n                try:\n                    s = s.decode(guessed_encoding, errors)\n                except UnicodeDecodeError:\n                    s = s.decode(encoding, 'ignore')\n    else:\n        if hasattr(s, '__unicode__'):\n            s = unicode(s, encoding, errors)\n        else:\n            s = unicode(str(s), encoding, errors)\n\n    return s\n\n\ndef smart_str(s, encoding='utf-8', errors='strict'):\n    \"\"\"\n    Return a bytestring version of 's', encoded as specified in 'encoding'.\n    \"\"\"\n    if isinstance(s, unicode):\n        s = s.encode(encoding, errors)\n    elif not isinstance(s, str):\n        s = str(s)\n    return s\n\n\ndef is_known_encoding(encoding):\n    \"\"\"\n    :return: True if the encoding name is known.\n\n    >>> is_known_encoding( 'foo' )\n    False\n    >>> is_known_encoding( 'utf-8' )\n    True\n    \"\"\"\n    try:\n        codecs.lookup(encoding)\n        return True\n    except LookupError:\n        return False\n\n"}},"msg":"Better support for unicode(object) calls in smart_unicode function\nThis leads to a fix of Encoding issue in URL during eval.py injection #4423"}},"https:\/\/github.com\/zakizaidi\/w3a.gif":{"d92c861c687d66626b1e4a99f1af96906ca49a7a":{"url":"https:\/\/api.github.com\/repos\/zakizaidi\/w3a.gif\/commits\/d92c861c687d66626b1e4a99f1af96906ca49a7a","html_url":"https:\/\/github.com\/zakizaidi\/w3a.gif\/commit\/d92c861c687d66626b1e4a99f1af96906ca49a7a","sha":"d92c861c687d66626b1e4a99f1af96906ca49a7a","keyword":"eval injection fix","diff":"diff --git a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\nindex c288ec4f1..6f8e5baa1 100644\n--- a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n+++ b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n@@ -23,6 +23,7 @@\n import copy\n \n from w3af.core.data.dc.utils.token import DataToken\n+from w3af.core.data.misc.encoding import smart_unicode\n \n \n class TestToken(unittest.TestCase):\n@@ -58,4 +59,13 @@ def test_copy_after_change(self):\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file\ndiff --git a\/w3af\/core\/data\/misc\/encoding.py b\/w3af\/core\/data\/misc\/encoding.py\nindex 353b453d0..f65da333d 100644\n--- a\/w3af\/core\/data\/misc\/encoding.py\n+++ b\/w3af\/core\/data\/misc\/encoding.py\n@@ -70,7 +70,7 @@ def _percent_encode(encodingexc):\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n@@ -95,9 +95,20 @@ def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","message":"","files":{"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py":{"changes":[{"diff":"\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file","add":10,"remove":1,"filename":"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py","badparts":["        self.assertEqual(token.get_path(), self.PATH)"],"goodparts":["        self.assertEqual(token.get_path(), self.PATH)","    def test_invalid_utf8(self):","        invalid_utf8 = '\\xf3'","        token = DataToken(self.NAME, invalid_utf8, self.PATH)","        self.assertRaises(UnicodeDecodeError, unicode, token)","        encoded_token = smart_unicode(token)","        self.assertEqual(encoded_token, u'\\xf3')"]}],"source":"\n\"\"\" test_token.py Copyright 2014 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import unittest import copy from w3af.core.data.dc.utils.token import DataToken class TestToken(unittest.TestCase): NAME='name' VALUE='value' PATH='path' PAYLOAD='payload' def test_basic(self): token=DataToken(self.NAME, self.VALUE, self.PATH) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy(self): original=DataToken(self.NAME, self.VALUE, self.PATH) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy_after_change(self): original=DataToken(self.NAME, self.VALUE, self.PATH) original.set_value(self.PAYLOAD) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.PAYLOAD) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) ","sourceWithComments":"\"\"\"\ntest_token.py\n\nCopyright 2014 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport unittest\nimport copy\n\nfrom w3af.core.data.dc.utils.token import DataToken\n\n\nclass TestToken(unittest.TestCase):\n    NAME = 'name'\n    VALUE = 'value'\n    PATH = 'path'\n    PAYLOAD = 'payload'\n\n    def test_basic(self):\n        token = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy_after_change(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n        original.set_value(self.PAYLOAD)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.PAYLOAD)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)"},"\/w3af\/core\/data\/misc\/encoding.py":{"changes":[{"diff":"\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n","add":1,"remove":1,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["    Return the unicode representation of 's'. Decodes bytestrings using"],"goodparts":["    Return the unicode representation of 's'. Decodes byte-strings using"]},{"diff":"\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","add":13,"remove":2,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["            s = unicode(s, encoding, errors)","            s = unicode(str(s), encoding, errors)"],"goodparts":["            try:","                s = unicode(s)","            except UnicodeDecodeError:","                s = str(s)","                s = smart_unicode(s, encoding=encoding, errors=errors,","                                  on_error_guess=on_error_guess)","            s = str(s)","            s = smart_unicode(s, encoding=encoding, errors=errors,","                              on_error_guess=on_error_guess)"]}],"source":"\n\"\"\" encoding.py Copyright 2012 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import codecs import urllib import chardet ESCAPED_CHAR='slash_escape_char' PERCENT_ENCODE='percent_encode' HTML_ENCODE='html_encode_char' def _return_html_encoded(encodingexc): \"\"\" :return: & \"\"\" st=encodingexc.start en=encodingexc.end hex_encoded=\"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en]) return unicode('& def _return_escaped_char(encodingexc): \"\"\" :return: \\\\xff when input is \\xff \"\"\" st=encodingexc.start en=encodingexc.end slash_x_XX=repr(encodingexc.object[st:en])[1:-1] return unicode(slash_x_XX), en def _percent_encode(encodingexc): if not isinstance(encodingexc, UnicodeEncodeError): raise encodingexc st=encodingexc.start en=encodingexc.end return( u'%s' %(urllib.quote(encodingexc.object[st:en].encode('utf8')),), en ) codecs.register_error(ESCAPED_CHAR, _return_escaped_char) codecs.register_error(PERCENT_ENCODE, _percent_encode) codecs.register_error(HTML_ENCODE, _return_html_encoded) def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True): \"\"\" Return the unicode representation of 's'. Decodes bytestrings using the 'encoding' codec. \"\"\" if isinstance(s, unicode): return s if isinstance(s, str): try: s=s.decode(encoding, errors) except UnicodeDecodeError: if not on_error_guess: raise guessed_encoding=chardet.detect(s)['encoding'] if guessed_encoding is None: s=s.decode(encoding, 'ignore') else: try: s=s.decode(guessed_encoding, errors) except UnicodeDecodeError: s=s.decode(encoding, 'ignore') else: if hasattr(s, '__unicode__'): s=unicode(s, encoding, errors) else: s=unicode(str(s), encoding, errors) return s def smart_str(s, encoding='utf-8', errors='strict'): \"\"\" Return a bytestring version of 's', encoded as specified in 'encoding'. \"\"\" if isinstance(s, unicode): s=s.encode(encoding, errors) elif not isinstance(s, str): s=str(s) return s def is_known_encoding(encoding): \"\"\" :return: True if the encoding name is known. >>> is_known_encoding( 'foo') False >>> is_known_encoding( 'utf-8') True \"\"\" try: codecs.lookup(encoding) return True except LookupError: return False ","sourceWithComments":"\"\"\"\nencoding.py\n\nCopyright 2012 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport codecs\nimport urllib\nimport chardet\n\n# Custom error handling schemes registration\nESCAPED_CHAR = 'slash_escape_char'\nPERCENT_ENCODE = 'percent_encode'\nHTML_ENCODE = 'html_encode_char'\n\n\ndef _return_html_encoded(encodingexc):\n    \"\"\"\n    :return: &#xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n    hex_encoded = \"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en])\n\n    return unicode('&#x' + hex_encoded), en\n\n\ndef _return_escaped_char(encodingexc):\n    \"\"\"\n    :return: \\\\xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n\n    slash_x_XX = repr(encodingexc.object[st:en])[1:-1]\n    return unicode(slash_x_XX), en\n\n\ndef _percent_encode(encodingexc):\n    if not isinstance(encodingexc, UnicodeEncodeError):\n        raise encodingexc\n\n    st = encodingexc.start\n    en = encodingexc.end\n\n    return (\n        u'%s' % (urllib.quote(encodingexc.object[st:en].encode('utf8')),),\n        en\n    )\n\ncodecs.register_error(ESCAPED_CHAR, _return_escaped_char)\ncodecs.register_error(PERCENT_ENCODE, _percent_encode)\ncodecs.register_error(HTML_ENCODE, _return_html_encoded)\n\n\ndef smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n    \"\"\"\n    Return the unicode representation of 's'. Decodes bytestrings using\n    the 'encoding' codec.\n    \"\"\"\n    if isinstance(s, unicode):\n        return s\n    \n    if isinstance(s, str):\n        try:\n            s = s.decode(encoding, errors)\n        except UnicodeDecodeError:\n            if not on_error_guess:\n                raise\n\n            guessed_encoding = chardet.detect(s)['encoding']\n\n            if guessed_encoding is None:\n                # Chardet failed to guess the encoding! This is really broken\n                s = s.decode(encoding, 'ignore')\n            else:\n                try:\n                    s = s.decode(guessed_encoding, errors)\n                except UnicodeDecodeError:\n                    s = s.decode(encoding, 'ignore')\n    else:\n        if hasattr(s, '__unicode__'):\n            s = unicode(s, encoding, errors)\n        else:\n            s = unicode(str(s), encoding, errors)\n\n    return s\n\n\ndef smart_str(s, encoding='utf-8', errors='strict'):\n    \"\"\"\n    Return a bytestring version of 's', encoded as specified in 'encoding'.\n    \"\"\"\n    if isinstance(s, unicode):\n        s = s.encode(encoding, errors)\n    elif not isinstance(s, str):\n        s = str(s)\n    return s\n\n\ndef is_known_encoding(encoding):\n    \"\"\"\n    :return: True if the encoding name is known.\n\n    >>> is_known_encoding( 'foo' )\n    False\n    >>> is_known_encoding( 'utf-8' )\n    True\n    \"\"\"\n    try:\n        codecs.lookup(encoding)\n        return True\n    except LookupError:\n        return False\n\n"}},"msg":"Better support for unicode(object) calls in smart_unicode function\nThis leads to a fix of Encoding issue in URL during eval.py injection #4423"}},"https:\/\/github.com\/De30\/w3af_Attack-and-Audit-Framework":{"d92c861c687d66626b1e4a99f1af96906ca49a7a":{"url":"https:\/\/api.github.com\/repos\/De30\/w3af_Attack-and-Audit-Framework\/commits\/d92c861c687d66626b1e4a99f1af96906ca49a7a","html_url":"https:\/\/github.com\/De30\/w3af_Attack-and-Audit-Framework\/commit\/d92c861c687d66626b1e4a99f1af96906ca49a7a","sha":"d92c861c687d66626b1e4a99f1af96906ca49a7a","keyword":"eval injection fix","diff":"diff --git a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\nindex c288ec4f1a..6f8e5baa11 100644\n--- a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n+++ b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n@@ -23,6 +23,7 @@\n import copy\n \n from w3af.core.data.dc.utils.token import DataToken\n+from w3af.core.data.misc.encoding import smart_unicode\n \n \n class TestToken(unittest.TestCase):\n@@ -58,4 +59,13 @@ def test_copy_after_change(self):\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file\ndiff --git a\/w3af\/core\/data\/misc\/encoding.py b\/w3af\/core\/data\/misc\/encoding.py\nindex 353b453d0d..f65da333d2 100644\n--- a\/w3af\/core\/data\/misc\/encoding.py\n+++ b\/w3af\/core\/data\/misc\/encoding.py\n@@ -70,7 +70,7 @@ def _percent_encode(encodingexc):\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n@@ -95,9 +95,20 @@ def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","message":"","files":{"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py":{"changes":[{"diff":"\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file","add":10,"remove":1,"filename":"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py","badparts":["        self.assertEqual(token.get_path(), self.PATH)"],"goodparts":["        self.assertEqual(token.get_path(), self.PATH)","    def test_invalid_utf8(self):","        invalid_utf8 = '\\xf3'","        token = DataToken(self.NAME, invalid_utf8, self.PATH)","        self.assertRaises(UnicodeDecodeError, unicode, token)","        encoded_token = smart_unicode(token)","        self.assertEqual(encoded_token, u'\\xf3')"]}],"source":"\n\"\"\" test_token.py Copyright 2014 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import unittest import copy from w3af.core.data.dc.utils.token import DataToken class TestToken(unittest.TestCase): NAME='name' VALUE='value' PATH='path' PAYLOAD='payload' def test_basic(self): token=DataToken(self.NAME, self.VALUE, self.PATH) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy(self): original=DataToken(self.NAME, self.VALUE, self.PATH) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy_after_change(self): original=DataToken(self.NAME, self.VALUE, self.PATH) original.set_value(self.PAYLOAD) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.PAYLOAD) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) ","sourceWithComments":"\"\"\"\ntest_token.py\n\nCopyright 2014 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport unittest\nimport copy\n\nfrom w3af.core.data.dc.utils.token import DataToken\n\n\nclass TestToken(unittest.TestCase):\n    NAME = 'name'\n    VALUE = 'value'\n    PATH = 'path'\n    PAYLOAD = 'payload'\n\n    def test_basic(self):\n        token = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy_after_change(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n        original.set_value(self.PAYLOAD)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.PAYLOAD)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)"},"\/w3af\/core\/data\/misc\/encoding.py":{"changes":[{"diff":"\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n","add":1,"remove":1,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["    Return the unicode representation of 's'. Decodes bytestrings using"],"goodparts":["    Return the unicode representation of 's'. Decodes byte-strings using"]},{"diff":"\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","add":13,"remove":2,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["            s = unicode(s, encoding, errors)","            s = unicode(str(s), encoding, errors)"],"goodparts":["            try:","                s = unicode(s)","            except UnicodeDecodeError:","                s = str(s)","                s = smart_unicode(s, encoding=encoding, errors=errors,","                                  on_error_guess=on_error_guess)","            s = str(s)","            s = smart_unicode(s, encoding=encoding, errors=errors,","                              on_error_guess=on_error_guess)"]}],"source":"\n\"\"\" encoding.py Copyright 2012 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import codecs import urllib import chardet ESCAPED_CHAR='slash_escape_char' PERCENT_ENCODE='percent_encode' HTML_ENCODE='html_encode_char' def _return_html_encoded(encodingexc): \"\"\" :return: & \"\"\" st=encodingexc.start en=encodingexc.end hex_encoded=\"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en]) return unicode('& def _return_escaped_char(encodingexc): \"\"\" :return: \\\\xff when input is \\xff \"\"\" st=encodingexc.start en=encodingexc.end slash_x_XX=repr(encodingexc.object[st:en])[1:-1] return unicode(slash_x_XX), en def _percent_encode(encodingexc): if not isinstance(encodingexc, UnicodeEncodeError): raise encodingexc st=encodingexc.start en=encodingexc.end return( u'%s' %(urllib.quote(encodingexc.object[st:en].encode('utf8')),), en ) codecs.register_error(ESCAPED_CHAR, _return_escaped_char) codecs.register_error(PERCENT_ENCODE, _percent_encode) codecs.register_error(HTML_ENCODE, _return_html_encoded) def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True): \"\"\" Return the unicode representation of 's'. Decodes bytestrings using the 'encoding' codec. \"\"\" if isinstance(s, unicode): return s if isinstance(s, str): try: s=s.decode(encoding, errors) except UnicodeDecodeError: if not on_error_guess: raise guessed_encoding=chardet.detect(s)['encoding'] if guessed_encoding is None: s=s.decode(encoding, 'ignore') else: try: s=s.decode(guessed_encoding, errors) except UnicodeDecodeError: s=s.decode(encoding, 'ignore') else: if hasattr(s, '__unicode__'): s=unicode(s, encoding, errors) else: s=unicode(str(s), encoding, errors) return s def smart_str(s, encoding='utf-8', errors='strict'): \"\"\" Return a bytestring version of 's', encoded as specified in 'encoding'. \"\"\" if isinstance(s, unicode): s=s.encode(encoding, errors) elif not isinstance(s, str): s=str(s) return s def is_known_encoding(encoding): \"\"\" :return: True if the encoding name is known. >>> is_known_encoding( 'foo') False >>> is_known_encoding( 'utf-8') True \"\"\" try: codecs.lookup(encoding) return True except LookupError: return False ","sourceWithComments":"\"\"\"\nencoding.py\n\nCopyright 2012 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport codecs\nimport urllib\nimport chardet\n\n# Custom error handling schemes registration\nESCAPED_CHAR = 'slash_escape_char'\nPERCENT_ENCODE = 'percent_encode'\nHTML_ENCODE = 'html_encode_char'\n\n\ndef _return_html_encoded(encodingexc):\n    \"\"\"\n    :return: &#xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n    hex_encoded = \"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en])\n\n    return unicode('&#x' + hex_encoded), en\n\n\ndef _return_escaped_char(encodingexc):\n    \"\"\"\n    :return: \\\\xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n\n    slash_x_XX = repr(encodingexc.object[st:en])[1:-1]\n    return unicode(slash_x_XX), en\n\n\ndef _percent_encode(encodingexc):\n    if not isinstance(encodingexc, UnicodeEncodeError):\n        raise encodingexc\n\n    st = encodingexc.start\n    en = encodingexc.end\n\n    return (\n        u'%s' % (urllib.quote(encodingexc.object[st:en].encode('utf8')),),\n        en\n    )\n\ncodecs.register_error(ESCAPED_CHAR, _return_escaped_char)\ncodecs.register_error(PERCENT_ENCODE, _percent_encode)\ncodecs.register_error(HTML_ENCODE, _return_html_encoded)\n\n\ndef smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n    \"\"\"\n    Return the unicode representation of 's'. Decodes bytestrings using\n    the 'encoding' codec.\n    \"\"\"\n    if isinstance(s, unicode):\n        return s\n    \n    if isinstance(s, str):\n        try:\n            s = s.decode(encoding, errors)\n        except UnicodeDecodeError:\n            if not on_error_guess:\n                raise\n\n            guessed_encoding = chardet.detect(s)['encoding']\n\n            if guessed_encoding is None:\n                # Chardet failed to guess the encoding! This is really broken\n                s = s.decode(encoding, 'ignore')\n            else:\n                try:\n                    s = s.decode(guessed_encoding, errors)\n                except UnicodeDecodeError:\n                    s = s.decode(encoding, 'ignore')\n    else:\n        if hasattr(s, '__unicode__'):\n            s = unicode(s, encoding, errors)\n        else:\n            s = unicode(str(s), encoding, errors)\n\n    return s\n\n\ndef smart_str(s, encoding='utf-8', errors='strict'):\n    \"\"\"\n    Return a bytestring version of 's', encoded as specified in 'encoding'.\n    \"\"\"\n    if isinstance(s, unicode):\n        s = s.encode(encoding, errors)\n    elif not isinstance(s, str):\n        s = str(s)\n    return s\n\n\ndef is_known_encoding(encoding):\n    \"\"\"\n    :return: True if the encoding name is known.\n\n    >>> is_known_encoding( 'foo' )\n    False\n    >>> is_known_encoding( 'utf-8' )\n    True\n    \"\"\"\n    try:\n        codecs.lookup(encoding)\n        return True\n    except LookupError:\n        return False\n\n"}},"msg":"Better support for unicode(object) calls in smart_unicode function\nThis leads to a fix of Encoding issue in URL during eval.py injection #4423"}},"https:\/\/github.com\/satyamk1996\/VAPT":{"d92c861c687d66626b1e4a99f1af96906ca49a7a":{"url":"https:\/\/api.github.com\/repos\/satyamk1996\/VAPT\/commits\/d92c861c687d66626b1e4a99f1af96906ca49a7a","html_url":"https:\/\/github.com\/satyamk1996\/VAPT\/commit\/d92c861c687d66626b1e4a99f1af96906ca49a7a","sha":"d92c861c687d66626b1e4a99f1af96906ca49a7a","keyword":"eval injection fix","diff":"diff --git a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\nindex c288ec4f1a..6f8e5baa11 100644\n--- a\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n+++ b\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py\n@@ -23,6 +23,7 @@\n import copy\n \n from w3af.core.data.dc.utils.token import DataToken\n+from w3af.core.data.misc.encoding import smart_unicode\n \n \n class TestToken(unittest.TestCase):\n@@ -58,4 +59,13 @@ def test_copy_after_change(self):\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file\ndiff --git a\/w3af\/core\/data\/misc\/encoding.py b\/w3af\/core\/data\/misc\/encoding.py\nindex 353b453d0d..f65da333d2 100644\n--- a\/w3af\/core\/data\/misc\/encoding.py\n+++ b\/w3af\/core\/data\/misc\/encoding.py\n@@ -70,7 +70,7 @@ def _percent_encode(encodingexc):\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n@@ -95,9 +95,20 @@ def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","message":"","files":{"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py":{"changes":[{"diff":"\n         self.assertEqual(token.get_name(), self.NAME)\n         self.assertEqual(token.get_value(), self.PAYLOAD)\n         self.assertEqual(token.get_original_value(), self.VALUE)\n-        self.assertEqual(token.get_path(), self.PATH)\n\\ No newline at end of file\n+        self.assertEqual(token.get_path(), self.PATH)\n+\n+    def test_invalid_utf8(self):\n+        invalid_utf8 = '\\xf3'\n+        token = DataToken(self.NAME, invalid_utf8, self.PATH)\n+\n+        self.assertRaises(UnicodeDecodeError, unicode, token)\n+\n+        encoded_token = smart_unicode(token)\n+        self.assertEqual(encoded_token, u'\\xf3')\n\\ No newline at end of file","add":10,"remove":1,"filename":"\/w3af\/core\/data\/dc\/utils\/tests\/test_token.py","badparts":["        self.assertEqual(token.get_path(), self.PATH)"],"goodparts":["        self.assertEqual(token.get_path(), self.PATH)","    def test_invalid_utf8(self):","        invalid_utf8 = '\\xf3'","        token = DataToken(self.NAME, invalid_utf8, self.PATH)","        self.assertRaises(UnicodeDecodeError, unicode, token)","        encoded_token = smart_unicode(token)","        self.assertEqual(encoded_token, u'\\xf3')"]}],"source":"\n\"\"\" test_token.py Copyright 2014 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import unittest import copy from w3af.core.data.dc.utils.token import DataToken class TestToken(unittest.TestCase): NAME='name' VALUE='value' PATH='path' PAYLOAD='payload' def test_basic(self): token=DataToken(self.NAME, self.VALUE, self.PATH) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy(self): original=DataToken(self.NAME, self.VALUE, self.PATH) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.VALUE) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) def test_copy_after_change(self): original=DataToken(self.NAME, self.VALUE, self.PATH) original.set_value(self.PAYLOAD) token=copy.deepcopy(original) self.assertEqual(token.get_name(), self.NAME) self.assertEqual(token.get_value(), self.PAYLOAD) self.assertEqual(token.get_original_value(), self.VALUE) self.assertEqual(token.get_path(), self.PATH) ","sourceWithComments":"\"\"\"\ntest_token.py\n\nCopyright 2014 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport unittest\nimport copy\n\nfrom w3af.core.data.dc.utils.token import DataToken\n\n\nclass TestToken(unittest.TestCase):\n    NAME = 'name'\n    VALUE = 'value'\n    PATH = 'path'\n    PAYLOAD = 'payload'\n\n    def test_basic(self):\n        token = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.VALUE)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)\n\n    def test_copy_after_change(self):\n        original = DataToken(self.NAME, self.VALUE, self.PATH)\n        original.set_value(self.PAYLOAD)\n\n        token = copy.deepcopy(original)\n\n        self.assertEqual(token.get_name(), self.NAME)\n        self.assertEqual(token.get_value(), self.PAYLOAD)\n        self.assertEqual(token.get_original_value(), self.VALUE)\n        self.assertEqual(token.get_path(), self.PATH)"},"\/w3af\/core\/data\/misc\/encoding.py":{"changes":[{"diff":"\n \n def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n     \"\"\"\n-    Return the unicode representation of 's'. Decodes bytestrings using\n+    Return the unicode representation of 's'. Decodes byte-strings using\n     the 'encoding' codec.\n     \"\"\"\n     if isinstance(s, unicode):\n","add":1,"remove":1,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["    Return the unicode representation of 's'. Decodes bytestrings using"],"goodparts":["    Return the unicode representation of 's'. Decodes byte-strings using"]},{"diff":"\n                     s = s.decode(encoding, 'ignore')\n     else:\n         if hasattr(s, '__unicode__'):\n-            s = unicode(s, encoding, errors)\n+            try:\n+                # Read the pyar thread \"__unicode__ deberia tomar los mismos\n+                # parametros que unicode() ?\" to better understand why I can't\n+                # pass encoding and errors parameters here:\n+                s = unicode(s)\n+            except UnicodeDecodeError:\n+                # And why I'm doing it here:\n+                s = str(s)\n+                s = smart_unicode(s, encoding=encoding, errors=errors,\n+                                  on_error_guess=on_error_guess)\n         else:\n-            s = unicode(str(s), encoding, errors)\n+            s = str(s)\n+            s = smart_unicode(s, encoding=encoding, errors=errors,\n+                              on_error_guess=on_error_guess)\n \n     return s\n \n","add":13,"remove":2,"filename":"\/w3af\/core\/data\/misc\/encoding.py","badparts":["            s = unicode(s, encoding, errors)","            s = unicode(str(s), encoding, errors)"],"goodparts":["            try:","                s = unicode(s)","            except UnicodeDecodeError:","                s = str(s)","                s = smart_unicode(s, encoding=encoding, errors=errors,","                                  on_error_guess=on_error_guess)","            s = str(s)","            s = smart_unicode(s, encoding=encoding, errors=errors,","                              on_error_guess=on_error_guess)"]}],"source":"\n\"\"\" encoding.py Copyright 2012 Andres Riancho This file is part of w3af, http:\/\/w3af.org\/. w3af is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation version 2 of the License. w3af is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with w3af; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA \"\"\" import codecs import urllib import chardet ESCAPED_CHAR='slash_escape_char' PERCENT_ENCODE='percent_encode' HTML_ENCODE='html_encode_char' def _return_html_encoded(encodingexc): \"\"\" :return: & \"\"\" st=encodingexc.start en=encodingexc.end hex_encoded=\"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en]) return unicode('& def _return_escaped_char(encodingexc): \"\"\" :return: \\\\xff when input is \\xff \"\"\" st=encodingexc.start en=encodingexc.end slash_x_XX=repr(encodingexc.object[st:en])[1:-1] return unicode(slash_x_XX), en def _percent_encode(encodingexc): if not isinstance(encodingexc, UnicodeEncodeError): raise encodingexc st=encodingexc.start en=encodingexc.end return( u'%s' %(urllib.quote(encodingexc.object[st:en].encode('utf8')),), en ) codecs.register_error(ESCAPED_CHAR, _return_escaped_char) codecs.register_error(PERCENT_ENCODE, _percent_encode) codecs.register_error(HTML_ENCODE, _return_html_encoded) def smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True): \"\"\" Return the unicode representation of 's'. Decodes bytestrings using the 'encoding' codec. \"\"\" if isinstance(s, unicode): return s if isinstance(s, str): try: s=s.decode(encoding, errors) except UnicodeDecodeError: if not on_error_guess: raise guessed_encoding=chardet.detect(s)['encoding'] if guessed_encoding is None: s=s.decode(encoding, 'ignore') else: try: s=s.decode(guessed_encoding, errors) except UnicodeDecodeError: s=s.decode(encoding, 'ignore') else: if hasattr(s, '__unicode__'): s=unicode(s, encoding, errors) else: s=unicode(str(s), encoding, errors) return s def smart_str(s, encoding='utf-8', errors='strict'): \"\"\" Return a bytestring version of 's', encoded as specified in 'encoding'. \"\"\" if isinstance(s, unicode): s=s.encode(encoding, errors) elif not isinstance(s, str): s=str(s) return s def is_known_encoding(encoding): \"\"\" :return: True if the encoding name is known. >>> is_known_encoding( 'foo') False >>> is_known_encoding( 'utf-8') True \"\"\" try: codecs.lookup(encoding) return True except LookupError: return False ","sourceWithComments":"\"\"\"\nencoding.py\n\nCopyright 2012 Andres Riancho\n\nThis file is part of w3af, http:\/\/w3af.org\/ .\n\nw3af is free software; you can redistribute it and\/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation version 2 of the License.\n\nw3af is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with w3af; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n\"\"\"\nimport codecs\nimport urllib\nimport chardet\n\n# Custom error handling schemes registration\nESCAPED_CHAR = 'slash_escape_char'\nPERCENT_ENCODE = 'percent_encode'\nHTML_ENCODE = 'html_encode_char'\n\n\ndef _return_html_encoded(encodingexc):\n    \"\"\"\n    :return: &#xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n    hex_encoded = \"\".join(hex(ord(c))[2:] for c in encodingexc.object[st:en])\n\n    return unicode('&#x' + hex_encoded), en\n\n\ndef _return_escaped_char(encodingexc):\n    \"\"\"\n    :return: \\\\xff when input is \\xff\n    \"\"\"\n    st = encodingexc.start\n    en = encodingexc.end\n\n    slash_x_XX = repr(encodingexc.object[st:en])[1:-1]\n    return unicode(slash_x_XX), en\n\n\ndef _percent_encode(encodingexc):\n    if not isinstance(encodingexc, UnicodeEncodeError):\n        raise encodingexc\n\n    st = encodingexc.start\n    en = encodingexc.end\n\n    return (\n        u'%s' % (urllib.quote(encodingexc.object[st:en].encode('utf8')),),\n        en\n    )\n\ncodecs.register_error(ESCAPED_CHAR, _return_escaped_char)\ncodecs.register_error(PERCENT_ENCODE, _percent_encode)\ncodecs.register_error(HTML_ENCODE, _return_html_encoded)\n\n\ndef smart_unicode(s, encoding='utf8', errors='strict', on_error_guess=True):\n    \"\"\"\n    Return the unicode representation of 's'. Decodes bytestrings using\n    the 'encoding' codec.\n    \"\"\"\n    if isinstance(s, unicode):\n        return s\n    \n    if isinstance(s, str):\n        try:\n            s = s.decode(encoding, errors)\n        except UnicodeDecodeError:\n            if not on_error_guess:\n                raise\n\n            guessed_encoding = chardet.detect(s)['encoding']\n\n            if guessed_encoding is None:\n                # Chardet failed to guess the encoding! This is really broken\n                s = s.decode(encoding, 'ignore')\n            else:\n                try:\n                    s = s.decode(guessed_encoding, errors)\n                except UnicodeDecodeError:\n                    s = s.decode(encoding, 'ignore')\n    else:\n        if hasattr(s, '__unicode__'):\n            s = unicode(s, encoding, errors)\n        else:\n            s = unicode(str(s), encoding, errors)\n\n    return s\n\n\ndef smart_str(s, encoding='utf-8', errors='strict'):\n    \"\"\"\n    Return a bytestring version of 's', encoded as specified in 'encoding'.\n    \"\"\"\n    if isinstance(s, unicode):\n        s = s.encode(encoding, errors)\n    elif not isinstance(s, str):\n        s = str(s)\n    return s\n\n\ndef is_known_encoding(encoding):\n    \"\"\"\n    :return: True if the encoding name is known.\n\n    >>> is_known_encoding( 'foo' )\n    False\n    >>> is_known_encoding( 'utf-8' )\n    True\n    \"\"\"\n    try:\n        codecs.lookup(encoding)\n        return True\n    except LookupError:\n        return False\n\n"}},"msg":"Better support for unicode(object) calls in smart_unicode function\nThis leads to a fix of Encoding issue in URL during eval.py injection #4423"}},"https:\/\/github.com\/sonic-net\/sonic-buildimage":{"f1826586b01ffada91e99d93d4c2d28c148d8239":{"url":"https:\/\/api.github.com\/repos\/sonic-net\/sonic-buildimage\/commits\/f1826586b01ffada91e99d93d4c2d28c148d8239","html_url":"https:\/\/github.com\/sonic-net\/sonic-buildimage\/commit\/f1826586b01ffada91e99d93d4c2d28c148d8239","sha":"f1826586b01ffada91e99d93d4c2d28c148d8239","keyword":"eval injection malicious","diff":"diff --git a\/device\/common\/pddf\/plugins\/fanutil.py b\/device\/common\/pddf\/plugins\/fanutil.py\nindex f34c260035e..c2944e7b5b8 100755\n--- a\/device\/common\/pddf\/plugins\/fanutil.py\n+++ b\/device\/common\/pddf\/plugins\/fanutil.py\n@@ -11,6 +11,7 @@\n \n import os.path\n import sys\n+import ast\n sys.path.append('\/usr\/share\/sonic\/platform\/plugins')\n import pddfparse\n import json\n@@ -170,7 +171,7 @@ def set_speed(self, val):\n             print(\"Setting fan speed is not allowed !\")\n             return False\n         else:\n-            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n+            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n             pwm = duty_cycle_to_pwm(val)\n             print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n \n","message":"","files":{"\/device\/common\/pddf\/plugins\/fanutil.py":{"changes":[{"diff":"\n             print(\"Setting fan speed is not allowed !\")\n             return False\n         else:\n-            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n+            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n             pwm = duty_cycle_to_pwm(val)\n             print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n \n","add":1,"remove":1,"filename":"\/device\/common\/pddf\/plugins\/fanutil.py","badparts":["            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])"],"goodparts":["            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])"]}],"source":"\n import os.path import sys sys.path.append('\/usr\/share\/sonic\/platform\/plugins') import pddfparse import json try: from sonic_fan.fan_base import FanBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class FanUtil(FanBase): \"\"\"PDDF generic FAN util class\"\"\" def __init__(self): FanBase.__init__(self) global pddf_obj global plugin_data with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) +'\/..\/pddf\/pd-plugin.json')) as pd: plugin_data=json.load(pd) pddf_obj=pddfparse.PddfParse() self.platform=pddf_obj.get_platform() self.num_fans=(self.platform['num_fantrays'] * self.platform['num_fans_pertray']) def get_num_fans(self): return self.num_fans def get_presence(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return False attr_name=\"fan\" +str(idx) +\"_present\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr_name) if not output: return False mode=output['mode'] presence=output['status'].rstrip() vmap=plugin_data['FAN']['present'][mode]['valmap'] if presence in vmap: status=vmap[presence] else: status=False return status def get_status(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return False speed=self.get_speed(idx) status=True if(speed !=0) else False return status def get_direction(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return None attr=\"fan\" +str(idx) +\"_direction\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return None mode=output['mode'] val=output['status'] val=val.rstrip() vmap=plugin_data['FAN']['direction'][mode]['valmap'] if val in vmap: direction=vmap[val] else: direction=val return direction def get_directions(self): num_fan=self.get_num_fan() for i in range(1, num_fan+1): attr=\"fan\" +str(i) +\"_direction\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return None mode=output['mode'] val=output['status'] val=val.rstrip() vmap=plugin_data['FAN']['direction'][mode]['valmap'] direction=vmap[str(val)] print(\"FAN-%d direction is %s\" %(i, direction)) return 0 def get_speed(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return 0 attr=\"fan\" +str(idx) +\"_input\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return 0 val=output['status'].rstrip() if val.isalpha(): return 0 else: rpm_speed=int(float(val)) return rpm_speed def get_speeds(self): num_fan=self.get_num_fan() ret=\"FAN_INDEX\\t\\tRPM\\n\" for i in range(1, num_fan+1): attr1=\"fan\" +str(i) +\"_input\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr1) if not output: return \"\" val=output['status'].rstrip() if val.isalpha(): frpm=0 else: frpm=int(val) ret +=\"FAN-%d\\t\\t\\t%d\\n\" %(i, frpm) return ret def set_speed(self, val): if val < 0 or val > 100: print(\"Error: Invalid speed %d. Please provide a valid speed percentage\" % val) return False num_fan=self.num_fans if 'duty_cycle_to_pwm' not in plugin_data['FAN']: print(\"Setting fan speed is not allowed !\") return False else: duty_cycle_to_pwm=eval(plugin_data['FAN']['duty_cycle_to_pwm']) pwm=duty_cycle_to_pwm(val) print(\"New Speed: %d%% -PWM value to be set is %d\\n\" %(val, pwm)) for i in range(1, num_fan+1): attr=\"fan\" +str(i) +\"_pwm\" node=pddf_obj.get_path(\"FAN-CTRL\", attr) if node is None: return False try: with open(node, 'w') as f: f.write(str(pwm)) except IOError: return False return True def dump_sysfs(self): return pddf_obj.cli_dump_dsysfs('fan') def get_change_event(self): \"\"\" TODO: This function need to be implemented when decide to support monitoring FAN(fand) on this platform. \"\"\" raise NotImplementedError ","sourceWithComments":"# Sample pddf_fanutil file\n# All the supported FAN SysFS aattributes are\n#- fan<idx>_present\n#- fan<idx>_direction\n#- fan<idx>_input\n#- fan<idx>_pwm\n#- fan<idx>_fault\n# where idx is in the range [1-12]\n#\n\n\nimport os.path\nimport sys\nsys.path.append('\/usr\/share\/sonic\/platform\/plugins')\nimport pddfparse\nimport json\n\ntry:\n    from sonic_fan.fan_base import FanBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass FanUtil(FanBase):\n    \"\"\"PDDF generic FAN util class\"\"\"\n\n    def __init__(self):\n        FanBase.__init__(self)\n        global pddf_obj\n        global plugin_data\n        with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) + '\/..\/pddf\/pd-plugin.json')) as pd:\n            plugin_data = json.load(pd)\n\n        pddf_obj = pddfparse.PddfParse()\n        self.platform = pddf_obj.get_platform()\n\n        self.num_fans = (self.platform['num_fantrays'] * self.platform['num_fans_pertray'])\n\n    def get_num_fans(self):\n        return self.num_fans\n\n    def get_presence(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return False\n\n        attr_name = \"fan\" + str(idx) + \"_present\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr_name)\n        if not output:\n            return False\n\n        mode = output['mode']\n        presence = output['status'].rstrip()\n\n        vmap = plugin_data['FAN']['present'][mode]['valmap']\n\n        if presence in vmap:\n            status = vmap[presence]\n        else:\n            status = False\n\n        return status\n\n    def get_status(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return False\n\n        speed = self.get_speed(idx)\n        status = True if (speed != 0) else False\n        return status\n\n    def get_direction(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return None\n\n        attr = \"fan\" + str(idx) + \"_direction\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n        if not output:\n            return None\n\n        mode = output['mode']\n        val = output['status']\n\n        val = val.rstrip()\n        vmap = plugin_data['FAN']['direction'][mode]['valmap']\n\n        if val in vmap:\n            direction = vmap[val]\n        else:\n            direction = val\n\n        return direction\n\n    def get_directions(self):\n        num_fan = self.get_num_fan()\n\n        for i in range(1, num_fan+1):\n            attr = \"fan\" + str(i) + \"_direction\"\n            output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n            if not output:\n                return None\n\n            mode = output['mode']\n            val = output['status']\n\n            val = val.rstrip()\n            vmap = plugin_data['FAN']['direction'][mode]['valmap']\n\n            direction = vmap[str(val)]\n\n            print(\"FAN-%d direction is %s\" % (i, direction))\n\n        return 0\n\n    def get_speed(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return 0\n\n        attr = \"fan\" + str(idx) + \"_input\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n        if not output:\n            return 0\n\n        #mode = output['mode']\n        val = output['status'].rstrip()\n\n        if val.isalpha():\n            return 0\n        else:\n            rpm_speed = int(float(val))\n\n        return rpm_speed\n\n    def get_speeds(self):\n        num_fan = self.get_num_fan()\n        ret = \"FAN_INDEX\\t\\tRPM\\n\"\n\n        for i in range(1, num_fan+1):\n            attr1 = \"fan\" + str(i) + \"_input\"\n            output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr1)\n            if not output:\n                return \"\"\n\n            #mode = output['mode']\n            val = output['status'].rstrip()\n\n            if val.isalpha():\n                frpm = 0\n            else:\n                frpm = int(val)\n\n            ret += \"FAN-%d\\t\\t\\t%d\\n\" % (i, frpm)\n\n        return ret\n\n    def set_speed(self, val):\n        if val < 0 or val > 100:\n            print(\"Error: Invalid speed %d. Please provide a valid speed percentage\" % val)\n            return False\n\n        num_fan = self.num_fans\n        if 'duty_cycle_to_pwm' not in plugin_data['FAN']:\n            print(\"Setting fan speed is not allowed !\")\n            return False\n        else:\n            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n            pwm = duty_cycle_to_pwm(val)\n            print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n\n            for i in range(1, num_fan+1):\n                attr = \"fan\" + str(i) + \"_pwm\"\n                node = pddf_obj.get_path(\"FAN-CTRL\", attr)\n                if node is None:\n                    return False\n                try:\n                    with open(node, 'w') as f:\n                        f.write(str(pwm))\n                except IOError:\n                    return False\n\n        return True\n\n    def dump_sysfs(self):\n        return pddf_obj.cli_dump_dsysfs('fan')\n\n    def get_change_event(self):\n        \"\"\"\n        TODO: This function need to be implemented\n        when decide to support monitoring FAN(fand)\n        on this platform.\n        \"\"\"\n        raise NotImplementedError\n"}},"msg":"Replace eval (#12103)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\n#### Why I did it\r\n`eval()` - not secure against maliciously constructed input, can be dangerous if used to evaluate dynamic content. This may be a code injection vulnerability.\r\n#### How I did it\r\n`eval()` - use `literal_eval()`"}},"https:\/\/github.com\/QuantaSwitch\/sonic-buildimage-sw-1":{"f1826586b01ffada91e99d93d4c2d28c148d8239":{"url":"https:\/\/api.github.com\/repos\/QuantaSwitch\/sonic-buildimage-sw-1\/commits\/f1826586b01ffada91e99d93d4c2d28c148d8239","html_url":"https:\/\/github.com\/QuantaSwitch\/sonic-buildimage-sw-1\/commit\/f1826586b01ffada91e99d93d4c2d28c148d8239","sha":"f1826586b01ffada91e99d93d4c2d28c148d8239","keyword":"eval injection malicious","diff":"diff --git a\/device\/common\/pddf\/plugins\/fanutil.py b\/device\/common\/pddf\/plugins\/fanutil.py\nindex f34c26003..c2944e7b5 100755\n--- a\/device\/common\/pddf\/plugins\/fanutil.py\n+++ b\/device\/common\/pddf\/plugins\/fanutil.py\n@@ -11,6 +11,7 @@\n \n import os.path\n import sys\n+import ast\n sys.path.append('\/usr\/share\/sonic\/platform\/plugins')\n import pddfparse\n import json\n@@ -170,7 +171,7 @@ def set_speed(self, val):\n             print(\"Setting fan speed is not allowed !\")\n             return False\n         else:\n-            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n+            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n             pwm = duty_cycle_to_pwm(val)\n             print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n \n","message":"","files":{"\/device\/common\/pddf\/plugins\/fanutil.py":{"changes":[{"diff":"\n             print(\"Setting fan speed is not allowed !\")\n             return False\n         else:\n-            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n+            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n             pwm = duty_cycle_to_pwm(val)\n             print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n \n","add":1,"remove":1,"filename":"\/device\/common\/pddf\/plugins\/fanutil.py","badparts":["            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])"],"goodparts":["            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])"]}],"source":"\n import os.path import sys sys.path.append('\/usr\/share\/sonic\/platform\/plugins') import pddfparse import json try: from sonic_fan.fan_base import FanBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class FanUtil(FanBase): \"\"\"PDDF generic FAN util class\"\"\" def __init__(self): FanBase.__init__(self) global pddf_obj global plugin_data with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) +'\/..\/pddf\/pd-plugin.json')) as pd: plugin_data=json.load(pd) pddf_obj=pddfparse.PddfParse() self.platform=pddf_obj.get_platform() self.num_fans=(self.platform['num_fantrays'] * self.platform['num_fans_pertray']) def get_num_fans(self): return self.num_fans def get_presence(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return False attr_name=\"fan\" +str(idx) +\"_present\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr_name) if not output: return False mode=output['mode'] presence=output['status'].rstrip() vmap=plugin_data['FAN']['present'][mode]['valmap'] if presence in vmap: status=vmap[presence] else: status=False return status def get_status(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return False speed=self.get_speed(idx) status=True if(speed !=0) else False return status def get_direction(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return None attr=\"fan\" +str(idx) +\"_direction\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return None mode=output['mode'] val=output['status'] val=val.rstrip() vmap=plugin_data['FAN']['direction'][mode]['valmap'] if val in vmap: direction=vmap[val] else: direction=val return direction def get_directions(self): num_fan=self.get_num_fan() for i in range(1, num_fan+1): attr=\"fan\" +str(i) +\"_direction\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return None mode=output['mode'] val=output['status'] val=val.rstrip() vmap=plugin_data['FAN']['direction'][mode]['valmap'] direction=vmap[str(val)] print(\"FAN-%d direction is %s\" %(i, direction)) return 0 def get_speed(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return 0 attr=\"fan\" +str(idx) +\"_input\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return 0 val=output['status'].rstrip() if val.isalpha(): return 0 else: rpm_speed=int(float(val)) return rpm_speed def get_speeds(self): num_fan=self.get_num_fan() ret=\"FAN_INDEX\\t\\tRPM\\n\" for i in range(1, num_fan+1): attr1=\"fan\" +str(i) +\"_input\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr1) if not output: return \"\" val=output['status'].rstrip() if val.isalpha(): frpm=0 else: frpm=int(val) ret +=\"FAN-%d\\t\\t\\t%d\\n\" %(i, frpm) return ret def set_speed(self, val): if val < 0 or val > 100: print(\"Error: Invalid speed %d. Please provide a valid speed percentage\" % val) return False num_fan=self.num_fans if 'duty_cycle_to_pwm' not in plugin_data['FAN']: print(\"Setting fan speed is not allowed !\") return False else: duty_cycle_to_pwm=eval(plugin_data['FAN']['duty_cycle_to_pwm']) pwm=duty_cycle_to_pwm(val) print(\"New Speed: %d%% -PWM value to be set is %d\\n\" %(val, pwm)) for i in range(1, num_fan+1): attr=\"fan\" +str(i) +\"_pwm\" node=pddf_obj.get_path(\"FAN-CTRL\", attr) if node is None: return False try: with open(node, 'w') as f: f.write(str(pwm)) except IOError: return False return True def dump_sysfs(self): return pddf_obj.cli_dump_dsysfs('fan') def get_change_event(self): \"\"\" TODO: This function need to be implemented when decide to support monitoring FAN(fand) on this platform. \"\"\" raise NotImplementedError ","sourceWithComments":"# Sample pddf_fanutil file\n# All the supported FAN SysFS aattributes are\n#- fan<idx>_present\n#- fan<idx>_direction\n#- fan<idx>_input\n#- fan<idx>_pwm\n#- fan<idx>_fault\n# where idx is in the range [1-12]\n#\n\n\nimport os.path\nimport sys\nsys.path.append('\/usr\/share\/sonic\/platform\/plugins')\nimport pddfparse\nimport json\n\ntry:\n    from sonic_fan.fan_base import FanBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass FanUtil(FanBase):\n    \"\"\"PDDF generic FAN util class\"\"\"\n\n    def __init__(self):\n        FanBase.__init__(self)\n        global pddf_obj\n        global plugin_data\n        with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) + '\/..\/pddf\/pd-plugin.json')) as pd:\n            plugin_data = json.load(pd)\n\n        pddf_obj = pddfparse.PddfParse()\n        self.platform = pddf_obj.get_platform()\n\n        self.num_fans = (self.platform['num_fantrays'] * self.platform['num_fans_pertray'])\n\n    def get_num_fans(self):\n        return self.num_fans\n\n    def get_presence(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return False\n\n        attr_name = \"fan\" + str(idx) + \"_present\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr_name)\n        if not output:\n            return False\n\n        mode = output['mode']\n        presence = output['status'].rstrip()\n\n        vmap = plugin_data['FAN']['present'][mode]['valmap']\n\n        if presence in vmap:\n            status = vmap[presence]\n        else:\n            status = False\n\n        return status\n\n    def get_status(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return False\n\n        speed = self.get_speed(idx)\n        status = True if (speed != 0) else False\n        return status\n\n    def get_direction(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return None\n\n        attr = \"fan\" + str(idx) + \"_direction\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n        if not output:\n            return None\n\n        mode = output['mode']\n        val = output['status']\n\n        val = val.rstrip()\n        vmap = plugin_data['FAN']['direction'][mode]['valmap']\n\n        if val in vmap:\n            direction = vmap[val]\n        else:\n            direction = val\n\n        return direction\n\n    def get_directions(self):\n        num_fan = self.get_num_fan()\n\n        for i in range(1, num_fan+1):\n            attr = \"fan\" + str(i) + \"_direction\"\n            output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n            if not output:\n                return None\n\n            mode = output['mode']\n            val = output['status']\n\n            val = val.rstrip()\n            vmap = plugin_data['FAN']['direction'][mode]['valmap']\n\n            direction = vmap[str(val)]\n\n            print(\"FAN-%d direction is %s\" % (i, direction))\n\n        return 0\n\n    def get_speed(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return 0\n\n        attr = \"fan\" + str(idx) + \"_input\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n        if not output:\n            return 0\n\n        #mode = output['mode']\n        val = output['status'].rstrip()\n\n        if val.isalpha():\n            return 0\n        else:\n            rpm_speed = int(float(val))\n\n        return rpm_speed\n\n    def get_speeds(self):\n        num_fan = self.get_num_fan()\n        ret = \"FAN_INDEX\\t\\tRPM\\n\"\n\n        for i in range(1, num_fan+1):\n            attr1 = \"fan\" + str(i) + \"_input\"\n            output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr1)\n            if not output:\n                return \"\"\n\n            #mode = output['mode']\n            val = output['status'].rstrip()\n\n            if val.isalpha():\n                frpm = 0\n            else:\n                frpm = int(val)\n\n            ret += \"FAN-%d\\t\\t\\t%d\\n\" % (i, frpm)\n\n        return ret\n\n    def set_speed(self, val):\n        if val < 0 or val > 100:\n            print(\"Error: Invalid speed %d. Please provide a valid speed percentage\" % val)\n            return False\n\n        num_fan = self.num_fans\n        if 'duty_cycle_to_pwm' not in plugin_data['FAN']:\n            print(\"Setting fan speed is not allowed !\")\n            return False\n        else:\n            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n            pwm = duty_cycle_to_pwm(val)\n            print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n\n            for i in range(1, num_fan+1):\n                attr = \"fan\" + str(i) + \"_pwm\"\n                node = pddf_obj.get_path(\"FAN-CTRL\", attr)\n                if node is None:\n                    return False\n                try:\n                    with open(node, 'w') as f:\n                        f.write(str(pwm))\n                except IOError:\n                    return False\n\n        return True\n\n    def dump_sysfs(self):\n        return pddf_obj.cli_dump_dsysfs('fan')\n\n    def get_change_event(self):\n        \"\"\"\n        TODO: This function need to be implemented\n        when decide to support monitoring FAN(fand)\n        on this platform.\n        \"\"\"\n        raise NotImplementedError\n"}},"msg":"Replace eval (#12103)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\n#### Why I did it\r\n`eval()` - not secure against maliciously constructed input, can be dangerous if used to evaluate dynamic content. This may be a code injection vulnerability.\r\n#### How I did it\r\n`eval()` - use `literal_eval()`"}},"https:\/\/github.com\/tomatoling\/sonic-tomato":{"f1826586b01ffada91e99d93d4c2d28c148d8239":{"url":"https:\/\/api.github.com\/repos\/tomatoling\/sonic-tomato\/commits\/f1826586b01ffada91e99d93d4c2d28c148d8239","html_url":"https:\/\/github.com\/tomatoling\/sonic-tomato\/commit\/f1826586b01ffada91e99d93d4c2d28c148d8239","sha":"f1826586b01ffada91e99d93d4c2d28c148d8239","keyword":"eval injection malicious","diff":"diff --git a\/device\/common\/pddf\/plugins\/fanutil.py b\/device\/common\/pddf\/plugins\/fanutil.py\nindex f34c26003..c2944e7b5 100755\n--- a\/device\/common\/pddf\/plugins\/fanutil.py\n+++ b\/device\/common\/pddf\/plugins\/fanutil.py\n@@ -11,6 +11,7 @@\n \n import os.path\n import sys\n+import ast\n sys.path.append('\/usr\/share\/sonic\/platform\/plugins')\n import pddfparse\n import json\n@@ -170,7 +171,7 @@ def set_speed(self, val):\n             print(\"Setting fan speed is not allowed !\")\n             return False\n         else:\n-            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n+            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n             pwm = duty_cycle_to_pwm(val)\n             print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n \n","message":"","files":{"\/device\/common\/pddf\/plugins\/fanutil.py":{"changes":[{"diff":"\n             print(\"Setting fan speed is not allowed !\")\n             return False\n         else:\n-            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n+            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n             pwm = duty_cycle_to_pwm(val)\n             print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n \n","add":1,"remove":1,"filename":"\/device\/common\/pddf\/plugins\/fanutil.py","badparts":["            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])"],"goodparts":["            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])"]}],"source":"\n import os.path import sys sys.path.append('\/usr\/share\/sonic\/platform\/plugins') import pddfparse import json try: from sonic_fan.fan_base import FanBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class FanUtil(FanBase): \"\"\"PDDF generic FAN util class\"\"\" def __init__(self): FanBase.__init__(self) global pddf_obj global plugin_data with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) +'\/..\/pddf\/pd-plugin.json')) as pd: plugin_data=json.load(pd) pddf_obj=pddfparse.PddfParse() self.platform=pddf_obj.get_platform() self.num_fans=(self.platform['num_fantrays'] * self.platform['num_fans_pertray']) def get_num_fans(self): return self.num_fans def get_presence(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return False attr_name=\"fan\" +str(idx) +\"_present\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr_name) if not output: return False mode=output['mode'] presence=output['status'].rstrip() vmap=plugin_data['FAN']['present'][mode]['valmap'] if presence in vmap: status=vmap[presence] else: status=False return status def get_status(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return False speed=self.get_speed(idx) status=True if(speed !=0) else False return status def get_direction(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return None attr=\"fan\" +str(idx) +\"_direction\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return None mode=output['mode'] val=output['status'] val=val.rstrip() vmap=plugin_data['FAN']['direction'][mode]['valmap'] if val in vmap: direction=vmap[val] else: direction=val return direction def get_directions(self): num_fan=self.get_num_fan() for i in range(1, num_fan+1): attr=\"fan\" +str(i) +\"_direction\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return None mode=output['mode'] val=output['status'] val=val.rstrip() vmap=plugin_data['FAN']['direction'][mode]['valmap'] direction=vmap[str(val)] print(\"FAN-%d direction is %s\" %(i, direction)) return 0 def get_speed(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return 0 attr=\"fan\" +str(idx) +\"_input\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return 0 val=output['status'].rstrip() if val.isalpha(): return 0 else: rpm_speed=int(float(val)) return rpm_speed def get_speeds(self): num_fan=self.get_num_fan() ret=\"FAN_INDEX\\t\\tRPM\\n\" for i in range(1, num_fan+1): attr1=\"fan\" +str(i) +\"_input\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr1) if not output: return \"\" val=output['status'].rstrip() if val.isalpha(): frpm=0 else: frpm=int(val) ret +=\"FAN-%d\\t\\t\\t%d\\n\" %(i, frpm) return ret def set_speed(self, val): if val < 0 or val > 100: print(\"Error: Invalid speed %d. Please provide a valid speed percentage\" % val) return False num_fan=self.num_fans if 'duty_cycle_to_pwm' not in plugin_data['FAN']: print(\"Setting fan speed is not allowed !\") return False else: duty_cycle_to_pwm=eval(plugin_data['FAN']['duty_cycle_to_pwm']) pwm=duty_cycle_to_pwm(val) print(\"New Speed: %d%% -PWM value to be set is %d\\n\" %(val, pwm)) for i in range(1, num_fan+1): attr=\"fan\" +str(i) +\"_pwm\" node=pddf_obj.get_path(\"FAN-CTRL\", attr) if node is None: return False try: with open(node, 'w') as f: f.write(str(pwm)) except IOError: return False return True def dump_sysfs(self): return pddf_obj.cli_dump_dsysfs('fan') def get_change_event(self): \"\"\" TODO: This function need to be implemented when decide to support monitoring FAN(fand) on this platform. \"\"\" raise NotImplementedError ","sourceWithComments":"# Sample pddf_fanutil file\n# All the supported FAN SysFS aattributes are\n#- fan<idx>_present\n#- fan<idx>_direction\n#- fan<idx>_input\n#- fan<idx>_pwm\n#- fan<idx>_fault\n# where idx is in the range [1-12]\n#\n\n\nimport os.path\nimport sys\nsys.path.append('\/usr\/share\/sonic\/platform\/plugins')\nimport pddfparse\nimport json\n\ntry:\n    from sonic_fan.fan_base import FanBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass FanUtil(FanBase):\n    \"\"\"PDDF generic FAN util class\"\"\"\n\n    def __init__(self):\n        FanBase.__init__(self)\n        global pddf_obj\n        global plugin_data\n        with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) + '\/..\/pddf\/pd-plugin.json')) as pd:\n            plugin_data = json.load(pd)\n\n        pddf_obj = pddfparse.PddfParse()\n        self.platform = pddf_obj.get_platform()\n\n        self.num_fans = (self.platform['num_fantrays'] * self.platform['num_fans_pertray'])\n\n    def get_num_fans(self):\n        return self.num_fans\n\n    def get_presence(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return False\n\n        attr_name = \"fan\" + str(idx) + \"_present\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr_name)\n        if not output:\n            return False\n\n        mode = output['mode']\n        presence = output['status'].rstrip()\n\n        vmap = plugin_data['FAN']['present'][mode]['valmap']\n\n        if presence in vmap:\n            status = vmap[presence]\n        else:\n            status = False\n\n        return status\n\n    def get_status(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return False\n\n        speed = self.get_speed(idx)\n        status = True if (speed != 0) else False\n        return status\n\n    def get_direction(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return None\n\n        attr = \"fan\" + str(idx) + \"_direction\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n        if not output:\n            return None\n\n        mode = output['mode']\n        val = output['status']\n\n        val = val.rstrip()\n        vmap = plugin_data['FAN']['direction'][mode]['valmap']\n\n        if val in vmap:\n            direction = vmap[val]\n        else:\n            direction = val\n\n        return direction\n\n    def get_directions(self):\n        num_fan = self.get_num_fan()\n\n        for i in range(1, num_fan+1):\n            attr = \"fan\" + str(i) + \"_direction\"\n            output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n            if not output:\n                return None\n\n            mode = output['mode']\n            val = output['status']\n\n            val = val.rstrip()\n            vmap = plugin_data['FAN']['direction'][mode]['valmap']\n\n            direction = vmap[str(val)]\n\n            print(\"FAN-%d direction is %s\" % (i, direction))\n\n        return 0\n\n    def get_speed(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return 0\n\n        attr = \"fan\" + str(idx) + \"_input\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n        if not output:\n            return 0\n\n        #mode = output['mode']\n        val = output['status'].rstrip()\n\n        if val.isalpha():\n            return 0\n        else:\n            rpm_speed = int(float(val))\n\n        return rpm_speed\n\n    def get_speeds(self):\n        num_fan = self.get_num_fan()\n        ret = \"FAN_INDEX\\t\\tRPM\\n\"\n\n        for i in range(1, num_fan+1):\n            attr1 = \"fan\" + str(i) + \"_input\"\n            output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr1)\n            if not output:\n                return \"\"\n\n            #mode = output['mode']\n            val = output['status'].rstrip()\n\n            if val.isalpha():\n                frpm = 0\n            else:\n                frpm = int(val)\n\n            ret += \"FAN-%d\\t\\t\\t%d\\n\" % (i, frpm)\n\n        return ret\n\n    def set_speed(self, val):\n        if val < 0 or val > 100:\n            print(\"Error: Invalid speed %d. Please provide a valid speed percentage\" % val)\n            return False\n\n        num_fan = self.num_fans\n        if 'duty_cycle_to_pwm' not in plugin_data['FAN']:\n            print(\"Setting fan speed is not allowed !\")\n            return False\n        else:\n            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n            pwm = duty_cycle_to_pwm(val)\n            print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n\n            for i in range(1, num_fan+1):\n                attr = \"fan\" + str(i) + \"_pwm\"\n                node = pddf_obj.get_path(\"FAN-CTRL\", attr)\n                if node is None:\n                    return False\n                try:\n                    with open(node, 'w') as f:\n                        f.write(str(pwm))\n                except IOError:\n                    return False\n\n        return True\n\n    def dump_sysfs(self):\n        return pddf_obj.cli_dump_dsysfs('fan')\n\n    def get_change_event(self):\n        \"\"\"\n        TODO: This function need to be implemented\n        when decide to support monitoring FAN(fand)\n        on this platform.\n        \"\"\"\n        raise NotImplementedError\n"}},"msg":"Replace eval (#12103)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\n#### Why I did it\r\n`eval()` - not secure against maliciously constructed input, can be dangerous if used to evaluate dynamic content. This may be a code injection vulnerability.\r\n#### How I did it\r\n`eval()` - use `literal_eval()`"}},"https:\/\/github.com\/SelvaSupermicro\/sonic-buildimage-draft":{"f1826586b01ffada91e99d93d4c2d28c148d8239":{"url":"https:\/\/api.github.com\/repos\/SelvaSupermicro\/sonic-buildimage-draft\/commits\/f1826586b01ffada91e99d93d4c2d28c148d8239","html_url":"https:\/\/github.com\/SelvaSupermicro\/sonic-buildimage-draft\/commit\/f1826586b01ffada91e99d93d4c2d28c148d8239","sha":"f1826586b01ffada91e99d93d4c2d28c148d8239","keyword":"eval injection malicious","diff":"diff --git a\/device\/common\/pddf\/plugins\/fanutil.py b\/device\/common\/pddf\/plugins\/fanutil.py\nindex f34c26003..c2944e7b5 100755\n--- a\/device\/common\/pddf\/plugins\/fanutil.py\n+++ b\/device\/common\/pddf\/plugins\/fanutil.py\n@@ -11,6 +11,7 @@\n \n import os.path\n import sys\n+import ast\n sys.path.append('\/usr\/share\/sonic\/platform\/plugins')\n import pddfparse\n import json\n@@ -170,7 +171,7 @@ def set_speed(self, val):\n             print(\"Setting fan speed is not allowed !\")\n             return False\n         else:\n-            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n+            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n             pwm = duty_cycle_to_pwm(val)\n             print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n \n","message":"","files":{"\/device\/common\/pddf\/plugins\/fanutil.py":{"changes":[{"diff":"\n             print(\"Setting fan speed is not allowed !\")\n             return False\n         else:\n-            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n+            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n             pwm = duty_cycle_to_pwm(val)\n             print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n \n","add":1,"remove":1,"filename":"\/device\/common\/pddf\/plugins\/fanutil.py","badparts":["            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])"],"goodparts":["            duty_cycle_to_pwm = ast.literal_eval(plugin_data['FAN']['duty_cycle_to_pwm'])"]}],"source":"\n import os.path import sys sys.path.append('\/usr\/share\/sonic\/platform\/plugins') import pddfparse import json try: from sonic_fan.fan_base import FanBase except ImportError as e: raise ImportError(str(e) +\"-required module not found\") class FanUtil(FanBase): \"\"\"PDDF generic FAN util class\"\"\" def __init__(self): FanBase.__init__(self) global pddf_obj global plugin_data with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) +'\/..\/pddf\/pd-plugin.json')) as pd: plugin_data=json.load(pd) pddf_obj=pddfparse.PddfParse() self.platform=pddf_obj.get_platform() self.num_fans=(self.platform['num_fantrays'] * self.platform['num_fans_pertray']) def get_num_fans(self): return self.num_fans def get_presence(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return False attr_name=\"fan\" +str(idx) +\"_present\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr_name) if not output: return False mode=output['mode'] presence=output['status'].rstrip() vmap=plugin_data['FAN']['present'][mode]['valmap'] if presence in vmap: status=vmap[presence] else: status=False return status def get_status(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return False speed=self.get_speed(idx) status=True if(speed !=0) else False return status def get_direction(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return None attr=\"fan\" +str(idx) +\"_direction\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return None mode=output['mode'] val=output['status'] val=val.rstrip() vmap=plugin_data['FAN']['direction'][mode]['valmap'] if val in vmap: direction=vmap[val] else: direction=val return direction def get_directions(self): num_fan=self.get_num_fan() for i in range(1, num_fan+1): attr=\"fan\" +str(i) +\"_direction\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return None mode=output['mode'] val=output['status'] val=val.rstrip() vmap=plugin_data['FAN']['direction'][mode]['valmap'] direction=vmap[str(val)] print(\"FAN-%d direction is %s\" %(i, direction)) return 0 def get_speed(self, idx): if idx < 1 or idx > self.num_fans: print(\"Invalid fan index %d\\n\" % idx) return 0 attr=\"fan\" +str(idx) +\"_input\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr) if not output: return 0 val=output['status'].rstrip() if val.isalpha(): return 0 else: rpm_speed=int(float(val)) return rpm_speed def get_speeds(self): num_fan=self.get_num_fan() ret=\"FAN_INDEX\\t\\tRPM\\n\" for i in range(1, num_fan+1): attr1=\"fan\" +str(i) +\"_input\" output=pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr1) if not output: return \"\" val=output['status'].rstrip() if val.isalpha(): frpm=0 else: frpm=int(val) ret +=\"FAN-%d\\t\\t\\t%d\\n\" %(i, frpm) return ret def set_speed(self, val): if val < 0 or val > 100: print(\"Error: Invalid speed %d. Please provide a valid speed percentage\" % val) return False num_fan=self.num_fans if 'duty_cycle_to_pwm' not in plugin_data['FAN']: print(\"Setting fan speed is not allowed !\") return False else: duty_cycle_to_pwm=eval(plugin_data['FAN']['duty_cycle_to_pwm']) pwm=duty_cycle_to_pwm(val) print(\"New Speed: %d%% -PWM value to be set is %d\\n\" %(val, pwm)) for i in range(1, num_fan+1): attr=\"fan\" +str(i) +\"_pwm\" node=pddf_obj.get_path(\"FAN-CTRL\", attr) if node is None: return False try: with open(node, 'w') as f: f.write(str(pwm)) except IOError: return False return True def dump_sysfs(self): return pddf_obj.cli_dump_dsysfs('fan') def get_change_event(self): \"\"\" TODO: This function need to be implemented when decide to support monitoring FAN(fand) on this platform. \"\"\" raise NotImplementedError ","sourceWithComments":"# Sample pddf_fanutil file\n# All the supported FAN SysFS aattributes are\n#- fan<idx>_present\n#- fan<idx>_direction\n#- fan<idx>_input\n#- fan<idx>_pwm\n#- fan<idx>_fault\n# where idx is in the range [1-12]\n#\n\n\nimport os.path\nimport sys\nsys.path.append('\/usr\/share\/sonic\/platform\/plugins')\nimport pddfparse\nimport json\n\ntry:\n    from sonic_fan.fan_base import FanBase\nexcept ImportError as e:\n    raise ImportError(str(e) + \"- required module not found\")\n\n\nclass FanUtil(FanBase):\n    \"\"\"PDDF generic FAN util class\"\"\"\n\n    def __init__(self):\n        FanBase.__init__(self)\n        global pddf_obj\n        global plugin_data\n        with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) + '\/..\/pddf\/pd-plugin.json')) as pd:\n            plugin_data = json.load(pd)\n\n        pddf_obj = pddfparse.PddfParse()\n        self.platform = pddf_obj.get_platform()\n\n        self.num_fans = (self.platform['num_fantrays'] * self.platform['num_fans_pertray'])\n\n    def get_num_fans(self):\n        return self.num_fans\n\n    def get_presence(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return False\n\n        attr_name = \"fan\" + str(idx) + \"_present\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr_name)\n        if not output:\n            return False\n\n        mode = output['mode']\n        presence = output['status'].rstrip()\n\n        vmap = plugin_data['FAN']['present'][mode]['valmap']\n\n        if presence in vmap:\n            status = vmap[presence]\n        else:\n            status = False\n\n        return status\n\n    def get_status(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return False\n\n        speed = self.get_speed(idx)\n        status = True if (speed != 0) else False\n        return status\n\n    def get_direction(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return None\n\n        attr = \"fan\" + str(idx) + \"_direction\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n        if not output:\n            return None\n\n        mode = output['mode']\n        val = output['status']\n\n        val = val.rstrip()\n        vmap = plugin_data['FAN']['direction'][mode]['valmap']\n\n        if val in vmap:\n            direction = vmap[val]\n        else:\n            direction = val\n\n        return direction\n\n    def get_directions(self):\n        num_fan = self.get_num_fan()\n\n        for i in range(1, num_fan+1):\n            attr = \"fan\" + str(i) + \"_direction\"\n            output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n            if not output:\n                return None\n\n            mode = output['mode']\n            val = output['status']\n\n            val = val.rstrip()\n            vmap = plugin_data['FAN']['direction'][mode]['valmap']\n\n            direction = vmap[str(val)]\n\n            print(\"FAN-%d direction is %s\" % (i, direction))\n\n        return 0\n\n    def get_speed(self, idx):\n        # 1 based fan index\n        if idx < 1 or idx > self.num_fans:\n            print(\"Invalid fan index %d\\n\" % idx)\n            return 0\n\n        attr = \"fan\" + str(idx) + \"_input\"\n        output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr)\n        if not output:\n            return 0\n\n        #mode = output['mode']\n        val = output['status'].rstrip()\n\n        if val.isalpha():\n            return 0\n        else:\n            rpm_speed = int(float(val))\n\n        return rpm_speed\n\n    def get_speeds(self):\n        num_fan = self.get_num_fan()\n        ret = \"FAN_INDEX\\t\\tRPM\\n\"\n\n        for i in range(1, num_fan+1):\n            attr1 = \"fan\" + str(i) + \"_input\"\n            output = pddf_obj.get_attr_name_output(\"FAN-CTRL\", attr1)\n            if not output:\n                return \"\"\n\n            #mode = output['mode']\n            val = output['status'].rstrip()\n\n            if val.isalpha():\n                frpm = 0\n            else:\n                frpm = int(val)\n\n            ret += \"FAN-%d\\t\\t\\t%d\\n\" % (i, frpm)\n\n        return ret\n\n    def set_speed(self, val):\n        if val < 0 or val > 100:\n            print(\"Error: Invalid speed %d. Please provide a valid speed percentage\" % val)\n            return False\n\n        num_fan = self.num_fans\n        if 'duty_cycle_to_pwm' not in plugin_data['FAN']:\n            print(\"Setting fan speed is not allowed !\")\n            return False\n        else:\n            duty_cycle_to_pwm = eval(plugin_data['FAN']['duty_cycle_to_pwm'])\n            pwm = duty_cycle_to_pwm(val)\n            print(\"New Speed: %d%% - PWM value to be set is %d\\n\" % (val, pwm))\n\n            for i in range(1, num_fan+1):\n                attr = \"fan\" + str(i) + \"_pwm\"\n                node = pddf_obj.get_path(\"FAN-CTRL\", attr)\n                if node is None:\n                    return False\n                try:\n                    with open(node, 'w') as f:\n                        f.write(str(pwm))\n                except IOError:\n                    return False\n\n        return True\n\n    def dump_sysfs(self):\n        return pddf_obj.cli_dump_dsysfs('fan')\n\n    def get_change_event(self):\n        \"\"\"\n        TODO: This function need to be implemented\n        when decide to support monitoring FAN(fand)\n        on this platform.\n        \"\"\"\n        raise NotImplementedError\n"}},"msg":"Replace eval (#12103)\n\nSigned-off-by: maipbui <maibui@microsoft.com>\r\n#### Why I did it\r\n`eval()` - not secure against maliciously constructed input, can be dangerous if used to evaluate dynamic content. This may be a code injection vulnerability.\r\n#### How I did it\r\n`eval()` - use `literal_eval()`"}},"https:\/\/github.com\/suhyunyoon\/wsss_framework":{"bc2793506f8663c7a4e9612d28f50cc9bf1cf0f3":{"url":"https:\/\/api.github.com\/repos\/suhyunyoon\/wsss_framework\/commits\/bc2793506f8663c7a4e9612d28f50cc9bf1cf0f3","html_url":"https:\/\/github.com\/suhyunyoon\/wsss_framework\/commit\/bc2793506f8663c7a4e9612d28f50cc9bf1cf0f3","message":"Add resnet optimizer and prevent eval injection","sha":"bc2793506f8663c7a4e9612d28f50cc9bf1cf0f3","keyword":"eval injection prevent","diff":"diff --git a\/models\/resnet.py b\/models\/resnet.py\nindex 99bcd43..52efaba 100644\n--- a\/models\/resnet.py\n+++ b\/models\/resnet.py\n@@ -279,6 +279,17 @@ def on_load_checkpoint(self, state_dict, strict=True) -> None:\n             state_dict.pop(k, None)\n \n         self.load_state_dict(state_dict, strict=False)\n+    \n+    def get_parameter_groups(self):\n+        groups = ([], [])\n+\n+        for name, value in self.named_parameters():\n+            if 'fc' in name:\n+                groups[1].append(value)\n+            else:\n+                groups[0].append(value)\n+\n+        return groups\n \n \n def _resnet(\ndiff --git a\/utils\/optims.py b\/utils\/optims.py\nindex 4681113..f2c4508 100644\n--- a\/utils\/optims.py\n+++ b\/utils\/optims.py\n@@ -43,15 +43,19 @@ def get_finetune_optimzier(cfg, model):\n     # Load Optimizer method\n     if hasattr(optim, cfg['optimizer']['name']):\n         optim_method = getattr(optim, cfg['optimizer']['name'])\n-    # scratch method\n-    else:\n-        optim_method = eval(optim, cfg['optimizer']['name'])\n+    # scratch method (prevent injection)\n+    elif '.' not in cfg['optimizer']['name'] and \\\n+         '(' not in cfg['optimizer']['name'] and \\\n+         ' ' not in cfg['optimizer']['name']:\n+        optim_method = eval(cfg['optimizer']['name'])\n \n     # Load Scheduler method\n     if 'scheduler' in cfg:\n         if hasattr(lr_scheduler, cfg['scheduler']['name']):\n             scheduler_method = getattr(lr_scheduler, cfg['scheduler']['name'])\n-        else:\n+        elif '.' not in cfg['optimizer']['name'] and \\\n+            '(' not in cfg['optimizer']['name'] and \\\n+            ' ' not in cfg['optimizer']['name']:\n             scheduler_method = eval(cfg['scheduler']['name'])\n     else:\n         scheduler_method = None\n@@ -68,7 +72,14 @@ def get_finetune_optimzier(cfg, model):\n \n     # ResNets\n     elif ('resnet' in cfg['network']) or ('resnext' in cfg['network']) or ('res2net' in cfg['network']):\n-        parameters = model.parameters()\n+        if hasattr(model, 'get_parameter_groups'):\n+            param_groups = model.get_parameter_groups()\n+\n+            parameters = [\n+                {'params': param_groups[0], 'lr': 1 * cfg['optimizer']['kwargs']['lr'], 'weight_decay': cfg['optimizer']['kwargs']['weight_decay']},\n+                {'params': param_groups[1], 'lr': 10 * cfg['optimizer']['kwargs']['lr'], 'weight_decay': cfg['optimizer']['kwargs']['weight_decay']}]\n+        else:\n+            parameters = model.parameters()\n \n     # Dino_ResNet\n     elif cfg['network'] == 'dino_resnet50':\n","files":{"\/utils\/optims.py":{"changes":[{"diff":"\n     # Load Optimizer method\n     if hasattr(optim, cfg['optimizer']['name']):\n         optim_method = getattr(optim, cfg['optimizer']['name'])\n-    # scratch method\n-    else:\n-        optim_method = eval(optim, cfg['optimizer']['name'])\n+    # scratch method (prevent injection)\n+    elif '.' not in cfg['optimizer']['name'] and \\\n+         '(' not in cfg['optimizer']['name'] and \\\n+         ' ' not in cfg['optimizer']['name']:\n+        optim_method = eval(cfg['optimizer']['name'])\n \n     # Load Scheduler method\n     if 'scheduler' in cfg:\n         if hasattr(lr_scheduler, cfg['scheduler']['name']):\n             scheduler_method = getattr(lr_scheduler, cfg['scheduler']['name'])\n-        else:\n+        elif '.' not in cfg['optimizer']['name'] and \\\n+            '(' not in cfg['optimizer']['name'] and \\\n+            ' ' not in cfg['optimizer']['name']:\n             scheduler_method = eval(cfg['scheduler']['name'])\n     else:\n         scheduler_method = None\n","add":8,"remove":4,"filename":"\/utils\/optims.py","badparts":["    else:","        optim_method = eval(optim, cfg['optimizer']['name'])","        else:"],"goodparts":["    elif '.' not in cfg['optimizer']['name'] and \\","         '(' not in cfg['optimizer']['name'] and \\","         ' ' not in cfg['optimizer']['name']:","        optim_method = eval(cfg['optimizer']['name'])","        elif '.' not in cfg['optimizer']['name'] and \\","            '(' not in cfg['optimizer']['name'] and \\","            ' ' not in cfg['optimizer']['name']:"]},{"diff":"\n \n     # ResNets\n     elif ('resnet' in cfg['network']) or ('resnext' in cfg['network']) or ('res2net' in cfg['network']):\n-        parameters = model.parameters()\n+        if hasattr(model, 'get_parameter_groups'):\n+            param_groups = model.get_parameter_groups()\n+\n+            parameters = [\n+                {'params': param_groups[0], 'lr': 1 * cfg['optimizer']['kwargs']['lr'], 'weight_decay': cfg['optimizer']['kwargs']['weight_decay']},\n+                {'params': param_groups[1], 'lr': 10 * cfg['optimizer']['kwargs']['lr'], 'weight_decay': cfg['optimizer']['kwargs']['weight_decay']}]\n+        else:\n+            parameters = model.parameters()\n \n     # Dino_ResNet\n     elif cfg['network'] == 'dino_resnet50':\n","add":8,"remove":1,"filename":"\/utils\/optims.py","badparts":["        parameters = model.parameters()"],"goodparts":["        if hasattr(model, 'get_parameter_groups'):","            param_groups = model.get_parameter_groups()","            parameters = [","                {'params': param_groups[0], 'lr': 1 * cfg['optimizer']['kwargs']['lr'], 'weight_decay': cfg['optimizer']['kwargs']['weight_decay']},","                {'params': param_groups[1], 'lr': 10 * cfg['optimizer']['kwargs']['lr'], 'weight_decay': cfg['optimizer']['kwargs']['weight_decay']}]","        else:","            parameters = model.parameters()"]}],"source":"\nimport numpy as np from torch import optim from torch.optim import lr_scheduler class PolyOptimizer(optim.SGD): def __init__(self, params, lr, weight_decay, max_step, momentum=0.9): super().__init__(params, lr, weight_decay) self.param_groups=params self.global_step=0 self.max_step=max_step self.momentum=momentum self.__initial_lr=[group['lr'] for group in self.param_groups] def step(self, closure=None): if self.global_step < self.max_step: lr_mult=(1 -self.global_step \/ self.max_step) ** self.momentum for i in range(len(self.param_groups)): self.param_groups[i]['lr']=self.__initial_lr[i] * lr_mult super().step(closure) self.global_step +=1 def reduce_lr(epoch, optimizer, reduce_points, factor): values=reduce_points.strip().split(',') change_points=map(lambda x: int(x.strip()), values) if change_points is not None and epoch in change_points: for g in optimizer.param_groups: g['lr']=g['lr']*factor print(\"Reduce Learning Rate: \", epoch, g['lr']) return True def get_finetune_optimzier(cfg, model): if hasattr(optim, cfg['optimizer']['name']): optim_method=getattr(optim, cfg['optimizer']['name']) else: optim_method=eval(optim, cfg['optimizer']['name']) if 'scheduler' in cfg: if hasattr(lr_scheduler, cfg['scheduler']['name']): scheduler_method=getattr(lr_scheduler, cfg['scheduler']['name']) else: scheduler_method=eval(cfg['scheduler']['name']) else: scheduler_method=None if cfg['network'].startswith('vgg'): param_groups=model.get_parameter_groups() parameters=[ {'params': param_groups[0], 'lr': 1 * cfg['optimizer']['lr']}, {'params': param_groups[1], 'lr': 2 * cfg['optimizer']['lr']}, {'params': param_groups[2], 'lr': 10 * cfg['optimizer']['lr']}, {'params': param_groups[3], 'lr': 20 * cfg['optimizer']['lr']}] elif('resnet' in cfg['network']) or('resnext' in cfg['network']) or('res2net' in cfg['network']): parameters=model.parameters() elif cfg['network']=='dino_resnet50': parameters=model.parameters() elif cfg['network'].startwith('vit'): parameters=model.parameters() else: parameters=model.parameters() optimizer=optim_method(parameters, **cfg['optimizer']['kwargs']) scheduler=scheduler_method(optimizer, **cfg['scheduler']['kwargs']) if scheduler_method else None return optimizer, scheduler ","sourceWithComments":"import numpy as np\n\nfrom torch import optim\nfrom torch.optim import lr_scheduler\n\n# Mostly Copied from https:\/\/github.com\/jiwoon-ahn\/irn\/blob\/master\/misc\/torchutils.py\nclass PolyOptimizer(optim.SGD):\n    def __init__(self, params, lr, weight_decay, max_step, momentum=0.9):\n        super().__init__(params, lr, weight_decay)\n        self.param_groups = params\n        self.global_step = 0\n        self.max_step = max_step\n        self.momentum = momentum\n\n        self.__initial_lr = [group['lr'] for group in self.param_groups]\n\n    def step(self, closure=None):\n        if self.global_step < self.max_step:\n            lr_mult = (1 - self.global_step \/ self.max_step) ** self.momentum\n\n            for i in range(len(self.param_groups)):\n                self.param_groups[i]['lr'] = self.__initial_lr[i] * lr_mult\n        super().step(closure)\n\n        self.global_step += 1\n\n\ndef reduce_lr(epoch, optimizer, reduce_points, factor):\n    values = reduce_points.strip().split(',')\n    \n    change_points = map(lambda x: int(x.strip()), values)\n\n    if change_points is not None and epoch in change_points:\n        for g in optimizer.param_groups:\n            g['lr'] = g['lr']*factor\n            print(\"Reduce Learning Rate : \", epoch, g['lr'])\n        return True\n \n\n# Return Optimizer and Scheduler\ndef get_finetune_optimzier(cfg, model):\n\n    # Load Optimizer method\n    if hasattr(optim, cfg['optimizer']['name']):\n        optim_method = getattr(optim, cfg['optimizer']['name'])\n    # scratch method\n    else:\n        optim_method = eval(optim, cfg['optimizer']['name'])\n\n    # Load Scheduler method\n    if 'scheduler' in cfg:\n        if hasattr(lr_scheduler, cfg['scheduler']['name']):\n            scheduler_method = getattr(lr_scheduler, cfg['scheduler']['name'])\n        else:\n            scheduler_method = eval(cfg['scheduler']['name'])\n    else:\n        scheduler_method = None\n\n    # VGGs\n    if cfg['network'].startswith('vgg'):\n        param_groups = model.get_parameter_groups()\n\n        parameters = [\n            {'params': param_groups[0], 'lr': 1 * cfg['optimizer']['lr']},\n            {'params': param_groups[1], 'lr': 2 * cfg['optimizer']['lr']},\n            {'params': param_groups[2], 'lr': 10 * cfg['optimizer']['lr']},\n            {'params': param_groups[3], 'lr': 20 * cfg['optimizer']['lr']}]\n\n    # ResNets\n    elif ('resnet' in cfg['network']) or ('resnext' in cfg['network']) or ('res2net' in cfg['network']):\n        parameters = model.parameters()\n\n    # Dino_ResNet\n    elif cfg['network'] == 'dino_resnet50':\n        parameters = model.parameters()\n\n    # ViTs\n    elif cfg['network'].startwith('vit'):\n        parameters = model.parameters()\n\n    # Custom hparams\n    else:\n        parameters = model.parameters()\n\n    # Optimizer\n    optimizer = optim_method(parameters, **cfg['optimizer']['kwargs'])\n    # Scheduler\n    scheduler = scheduler_method(optimizer, **cfg['scheduler']['kwargs']) if scheduler_method else None\n\n    return optimizer, scheduler"}},"msg":"Add resnet optimizer and prevent eval injection"}},"https:\/\/github.com\/hammerhorn\/working":{"8364f8bffe24baf57ff9c9655db70bd30dfac95b":{"url":"https:\/\/api.github.com\/repos\/hammerhorn\/working\/commits\/8364f8bffe24baf57ff9c9655db70bd30dfac95b","html_url":"https:\/\/github.com\/hammerhorn\/working\/commit\/8364f8bffe24baf57ff9c9655db70bd30dfac95b","message":"prevents code injection by using eval() safely","sha":"8364f8bffe24baf57ff9c9655db70bd30dfac95b","keyword":"eval injection prevent","diff":"diff --git a\/cjh\/maths\/geometry.py b\/cjh\/maths\/geometry.py\nindex 0851ddb..522bf3d 100644\n--- a\/cjh\/maths\/geometry.py\n+++ b\/cjh\/maths\/geometry.py\n@@ -91,13 +91,14 @@ def _initialize(self):\n     def input(self, shell=Terminal, prompt=''):\n         \"\"\"prompts user for comma-separated tuple\"\"\"\n         prompt += ' (x, y) : '\n-        inp = lambda: eval(shell.input(prompt))\n+        inp = lambda: tuple(eval(shell.input(prompt)))  # code injection risk?\n+\n         while True:\n             try:\n                 self.x_mag, self.y_mag = inp()\n             except KeyboardInterrupt:\n                 break\n-            except (NameError, TypeError):  # What kind?\n+            except (NameError, TypeError, ValueError):  # What kind?\n                 continue\n             else:\n                 break\n","files":{"\/cjh\/maths\/geometry.py":{"changes":[{"diff":"\n     def input(self, shell=Terminal, prompt=''):\n         \"\"\"prompts user for comma-separated tuple\"\"\"\n         prompt += ' (x, y) : '\n-        inp = lambda: eval(shell.input(prompt))\n+        inp = lambda: tuple(eval(shell.input(prompt)))  # code injection risk?\n+\n         while True:\n             try:\n                 self.x_mag, self.y_mag = inp()\n             except KeyboardInterrupt:\n                 break\n-            except (NameError, TypeError):  # What kind?\n+            except (NameError, TypeError, ValueError):  # What kind?\n                 continue\n             else:\n                 break\n","add":3,"remove":2,"filename":"\/cjh\/maths\/geometry.py","badparts":["        inp = lambda: eval(shell.input(prompt))","            except (NameError, TypeError):  # What kind?"],"goodparts":["        inp = lambda: tuple(eval(shell.input(prompt)))  # code injection risk?","            except (NameError, TypeError, ValueError):  # What kind?"]}],"source":"\n \"\"\" classes: Point, Area, TwoDShape, Polygon, Ellipse, Circle, Graph move non-geometry stuff from graph to goboard \"\"\" import decimal import json import math import sys try: import Tkinter as tk except ImportError: try: import tkinter as tk except ImportError: print(\"Could not import module 'tkinter'.\") from termcolor import colored from cjh.letterator import Letter from cjh.maths.algebra import Polynom from cjh.maths.angles import Angle import easycat from fiziko.kinematics import Disp from fiziko.scalars import Scalar, Unit from things import Thing from versatiledialogs.lists import Enumeration, ItemList, PlainList from versatiledialogs.terminal import Terminal __author__='Chris Horn <hammerhorn@gmail.com>' __license__='GPL' class Point(Disp): \"\"\" 2-d spatial point \"\"\" def __init__(self, x, y): super(Point, self).__init__(0, Angle()) self.label='a point' self.x_mag=float(x) self.y_mag=float(y) self.units=Unit() self.marker='none' self._initialize() self.mag=math.sqrt(self.x_mag**2 +self.y_mag**2) if self.x_mag < 0.0: self.mag *=-1.0 self.theta.units=Unit('rad') def __repr__(self): return '({},{})'.format(round(self.x_mag, 4), round(self.y_mag, 4)) def __eq__(self, other): if self.tuple()==other.tuple(): return True else: return False def __ne__(self, other): if self.tuple() !=other.tuple(): return True else: return False def __add__(self, other): return Point( decimal.Decimal(self.x_mag) +decimal.Decimal(other.x_mag), decimal.Decimal(self.y_mag) +decimal.Decimal(other.y_mag)) def __sub__(self, other): \"\"\"Get the distance between two points.\"\"\" return math.hypot(self.x -other.x, self.y -other.y) def _initialize(self): \"\"\" Finds the distance from the origin and the angle. (There might be something comparable in a parent class?) \"\"\" self.mag=math.sqrt(self.x_mag**2 +self.y_mag**2) try: self.theta=Angle(math.atan(self.y_mag\/self.x_mag), 'rad') except ZeroDivisionError: self.theta=Angle(0, 'rad') if self.x_mag < 0.0: self.mag *=-1.0 self.theta.units=Unit('rad') def input(self, shell=Terminal, prompt=''): \"\"\"prompts user for comma-separated tuple\"\"\" prompt +='(x, y): ' inp=lambda: eval(shell.input(prompt)) while True: try: self.x_mag, self.y_mag=inp() except KeyboardInterrupt: break except(NameError, TypeError): continue else: break self._initialize() @property def distance_str(self): \"\"\"str describing the distance from the origin\"\"\" return '{} from the origin'.format(Scalar(abs(self.mag), self.units)) def tuple(self): \"\"\"returns point as a float tuple\"\"\" return(self.x_mag, self.y_mag) @property def x(self): \"\"\"x magnitude of the Point\"\"\" return self.x_mag @x.setter def x(self, x_val): \"\"\"setter for x\"\"\" self.x_mag=float(x_val) self._initialize() @property def y(self): \"\"\"y magnitude of the Point\"\"\" return self.y_mag @y.setter def y(self, y_val): \"\"\"setter for y\"\"\" self.y_mag=float(y_val) self._initialize() @property def x_y(self): \"\"\"coordinates in tuple form\"\"\" return self.tuple() @x_y.setter def x_y(self, xy): \"\"\"takes a 2-member tuple\"\"\" self.x_mag=xy[0] self.y_mag=xy[1] self._initialize() class Area(Scalar): \"\"\"area on a two-dimensional grid, surface area\"\"\" def __init__(self, d=0.0): super(Area, self).__init__(d, 'units^2') def draw(self): \"\"\" a very rough approximation only \"\"\" length=int(float(self.mag) ** 0.5) drawn=0 for _ in range(length): Terminal.output('') for _ in range(length): easycat.write(colored(' ', attrs=['reverse', 'bold'])) drawn +=1 easycat.write(' ') for _ in range(int(self.mag) -drawn): easycat.write(colored(' ', attrs=['reverse', 'bold'])) class TwoDShape(Thing): \"\"\"Ellipses and Polygons\"\"\" def __init__(self): super(TwoDShape, self).__init__() self.perimeter=Disp(u='units') self.area=Area() def __str__(self): s='\\n' +Terminal.fx('u', self.label) s +='{:>9}={}\\n'.format('Area', self.area) s +='{:>9}={}'.format('Perimeter', self.perimeter.to_scalar()) return s @property def area_(self): \"\"\"returns area as an Area object\"\"\" return self.area @area_.setter def area_(self, fl): \"\"\"set area, takes a float\"\"\" self.area=Area(fl) @property def perim(self): \"\"\"returns perimeter as Disp object\"\"\" return self.perimeter @perim.setter def perim(self, fl): \"\"\"set perimeter, takes a float\"\"\" self.perimeter=Disp(fl) class Polygon(TwoDShape): \"\"\"Polygon -will be changed to being set by a collection of Points\"\"\" def __init__(self, sides): super(Polygon, self).__init__() self.label +='({}-gon)'.format(sides) self.sides=sides self.angle_sum=Angle((self.sides -2) * 180) def __str__(self): out_str='In a figure with{} sides,\\n'.format(self.sides) out_str +='\\n\\tsum of all angles={}\\n'.format(self.angle_sum) out_str +='\\t average angle={}\\n'.format( self.angle_sum \/ self.sides) return out_str class Ellipse(TwoDShape): \"\"\"Plot Ellipse, get area and circumference; parent for Circle\"\"\" def __init__(self, h_semiaxis, v_semiaxis=None, center_point=Point(0.0, 0.0)): super(Ellipse, self).__init__() if v_semiaxis==None: v_semiaxis=h_semiaxis self.area=Area(decimal.Decimal(math.pi) * decimal.Decimal( h_semiaxis) * decimal.Decimal(v_semiaxis)) self.center=center_point if h_semiaxis > v_semiaxis: f=math.sqrt(h_semiaxis ** 2 -v_semiaxis ** 2) self.focus1=self.center +Disp(f, 'units', Angle(0)) self.focus2=self.center -Disp(f, 'units', Angle(0)) self.eccentricity=f \/ h_semiaxis else: f=math.sqrt(v_semiaxis ** 2 -h_semiaxis ** 2) self.focus1=Point(self.center.x_mag, self.center.y_mag +f) self.focus2=Point(self.center.x_mag, self.center.y_mag -f) self.eccentricity=decimal.Decimal(f) \/ decimal.Decimal(v_semiaxis) def __str__(self): s='\\n' +Terminal.ul(self.label) +'\\n' s +='{:>13}={}\\n'.format('Area', self.area) s +='{:>13}={}\\n'.format('Center', self.center) if self.focus1 !=self.focus2: s +='{:>13}={} &{}\\n'.format('Foci', self.focus1, self.focus2) s +='{:>13}={}\\n'.format('Eccentricity', self.eccentricity) return s class Circle(Ellipse): \"\"\"Plot Circles; get area and circumference\"\"\" def __init__(self, radius, center=Point(0.0, 0.0)): \"\"\"currently takes a float\"\"\" super(Circle, self).__init__(radius, center_point=center) self.perimeter=Disp(decimal.Decimal(2.0) * decimal.Decimal( math.pi) * decimal.Decimal(radius)) self.radius=Disp(radius, u='units') def eval(self, x_input): \"\"\"Modify this to return a tuple of two y values\"\"\" return( self.__call__(x_input), self.center.y_mag -math.sqrt( self.radius.mag ** 2 -decimal.Decimal( x_input -self.center.x_mag) ** 2)) def __call__(self, x_value): \"\"\"Function of the upper half of the circle\"\"\" try: f_of_x=self.center.y_mag +math.sqrt( self.radius.mag ** 2 -decimal.Decimal( x_value -self.center.x_mag) ** 2) return f_of_x except ValueError: Terminal.notify( 'function is undefined at f({})'.format(x_value)) return None class Graph(Thing): \"\"\" a crude graphing calculator and multi-purpose grid \"\"\" def __init__(self, size=19, skinfile='graph.json', sh_obj=Terminal(), adjust_ssize=0): basedir='__data__\/skins' self.sh_obj=sh_obj if self.sh_obj.platform=='android': basedir=\\ '\/storage\/sdcard0\/com.hipipal.qpyplus\/lib\/python2.7\/\\ site-packages\/' +basedir super(Graph, self).__init__() self.size=int(size) def shrink(deduct): \"\"\" if board would be too big for screen size, make a smaller board. \"\"\" if self.size +deduct > Terminal.height(): self.size=Terminal.height() -deduct shrink(-adjust_ssize) self.max_domain=self.size \/\/ 2 if self.size % 2==0: self.max_domain -=1 self.cursor=[-self.max_domain -1, self.max_domain] self.plane=[[0 for _ in range(self.size)] for _ in range(self.size)] for col in range(self.size): for rank in range(self.size): self.plane[col][rank]=Point( col -self.max_domain, self.max_domain -rank) if col==self.max_domain and rank==self.max_domain: self.plane[col][rank].marker='origin' elif col==self.max_domain: self.plane[col][rank].marker='y_axis' elif rank==self.max_domain: self.plane[col][rank].marker='x_axis' else: self.plane[col][rank].marker='empty' if sys.version_info.major==2: self.skin_dict=json.load(open( '{}\/{}'.format(basedir, skinfile), 'rb')) elif sys.version_info.major==3: file_handle=open(basedir +'\/' +skinfile, 'rb') file_str=file_handle.read().decode('utf-8') self.skin_dict=json.loads(file_str) self.fx_list=[] self.funct_cnt=len(self.fx_list) seq=Letter.caps_gen() Letter.pass_no=1 self.letters=[next(seq) for _ in range(self.size)] self.label +='({0} \u00d7{0})'.format(self.size) def __str__(self): \"\"\"this would be better if the cursor could be hidden\"\"\" string='\\n' string +=' ' * 3 for i in range(self.size): string +='{:>2s}'.format(self.letters[i]) string +=\"\\n\" for rank in range(self.size): string +=('%3d ' %(self.size -rank)) for col in range(self.size): xy_coords=col -self.max_domain, self.max_domain -rank if xy_coords==tuple(self.cursor): string +='\\b(' tag_list=self.skin_dict.keys() tag=self.plane[col][rank].marker if sys.version_info.major==2: if tag in tag_list: string +=self.skin_dict[tag].encode('utf-8') else: string +='??'.encode('utf-8') elif sys.version_info.major==3: if tag in tag_list: string +=self.skin_dict[tag] else: string +='??' if xy_coords==tuple(self.cursor): string +='\\b)' if self.size > 9: string +=('{:2d} '.format(self.size -rank)) else: string +=('{:1d} '.format(self.size -rank)) string +='\\n' string +=' '* 3 for i in range(self.size): string +='{:>2s}'.format(self.letters[i]) string +='\\n' return string def fill(self, color='empty'): \"\"\" some problems under python3? \"\"\" for col in range(-self.max_domain, self.max_domain +1): for rank in range(-self.max_domain, self.max_domain +1): self.plot_point(col, rank, color) def view_edit(self): \"\"\" Interactive wysiwyg editor * When board size is even, rightmost column willaccept neither a point nor the cursor, but you can go past and back. \"\"\" while True: try: if self.sh_obj.interface=='term': point=Terminal.make_page( 'EDIT', self, self.pt_at_cursor) else: self.sh_obj.msgtxt.set(self.__str__()) point=self.pt_at_cursor() if type(point)==Point: string='' string +=('\\t' +str(point)) +'\\n' string +=('\\t[' +point.distance_str +']') +'\\n' if self.sh_obj.interface=='term': Terminal.output(string) else: tk.Label(self.sh_obj.main_window, text=str(point)) tk.Label(self.sh_obj.main_window, text='[{}]'.format( point.distance_str)) info_list=[ 'Use h, j, k, l to move the cursor', 'b=black, w=white, x=erase, *=star', 'Ctl-c to exit editor'] if self.cursor[0] >=-self.max_domain and\\ self.cursor[0] <=self.max_domain and\\ self.cursor[1] >=-self.max_domain and\\ self.cursor[1] <=self.max_domain: pass else: rescue_key='l or h' if self.cursor[1] < -self.max_domain or\\ self.cursor[1] > self.max_domain: rescue_key='j or k' info_list[0]='Press{} to reveal cursor'.format( rescue_key) info=ItemList(info_list) if self.sh_obj.interface=='term': Terminal.output(info) else: tk.Label(self.sh_obj.main_window, text=str(info)).pack() char=Terminal.get_keypress() if char=='h': if self.cursor[0] > -self.max_domain: self.cursor[0] -=1 else: self.cursor[0] +=self.size elif char=='l': if self.size % 2==0: self.max_domain +=1 if self.cursor[0] < self.max_domain: self.cursor[0] +=1 else: self.cursor[0] -=self.size if self.size % 2==0: self.max_domain +=1 elif char=='j': if self.cursor[1] > -1 * self.max_domain: self.cursor[1] -=1 else: self.cursor[1] +=self.size elif char=='k': if self.cursor[1] < self.max_domain: self.cursor[1] +=1 else: self.cursor[1] -=self.size elif char=='b': self.plot_point(self.cursor[0], self.cursor[1], 'black') elif char=='w': self.plot_point(self.cursor[0], self.cursor[1], 'white') elif char=='x' or char=='\\x7f': self.plot_point(self.cursor[0], self.cursor[1], 'empty') elif char=='*': self.plot_point(self.cursor[0], self.cursor[1], 'star') except KeyboardInterrupt: Terminal.output('') break def color_chooser(self): \"\"\" set the point's color tag \"\"\" colors=['black', 'white', 'empty', 'star'] if self.sh_obj.interface=='term': return Terminal.make_page( 'color-chooser', str(self) +'\\nPress Ctrl-c to cancel', self.prompt_color) else: opt_no=self.sh_obj.list_menu( PlainList(colors), 'Choose a color', 'Color Chooser') index=opt_no -1 return colors[index] def prompt_color(self): \"\"\" Prompt the user to choose a color; this should be in a go_stone class \"\"\" choice=-1 while choice !='b' and choice !='w' and choice !='x' and\\ choice !='*': choice=self.sh_obj.get_keypress( '\\nPick up a color\\n(b=black, w=white, x=erase, *=star)') if choice=='b': return 'black' elif choice=='w': return 'white' elif choice=='x': return 'empty' elif choice=='*': return 'star' else: Terminal.output('Cancelling operation') return -1 def prompt_point(self, color): \"\"\" Prompt user for x,y coordinates and plot point. \"\"\" pair_x, pair_y=eval(self.sh_obj.input('(x, y):')) self.plot_point(pair_x, pair_y, color) def plot_point(self, x_val, y_val, color='black'): \"\"\" Plot a point of specified color at x, y \"\"\" if color=='empty': self.erase_point(x_val, y_val) elif x_val >=(-self.max_domain) and x_val <=self.max_domain and\\ y_val >=(-self.max_domain) and y_val <=self.max_domain: if color=='black' or color=='white' or color=='star': self.plane[int(round(x_val) +self.max_domain)][int( self.max_domain -round(y_val))].marker=color def erase_point(self, x_val, y_val): \"\"\" Erase point at x, y. \"\"\" x_val=int(round(x_val)) y_val=int(round(y_val)) if(x_val !=0) and(-y_val !=0): self.plane[x_val +self.max_domain]\\ [-y_val +self.max_domain].marker='empty' elif(x_val==0) and(-y_val !=0): self.plane[x_val +self.max_domain]\\ [-y_val +self.max_domain].marker='y_axis' elif(-y_val==0) and(x_val !=0): self.plane[x_val +self.max_domain]\\ [-y_val +self.max_domain].marker='x_axis' else: self.plane[x_val +self.max_domain]\\ [-y_val +self.max_domain].marker='origin' def print_points(self): \"\"\" Print the graph as a table of ordered pairs. Used for debugging or non- Euclidean space. \"\"\" for y_val in range(self.size): for x_val in range(self.size): if self.pt_at_cursor() and self.plane[x_val][y_val]==\\ self.pt_at_cursor(): easycat.write('{:>9}'.format('>{}<'.format( self.plane[x_val][y_val]))) elif self.pt_at_cursor() and self.plane[x_val][y_val]==\\ self.pt_at_cursor(): easycat.write('{:>9}'.format(self.plane[x_val][y_val])) else: easycat.write('{:>8} '.format(self.plane[x_val][y_val])) Terminal.output('') def pt_at_cursor(self): \"\"\" returns Point object where cursor is located \"\"\" if self.cursor[0] <=self.max_domain and\\ self.cursor[0] >=-self.max_domain and\\ self.cursor[1] <=self.max_domain and\\ self.cursor[1] >=-self.max_domain: return self.plane[int(self.cursor[0] +self.max_domain)]\\ [int(self.max_domain -self.cursor[1])] def indices_to_point(self, index1, index2): \"\"\"Maybe the reverse would be more useful. Also, give it the ability to take either a tuple or pair of args. \"\"\" return Point(index1 -self.max_domain, self.max_domain -index2) def list_functs(self): \"\"\" Currently lists all attached polynomials; add ability to list 'auto-shapes, etc.' \"\"\" enum=Enumeration(self.fx_list, 'attached functions') if self.sh_obj=='term': Terminal.output(enum) self.sh_obj.wait() else: self.sh_obj.wait(str(enum)) def add_polynomial(self): \"\"\" Use the Polynom.wizard() and attach result to the goban \"\"\" try: color=self.color_chooser() f_x=Polynom([]) f_x.wizard(sh_class=self.sh_obj) if self.sh_obj=='term': self.sh_obj.text_splash( 'Preview goes here', flashes=3, duration=.5) self.sh_obj.output(\"\\nAttach '{}'?\".format(f_x)) ans=self.sh_obj.get_keypress() else: ans='y' if ans=='y' and color !=-1: self.plot_funct(f_x, color) self.fx_list.append(f_x) except(KeyboardInterrupt, OverflowError): pass def plot_funct(self, funct_a, color): \"\"\" Any numerical function will do: native python functions, Polynom objects, or whatever.... \"\"\" self.funct_cnt +=1 for var in range(-self.max_domain, self.max_domain +1): try: self.plot_point(var, int(round(funct_a(var))), color) except(TypeError, ValueError): continue def prompt_circle(self, color): \"\"\" Prompt user for specifications and draw circle \"\"\" radius=float(self.sh_obj.input('radius: ')) center=0, 0 center=eval(self.sh_obj.input('center(x, y): ')) self.add_ellipse(radius, radius, color,(float(center[0]), float( center[1]))) def prompt_ellipse(self, color): \"\"\" Prompt user for attributes and draw ellipse \"\"\" semiaxes=eval(self.sh_obj.input('semiaxes(H, V): ')) center=eval(self.sh_obj.input('center(x, y): ')) self.add_ellipse(float(semiaxes[0]), float(semiaxes[1]), color,(float( center[0]), float(center[1]))) def add_ellipse(self, semiaxis_a=None, semiaxis_b=None, color='black', center=(0, 0)): \"\"\" draw ellipse on the plane; use a Point object instead of a tuple \"\"\" if not semiaxis_a: semiaxis_a=self.max_domain if not semiaxis_b: semiaxis_b=semiaxis_a self.funct_cnt +=1 for x_val in range(-1 * self.max_domain, self.max_domain +1): try: self.plot_point(x_val, int(center[1] +round(math.sqrt( semiaxis_b ** 2 -semiaxis_b ** 2 *(x_val -center[0]) ** 2 \/ semiaxis_a ** 2))), color) except ZeroDivisionError: pass except ValueError: pass try: self.plot_point(x_val, int(center[1] -round(math.sqrt( semiaxis_b ** 2 -semiaxis_b ** 2 *(x_val -center[0]) ** 2 \/ semiaxis_a ** 2))), color) except ZeroDivisionError: pass except ValueError: pass def prompt_wave(self, color): \"\"\" Prompt user for attributes, and draw sine wave on plane. \"\"\" self.add_sinewave( float(self.sh_obj.input('wavelength: ')), float(self.sh_obj.input('amplitude: ')), float(self.sh_obj.input('h_shift: ')), color) def add_sinewave(self, wlength=None, amplitude=None, h_shift=0, color='black'): \"\"\" Draw sine wave onto plane. \"\"\" if wlength is None: wlength=(2 * self.max_domain) if amplitude is None: amplitude=self.max_domain for x_val in range(-1 * self.max_domain, self.max_domain +1): try: self.plot_point( x_val, int(round(amplitude * math.sin( 2.0 * x_val * math.pi \/ wlength -(h_shift\/math.pi)))), color) except ZeroDivisionError: pass def write_sgf(self, basename): \"\"\" Save the current board position as SGF. \"\"\" sequence='' for cols in range(self.size): for rows in range(self.size): if self.plane[rows][cols].marker=='white': sequence +=' AW[%s%s]' %(chr(rows+97), chr(cols+97)) elif self.plane[rows][cols].marker=='black': sequence +=' AB[%s%s]' %(chr(rows+97), chr(cols+97)) if sys.version_info.major==3: self._save( basename, 'sgf', lambda f: f.write( bytes('(;GM[1] SZ[{}] KM[6.5] AP[go_test.py]{} ;)'.format( self.size, sequence), 'UTF-8'))) elif sys.version_info.major==2: self._save(basename, 'sgf', lambda f: f.write( '(;GM[1] SZ[{}] KM[6.5] AP[go_test.py]{} ;)'.format( self.size, sequence))) def save_skin(self, basename): \"\"\" Save skin as JSON \"\"\" json.dump(self.skin_dict, basename +'.json', indent=2) return 0 ","sourceWithComments":"#!\/usr\/bin\/env python\n#coding=utf8\n\"\"\"\nclasses: Point, Area, TwoDShape, Polygon, Ellipse, Circle, Graph\n\nmove non-geometry stuff from graph to goboard\n\"\"\"\nimport decimal\nimport json\nimport math\nimport sys\n# import time\ntry:\n    import Tkinter as tk\nexcept ImportError:\n    try:\n        import tkinter as tk\n    except ImportError:\n        print(\"Could not import module 'tkinter'.\") #pylint: disable=C0325\n\nfrom termcolor import colored\n\nfrom cjh.letterator import Letter\nfrom cjh.maths.algebra import Polynom\nfrom cjh.maths.angles import Angle\nimport easycat\nfrom fiziko.kinematics import Disp\nfrom fiziko.scalars import Scalar, Unit\nfrom things import Thing\nfrom versatiledialogs.lists import Enumeration, ItemList, PlainList\nfrom versatiledialogs.terminal import Terminal\n\n__author__ = 'Chris Horn <hammerhorn@gmail.com>'\n__license__ = 'GPL'\n\nclass Point(Disp):\n    \"\"\"\n    2-d spatial point\n    \"\"\"\n    def __init__(self, x, y):\n        super(Point, self).__init__(0, Angle())\n        self.label = 'a point'\n        self.x_mag = float(x)\n        self.y_mag = float(y)\n        self.units = Unit()\n        self.marker = 'none'  # should be put into child class go_stone?\n        self._initialize()\n        self.mag = math.sqrt(self.x_mag**2 + self.y_mag**2)\n        if self.x_mag < 0.0:\n            self.mag *= -1.0\n        self.theta.units = Unit('rad')\n\n    def __repr__(self):\n        return '({}, {})'.format(round(self.x_mag, 4), round(self.y_mag, 4))\n\n    def __eq__(self, other):\n        if self.tuple() == other.tuple():\n            return True\n        else:\n            return False\n\n    def __ne__(self, other):\n        if self.tuple() != other.tuple():\n            return True\n        else:\n            return False\n\n    def __add__(self, other):\n        return Point(\n            decimal.Decimal(self.x_mag) + decimal.Decimal(other.x_mag),\n            decimal.Decimal(self.y_mag) + decimal.Decimal(other.y_mag))\n\n    def __sub__(self, other):\n        \"\"\"Get the distance between two points.\"\"\"\n        return math.hypot(self.x - other.x, self.y - other.y)\n    \n    def _initialize(self):\n        \"\"\"\n        Finds the distance from the origin and the angle.\n        (There might be something comparable in a parent class?)\n        \"\"\"\n        self.mag = math.sqrt(self.x_mag**2 + self.y_mag**2)\n        try:\n            self.theta = Angle(math.atan(self.y_mag\/self.x_mag), 'rad')\n        except ZeroDivisionError:\n            self.theta = Angle(0, 'rad')\n        if self.x_mag < 0.0:\n            self.mag *= -1.0\n        self.theta.units = Unit('rad')\n\n    def input(self, shell=Terminal, prompt=''):\n        \"\"\"prompts user for comma-separated tuple\"\"\"\n        prompt += ' (x, y) : '\n        inp = lambda: eval(shell.input(prompt))\n        while True:\n            try:\n                self.x_mag, self.y_mag = inp()\n            except KeyboardInterrupt:\n                break\n            except (NameError, TypeError):  # What kind?\n                continue\n            else:\n                break\n        self._initialize()\n\n    @property\n    def distance_str(self):\n        \"\"\"str describing the distance from the origin\"\"\"\n        return '{} from the origin'.format(Scalar(abs(self.mag), self.units))\n\n    def tuple(self):\n        \"\"\"returns point as a float tuple\"\"\"\n        return (self.x_mag, self.y_mag)\n\n    @property\n    def x(self):\n        \"\"\"x magnitude of the Point\"\"\"\n        return self.x_mag\n\n    @x.setter\n    def x(self, x_val):\n        \"\"\"setter for x\"\"\"\n        self.x_mag = float(x_val)\n        self._initialize()\n\n    @property\n    def y(self):\n        \"\"\"y magnitude of the Point\"\"\"\n        return self.y_mag\n\n    @y.setter\n    def y(self, y_val):\n        \"\"\"setter for y\"\"\"\n        self.y_mag = float(y_val)\n        self._initialize()\n\n    @property\n    def x_y(self):\n        \"\"\"coordinates in tuple form\"\"\"\n        return self.tuple()\n\n    @x_y.setter\n    def x_y(self, xy):\n        \"\"\"takes a 2-member tuple\"\"\"\n        self.x_mag = xy[0]\n        self.y_mag = xy[1]\n        self._initialize()\n\n\nclass Area(Scalar):\n    \"\"\"area on a two-dimensional grid, surface area\"\"\"\n    def __init__(self, d=0.0):\n        super(Area, self).__init__(d, 'units^2')\n\n    def draw(self):\n        \"\"\" a very rough approximation only \"\"\"\n        length = int(float(self.mag) ** 0.5)\n        drawn = 0\n        for _ in range(length):\n            Terminal.output('')\n            for _ in range(length):\n                easycat.write(colored('  ', attrs=['reverse', 'bold']))\n                drawn += 1\n\n            easycat.write(' ')\n        for _ in range(int(self.mag) - drawn):\n            easycat.write(colored('  ', attrs=['reverse', 'bold']))\n\nclass TwoDShape(Thing):\n    \"\"\"Ellipses and Polygons\"\"\"\n    def __init__(self):\n        super(TwoDShape, self).__init__()\n        self.perimeter = Disp(u='units')\n        self.area = Area()\n\n    def __str__(self):\n        s = '\\n' + Terminal.fx('u', self.label)\n        s += '{:>9} = {}\\n'.format('Area', self.area)\n        s += '{:>9} = {}'.format('Perimeter', self.perimeter.to_scalar())\n        return s\n\n    @property\n    def area_(self):\n        \"\"\"returns area as an Area object\"\"\"\n        return self.area\n\n    @area_.setter\n    def area_(self, fl):\n        \"\"\"set area, takes a float\"\"\"\n        self.area = Area(fl)\n\n    @property\n    def perim(self):\n        \"\"\"returns perimeter as Disp object\"\"\"\n        return self.perimeter\n\n    @perim.setter\n    def perim(self, fl):\n        \"\"\"set perimeter, takes a float\"\"\"\n        self.perimeter = Disp(fl)\n\n\nclass Polygon(TwoDShape):\n    \"\"\"Polygon - will be changed to being set by a collection of Points\"\"\"\n    def __init__(self, sides):\n        super(Polygon, self).__init__()\n        self.label += ' ({}-gon)'.format(sides)\n        self.sides = sides\n        self.angle_sum = Angle((self.sides - 2) * 180)\n\n    def __str__(self):\n        out_str = 'In a figure with {} sides,\\n'.format(self.sides)\n        out_str += '\\n\\tsum of all angles = {}\\n'.format(self.angle_sum)\n        out_str += '\\t    average angle = {}\\n'.format(\n            self.angle_sum \/ self.sides)\n        return out_str\n\nclass Ellipse(TwoDShape):\n    \"\"\"Plot Ellipse, get area and circumference; parent for Circle\"\"\"\n    def __init__(self, h_semiaxis, v_semiaxis=None,\n                 center_point=Point(0.0, 0.0)):\n        super(Ellipse, self).__init__()\n        if v_semiaxis == None:\n            v_semiaxis = h_semiaxis\n        self.area = Area(decimal.Decimal(math.pi) * decimal.Decimal(\n            h_semiaxis) * decimal.Decimal(v_semiaxis))\n        self.center = center_point\n        if h_semiaxis > v_semiaxis:\n            f = math.sqrt(h_semiaxis ** 2 - v_semiaxis ** 2)\n            self.focus1 = self.center + Disp(f, 'units', Angle(0))\n            self.focus2 = self.center - Disp(f, 'units', Angle(0))\n            self.eccentricity = f \/ h_semiaxis\n        else:\n            f = math.sqrt(v_semiaxis ** 2 - h_semiaxis ** 2)\n            self.focus1 = Point(self.center.x_mag, self.center.y_mag + f)\n            self.focus2 = Point(self.center.x_mag, self.center.y_mag - f)\n            self.eccentricity = decimal.Decimal(f) \/ decimal.Decimal(v_semiaxis)\n\n    def __str__(self):\n        s = '\\n' + Terminal.ul(self.label) + '\\n'\n        s += '{:>13} = {}\\n'.format('Area', self.area)\n      # s += \"{:>13} = {}\".format('Circumference', self.perimeter.to_Scalar())\n        s += '{:>13} = {}\\n'.format('Center', self.center)\n        if self.focus1 != self.focus2:\n            s += '{:>13} = {} & {}\\n'.format('Foci', self.focus1, self.focus2)\n        s += '{:>13} = {}\\n'.format('Eccentricity', self.eccentricity)\n        return s\n\nclass Circle(Ellipse):\n    \"\"\"Plot Circles; get area and circumference\"\"\"\n    def __init__(self, radius, center=Point(0.0, 0.0)):\n        \"\"\"currently takes a float\"\"\"\n        super(Circle, self).__init__(radius, center_point=center)\n        self.perimeter = Disp(decimal.Decimal(2.0) * decimal.Decimal(\n            math.pi) * decimal.Decimal(radius))\n        self.radius = Disp(radius, u='units')\n\n    def eval(self, x_input):\n        \"\"\"Modify this to return a tuple of two y values\"\"\"\n        return (\n            self.__call__(x_input),\n            self.center.y_mag - math.sqrt(\n                self.radius.mag ** 2 - decimal.Decimal(\n                    x_input - self.center.x_mag) ** 2))\n\n    def __call__(self, x_value):\n        \"\"\"Function of the upper half of the circle\"\"\"\n        try:\n            f_of_x = self.center.y_mag + math.sqrt(\n                self.radius.mag ** 2 -decimal.Decimal(\n                    x_value - self.center.x_mag) ** 2)\n            return f_of_x\n        except ValueError:\n            Terminal.notify(\n                'function is undefined at f({})'.format(x_value))\n            return None\n\n\nclass Graph(Thing):\n    \"\"\"\n    a crude graphing calculator and multi-purpose grid\n    \"\"\"\n    def __init__(self, size=19, skinfile='graph.json',\n                 sh_obj=Terminal(), adjust_ssize=0):\n        basedir = '__data__\/skins'\n        self.sh_obj = sh_obj\n        if self.sh_obj.platform == 'android':\n            basedir =\\\n                '\/storage\/sdcard0\/com.hipipal.qpyplus\/lib\/python2.7\/\\\n                site-packages\/' + basedir\n        super(Graph, self).__init__()\n        self.size = int(size)\n\n        # shrink to screen size\n        def shrink(deduct):\n            \"\"\"\n            if board would be too big for screen size, make a smaller board.\n            \"\"\"\n            if self.size + deduct > Terminal.height():\n                self.size = Terminal.height() - deduct\n        shrink(-adjust_ssize)\n\n        self.max_domain = self.size \/\/ 2\n        if self.size % 2 == 0:\n            self.max_domain -= 1\n\n        self.cursor = [-self.max_domain - 1, self.max_domain]\n        self.plane = [[0 for _ in range(self.size)] for _ in range(self.size)]\n        for col in range(self.size):\n            for rank in range(self.size):\n                self.plane[col][rank] = Point(\n                    col - self.max_domain, self.max_domain - rank)\n                if col == self.max_domain and rank == self.max_domain:\n                    self.plane[col][rank].marker = 'origin'\n                elif col == self.max_domain:\n                    self.plane[col][rank].marker = 'y_axis'\n                elif rank == self.max_domain:\n                    self.plane[col][rank].marker = 'x_axis'\n                else: self.plane[col][rank].marker = 'empty'\n\n    # DO NOT--># if self.is_hoshi(\n    #       -->#     col - self.max_domain, self.max_domain - rank):\n    # ERASE!-->#     self.plane[col][rank].marker = 'hoshi'\n\n        if sys.version_info.major == 2:\n            self.skin_dict = json.load(open(\n                '{}\/{}'.format(basedir, skinfile), 'rb'))\n        elif sys.version_info.major == 3:\n            file_handle = open(basedir + '\/' + skinfile, 'rb')\n            file_str = file_handle.read().decode('utf-8')\n            self.skin_dict = json.loads(file_str)\n\n        #######################################################################\n###\n#####################\n        ##    reader = codecs.getreader('utf-8')\n                   ##\n        ##    self.skin_dict = json.load(reader('skins\/' + skinfile))\n                   ##\n        ##    self.skin_dict = json.load(f)\n                   ##\n        ##    raw_input('Press enter to try opening ' + skinfile)\n                   ##\n        ##    self.skin_dict = json.load(str(open('skins\/' + skinfile, 'rb'), en\n#co\n#ding='UTF-8'))     ##\n        ########################################################################\n##\n#####################\n\n#        except: # else:\n#            self.skin_dict = {\"black\"  : u\"\u25cf \",\n#                              \"white\"  : u\"o \",\n#                              \"star\"   : u\"\u2a09 \",\n#                              \"hoshi\"  : u\"  \",\n#                              \"origin\" : u\"+-\",\n#                              \"y_axis\" : u\"| \",\n#                              \"x_axis\" : u\"--\",\n#                              \"empty\"  : u\"  \"}\n        #self.skin = skinfile\n        self.fx_list = []\n        self.funct_cnt = len(self.fx_list)\n        seq = Letter.caps_gen()\n        Letter.pass_no = 1\n        self.letters = [next(seq) for _ in range(self.size)]\n        #self.label = \"goban #%d (%d \u00d7 %d)\" % (self.__class__.count, BOARD_SIZE\n#, B\n#OARD_SIZE)\n        self.label += ' ({0} \u00d7 {0})'.format(self.size)\n\n    def __str__(self):\n        \"\"\"this would be better if the cursor could be hidden\"\"\"\n        string = '\\n' #'{}\\n'.format(self.ul_label(self.size * 2 + 5))\n        string += ' ' * 3\n        for i in range(self.size):\n            string += '{:>2s}'.format(self.letters[i])\n        string += \"\\n\"\n        for rank in range(self.size):\n            string += ('%3d ' % (self.size - rank))\n            for col in range(self.size):\n                xy_coords = col - self.max_domain, self.max_domain - rank\n                if xy_coords == tuple(self.cursor):\n                    string += '\\b('\n                tag_list = self.skin_dict.keys()\n                tag = self.plane[col][rank].marker\n                if sys.version_info.major == 2:\n                    if tag in tag_list:\n                        string += self.skin_dict[tag].encode('utf-8')\n                    else: string += '??'.encode('utf-8')\n                elif sys.version_info.major == 3:\n                    if tag in tag_list:\n                        string += self.skin_dict[tag]\n                    else: string += '??'\n                if xy_coords == tuple(self.cursor):\n                    string += '\\b)'\n            if self.size > 9:\n                string += ('{:2d} '.format(self.size - rank))\n            else: string += ('{:1d} '.format(self.size - rank))\n            string += '\\n'\n        string += ' '* 3\n        for i in range(self.size):\n            string += '{:>2s}'.format(self.letters[i])\n        string += '\\n'\n        return string\n\n\n     ###########\n     #  PLANE  #\n     ###########\n    #@staticmethod\n    #def is_hoshi(self, x, y):\n    #    \"\"\"\n    #    don't show \"cross-hairs\"\n    #    returns False\n    #    \"\"\"\n    #    return False\n\n    def fill(self, color='empty'):\n        \"\"\"\n        some problems under python3?\n        \"\"\"\n        for col in range(-self.max_domain, self.max_domain + 1):\n            for rank in range(-self.max_domain, self.max_domain + 1):\n                self.plot_point(col, rank, color)\n\n    def view_edit(self):  # , widget=None):\n        \"\"\"\n        Interactive wysiwyg editor\n\n        * When board size is even, rightmost column willaccept neither a  point\n        nor the cursor, but you can go past and back.\n        \"\"\"\n        while True:\n            try:\n                if self.sh_obj.interface == 'term':\n                    point = Terminal.make_page(\n                        'EDIT', self, self.pt_at_cursor)\n                else:\n                    self.sh_obj.msgtxt.set(self.__str__())\n                    point = self.pt_at_cursor()\n\n                if type(point) == Point:\n                    string = ''\n                    string += ('\\t' + str(point)) + '\\n'\n                    string += ('\\t[' + point.distance_str + ']') + '\\n'\n\n                    if self.sh_obj.interface == 'term':\n                        Terminal.output(string)\n                    #self.sh_obj.output(string)\n                    else:\n                        tk.Label(self.sh_obj.main_window, text=str(point))\n                        tk.Label(self.sh_obj.main_window, text='[{}]'.format(\n                            point.distance_str))\n                        #label1.pack()\n                        #label2.pack()\n\n                info_list = [\n                    'Use h, j, k, l to move the cursor',\n                    'b=black, w=white, x=erase, *=star',\n                    'Ctl-c to exit editor']\n                if self.cursor[0] >= -self.max_domain and\\\n                    self.cursor[0] <= self.max_domain and\\\n                    self.cursor[1] >= -self.max_domain and\\\n                    self.cursor[1] <= self.max_domain:\n                    pass\n                else:\n                    rescue_key = 'l or h'\n                    if self.cursor[1] < -self.max_domain or\\\n                        self.cursor[1] > self.max_domain:\n                        rescue_key = 'j or k'\n                    info_list[0] = 'Press {} to reveal cursor'.format(\n                        rescue_key)\n\n                info = ItemList(info_list)\n                if self.sh_obj.interface == 'term':\n                    Terminal.output(info)\n                else:\n                    tk.Label(self.sh_obj.main_window, text=str(info)).pack()\n\n                char = Terminal.get_keypress()\n                if char == 'h':\n                    if self.cursor[0] > -self.max_domain:\n                        self.cursor[0] -= 1\n                    else:\n                        self.cursor[0] += self.size\n                elif char == 'l':\n                    if self.size % 2 == 0:\n                        self.max_domain += 1\n                    if self.cursor[0] < self.max_domain:\n                        self.cursor[0] += 1\n                    else:\n                        self.cursor[0] -= self.size\n                    if self.size % 2 == 0:\n                        self.max_domain += 1\n                elif char == 'j':\n                    if self.cursor[1] > -1 * self.max_domain:\n                        self.cursor[1] -= 1\n                    else:\n                        self.cursor[1] += self.size\n                elif char == 'k':\n                    if self.cursor[1] < self.max_domain:\n                        self.cursor[1] += 1\n                    else:\n                        self.cursor[1] -= self.size\n                elif char == 'b':\n                    self.plot_point(self.cursor[0], self.cursor[1], 'black')\n                elif char == 'w':\n                    self.plot_point(self.cursor[0], self.cursor[1], 'white')\n                elif char == 'x' or char == '\\x7f':\n                    self.plot_point(self.cursor[0], self.cursor[1], 'empty')\n                elif char == '*':\n                    self.plot_point(self.cursor[0], self.cursor[1], 'star')\n\n            except KeyboardInterrupt:\n                Terminal.output('')\n                break\n\n\n     ############\n     #  POINTS  #\n     ############\n    def color_chooser(self):\n        \"\"\"\n        set the point's color tag\n        \"\"\"\n        colors = ['black', 'white', 'empty', 'star']\n        if self.sh_obj.interface == 'term':\n            return Terminal.make_page(\n                'color-chooser', str(self) + '\\nPress Ctrl-c to cancel',\n                self.prompt_color)\n        else:\n            opt_no = self.sh_obj.list_menu(\n                PlainList(colors), 'Choose a color', 'Color Chooser')\n            index = opt_no - 1\n            return colors[index]\n\n    def prompt_color(self):\n        \"\"\"\n        Prompt the user to choose a color; this should be in a go_stone class\n        \"\"\"\n        choice = -1\n        while choice != 'b' and choice != 'w' and choice != 'x' and\\\n            choice != '*':\n            choice = self.sh_obj.get_keypress(\n                '\\nPick up a color\\n(b=black, w=white, x=erase, *=star)')\n        if choice == 'b':\n            return 'black'\n        elif choice == 'w':\n            return 'white'\n        elif choice == 'x':\n            return 'empty'\n        elif choice == '*':\n            return 'star'\n        else:\n            Terminal.output('Cancelling operation')\n            return -1\n\n    def prompt_point(self, color):\n        \"\"\"\n        Prompt user for x,y coordinates and plot point.\n        \"\"\"\n        pair_x, pair_y = eval(self.sh_obj.input('(x, y):'))\n        self.plot_point(pair_x, pair_y, color)\n\n    def plot_point(self, x_val, y_val, color='black'):\n        \"\"\"\n        Plot a point of specified color at x, y\n        \"\"\"\n        if color == 'empty':\n            self.erase_point(x_val, y_val)\n        elif x_val >= (-self.max_domain) and x_val <= self.max_domain and\\\n             y_val >= (-self.max_domain) and y_val <= self.max_domain:\n\n            # try: #WHAT'S THE ERROR?\n            if color == 'black' or color == 'white' or color == 'star':\n                self.plane[int(round(x_val) + self.max_domain)][int(\n                    self.max_domain - round(y_val))].marker = color\n            # except:\n            #    pass\n\n    def erase_point(self, x_val, y_val):\n        \"\"\"\n        Erase point at x, y.\n        \"\"\"\n        x_val = int(round(x_val))\n        y_val = int(round(y_val))\n\n        #if self.is_hoshi(x_val, -y_val):\n        #    self.plane[x_val + self.max_domain][-y_val +\\\n        #        self.max_domain].marker = 'hoshi'\n        #el\n        if (x_val != 0) and (-y_val != 0):\n            self.plane[x_val + self.max_domain]\\\n                [-y_val + self.max_domain].marker = 'empty'\n        elif (x_val == 0) and (-y_val != 0):\n            self.plane[x_val + self.max_domain]\\\n                [-y_val + self.max_domain].marker = 'y_axis'\n        elif (-y_val == 0) and (x_val != 0):\n            self.plane[x_val + self.max_domain]\\\n                [-y_val + self.max_domain].marker = 'x_axis'\n        else: self.plane[x_val + self.max_domain]\\\n            [-y_val + self.max_domain].marker = 'origin'\n\n    def print_points(self):\n        \"\"\"\n        Print the graph as a table of ordered pairs.  Used for debugging or non-\n        Euclidean space.\n        \"\"\"\n        for y_val in range(self.size):\n            for x_val in range(self.size):\n                if self.pt_at_cursor() and self.plane[x_val][y_val] ==\\\n                    self.pt_at_cursor():\n                    easycat.write('{:>9}'.format('>{}<'.format(\n                        self.plane[x_val][y_val])))\n                elif self.pt_at_cursor() and self.plane[x_val][y_val] ==\\\n                    self.pt_at_cursor():\n                    easycat.write('{:>9}'.format(self.plane[x_val][y_val]))\n                else:\n                    easycat.write('{:>8} '.format(self.plane[x_val][y_val]))\n            Terminal.output('')\n\n    def pt_at_cursor(self):\n        \"\"\"\n        returns Point object where cursor is located\n        \"\"\"\n        if self.cursor[0] <= self.max_domain and\\\n           self.cursor[0] >= -self.max_domain and\\\n           self.cursor[1] <= self.max_domain and\\\n           self.cursor[1] >= -self.max_domain:\n\n            # not sure what this error is about.\n            # this is an overly-lazy fix.\n            return self.plane[int(self.cursor[0] + self.max_domain)]\\\n                [int(self.max_domain - self.cursor[1])]\n\n    def indices_to_point(self, index1, index2):\n        \"\"\"Maybe the reverse would be more useful.\n        Also, give it the ability to take either\n        a tuple or pair of args.\n        \"\"\"\n        return Point(index1 - self.max_domain, self.max_domain - index2)\n\n\n     #################\n     #  POLYNOMIALS  #\n     #################\n    def list_functs(self):\n        \"\"\"\n        Currently lists all attached polynomials; add ability to list\n        'auto-shapes, etc.'\n        \"\"\"\n        enum = Enumeration(self.fx_list, 'attached functions')\n        if self.sh_obj == 'term':\n            Terminal.output(enum)\n            self.sh_obj.wait()\n        else:\n            # change this\n            self.sh_obj.wait(str(enum))\n\n    def add_polynomial(self):\n        \"\"\"\n        Use the Polynom.wizard() and attach result to the goban\n        \"\"\"\n        try:\n            color = self.color_chooser()\n            f_x = Polynom([])\n            f_x.wizard(sh_class=self.sh_obj)\n\n            # Attach function\n            if self.sh_obj == 'term':\n                self.sh_obj.text_splash(\n                    'Preview goes here', flashes=3, duration=.5)\n                self.sh_obj.output(\"\\nAttach '{}'?\".format(f_x))\n                ans = self.sh_obj.get_keypress()\n            else: ans = 'y'\n            if ans == 'y' and color != -1:\n                self.plot_funct(f_x, color)\n                self.fx_list.append(f_x)\n        except (KeyboardInterrupt, OverflowError):\n            pass\n\n    def plot_funct(self, funct_a, color):\n        \"\"\"\n        Any numerical function will do:\n        native python functions, Polynom objects, or whatever....\n        \"\"\"\n        self.funct_cnt += 1\n        for var in range(-self.max_domain, self.max_domain + 1):\n            try:\n                self.plot_point(var, int(round(funct_a(var))), color)\n            except (TypeError, ValueError):\n                continue\n\n     ############\n     #  SHAPES  #\n     ############\n    def prompt_circle(self, color):\n        \"\"\"\n        Prompt user for specifications and draw circle\n        \"\"\"\n        radius = float(self.sh_obj.input('radius: '))\n        center = 0, 0\n        center = eval(self.sh_obj.input('center (x, y): '))\n        self.add_ellipse(radius, radius, color, (float(center[0]), float(\n            center[1])))\n\n    def prompt_ellipse(self, color):\n        \"\"\"\n        Prompt user for attributes and draw ellipse\n        \"\"\"\n        semiaxes = eval(self.sh_obj.input('semiaxes (H, V): '))\n        center = eval(self.sh_obj.input('center (x, y): '))\n        self.add_ellipse(float(semiaxes[0]), float(semiaxes[1]), color, (float(\n            center[0]), float(center[1])))\n\n    def add_ellipse(self, semiaxis_a=None, semiaxis_b=None, color='black',\n                    center=(0, 0)):\n        \"\"\"\n        draw ellipse on the plane; use a Point object instead of a tuple\n        \"\"\"\n        if not semiaxis_a:\n            semiaxis_a = self.max_domain\n        if not semiaxis_b:\n            semiaxis_b = semiaxis_a\n        self.funct_cnt += 1\n        for x_val in range(-1 * self.max_domain, self.max_domain + 1):\n            try:\n                self.plot_point(x_val, int(center[1] + round(math.sqrt(\n                    semiaxis_b ** 2 - semiaxis_b ** 2 * (x_val - center[0]) **\n                    2 \/ semiaxis_a ** 2))), color)\n            except ZeroDivisionError:\n                pass\n            except ValueError:\n                pass\n            try:\n                self.plot_point(x_val, int(center[1] - round(math.sqrt(\n                    semiaxis_b ** 2 - semiaxis_b ** 2 * (x_val - center[0]) **\n                    2 \/ semiaxis_a ** 2))), color)\n            except ZeroDivisionError:\n                pass\n            except ValueError:\n                pass\n\n    def prompt_wave(self, color):\n        \"\"\"\n        Prompt user for attributes, and draw sine wave on plane.\n        \"\"\"\n        self.add_sinewave(\n            float(self.sh_obj.input('wavelength: ')),\n            float(self.sh_obj.input('amplitude: ')),\n            float(self.sh_obj.input('h_shift: ')),\n            color)\n\n    def add_sinewave(self, wlength=None, amplitude=None, h_shift=0,\n                     color='black'):\n        \"\"\"\n        Draw sine wave onto plane.\n        \"\"\"\n        if wlength is None:\n            wlength = (2 * self.max_domain)\n        if amplitude is None:\n            amplitude = self.max_domain\n        for x_val in range(-1 * self.max_domain, self.max_domain + 1):\n            try:\n                self.plot_point(\n                    x_val,\n                    int(round(amplitude * math.sin(\n                        2.0 * x_val * math.pi \/ wlength - (h_shift\/math.pi)))),\n                    color)\n            except ZeroDivisionError:\n                pass\n\n\n     ###########\n     #  FILES  #\n     ###########\n    def write_sgf(self, basename):\n        \"\"\"\n        Save the current board position as SGF.\n        \"\"\"\n        #header = {'GM':1, 'SZ':self.BOARD_SIZE, 'KM':6.5}\n\n        #Generate string\n        sequence = ''\n        for cols in range(self.size):\n            for rows in range(self.size):\n                if   self.plane[rows][cols].marker == 'white':\n                    sequence += ' AW[%s%s]' % (chr(rows+97), chr(cols+97))\n                elif self.plane[rows][cols].marker == 'black':\n                    sequence += ' AB[%s%s]' % (chr(rows+97), chr(cols+97))\n\n        #Write to file\n        if sys.version_info.major == 3:\n            self._save(\n                basename,\n                'sgf',\n                lambda f: f.write(\n                    bytes('(;GM[1] SZ[{}] KM[6.5] AP[go_test.py] {} ;)'.format(\n                        self.size, sequence), 'UTF-8')))\n        elif sys.version_info.major == 2:\n            self._save(basename, 'sgf', lambda f: f.write(\n                '(;GM[1] SZ[{}] KM[6.5] AP[go_test.py] {} ;)'.format(\n                    self.size, sequence)))\n\n    def save_skin(self, basename):\n        \"\"\"\n        Save skin as JSON\n        \"\"\"  # error\n        #return_val = self._save(basename, 'json', lambda: json.dump(\n        #    self.skin_dict, basename + '.json', indent=2))\n        # try:\n        json.dump(self.skin_dict, basename + '.json', indent=2)\n        # except:  # No idea what kind...\n        #    return -1\n        # else:         # ? ?\n        return 0  # ? purely a guess\n"}},"msg":"prevents code injection by using eval() safely"}},"https:\/\/github.com\/elucidant\/super_simple_siem":{"94d15a7c3d6832c26ea8247999ad1c798d5e10ae":{"url":"https:\/\/api.github.com\/repos\/elucidant\/super_simple_siem\/commits\/94d15a7c3d6832c26ea8247999ad1c798d5e10ae","html_url":"https:\/\/github.com\/elucidant\/super_simple_siem\/commit\/94d15a7c3d6832c26ea8247999ad1c798d5e10ae","message":"Add support for whitelisting\n\nmakealerts checks against a whitelist lookup table with row indicating\ncriteria for whitelisting alerts.  If an alert is whitelisted, it is not\nsaved in the KVStore. Sufficient information should be available in the\nsuper simple siem log to find out which rule was applied.\n\nRules are parsed using a parsec style combinator library, this should\nprevent code injection (it does not use python's eval).\n\nAdded a Health dashboard with stats makealerts.","sha":"94d15a7c3d6832c26ea8247999ad1c798d5e10ae","keyword":"eval injection prevent","diff":"diff --git a\/bin\/alert_collection.py b\/bin\/alert_collection.py\nindex 91151a0..bb47eea 100755\n--- a\/bin\/alert_collection.py\n+++ b\/bin\/alert_collection.py\n@@ -89,7 +89,8 @@ def insert(self, record,\n                 elif days:\n                     delta_seconds = int(days.group(1)) * 3600 * 24\n                 else:\n-                    if logger: logger.error(\"Cannot parse \" + combine_window + \", default to 24 hours\")\n+                    if logger:\n+                        logger.error(\"sid=%s,message=\\\"Cannot parse combine_window %s, default to 24h\\\"\", sid, combine_window)\n                     delta_seconds = 3600 * 24\n                 cutoff = alert_record['time'] - delta_seconds\n                 fields = combine.split(\",\")\n@@ -140,7 +141,7 @@ def same_fields(old, new):\n         else:\n             if logger:\n                 missing = set([event_time, entity, alert_type]) - set(record.keys())\n-                logger.warning('Missing fields in record: %s', missing)\n+                logger.error('sid=%s,message=\"Missing fields in record: %s\"', sid, missing)\n                 insert_stats.errors += 1\n \n     # CSV file with a single json column with the json as exported by | listalerts json=json\n@@ -165,7 +166,7 @@ def replace(self, alert_record, notes=None, logger=None, sid=None, username=None\n                     })\n             self.coll.data.update(key, json.dumps(alert_record))\n         else:\n-            logger.warning('Cannot find alert: %s', str(key))\n+            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))\n \n     def update(self, key, action, status, notes=None, logger=None, sid=None, username=None):\n         if key:\n@@ -180,13 +181,13 @@ def update(self, key, action, status, notes=None, logger=None, sid=None, usernam\n                 })\n             self.coll.data.update(key, json.dumps(alert_record))\n         else:\n-            logger.warning('Cannot find alert: %s', str(key))\n+            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))\n \n     def delete(self, key, logger=None):\n         if key:\n             self.coll.data.delete_by_id(key)\n         else:\n-            logger.warning('Cannot find alert: %s', str(key))\n+            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))\n \n     def find(self, type, entity, time_gte):\n         \"\"\"Find records for the type, entity and time (int).\"\"\"\n@@ -268,5 +269,7 @@ def __init__(self):\n         self.duplicate = 0\n         self.merged = 0\n         self.errors = 0\n+        self.whitelisted = 0\n     def __str__(self):\n-        return 'inserted=%d, duplicate=%d, merged=%d, errors=%d' % (self.inserted, self.duplicate, self.merged, self.errors)\n+        return 'inserted=%d,duplicate=%d,merged=%d,errors=%d,whitelisted=%d' % (\n+        self.inserted, self.duplicate, self.merged, self.errors, self.whitelisted)\ndiff --git a\/bin\/criteria_parser.py b\/bin\/criteria_parser.py\nnew file mode 100644\nindex 0000000..33d6dd6\n--- \/dev\/null\n+++ b\/bin\/criteria_parser.py\n@@ -0,0 +1,267 @@\n+from parsec.src.parsec import *\n+\n+class Context:\n+    def __init__(self, record):\n+        self.record = record\n+        self.debug = []\n+\n+class Expr:\n+    def evaluate(self, context):\n+        raise NotImplementedError(\"subclass must override evaluate\")\n+    def ast(self, indent = \"\"):\n+        raise NotImplementedError(\"subclass must override evaluate\")\n+\n+class LiteralExpr(Expr):\n+    def __init__(self, value):\n+        self.value = value\n+    def evaluate(self, context):\n+        return self.value\n+    def __str__(self):\n+        return \"LiteralExpr(\" + str(self.value) + \")\"\n+    def ast(self, indent = \"\"):\n+        return indent + str(self.value)\n+\n+class FieldExpr(Expr):\n+    def __init__(self, field):\n+        self.field = field\n+    def evaluate(self, context):\n+        if self.field in context.record:\n+            context.debug.append(\"record['%s'] => %s\" % (self.field, context.record[self.field]))\n+            return context.record[self.field]\n+        else:\n+            context.debug.append(\"record['%s'] => None\" % self.field)\n+            return None\n+    def __str__(self):\n+        return \"FieldExpr(\" + self.field + \")\"\n+    def ast(self, indent = \"\"):\n+        return indent + \"record['%s']\" % self.field\n+\n+class MatchExpr(Expr):\n+    def __init__(self, functionName, patternExpr, stringExpr):\n+        self.functionName = functionName\n+        self.patternExpr = patternExpr\n+        self.stringExpr = stringExpr\n+    def evaluate(self, context):\n+        import re\n+        pattern = self.patternExpr.evaluate(context)\n+        s = self.stringExpr.evaluate(context)\n+        if self.functionName == 'search':\n+            match_obj = re.search(pattern, s)\n+        elif self.functionName == 'match':\n+            match_obj = re.match(pattern, s)\n+        else:\n+            raise RuntimeError('invalid function name: %s' % self.functionName)\n+        context.debug.append(\"%s(%s, %s) => %s\" % (self.functionName, pattern, s, str(match_obj)))\n+        return match_obj is not None\n+    def __str__(self):\n+        return \"MatchExpr(%s,  %s, %s)\" % (self.functionName, self.patternExpr, self.stringExpr)\n+    def ast(self, indent = \"\"):\n+        inner_indent = indent + \"  \"\n+        return (\n+            indent + \"(\" + self.functionName + \"\\n\"\n+            + self.patternExpr.ast(inner_indent) + \"\\n\"\n+            + self.stringExpr.ast(inner_indent) + \"\\n\"\n+            + indent + \")\"\n+        )\n+\n+class ComparisonExpr(Expr):\n+    def __init__(self, leftExpr, rightExpr, opStr, compareFun):\n+        self.leftExpr = leftExpr\n+        self.rightExpr = rightExpr\n+        self.opStr = opStr\n+        self.compareFun = compareFun\n+    def evaluate(self, context):\n+        import numbers\n+        left = self.leftExpr.evaluate(context)\n+        right = self.rightExpr.evaluate(context)\n+        if isinstance(left, numbers.Number) and not isinstance(right, numbers.Number):\n+            right = float(right)\n+        if not isinstance(left, numbers.Number) and isinstance(right, numbers.Number):\n+            left = float(left)\n+        result = self.compareFun(left, right)\n+        context.debug.append(\"%s %s %s => %s\" % (left, self.opStr, right, result))\n+        return result\n+    def __str__(self):\n+        return \"ComparisonExpr(\" + str(self.leftExpr) + \", \" + str(self.rightExpr) + \", \" + self.opStr + \")\"\n+    def ast(self, indent = \"\"):\n+        inner_indent = indent + \"  \"\n+        return (\n+            indent + \"(\" + self.opStr + \"\\n\"\n+            + self.leftExpr.ast(inner_indent) + \"\\n\"\n+            + self.rightExpr.ast(inner_indent) + \"\\n\"\n+            + indent + \")\"\n+        )\n+\n+class CriteriaParser:\n+\n+    def __init__(self):\n+        self.whitespace = regex(r'\\s+', re.MULTILINE)\n+        self.comment = regex(r'#.*')\n+        self.ignore =  many((self.whitespace | self.comment))\n+\n+        # setup mutually referencing parsers as dummy parser where the fn parameter is replaced afterwards\n+        self.paren_comparison = Parser(lambda x: x)\n+        self.comparison = Parser(lambda x: x)\n+\n+        number_int = self.lexeme(regex(r'\\d+')).parsecmap(lambda s: LiteralExpr(int(s)))\n+        number_float = self.lexeme(regex(r'\\d+\\.\\d+')).parsecmap(lambda s: LiteralExpr(float(s)))\n+        self.number = number_float | number_int\n+\n+        def any_char_fn(text, index=0):\n+            if index < len(text):\n+                return Value.success(index + 1, text[index])\n+            else:\n+                return Value.failure(index, 'any_char')\n+        any_char = Parser(any_char_fn)\n+        shortstringchar_double = none_of('\"\\n\\\\')\n+        shortstringchar_single = none_of(\"'\\n\\\\\")\n+        escapeseq = string('\\\\') >> any_char\n+        shortstringitem_single = shortstringchar_single | escapeseq.parsecmap(self.unescape)\n+        shortstring_single = (string(\"'\") >> many(shortstringitem_single)) << string(\"'\")\n+        shortstringitem_double = shortstringchar_double | escapeseq.parsecmap(self.unescape)\n+        shortstring_double = (string('\"') >> many(shortstringitem_double)) << string('\"')\n+        self.shortstring = (shortstring_single ^ shortstring_double).parsecmap(lambda arr: LiteralExpr(''.join(arr)))\n+\n+        raw_escapeseq = (string('\\\\') + any_char).parsecmap(lambda x: x[0] + x[1])\n+        raw_shortstringitem_single = shortstringchar_single | raw_escapeseq\n+        raw_shortstring_single = (string(\"r'\") >> many(raw_shortstringitem_single)) << string(\"'\")\n+        raw_shortstringitem_double = shortstringchar_double | raw_escapeseq\n+        raw_shortstring_double = (string('r\"') >> many(raw_shortstringitem_double)) << string('\"')\n+        self.raw_shortstring = (raw_shortstring_single ^ raw_shortstring_double).parsecmap(lambda arr: LiteralExpr(''.join(arr)))\n+\n+        self.literal = self.raw_shortstring ^ self.number ^ self.shortstring\n+\n+        self.fieldname = regex(\"[A-Z_a-z][0-9A-Za-z_-]*\").parsecmap(lambda s: FieldExpr(s))\n+\n+        self.term = self.lexeme(self.literal ^ self.fieldname)\n+\n+        function_name = self.lexeme(string('search')) ^ self.lexeme(string('match'))\n+        function_call_args = separated(self.term, self.lexeme(string(',')), mint=2, maxt=2, end=None)\n+        self.function_call = ((function_name << self.lexeme(string('(')))\n+                + (function_call_args << self.lexeme(string(')')))).parsecmap(\n+            lambda x: MatchExpr(x[0], x[1][0], x[1][1])\n+        )\n+\n+        op_equal = ((self.term << self.lexeme(string(\"==\"))) + self.term).parsecmap(\n+            lambda t: ComparisonExpr(t[0], t[1], \"==\", lambda x, y: x == y)\n+        )\n+        op_not_equal = ((self.term << self.lexeme(string(\"!=\"))) + self.term).parsecmap(\n+            lambda t: ComparisonExpr(t[0], t[1], \"!=\", lambda x, y: x != y)\n+        )\n+        op_gt = ((self.term << self.lexeme(string(\">\"))) + self.term).parsecmap(\n+            lambda t: ComparisonExpr(t[0], t[1], \">\", lambda x, y: x > y)\n+        )\n+        op_ge = ((self.term << self.lexeme(string(\">=\"))) + self.term).parsecmap(\n+            lambda t: ComparisonExpr(t[0], t[1], \">=\", lambda x, y: x >= y)\n+        )\n+        op_lt = ((self.term << self.lexeme(string(\"<\"))) + self.term).parsecmap(\n+            lambda t: ComparisonExpr(t[0], t[1], \"<\", lambda x, y: x < y)\n+        )\n+        op_le = ((self.term << self.lexeme(string(\"<=\"))) + self.term).parsecmap(\n+            lambda t: ComparisonExpr(t[0], t[1], \"<=\", lambda x, y: x <= y)\n+        )\n+        self.comparison.fn = op_equal ^ op_not_equal ^ op_ge ^ op_le ^ op_gt ^ op_lt ^ self.paren_comparison ^ self.function_call\n+\n+        self.conjunction = ((self.comparison << self.lexeme(string(\"and\"))) + self.comparison).parsecmap(\n+            lambda t: ComparisonExpr(t[0], t[1], \"and\", lambda x, y: x and y)\n+        ) ^ self.comparison\n+\n+        self.disjunction = ((self.conjunction << self.lexeme(string(\"or\"))) + self.conjunction).parsecmap(\n+            lambda t: ComparisonExpr(t[0], t[1], \"or\", lambda x, y: x or y)\n+        ) ^ self.conjunction\n+\n+        self.paren_comparison.fn = (self.lexeme(string('(')) >> self.disjunction) << self.lexeme(string(')'))\n+\n+        self.expression = self.ignore >> self.disjunction\n+\n+    def unescape(self, c):\n+        if c == '\\n':\n+            return ''\n+        elif c == 'a':\n+            return '\\a'\n+        elif c == 'b':\n+            return '\\b'\n+        elif c == 'f':\n+            return '\\f'\n+        elif c == 'n':\n+            return '\\n'\n+        elif c == 'r':\n+            return '\\r'\n+        elif c == 't':\n+            return '\\t'\n+        elif c == 'v':\n+            return '\\v'\n+        elif c == '\\\\':\n+            return '\\\\'\n+        else:\n+            return '\\\\' + c\n+\n+    # lexer for words, skip all ignored characters.\n+    def lexeme(self, p):\n+        return p << self.ignore\n+\n+    def parse(self, criteria):\n+        return self.expression.parse_strict(criteria)\n+\n+    def test(self, parser, s):\n+        result = parser.parse_strict(s)\n+        print result\n+\n+    def test_eval(self, criteria, record, expected, debug=False):\n+        expr = self.expression.parse_strict(criteria)\n+        c = Context(record)\n+        v = expr.evaluate(c)\n+        #print \"criteria: %s => %s\" % (criteria, \"\\n\" + expr.ast())\n+        if v != expected or debug:\n+            print \"ERROR: %s evaluated on %s => got %s expected %s\" % (expr, c.record, v, expected)\n+            print \"DEBUG: %s\" % str(c.debug)\n+\n+    def test_string(self, text_to_parse, expected_string):\n+        p = self.literal.parse_strict(text_to_parse)\n+        if type(p.value) == str and p.value == expected_string:\n+            print 'STR: SUCCESS on %s' % text_to_parse\n+        else:\n+            print 'STR: FAIL    on %s expected %s, got %s' % (text_to_parse, expected_string, p.value)\n+\n+def main():\n+    print 'test_parsec'\n+    cp = CriteriaParser()\n+    cp.test_string(\"'abc'\", \"abc\")\n+    cp.test_string(\"'ab\\\\tc'\", \"ab\\tc\")\n+    cp.test_string('\"ab\\\\\\\\c\"', \"ab\\\\c\")\n+    cp.test_string(\"r'abc'\", \"abc\")\n+    cp.test_string(\"r'ab\\\\tc'\", \"ab\\\\tc\")\n+    cp.test_string('r\"ab\\\\\\\\c\"', \"ab\\\\\\\\c\")\n+    cp.test(cp.term, '123')\n+    cp.test(cp.term, '3.14')\n+    cp.test(cp.function_call, 'search(\"pattern\", \"foo\")')\n+    cp.test_eval('user == \"admin\"', {'user': \"admin\"}, True)\n+    cp.test_eval('user == \"admin1\"', {'user': \"admin\"}, False)\n+    cp.test_eval('count > 10', {'count': \"15\"}, True)\n+    cp.test_eval('count > 10', {'count': \"5\"}, False)\n+    cp.test_eval('count >= 10', {'count': \"10\"}, True)\n+    cp.test_eval('count >= 10', {'count': \"9\"}, False)\n+    cp.test_eval('count <= 10', {'count': \"10\"}, True)\n+    cp.test_eval('count <= 10', {'count': \"11\"}, False)\n+    cp.test_eval('count != 10', {'count': \"11\"}, True)\n+    cp.test_eval('count != 10', {'count': \"10\"}, False)\n+    cp.test_eval('  1 == 1 and 2 == 2', {}, True)\n+    cp.test_eval('1 == 1 and 2 == 2', {}, True)\n+    cp.test_eval('1 == 1 and 2 == 3', {}, False)\n+    cp.test_eval('1 == 1 and 2 == 2 or \"foo\" == \"foo\"', {}, True)\n+    cp.test_eval('1 == 1 and 2 != 2 or \"foo\" == \"foo\"', {}, True)\n+    cp.test_eval('1 == 1 and 2 != 2 or \"foo\" == \"bar\"', {}, False)\n+    cp.test_eval('1 == 1 and 2 != 2 or \"foo\" == \"bar\"', {}, False)\n+    cp.test_eval('1 == 1 and (2 != 2 or \"foo\" == \"foo\")', {}, True)\n+    cp.test_eval('match(\"fo+\", \"foo\")', {}, True)\n+    cp.test_eval('match(\"fo+\", \"bar\")', {}, False)\n+    cp.test_eval('match(\"admin*\", user)', {'user': \"admin1\"}, True)\n+    cp.test_eval('match(\"admin*\", user)', {'user': \"user\"}, False)\n+    cp.test_eval('match(\"admin*\", user) and count > 10', {'user': \"admin1\", \"count\": 15}, True)\n+    cp.test_eval(r'r\"192\\.168\" == \"192\\\\.168\"', {}, True)\n+    cp.test_eval(r'match(r\"192\\.168\\.\\d+\\.\\d+\", clientip)', {'clientip': \"192.168.1.1\"}, True)\n+    cp.test_eval(r'match(r\"10\\.10\\.\\d+\\.\\d+\", clientip)', {'clientip': \"192.168.1.1\"}, False)\n+\n+if __name__ == \"__main__\":\n+    main()\n+\ndiff --git a\/bin\/makealerts.py b\/bin\/makealerts.py\nindex c6e613d..28036c5 100755\n--- a\/bin\/makealerts.py\n+++ b\/bin\/makealerts.py\n@@ -20,7 +20,47 @@\n from splunklib.searchcommands import dispatch, StreamingCommand, Configuration, Option, validators\n import sys, json\n from splunklib.client import connect\n+from splunklib import results\n from alert_collection import AlertCollection, InsertStats\n+from criteria_parser import CriteriaParser, Context\n+import datetime\n+\n+class Whitelist:\n+    # assume we have the following fields:\n+    # start and end (in YYYY-MM-DD format): only apply alert if current date is between start and end\n+    # criteria (a boolean expression that will the following syntax):\n+    #   expression: '(' expression ')'\n+    #   expression: expression 'and' expression\n+    #   expression: expression 'or' expression\n+    #   expression: fieldname operator literal\n+    #   expression: fieldname 'matches' regular_expression\n+    #   fieldname: a string without space\n+    #   operator: '==' | '!=' | '>=' | '<=' | '>' | '<'\n+    #   literal: literal_string, literal_number\n+    #   literal_string: python-style string literal\n+    #   literal_number: python-style number literal\n+    #   regular_expression: python-style string literal\n+    def __init__(self, row):\n+        self.row = row\n+        self.name = row['name']\n+        self.type = row['type']\n+        self.start = datetime.datetime.strptime(row['start'], \"%Y-%m-%d\")\n+        self.end = datetime.datetime.strptime(row['end'], \"%Y-%m-%d\")\n+        self.criteria = None\n+\n+    def parse_criteria(self):\n+        cp = CriteriaParser()\n+        self.criteria = cp.parse(self.row['criteria'])\n+\n+    def __str__(self):\n+        return (\n+        \"Whitelist(name=\" + self.name + \", type=\" + self.type + \", start=\" + str(self.start) + \", end=\" + str(self.end)\n+            + \", criteria=\" + str(self.criteria) + \") parsed from \" + str(self.row)\n+        )\n+\n+    # Returns true if the alert described by the record is whitelisted\n+    def is_whitelisted(self, context):\n+        return self.criteria.evaluate(context)\n \n @Configuration()\n class MakeAlertsCommand(StreamingCommand):\n@@ -71,6 +111,30 @@ class MakeAlertsCommand(StreamingCommand):\n     def __init__(self):\n         super(MakeAlertsCommand, self).__init__()\n         self.insert_stats = InsertStats()\n+        self.whitelist = []\n+        self.whitelist_loaded = False\n+\n+    def load_whitelist(self, searchinfo):\n+        if not self.whitelist_loaded:\n+            self.whitelist_loaded = True\n+            service = connect(token=searchinfo.session_key, app=searchinfo.app)\n+            rr = results.ResultsReader(service.jobs.oneshot(\"| inputlookup whitelist\"))\n+            today = datetime.datetime.today()\n+            for result in rr:\n+                if isinstance(result, results.Message):\n+                    self.logger.error(\n+                    \"sid=%s,s3tag=whitelist,type=%s,message=%s\", searchinfo.sid, result.type, result.message)\n+                elif self.alert_type == result['type']:\n+                    try:\n+                        wl = Whitelist(result)\n+                        if today >= wl.start and today <= wl.end:\n+                            wl.parse_criteria()\n+                            self.whitelist.append(wl)\n+                    except Exception as e:\n+                        self.logger.error(\n+                        \"sid=%s,s3tag=whitelist,type=\\\"invalid whitelist\\\",message=\\\"%s\\\",record=%s\", searchinfo.sid,\n+                        str(e), str(result))\n+\n \n     def is_scheduled(self):\n         sid = self._metadata.searchinfo.sid\n@@ -78,7 +142,9 @@ def is_scheduled(self):\n \n     def stream(self, records):\n         #self.logger.info('MakeAlertsCommand: %s, type of record %s', self, type(records))  # logs command line\n-        self.logger.info('SEARCHINFO %s', self._metadata.searchinfo)\n+        #self.logger.info('SEARCHINFO %s', self._metadata.searchinfo)\n+\n+        self.load_whitelist(self._metadata.searchinfo)\n         sid = self._metadata.searchinfo.sid\n \n         if not self.interactive and not self.is_scheduled():\n@@ -88,32 +154,41 @@ def stream(self, records):\n             self.alerts = AlertCollection(self._metadata.searchinfo.session_key)\n \n         for record in records:\n-            self.alerts.insert(record,\n-                event_time=self.time,\n-                entity=self.entity,\n-                alert_type=self.alert_type,\n-                severity=self.severity,\n-                idfield=self.idfield,\n-                combine=self.combine,\n-                combine_window=self.combine_window,\n-                search_query=self._metadata.searchinfo.search,\n-                search_earliest=self._metadata.searchinfo.earliest_time,\n-                search_latest=self._metadata.searchinfo.latest_time,\n-                logger=self.logger,\n-                sid=sid,\n-                username=self._metadata.searchinfo.username,\n-                insert_stats=self.insert_stats)\n+            for wl in self.whitelist:\n+                context = Context(record)\n+                if wl.is_whitelisted(context):\n+                    self.insert_stats.whitelisted += 1\n+                    self.logger.info(\"sid=%s,s3tag=criteria,debug=\\\"%s\\\"\", self._metadata.searchinfo.sid, str(context.debug))\n+                    self.logger.info(\"sid=%s,s3tag=whitelisted,type=\\\"%s\\\",name=\\\"%s\\\"\", self._metadata.searchinfo.sid, wl.type, wl.name)\n+                    break\n+            else:\n+                self.alerts.insert(record,\n+                    event_time=self.time,\n+                    entity=self.entity,\n+                    alert_type=self.alert_type,\n+                    severity=self.severity,\n+                    idfield=self.idfield,\n+                    combine=self.combine,\n+                    combine_window=self.combine_window,\n+                    search_query=self._metadata.searchinfo.search,\n+                    search_earliest=self._metadata.searchinfo.earliest_time,\n+                    search_latest=self._metadata.searchinfo.latest_time,\n+                    logger=self.logger,\n+                    sid=sid,\n+                    username=self._metadata.searchinfo.username,\n+                    insert_stats=self.insert_stats)\n             yield record\n \n     def finish(self):\n         if self.interactive and (not self.is_scheduled()) and self.insert_stats.errors > 0:\n            self.write_error(\n-               \"There were {0} error(s) when trying to insert data, check logs with this search 'index=_internal MakeAlertsCommand source=*super_simple_siem.log WARNING'\",\n+               \"There were {0} error(s) when trying to insert data, check logs with this search 'index=_internal MakeAlertsCommand source=*super_simple_siem.log* ERROR'\",\n                self.insert_stats.errors)\n \n-        # only log stats when running from a scheduled search\n-        if self.is_scheduled():\n-            self.logger.info('finish: %s', str(self.insert_stats))\n+        self.logger.info('sid=%s,s3tag=stats,%s,whitelist=%s',\n+            self._metadata.searchinfo.sid,\n+            str(self.insert_stats),\n+            \"[\" + \";\".join(str(x) for x in self.whitelist) + \"]\")\n \n         try:\n             super(MakeAlertsCommand, self).finish()\ndiff --git a\/metadata\/default.meta b\/metadata\/default.meta\nindex 95c714c..1e29b14 100644\n--- a\/metadata\/default.meta\n+++ b\/metadata\/default.meta\n@@ -57,6 +57,9 @@ owner = admin\n [views\/documentation]\n owner = admin\n \n+[views\/health_stats]\n+owner = admin\n+\n [datamodels\/alertsmodel]\n access = read : [ * ], write : [ admin, power ]\n export = none\n@@ -74,8 +77,8 @@ owner = admin\n \n [lookups\/whitelist.csv]\n access = read : [ * ], write : [ admin, power ]\n-export = none\n-owner = admin\n+export = system\n+owner = nobody\n \n [transforms\/analysts]\n access = read : [ admin, power ], write : [ admin, power ]\n@@ -104,8 +107,8 @@ owner = admin\n \n [transforms\/whitelist]\n access = read : [ * ], write : [ admin, power ]\n-export = none\n-owner = admin\n+export = system\n+owner = nobody\n \n [searchbnf]\n export = system\n","files":{"\/bin\/alert_collection.py":{"changes":[{"diff":"\n                 elif days:\n                     delta_seconds = int(days.group(1)) * 3600 * 24\n                 else:\n-                    if logger: logger.error(\"Cannot parse \" + combine_window + \", default to 24 hours\")\n+                    if logger:\n+                        logger.error(\"sid=%s,message=\\\"Cannot parse combine_window %s, default to 24h\\\"\", sid, combine_window)\n                     delta_seconds = 3600 * 24\n                 cutoff = alert_record['time'] - delta_seconds\n                 fields = combine.split(\",\")\n","add":2,"remove":1,"filename":"\/bin\/alert_collection.py","badparts":["                    if logger: logger.error(\"Cannot parse \" + combine_window + \", default to 24 hours\")"],"goodparts":["                    if logger:","                        logger.error(\"sid=%s,message=\\\"Cannot parse combine_window %s, default to 24h\\\"\", sid, combine_window)"]},{"diff":"\n         else:\n             if logger:\n                 missing = set([event_time, entity, alert_type]) - set(record.keys())\n-                logger.warning('Missing fields in record: %s', missing)\n+                logger.error('sid=%s,message=\"Missing fields in record: %s\"', sid, missing)\n                 insert_stats.errors += 1\n \n     # CSV file with a single json column with the json as exported by | listalerts json=json\n","add":1,"remove":1,"filename":"\/bin\/alert_collection.py","badparts":["                logger.warning('Missing fields in record: %s', missing)"],"goodparts":["                logger.error('sid=%s,message=\"Missing fields in record: %s\"', sid, missing)"]},{"diff":"\n                     })\n             self.coll.data.update(key, json.dumps(alert_record))\n         else:\n-            logger.warning('Cannot find alert: %s', str(key))\n+            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))\n \n     def update(self, key, action, status, notes=None, logger=None, sid=None, username=None):\n         if key:\n","add":1,"remove":1,"filename":"\/bin\/alert_collection.py","badparts":["            logger.warning('Cannot find alert: %s', str(key))"],"goodparts":["            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))"]},{"diff":"\n                 })\n             self.coll.data.update(key, json.dumps(alert_record))\n         else:\n-            logger.warning('Cannot find alert: %s', str(key))\n+            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))\n \n     def delete(self, key, logger=None):\n         if key:\n             self.coll.data.delete_by_id(key)\n         else:\n-            logger.warning('Cannot find alert: %s', str(key))\n+            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))\n \n     def find(self, type, entity, time_gte):\n         \"\"\"Find records for the type, entity and time (int).\"\"\"\n","add":2,"remove":2,"filename":"\/bin\/alert_collection.py","badparts":["            logger.warning('Cannot find alert: %s', str(key))","            logger.warning('Cannot find alert: %s', str(key))"],"goodparts":["            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))","            logger.error('sid=%s,message=\"Cannot find alert: %s\"', sid, str(key))"]},{"diff":"\n         self.duplicate = 0\n         self.merged = 0\n         self.errors = 0\n+        self.whitelisted = 0\n     def __str__(self):\n-        return 'inserted=%d, duplicate=%d, merged=%d, errors=%d' % (self.inserted, self.duplicate, self.merged, self.errors)\n+        return 'inserted=%d,duplicate=%d,merged=%d,errors=%d,whitelisted=%d' % (\n+        self.inserted, self.duplicate, self.merged, self.errors, self.whitelisted)","add":3,"remove":1,"filename":"\/bin\/alert_collection.py","badparts":["        return 'inserted=%d, duplicate=%d, merged=%d, errors=%d' % (self.inserted, self.duplicate, self.merged, self.errors)"],"goodparts":["        self.whitelisted = 0","        return 'inserted=%d,duplicate=%d,merged=%d,errors=%d,whitelisted=%d' % (","        self.inserted, self.duplicate, self.merged, self.errors, self.whitelisted)"]}],"source":"\n from __future__ import absolute_import, division, print_function, unicode_literals import sys, json from splunklib.client import connect from utils import parse import time class AlertCollection: app_name='super_simple_siem' coll_name ='alerts' def __init__(self, session_key): self.session_key=session_key self.alert_service=connect(token=session_key, app=self.app_name) self.coll=self.alert_service.kvstore[self.coll_name] def purge(self): self.coll.data.delete() def fix_field_name(self, field_name): import re return re.sub('[.$]', '', field_name) def insert(self, record, event_time='_time', entity='entity', alert_type='type', severity=None, idfield=None, combine=None, combine_window=None, search_query=None, search_earliest=None, search_latest=None, logger=None, sid=None, username=None, insert_stats=None): import re if insert_stats is None: insert_stats=InsertStats() if event_time in record and entity in record: alert_data={self.fix_field_name(key): value for key, value in record.iteritems() if key[0] !='_'} alert_record={ 'data': alert_data} alert_record['time']=float(record[event_time]) alert_record['entity']=record[entity] alert_record['type']=alert_type alert_record['status']='open' if severity: alert_record['severity']=record[severity] alert_record['analyst']=None alert_record['sid']=sid alert_record['search_query']=search_query alert_record['search_earliest']=search_earliest alert_record['search_latest']=search_latest alert_record['work_log']=[{ 'time': time.time(), 'action': 'create', 'notes': None, 'data':{}, 'analyst': username }] if combine and combine_window: hours=re.match(r'(\\d+)(hours?|h)', combine_window) days=re.match(r'(\\d+)(days?|d)', combine_window) if hours: delta_seconds=int(hours.group(1)) * 3600 elif days: delta_seconds=int(days.group(1)) * 3600 * 24 else: if logger: logger.error(\"Cannot parse \" +combine_window +\", default to 24 hours\") delta_seconds=3600 * 24 cutoff=alert_record['time'] -delta_seconds fields=combine.split(\",\") def same_fields(old, new): return reduce(lambda a, b: a and b, map(lambda f: old['data'][f]==new['data'][f], fields)) candidates0=[ a for a in self.find(alert_record['type'], alert_record['entity'], cutoff)] candidates1=[ a for a in candidates0 if(a['status']=='open' or a['status']=='assigned')] candidates2=[ a for a in candidates1 if same_fields(a, alert_record)] if candidates2: existing=candidates2[0] if existing['data']==alert_record['data']: record[idfield]=existing['_key'] insert_stats.duplicate +=1 if logger: logger.info('DUPLICATE alert_record: %s', alert_record) else: alert_data['sid']=sid existing['work_log'].insert(0,{ 'time': time.time(), 'action': 'combine', 'notes': None, 'data': alert_data, 'analyst': username }) self.coll.data.update(existing['_key'], json.dumps(existing)) insert_stats.merged +=1 else: alert_id=self.coll.data.insert(json.dumps(alert_record)) insert_stats.inserted +=1 if idfield: record[idfield]=alert_id['_key'] else: same_existing_alerts=[ a for a in self.find(alert_record['type'], alert_record['entity'], alert_record['time']) if a['data']==alert_record['data'] ] if not same_existing_alerts: alert_id=self.coll.data.insert(json.dumps(alert_record)) insert_stats.inserted +=1 if idfield: record[idfield]=alert_id['_key'] else: if idfield: record[idfield]=same_existing_alerts[0]['_key'] insert_stats.duplicate +=1 if logger: logger.info('DUPLICATE alert_record: %s', alert_record) else: if logger: missing=set([event_time, entity, alert_type]) -set(record.keys()) logger.warning('Missing fields in record: %s', missing) insert_stats.errors +=1 def csv_import(self, file_of_json_inside_csv): import csv with open(file_of_json_inside_csv, 'rb') as csvfile: rows=csv.reader(csvfile) for row in rows: if row[0] !='json': self.coll.data.insert(row[0]) def replace(self, alert_record, notes=None, logger=None, sid=None, username=None): key=alert_record.get(\"_key\") if key: if notes: alert_record['work_log'].insert(0,{ 'time': time.time(), 'action': 'update', 'notes': notes, 'data':{'sid': sid}, 'analyst': username }) self.coll.data.update(key, json.dumps(alert_record)) else: logger.warning('Cannot find alert: %s', str(key)) def update(self, key, action, status, notes=None, logger=None, sid=None, username=None): if key: alert_record=self.coll.data.query_by_id(key) alert_record['status']=status alert_record['work_log'].insert(0,{ 'time': time.time(), 'action': action, 'notes': notes, 'data':{'sid': sid}, 'analyst': username }) self.coll.data.update(key, json.dumps(alert_record)) else: logger.warning('Cannot find alert: %s', str(key)) def delete(self, key, logger=None): if key: self.coll.data.delete_by_id(key) else: logger.warning('Cannot find alert: %s', str(key)) def find(self, type, entity, time_gte): \"\"\"Find records for the type, entity and time(int).\"\"\" q={ 'type': type, 'entity': entity, 'time':{ '$gte': time_gte} } encoded=json.dumps(q) return self.coll.data.query(query=encoded) def list(self, status=[], type=[], severity=[], analyst=[], entity=[], earliest_time=None, latest_time=None, logger=None): if status or type or analyst or entity or severity: if status: qs={ '$or':[{ 'status': s} for s in status]} else: qs={} if type: qt={ '$or':[{ 'type': s} for s in type]} else: qt={} if analyst: qa={ '$or':[{ 'analyst': s} for s in analyst]} else: qa={} if entity: qe={ '$or':[{ 'entity': s} for s in entity]} else: qe={} if severity: qss={ '$or':[{ 'severity': s} for s in severity]} else: qss={} clauses=[] if qs: clauses.append(qs) if qt: clauses.append(qt) if qa: clauses.append(qa) if qe: clauses.append(qe) if qss: clauses.append(qss) if earliest_time: clauses.append({'time':{'$gte': earliest_time}}) if latest_time: clauses.append({'time':{'$lt': latest_time}}) encoded=json.dumps({ '$and': clauses}) res= self.coll.data.query(query=encoded) else: if earliest_time or latest_time: clauses=[] if earliest_time: clauses.append({'time':{'$gte': earliest_time}}) if latest_time: clauses.append({'time':{'$lt': latest_time}}) encoded=json.dumps({ '$and': clauses}) res= self.coll.data.query(query=encoded) else: res=self.coll.data.query() return sorted(res, key=lambda r: -r['time']) def dump(self): print(\"Collection data: %s\" % json.dumps(self.coll.data.query(), indent=1)) def main(): opts=parse(sys.argv[1:],{}, \".splunkrc\") service=connect(**opts.kwargs) alerts=AlertCollection(service.token) if 'purge' in sys.argv: alerts.purge() elif 'dump' in sys.argv: alerts.dump() elif 'import'in sys.argv and len(sys.argv)==3: filename=sys.argv[2] alerts.csv_import(filename) if __name__==\"__main__\": main() class InsertStats: def __init__(self): self.inserted=0 self.duplicate=0 self.merged=0 self.errors=0 def __str__(self): return 'inserted=%d, duplicate=%d, merged=%d, errors=%d' %(self.inserted, self.duplicate, self.merged, self.errors) ","sourceWithComments":"#!\/usr\/bin\/env python\n# coding=utf-8\n#\n# Copyright 2016-2017 Jean-Laurent Huynh\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport sys, json\nfrom splunklib.client import connect\nfrom utils import parse\nimport time\n\nclass AlertCollection:\n    app_name = 'super_simple_siem'\n    coll_name  = 'alerts'\n\n    def __init__(self, session_key):\n        self.session_key = session_key\n        self.alert_service = connect(token=session_key, app=self.app_name)\n        self.coll = self.alert_service.kvstore[self.coll_name]\n\n    def purge(self):\n        self.coll.data.delete()\n\n    def fix_field_name(self, field_name):\n        import re\n        return re.sub('[.$]', '', field_name)\n\n\n    # insert the record or combine with an existing record (if combine and combine_window allow it).\n    #   combining is based on type, entity, time and data subject to combine and combine_window constraints.\n    #   when combining, the main alert data is preserved, additional information is added to the work log.\n    # do no insert duplicate records (same type, entity, time and data).\n    # if logger is provided, log duplicate records for troubleshooting.\n    # if insert_stats is provided, tabulate counts of insert status\n    def insert(self, record,\n            event_time='_time',\n            entity='entity',\n            alert_type='type',\n            severity=None,\n            idfield=None,\n            combine=None,\n            combine_window=None,\n            search_query=None,\n            search_earliest=None,\n            search_latest=None,\n            logger=None, sid=None, username=None, insert_stats=None):\n        import re\n        if insert_stats is None:\n            insert_stats = InsertStats()\n        if event_time in record and entity in record:\n            alert_data = {self.fix_field_name(key): value for key, value in record.iteritems() if key[0] != '_'}\n            alert_record = { 'data': alert_data }\n            alert_record['time'] = float(record[event_time])\n            alert_record['entity'] = record[entity]\n            alert_record['type'] = alert_type\n            alert_record['status'] = 'open'\n            if severity:\n                alert_record['severity'] = record[severity]\n            alert_record['analyst'] = None\n            alert_record['sid'] = sid\n            alert_record['search_query'] = search_query\n            alert_record['search_earliest'] = search_earliest\n            alert_record['search_latest'] = search_latest\n            alert_record['work_log'] = [ {\n                'time': time.time(),\n                'action': 'create',\n                'notes': None,\n                'data': {},\n                'analyst': username\n            } ]\n            if combine and combine_window:\n                hours = re.match(r'(\\d+)(hours?|h)', combine_window)\n                days = re.match(r'(\\d+)(days?|d)', combine_window)\n                if hours:\n                    delta_seconds = int(hours.group(1)) * 3600\n                elif days:\n                    delta_seconds = int(days.group(1)) * 3600 * 24\n                else:\n                    if logger: logger.error(\"Cannot parse \" + combine_window + \", default to 24 hours\")\n                    delta_seconds = 3600 * 24\n                cutoff = alert_record['time'] - delta_seconds\n                fields = combine.split(\",\")\n                def same_fields(old, new):\n                   return reduce(lambda a, b: a and b, map(lambda f: old['data'][f] == new['data'][f], fields))\n                candidates0 = [ a for a in self.find(alert_record['type'], alert_record['entity'], cutoff) ]\n                candidates1 = [ a for a in candidates0 if (a['status'] == 'open' or a['status'] == 'assigned') ]\n                candidates2 = [ a for a in candidates1 if same_fields(a, alert_record) ]\n                if candidates2:\n                    existing = candidates2[0]\n                    if existing['data'] == alert_record['data']:\n                        record[idfield] = existing['_key']\n                        insert_stats.duplicate += 1\n                        if logger:\n                            logger.info('DUPLICATE alert_record: %s', alert_record)\n                    else:\n                        alert_data['sid'] = sid\n                        existing['work_log'].insert(0, {\n                                'time': time.time(),\n                                'action': 'combine',\n                                'notes': None,\n                                'data': alert_data,\n                                'analyst': username\n                            })\n                        self.coll.data.update(existing['_key'], json.dumps(existing))\n                        insert_stats.merged += 1\n                else:\n                    alert_id = self.coll.data.insert(json.dumps(alert_record))\n                    insert_stats.inserted += 1\n                    if idfield:\n                        record[idfield] = alert_id['_key']\n            else:\n                same_existing_alerts = [ a for a\n                    in self.find(alert_record['type'], alert_record['entity'], alert_record['time'])\n                    if a['data'] == alert_record['data']\n                ]\n                if not same_existing_alerts:\n                    alert_id = self.coll.data.insert(json.dumps(alert_record))\n                    insert_stats.inserted += 1\n                    if idfield:\n                        record[idfield] = alert_id['_key']\n                else:\n                    if idfield:\n                        record[idfield] = same_existing_alerts[0]['_key']\n                    insert_stats.duplicate += 1\n                    if logger:\n                        logger.info('DUPLICATE alert_record: %s', alert_record)\n        else:\n            if logger:\n                missing = set([event_time, entity, alert_type]) - set(record.keys())\n                logger.warning('Missing fields in record: %s', missing)\n                insert_stats.errors += 1\n\n    # CSV file with a single json column with the json as exported by | listalerts json=json\n    def csv_import(self, file_of_json_inside_csv):\n        import csv\n        with open(file_of_json_inside_csv, 'rb') as csvfile:\n            rows = csv.reader(csvfile)\n            for row in rows:\n                if row[0] != 'json':\n                    self.coll.data.insert(row[0])\n\n    def replace(self, alert_record, notes=None, logger=None, sid=None, username=None):\n        key = alert_record.get(\"_key\")\n        if key:\n            if notes:\n                alert_record['work_log'].insert(0, {\n                        'time': time.time(),\n                        'action': 'update',\n                        'notes': notes,\n                        'data': {'sid': sid},\n                        'analyst': username\n                    })\n            self.coll.data.update(key, json.dumps(alert_record))\n        else:\n            logger.warning('Cannot find alert: %s', str(key))\n\n    def update(self, key, action, status, notes=None, logger=None, sid=None, username=None):\n        if key:\n            alert_record = self.coll.data.query_by_id(key)\n            alert_record['status'] = status\n            alert_record['work_log'].insert(0, {\n                    'time': time.time(),\n                    'action': action,\n                    'notes': notes,\n                    'data': {'sid': sid},\n                    'analyst': username\n                })\n            self.coll.data.update(key, json.dumps(alert_record))\n        else:\n            logger.warning('Cannot find alert: %s', str(key))\n\n    def delete(self, key, logger=None):\n        if key:\n            self.coll.data.delete_by_id(key)\n        else:\n            logger.warning('Cannot find alert: %s', str(key))\n\n    def find(self, type, entity, time_gte):\n        \"\"\"Find records for the type, entity and time (int).\"\"\"\n        q = {\n            'type': type,\n            'entity': entity,\n            'time': { '$gte': time_gte}\n        }\n        encoded = json.dumps(q)\n        return self.coll.data.query(query=encoded)\n\n    def list(self, status = [], type=[], severity=[], analyst=[], entity=[],\n            earliest_time=None, latest_time=None,\n            logger=None):\n        if status or type or analyst or entity or severity:\n            if status:\n                qs = { '$or': [{ 'status': s } for s in status] }\n            else:\n                qs = {}\n            if type:\n                qt = { '$or': [{ 'type': s } for s in type] }\n            else:\n                qt = {}\n            if analyst:\n                qa = { '$or': [{ 'analyst': s } for s in analyst] }\n            else:\n                qa = {}\n            if entity:\n                qe = { '$or': [{ 'entity': s } for s in entity] }\n            else:\n                qe = {}\n            if severity:\n                qss = { '$or': [{ 'severity': s } for s in severity] }\n            else:\n                qss = {}\n            clauses = []\n            if qs: clauses.append(qs)\n            if qt: clauses.append(qt)\n            if qa: clauses.append(qa)\n            if qe: clauses.append(qe)\n            if qss: clauses.append(qss)\n            if earliest_time: clauses.append({'time': {'$gte': earliest_time}})\n            if latest_time: clauses.append({'time': {'$lt': latest_time}})\n            encoded = json.dumps({ '$and': clauses })\n            res =  self.coll.data.query(query=encoded)\n        else:\n            if earliest_time or latest_time:\n                clauses = []\n                if earliest_time: clauses.append({'time': {'$gte': earliest_time}})\n                if latest_time: clauses.append({'time': {'$lt': latest_time}})\n                encoded = json.dumps({ '$and': clauses })\n                res =  self.coll.data.query(query=encoded)\n            else:\n                res = self.coll.data.query()\n        return sorted(res, key=lambda r: -r['time'])\n\n    def dump(self):\n        print(\"Collection data: %s\" % json.dumps(self.coll.data.query(), indent=1))\n\ndef main():\n    opts = parse(sys.argv[1:], {}, \".splunkrc\")\n    #print(opts)\n    service = connect(**opts.kwargs)\n    alerts = AlertCollection(service.token)\n    if 'purge' in sys.argv:\n        alerts.purge()\n    elif 'dump' in sys.argv:\n        alerts.dump()\n    elif 'import'in sys.argv and len(sys.argv) == 3:\n        filename = sys.argv[2]\n        alerts.csv_import(filename)\n\nif __name__ == \"__main__\":\n    main()\n\nclass InsertStats:\n    def __init__(self):\n        self.inserted = 0\n        self.duplicate = 0\n        self.merged = 0\n        self.errors = 0\n    def __str__(self):\n        return 'inserted=%d, duplicate=%d, merged=%d, errors=%d' % (self.inserted, self.duplicate, self.merged, self.errors)\n"},"\/bin\/makealerts.py":{"changes":[{"diff":"\n \n     def stream(self, records):\n         #self.logger.info('MakeAlertsCommand: %s, type of record %s', self, type(records))  # logs command line\n-        self.logger.info('SEARCHINFO %s', self._metadata.searchinfo)\n+        #self.logger.info('SEARCHINFO %s', self._metadata.searchinfo)\n+\n+        self.load_whitelist(self._metadata.searchinfo)\n         sid = self._metadata.searchinfo.sid\n \n         if not self.interactive and not self.is_scheduled():\n","add":3,"remove":1,"filename":"\/bin\/makealerts.py","badparts":["        self.logger.info('SEARCHINFO %s', self._metadata.searchinfo)"],"goodparts":["        self.load_whitelist(self._metadata.searchinfo)"]},{"diff":"\n             self.alerts = AlertCollection(self._metadata.searchinfo.session_key)\n \n         for record in records:\n-            self.alerts.insert(record,\n-                event_time=self.time,\n-                entity=self.entity,\n-                alert_type=self.alert_type,\n-                severity=self.severity,\n-                idfield=self.idfield,\n-                combine=self.combine,\n-                combine_window=self.combine_window,\n-                search_query=self._metadata.searchinfo.search,\n-                search_earliest=self._metadata.searchinfo.earliest_time,\n-                search_latest=self._metadata.searchinfo.latest_time,\n-                logger=self.logger,\n-                sid=sid,\n-                username=self._metadata.searchinfo.username,\n-                insert_stats=self.insert_stats)\n+            for wl in self.whitelist:\n+                context = Context(record)\n+                if wl.is_whitelisted(context):\n+                    self.insert_stats.whitelisted += 1\n+                    self.logger.info(\"sid=%s,s3tag=criteria,debug=\\\"%s\\\"\", self._metadata.searchinfo.sid, str(context.debug))\n+                    self.logger.info(\"sid=%s,s3tag=whitelisted,type=\\\"%s\\\",name=\\\"%s\\\"\", self._metadata.searchinfo.sid, wl.type, wl.name)\n+                    break\n+            else:\n+                self.alerts.insert(record,\n+                    event_time=self.time,\n+                    entity=self.entity,\n+                    alert_type=self.alert_type,\n+                    severity=self.severity,\n+                    idfield=self.idfield,\n+                    combine=self.combine,\n+                    combine_window=self.combine_window,\n+                    search_query=self._metadata.searchinfo.search,\n+                    search_earliest=self._metadata.searchinfo.earliest_time,\n+                    search_latest=self._metadata.searchinfo.latest_time,\n+                    logger=self.logger,\n+                    sid=sid,\n+                    username=self._metadata.searchinfo.username,\n+                    insert_stats=self.insert_stats)\n             yield record\n \n     def finish(self):\n         if self.interactive and (not self.is_scheduled()) and self.insert_stats.errors > 0:\n            self.write_error(\n-               \"There were {0} error(s) when trying to insert data, check logs with this search 'index=_internal MakeAlertsCommand source=*super_simple_siem.log WARNING'\",\n+               \"There were {0} error(s) when trying to insert data, check logs with this search 'index=_internal MakeAlertsCommand source=*super_simple_siem.log* ERROR'\",\n                self.insert_stats.errors)\n \n-        # only log stats when running from a scheduled search\n-        if self.is_scheduled():\n-            self.logger.info('finish: %s', str(self.insert_stats))\n+        self.logger.info('sid=%s,s3tag=stats,%s,whitelist=%s',\n+            self._metadata.searchinfo.sid,\n+            str(self.insert_stats),\n+            \"[\" + \";\".join(str(x) for x in self.whitelist) + \"]\")\n \n         try:\n             super(MakeAlertsCommand, self).finish","add":28,"remove":19,"filename":"\/bin\/makealerts.py","badparts":["            self.alerts.insert(record,","                event_time=self.time,","                entity=self.entity,","                alert_type=self.alert_type,","                severity=self.severity,","                idfield=self.idfield,","                combine=self.combine,","                combine_window=self.combine_window,","                search_query=self._metadata.searchinfo.search,","                search_earliest=self._metadata.searchinfo.earliest_time,","                search_latest=self._metadata.searchinfo.latest_time,","                logger=self.logger,","                sid=sid,","                username=self._metadata.searchinfo.username,","                insert_stats=self.insert_stats)","               \"There were {0} error(s) when trying to insert data, check logs with this search 'index=_internal MakeAlertsCommand source=*super_simple_siem.log WARNING'\",","        if self.is_scheduled():","            self.logger.info('finish: %s', str(self.insert_stats))"],"goodparts":["            for wl in self.whitelist:","                context = Context(record)","                if wl.is_whitelisted(context):","                    self.insert_stats.whitelisted += 1","                    self.logger.info(\"sid=%s,s3tag=criteria,debug=\\\"%s\\\"\", self._metadata.searchinfo.sid, str(context.debug))","                    self.logger.info(\"sid=%s,s3tag=whitelisted,type=\\\"%s\\\",name=\\\"%s\\\"\", self._metadata.searchinfo.sid, wl.type, wl.name)","                    break","            else:","                self.alerts.insert(record,","                    event_time=self.time,","                    entity=self.entity,","                    alert_type=self.alert_type,","                    severity=self.severity,","                    idfield=self.idfield,","                    combine=self.combine,","                    combine_window=self.combine_window,","                    search_query=self._metadata.searchinfo.search,","                    search_earliest=self._metadata.searchinfo.earliest_time,","                    search_latest=self._metadata.searchinfo.latest_time,","                    logger=self.logger,","                    sid=sid,","                    username=self._metadata.searchinfo.username,","                    insert_stats=self.insert_stats)","               \"There were {0} error(s) when trying to insert data, check logs with this search 'index=_internal MakeAlertsCommand source=*super_simple_siem.log* ERROR'\",","        self.logger.info('sid=%s,s3tag=stats,%s,whitelist=%s',","            self._metadata.searchinfo.sid,","            str(self.insert_stats),","            \"[\" + \";\".join(str(x) for x in self.whitelist) + \"]\")"]}],"source":"\n from __future__ import absolute_import, division, print_function, unicode_literals from splunklib.searchcommands import dispatch, StreamingCommand, Configuration, Option, validators import sys, json from splunklib.client import connect from alert_collection import AlertCollection, InsertStats @Configuration() class MakeAlertsCommand(StreamingCommand): time=Option( doc=''' **Syntax:** **time=***<field>* **Description:** Field name used to determine event time for the alert''', require=False, validate=validators.Fieldname(), default='_time') entity=Option( doc=''' **Syntax:** **entity=***<field>* **Description:** Field name used to determine the entity triggering the alert(account name, machine name,...)''', require=False, validate=validators.Fieldname(), default='entity') alert_type=Option( doc=''' **Syntax:** **type=***<string>* **Description:** Field name used to determine the type of alert''', require=True, name='type') severity=Option( doc=''' **Syntax:** **severity=***<field>* **Description:** Field name used to set severity of the alert''', require=False, validate=validators.Fieldname(), default=None) idfield=Option( doc=''' **Syntax:** **idfield=***<field>* **Description:** Field name used to store the alert id''', require=False, default=None, validate=validators.Fieldname()) combine=Option( doc=''' **Syntax:** **combine=***\"<fields>\"* **Description:** Comma separated field names where alerts should be combined instead of creating new ones.''', require=False, default=None) combine_window=Option( doc=''' **Syntax:** **combine_window=***<string>* **Description:** hours or days. ''', require=False, default=None) interactive=Option( doc=''' **Syntax:** **interactive=***<bool>* **Description:** If true, makealerts can run in an interactive search, otherwise it will run only in scheduled search (this is to prevent alerts created accidentally when copy and pasting scheduled search text)''', require=False, default=False, validate=validators.Boolean()) alerts=None def __init__(self): super(MakeAlertsCommand, self).__init__() self.insert_stats=InsertStats() def is_scheduled(self): sid=self._metadata.searchinfo.sid return sid.startswith(\"scheduler_\") or sid.startswith(\"rt_scheduler_\") def stream(self, records): self.logger.info('SEARCHINFO %s', self._metadata.searchinfo) sid=self._metadata.searchinfo.sid if not self.interactive and not self.is_scheduled(): raise RuntimeError(\"When testing makealerts from interactive search, provide the 'interative=t' option.\") if not self.alerts: self.alerts=AlertCollection(self._metadata.searchinfo.session_key) for record in records: self.alerts.insert(record, event_time=self.time, entity=self.entity, alert_type=self.alert_type, severity=self.severity, idfield=self.idfield, combine=self.combine, combine_window=self.combine_window, search_query=self._metadata.searchinfo.search, search_earliest=self._metadata.searchinfo.earliest_time, search_latest=self._metadata.searchinfo.latest_time, logger=self.logger, sid=sid, username=self._metadata.searchinfo.username, insert_stats=self.insert_stats) yield record def finish(self): if self.interactive and(not self.is_scheduled()) and self.insert_stats.errors > 0: self.write_error( \"There were{0} error(s) when trying to insert data, check logs with this search 'index=_internal MakeAlertsCommand source=*super_simple_siem.log WARNING'\", self.insert_stats.errors) if self.is_scheduled(): self.logger.info('finish: %s', str(self.insert_stats)) try: super(MakeAlertsCommand, self).finish() except: pass dispatch(MakeAlertsCommand, sys.argv, sys.stdin, sys.stdout, __name__) ","sourceWithComments":"#!\/usr\/bin\/env python\n# coding=utf-8\n#\n# Copyright 2016-2017 Jean-Laurent Huynh\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nfrom splunklib.searchcommands import dispatch, StreamingCommand, Configuration, Option, validators\nimport sys, json\nfrom splunklib.client import connect\nfrom alert_collection import AlertCollection, InsertStats\n\n@Configuration()\nclass MakeAlertsCommand(StreamingCommand):\n    time = Option(\n        doc='''\n        **Syntax:** **time=***<field>*\n        **Description:** Field name used to determine event time for the alert''',\n        require=False, validate=validators.Fieldname(), default='_time')\n    entity = Option(\n        doc='''\n        **Syntax:** **entity=***<field>*\n        **Description:** Field name used to determine the entity triggering the alert (account name, machine name, ...)''',\n        require=False, validate=validators.Fieldname(), default='entity')\n    alert_type = Option(\n        doc='''\n        **Syntax:** **type=***<string>*\n        **Description:** Field name used to determine the type of alert''',\n        require=True, name='type')\n    severity = Option(\n        doc='''\n        **Syntax:** **severity=***<field>*\n        **Description:** Field name used to set severity of the alert''',\n        require=False, validate=validators.Fieldname(), default=None)\n    idfield = Option(\n        doc='''\n        **Syntax:** **idfield=***<field>*\n        **Description:** Field name used to store the alert id''',\n        require=False, default=None, validate=validators.Fieldname())\n    combine = Option(\n        doc='''\n        **Syntax:** **combine=***\"<fields>\"*\n        **Description:** Comma separated field names where alerts should be combined instead of creating new ones.''',\n        require=False, default=None)\n    combine_window = Option(\n        doc='''\n        **Syntax:** **combine_window=***<string>*\n        **Description:** hours or days. ''',\n        require=False, default=None)\n    interactive = Option(\n        doc='''\n        **Syntax:** **interactive=***<bool>*\n        **Description:** If true, makealerts can run in an interactive search, otherwise it will run only in scheduled search\n        (this is to prevent alerts created accidentally when copy and pasting scheduled search text)''',\n        require=False, default=False, validate=validators.Boolean())\n\n    alerts = None\n\n    def __init__(self):\n        super(MakeAlertsCommand, self).__init__()\n        self.insert_stats = InsertStats()\n\n    def is_scheduled(self):\n        sid = self._metadata.searchinfo.sid\n        return sid.startswith(\"scheduler_\") or sid.startswith(\"rt_scheduler_\")\n\n    def stream(self, records):\n        #self.logger.info('MakeAlertsCommand: %s, type of record %s', self, type(records))  # logs command line\n        self.logger.info('SEARCHINFO %s', self._metadata.searchinfo)\n        sid = self._metadata.searchinfo.sid\n\n        if not self.interactive and not self.is_scheduled():\n            raise RuntimeError(\"When testing makealerts from interactive search, provide the 'interative=t' option.\")\n\n        if not self.alerts:\n            self.alerts = AlertCollection(self._metadata.searchinfo.session_key)\n\n        for record in records:\n            self.alerts.insert(record,\n                event_time=self.time,\n                entity=self.entity,\n                alert_type=self.alert_type,\n                severity=self.severity,\n                idfield=self.idfield,\n                combine=self.combine,\n                combine_window=self.combine_window,\n                search_query=self._metadata.searchinfo.search,\n                search_earliest=self._metadata.searchinfo.earliest_time,\n                search_latest=self._metadata.searchinfo.latest_time,\n                logger=self.logger,\n                sid=sid,\n                username=self._metadata.searchinfo.username,\n                insert_stats=self.insert_stats)\n            yield record\n\n    def finish(self):\n        if self.interactive and (not self.is_scheduled()) and self.insert_stats.errors > 0:\n           self.write_error(\n               \"There were {0} error(s) when trying to insert data, check logs with this search 'index=_internal MakeAlertsCommand source=*super_simple_siem.log WARNING'\",\n               self.insert_stats.errors)\n\n        # only log stats when running from a scheduled search\n        if self.is_scheduled():\n            self.logger.info('finish: %s', str(self.insert_stats))\n\n        try:\n            super(MakeAlertsCommand, self).finish()\n        except:\n            pass\n\ndispatch(MakeAlertsCommand, sys.argv, sys.stdin, sys.stdout, __name__)\n\n\n"}},"msg":"Add support for whitelisting\n\nmakealerts checks against a whitelist lookup table with row indicating\ncriteria for whitelisting alerts.  If an alert is whitelisted, it is not\nsaved in the KVStore. Sufficient information should be available in the\nsuper simple siem log to find out which rule was applied.\n\nRules are parsed using a parsec style combinator library, this should\nprevent code injection (it does not use python's eval).\n\nAdded a Health dashboard with stats makealerts."}},"https:\/\/github.com\/thegamecracks\/thegamebot":{"13cf6f699758286d3222d01913bc111bd42ca1dc":{"url":"https:\/\/api.github.com\/repos\/thegamecracks\/thegamebot\/commits\/13cf6f699758286d3222d01913bc111bd42ca1dc","html_url":"https:\/\/github.com\/thegamecracks\/thegamebot\/commit\/13cf6f699758286d3222d01913bc111bd42ca1dc","message":"Feature Update 5 (#5)\n\nNew commands:\r\n- Administrative\r\n  - cooldown\r\n    - update: Add or update a command's cooldown.\r\n    - reset: Reset a command's cooldown for either the user or everyone.\r\n    - remove: Remove a command's cooldown.\r\n  - concurrency\r\n    - update: Add or update a command's max concurrency.\r\n    - remove: Remove a command's max concurrency.\r\n  - restart: Create a RESTART file before closing the bot; to be used in conjunction with runloop.bat\r\n- Embedding\r\n  - \/hyperlink: Similar to \"hyperlink quick\" except done using plain text instead of an embed, taking advantage of the interaction's webhook capabilities.\r\n- Games\r\n  - blackjack: Run a zero-stakes game of blackjack. Uses two guilds to host the playing card emojis.\r\n    - stats: View total games, wins, and losses.\r\n    - reset: Reset your stats.\r\n  - phasmophobia: Moved from Undefined cog\r\n  - unturned: Moved from Undefined cog\r\n- Graphing\r\n  - interest: Graph the simple and compound interest for an investment as a stackplot\r\n- Informative\r\n  - \/invite: Similar to the \"invite\" text command.\r\n- Notes\r\n  - \/notes\r\n    - add: Add a note.\r\n    - remove: Remove a note.\r\n    - show: Show one or all notes.\r\n- Randomization\r\n  - \/8ball: Similar to the \"8ball\" text command except without the delay between the invokation and the result.\r\n  - \/pick: Similar to the \"pick\" text command.\r\n- Undefined\r\n  - upsidedown: Flips the user's message upside down. Only works one way.\r\n  - leave: Tell the bot to leave the server. (user requires Manage Server permission)\r\n\r\nAdditions:\r\n- Jishaku cog\r\n- runloop.bat for running the bot and repeating if a file named RESTART exists\r\n- `utils.update_text` for printing a line and then clearing it with another line\r\n  - Used in main.py and dbsetup.py\r\n- Adds bot\/converters.py\r\n  - Moves `CommandConverter` from bot\/commands\/info.py\r\n  - Adds `UnicodeEmojiConverter` to check if an argument is a unicode emoji.\r\n- bot\/database\r\n  - `Database` subclass `GameDatabase` which is currently composed of a `BlackjackDatabase`\r\n  - Includes GuildDatabase in __init__.py since that was forgotten\r\n- bot\/classes\/confirmation.py\r\n  - Base class `EmbedConfirmation`\r\n  - `TextConfirmation` to get a yes\/no response from the user by message\r\n  - `AdaptiveConfirmation` which chooses between confirming via reaction or by message based on the bot's permissions and intents\r\n  - Renames previous `Confirmation` class to `ReactionConfirmation`\r\n- bot\/utils.py\r\n  - Added `iterable_has()` from bot\/commands\/info.py\r\n- Adds \"slash_guild_ids\" to the settings file, containing the list of guilds for slash commands to be registered\r\n\r\nImprovements:\r\n- Commands:\r\n  - \"about\": Sends an approximate member count when members intent is disabled instead of a generic \"Unavailable\" message\r\n  - \"block\": Now edits the first message instead of sending two messages\r\n  - \"commandinfo\"\r\n    - Adds the command's max concurrency to the description\r\n    - Now only shows cooldown if the command has a cooldown\r\n  - \"embed\"\r\n    - Sends an error message when failing to send the embed (usually due to missing parameters given by the user)\r\n    - Error messages now delete themselves after 10 seconds\r\n    - Adjusts description to work with the new plain text rendering in help command\r\n  - \"evaluate\": Fixes help documentation being incorrectly formatted\r\n  - \"invite\": Now requests the slash commands scope\r\n  - \"reversecipher\": Adds cooldown\r\n  - \"serverinfo\": Displays roles using mentions instead of names\r\n  - \"shutdown\"\r\n    - Adds confirmation prompt\r\n\t- Prints to terminal when beginning shutdown\r\n  - \"userinfo\": Displays roles using mentions instead of names\r\n  - Adds concurrency queue to note commands\r\n- Updates discord.py to 1.6.0\r\n- \"divide\" command now responds to division by zero error\r\n- IrishSquad cog\r\n  - Adds bot owner-only vacuum command for cleaning up the database of non-existing members\r\n  - \"charge amount\"\r\n    - Renamed to \"charge number\" with \"amount\" as alias\r\n    - Uses typehint converter instead of manually instantiating the converter\r\n    - Fixes being able to query members outside of the guild\r\n  - \"charge total\" now also shows a leaderboard of the top 10 members\r\n  - Removes `has_guild_permissions_dm_safe` custom check (used for \"charge reset\") since returning False is equivalent to raising a CheckFailure\r\n  - Charges are now printed with commas\r\n  - Adds guild property\r\n- bot\/database\r\n  - Databases are now instantiated once in dbsetup.py instead of enforcing databases to be singletons. This means cogs no longer have to \"initialize\" their database.\r\n  - Adds `vacuum()` method to `Database` class\r\n  - Adds ON DELETE CASCADE to all foreign keys\r\n  - Cast user\/guild_id to int to help prevent SQL injections\r\n  - Renames as_Row argument to as_row\r\n- utils.fuzzy_match_word(): Allows non-list objects to be given for `choices`\r\n- Allows case-insensitive help for cogs\r\n- Graphing\r\n  - Attempts fixing memory leak by closing figures as they won't always close themselves, which resulted in figures piling up in the background\r\n  - Switches to a non-GUI backend (Anti-Grain Geometry), since\r\n    1. Interactive GUI isn't needed\r\n\t2. Tkinter sometimes throws an AsyncDelete exception which crashes the bot, particularly when the process is halted or suspended\r\n  - Sets style mode to \"fast\" to optimize rendering\r\n  - Reduces redundancy in graphing commands by having custom style settings stored in data\/discord.mplstyle\r\n- Overhuals `utils.truncate_message` to support more edge cases, improve parameter names, and make the code slightly easier to read\r\n- Moves the uptime tracking from the Informative cog into its own Uptime cog\r\n- The global cooldown check is now registered using a Checks cog instead of manually adding the check. This makes it possible to inspect\/modify the cooldown mapping, and simplifies disabling the global cooldown just by unloading the cog.\r\n  - UserOnCooldown now inherits from commands.CommandError instead of commands.CheckFailure\r\n- CheckFailures are now ignored in the error handler when there is no programmed response for it\r\n- Adds error response for PrivateMessageOnly, raised by commands.dm_only() check\r\n\r\nTweaks:\r\n- Changes global cooldown from 15\/42s to 15\/60s\r\n- Renames `utils.CLIENT_EVALUATE_WHITELIST` to `utils.SAFE_EVAL_WHITELIST` and makes it a frozenset\r\n- Updates randomization commands to use references instead of mentions\r\n- Updates graphing commands to use the new resolved attribute of MessageReference\r\n- All `add_user` arguments related to databases now default to True\r\n- Most error messages now automatically delete itself\r\n- bot\/utils\r\n  - `convert_base()`: Default mapping is now the url-safe base64 sequence\r\n- Ciphers cog: Tweaks documentation of commands\r\n\r\nFixes:\r\n- Commands:\r\n  - \"block\": NameError occurring when a non-owner uses the command\r\n- Retry after time in cooldown responses not always being rounded to the nearest tenth\r\n- Group doc not being shown in help command (this has been missing for ages!)\r\n- Help command not supporting cogs with no explicit qualified_name declaration\r\n- Error messages not being sent for check failures\r\n- AttributeError when handling MissingRole and related errors\r\n\r\nOther:\r\n- Refactors several instances of string concatenations to joins to improve performance, based on an analysis from https:\/\/stackoverflow.com\/a\/16147471\r\n- Refactors all cog descriptions to be specified using docstrings","sha":"13cf6f699758286d3222d01913bc111bd42ca1dc","keyword":"eval injection prevent","diff":"diff --git a\/bot\/checks.py b\/bot\/checks.py\nindex 021ca30..3f89d15 100644\n--- a\/bot\/checks.py\n+++ b\/bot\/checks.py\n@@ -4,20 +4,9 @@\n \n from bot import settings\n \n-COMMAND_COOLDOWN_SETTINGS = (15, 42, commands.BucketType.user)\n-\n-global_checks_wrapped = [\n-    'command_cooldown',\n-]\n-\n-GlobalCheckPredicate = collections.namedtuple(\n-    'GlobalCheckPredicate', ['predicate', 'call_once'],\n-    defaults={'call_once': False}\n-)\n-\n \n # Errors\n-class UserOnCooldown(commands.CheckFailure):\n+class UserOnCooldown(commands.CommandError):\n     \"\"\"Raised when a user has invoked too many commands\n     and is being globally ratelimited.\"\"\"\n     __slots__ = ('retry_after',)\n@@ -39,24 +28,6 @@ class InvalidBotAdmin(InvalidIdentification):\n     \"\"\"Raised when a command requires the user to be in ADMIN_IDS.\"\"\"\n \n \n-# Global checks\n-def command_cooldown(bot):\n-    mapping = commands.CooldownMapping.from_cooldown(\n-        *COMMAND_COOLDOWN_SETTINGS)\n-\n-    async def predicate(ctx):\n-        bucket = mapping.get_bucket(ctx.message)\n-        if bucket.update_rate_limit():\n-            # user is rate limited\n-            raise UserOnCooldown(\n-                bucket.get_retry_after(),\n-                'User is using commands too frequently.'\n-            )\n-        return True\n-\n-    return GlobalCheckPredicate(predicate, call_once=True)\n-\n-\n # Checks\n def is_bot_admin():\n     async def predicate(ctx):\n@@ -92,7 +63,38 @@ async def predicate(ctx):\n     return commands.check(predicate)\n \n \n+class Checks(commands.Cog):\n+    \"\"\"Global bot checks.\"\"\"\n+\n+    GLOBAL_COOLDOWN_SETTINGS = (15, 60, commands.BucketType.user)\n+\n+    def __init__(self, bot, *, global_cooldown_settings=None):\n+        \"\"\"\n+        Args:\n+            bot (commands.Bot): The discord bot.\n+            global_cooldown_settings (Optional[Tuple[int, int, commands.BucketType]]):\n+                The settings to use for the global cooldown (rate, per, type).\n+                Defaults to self.GLOBAL_COOLDOWN_SETTINGS.\n+\n+        \"\"\"\n+        self.bot = bot\n+\n+        if global_cooldown_settings is None:\n+            global_cooldown_settings = self.GLOBAL_COOLDOWN_SETTINGS\n+        self.global_cooldown = commands.CooldownMapping.from_cooldown(\n+            *global_cooldown_settings)\n+\n+    def bot_check_once(self, ctx):\n+        # Global cooldown\n+        bucket = self.global_cooldown.get_bucket(ctx.message)\n+        if bucket.update_rate_limit():\n+            raise UserOnCooldown(\n+                bucket.get_retry_after(),\n+                'User is using commands too frequently.'\n+            )\n+\n+        return True\n+\n+\n def setup(bot):\n-    for check in global_checks_wrapped:\n-        predicate, call_once = globals()[check](bot)\n-        bot.add_check(predicate, call_once=call_once)\n+    bot.add_cog(Checks(bot))\ndiff --git a\/bot\/classes\/confirmation.py b\/bot\/classes\/confirmation.py\nindex f191179..9bd976d 100644\n--- a\/bot\/classes\/confirmation.py\n+++ b\/bot\/classes\/confirmation.py\n@@ -1,10 +1,12 @@\n+import abc\n import asyncio\n from dataclasses import dataclass\n+from typing import Optional\n \n import discord\n \n \n-@dataclass\n+@dataclass(frozen=True)\n class ConfirmationEmoji:\n     emoji: str\n     color: int\n@@ -14,23 +16,42 @@ def colour(self):\n         return self.color\n \n \n-class Confirmation:\n+class EmbedConfirmation(abc.ABC):\n+    \"\"\"The base class for embed confirmations.\n+\n+    Args:\n+        ctx (discord.ext.commands.Context)\n+        color (int): The color of the embed.\n+\n+    \"\"\"\n     def __init__(self, ctx, color=0):\n         self.ctx = ctx\n         self.color = color\n-        self.embed = discord.Embed(\n-            color=color\n+        self.embed = None\n+        self.message = None\n+\n+    @abc.abstractmethod\n+    def _create_embed(self, title: str) -> discord.Embed:\n+        embed = discord.Embed(\n+            title=title,\n+            color=self.color\n         ).set_author(\n-            name=ctx.author.display_name,\n-            icon_url=ctx.author.avatar_url\n+            name=self.ctx.author.display_name,\n+            icon_url=self.ctx.author.avatar_url\n         )\n-        self.emoji_yes = ConfirmationEmoji(\n-            '\\N{WHITE HEAVY CHECK MARK}', 0x77B255)\n-        self.emoji_no = ConfirmationEmoji(\n-            '\\N{CROSS MARK}', 0xDD2E44)\n-        self.message = None\n+        self.embed = embed\n+        return embed\n+\n+    @abc.abstractmethod\n+    async def _prompt(self, title: str) -> discord.Message:\n+        \"\"\"Send the message prompt.\"\"\"\n+        embed = self._create_embed(title)\n+        message = await self.ctx.send(embed=embed)\n+        self.message = message\n \n-    async def confirm(self, title: str, timeout=30):\n+        return message\n+\n+    async def confirm(self, title: str, timeout=30) -> Optional[bool]:\n         \"\"\"Ask the user to confirm.\n \n         Returns:\n@@ -38,32 +59,53 @@ async def confirm(self, title: str, timeout=30):\n             None: Timed out.\n \n         \"\"\"\n-        async def clear_reactions(message):\n-            try:\n-                await message.clear_reactions()\n-            except discord.Forbidden:\n-                pass\n+        await self._prompt(title)\n+        return await self.get_answer(timeout=timeout)\n \n-        ctx = self.ctx\n+    @abc.abstractmethod\n+    async def get_answer(self, *, timeout: int) -> Optional[bool]:\n+        \"\"\"Get the user's answer.\"\"\"\n \n+    async def update(self, title: str, color=None):\n         self.embed.title = title\n+        if color is not None:\n+            self.embed.color = color\n \n-        # Send prompt\n-        message = await ctx.send(embed=self.embed)\n-        self.message = message\n+        await self.message.edit(embed=self.embed)\n+\n+\n+class ReactionConfirmation(EmbedConfirmation):\n+    \"\"\"An embed confirmation that takes its input using reactions.\"\"\"\n+    def __init__(self, ctx, color=0):\n+        super().__init__(ctx, color)\n+\n+        self.emoji_yes = ConfirmationEmoji(\n+            '\\N{WHITE HEAVY CHECK MARK}', 0x77B255)\n+        self.emoji_no = ConfirmationEmoji(\n+            '\\N{CROSS MARK}', 0xDD2E44)\n+\n+    def _create_embed(self, title: str) -> discord.Embed:\n+        return EmbedConfirmation._create_embed(self, title)\n+\n+    async def _prompt(self, title: str) -> discord.Message:\n+        message = await EmbedConfirmation._prompt(self, title)\n \n         # Add reactions\n-        emoji = [self.emoji_yes.emoji, self.emoji_no.emoji]\n+        emoji = (self.emoji_yes.emoji, self.emoji_no.emoji)\n         for e in emoji:\n             await message.add_reaction(e)\n \n-        # Wait for response\n+        return message\n+\n+    async def get_answer(self, *, timeout: int) -> Optional[bool]:\n         def check(r, u):\n-            return (r.message == message and u == ctx.author\n+            return (r.message == self.message and u == self.ctx.author\n                     and r.emoji in emoji)\n \n+        emoji = (self.emoji_yes.emoji, self.emoji_no.emoji)\n+\n         try:\n-            reaction, user = await ctx.bot.wait_for(\n+            reaction, user = await self.ctx.bot.wait_for(\n                 'reaction_add', check=check, timeout=timeout\n             )\n         except asyncio.TimeoutError:\n@@ -71,11 +113,88 @@ def check(r, u):\n         else:\n             return reaction.emoji == self.emoji_yes.emoji\n         finally:\n-            await clear_reactions(message)\n+            try:\n+                await self.message.clear_reactions()\n+            except discord.Forbidden:\n+                pass\n \n-    async def update(self, title: str, color=None):\n-        self.embed.title = title\n-        if color is not None:\n-            self.embed.color = color\n \n-        await self.message.edit(embed=self.embed)\n+class TextConfirmation(EmbedConfirmation):\n+    \"\"\"An embed confirmation that takes its input using messages.\n+\n+    Args:\n+        yes (Union[str, Iterable[str]])\n+        no (Union[str, Iterable[str]])\n+\n+    \"\"\"\n+    def __init__(self, ctx, color=0, yes=('yes', 'y'), no=('no', 'n')):\n+        super().__init__(ctx, color)\n+\n+        self.yes = (yes,) if isinstance(yes, str) else yes\n+        self.no = (no,) if isinstance(no, str) else no\n+\n+    def _create_embed(self, title: str) -> discord.Embed:\n+        embed = EmbedConfirmation._create_embed(self, title)\n+        self.embed.set_footer(\n+            text='Respond by typing *{yes}* or *{no}*'.format(\n+                yes='\/'.join([str(s) for s in self.yes]),\n+                no='\/'.join([str(s) for s in self.no])\n+            )\n+        )\n+        return embed\n+\n+    async def _prompt(self, title: str) -> discord.Message:\n+        return await EmbedConfirmation._prompt(self, title)\n+\n+    async def get_answer(self, *, timeout: int) -> Optional[bool]:\n+        def check(m: discord.Message):\n+            if m.author == self.ctx.author and m.channel == self.message.channel:\n+                content = m.content.strip().lower()\n+                return content in self.yes or content in self.no\n+            return False\n+\n+        try:\n+            message = await self.ctx.bot.wait_for(\n+                'message', check=check, timeout=timeout\n+            )\n+        except asyncio.TimeoutError:\n+            return None\n+        else:\n+            content = message.content.strip().lower()\n+            return content in self.yes\n+\n+\n+class AdaptiveConfirmation(ReactionConfirmation, TextConfirmation):\n+    \"\"\"An embed confirmation that uses reactions if possible,\n+    otherwise asks via text.\"\"\"\n+    def __init__(self, ctx, color=0):\n+        super().__init__(ctx, color)\n+\n+        # Determine whether to use reactions or text\n+        # Reactions will not work if in DMs without members intent\n+        mode = 'text'\n+        if ctx.guild is not None:\n+            bot_perms = self.ctx.me.permissions_in(self.ctx.channel)\n+            if bot_perms.add_reactions:\n+                mode = 'react'\n+        else:\n+            mode = 'react' if ctx.bot.intents.members else 'text'\n+        self.mode = mode\n+\n+    def _create_embed(self, title: str) -> discord.Embed:\n+        if self.mode == 'react':\n+            return super()._create_embed(title)\n+        else:\n+            return super(ReactionConfirmation, self)._create_embed(title)\n+\n+    async def _prompt(self, title: str) -> discord.Message:\n+        if self.mode == 'react':\n+            return await super()._prompt(title)\n+        else:\n+            return await super(ReactionConfirmation, self)._prompt(title)\n+\n+    async def get_answer(self, *, timeout: int) -> Optional[bool]:\n+        if self.mode == 'react':\n+            return await super().get_answer(timeout=timeout)\n+        else:\n+            return await super(ReactionConfirmation, self).get_answer(timeout=timeout)\ndiff --git a\/bot\/classes\/games\/blackjack.py b\/bot\/classes\/games\/blackjack.py\nnew file mode 100644\nindex 0000000..f7bc10e\n--- \/dev\/null\n+++ b\/bot\/classes\/games\/blackjack.py\n@@ -0,0 +1,476 @@\n+import asyncio\n+import copy\n+from dataclasses import dataclass, field, replace\n+import functools\n+import itertools\n+import random\n+from typing import FrozenSet, List, Optional, Tuple, Union, Dict\n+\n+import discord\n+from discord.ext import commands\n+import inflect\n+\n+from bot.classes.get_reaction import get_reaction\n+from bot import settings\n+\n+\n+inflector = inflect.engine()\n+\n+\n+RANKS = tuple(str(n) for n in range(2, 11)) + ('JACK', 'QUEEN', 'KING', 'ACE')\n+SUITS = ('SPADE', 'HEART', 'DIAMOND', 'CLUB')\n+\n+\n+@dataclass(frozen=True)\n+class Card:\n+    rank: str\n+    suit: str\n+    facedown: bool = False\n+\n+    def __post_init__(self):\n+        if self.rank not in RANKS:\n+            raise ValueError(f'Unknown rank {self.rank!r}')\n+        if self.suit not in SUITS:\n+            raise ValueError(f'Unknown suit {self.suit!r}')\n+\n+    def __str__(self):\n+        if self.facedown:\n+            return 'Hidden'\n+        return f'{self.rank.capitalize()} of {self.suit.capitalize()}s'\n+\n+    @functools.cached_property\n+    def value(self) -> Tuple[int, ...]:\n+        rank = self.rank\n+        if rank in ('JACK', 'QUEEN', 'KING'):\n+            return 10,\n+        elif rank == 'ACE':\n+            return 1, 11\n+        return int(rank),\n+\n+    @functools.cached_property\n+    def color(self):\n+        if self.suit in ('DIAMONDS', 'HEARTS'):\n+            return 'RED'\n+        elif self.suit in ('CLUBS', 'SPADES'):\n+            return 'BLACK'\n+        raise ValueError(f'Unknown suit {self.suit!r}')\n+\n+    def replace(self, **kwargs):\n+        return replace(self, **kwargs)\n+\n+\n+@dataclass\n+class Hand:\n+    cards: List[Card] = field(default_factory=list)\n+\n+    def __post_init__(self):\n+        self._cache_values = None\n+        self._cache_soft = None\n+\n+    def __contains__(self, item):\n+        return item in self.cards\n+\n+    def __delitem__(self, index):\n+        del self.cards[index]\n+\n+    def __getitem__(self, index):\n+        return self.cards[index]\n+\n+    def __iter__(self):\n+        return iter(self.cards)\n+\n+    def __len__(self):\n+        return len(self.cards)\n+\n+    def __setitem__(self, index, item):\n+        self.cards[index] = item\n+\n+    def __str__(self):\n+        return inflector.join(self)\n+\n+    def append(self, card: Card):\n+        \"\"\"Add a card to the hand.\"\"\"\n+        self.cards.append(card)\n+\n+        # Clear cache and then compute new values\n+        self._clear_cache()\n+        values = self.values\n+\n+    def _clear_cache(self):\n+        self._cache_values = None\n+        self._cache_soft = None\n+\n+    def copy(self):\n+        \"\"\"Create a new hand with the same cards.\"\"\"\n+        return copy.deepcopy(self)\n+\n+    def count(self, rank=None, suit=None) -> int:\n+        \"\"\"Count the number of cards with a particular rank and\/or suit.\"\"\"\n+        count = 0\n+        for card in self:\n+            if rank is not None:\n+                if suit is not None:\n+                    count += card.rank == rank and card.suit == suit\n+                else:\n+                    count += card.rank == rank\n+            elif suit is not None:\n+                count += card.suit == suit\n+            else:\n+                raise ValueError('Rank or suit must be specified')\n+\n+        return count\n+\n+    @property\n+    def maximum(self) -> int:\n+        \"\"\"Returns the maximum legal value of the hand.\n+        If there are no legal values, returns the minimum of the hand.\"\"\"\n+        legal, over = [], []\n+        for v in self.values:\n+            if v <= 21:\n+                legal.append(v)\n+            else:\n+                over.append(v)\n+\n+        if legal:\n+            return max(legal)\n+        return min(over)\n+\n+    @property\n+    def minimum(self) -> int:\n+        \"\"\"Returns the minimum value of the hand.\"\"\"\n+        return min(self.values)\n+\n+    def reveal(self) -> int:\n+        \"\"\"Reveal any cards in the hand that are facedown.\n+        This returns the number of cards that were revealed.\"\"\"\n+        revealed = 0\n+        for i, card in enumerate(self):\n+            if card.facedown:\n+                self[i] = card.replace(facedown=False)\n+                revealed += 1\n+        if revealed:\n+            self._clear_cache()\n+        return revealed\n+\n+    @property\n+    def soft(self) -> bool:\n+        if self._cache_soft is None:\n+            # Soft is determined during calculation of values\n+            values = self.values\n+        return self._cache_soft\n+\n+    @property\n+    def values(self) -> FrozenSet[int]:\n+        \"\"\"Return a frozenset of possible values for the hand.\"\"\"\n+        if self._cache_values is not None:\n+            return self._cache_values\n+\n+        total = 0\n+        variables = []\n+        for card in self:\n+            value = card.value\n+            if card.facedown:\n+                continue\n+            elif len(value) == 1:\n+                total += value[0]\n+            else:\n+                variables.append(value)\n+\n+        # Calculate all the possible values for the hand\n+        has_ace = self.count('ACE')\n+        values = {}  # map value to softness\n+        for comb in itertools.product(*variables):\n+            v = total + sum(comb)\n+            values.setdefault(v, False)\n+            values[v] = has_ace and 11 in comb or values[v]\n+        value_set = frozenset(val for val, soft in values.items())\n+\n+        self._cache_values = value_set\n+        self._cache_soft = values[self.maximum]\n+\n+        return value_set\n+\n+    @property\n+    def val(self) -> str:\n+        value = self.maximum\n+        if value == 21 and len(self) == 2:\n+            return 'blackjack'\n+        elif self.soft:\n+            return f'soft {value}'\n+        return str(value)\n+\n+\n+CARDS = tuple(Card(r, s) for r in RANKS for s in SUITS)\n+\n+\n+@dataclass(frozen=True)\n+class BotBlackjackGameResults:\n+    done: bool\n+    last_player: discord.User\n+    player: Hand\n+    dealer: Hand\n+    winner: Optional[bool] = None\n+    moves: List[str] = field(default_factory=list)\n+\n+\n+class BotBlackjackGame:\n+    \"\"\"A one-use blackjack game.\"\"\"\n+\n+    HIT_ON_SOFT_17 = True\n+    # Hit if the dealer has a soft 17.\n+    REVEAL_DEALER_BLACKJACK = False\n+    # Reveal the dealer's hand if their hand is a blackjack.\n+    # As there is no ability to double down, this setting affects\n+    # the start of the game instead.\n+    REVEAL_ON_BLACKJACK = True\n+    # Reveal the dealer's hand if the player gets a blackjack.\n+    # This allows pushes (ties) with blackjacks to occur.\n+\n+    TIMEOUT = 30\n+\n+    CARD_CLUSTER_1 = 798370146867085332\n+    CARD_CLUSTER_2 = 798378538809032714\n+\n+    EMOJI_DOWN = 798378635232149534\n+    EMOJI_HIT = 798381258257989653\n+    EMOJI_STAND = 798381243770470420\n+    EMOJI_DEFAULT = '\\N{NO ENTRY}'\n+\n+    def __init__(\n+            self, ctx, *, color=0xE6D94D, deck: Union[int, List[Card]],\n+            message=None):\n+        self._ctx: commands.Context = ctx\n+        self._client: discord.Client = ctx.bot\n+        self.color = color\n+        self.emojis = self.chunk_emojis()\n+        self.message: Optional[discord.Message] = message\n+\n+        if isinstance(deck, int):\n+            deck = [c for _ in range(deck) for c in CARDS]\n+            random.shuffle(deck)\n+\n+        self.deck = deck\n+        self.player = Hand([deck.pop(), deck.pop()])\n+        self.dealer = Hand([deck.pop(), deck.pop().replace(facedown=True)])\n+\n+        self.win = None\n+\n+    def check_dealer_blackjack(self, hand: Hand, hidden=True) -> bool:\n+        \"\"\"Check if a dealer's hand is, or could be a blackjack.\n+\n+        Args:\n+            hand (Hand): The dealer's hand.\n+            hidden (bool): If True, this will peek the hidden card\n+                when the first card has a value of 10 or greater,\n+                returning True if the second card adds up to blackjack\n+                (this does not reveal the card).\n+                Otherwise, returns True if the potential for blackjack\n+                exists.\n+\n+        \"\"\"\n+        value1 = max(hand[0].value)\n+        if value1 >= 10:\n+            return True if not hidden else value1 + max(hand[1].value) == 21\n+        return False\n+\n+    def embed_update(self, user=None, done=False) -> discord.Embed:\n+        \"\"\"Return the embed for the current game.\n+        This includes both the running and final state of the game.\n+\n+        Args:\n+            user (Optional[discord.User]): The user that played the last move.\n+            done (bool): If True, adds the result onto the embed.\n+\n+        \"\"\"\n+        user = self._ctx.author if user is None else user\n+        embed = discord.Embed(\n+            description='Result: ' if done else '',\n+            color=self.color\n+        ).set_author(\n+            name=user.display_name,\n+            icon_url=user.avatar_url\n+        )\n+\n+        # deck = self.deck\n+        player = self.player\n+        dealer = self.dealer\n+\n+        win = None\n+        if done:\n+            if player.maximum > 21:\n+                win = False\n+                embed.description += 'Bust'\n+            elif dealer.maximum > 21:\n+                win = True\n+                embed.description += 'Dealer Bust'\n+            elif player.maximum == 21:\n+                if self.REVEAL_ON_BLACKJACK and self.check_dealer_blackjack(\n+                        dealer, hidden=False):\n+                    dealer.reveal()\n+                if dealer.maximum == 21:\n+                    embed.description += 'Push'\n+                else:\n+                    win = True\n+                    embed.description += 'Win'\n+            elif player.maximum == dealer.maximum:\n+                embed.description += 'Push'\n+            else:\n+                win = player.maximum > dealer.maximum\n+                if win:\n+                    embed.description += 'Win'\n+                else:\n+                    embed.description += 'Loss'\n+\n+            if win:\n+                embed.color = 0x77B255\n+            elif win is False:\n+                embed.color = 0xDD2E44\n+            self.win = win\n+        else:\n+            embed.set_footer(text=f'Remaining cards: {len(self.deck)}')\n+\n+        embed.add_field(\n+            name='You',\n+            value=f'{self.list_emojis(player)}\\n\\nValue: {player.val.capitalize()}'\n+        )\n+        embed.add_field(\n+            name='Dealer',\n+            value=f'{self.list_emojis(dealer)}\\n\\nValue: {dealer.val.capitalize()}'\n+        )\n+\n+        return embed\n+\n+    @staticmethod\n+    def emoji_name(card: Card) -> str:\n+        \"\"\"Return the emoji name for a given card.\"\"\"\n+        if card.facedown:\n+            return 'down'\n+\n+        rank = card.rank\n+        suit = card.suit[0]\n+        try:\n+            int(rank)\n+        except ValueError:\n+            # Take the first letter for non-numbered ranks\n+            rank = rank[0].lower()\n+\n+        return '{}{}'.format(rank, suit)\n+\n+    def chunk_emojis(self) -> Dict[str, discord.Emoji]:\n+        \"\"\"Chunk all the emojis available.\"\"\"\n+        d = {\n+            'hit': self._client.get_emoji(self.EMOJI_HIT),\n+            'stand': self._client.get_emoji(self.EMOJI_STAND),\n+            'down': self._client.get_emoji(self.EMOJI_DOWN)\n+        }\n+\n+        cluster_1: discord.Guild = self._client.get_guild(self.CARD_CLUSTER_1)\n+        cluster_2: discord.Guild = self._client.get_guild(self.CARD_CLUSTER_2)\n+        for card in CARDS:\n+            name = self.emoji_name(card)\n+            if card.rank == 'QUEEN':\n+                d[name] = discord.utils.get(cluster_2.emojis, name=name)\n+            else:\n+                d[name] = discord.utils.get(cluster_1.emojis, name=name)\n+\n+        for k, v in d.items():\n+            if v is None:\n+                print(f'Could not find emoji for {v}')\n+                d[k] = self.EMOJI_DEFAULT\n+\n+        return d\n+\n+    def emoji(self, card: Card) -> discord.Emoji:\n+        \"\"\"Get the given emoji for a card.\n+        If the card or emoji does not exist, returns the default emoji.\"\"\"\n+        name = self.emoji_name(card)\n+        return self.emojis.get(name, self.EMOJI_DEFAULT)\n+\n+    def list_emojis(self, hand: Hand) -> str:\n+        \"\"\"Return a string with a list of card emojis for a given hand.\"\"\"\n+        return ' '.join([str(self.emoji(c)) for c in hand])\n+\n+    async def run(self, *,\n+                  channel: Optional[discord.TextChannel] = None,\n+                  users: Optional[List[discord.User]] = None,\n+                  outro_content: str = '') -> BotBlackjackGameResults:\n+        \"\"\"\n+        Args:\n+            channel (Optional[discord.TextChannel]):\n+                The channel to send the message to.\n+                If None, uses `self._ctx.channel`.\n+            users (Optional[List[discord.User]]):\n+                A list of users that can participate in the game.\n+                If None, anyone can participate.\n+            outro_content (str): The message's content shown\n+                at the end of the game.\n+        \"\"\"\n+        if channel is None:\n+            channel = self._ctx.channel\n+\n+        deck = self.deck\n+        player = self.player\n+        dealer = self.dealer\n+\n+        emojis = [\n+            self.emojis['hit'],\n+            self.emojis['stand']\n+        ]\n+\n+        last_player = self._ctx.author\n+        moves = []\n+\n+        # Send initial message\n+        message = self.message\n+        if message is None:\n+            message = await channel.send('Loading...')\n+            self.message = message\n+            for e in emojis:\n+                await message.add_reaction(e)\n+            await asyncio.sleep(1)\n+\n+        # Peek the second card to check for blackjack\n+        if self.REVEAL_DEALER_BLACKJACK and self.check_dealer_blackjack(dealer):\n+            dealer.reveal()\n+\n+        while max(player.maximum, dealer.maximum) < 21:\n+            await message.edit(content='', embed=self.embed_update(user=last_player))\n+            try:\n+                reaction, last_player = await get_reaction(\n+                    self._client, message,\n+                    emojis, users,\n+                    timeout=self.TIMEOUT\n+                )\n+            except asyncio.TimeoutError:\n+                await message.edit(content='Ended game due to inactivity.')\n+                return BotBlackjackGameResults(\n+                    done=False, last_player=last_player,\n+                    player=player, dealer=dealer, moves=moves\n+                )\n+            else:\n+                if reaction.emoji == emojis[0]:\n+                    # Hit\n+                    moves.append('hit')\n+                    player.append(deck.pop())\n+                elif reaction.emoji == emojis[1]:\n+                    # Stand\n+                    moves.append('stand')\n+                    dealer.reveal()\n+                    while (dealer.maximum < 17 or self.HIT_ON_SOFT_17\n+                            and dealer.soft and dealer.maximum == 17):\n+                        dealer.append(deck.pop())\n+                    break\n+                else:\n+                    raise ValueError(f'Unknown reaction {reaction!r}')\n+\n+        embed = self.embed_update(user=last_player, done=True)\n+        if moves:\n+            embed.description += f\"\\nMoves: {', '.join(moves)}\"\n+        else:\n+            embed.description += '\\nMoves: None'\n+        await message.edit(content=outro_content, embed=embed)\n+\n+        return BotBlackjackGameResults(\n+            done=True, last_player=last_player, player=player,\n+            dealer=dealer, winner=self.win, moves=moves\n+        )\ndiff --git a\/bot\/classes\/games\/multimath.py b\/bot\/classes\/games\/multimath.py\nindex 1da483b..f95c71e 100644\n--- a\/bot\/classes\/games\/multimath.py\n+++ b\/bot\/classes\/games\/multimath.py\n@@ -1,6 +1,5 @@\n import asyncio\n import collections\n-import math\n import operator\n import random\n \n@@ -194,10 +193,9 @@ async def run(self, *, channel=None, users=None):\n             channel (Optional[discord.TextChannel]):\n                 The channel to send the message to.\n                 If None, uses `self._ctx.channel`.\n-            users (Optional[Union[True, List[discord.User]]]):\n+            users (Optional[List[discord.User]]):\n                 A list of users that can participate in the game.\n-                If None, the author of self._ctx will be the only participant.\n-                If True, anyone can participate.\n+                If None, anyone can participate.\n         \"\"\"\n         async def finish_and_show_score(header, last_answerer=None):\n             \"Display the final score and who got it wrong >:(\"\n@@ -208,12 +206,6 @@ async def finish_and_show_score(header, last_answerer=None):\n                 [header, embed_finish.description])\n             await message.edit(embed=embed_finish)\n \n-        if users is None:\n-            # Allow only caller\n-            users = [self._ctx.author]\n-        elif users is True:\n-            # Allow all participants\n-            users = None\n         if channel is None:\n             # Assumes game to be started in the caller's channel\n             channel = self._ctx.channel\ndiff --git a\/bot\/classes\/get_reaction.py b\/bot\/classes\/get_reaction.py\nindex ffa67a2..db1c828 100644\n--- a\/bot\/classes\/get_reaction.py\n+++ b\/bot\/classes\/get_reaction.py\n@@ -15,8 +15,6 @@ async def get_reaction(client, message, reactions=None,\n         reactions (Optional[List[Union[Emoji, PartialEmoji, str]]]):\n             Returns only reaction changes within this list.\n             If None, returns any reaction change.\n-        timeout (Optional[float]): The timeout period.\n-            Raises TimeoutError.\n         users (Optional[List[discord.User]]): A list of users\n             that are allowed to react to the message.\n             If None, returns any user's reaction change.\n@@ -40,6 +38,7 @@ def check(r: discord.Reaction, u: discord.User):\n \n         return result\n \n+    completed_tasks = ()\n     pending_tasks = [\n         client.wait_for('reaction_add', check=check),\n         client.wait_for('reaction_remove', check=check),\ndiff --git a\/bot\/commands\/administrative.py b\/bot\/commands\/administrative.py\nindex f1db168..69435db 100644\n--- a\/bot\/commands\/administrative.py\n+++ b\/bot\/commands\/administrative.py\n@@ -6,7 +6,7 @@\n import io\n import textwrap\n import time\n-import typing\n+from typing import Optional\n \n import discord\n from discord.ext import commands\n@@ -14,19 +14,37 @@\n import matplotlib.pyplot as plt\n import numpy as np\n \n-from bot import checks\n-from bot import settings\n-from bot import utils\n+from bot.classes.confirmation import AdaptiveConfirmation\n from bot.other import discordlogger\n+from bot import checks, converters, settings, utils\n \n \n def get_user_for_log(ctx):\n     return f'{ctx.author} ({ctx.author.id})'\n \n \n+def send_restart_signal():\n+    \"\"\"Create a file named RESTART that the batch file running the script\n+    loop should detect and recognize to rerun the bot again.\"\"\"\n+    open('RESTART', 'w').close()\n+\n+\n+class BucketTypeConverter(commands.Converter):\n+    async def convert(self, ctx, argument):\n+        try:\n+            # Convert by number\n+            return commands.BucketType(argument)\n+        except ValueError:\n+            try:\n+                # Convert by enum name\n+                return getattr(commands.BucketType, argument)\n+            except AttributeError:\n+                raise commands.BadArgument(f'{argument!r} is not a valid BucketType')\n+\n+\n class Administrative(commands.Cog):\n+    \"\"\"Administrative commands available for owners\/admins.\"\"\"\n     qualified_name = 'Administrative'\n-    description = 'Administrative commands available for owners\/admins.'\n \n     def __init__(self, bot):\n         self.bot = bot\n@@ -40,35 +58,171 @@ def __init__(self, bot):\n     @checks.is_bot_owner()\n     async def client_block(self, ctx, x: int = 20):\n         \"\"\"Block the operation of the bot.\"\"\"\n-        await ctx.send(f'Blocking for {x} seconds.')\n+        message = await ctx.send(f'Blocking for {x} seconds.')\n         time.sleep(x)\n-        await ctx.send('Finished blocking.')\n+        await message.edit(content='Finished blocking.')\n \n \n-    @client_block.error\n-    async def client_block_error(self, ctx, error):\n-        error = getattr(error, 'original', error)\n-        if isinstance(error, checks.InvalidBotOwner):\n-            await ctx.send(get_denied_message())\n \n \n \n+    @commands.group(name='cooldown', invoke_without_command=True)\n+    @checks.is_bot_admin()\n+    async def client_cooldown(self, ctx):\n+        \"\"\"Modify a command's cooldown.\"\"\"\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n+\n+\n+    @client_cooldown.command(name='update')\n+    async def client_cooldown_update(\n+            self, ctx,\n+            command: converters.CommandConverter,\n+            rate: Optional[int] = None,\n+            per: Optional[float] = None,\n+            type: BucketTypeConverter = None):\n+        \"\"\"Update a command's cooldown.\"\"\"\n+        type: commands.BucketType\n+        command: commands.Command\n+\n+        # Fill missing arguments\n+        old_cool: commands.CooldownMapping = command._buckets\n+        if old_cool.valid:\n+            rate = old_cool._cooldown.rate if rate is None else rate\n+            per = old_cool._cooldown.per if per is None else per\n+            type = old_cool._cooldown.type if type is None else type\n+\n+        # Default arguments\n+        if type is None:\n+            type = commands.BucketType.default\n+\n+        # Check arguments\n+        if rate is None:\n+            return await ctx.send(\n+                'There is no cooldown; `rate` must be specified.',\n+                delete_after=10\n+            )\n+        elif rate < 1:\n+            return await ctx.send('`rate` cannot be below 1.', delete_after=10)\n+        elif per is None:\n+            return await ctx.send(\n+                'There is no cooldown; `per` must be specified.',\n+                delete_after=10\n+            )\n+        elif per < 0:\n+            return await ctx.send('`per` cannot be negative.', delete_after=10)\n+\n+        buckets = commands.CooldownMapping(commands.Cooldown(rate, per, type))\n+        command._buckets = buckets\n+\n+        await ctx.send(f'Updated cooldown for {command.name}.')\n+\n+\n+    @client_cooldown.command(name='reset')\n+    async def client_cooldown_reset(self, ctx,\n+                                    everyone: Optional[bool] = False,\n+                                    *, command: converters.CommandConverter):\n+        \"\"\"Reset a command's cooldown.\n+\n+everyone: If true, this will reset everyone's cooldown. Otherwise it only\n+resets your cooldown.\n+command: The name of the command to reset.\"\"\"\n+        command: commands.Command\n+\n+        if not command._buckets.valid:\n+            return await ctx.send('This command does not have a cooldown.',\n+                                  delete_after=10)\n+\n+        if everyone:\n+            buckets = command._buckets\n+            buckets._cache.clear()\n+        else:\n+            command.reset_cooldown(ctx)\n+\n+        await ctx.send(f'Resetted cooldown for {command.name}.')\n+\n+\n+    @client_cooldown.command(name='remove')\n+    async def client_cooldown_remove(\n+            self, ctx, *, command: converters.CommandConverter):\n+        \"\"\"Remove a command's cooldown.\"\"\"\n+        command: commands.Command\n \n+        if not command._buckets.valid:\n+            return await ctx.send('This command does not have a cooldown.',\n+                                  delete_after=10)\n \n-    @commands.command(name='cooldown')\n+        buckets = commands.CooldownMapping(None)\n+        command._buckets = buckets\n+\n+        await ctx.send(f'Removed cooldown for {command.name}.')\n+\n+\n+\n+\n+\n+    @commands.group(name='concurrency', invoke_without_command=True)\n     @checks.is_bot_admin()\n-    async def client_cooldown(self, ctx, *, command):\n-        \"\"\"Reset your cooldown for a command.\n+    async def client_concurrency(self, ctx):\n+        \"\"\"Modify a command's max concurrency.\"\"\"\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n+\n+\n+    @client_concurrency.command(name='update')\n+    async def client_concurrency_update(\n+            self, ctx,\n+            command: converters.CommandConverter,\n+            number: Optional[int] = None,\n+            per: Optional[BucketTypeConverter] = None,\n+            wait: bool = None):\n+        \"\"\"Update a command's concurrency limit.\"\"\"\n+        command: commands.Command\n+\n+        # Fill missing arguments\n+        old_con: commands.MaxConcurrency = command._max_concurrency\n+        if old_con is not None:\n+            number = old_con.number if number is None else number\n+            per = old_con.per if per is None else number\n+            wait = old_con.wait if wait is None else wait\n+\n+        # Default arguments\n+        if per is None:\n+            per = commands.BucketType.default\n+        if wait is None:\n+            wait = False\n+\n+        # Check arguments\n+        if number is None:\n+            return await ctx.send(\n+                'There is no concurrency limit; `number` must be specified.',\n+                delete_after=10\n+            )\n+        elif number < 1:\n+            return await ctx.send('`number` cannot be below 1.', delete_after=10)\n+\n+        con = commands.MaxConcurrency(number, per=per, wait=wait)\n+        command._max_concurrency = con\n+        # NOTE: no need to worry about race conditions since MaxConcurrency.release()\n+        # excepts KeyError if the bucket does not exist\n \n-Will reset cooldowns for all subcommands in a group.\"\"\"\n-        com = self.bot.get_command(command)\n+        await ctx.send(f'Updated concurrency limits for {command.name}.')\n \n-        if com is None:\n-            await ctx.send('Unknown command.')\n \n-        com.reset_cooldown(ctx)\n+    @client_concurrency.command(name='remove')\n+    async def client_concurrency_remove(self, ctx, *,\n+                                        command: converters.CommandConverter):\n+        \"\"\"Remove a command's max concurrency limit.\"\"\"\n+        command: commands.Command\n+\n+        if command._max_concurrency is None:\n+            return await ctx.send(\n+                'This command does not have a max concurrency limit.',\n+                delete_after=10\n+            )\n \n-        await ctx.send('Cooldown reset.')\n+        command._max_concurrency = None\n+        await ctx.send(f'Removed concurrency limits for {command.name}.')\n \n \n \n@@ -90,7 +244,7 @@ def cleanup_code(content):\n     @commands.command(name='execute')\n     @checks.is_bot_owner()\n     async def client_execute(\n-            self, ctx, sendIOtoDM: typing.Optional[bool] = False, *, x: str):\n+            self, ctx, sendIOtoDM: Optional[bool] = False, *, x: str):\n         \"\"\"Run python code in an async condition.\n Graphs can be generated if a Figure is returned.\n \n@@ -141,6 +295,7 @@ async def send(*args, **kwargs):\n             with contextlib.redirect_stdout(f):\n                 result = await environment['func']()\n         except Exception:\n+            # TODO: paginate error message\n             error_message = utils.exception_message()\n             return await ctx.send(f'```py\\n{error_message}```')\n \n@@ -150,6 +305,7 @@ async def send(*args, **kwargs):\n             image = io.BytesIO()\n             result.savefig(\n                 image, format='png', bbox_inches='tight', pad_inches=0)\n+            plt.close(result)\n             image.seek(0)\n             image = discord.File(image, 'Graph.png')\n             result = None\n@@ -173,7 +329,7 @@ async def send(*args, **kwargs):\n     async def client_clearsettingscache(self, ctx):\n         \"\"\"Clear the settings cache.\"\"\"\n         settings.clear_cache()\n-        await ctx.send('Cleared cache.')\n+        await ctx.send('Cleared cache.', delete_after=10)\n \n \n \n@@ -184,7 +340,8 @@ async def client_clearsettingscache(self, ctx):\n     @commands.cooldown(2, 40, commands.BucketType.default)\n     async def client_presence(self, ctx):\n         \"\"\"Commands to change the bot's presence. Restricted to admins.\"\"\"\n-        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n \n \n     @client_presence.command(name='competing')\n@@ -208,7 +365,7 @@ async def client_competing_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(\n@@ -232,7 +389,7 @@ async def client_playing_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(\n@@ -260,7 +417,7 @@ async def client_streaming_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(name='listening')\n@@ -284,7 +441,7 @@ async def client_listening_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(\n@@ -309,7 +466,7 @@ async def client_watching_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(\n@@ -332,7 +489,7 @@ async def client_status_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n \n@@ -367,6 +524,9 @@ def reload(ext):\n                 return 'This extension failed to be reloaded.'\n \n         if extension == 'all':\n+            logger.info('Attempting to reload all extensions '\n+                        f'by {get_user_for_log(ctx)}')\n+            await ctx.trigger_typing()\n             # NOTE: must cast dict into list as extensions is mutated\n             # during reloading\n             for ext in list(self.bot.extensions):\n@@ -380,6 +540,7 @@ def reload(ext):\n         else:\n             logger.info(f'Attempting to reload {extension} extension '\n                         f'by {get_user_for_log(ctx)}')\n+            await ctx.trigger_typing()\n             result = reload(extension)\n             if result is not None:\n                 await ctx.send(result)\n@@ -472,9 +633,30 @@ async def client_sendmessage_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, AttributeError):\n             if \"'NoneType' object has no attribute\" in str(error):\n-                await ctx.send('I cannot find the given channel.')\n+                await ctx.send('I cannot find the given channel.', delete_after=8)\n         elif isinstance(error, discord.Forbidden):\n-            await ctx.send('I cannot access this given channel.')\n+            await ctx.send('I cannot access this given channel.', delete_after=8)\n+\n+\n+\n+\n+\n+    @commands.command(name='restart')\n+    @checks.is_bot_owner()\n+    async def client_restart(self, ctx):\n+        \"\"\"Restarts the bot.\"\"\"\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n+\n+        confirmed = await prompt.confirm(\n+            'Are you sure you want to RESTART the bot?')\n+\n+        if confirmed:\n+            await prompt.update('Restarting.', prompt.emoji_yes.color)\n+            send_restart_signal()\n+            print(f'Initiating restart by {get_user_for_log(ctx)}')\n+            await self.bot.logout()\n+        else:\n+            await prompt.update('Cancelled restart.', prompt.emoji_no.color)\n \n \n \n@@ -482,14 +664,21 @@ async def client_sendmessage_error(self, ctx, error):\n \n     @commands.command(\n         name='shutdown',\n-        brief='Shutdown the bot.',\n         aliases=('close', 'exit', 'quit', 'stop'))\n     @checks.is_bot_owner()\n     async def client_shutdown(self, ctx):\n-        \"\"\"Shuts down the bot.\"\"\"\n-        print('Shutting down')\n-        await ctx.send('Shutting down.')\n-        await self.bot.logout()\n+        \"\"\"Shutdown the bot.\"\"\"\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n+\n+        confirmed = await prompt.confirm(\n+            'Are you sure you want to SHUTDOWN the bot?')\n+\n+        if confirmed:\n+            await prompt.update('Shutting down.', prompt.emoji_yes.color)\n+            print(f'Initiating shutdown by {get_user_for_log(ctx)}')\n+            await self.bot.logout()\n+        else:\n+            await prompt.update('Cancelled shutdown.', prompt.emoji_no.color)\n \n \n \ndiff --git a\/bot\/commands\/background.py b\/bot\/commands\/background.py\nindex cb73f1d..a0d318e 100644\n--- a\/bot\/commands\/background.py\n+++ b\/bot\/commands\/background.py\n@@ -13,8 +13,8 @@\n # Since the settings file is used as an argument to decorators which are\n # evaluated at runtime, the file must be set up\n class Tasks(commands.Cog):\n+    \"\"\"Commands for controlling background tasks.\"\"\"\n     qualified_name = 'Tasks'\n-    description = 'Commands for controlling background tasks.'\n \n     def __init__(self, bot):\n         self.bot = bot\n@@ -163,10 +163,11 @@ async def before_random_presence(self):\n     @checks.is_bot_admin()\n     async def random_presence_toggle(self, ctx, toggle: bool):\n         if toggle:\n-            try:\n+            if not self.random_precense.is_running():\n                 self.random_presence.start()\n-            except RuntimeError:\n-                return await ctx.send('The task is already running.')\n+            else:\n+                return await ctx.send(\n+                    'The task is already running.', delete_after=6)\n \n             min_delay = settings.get_setting('bgtask_RandomPresenceMinDelay')\n             max_delay = settings.get_setting('bgtask_RandomPresenceMaxDelay')\n@@ -178,10 +179,12 @@ async def random_presence_toggle(self, ctx, toggle: bool):\n                     max_delay\n                 )\n             )\n-        else:\n+        elif self.random_precense.is_running():\n             self.random_presence.cancel()\n             print('Disabled random presence')\n             await ctx.send('Turned off random presence changes.')\n+        else:\n+            await ctx.send('The task is not running.', delete_after=6)\n \n \n \ndiff --git a\/bot\/commands\/ciphers.py b\/bot\/commands\/ciphers.py\nindex 9632f76..ad95ca6 100644\n--- a\/bot\/commands\/ciphers.py\n+++ b\/bot\/commands\/ciphers.py\n@@ -163,8 +163,8 @@\n \n \n class Ciphers(commands.Cog):\n+    \"\"\"Commands for encoding\/decoding text.\"\"\"\n     qualified_name = 'Ciphers'\n-    description = 'Commands for encoding\/decoding text.'\n \n     def __init__(self, bot):\n         self.bot = bot\n@@ -209,6 +209,7 @@ def ciphercaesar(shift: int, text: str):\n     @commands.cooldown(2, 5, commands.BucketType.member)\n     async def client_ciphercaesar(self, ctx, shift: int, *, string: str):\n         \"\"\"Takes an amount of letters to shift and a string.\n+\n shift: An integer amount of letters to shift. Can be a negative integer.\n string: A string to cipher.\"\"\"\n         await ctx.send(self.ciphercaesar(shift, string))\n@@ -239,10 +240,12 @@ async def client_atbash(self, ctx, *, string: str):\n         name='reversecipher',\n         brief='The Reverse Cipher.',\n         aliases=('reverse',))\n-    async def client_cipherreverse(self, ctx, *, string: str):\n+    @commands.cooldown(1, 3, commands.BucketType.member)\n+    async def client_cipherreverse(self, ctx, *, message: str):\n         \"\"\"Takes a string and reverses it.\n-string: A string to cipher.\"\"\"\n-        result = string[::-1]\n+\n+message: A message to cipher.\"\"\"\n+        result = message[::-1]\n \n         await ctx.send(result)\n \n@@ -283,6 +286,7 @@ def ciphercolumnar(key: int, s: str):\n     @commands.cooldown(1, 3, commands.BucketType.member)\n     async def client_ciphercolumnar(self, ctx, key: int, *, string: str):\n         \"\"\"See http:\/\/inventwithpython.com\/cracking\/chapter7.html\n+\n key: The integer key to use in the cipher.\n  Must be between 2 and half the message size.\n string: A string to cipher.\n@@ -302,7 +306,7 @@ async def client_ciphercolumnar(self, ctx, key: int, *, string: str):\n This will be the ciphertext.\"\"\"\n         # Test if key is in valid range\n         if key < 2 or key > len(string) \/\/ 2:\n-            return await ctx.send('Key is out of range.')\n+            return await ctx.send('Key is out of range.', delete_after=8)\n \n         await ctx.send(self.ciphercolumnar(key, string))\n \n@@ -348,21 +352,23 @@ def cipherotp(text: str, key: str, decipher: bool):\n         brief='The One-time Pad Cipher.',\n         aliases=('otpc',))\n     @commands.cooldown(1, 3, commands.BucketType.member)\n-    async def client_cipherotp(self, ctx, mode: str, text: str, key: str):\n+    async def client_cipherotp(self, ctx, mode: commands.clean_content,\n+                               text: str, key: str):\n         \"\"\"Cipher\/decipher alphanumeric text (excluding spaces) \\\n using the one-time pad cipher.\n+\n mode: Indicate whether to cipher or decipher the text\n- (\"cipher\"\/\"ci\", \"decipher\"\/\"de\").\n+ (\"encode\"\/\"en\", \"decode\"\/\"de\").\n text: The text to cipher\/decipher.\n key: The one time key to use.\"\"\"\n         mode = mode.casefold()\n \n-        if mode in ('cipher', 'ci'):\n+        if mode in ('encode', 'en'):\n             mode = False\n-        elif mode in ('decipher', 'de'):\n+        elif mode in ('decode', 'de'):\n             mode = True\n         else:\n-            return await ctx.send('Mode must be either \"cipher\" or \"decipher\"')\n+            return await ctx.send('Unknown mode \"{mode}\"', delete_after=6)\n \n         await ctx.send(self.cipherotp(text, key, mode))\n \n@@ -472,12 +478,10 @@ def encode_word(word):\n         brief='The morse code encrypter\/decrypter.',\n         aliases=('morse', 'mc', 'mcode'))\n     @commands.cooldown(1, 3, commands.BucketType.member)\n-    async def client_morsecode(self, ctx,\n-        mode: str, spacing: str, *, string: str):\n+    async def client_morsecode(\n+            self, ctx, mode: commands.clean_content,\n+            spacing: commands.clean_content, *, string: str):\n         \"\"\"Translates text to morse code and back.\n-mode: Either \"encode\"\/\"en\" or \"decode\"\/\"de\". Selects between encoding and decoding.\n-spacing: Either \"space\"\/\"spaces\" or \"bar\"\/\"bars\". Selects between using \" \"\/\" \/ \" and \"|\"\/\"||\" to show letter and word gaps.\n-string: The text or morse code to encrypt\/decrypt.\n Allowed characters:\n     abcdefghijklmnopqrstuvwxyz 0123456789,;.:?!()+-\/=@&_'\"\n Prosigns that are encoded and decoded cleanly:\n@@ -494,7 +498,11 @@ async def client_morsecode(self, ctx,\n     <BT>  New paragraph           -> =\n     <KN>  Invite specific station -> (\n     <SN>  Understood (alternate form <VE> can be used, but decodes to <SN>)\n-Other characters will be passed through.\"\"\"\n+Other characters will be passed through.\n+\n+mode: Either \"encode\"\/\"en\" or \"decode\"\/\"de\". Selects between encoding and decoding.\n+spacing: Either \"space\"\/\"spaces\" or \"bar\"\/\"bars\". Selects between using \" \"\/\" \/ \" and \"|\"\/\"||\" to show letter and word gaps.\n+string: The text or morse code to encrypt\/decrypt.\"\"\"\n         mode = mode.casefold()\n         spacing = spacing.casefold()\n \n@@ -503,7 +511,7 @@ async def client_morsecode(self, ctx,\n         elif mode in ('decode', 'de'):\n             decoding = True\n         else:\n-            raise ValueError(f'Unknown mode {mode!r}')\n+            return await ctx.send(f'Unknown mode \"{mode}\"', delete_after=6)\n \n         if spacing in ('space', 'spaces'):\n             character_gap = ' '\n@@ -512,7 +520,8 @@ async def client_morsecode(self, ctx,\n             character_gap = '|'\n             space_char = '||'\n         else:\n-            raise ValueError(f'Unknown spacing {spacing!r}')\n+            return await ctx.send(\n+                f'Unknown spacing \"{spacing}\"', delete_after=6)\n \n         message = self.morsecode(\n             decoding, string,\n@@ -522,13 +531,6 @@ async def client_morsecode(self, ctx,\n         await ctx.send(f'```\\n{message}```')\n \n \n-    @client_morsecode.error\n-    async def client_morsecode_error(self, ctx, error):\n-        error = getattr(error, 'original', error)\n-        if isinstance(error, ValueError):\n-            await ctx.send(str(error))\n-\n-\n     @commands.command(\n         name='morsecodetable',\n         brief='The interational morse code table.',\n@@ -576,9 +578,10 @@ def ciphervigenere(text: str, key: str, decipher: bool):\n         name='vigenerecipher',\n         brief='The Vigenere Cipher.')\n     @commands.cooldown(1, 3, commands.BucketType.member)\n-    async def client_vigenerecipher(self, ctx,\n-        mode: str, key: str, *, text: str):\n+    async def client_vigenerecipher(\n+            self, ctx, mode: commands.clean_content, key: str, *, text: str):\n         \"\"\"Encrypt.\n+\n mode: Either \"encrypt\"\/\"en\" or \"decrypt\"\/\"de\". Selects between encrypting and decrypting.\n key: The key to use.\n text: The text to encrypt\/decrypt.\"\"\"\n@@ -589,19 +592,12 @@ async def client_vigenerecipher(self, ctx,\n         elif mode in ('decrypt', 'de'):\n             decrypting = True\n         else:\n-            raise ValueError(f'Unknown mode {mode!r}')\n+            return await ctx.send(f'Unknown mode \"{mode}\"', delete_after=6)\n \n         await ctx.send(\n             '```' + self.ciphervigenere(text, key, decrypting) + '```')\n \n \n-    @client_vigenerecipher.error\n-    async def client_vigenerecipher_error(self, ctx, error):\n-        error = getattr(error, 'original', error)\n-        if isinstance(error, ValueError):\n-            await ctx.send(str(error))\n-\n-\n \n \n \ndiff --git a\/bot\/commands\/embedding.py b\/bot\/commands\/embedding.py\nindex 537a8a6..a639911 100644\n--- a\/bot\/commands\/embedding.py\n+++ b\/bot\/commands\/embedding.py\n@@ -2,16 +2,21 @@\n import collections\n import datetime\n import functools\n+import re\n \n import discord\n from discord.ext import commands\n+from discord_slash.utils import manage_commands\n+from discord_slash import cog_ext as dslash_cog\n+from discord_slash import SlashContext\n+import discord_slash as dslash\n \n from bot import utils\n \n \n class Embedding(commands.Cog):\n+    \"\"\"Commands for creating embeds.\"\"\"\n     qualified_name = 'Embedding'\n-    description = 'Commands for creating embeds.'\n \n     embed_specs = {\n         'title':    ('--title', '-T'),\n@@ -24,6 +29,8 @@ class Embedding(commands.Cog):\n         'authorurl':          ('--authorurl', '-AU')\n     }\n \n+    hyperlink_regex = re.compile('\\[.+\\]\\(.+\\)')\n+\n     def __init__(self, bot):\n         self.bot = bot\n \n@@ -42,10 +49,10 @@ async def client_createembed(\n             *parameters):\n         \"\"\"Create an embed.\n Example:\n-    embed 0xDDA212 \"description with \\\\\"quotes\\\\\"\" --title \"Title\"\n-If you want to stop links from being embedded in your message,\n+> embed 0xDDA212 \"description with \\\\\\\\\"quotes\\\\\\\\\"\" --title \"Title\"\n+If you want to stop links from being embedded in your command,\n you can use code block tags like so:\n-    embed FFCC22 description `\u200b`\u200b` --title Title `\u200b`\u200b`\n+> embed FFCC22 description \\`\\`\u200b\\` --title Title \\`\\`\\`\n \n -T  --title        \"<text>\"\n -TU --titleurl     <url>\n@@ -146,7 +153,13 @@ def default_field(field_num):\n             embed_dict['fields'] = list(fields.values())\n         embed = discord.Embed.from_dict(embed_dict)\n         embed.timestamp = datetime.datetime.now().astimezone()\n-        await ctx.send(embed=embed)\n+        try:\n+            await ctx.send(embed=embed)\n+        except discord.HTTPException as e:\n+            await ctx.send(\n+                f'There was an error with your embed parameters: {e.text}',\n+                delete_after=10\n+            )\n \n \n \n@@ -159,7 +172,8 @@ async def client_hyperlink(self, ctx):\n         \"\"\"Commands for using the Embed's hyperlink feature.\n \n These commands only work in servers.\"\"\"\n-        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n         ctx.command.reset_cooldown(ctx)\n \n \n@@ -171,10 +185,11 @@ async def client_hyperlink_procedure(self, ctx):\n You will be DM'd for your parameters.\"\"\"\n         async def cancel_message(message):\n             await message.edit(\n-                content=f'~~{message.content}~~ Canceled hyperlink.')\n+                content=f'~~{message.content}~~ Canceled hyperlink.',\n+                delete_after=10\n+            )\n \n         def check(message):\n-            \"Wait for a message in the author's DMs.\"\n             return message.channel == ctx.author.dm_channel\n \n         link_request = await ctx.author.send(\n@@ -232,10 +247,11 @@ async def client_hyperlink_quick(self, ctx):\n You will be DM'd for your parameters.\"\"\"\n         async def cancel_message(message):\n             await message.edit(\n-                content=f'~~{message.content}~~ Canceled hyperlink.')\n+                content=f'~~{message.content}~~ Canceled hyperlink.',\n+                delete_after=10\n+            )\n \n         def check(message):\n-            \"Wait for a message in the author's DMs.\"\n             return message.channel == ctx.author.dm_channel\n \n         message_request = await ctx.author.send(\n@@ -266,6 +282,31 @@ def check(message):\n \n \n \n+    @dslash_cog.cog_slash(\n+        name='hyperlink',\n+        options=[manage_commands.create_option(\n+            name='message',\n+            description=\"The message to format. Example: text [display text](https:\/\/mylink.com\/) text\",\n+            option_type=3,\n+            required=True\n+        )]\n+    )\n+    async def client_slash_hyperlink(self, ctx: SlashContext, message):\n+        \"\"\"Send a message with the ability to replace links with custom text.\"\"\"\n+        await ctx.respond(eat=True)\n+        if not self.hyperlink_regex.search(message):\n+            return await ctx.send(\n+                'Your message should use a custom text hyperlink at least once.\\n'\n+                'See the example in the message option.',\n+                hidden=True\n+            )\n+        content = f\"**Hyperlink message by {ctx.author.mention}**\\n{message}\"\n+        await ctx.send(content, allowed_mentions=discord.AllowedMentions.none())\n+\n+\n+\n+\n+\n \n \n \ndiff --git a\/bot\/commands\/games.py b\/bot\/commands\/games.py\nindex 4df80d6..295ae22 100644\n--- a\/bot\/commands\/games.py\n+++ b\/bot\/commands\/games.py\n@@ -1,27 +1,252 @@\n import asyncio\n+import collections\n+import csv\n+import json\n+import math\n+import random\n+from concurrent.futures.thread import ThreadPoolExecutor\n+from typing import Optional, List, Union\n \n import discord\n from discord.ext import commands\n+import inflect\n \n-from bot.classes.games import multimath\n+from bot.classes.confirmation import AdaptiveConfirmation\n+from bot.classes.games import blackjack, multimath\n+from bot.classes.get_reaction import get_reaction\n from bot.classes import paginator\n+from bot.database import GameDatabase\n+from bot import checks, utils\n+\n+inflector = inflect.engine()\n+\n+\n+# phasmophobia commands\n+class Ghost:\n+    __slots__ = ('name', 'evidences', 'url')\n+\n+    def __init__(self, name, evidences, url):\n+        self.name = name\n+        self.evidences = evidences\n+        self.url = url\n+\n+\n+GHOST_EVIDENCE = [\n+    Ghost('Banshee',\n+          ('EMF Level 5', 'Fingerprints', 'Freezing Temperatures'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Banshee'),\n+    Ghost('Demon',\n+          ('Freezing Temperatures', 'Ghost Writing', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Demon'),\n+    Ghost('Jinn',\n+          ('EMF Level 5', 'Ghost Orb', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Jinn'),\n+    Ghost('Mare',\n+          ('Freezing Temperatures', 'Ghost Orb', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Mare'),\n+    Ghost('Oni',\n+          ('EMF Level 5', 'Ghost Writing', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Oni'),\n+    Ghost('Phantom',\n+          ('EMF Level 5', 'Freezing Temperatures', 'Ghost Orb'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Phantom'),\n+    Ghost('Poltergeist',\n+          ('Fingerprints', 'Ghost Orb', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Poltergeist'),\n+    Ghost('Revenant',\n+          ('EMF Level 5', 'Fingerprints', 'Ghost Writing'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Revenant'),\n+    Ghost('Shade',\n+          ('EMF Level 5', 'Ghost Orb', 'Ghost Writing'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Shade'),\n+    Ghost('Spirit',\n+          ('Fingerprints', 'Ghost Writing', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Spirit'),\n+    Ghost('Wraith',\n+          ('Fingerprints', 'Freezing Temperatures', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Wraith'),\n+    Ghost('Yurei',\n+          ('Freezing Temperatures', 'Ghost Orb', 'Ghost Writing'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Yurei')\n+]\n+EVIDENCES = [\n+    'EMF Level 5', 'Freezing Temperatures', 'Fingerprints',\n+    'Ghost Orb', 'Ghost Writing', 'Spirit Box'\n+]\n+\n+\n+def phasmophobia_match_ghost_evidence(evidences):\n+    possible_ghosts = GHOST_EVIDENCE\n+\n+    for e in evidences:\n+        new_ghosts = []\n+\n+        for g in possible_ghosts:\n+            if e.lower() in [gev.lower() for gev in g.evidences]:\n+                new_ghosts.append(g)\n+\n+        possible_ghosts = new_ghosts\n+\n+        if len(possible_ghosts) == 0:\n+            return possible_ghosts\n+\n+    return possible_ghosts\n+\n+\n+# unturned commands\n+class UnturnedItem:\n+    __slots__ = ('id', 'name', 'rarity', 'url', 'dimensions', 'recipe_data')\n+\n+    def __init__(self, id_, name, rarity, url, dimensions, recipe_data):\n+        self.id = id_\n+        self.name = name\n+        self.rarity = rarity\n+        self.url = url\n+        self.dimensions = dimensions\n+        self.recipe_data = recipe_data\n+\n+    def __repr__(self):\n+        return '{}({!r}, {!r})'.format(\n+            self.__class__.__name__,\n+            self.id,\n+            self.name\n+        )\n+\n+\n+class UnturnedDatabase:\n+    UNTURNED_ITEM_IDS_PATH = 'data\/unturned_item_ids.csv'\n+    UNTURNED_ITEM_RECIPES_PATH = 'data\/unturned_recipes.json'\n+\n+    def __init__(self, items):\n+        self.items = items\n+\n+    @classmethod\n+    def _get_items_from_files(cls):\n+        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:\n+            recipes = json.load(f)\n+\n+        items = {}\n+        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:\n+            reader = csv.reader(f)\n+            header = next(reader)\n+            for id_, name, rarity, url in reader:\n+                rec = recipes.get(id_)\n+                dimensions = rec['dimensions'] if rec else None\n+                recipe_data = (\n+                    {'primitive': rec['primitive'],\n+                     'recipes': rec['recipes']}\n+                    if rec else None\n+                )\n+                id_ = int(id_)\n+                items[id_] = UnturnedItem(\n+                    id_, name, rarity, url, dimensions, recipe_data)\n+\n+        return items\n+\n+    @classmethod\n+    async def _get_items_from_files_nonblocking(cls):\n+        executor = ThreadPoolExecutor()\n+        loop = asyncio.get_running_loop()\n+\n+        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:\n+            recipes = json.loads(await loop.run_in_executor(executor, f.read))\n+\n+        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:\n+            raw_lines = await loop.run_in_executor(executor, f.readlines)\n+\n+        items = {}\n+        reader = csv.reader(raw_lines)\n+        next(reader)  # skip header\n+\n+        for ID, name, rarity, url in reader:\n+            rec = recipes.get(ID)\n+            dimensions = rec['dimensions'] if rec else None\n+            recipe_data = (\n+                {'primitive': rec['primitive'],\n+                 'recipes': rec['recipes']}\n+                if rec else None\n+            )\n+\n+            ID = int(ID)\n+            items[ID] = UnturnedItem(ID, name, rarity, url,\n+                                     dimensions, recipe_data)\n+\n+        return items\n+\n+    def reload_items(self):\n+        \"\"\"Regenerate self.items from the data files.\"\"\"\n+        self.items = self._get_items_from_files()\n+\n+    async def reload_items_nonblocking(self):\n+        \"\"\"Regenerate self.items from the data files.\n+        Uses a thread pool to read files.\"\"\"\n+        self.items = await self._get_items_from_files_nonblocking()\n+\n+    def unturned_get_item(self, search: str) \\\n+            -> Optional[Union[UnturnedItem, List[UnturnedItem]]]:\n+        \"\"\"Search for an item from UNTURNED_ITEM_IDS either by name or ID.\n+\n+        Returns:\n+            List[UnturnedItem]: multiple matches were found.\n+            None: no matches were found.\n+            UnturnedItem: the search term matches one item.\n+\n+        \"\"\"\n+        def get_item_by_name(name):\n+            result = discord.utils.get(self.items.values(), name=name)\n+            if result is None:\n+                raise ValueError(f'Could not find an item with that name.')\n+            return result\n+\n+        # Search by ID\n+        try:\n+            item_id = int(search)\n+        except ValueError:\n+            pass\n+        else:\n+            return self.items.get(item_id)\n+\n+        # Search by name\n+        result = utils.fuzzy_match_word(\n+            search, tuple(entry.name for entry in self.items.values()),\n+            return_possible=True\n+        )\n+\n+        if isinstance(result, str):\n+            return get_item_by_name(result)\n+        elif isinstance(result, collections.abc.Iterable):\n+            return [get_item_by_name(name) for name in result]\n+        elif result is None:\n+            return\n+\n+    @classmethod\n+    def from_files(cls):\n+        return cls(cls._get_items_from_files())\n \n \n class Games(commands.Cog):\n+    \"\"\"Commands with interactive games and related to other games.\"\"\"\n     qualified_name = 'Games'\n-    description = 'Commands with interactive games.'\n+\n+    BLACKJACK_SESSION_LENGTH = 30\n+    # The number of rounds that can be played in a single session.\n+    BLACKJACK_SHUFFLE_SIZE = 0.5\n+    # The percentage at which the deck size is too small\n+    # and should be shuffled. The lower, the less frequent the shuffling.\n \n     def __init__(self, bot):\n         self.bot = bot\n+        self.gamedb = GameDatabase\n+        self.unturneddb = UnturnedDatabase.from_files()\n \n \n \n \n \n     @commands.command(name='testpages')\n-    @commands.max_concurrency(1, commands.BucketType.channel)\n+    @commands.is_owner()\n     async def client_testpages(self, ctx):\n-        \"Create a simple paginator.\"\n+        \"\"\"Create a simple paginator.\"\"\"\n         embeds = [\n             discord.Embed(title=\"test page 1\",\n                 description=\"This is just some test content!\", color=0x115599),\n@@ -39,43 +264,826 @@ async def client_testpages(self, ctx):\n \n \n \n+    @commands.command(name='testconfirmation')\n+    @commands.is_owner()\n+    async def client_testconfirmation(self, ctx):\n+        \"\"\"Create a test confirmation prompt.\"\"\"\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n+\n+        confirmed = await prompt.confirm('Confirmation')\n+\n+        if confirmed:\n+            await prompt.update('Confirmed', prompt.emoji_yes.color)\n+        else:\n+            await prompt.update('Cancelled', prompt.emoji_no.color)\n+\n+\n+\n+\n+\n+    def get_members(self, ctx, players: str, members: list) \\\n+            -> Optional[List[discord.User]]:\n+        \"\"\"Take a players and greedy members argument and parse it\n+        for the users argument in games.\"\"\"\n+        lower = players.lower()\n+        if lower == 'allow':\n+            if members:\n+                # Player whitelist\n+                members.append(ctx.author)\n+                return members\n+            # All players\n+            return None\n+        elif lower in ('me', 'all'):\n+            if members:\n+                # Argument error\n+                raise ValueError(\n+                    'You cannot specify which members can play if you do '\n+                    'not allow others. See the help message for more info.'\n+                )\n+            return [ctx.author] if lower == 'me' else None\n+        else:\n+            raise ValueError(f'Unknown input for \"players\": {players!r}')\n+\n+\n+\n+\n+\n+    @commands.group(name='blackjack', aliases=('bj',), invoke_without_command=True)\n+    @commands.cooldown(1, 20, commands.BucketType.user)\n+    @commands.max_concurrency(2, commands.BucketType.channel)\n+    async def client_blackjack(\n+            self, ctx,\n+            size: Optional[int] = 2,\n+            players='me',\n+            members: commands.Greedy[discord.User] = None):\n+        \"\"\"Start a session of blackjack.\n+\n+This game allows multiple people to participate with the same hand.\n+If the first parameter says \"allow\", you can then specify which other members are allowed to play, by mention or name:\n+> blackjack allow Alice#1234 Bob\n+If no members are specified after \"allow\" or you type \"all\", anyone can play:\n+> blackjack all\n+Otherwise, only you can play:\n+> blackjack\n+\n+size: (optional) The size of the deck to use in the session.\n+    Only double-decks will count towards your stats.\"\"\"\n+        def create_deck(size):\n+            deck = [c for _ in range(size) for c in blackjack.CARDS]\n+            random.shuffle(deck)\n+            return deck\n+\n+        def time_to_shuffle(deck, size):\n+            return len(deck) \/ (52 * size) < self.BLACKJACK_SHUFFLE_SIZE\n+\n+        if ctx.guild is None and not self.bot.intents.members:\n+            return await ctx.send(\n+                'Unfortunately games will not work in DMs at this time.',\n+                delete_after=10\n+            )\n+        elif size < 1:\n+            return await ctx.send('The deck size must be at least one.',\n+                                  delete_after=6)\n+        elif size > 10:\n+            return await ctx.send('The deck size can only be ten at most.',\n+                                  delete_after=6)\n+\n+        try:\n+            users = self.get_members(ctx, players, members)\n+        except ValueError as e:\n+            return await ctx.send(e, delete_after=8)\n+\n+        message = None\n+        d = create_deck(size)\n+        i = 0\n+        while not self.bot.is_closed():\n+            if time_to_shuffle(d, size):\n+                await message.edit(content='Shuffling deck...')\n+                d = create_deck(size)\n+                await asyncio.sleep(2)\n+\n+            game = blackjack.BotBlackjackGame(ctx, deck=d, message=message)\n+\n+            i += 1\n+            outro = 'React to the play emoji to continue.'\n+            if i >= self.BLACKJACK_SESSION_LENGTH:\n+                outro = ('Reached maximum session length of '\n+                         f'{self.BLACKJACK_SESSION_LENGTH} games.')\n+\n+            results = await game.run(\n+                users=users, outro_content=outro)\n+\n+            if results.done:\n+                if size == 2:\n+                    await self.gamedb.blackjack.change(\n+                        'played', results.last_player.id, 1)\n+                    if results.player.maximum == 21:\n+                        await self.gamedb.blackjack.change(\n+                            'blackjacks', results.last_player.id, 1)\n+                    if results.winner:\n+                        await self.gamedb.blackjack.change(\n+                            'wins', results.last_player.id, 1)\n+                    elif results.winner is False:\n+                        await self.gamedb.blackjack.change(\n+                            'losses', results.last_player.id, 1)\n+            else:\n+                # Game timed out\n+                break\n+\n+            if i >= self.BLACKJACK_SESSION_LENGTH:\n+                break\n+\n+            message = game.message\n+\n+            # Loop the game if the player(s) react with this emoji\n+            emojis = ['\\N{BLACK RIGHT-POINTING TRIANGLE}']\n+            for e in emojis:\n+                await message.add_reaction(e)\n+\n+            try:\n+                await get_reaction(self.bot, message, emojis, users, timeout=15)\n+            except asyncio.TimeoutError:\n+                return await message.edit(content='Finished session.')\n+\n+\n+\n+\n+\n+    @client_blackjack.group(name='stats', invoke_without_command=True)\n+    @commands.cooldown(2, 15, commands.BucketType.user)\n+    async def client_blackjack_stats(self, ctx):\n+        \"\"\"View your blackjack stats.\"\"\"\n+        db = self.gamedb.blackjack\n+        row = await db.get_blackjack_row(ctx.author.id)\n+        blackjacks = row['blackjacks']\n+        losses = row['losses']\n+        played = row['played']\n+        wins = row['wins']\n+        ties = played - wins - losses\n+\n+        description = [\n+            f'Games played: **{played:,}**',\n+            f'Wins: **{wins:,}**',\n+            f'Losses: **{losses:,}**'\n+        ]\n+        if ties:\n+            description.append(f'Ties: **{ties:,}**')\n+        if blackjacks:\n+            description.append(f'Blackjacks: **{blackjacks:,}**')\n+        if played:\n+            rate = f'Win rate: **{wins \/ played:.0%}**'\n+            description.append(rate)\n+            if ties:\n+                description.append(\n+                    f'Win rate (no pushes): **{wins \/ (played - ties):.0%}**')\n+\n+        description = '\\n'.join(description)\n+        embed = discord.Embed(\n+            color=utils.get_user_color(ctx.author),\n+            description=description\n+        ).set_author(\n+            name=ctx.author.display_name,\n+            icon_url=ctx.author.avatar_url\n+        )\n+\n+        await ctx.send(embed=embed)\n+\n+\n+\n+\n+\n+    @client_blackjack.group(name='reset', invoke_without_command=True)\n+    @commands.cooldown(1, 60, commands.BucketType.user)\n+    async def client_blackjack_stats_reset(self, ctx):\n+        \"\"\"Reset your blackjack stats.\"\"\"\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n+\n+        confirmed = await prompt.confirm(\n+            'Are you sure you want to reset your blackjack stats?')\n+\n+        if confirmed:\n+            await self.gamedb.delete_data(ctx.author.id)\n+            await prompt.update('Successfully wiped your stats!',\n+                                prompt.emoji_yes.color)\n+        else:\n+            await prompt.update('Cancelled reset.', prompt.emoji_no.color)\n+\n+\n+\n+\n+\n     @commands.command(name='multimath')\n-    @commands.max_concurrency(1, commands.BucketType.channel)\n+    @commands.cooldown(1, 20, commands.BucketType.user)\n+    @commands.max_concurrency(2, commands.BucketType.channel)\n     async def client_multimath(\n             self, ctx,\n-            players='only me',\n+            players='me',\n             members: commands.Greedy[discord.User] = None):\n         \"\"\"Answer simple multiple-choice math expressions.\n \n If the first parameter says \"allow\", you can then specify which other members are allowed to play, by mention or name:\n > multimath allow Alice#1234 Bob\n-If no members are specified after \"allow\", anyone can play:\n-> multimath allow\n+If no members are specified after \"allow\" or you type \"all\", anyone can play:\n+> multimath all\n Otherwise, only you can play:\n > multimath\"\"\"\n-        if 'allow' in players.lower():\n-            if members:\n-                # Player whitelist\n-                users = members\n-                users.append(ctx.author)\n-            else:\n-                # All players\n-                users = True\n+        if ctx.guild is None and not self.bot.intents.members:\n+            return await ctx.send(\n+                'Unfortunately games will not work in DMs at this time.',\n+                delete_after=10\n+            )\n+\n+        try:\n+            users = self.get_members(ctx, players, members)\n+        except ValueError as e:\n+            return await ctx.send(e, delete_after=8)\n+\n+        game = multimath.BotMultimathGame(ctx)\n+\n+        await game.run(users=users)\n+\n+\n+\n+\n+\n+    @commands.group(name='phasmophobia', invoke_without_command=True)\n+    async def client_phasmophobia(self, ctx):\n+        \"\"\"Commands related to the game Phasmophobia.\"\"\"\n+\n+\n+    @client_phasmophobia.command(name='evidence')\n+    @commands.cooldown(3, 10, commands.BucketType.user)\n+    async def client_phasmophobia_ghost_evidence(self, ctx, *, evidences):\n+        \"\"\"Determine the ghost(s) based on evidence.\n+Example usage:\n+    <command> emf level 5, fingerprints, freezing temp\n+Available evidences:\n+EMF Level 5\n+Freezing Temperatures\n+Fingerprints\n+Ghost Orb\n+Ghost Writing\n+Spirit Box\"\"\"\n+        def show_evidence(evidences, has_corrected):\n+            if not has_corrected:\n+                return ''\n+            return f\" ({', '.join(evidences)})\"\n+\n+        evidences = [s.strip() for s in evidences.split(',') if s.strip()]\n+\n+        # Fuzzy match the evidence\n+        corrected_evidence = False\n+        for i, e in enumerate(evidences):\n+            match = utils.fuzzy_match_word(e, EVIDENCES)\n+            if not match:\n+                return await ctx.send(f'Unknown evidence: \"{e}\"')\n+            elif match == e:\n+                continue\n+            evidences[i] = match\n+            corrected_evidence = True\n+\n+        # Determine ghosts\n+        ghosts = phasmophobia_match_ghost_evidence(evidences)\n+\n+        title = None\n+        embed = None\n+        if not ghosts:\n+            title = 'No ghosts match the given evidence{}.'.format(\n+                show_evidence(evidences, corrected_evidence)\n+            )\n+        elif len(ghosts) == 1:\n+            title = 'One ghost matches the given evidence{}:'.format(\n+                show_evidence(evidences, corrected_evidence)\n+            )\n+\n+            g = ghosts[0]\n+            embed = discord.Embed(\n+                description='[{}]({})'.format(g.name, g.url),\n+                color=utils.get_bot_color()\n+            )\n         else:\n-            if members:\n-                # Argument error\n-                ctx.command.reset_cooldown(ctx)\n-                return await ctx.send(\n-                    'You cannot specify which members can play if you do '\n-                    'not allow others. See the help message for more info.'\n+            title = '{} ghosts match the given evidence{}:'.format(\n+                inflector.number_to_words(\n+                    len(ghosts), threshold=10).capitalize(),\n+                show_evidence(evidences, corrected_evidence)\n+            )\n+\n+            embed = discord.Embed(\n+                description='\\n'.join([\n+                    '[{}]({}) ({})'.format(\n+                        g.name, g.url, ', '.join(g.evidences))\n+                    for g in ghosts\n+                ]),\n+                color=utils.get_bot_color()\n+            )\n+\n+        await ctx.send(title, embed=embed)\n+\n+\n+\n+\n+\n+    @commands.group(name='unturned', invoke_without_command=True)\n+    async def client_unturned(self, ctx):\n+        \"\"\"Commands related to the game Unturned.\"\"\"\n+\n+\n+    @staticmethod\n+    def unturned_could_not_find_item(search):\n+        \"\"\"Create a message for when an item search\n+        does not return anything.\"\"\"\n+        try:\n+            int(search)\n+        except ValueError:\n+            return 'Could not find an item with that name.'\n+        else:\n+            return 'Could not find an item with that ID.'\n+\n+\n+    @staticmethod\n+    def unturned_get_rarity_color(rarity):\n+        \"\"\"Return the color for a given item rarity.\n+\n+        Args:\n+            rarity (UnturnedItem)\n+\n+        Returns:\n+            int\n+\n+        \"\"\"\n+        return ( 0x777777 if rarity == 'Common'\n+            else 0x71BA51 if rarity == 'Uncommon'\n+            else 0x3D8EB9 if rarity == 'Rare'\n+            else 0x8870FF if rarity == 'Epic'\n+            else 0xD33257 if rarity == 'Legendary'\n+            else 0x637C63\n+        )\n+\n+\n+    @staticmethod\n+    def unturned_multiple_matches(results, *, threshold=5):\n+        \"\"\"Create a message and embed showing multiple matches.\n+\n+        Args:\n+            List[UnturnedItem]\n+\n+        Returns:\n+            Tuple[str, discord.Embed]\n+\n+        \"\"\"\n+        # List the first five possible matches\n+        amount = len(results)\n+        results = results[:threshold]\n+\n+        description = [entry.name for entry in results]\n+        if amount > threshold:\n+            description.append('...')\n+        description = '\\n'.join(description)\n+\n+        embed = discord.Embed(\n+            color=utils.get_bot_color(),\n+            description=description\n+        )\n+\n+        content = '{} items were matched:'.format(\n+            inflector.number_to_words(amount, threshold=10).capitalize()\n+        )\n+\n+        return content, embed\n+\n+\n+    @client_unturned.command(name='item', aliases=['i'])\n+    @commands.cooldown(3, 10, commands.BucketType.user)\n+    async def client_unturned_item(self, ctx, *, item):\n+        \"\"\"Search for an Unturned item by ID or name.\n+Information was pre-scraped from https:\/\/unturneditems.com\/.\n+Up to date as of 3.20.15.0.\"\"\"\n+        def item_embed(entry):\n+            id_, name, rarity, url, dimensions, recipe_data = (\n+                entry.id, entry.name, entry.rarity, entry.url,\n+                entry.dimensions, entry.recipe_data\n+            )\n+\n+            description = (\n+                f'[**{name}**]({url})\\n'\n+                f'ID: {id_}\\n'\n+                f'Rarity: {rarity}\\n'\n+            )\n+\n+            if dimensions is not None:\n+                description += f'Dimensions: {dimensions[0]}x{dimensions[1]}\\n'\n+\n+            if recipe_data is not None:\n+                # List every recipe\n+                recipes_str = []\n+                for recipe in recipe_data['recipes']:\n+                    amount, items_raw, skills = (\n+                        recipe['amount'], recipe['recipe'], recipe['skills']\n+                    )\n+                    # Distinguish between consumed and required items\n+                    items_consumed, items_required = [], []\n+                    for raw_id, quantity in items_raw:\n+                        item = self.unturneddb.unturned_get_item(raw_id)\n+                        if quantity == 0:\n+                            items_required.append(item.name)\n+                        else:\n+                            items_consumed.append((item, quantity))\n+\n+                    rec_str = []\n+                    first = True\n+                    # List consumed items\n+                    for item in items_consumed:\n+                        rec_str.append('> ')\n+                        if not first:\n+                            rec_str.append('+ ')\n+                        rec_str.append(f'{item[1]} x {item[0].name}\\n')\n+                        first = False\n+\n+                    # Show product\n+                    rec_str.append(f'> = {amount} x {name}\\n')\n+\n+                    if items_required:\n+                        rec_str.append('> (Uses {})\\n'.format(\n+                            inflector.join(items_required)\n+                        ))\n+\n+                    requires = skills.copy()\n+\n+                    # Include other conditions in requirements\n+                    if recipe['requires_heat']:\n+                        requires.append('Heat')\n+\n+                    if requires:\n+                        rec_str.append(f'> (Requires {inflector.join(requires)})')\n+\n+                    recipes_str.append(''.join(rec_str))\n+\n+                recipes_str = '> OR:\\n'.join(recipes_str)\n+\n+                if recipes_str:\n+                    description += f'Recipes:\\n{recipes_str}\\n'\n+\n+            return discord.Embed(\n+                color=self.unturned_get_rarity_color(rarity),\n+                description=description\n+            ).set_thumbnail(\n+                url=f'https:\/\/unturneditems.com\/media\/{id_}.png'\n+            )\n+\n+        result = self.unturneddb.unturned_get_item(item)\n+\n+        if isinstance(result, list):\n+            content, embed = self.unturned_multiple_matches(result)\n+\n+            await ctx.send(content, embed=embed)\n+        elif result is None:\n+            await ctx.send(self.unturned_could_not_find_item(item))\n+        else:\n+            await ctx.send(embed=item_embed(result))\n+\n+\n+    @client_unturned.command(name='craft', aliases=['c'])\n+    @commands.cooldown(3, 10, commands.BucketType.user)\n+    async def client_unturned_craft(\n+            self, ctx, amount: Optional[int] = 1, *, item):\n+        \"\"\"Get the materials required to craft an item.\n+\n+amount: The number of the given item to craft. This parameter must be included.\n+item: The name or ID of the item to look up.\n+\n+Note: There are only a few items with recipe data since I have to manually enter this myself.\"\"\"\n+        def get_recipe_requirements(item, amount=None, frontier=None):\n+            \"\"\"Return the requirements for a recipe.\n+\n+            Dictionary returned is structured like so:\n+                'tree': [\n+                    [item, amount,\n+                     [...],\n+                     {'other': True, ...}],\n+                    ...\n+                ],\n+                # stores the tree structure that is being pathed\n+                'remainders': [[item, amount], ...],\n+                # any excess materials\n+                'skills': {'Crafting': 3, ...},\n+                # all skills that are needed\n+                'other': {'requires_heat': True, ...},\n+                # other information about the recipe\n+                'total_raw': [[item, amount], ...],\n+                # contains all the raw materials required\n+\n+            The design is to navigate through the item's recipe tree,\n+            recursively acquiring materials from the recipe of each\n+            material in the item.\n+            This lends to several considerations:\n+                1. How are skills acquired?\n+                2. What if a recipe produces extra items?\n+                3. What if an item is marked as primitive?\n+                4. What if a recipe is cyclic? (as in a recipe of an item\n+                    has that same item in its recipe)\n+\n+            1. Skills are stored in a dictionary where the key is the name\n+            of the skill, and the value being the level.\n+            When a recursive call returns a dictionary, it is merged\n+            into the current stack's skills, keeping the maximum level of each\n+            skill.\n+\n+            2. Extra items are stored as a list containing pairs of items\n+            and their amount. The items are initially non-unique but at\n+            the top level, the amounts are aggregated together by mapping\n+            the item ID to their amount, and then converted back into a list.\n+\n+            3. Primitive items like Metal Scrap means that their recipes\n+            should not be recursed into. [...]\n+\n+            [incomplete documentation]\n+            \"\"\"\n+            def create_output(*, tree=None, remainders=None,\n+                              skills=None, total_raw=None,\n+                              other=None):\n+                d = {\n+                    'tree': tree if tree is not None else [],\n+                    'remainders': remainders if remainders is not None else [],\n+                    'skills': skills if skills is not None else {},\n+                    'other': other if other is not None else {}\n+                }\n+                if total_raw is not None:\n+                    d['total_raw'] = total_raw\n+                return d\n+\n+            def parse_skills(skills):\n+                skill_dict = {}\n+                for s in skills:\n+                    skill_name, level = s.split()\n+                    skill_dict[skill_name] = int(level)\n+                return skill_dict\n+\n+            def get_total_raw(tree):\n+                \"\"\"Recursively summarize the raw materials of a tree.\"\"\"\n+                materials = {}\n+                if not tree:\n+                    return materials\n+                for item, amount, branch, _other in tree:\n+                    if branch:\n+                        # Item is broken down into more materials\n+                        branch_raw = get_total_raw(branch)\n+                        if branch_raw:\n+                            for item_id, item_and_amount in branch_raw.items():\n+                                item, amount = item_and_amount\n+                                materials.setdefault(item_id, [item, 0])\n+                                materials[item_id][1] += amount\n+                    else:\n+                        # Leaf node; must be primitive\/uncraftable; store it\n+                        materials.setdefault(item.id, [item, 0])\n+                        materials[item.id][1] += amount\n+                return materials\n+\n+            top_level = frontier is None\n+\n+            if (item.recipe_data is None\n+                    or not item.recipe_data['recipes']\n+                    or item.recipe_data['primitive'] and not top_level):\n+                # No recipes\/primitive item\n+                if top_level:\n+                    return create_output(total_raw=[[item, amount]])\n+                return create_output()\n+\n+            recipe = item.recipe_data['recipes'][0]\n+            # TODO: using only the first recipe will add limitations to\n+            #   how it figures out the requirements (ignoring other recipes\n+            #   that could work) but since most items only have one recipe,\n+            #   this generally won't have any issue\n+\n+            materials, amount_produced = recipe['recipe'], recipe['amount']\n+\n+            other = {'requires_heat': recipe.get('requires_heat', False)}\n+\n+            if amount is None:\n+                amount = recipe['amount']\n+\n+            if amount == 0:\n+                # Item is only required but not consumed\n+                if top_level:\n+                    raise ValueError('amount cannot be 0')\n+                return create_output()\n+\n+            if top_level:\n+                frontier = set()\n+\n+            if item.id in frontier:\n+                # Item already seen; do not recurse into its recipes\n+                return create_output(tree=[[item, amount, [], other]])\n+\n+            frontier.add(item.id)\n+\n+            tree = []\n+            remainders = []\n+\n+            # Parse skills into their name and level\n+            skills = parse_skills(recipe['skills'])\n+\n+            if amount % amount_produced != 0:\n+                # Recipe will result in excess produce\n+                remainders.append((item, amount % amount_produced))\n+\n+            # Recursively get requirements of recipe materials\n+            for mat_id, mat_amount in materials:\n+                mat = self.unturneddb.unturned_get_item(mat_id)\n+                if mat is None:\n+                    raise ValueError(\n+                        f'unknown item in recipe: {mat_id}')\n+\n+                branched_frontier = frontier.copy()\n+\n+                amount_to_craft = math.ceil(\n+                    amount \/ amount_produced) * mat_amount\n+\n+                mat_req = get_recipe_requirements(\n+                    mat,\n+                    amount_to_craft,\n+                    branched_frontier\n+                )\n+\n+                tree.append(\n+                    [mat, amount_to_craft, mat_req['tree'], mat_req['other']]\n                 )\n+\n+                remainders.extend(mat_req['remainders'])\n+\n+                # Collect skills\n+                for name, level in mat_req['skills'].items():\n+                    skills.setdefault(name, 0)\n+                    skills[name] = max(skills[name], level)\n+\n+                # Collect other booleans if top level\n+                if top_level:\n+                    for k, v in mat_req['other'].items():\n+                        other.setdefault(k, False)\n+                        other[k] = max(other[k], v)\n+\n+            # collect items\n+            if top_level:\n+                total_raw = list(get_total_raw(tree).values())\n+\n+                collected_remainders = {}\n+                for mat, mat_amount in remainders:\n+                    collected_remainders.setdefault(mat.id, [mat, 0])\n+                    collected_remainders[mat.id][1] += mat_amount\n+                collected_remainders = list(collected_remainders.values())\n+\n+                return create_output(\n+                    tree=tree,\n+                    remainders=collected_remainders,\n+                    skills=skills,\n+                    total_raw=total_raw,\n+                    other=other\n+                )\n+            return create_output(\n+                tree=tree,\n+                remainders=remainders,\n+                skills=skills,\n+                other=other\n+            )\n+\n+        def humanize_other(other):\n+            \"\"\"Convert a dictionary of other booleans from\n+            get_recipe_requirements into a list of human-readable strings.\"\"\"\n+            d = {'requires_heat': 'Heat'}\n+            s = []\n+            for k, v in other.items():\n+                if v:\n+                    s.append(d[k])\n+            return s\n+\n+        def tree_str(tree, level=1):\n+            \"\"\"Example tree produced by get_recipe_requirements:\n+\n+            Wire:\n+            [\n+             Metal Bar, 3, [[Metal Scrap, 2, []],\n+                            [Blowtorch, 0]],\n+             Blowtorch, 0, []\n+            ]\n+\n+            \"\"\"\n+            if not tree:\n+                return tree\n+\n+            s = []\n+            indent = '> ' * level\n+\n+            for item, amount, branch, other in tree:\n+                if amount:\n+                    # Skip unconsumed items, those are handled separately\n+                    s.append(f'{indent}{amount} x {item.name}')\n+\n+                for other_str in humanize_other(other):\n+                    s.append(f\"{'> ' * (level + 1)}{other_str}\")\n+\n+                s.extend(tree_str(branch, level=level + 1))\n+\n+            return s\n+\n+        result = self.unturneddb.unturned_get_item(item)\n+\n+        if isinstance(result, list):\n+            content, embed = self.unturned_multiple_matches(result)\n+\n+            return await ctx.send(content, embed=embed)\n+        elif result is None:\n+            return await ctx.send(self.unturned_could_not_find_item(item))\n+\n+        if result.recipe_data is None:\n+            return await ctx.send(\n+                \"Unfortunately I don't have the recipe data for this.\")\n+\n+        if amount <= 0:\n+            return await ctx.send(\n+                embed=discord.Embed(\n+                    color=utils.get_bot_color(),\n+                    description=(\n+                        f'{result.name}\\n'\n+                        f'ID: {result.id}\\n'\n+                        'Total raw:\\n**nothing**'\n+                    )\n+                ).set_thumbnail(\n+                    url=f'https:\/\/unturneditems.com\/media\/{result.id}.png'\n+                )\n+            )\n+\n+        requirements = get_recipe_requirements(result, amount)\n+        tree = requirements['tree']\n+        remainders = requirements['remainders']\n+        skills = requirements['skills']\n+        total_raw = requirements['total_raw']\n+\n+        # Fix inflector sometimes not properly pluralizing the name\n+        # if it starts with a capital letter\n+        is_name_capitalized = result.name[0].isupper()\n+        plural_name = result.name\n+        plural_name = plural_name[0].lower() + plural_name[1:]\n+        plural_name = inflector.plural(plural_name, amount)\n+        if is_name_capitalized:\n+            plural_name = plural_name[0].upper() + plural_name[1:]\n+\n+        description = [\n+            f'{amount} {plural_name}',\n+            f'ID: {result.id}'\n+        ]\n+\n+        if tree:\n+            description.extend((\n+                'Recipe tree:',\n+                '\\n'.join(tree_str(tree))\n+            ))\n+        # Else item is primitive\/has no recipes\n+\n+        items_consumed, items_required = [], []\n+        for item, quantity in total_raw:\n+            if quantity == 0:\n+                items_required.append(item.name)\n             else:\n-                # Solo\n-                users = None\n+                items_consumed.append((item, quantity))\n \n-        game = multimath.BotMultimathGame(ctx)\n+        description.append('Total raw:')\n \n-        await game.run(users=users)\n+        # List consumed and required items\n+        for item, amount in items_consumed:\n+            description.append(f'> {amount} x {item.name}')\n+        for item in items_required:\n+            description.append(f'> {item}')\n+\n+        # List excess material\n+        if remainders:\n+            description.append('Remainders:')\n+            description.extend(f'> {amount} x {item.name}'\n+                               for item, amount in remainders)\n+\n+        # Parse skill dict back into list of strings\n+        # and add other conditions here\n+        requires = [f'{k} {v}' for k, v in skills.items()]\n+        requires.extend(humanize_other(requirements['other']))\n+\n+        if requires:\n+            description.append(f'Requires {inflector.join(requires)}')\n+\n+        embed = discord.Embed(\n+            color=self.unturned_get_rarity_color(result.rarity),\n+            description='\\n'.join(description)\n+        ).set_thumbnail(\n+            url=f'https:\/\/unturneditems.com\/media\/{result.id}.png'\n+        )\n+\n+        await ctx.send(embed=embed)\n+\n+\n+    @client_unturned.command(name='reload')\n+    @checks.is_bot_admin()\n+    @commands.cooldown(1, 20, commands.BucketType.default)\n+    async def client_unturned_reload_db(self, ctx):\n+        \"\"\"Reload the item database.\"\"\"\n+        await self.unturneddb.reload_items_nonblocking()\n+        await ctx.send('Item database reloaded.')\n \n \n \ndiff --git a\/bot\/commands\/graphing.py b\/bot\/commands\/graphing.py\nindex 91b7d53..1bd23cc 100644\n--- a\/bot\/commands\/graphing.py\n+++ b\/bot\/commands\/graphing.py\n@@ -1,6 +1,7 @@\n import asyncio\n import collections\n import contextlib\n+import decimal\n import functools\n import io\n ##import multiprocessing\n@@ -35,14 +36,57 @@\n ##    return wrapper\n \n \n+def format_dollars(dollars: decimal.Decimal):\n+    dollars = round_dollars(dollars)\n+    sign = '-' if dollars < 0 else ''\n+    dollar_part = abs(int(dollars))\n+    cent_part = abs(int(dollars % 1 * 100))\n+    return '{}${:,}.{:02d}'.format(sign, dollar_part, cent_part)\n+\n+\n+class DollarConverter(commands.Converter):\n+    \"\"\"A decimal.Decimal converter that strips leading dollar signs\n+    and can round to the nearest cent.\"\"\"\n+\n+    def __init__(self, *, nearest_cent=True):\n+        super().__init__()\n+        self.nearest_cent = nearest_cent\n+\n+    async def convert(self, ctx, arg):\n+        arg = arg.lower()\n+        thousands = 1000 if arg.endswith('k') else 1\n+        arg = arg.replace(',', '').lstrip('$').rstrip('k')\n+        try:\n+            d = decimal.Decimal(arg) * thousands\n+        except decimal.InvalidOperation:\n+            raise commands.BadArgument(f'Dollar syntax error: {arg!r}')\n+        return round_dollars(d) if self.nearest_cent else d\n+\n+\n+class PercentConverter(commands.Converter):\n+    \"\"\"A decimal.Decimal converter that supports specifying percentages.\"\"\"\n+    async def convert(self, ctx, arg):\n+        try:\n+            if arg.endswith('%'):\n+                arg = arg.rstrip('%')\n+                return decimal.Decimal(arg) \/ 100\n+            return decimal.Decimal(arg)\n+        except decimal.InvalidOperation:\n+            raise commands.BadArgument(f'Decimal syntax error: {arg!r}')\n+\n+\n+def round_dollars(d) -> decimal.Decimal:\n+    \"\"\"Round a number-like object to the nearest cent.\"\"\"\n+    cent = decimal.Decimal('0.01')\n+    return decimal.Decimal(d).quantize(cent, rounding=decimal.ROUND_HALF_UP)\n+\n+\n class Graphing(commands.Cog):\n+    \"\"\"Commands for graphing things.\n+Most of the text-related commands can support obtaining text using:\n+the \"text\" parameter; file attachment; replying to a message;\n+or the last message that was sent.\"\"\"\n     qualified_name = 'Graphing'\n-    description = (\n-        'Commands for graphing things.\\n'\n-        'Most of the text-related commands can support obtaining text by: '\n-        'the \"text\" parameter; file attachment; replying to a message; '\n-        'or the last message that was sent.'\n-    )\n \n     TEXT_ANALYSIS_FILESIZE_LIMIT = 300_000\n     # Maximum file size allowed for client_frequencyanalysis in number of bytes\n@@ -108,9 +152,9 @@ async def get_text(self, ctx, text: str, *, message=None):\n             # Raises: discord.HTTPException, discord.Forbidden,\n             # discord.NotFound, UnicodeError\n \n-        if message is not None and not using_ctx_message and not text:\n-            # Check the message content and otherwise if that is empty,\n-            # keep it at one level of recursion\n+        if not text and not using_ctx_message:\n+            # message argument was passed; check the message content\n+            # and if that is empty, keep it at one level of recursion\n             text = message.content\n             if not text:\n                 return False, 'There is no text to analyse.'\n@@ -121,19 +165,14 @@ async def get_text(self, ctx, text: str, *, message=None):\n         if not text and ref is not None:\n             # Try recursing into the message the user replied to.\n             # First check the cache, then fetch the message\n-            message = None\n-            if ref.cached_message is not None:\n-                message = ref.cached_message\n-            elif perms.read_message_history:\n-                channel = self.bot.get_channel(ref.channel_id)\n-                if channel is not None:\n-                    message = await channel.fetch_message(ref.message_id)\n+            message = ref.resolved\n \n-            if message is not None:\n-                ref_text = await self.get_text(ctx, text, message=message)\n-\n-                if ref_text[0] is True:\n-                    return ref_text\n+            if isinstance(message, discord.DeletedReferencedMessage):\n+                return False, 'The given message was deleted.'\n+            elif message is None:\n+                return False, 'Could not resolve your replied message.'\n+            else:\n+                return await self.get_text(ctx, text, message=message)\n \n         if not text and perms.read_message_history:\n             # Try recursing into the last message sent\n@@ -172,6 +211,176 @@ async def get_text(self, ctx, text: str, *, message=None):\n \n \n \n+    def interest_simple_compound(self, p, r, t, n):\n+        \"\"\"Return a list of terms and a dictionary mapping the principal\n+        and interest over those terms.\n+\n+        Args:\n+            p (decimal.Decimal): The principal.\n+            r (decimal.Decimal): The interest rate.\n+            t (int): The investment term.\n+            n (int): The number of compounding periods per term.\n+\n+        \"\"\"\n+        samples = t*n + 1\n+\n+        terms = np.linspace(0, t, samples)\n+\n+        # decimal.Decimal() arrays can't be created with linspace()\n+        # (see numpy #8909), so this linear space has to be done manually.\n+        payments = np.ndarray((samples,), dtype=decimal.Decimal)\n+        start = decimal.Decimal()\n+        step = decimal.Decimal(t) \/ (t * n)\n+        for i in range(samples):\n+            payments[i] = start\n+            start += step\n+\n+        principal = np.full(terms.shape, p, dtype=decimal.Decimal)\n+\n+        simple_interest = p * r * payments\n+        compound_amount = p * (1 + r\/n) ** (n * payments)\n+        compound_interest = compound_amount - principal - simple_interest\n+\n+        return terms, {\n+            'Principal': principal,\n+            'Simple': simple_interest,\n+            'Compound': compound_interest\n+        }\n+\n+\n+    def interest_stackplot(self, ctx, p, r, t, n):\n+        \"\"\"Graph the interest of an investment over a given term.\n+\n+        Args:\n+            ctx (discord.ext.commands.Context)\n+            p (decimal.Decimal): The principal.\n+            r (decimal.Decimal): The interest rate.\n+            t (int): The investment term.\n+            n (int): The number of compounding periods per term.\n+\n+        Returns:\n+            Tuple[BytesIO, str]: The image and a message paired\n+                along with it.\n+\n+        \"\"\"\n+        bot_color = '#' + hex(utils.get_bot_color())[2:]\n+\n+        terms, data = self.interest_simple_compound(p, r, t, n)\n+\n+        fig, ax = plt.subplots()\n+\n+        # Graph stackplot\n+        ax.stackplot(terms, data.values(), labels=data.keys())\n+        ax.legend(loc='upper left')\n+\n+        # Move ylim so principal won't take up the majority of the plot\n+        simple_interest = data['Simple'][-1]\n+        compound_interest = data['Compound'][-1]\n+        maximum = p + simple_interest + compound_interest\n+        minimum = p - p * decimal.Decimal('0.05')\n+        ax.set_ylim([minimum, maximum])\n+\n+        # Add labels\n+        ax.set_title('Simple and Compound Interest')\n+        ax.set_xlabel('Term')\n+        ax.set_ylabel('Amount')\n+\n+        # Remove the x-axis margins\n+        ax.margins(x=0)\n+\n+        # Force integer ticks\n+        ax.xaxis.set_major_locator(MaxNLocator(integer=True))\n+\n+        # Set colors and add shadow to labels\n+        labels = (\n+            [ax.title, ax.xaxis.label, ax.yaxis.label]\n+            + ax.get_legend().get_texts() + ax.get_xticklabels()\n+            + ax.get_yticklabels()\n+        )\n+        for item in labels:\n+            item.set_color(bot_color)\n+            item.set_path_effects([\n+                path_effects.withSimplePatchShadow(\n+                    offset=(1, -1),\n+                    alpha=self.TEXT_SHADOW_ALPHA\n+                )\n+            ])\n+\n+        # Color the spines and ticks\n+        for spine in ax.spines.values():\n+            spine.set_color(bot_color)\n+        ax.tick_params(colors=bot_color)\n+\n+        # Create message\n+        simple_amount = p + simple_interest\n+        message = (\n+            'Present Value: {}\\n'\n+            'Future Values: {} simple; {} compound'\n+        ).format(format_dollars(p), format_dollars(simple_amount),\n+                 format_dollars(maximum))\n+\n+        f = io.BytesIO()\n+        fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0)\n+        # bbox_inches, pad_inches: removes padding around the graph\n+\n+        plt.close(fig)\n+        return f, message\n+\n+\n+    @commands.command(name='interest')\n+    @commands.cooldown(3, 60, commands.BucketType.channel)\n+    @commands.max_concurrency(3, wait=True)\n+    async def client_interest(\n+            self, ctx, principal: DollarConverter, rate: PercentConverter,\n+            term: int, periods: int = 1):\n+        \"\"\"Calculate simple and compound interest.\n+\n+principal: The initial investment.\n+rate: The interest rate. Can be specified as a percentage.\n+term: The number of terms.\n+periods: The number of compounding periods in each term.\"\"\"\n+        if not 0 < rate <= 100:\n+            return await ctx.send(\n+                'The interest rate must be between 0% and 100,000%.',\n+                delete_after=10\n+            )\n+        elif term * periods > min(36500, 36500000 \/ principal):\n+            # This tries keeping the numbers within a reasonable amount\n+            return await ctx.send(\n+                'The principal\/term\/periods are too large to calculate.',\n+                delete_after=10\n+            )\n+\n+        await ctx.trigger_typing()\n+\n+        loop = asyncio.get_running_loop()\n+\n+        with warnings.catch_warnings():\n+            warnings.simplefilter('ignore', UserWarning)\n+            f, content = await loop.run_in_executor(\n+                None, self.interest_stackplot, ctx,\n+                principal, rate, term, periods\n+            )\n+        f.seek(0)\n+\n+        await ctx.send(\n+            content, file=discord.File(f, 'Word Count Pie Chart.png'))\n+\n+\n+    @client_interest.error\n+    async def client_interest_error(self, ctx, error):\n+        error = getattr(error, 'original', error)\n+\n+        if isinstance(error, decimal.InvalidOperation):\n+            return await ctx.send(\n+                'The calculations were too large to handle.',\n+                delete_after=10\n+            )\n+\n+\n+\n+\n+\n ##    def frequency_analysis(self, conn, ctx, text):\n     def frequency_analysis(self, ctx, text):\n         \"\"\"Create a frequency analysis graph of a given text.\n@@ -213,13 +422,10 @@ def frequency_analysis(self, ctx, text):\n         # Force integer ticks\n         ax.yaxis.set_major_locator(MaxNLocator(integer=True))\n \n-        # Set fonts\n+        # Set colors and add shadow to labels\n         for item in ([ax.title, ax.xaxis.label, ax.yaxis.label]\n                      + ax.get_xticklabels() + ax.get_yticklabels()):\n-            item.set_family('calibri')\n-            item.set_fontsize(18)\n             item.set_color(bot_color)\n-            # Add shadow\n             item.set_path_effects([\n                 path_effects.withSimplePatchShadow(\n                     offset=(1, -1),\n@@ -227,13 +433,6 @@ def frequency_analysis(self, ctx, text):\n                 )\n             ])\n \n-        # Create transparent background\n-        ax.set_facecolor('#00000000')\n-        fig.patch.set_facecolor('#36393F4D')\n-\n-        # Hide the right and top spines\n-        ax.spines['right'].set_visible(False)\n-        ax.spines['top'].set_visible(False)\n         # Color the spines and ticks\n         for spine in ax.spines.values():\n             spine.set_color(bot_color)\n@@ -243,6 +442,7 @@ def frequency_analysis(self, ctx, text):\n         fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0)\n         # bbox_inches, pad_inches: removes padding around the graph\n \n+        plt.close(fig)\n ##        conn.send(f)\n         return f\n \n@@ -366,7 +566,7 @@ def word_count_pie(self, ctx, text):\n         # Add labels\n         if len(words) <= len(top_words):\n             ax.set_title(\n-                f'Top Words ({total_words:,} total)\\n'\n+                f'Word Count ({total_words:,} total)\\n'\n                 f'for {ctx.author.display_name}\\n'\n             )\n         else:\n@@ -378,12 +578,10 @@ def word_count_pie(self, ctx, text):\n             )\n         # NOTE: newline is appended at the end just to pad it from the labels\n \n-        # Set fonts\n+        # Set font styles\n         all_text = texts + autotexts\n         for item in ([ax.title] + all_text):\n-            item.set_family('calibri')\n             item.set_color(bot_color)\n-        ax.title.set_fontsize(18)\n         for item in all_text:\n             # Add shadow\n             item.set_path_effects([\n@@ -397,14 +595,11 @@ def word_count_pie(self, ctx, text):\n         for item in autotexts:\n             item.set_fontsize(12)\n \n-        # Create transparent background\n-        ax.set_facecolor('#00000000')\n-        fig.patch.set_facecolor('#36393F4D')\n-\n         f = io.BytesIO()\n         fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0)\n         # bbox_inches, pad_inches: removes padding around the graph\n \n+        plt.close(fig)\n         return f\n \n \n@@ -470,11 +665,10 @@ def test_bar_graphs_3d(self):\n         # we have data for.\n         ax.set_yticks(yticks)\n \n-        # Set fonts\n+        # Set colors\n         for item in ([ax.xaxis.label, ax.yaxis.label, ax.zaxis.label]\n                      + ax.get_xticklabels() + ax.get_yticklabels()\n                      + ax.get_zticklabels()):\n-            item.set_family('calibri')\n             item.set_color(bot_color)\n \n         # Set spine and pane colors\n@@ -485,10 +679,6 @@ def test_bar_graphs_3d(self):\n         # Set tick colors\n         ax.tick_params(colors=bot_color)\n \n-        # Create transparent background\n-        ax.set_facecolor('#00000000')\n-        fig.patch.set_facecolor('#36393F4D')\n-\n         return fig, ax\n \n \n@@ -508,6 +698,7 @@ def test_bar_graphs_3d_image(self, elevation=None, azimuth=None):\n         fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0)\n         # bbox_inches, pad_inches: removes padding around the graph\n \n+        plt.close(fig)\n         return f\n \n \n@@ -585,6 +776,7 @@ def run(data):\n \n         anim.save(fp, writer='pillow', fps=frames \/ duration)\n \n+        plt.close(fig)\n         return fp\n \n \n@@ -598,9 +790,11 @@ async def client_test3dgraphanimation(\n         loop = asyncio.get_running_loop()\n \n         if duration < 1:\n-            return await ctx.send('Duration must be at least 1 second.')\n+            return await ctx.send(\n+                'Duration must be at least 1 second.', delete_after=6)\n         if frames < 1:\n-            return await ctx.send('There must be at least 1 frame.')\n+            return await ctx.send(\n+                'There must be at least 1 frame.', delete_after=6)\n \n         func = functools.partial(\n             self.test_bar_graphs_3d_gif,\n@@ -618,7 +812,9 @@ async def client_test3dgraphanimation(\n         filesize = Path(fp).stat().st_size\n         if filesize > filesize_limit:\n             return await ctx.send(\n-                'Unfortunately the file is too large to upload.')\n+                'Unfortunately the file is too large to upload.',\n+                delete_after=10\n+            )\n \n         with open(fp, 'rb') as f:\n             await ctx.send(file=discord.File(f, '3D Graph Animation Test.gif'))\ndiff --git a\/bot\/commands\/guildirish.py b\/bot\/commands\/guildirish.py\nindex a1bf936..8494f83 100644\n--- a\/bot\/commands\/guildirish.py\n+++ b\/bot\/commands\/guildirish.py\n@@ -1,50 +1,49 @@\n+from typing import Optional\n+\n import discord\n from discord.ext import commands\n import inflect\n \n-from bot.classes.confirmation import Confirmation\n-from bot.database import IrishDatabase, DATABASE_IRISH\n+from bot.classes.confirmation import AdaptiveConfirmation\n+from bot.database import IrishDatabase\n from bot import checks\n from bot import utils\n \n inflector = inflect.engine()\n \n \n-def has_guild_permissions_dm_safe(*args, **kwargs):\n-    \"\"\"A variant of has_guild_permissions that does not throw NoPrivateMessage\n-    in DMs.\"\"\"\n-    original = commands.has_guild_permissions(*args, **kwargs).predicate\n-    async def predicate(ctx):\n-        return ctx.guild is not None and await original(ctx)\n-    return commands.check(predicate)\n-\n-\n class IrishSquad(commands.Cog):\n+    \"\"\"Commands for Irish Squad.\"\"\"\n     qualified_name = 'Irish Squad'\n-    description = 'Commands for Irish Squad.'\n \n     GUILD_ID = 153553830670368769\n \n+    CHARGE_LEADERBOARD_MAX = 10\n+\n     def __init__(self, bot):\n         self.bot = bot\n-        self.db = IrishDatabase(DATABASE_IRISH)\n+        self.db = IrishDatabase\n \n         if not self.bot.intents.members:\n             self.description += ('\\n**NOTE**: This category will not be '\n                                  'available in DMs at this time.')\n \n \n+    @property\n+    def guild(self) -> Optional[discord.Guild]:\n+        return self.bot.get_guild(self.GUILD_ID)\n+\n+\n     def cog_check(self, ctx):\n         if isinstance(ctx.author, discord.Member):\n             return ctx.author.guild.id == self.GUILD_ID\n \n         # In DMs; check if user is part of the guild\n-        guild = ctx.bot.get_guild(self.GUILD_ID)\n+        # NOTE: this requires members intent\n+        guild = self.guild\n         if guild is None:\n             # RIP\n             return False\n-\n-        # NOTE: this requires members intent\n         return guild.get_member(ctx.author.id) is not None\n \n \n@@ -55,7 +54,8 @@ def cog_check(self, ctx):\n                     invoke_without_command=True)\n     async def client_charges(self, ctx):\n         \"\"\"Commands for tracking the amount of charges in the squad.\"\"\"\n-        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n \n \n     @client_charges.command(name='add')\n@@ -63,7 +63,8 @@ async def client_charges(self, ctx):\n     async def client_addcharges(self, ctx, *, amount: int):\n         \"\"\"Add to the number of charges you have.\"\"\"\n         if amount < 1:\n-            return await ctx.send('You must add at least one charge.')\n+            return await ctx.send('You must add at least one charge.',\n+                                  delete_after=6)\n \n         await ctx.channel.trigger_typing()\n \n@@ -72,8 +73,8 @@ async def client_addcharges(self, ctx, *, amount: int):\n \n         await ctx.send(\n             inflector.inflect(\n-                \"Added {0} plural('charge', {0})! \"\n-                \"You now have {1} plural('charge', {1}).\".format(\n+                \"Added {0:,} plural('charge', {0})! \"\n+                \"You now have {1:,} plural('charge', {1}).\".format(\n                     amount, new_charges\n                 )\n             )\n@@ -88,7 +89,8 @@ async def client_addcharges(self, ctx, *, amount: int):\n     async def client_removecharges(self, ctx, amount: int):\n         \"\"\"Subtract from the number of charges you have.\"\"\"\n         if amount < 1:\n-            return await ctx.send('You must remove at least one charge.')\n+            return await ctx.send('You must remove at least one charge.',\n+                                  delete_after=6)\n \n         await ctx.channel.trigger_typing()\n \n@@ -97,16 +99,16 @@ async def client_removecharges(self, ctx, amount: int):\n \n         if new_charges < 0:\n             return await ctx.send(inflector.inflect(\n-                \"Cannot remove {0} plural('charge', {0}); \"\n-                \"you only have {1} plural('charge', {1}).\".format(\n+                \"Cannot remove {0:,} plural('charge', {0}); \"\n+                \"you only have {1:,} plural('charge', {1}).\".format(\n                     amount, charges)\n             ))\n \n         await self.db.subtract_charges(ctx.author.id, amount)\n         await ctx.send(\n             inflector.inflect(\n-                \"Removed {0} plural('charge', {0})! \"\n-                \"You now have {1} plural('charge', {1}).\".format(\n+                \"Removed {0:,} plural('charge', {0})! \"\n+                \"You now have {1:,} plural('charge', {1}).\".format(\n                     amount, new_charges\n                 )\n             )\n@@ -116,22 +118,29 @@ async def client_removecharges(self, ctx, amount: int):\n \n \n \n-    @client_charges.command(name='amount')\n+    @client_charges.command(name='number', aliases=('amount',))\n     @commands.cooldown(3, 10, commands.BucketType.user)\n-    async def client_charges_amount(self, ctx, user: discord.Member = None):\n-        \"\"\"Show the amount of charges you or someone else has.\"\"\"\n+    async def client_charges_number(self, ctx, *, user: discord.User = None):\n+        \"\"\"Show the number of charges you or someone else has.\"\"\"\n         await ctx.channel.trigger_typing()\n \n-        user = user if user is not None else ctx.author\n-        charges = await self.db.get_charges(user.id)\n+        if user is None:\n+            user = ctx.author\n+\n+        try:\n+            charges = await self.db.get_charges(user.id, add_user=False)\n+        except ValueError as e:\n+            # Prevents non-members of the guild from being added\n+            # to the database\n+            raise commands.UserNotFound(user) from e\n \n         if user == ctx.author:\n             await ctx.send(inflector.inflect(\n-                \"You have {0} plural('charge', {0}).\".format(charges)\n+                \"You have {0:,} plural('charge', {0}).\".format(charges)\n             ))\n         else:\n             await ctx.send(inflector.inflect(\n-                \"{0} has {1} plural('charge', {1}).\".format(\n+                \"{0} has {1:,} plural('charge', {1}).\".format(\n                     user.display_name, charges)\n             ))\n \n@@ -149,9 +158,34 @@ async def client_charges_guildtotal(self, ctx):\n \n         total = sum(r['amount'] for r in rows)\n \n-        await ctx.send(inflector.inflect(\n-            \"The squad has a total of {0} plural('charge', {0}).\".format(total)\n-        ))\n+        rows = sorted((r for r in rows if r['amount'] != 0),\n+                      key=lambda r: r['amount'], reverse=True)\n+\n+        description = []\n+        for i, r in enumerate(rows, start=1):\n+            if i > self.CHARGE_LEADERBOARD_MAX:\n+                description.append('...')\n+                break\n+\n+            user = self.bot.get_user(r['user_id'])\n+            mention = user.mention if user is not None else None\n+\n+            description.append(f\"{mention}: {r['amount']:,}\")\n+\n+        embed = None\n+        if description:\n+            embed = discord.Embed(\n+                color=utils.get_bot_color(),\n+                description='\\n'.join(description)\n+            )\n+\n+        await ctx.send(\n+            inflector.inflect(\n+                \"The squad has a total of {0:,} plural('charge', {0}).\".format(\n+                    total)\n+            ),\n+            embed=embed\n+        )\n \n \n \n@@ -159,14 +193,14 @@ async def client_charges_guildtotal(self, ctx):\n \n     @client_charges.command(name='reset')\n     @commands.check_any(\n-        has_guild_permissions_dm_safe(manage_guild=True),\n+        commands.has_guild_permissions(manage_guild=True),\n         checks.is_bot_owner()\n     )\n-    @commands.cooldown(1, 60, commands.BucketType.guild)\n+    @commands.cooldown(1, 60)\n     async def client_charges_reset(self, ctx):\n         \"\"\"Reset the number of charges everyone has.\n This requires a confirmation.\"\"\"\n-        prompt = Confirmation(ctx, utils.get_bot_color())\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n \n         confirmed = await prompt.confirm(\n             \"Are you sure you want to reset Irish Squad's number of charges?\")\n@@ -184,6 +218,58 @@ async def client_charges_reset(self, ctx):\n \n \n \n+    @client_charges.command(name='vacuum', aliases=('cleanup',))\n+    @checks.is_bot_owner()\n+    @commands.cooldown(1, 60)\n+    async def client_irish_vacuum(self, ctx):\n+        \"\"\"Clean up the database.\"\"\"\n+        if not self.bot.intents.members:\n+            return await ctx.send('This is currently disabled as the bot '\n+                                  'cannot fetch member data at this time.')\n+\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n+\n+        confirmed = await prompt.confirm(\n+            \"Are you sure you want to vacuum the database?\")\n+\n+        if confirmed:\n+            guild = self.guild\n+\n+            # Remove all IDs from the Users table if they are\n+            # not in the guild\n+            invalid_users = []\n+            async for row in self.db.yield_rows('Users'):\n+                user_id = row['id']\n+                member = guild.get_member(user_id)\n+                if member is None:\n+                    try:\n+                        member = await guild.fetch_member(user_id)\n+                    except discord.NotFound:\n+                        member = None\n+                if member is None:\n+                    invalid_users.append(user_id)\n+\n+            where = 'id IN ({})'.format(\n+                ', '.join([str(user_id) for user_id in invalid_users])\n+            )\n+            await self.db.delete_rows('Users', where=where)\n+\n+            # Execute vacuum\n+            await self.db.vacuum()\n+\n+            message = inflector.inflect(\n+                \"Completed clean up!\\n{0:,} plural('user', {0}) \"\n+                \"vacuumed.\".format(len(invalid_users))\n+            )\n+\n+            await prompt.update(message, prompt.emoji_yes.color)\n+        else:\n+            await prompt.update('Cancelled clean up.', prompt.emoji_no.color)\n+\n+\n+\n+\n+\n \n \n \ndiff --git a\/bot\/commands\/helpcommand.py b\/bot\/commands\/helpcommand.py\nindex 3859765..6563cbd 100644\n--- a\/bot\/commands\/helpcommand.py\n+++ b\/bot\/commands\/helpcommand.py\n@@ -12,6 +12,7 @@\n message_length_cooldown = commands.CooldownMapping.from_cooldown(\n     1, 30, commands.BucketType.user)\n \n+\n class HelpCommand(commands.HelpCommand):\n \n     help_categories_per_page = 9  # Max of 25 fields\n@@ -73,7 +74,7 @@ def subcommand_not_found(self, command, string):\n                 the input that caused it,\n                 and the command that doesn't have the requested subcommand.\n         \"\"\"\n-        if isinstance(command, Group) and len(command.all_commands) > 0:\n+        if isinstance(command, commands.Group) and len(command.all_commands) > 0:\n             message = 'Command \"{}\" has no subcommand named {}'.format(\n                 command.qualified_name, string)\n         else:\n@@ -103,7 +104,9 @@ async def send(self, content=None, *args, embed=None, **kwargs):\n                 # haven't recently received one\n                 if not message_length_cooldown.update_rate_limit(ctx.message):\n                     await destination.send(\n-                        'Help message is a bit long; sent it to you in DMs.')\n+                        'Help message is a bit long; sent it to you in DMs.',\n+                        delete_after=8\n+                    )\n         else:\n             await destination.send(content, embed=embed, *args, **kwargs)\n \n@@ -220,16 +223,16 @@ async def create_help_cog_page(self, cog, *, page_num):\n         return embed\n \n     async def get_commands(self):\n-        \"\"\"Return all sorted commands the bot has categorized by sorted cogs.\n+        \"\"\"Return all sorted commands the bot has, categorized by sorted cogs.\n \n         Returns:\n-            List[commands.Cog, List[commands.Command]]\n+            List[Optional[commands.Cog], List[commands.Command]]\n \n         \"\"\"\n         categories = collections.defaultdict(list)\n \n-        for command in await self.filter_commands(self.context.bot.commands):\n-            categories[type(command.cog)].append(command)\n+        for cmd in await self.filter_commands(self.context.bot.commands):\n+            categories[cmd.cog].append(cmd)\n \n         # Create a paired list of of the dictionary\n         categories_list = sorted(\n@@ -238,8 +241,8 @@ async def get_commands(self):\n         )\n \n         # Sort each command by name\n-        for _, commands in categories_list:\n-            commands.sort(key=lambda x: x.qualified_name)\n+        for _, cmds in categories_list:\n+            cmds.sort(key=lambda x: x.qualified_name)\n \n         return categories_list\n \n@@ -271,7 +274,7 @@ async def send_error_message(self, error):\n                 cog = self.context.bot.get_cog(string)\n             except (IndexError, ValueError):\n                 # Not a page number request\n-                await self.send(error)\n+                await self.send(error, delete_after=6)\n                 return\n \n         if cog is None:\n@@ -280,7 +283,7 @@ async def send_error_message(self, error):\n                 embed = await self.create_help_category_page(page_num=page_num)\n             except ValueError as e:\n                 # Invalid page number\n-                await destination.send(str(e))\n+                await destination.send(str(e), delete_after=6)\n             else:\n                 await self.send(embed=embed)\n         else:\n@@ -289,7 +292,7 @@ async def send_error_message(self, error):\n                 embed = await self.create_help_cog_page(cog, page_num=page_num)\n             except ValueError as e:\n                 # Invalid page number\n-                await destination.send(str(e))\n+                await destination.send(str(e), delete_after=6)\n             else:\n                 await self.send(embed=embed)\n \n@@ -314,7 +317,7 @@ async def send_group_help(self, group):\n         embed = discord.Embed(\n             title=self.get_command_signature(group),\n             color=utils.get_bot_color(),\n-            description=group.description\n+            description=group.help or group.short_doc\n         )\n \n         # Add fields\n@@ -328,19 +331,19 @@ async def send_group_help(self, group):\n \n     async def send_command_help(self, command):\n         \"Sends help for an individual command.\"\n-        description = f'`{self.get_command_signature(command)}`\\n'\n+        description = [f'`{self.get_command_signature(command)}`\\n']\n \n         if command.help:\n-            description += f'```{command.help}```'\n+            description.append(command.help)\n         elif command.short_doc:\n-            description += f'```{command.short_doc}```'\n+            description.append(command.short_doc)\n         else:\n-            description += 'There is no description for this command.'\n+            description.append('There is no description for this command.')\n \n         embed = discord.Embed(\n             title=command.qualified_name,\n             color=utils.get_bot_color(),\n-            description=description\n+            description=''.join(description)\n         )\n         if command.cog is not None:\n             embed.set_author(name=f'In {command.cog.qualified_name} category')\ndiff --git a\/bot\/commands\/images.py b\/bot\/commands\/images.py\nindex 5f26890..6a9290b 100644\n--- a\/bot\/commands\/images.py\n+++ b\/bot\/commands\/images.py\n@@ -39,8 +39,8 @@ def embed_thatapiguy(ctx, response: dict):\n \n \n class Images(commands.Cog):\n+    \"\"\"Commands for getting images.\"\"\"\n     qualified_name = 'Images'\n-    description = 'Commands for getting images.'\n \n     def __init__(self, bot):\n         self.bot = bot\n@@ -55,16 +55,21 @@ def __init__(self, bot):\n     async def client_getcatimage(self, ctx):\n         \"\"\"\\N{CAT FACE}\"\"\"\n         if CAT_API_KEY is None:\n-            return await ctx.send('Sorry, but the bot currently cannot '\n-                                  'query for a cat image.')\n+            await ctx.send(\n+                'Sorry, but the bot currently cannot query for a cat image.',\n+                delete_after=10\n+            )\n+            return await asyncio.sleep(10)\n \n         await ctx.trigger_typing()\n \n         try:\n             cat = await query_thatapiguy(CAT_API_URL, CAT_API_KEY)\n         except ValueError as e:\n-            return await ctx.send('Could not get a cat image; '\n-                                  f'status code {e.args[1]}')\n+            return await ctx.send(\n+                f'Could not get a cat image; status code {e.args[1]}',\n+                delete_after=8\n+            )\n \n         await ctx.send(embed=embed_thatapiguy(ctx, cat))\n \n@@ -78,16 +83,21 @@ async def client_getcatimage(self, ctx):\n     async def client_getdogimage(self, ctx):\n         \"\"\"\\N{DOG FACE}\"\"\"\n         if DOG_API_KEY is None:\n-            return await ctx.send('Sorry, but the bot currently cannot '\n-                                  'query for a dog image.')\n+            await ctx.send(\n+                'Sorry, but the bot currently cannot query for a dog image.',\n+                delete_after=10\n+            )\n+            return await asyncio.sleep(10)\n \n         await ctx.trigger_typing()\n \n         try:\n             dog = await query_thatapiguy(DOG_API_URL, DOG_API_KEY)\n         except ValueError as e:\n-            return await ctx.send('Failed to query a dog image; '\n-                                  f'status code {e.args[1]}')\n+            return await ctx.send(\n+                f'Failed to query a dog image; status code {e.args[1]}',\n+                delete_after=8\n+            )\n \n         await ctx.send(embed=embed_thatapiguy(ctx, dog))\n \ndiff --git a\/bot\/commands\/info.py b\/bot\/commands\/info.py\nindex 2dcc7bc..3a0842c 100644\n--- a\/bot\/commands\/info.py\n+++ b\/bot\/commands\/info.py\n@@ -2,69 +2,24 @@\n import sys\n import random\n import time\n-import typing\n+from typing import Optional\n \n-from dateutil.relativedelta import relativedelta\n import discord\n from discord.ext import commands\n+from discord_slash.utils import manage_commands\n+from discord_slash import cog_ext as dslash_cog\n+from discord_slash import SlashContext\n+import discord_slash as dslash\n import humanize\n import psutil\n import pytz\n \n-from bot import settings\n-from bot import utils\n-\n-\n-class CommandConverter(commands.Converter):\n-    async def can_run(self, ctx, command):\n-        \"\"\"A variant of command.can_run() that doesn't check if\n-        the command is disabled.\"\"\"\n-        original = ctx.command\n-        ctx.command = command\n-\n-        try:\n-            if not await ctx.bot.can_run(ctx):\n-                return False\n-\n-            cog = command.cog\n-            if cog is not None:\n-                local_check = commands.Cog._get_overridden_method(cog.cog_check)\n-                if local_check is not None:\n-                    ret = await discord.utils.maybe_coroutine(local_check, ctx)\n-                    if not ret:\n-                        return False\n-\n-            predicates = command.checks\n-            if not predicates:\n-                # since we have no checks, then we just return True.\n-                return True\n-\n-            return await discord.utils.async_all(\n-                predicate(ctx) for predicate in predicates)\n-        finally:\n-            ctx.command = original\n-\n-    async def convert(self, ctx, argument):\n-        c = ctx.bot.get_command(argument)\n-        try:\n-            if c is None:\n-                raise commands.BadArgument(\n-                    f'Could not convert \"{argument}\" into a command.')\n-            elif not await self.can_run(ctx, c):\n-                raise commands.BadArgument(f'The user cannot use \"{argument}\".')\n-        except commands.CheckFailure as e:\n-            raise commands.BadArgument(str(e)) from e\n-        return c\n-\n-\n-def iterable_has(iterable, *args):\n-    \"Used for parsing *args in commands.\"\n-    return any(s in iterable for s in args)\n+from bot import converters, settings, utils\n \n \n class Informative(commands.Cog):\n+    \"\"\"Informative commands.\"\"\"\n     qualified_name = 'Informative'\n-    description = 'Informative commands.'\n \n     ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS = False\n     # If True, members of any guild the bot is in can be looked up in DMs.\n@@ -72,8 +27,6 @@ class Informative(commands.Cog):\n \n     DATETIME_DIFFERENCE_PRECISION = {'minutes': False, 'seconds': False}\n \n-    UPTIME_ALLOWED_DOWNTIME = 10\n-\n     COMMANDINFO_BUCKETTYPE_DESCRIPTIONS = {\n         commands.BucketType.default:  'globally',\n         commands.BucketType.user:     'per user',\n@@ -92,79 +45,6 @@ def __init__(self, bot):\n \n \n \n-    def update_last_connect(self, *, force_update=False):\n-        if not self.bot.uptime_is_online:\n-            # Calculate downtime\n-            now = datetime.datetime.now().astimezone()\n-            diff = now - self.bot.uptime_last_disconnect\n-\n-            # Only update last connect if downtime was long,\n-            # else record the downtime\n-            if force_update or (diff.total_seconds()\n-                                > self.UPTIME_ALLOWED_DOWNTIME):\n-                self.bot.uptime_last_connect = now\n-                self.bot.uptime_last_connect_adjusted = now\n-                self.bot.uptime_total_downtime = datetime.timedelta()\n-\n-                if force_update:\n-                    print('Uptime: forced uptime reset')\n-                else:\n-                    print(\n-                        'Uptime: Downtime of {} seconds exceeded allowed '\n-                        'downtime ({} seconds); resetting uptime'.format(\n-                            diff.total_seconds(),\n-                            self.UPTIME_ALLOWED_DOWNTIME\n-                        )\n-                    )\n-            else:\n-                self.bot.uptime_total_downtime += diff\n-                self.bot.uptime_last_connect_adjusted = (\n-                    self.bot.uptime_last_connect\n-                    + self.bot.uptime_total_downtime\n-                )\n-                print('Uptime:', 'Recorded downtime of',\n-                      diff.total_seconds(), 'seconds')\n-\n-            self.bot.uptime_is_online = True\n-\n-\n-    @commands.Cog.listener()\n-    async def on_command_completion(self, ctx):\n-        \"\"\"Used for tracking processed commands.\"\"\"\n-        self.bot.info_processed_commands[ctx.command.qualified_name] += 1\n-\n-    @commands.Cog.listener()\n-    async def on_connect(self):\n-        \"\"\"Used for uptime tracking.\n-\n-        Triggered when waking up from computer sleep.\n-        As there is no way to tell how long the computer went for sleep,\n-        this forces the last_connect time to be updated.\n-\n-        \"\"\"\n-        self.update_last_connect(force_update=True)\n-\n-\n-    @commands.Cog.listener()\n-    async def on_disconnect(self):\n-        \"\"\"Used for uptime tracking.\"\"\"\n-        self.bot.uptime_last_disconnect = datetime.datetime.now().astimezone()\n-        self.bot.uptime_is_online = False\n-\n-\n-    @commands.Cog.listener()\n-    async def on_resumed(self):\n-        \"\"\"Used for uptime tracking.\n-\n-        Triggered when reconnecting from an internet loss.\n-\n-        \"\"\"\n-        self.update_last_connect()\n-\n-\n-\n-\n-\n     @commands.command(\n         name='about', aliases=['info'])\n     @commands.cooldown(3, 60, commands.BucketType.guild)\n@@ -193,28 +73,30 @@ async def client_aboutbot(self, ctx, *args):\n \n         await ctx.trigger_typing()\n \n-        field_statistics = (\n-            f\"Bot started at: {start_time.strftime('%Y\/%m\/%d %a %X UTC')}\\n\"\n-        )\n+        field_statistics = [\n+            f\"Bot started at: {start_time.strftime('%Y\/%m\/%d %a %X UTC')}\"\n+        ]\n \n         if self.bot.intents.members:\n             member_count = sum(not u.bot for u in self.bot.users)\n+            s_member_count = f'{member_count:,}'\n         else:\n-            member_count = 'Unavailable'\n+            member_count = sum(g.member_count for g in self.bot.guilds)\n+            s_member_count = f'~{member_count:,}'\n \n         commands_processed = sum(\n             self.bot.info_processed_commands.values()) + 1\n \n-        field_statistics += (\n-            f'# Members: {member_count:,}\\n'\n-            f'# Servers: {len(self.bot.guilds):,}\\n'\n-            f'# Commands: {len(self.bot.commands):,}\\n'\n-            f'# Commands processed: {commands_processed:,}\\n'\n-            f'Python version: {version_python}\\n'\n-            f'D.py version: {discord.__version__}\\n'\n-        )\n+        field_statistics.extend((\n+            f'# Members: {s_member_count}',\n+            f'# Servers: {len(self.bot.guilds):,}',\n+            f'# Commands: {len(self.bot.commands):,}',\n+            f'# Commands processed: {commands_processed:,}',\n+            f'Python version: {version_python}',\n+            f'D.py version: {discord.__version__}'\n+        ))\n \n-        if iterable_has(args, '-S', '--system'):\n+        if utils.iterable_has(args, '-S', '--system'):\n             # Add system information\n             p = self.process\n             with p.oneshot():\n@@ -229,17 +111,17 @@ async def client_aboutbot(self, ctx, *args):\n                         max(1, cpu \/ 2) * random.uniform(5, 30)\n                     )\n \n-            field_statistics += (\n-                f'> Bootup time: {self.bot.info_bootup_time:.3g} seconds\\n'\n-                f'> CPU usage: {cpu:.3g}%\\n'\n-                f'> Memory usage: {humanize.naturalsize(mem_usage)}\\n'\n-                f'> Threads: {num_threads}\\n'\n-                f'> Handles: {num_handles}\\n'\n-            )\n+            field_statistics.extend((\n+                f'> Bootup time: {self.bot.info_bootup_time:.3g} seconds',\n+                f'> CPU usage: {cpu:.3g}%',\n+                f'> Memory usage: {humanize.naturalsize(mem_usage)}',\n+                f'> Threads: {num_threads}',\n+                f'> Handles: {num_handles}'\n+            ))\n \n         embed.add_field(\n             name='Statistics',\n-            value=field_statistics\n+            value='\\n'.join(field_statistics)\n         )\n \n         await ctx.send(embed=embed)\n@@ -248,14 +130,14 @@ async def client_aboutbot(self, ctx, *args):\n \n \n \n-    @commands.command(name='commandinfo')\n+    @commands.command(name='commandinfo', aliases=('cinfo',))\n     @commands.cooldown(3, 15, commands.BucketType.user)\n     async def client_commandinfo(self, ctx, *, command):\n         \"\"\"Get statistics about a command.\"\"\"\n-        def get_group_uses(stats, command):\n-            \"Recursively count the uses of a command group.\"\n+        def get_group_uses(stats, cmd):\n+            \"\"\"Recursively count the uses of a command group.\"\"\"\n             uses = 0\n-            for sub in command.commands:\n+            for sub in cmd.commands:\n                 if isinstance(sub, commands.Group):\n                     uses += get_group_uses(stats, sub)\n                 uses += stats[sub.qualified_name]\n@@ -263,9 +145,10 @@ def get_group_uses(stats, command):\n \n         # Search for the command\n         try:\n-            command = await CommandConverter().convert(ctx, command)\n+            command = await converters.CommandConverter().convert(ctx, command)\n         except commands.BadArgument:\n-            return await ctx.send(\"That command doesn't exist.\")\n+            return await ctx.send(\"That command doesn't exist.\",\n+                                  delete_after=6)\n \n         # Create a response\n         embed = discord.Embed(\n@@ -283,41 +166,50 @@ def get_group_uses(stats, command):\n                    else '\\N{NO ENTRY}')\n \n         # Write description\n-        description = ''\n+        description = []\n \n         # Insert cog\n         if command.cog is not None:\n-            description += (\n-                f'Categorized under: __{command.cog.qualified_name}__\\n')\n+            description.append(\n+                f'Categorized under: __{command.cog.qualified_name}__')\n \n         # Insert aliases\n         if len(command.aliases) == 1:\n-            description += f\"Alias: {command.aliases[0]}\\n\"\n+            description.append(f\"Alias: {command.aliases[0]}\")\n         elif len(command.aliases) > 1:\n-            description += f\"Aliases: {', '.join(command.aliases)}\\n\"\n+            description.append(f\"Aliases: {', '.join(command.aliases)}\")\n \n         # Insert parent\n         if command.parent is not None:\n-            description += f'Parent command: {command.parent.name}\\n'\n+            description.append(f'Parent command: {command.parent.name}')\n \n         # Insert enabled status\n-        description += f\"Is enabled: {enabled}\\n\"\n+        description.append(f\"Is enabled: {enabled}\")\n \n         # Insert hidden status\n         if command.hidden:\n-            description += 'Is hidden: \\N{WHITE HEAVY CHECK MARK}\\n'\n+            description.append('Is hidden: \\N{WHITE HEAVY CHECK MARK}')\n \n         # Insert cooldown\n-        cooldown = command._buckets._cooldown\n+        cooldown: commands.Cooldown = command._buckets._cooldown\n         if cooldown is not None:\n             cooldown_type = self.COMMANDINFO_BUCKETTYPE_DESCRIPTIONS.get(\n                 cooldown.type, '')\n-            description += (\n+            description.append(\n                 'Cooldown settings: '\n-                f'{cooldown.rate}\/{cooldown.per:.2g}s {cooldown_type}\\n'\n+                f'{cooldown.rate}\/{cooldown.per:.2g}s {cooldown_type}'\n+            )\n+\n+        # Insert concurrency limit\n+        concurrency: commands.MaxConcurrency = command._max_concurrency\n+        if concurrency is not None:\n+            concurrency_type = self.COMMANDINFO_BUCKETTYPE_DESCRIPTIONS.get(\n+                concurrency.per, '')\n+            concurrency_wait = '(has queue)' if concurrency.wait else ''\n+            description.append(\n+                'Concurrency settings: '\n+                f'{concurrency.number} {concurrency_type} {concurrency_wait}'\n             )\n-        else:\n-            description += 'Cooldown settings: unlimited\\n'\n \n         # Insert uses\n         uses = stats[command.qualified_name]\n@@ -330,15 +222,15 @@ def get_group_uses(stats, command):\n             uses += 1\n \n         if is_group:\n-            description += (\n-                f'# subcommands: {len(command.commands):,}\\n'\n-                f'# uses (including subcommands): {uses:,}\\n'\n-            )\n+            description.extend((\n+                f'# subcommands: {len(command.commands):,}',\n+                f'# uses (including subcommands): {uses:,}'\n+            ))\n         else:\n-            description += f'# uses: {uses:,}\\n'\n+            description.append(f'# uses: {uses:,}')\n \n         # Finalize embed\n-        embed.description = description\n+        embed.description = '\\n'.join(description)\n \n         await ctx.send(embed=embed)\n \n@@ -346,28 +238,40 @@ def get_group_uses(stats, command):\n \n \n \n-    @commands.command(name='invite')\n-    @commands.cooldown(1, 60, commands.BucketType.channel)\n-    async def client_invite(self, ctx):\n-        \"Get the bot's invite link.\"\n-        perms = discord.Permissions(\n-            add_reactions=True,\n-            read_messages=True,\n-            send_messages=True,\n-            embed_links=True,\n-            attach_files=True,\n-            read_message_history=True,\n-            external_emojis=True,\n-            change_nickname=True,\n-            connect=True,\n-            speak=True\n-        )\n+    def get_invite_link(self, perms: Optional[discord.Permissions] = None,\n+                        slash_commands=True):\n+        if perms is None:\n+            perms = discord.Permissions(\n+                add_reactions=True,\n+                read_messages=True,\n+                send_messages=True,\n+                embed_links=True,\n+                attach_files=True,\n+                read_message_history=True,\n+                external_emojis=True,\n+                change_nickname=True,\n+                connect=True,\n+                speak=True\n+            )\n \n         link = discord.utils.oauth_url(self.bot.user.id, perms)\n \n+        if slash_commands:\n+            link = link.replace('scope=bot', 'scope=bot%20applications.commands')\n+\n+        return link\n+\n+\n+    @commands.command(name='invite')\n+    @commands.cooldown(1, 60, commands.BucketType.channel)\n+    async def client_invite(self, ctx):\n+        \"\"\"Get the bot's invite link.\"\"\"\n+        link = self.get_invite_link()\n         embed = discord.Embed(\n-            color=utils.get_bot_color(),\n-            description=f'[OAuth2 Invite Link]({link})'\n+            color=utils.get_bot_color()\n+        ).set_author(\n+            name=f'\u2014> Invitation link <\u2014',\n+            url=link\n         ).set_footer(\n             text=f'Requested by {ctx.author.name}',\n             icon_url=ctx.author.avatar_url\n@@ -376,6 +280,15 @@ async def client_invite(self, ctx):\n         await ctx.send(embed=embed)\n \n \n+    @dslash_cog.cog_slash(name='invite')\n+    async def client_slash_invite(self, ctx: SlashContext):\n+        \"\"\"Get the invite link for the bot.\"\"\"\n+        link = self.get_invite_link()\n+\n+        await ctx.respond(eat=True)\n+        await ctx.send(content=f'[Invitation link]({link})', hidden=True)\n+\n+\n \n \n \n@@ -456,7 +369,7 @@ async def client_serverinfo(self, ctx, streamer_friendly: bool = True):\n         )\n         embed.add_field(\n             name=f\"{len(roles):,} Role{'s' if len(roles) != 1 else ''}\",\n-            value=', '.join([str(r) for r in roles]),\n+            value=', '.join([r.mention for r in roles]),\n             inline=False\n         )\n         embed.set_footer(\n@@ -490,7 +403,7 @@ async def client_timezone(self, ctx, *, timezone):\n         try:\n             tz = pytz.timezone(timezone)\n         except pytz.UnknownTimeZoneError:\n-            return await ctx.send('Unknown timezone.')\n+            return await ctx.send('Unknown timezone.', delete_after=6)\n \n         UTC = pytz.utc\n         utcnow = UTC.localize(datetime.datetime.utcnow())\n@@ -530,7 +443,7 @@ async def client_uptime(self, ctx):\n         name='userinfo')\n     @commands.cooldown(3, 20, commands.BucketType.user)\n     async def client_userinfo(self, ctx,\n-                              streamer_friendly: typing.Optional[bool] = True,\n+                              streamer_friendly: Optional[bool] = True,\n                               *, user=None):\n         \"\"\"Get information about a user by name or mention.\n \n@@ -544,14 +457,13 @@ async def client_userinfo(self, ctx,\n         if user is None:\n             user = ctx.author\n         else:\n-            user_input = user\n-\n             try:\n                 user = await commands.MemberConverter().convert(ctx, user)\n             except commands.MemberNotFound as e:\n                 if (not self.ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS\n                         and ctx.guild is None):\n-                    return await ctx.send('Cannot search for members in DMs.')\n+                    return await ctx.send(\n+                        'Cannot search for members in DMs.', delete_after=8)\n                 # Else allow error handler to deal with it\n                 raise e\n             else:\n@@ -567,7 +479,9 @@ async def client_userinfo(self, ctx,\n                         elif not self.ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS:\n                             # Disallowed showing guild members in DMs\n                             return await ctx.send(\n-                                'Cannot search for members in DMs.')\n+                                'Cannot search for members in DMs.',\n+                                delete_after=8\n+                            )\n \n         # Extract attributes based on whether its a Member or User\n         if isinstance(user, discord.Member):\n@@ -587,7 +501,7 @@ async def client_userinfo(self, ctx,\n                 user.joined_at.strftime('%Y\/%m\/%d %a %X UTC')\n             )\n             nickname = user.nick\n-            roles = [role.name for role in user.roles]\n+            roles = user.roles\n             if len(roles) > 1:\n                 # Has a role(s); remove @everyone\n                 roles = roles[:0:-1]\n@@ -607,6 +521,7 @@ async def client_userinfo(self, ctx,\n             description = '*For more information, ' \\\n                           'use this command in a server.*'\n             activity = None\n+            guild = None\n             joined = None\n             nickname = None\n             roles = None\n@@ -698,7 +613,7 @@ async def client_userinfo(self, ctx,\n         if roles is not None:\n             embed.add_field(\n                 name=f\"{len(roles):,} Role{'s' if len(roles) != 1 else ''}\",\n-                value=', '.join(roles),\n+                value=', '.join([r.mention for r in roles]),\n                 inline=False\n             )\n         embed.set_footer(\ndiff --git a\/bot\/commands\/mathematics.py b\/bot\/commands\/mathematics.py\nindex 099c8bc..4747a04 100644\n--- a\/bot\/commands\/mathematics.py\n+++ b\/bot\/commands\/mathematics.py\n@@ -21,8 +21,8 @@\n \n \n class Mathematics(commands.Cog):\n+    \"\"\"Commands for mathematical operations.\"\"\"\n     qualified_name = 'Mathematics'\n-    description = 'Commands for mathematical operations.'\n \n     def __init__(self, bot):\n         self.bot = bot\n@@ -41,7 +41,7 @@ async def client_add(self, ctx, x: dec_or_hex, y: dec_or_hex):\n     async def client_add_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n@@ -61,7 +61,7 @@ async def client_subtract(self, ctx, x: dec_or_hex, y: dec_or_hex):\n     async def client_subtract_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n@@ -81,7 +81,7 @@ async def client_multiply(self, ctx, x: dec_or_hex, y: dec_or_hex):\n     async def client_multiply_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n@@ -101,7 +101,9 @@ async def client_divide(self, ctx, x: dec_or_hex, y: dec_or_hex):\n     async def client_divide_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n+        elif isinstance(error, ZeroDivisionError):\n+            await ctx.send('Division by Zero occurred.', delete_after=5)\n \n \n \n@@ -121,7 +123,7 @@ async def client_exponent(self, ctx, x: dec_or_hex, y: dec_or_hex):\n     async def client_exponent_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n@@ -141,7 +143,7 @@ async def client_sqrt(self, ctx, x: dec_or_hex):\n     async def client_sqrt_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n@@ -154,17 +156,17 @@ async def client_sqrt_error(self, ctx, error):\n     async def client_evaluate(self, ctx, *, expr: str):\n         \"\"\"Evaluates a simple mathematical expression.\n Syntax:\n-    **: Exponentation\n-    \/\/: Floor division\n-     %: Modulus\n-     ~: Bitwise NOT\n-     |: Bitwise OR\n-     &: Bitwise AND\n-     ^: Bitwise XOR\n-    <<: Left Shift\n-    >>: Right Shift\n-\n-Example expression: (1+3) ** -2 - 7 \/\/ 9e2\n+```yaml\n+**: Exponentation\n+\/\/: Floor division\n+ %: Modulus\n+ ~: Bitwise NOT\n+ |: Bitwise OR\n+ &: Bitwise AND\n+ ^: Bitwise XOR\n+<<: Left Shift\n+>>: Right Shift\n+``` Example expression: `(1+3) ** -2 - 7 \/\/ 9e2`\n \n To reveal the evaluation of your expression, add --debug to your expression.\"\"\"\n         debugging = '--debug' in expr\n@@ -201,15 +203,17 @@ async def client_evaluate(self, ctx, *, expr: str):\n     async def client_evaluate_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, SyntaxError):\n-            await ctx.send(f'Undefined Syntax Error occurred: {error}')\n+            await ctx.send(f'Undefined Syntax Error occurred: {error}',\n+                           delete_after=10)\n         elif isinstance(error, ZeroDivisionError):\n-            await ctx.send('Division by Zero occurred.')\n+            await ctx.send('Division by Zero occurred.', delete_after=5)\n         elif isinstance(error, ValueError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n         elif isinstance(error, TypeError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n         elif isinstance(error, decimal.Overflow):\n-            await ctx.send('Could not calculate due to overflow.')\n+            await ctx.send('Could not calculate due to overflow.',\n+                           delete_after=8)\n \n \n \n@@ -276,9 +280,9 @@ async def client_fibonacci(self, ctx, n: int, m: int = None):\n     async def client_fibonacci_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, ValueError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n         elif isinstance(error, OverflowError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n \n \n \n@@ -297,17 +301,18 @@ async def client_gcd(self, ctx, x: int, y: str):\n         await ctx.channel.trigger_typing()\n \n         if x > 1_000_000:\n-            await ctx.send('X must be below one million.')\n+            await ctx.send('X must be below one million.', delete_after=6)\n         elif y == 'low' or y == 'high':\n             await ctx.send(utils.gcd(x, y))\n         else:\n             try:\n                 y = int(y)\n             except ValueError:\n-                await ctx.send('Y is not an integer.')\n+                await ctx.send('Y is not an integer.', delete_after=6)\n             else:\n                 if y > 1_000_000:\n-                    await ctx.send('Y must be below one million.')\n+                    await ctx.send('Y must be below one million.',\n+                                   delete_after=6)\n                 else:\n                     await ctx.send(utils.gcd(x, y))\n \n@@ -328,9 +333,10 @@ async def client_isprime(self, ctx, n: int, setting: str = 'high'):\n \n         if n < 2:\n             return await ctx.send(f'{n} is not a prime number;\\n'\n-                           'all whole numbers below 3 are not prime.')\n+                                  'all whole numbers below 3 are not prime.')\n         elif n > 1_000_000:\n-            return await ctx.send('N must be below one million.')\n+            return await ctx.send('N must be below one million.',\n+                                  delete_after=6)\n \n \n         divisor = utils.gcd(n, setting)\n@@ -402,7 +408,8 @@ async def client_factors(self, ctx, n: int):\n n - The number to test.\n The maximum number to check factors is 10000.\"\"\"\n         if n > 10000:\n-            return await ctx.send('N must be below ten thousand.')\n+            return await ctx.send('N must be below ten thousand.',\n+                                  delete_after=6)\n \n         await ctx.channel.trigger_typing()\n \n@@ -418,12 +425,10 @@ async def client_factors(self, ctx, n: int):\n     @client_factors.error\n     async def client_factors_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n-        if isinstance(error, commands.BadArgument):\n-            await ctx.send('An integer must be given.')\n-        elif isinstance(error, ValueError):\n-            await ctx.send(str(error))\n+        if isinstance(error, ValueError):\n+            await ctx.send(str(error), delete_after=10)\n         elif isinstance(error, TypeError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n \n \n \n@@ -503,7 +508,8 @@ def separate(m):\n \n         await ctx.send('{quantity}{unit:~} ({unit})'.format(\n             quantity=quantity,\n-            unit=converted_unit.units))\n+            unit=converted_unit.units\n+        ))\n \n \n \n@@ -550,11 +556,9 @@ async def client_numberbase_error(self, ctx, error):\n                 num = [n[:-1] for n in msg.split() if n[:-1].isnumeric()][0]\n                 msg = ('There is a character within the number not part of'\n                     f' base {num}.')\n-            await ctx.send(msg)\n+            await ctx.send(msg, delete_after=10)\n         elif isinstance(error, TypeError):\n-            await ctx.send(str(error))\n-        else:\n-            await ctx.send('An unspecified error has occurred.')\n+            await ctx.send(str(error), delete_after=10)\n \n \n \ndiff --git a\/bot\/commands\/notes.py b\/bot\/commands\/notes.py\nindex 07cd938..47f9292 100644\n--- a\/bot\/commands\/notes.py\n+++ b\/bot\/commands\/notes.py\n@@ -3,21 +3,28 @@\n \n import discord\n from discord.ext import commands\n+from discord_slash.utils import manage_commands\n+from discord_slash import cog_ext as dslash_cog\n+from discord_slash import SlashContext\n+import discord_slash as dslash\n import inflect\n \n-from bot.database import NoteDatabase, DATABASE_USERS\n+\n+from bot.database import NoteDatabase\n from bot import utils\n \n inflector = inflect.engine()\n \n \n class Notes(commands.Cog):\n+    \"\"\"Commands for saving notes.\"\"\"\n     qualified_name = 'Notes'\n-    description = 'Commands for saving notes.'\n+\n+    max_notes_user = 20\n \n     def __init__(self, bot):\n         self.bot = bot\n-        self.notedb = NoteDatabase(DATABASE_USERS)\n+        self.notedb = NoteDatabase\n         self.cache = {}  # user_id: notes\n         # NOTE: this bot is small so this isn't required but if the bot\n         # never restarts frequently, the cache could grow forever,\n@@ -28,12 +35,12 @@ def __init__(self, bot):\n \n \n     async def add_note(self, user_id, *args, **kwargs):\n-        \"Adds a note and invalidates the user's cache.\"\n+        \"\"\"Adds a note and invalidates the user's cache.\"\"\"\n         await self.notedb.add_note(user_id, *args, **kwargs)\n         del self.cache[user_id]\n \n     async def delete_note_by_note_id(self, note_id, pop=False):\n-        \"Remove a note by note_id and update the cache.\"\n+        \"\"\"Remove a note by note_id and update the cache.\"\"\"\n         deleted = await self.notedb.delete_note_by_note_id(note_id, pop=True)\n \n         updated_ids = frozenset(note['user_id'] for note in deleted)\n@@ -59,18 +66,16 @@ async def get_notes(self, user_id):\n \n     @commands.command(name='addnote')\n     @commands.cooldown(2, 5, commands.BucketType.user)\n+    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)\n     async def client_addnote(self, ctx, *, note):\n-        \"\"\"Add a note.\n-\n-You can have a maximum of 20 notes.\"\"\"\n+        \"\"\"Store a note on the bot.\"\"\"\n         await ctx.channel.trigger_typing()\n \n         total_notes = len(await self.get_notes(ctx.author.id))\n \n-        if total_notes < 20:\n+        if total_notes < self.max_notes_user:\n             await self.add_note(\n-                ctx.author.id, datetime.datetime.now().astimezone(), note,\n-                add_user=True\n+                ctx.author.id, datetime.datetime.now().astimezone(), note\n             )\n \n             await ctx.send(\n@@ -80,7 +85,49 @@ async def client_addnote(self, ctx, *, note):\n             )\n         else:\n             await ctx.send(\n-                'Sorry, but you have reached your maximum limit of 20 notes.')\n+                'Sorry, but you have reached your maximum limit of '\n+                f'{self.max_notes_user:,} notes.',\n+                delete_after=6\n+            )\n+\n+\n+    @dslash_cog.cog_subcommand(\n+        base='notes',\n+        name='add',\n+        description=f'Store a note. You can have a maximum of {max_notes_user:,} notes.',\n+        base_description='Commands for saving notes.',\n+        options=[manage_commands.create_option(\n+            name='text',\n+            description='The content of your note.',\n+            option_type=3,\n+            required=True\n+        )]\n+    )\n+    async def client_slash_addnote(self, ctx: SlashContext, note):\n+        await ctx.respond(eat=True)\n+\n+        max_length = 2000 - len(f'__Note #{self.max_notes_user:,}__\\n')\n+        if len(note) > max_length:\n+            return await ctx.send('This note is too large.', hidden=True)\n+\n+        total_notes = len(await self.get_notes(ctx.author.id))\n+\n+        if total_notes < self.max_notes_user:\n+            await self.add_note(\n+                ctx.author.id, datetime.datetime.now().astimezone(), note\n+            )\n+\n+            await ctx.send(\n+                'Your {} note has been added!'.format(\n+                    inflector.ordinal(total_notes + 1)\n+                ), hidden=True\n+            )\n+        else:\n+            await ctx.send(\n+                'Sorry, but you have reached your maximum limit of '\n+                f'{self.max_notes_user:,} notes.',\n+                hidden=True\n+            )\n \n \n \n@@ -88,6 +135,7 @@ async def client_addnote(self, ctx, *, note):\n \n     @commands.command(name='removenote')\n     @commands.cooldown(2, 5, commands.BucketType.user)\n+    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)\n     async def client_removenote(self, ctx, index: int):\n         \"\"\"Remove a note.\n \n@@ -98,22 +146,55 @@ async def client_removenote(self, ctx, index: int):\n         note_list = await self.get_notes(ctx.author.id)\n \n         if len(note_list) == 0:\n-            return await ctx.send(\"You already don't have any notes.\")\n+            return await ctx.send(\"You already don't have any notes.\",\n+                                  delete_after=6)\n \n         try:\n             note = note_list[index - 1]\n         except IndexError:\n-            await ctx.send('That note index does not exist.')\n+            await ctx.send('That note index does not exist.', delete_after=6)\n         else:\n             await self.delete_note_by_note_id(note['note_id'])\n             await ctx.send('Note successfully deleted!')\n \n \n+    @dslash_cog.cog_subcommand(\n+        base='notes',\n+        name='remove',\n+        options=[manage_commands.create_option(\n+            name='index',\n+            description='The note to remove.',\n+            option_type=4,\n+            required=True\n+        )]\n+    )\n+    async def client_slash_removenote(self, ctx: SlashContext, index: int):\n+        \"\"\"Remove a note by index. To see the indices for your notes, use \/notes show.\"\"\"\n+        await ctx.respond(eat=True)\n+\n+        note_list = await self.get_notes(ctx.author.id)\n+\n+        if len(note_list) == 0:\n+            return await ctx.send(\"You already don't have any notes.\",\n+                                  hidden=True)\n+\n+        try:\n+            note = note_list[index - 1]\n+        except IndexError:\n+            await ctx.send('That note index does not exist.',\n+                           hidden=True)\n+        else:\n+            await self.delete_note_by_note_id(note['note_id'])\n+            await ctx.send('Note successfully deleted!',\n+                           hidden=True)\n+\n+\n \n \n \n     @commands.command(name='removenotes')\n     @commands.cooldown(1, 5, commands.BucketType.user)\n+    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)\n     async def client_removenotes(self, ctx, indices):\n         \"\"\"Remove multiple notes.\n \n@@ -124,7 +205,8 @@ async def client_removenotes(self, ctx, indices):\n         note_list = await self.get_notes(ctx.author.id)\n \n         if len(note_list) == 0:\n-            return await ctx.send(\"You already don't have any notes.\")\n+            return await ctx.send(\"You already don't have any notes.\",\n+                                  delete_after=6)\n \n         if indices.lower() == 'all':\n             for note in note_list:\n@@ -135,10 +217,13 @@ async def client_removenotes(self, ctx, indices):\n             start, end = [int(n) for n in indices.split('-')]\n             start -= 1\n             if start < 0:\n-                return await ctx.send('Start must be 1 or greater.')\n+                return await ctx.send('Start must be 1 or greater.',\n+                                      delete_after=6)\n             elif end > len(note_list):\n                 return await ctx.send(\n-                    f'End must only go up to {len(note_list)}.')\n+                    f'End must only go up to {len(note_list)}.',\n+                    delete_after=6\n+                )\n \n             for i in range(start, end):\n                 note = note_list[i]\n@@ -151,6 +236,7 @@ async def client_removenotes(self, ctx, indices):\n \n     @commands.command(name='shownote')\n     @commands.cooldown(2, 5, commands.BucketType.user)\n+    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)\n     async def client_shownote(self, ctx, index: int):\n         \"\"\"Show one of your notes.\"\"\"\n         await ctx.channel.trigger_typing()\n@@ -158,15 +244,14 @@ async def client_shownote(self, ctx, index: int):\n         note_list = await self.get_notes(ctx.author.id)\n \n         if len(note_list) == 0:\n-            return await ctx.send(\"You don't have any notes.\")\n-\n-        if index < 1:\n-            return await ctx.send('Index must be 1 or greater.')\n+            return await ctx.send(\"You don't have any notes.\", delete_after=6)\n+        elif index < 1:\n+            return await ctx.send('Index must be 1 or greater.', delete_after=6)\n \n         try:\n             note = note_list[index - 1]\n         except IndexError:\n-            await ctx.send('That note index does not exist.')\n+            await ctx.send('That note index does not exist.', delete_after=6)\n         else:\n             await ctx.send(embed=discord.Embed(\n                 title=f'Note #{index:,}',\n@@ -177,6 +262,58 @@ async def client_shownote(self, ctx, index: int):\n             ))\n \n \n+    @dslash_cog.cog_subcommand(\n+        base='notes',\n+        name='show',\n+        options=[manage_commands.create_option(\n+            name='index',\n+            description='The note to view. Leave empty to show all notes.',\n+            option_type=4,\n+            required=False\n+        )]\n+    )\n+    async def client_slash_shownote(self, ctx: SlashContext, index: int = None):\n+        \"\"\"Show one or all of your notes.\"\"\"\n+        await ctx.respond(eat=True)\n+\n+        note_list = await self.get_notes(ctx.author.id)\n+        notes_len = len(note_list)\n+\n+        if notes_len == 0:\n+            return await ctx.send(\"You don't have any notes.\", hidden=True)\n+        elif index is not None:\n+            # Show one note\n+            if index < 1:\n+                return await ctx.send('Index must be 1 or greater.', hidden=True)\n+\n+            try:\n+                note = note_list[index - 1]\n+            except IndexError:\n+                await ctx.send('That note index does not exist.', hidden=True)\n+            else:\n+                content = (\n+                    f'__Note #{index:,}__\\n'\n+                    f\"{note['content']}\"\n+                )\n+                await ctx.send(content, hidden=True)\n+        else:\n+            # Show all notes\n+            # Create fields for each note, keeping it under 2000 characters\n+            title_total = len(f'__Note {notes_len:,}__\\n')\n+            title_total += 2 * notes_len - 2  # Include newlines\n+            max_per_field = (2000 - title_total) \/\/ self.max_notes_user\n+\n+            fields = [\n+                f'__Note {i:,}__\\n'\n+                + utils.truncate_message(\n+                    note['content'], max_per_field, max_lines=5)\n+                for i, note in enumerate(note_list, start=1)\n+            ]\n+            content = '\\n\\n'.join(fields)\n+\n+            await ctx.send(content, hidden=True)\n+\n+\n \n \n \n@@ -190,11 +327,11 @@ async def client_shownotes(self, ctx):\n         note_list = await self.get_notes(ctx.author.id)\n \n         if len(note_list) == 0:\n-            return await ctx.send(\"You don't have any notes.\")\n+            return await ctx.send(\"You don't have any notes.\", delete_after=6)\n \n         # Create fields for each note, limiting them to 140 characters\/5 lines\n         fields = [\n-            utils.truncate_message(note['content'], 140, size_lines=5)\n+            utils.truncate_message(note['content'], 140, max_lines=5)\n             for note in note_list\n         ]\n         color = utils.get_user_color(ctx.author)\ndiff --git a\/bot\/commands\/prefix.py b\/bot\/commands\/prefix.py\nindex 40dd2e9..85d19b0 100644\n--- a\/bot\/commands\/prefix.py\n+++ b\/bot\/commands\/prefix.py\n@@ -1,8 +1,9 @@\n+# TODO: remove guild from database when removed\n import discord\n from discord.ext import commands\n import inflect\n \n-from bot.database import PrefixDatabase, DATABASE_USERS\n+from bot.database import PrefixDatabase\n from bot import utils\n \n inflector = inflect.engine()\n@@ -18,12 +19,12 @@ async def extended_check(ctx):\n \n \n class Prefix(commands.Cog):\n+    \"\"\"Commands for changing the bot's prefix.\"\"\"\n     qualified_name = 'Prefix'\n-    description = \"Commands for changing the bot's prefix.\"\n \n     def __init__(self, bot):\n         self.bot = bot\n-        self.prefixdb = PrefixDatabase(DATABASE_USERS)\n+        self.prefixdb = PrefixDatabase\n         self.mention_prefix_cooldown = commands.CooldownMapping.from_cooldown(\n             1, 15, commands.BucketType.member)\n \n@@ -41,17 +42,14 @@ def list_discard(seq, value):\n                 pass\n \n         # Ignore messages that are from bot or didn't mention the bot\n-        if self.bot.user not in message.mentions:\n-            return\n-        if message.author == self.bot.user:\n+        if (self.bot.user not in message.mentions\n+                or message.author == self.bot.user):\n             return\n \n         bot_mentions = (f'<@{self.bot.user.id}>', f'<@!{self.bot.user.id}>')\n \n-        # Ignore proper\/invalid command invokations\n-        # ctx = await self.bot.get_context(message)\n-        # if ctx.valid:\n-        #     return\n+        # Check if the message content ONLY consists of the mention\n+        # and return otherwise\n         if message.content not in bot_mentions:\n             return\n \n@@ -94,7 +92,8 @@ async def client_changeprefix(self, ctx, prefix):\n \n         if not prefix:\n             ctx.command.reset_cooldown(ctx)\n-            return await ctx.send('An empty prefix is not allowed.')\n+            return await ctx.send(\n+                'An empty prefix is not allowed.', delete_after=6)\n \n         await ctx.trigger_typing()\n \n@@ -103,13 +102,13 @@ async def client_changeprefix(self, ctx, prefix):\n         )\n \n         if prefix == current_prefix:\n-            await ctx.send('That is already the current prefix.')\n+            await ctx.send('That is already the current prefix.',\n+                           delete_after=6)\n         else:\n             # Escape escape characters before printing\n             clean_prefix = prefix.replace('\\\\', r'\\\\')\n             await self.prefixdb.update_prefix(ctx.guild.id, prefix)\n-            await ctx.send(\n-                f'Successfully changed prefix to: \"{clean_prefix}\"')\n+            await ctx.send(f'Successfully changed prefix to: \"{clean_prefix}\"')\n \n \n     @client_changeprefix.error\ndiff --git a\/bot\/commands\/randomization.py b\/bot\/commands\/randomization.py\nindex 4b1923d..a1b03bc 100644\n--- a\/bot\/commands\/randomization.py\n+++ b\/bot\/commands\/randomization.py\n@@ -2,6 +2,11 @@\n import random\n \n from discord.ext import commands\n+from discord_slash.utils import manage_commands\n+from discord_slash import cog_ext as dslash_cog\n+from discord_slash import SlashContext\n+\n+from bot import settings, utils\n \n CLIENT_EIGHTBALL = (\n     'It is certain.',\n@@ -28,15 +33,16 @@\n     'Very doubtful.'\n )\n CLIENT_PICK_DIALOGUE = (\n-    '{mention} I choose {choice}.',\n-    '{mention} I pick {choice}.',\n-    '{mention} I select {choice}.',\n+    'I choose {choice}.',\n+    'I pick {choice}.',\n+    'I select {choice}.',\n+    'My choice is {choice}.'\n )\n \n \n class Randomization(commands.Cog):\n+    \"\"\"Commands with randomized interactions.\"\"\"\n     qualified_name = 'Randomization'\n-    description = 'Commands with randomized interactions.'\n \n     def __init__(self, bot):\n         self.bot = bot\n@@ -83,7 +89,7 @@ def flip(sides=('Heads', 'Tails')):\n         if not skip_delay:\n             await ctx.trigger_typing()\n             await asyncio.sleep(1.5)\n-        await ctx.send(result)\n+        await ctx.send(result, reference=ctx.message)\n \n \n \n@@ -116,7 +122,8 @@ def roll():\n                 amount, sides = int(dice), 6\n         except ValueError:\n             # excepts \"2d6d6\" (dice.split) and failed integer conversions\n-            return await ctx.send('Failed to parse parameter \"dice\".')\n+            return await ctx.send('Failed to parse parameter \"dice\".',\n+                                  delete_after=6)\n \n         skip_delay = False\n \n@@ -150,7 +157,7 @@ def roll():\n         if not skip_delay:\n             await ctx.trigger_typing()\n             await asyncio.sleep(1.5)\n-        await ctx.send(result)\n+        await ctx.send(result, reference=ctx.message)\n \n \n \n@@ -164,8 +171,25 @@ async def client_eightball(self, ctx, *, question: str = ''):\n         \"\"\"Answers a yes or no question.\"\"\"\n         await ctx.trigger_typing()\n         await asyncio.sleep(random.randint(1, 5))\n-        await ctx.send(\n-            f'{ctx.author.mention} {random.choice(CLIENT_EIGHTBALL)}')\n+        await ctx.send(random.choice(CLIENT_EIGHTBALL), reference=ctx.message)\n+\n+\n+\n+\n+\n+    @dslash_cog.cog_slash(\n+        name='8ball',\n+        options=[manage_commands.create_option(\n+            name='question',\n+            description='The question to ask. Can be left empty.',\n+            option_type=3,\n+            required=False\n+        )]\n+    )\n+    async def client_slash_eightball(self, ctx: SlashContext, question=''):\n+        \"\"\"Shake an eight-ball for a question.\"\"\"\n+        await ctx.respond()\n+        await ctx.send(random.choice(CLIENT_EIGHTBALL))\n \n \n \n@@ -180,14 +204,48 @@ async def client_pick(self, ctx, choice1, choice2, *choices):\n Ayana command used as reference.\"\"\"\n         choices = list(choices)\n         choices += [choice1, choice2]\n+        selected = random.choice(CLIENT_PICK_DIALOGUE).format(\n+            choice=random.choice(choices))\n         await ctx.trigger_typing()\n         await asyncio.sleep(1)\n-        await ctx.send(\n-            random.choice(CLIENT_PICK_DIALOGUE).format(\n-                choice=random.choice(choices),\n-                mention=ctx.author.mention\n-            )\n-        )\n+        await ctx.send(selected, reference=ctx.message)\n+\n+    @dslash_cog.cog_slash(\n+        name='pick',\n+        options=[manage_commands.create_option(\n+            name='first',\n+            description='The first option.',\n+            option_type=3,\n+            required=True\n+        ), manage_commands.create_option(\n+            name='second',\n+            description='The second option.',\n+            option_type=3,\n+            required=True\n+        ), manage_commands.create_option(\n+            name='extra',\n+            description='Extra options, separated by spaces. '\n+                        'Use quotes for multi-word choices (\"one choice\").',\n+            option_type=3,\n+            required=False\n+        )]\n+    )\n+    async def client_slash_pick(self, ctx: SlashContext,\n+                                choice1, choice2, extra=None):\n+        \"\"\"Choose one of the given options.\"\"\"\n+        await ctx.respond()\n+\n+        if extra is not None:\n+            choices = utils.parse_var_positional(extra)\n+        else:\n+            choices = []\n+        choices.append(choice1)\n+        choices.append(choice2)\n+\n+        selected = random.choice(CLIENT_PICK_DIALOGUE).format(\n+            choice=random.choice(choices))\n+\n+        await ctx.send(selected)\n \n \n \ndiff --git a\/bot\/commands\/reminders.py b\/bot\/commands\/reminders.py\nindex 01fccc5..594b016 100644\n--- a\/bot\/commands\/reminders.py\n+++ b\/bot\/commands\/reminders.py\n@@ -10,22 +10,22 @@\n \n from bot import utils\n from bot.classes.timeobj import parse_timedelta\n-from bot.database import ReminderDatabase, DATABASE_USERS\n+from bot.database import ReminderDatabase\n from bot.other import discordlogger\n \n inflector = inflect.engine()\n \n \n class Reminders(commands.Cog):\n+    \"\"\"Commands for setting up reminders.\"\"\"\n     qualified_name = 'Reminders'\n-    description = 'Commands for setting up reminders.'\n \n     send_reminders_near_due = datetime.timedelta(minutes=11)\n     # NOTE: should be just a bit longer than task loop\n \n     def __init__(self, bot):\n         self.bot = bot\n-        self.reminderdb = ReminderDatabase(DATABASE_USERS)\n+        self.reminderdb = ReminderDatabase\n         self.cache = {}  # user_id: reminders\n         # NOTE: this bot is small so this isn't required but if the bot\n         # never restarts frequently, the cache could grow forever,\n@@ -45,8 +45,8 @@ def cog_unload(self):\n \n \n \n-    async def add_reminder(self, user_id, utcdue, content, add_user=False):\n-        \"Adds a reminder and invalidates the user's cache.\"\n+    async def add_reminder(self, user_id, utcdue, content, add_user=True):\n+        \"\"\"Adds a reminder and invalidates the user's cache.\"\"\"\n         reminder_id = await self.reminderdb.add_reminder(\n             user_id, utcdue, content, add_user=add_user)\n         self.cache.pop(user_id, None)\n@@ -130,16 +130,19 @@ async def client_addreminder(self, ctx, *, time_and_reminder):\n                 return await self.send_with_disclaimer(\n                     ctx,\n                     'Could not understand your reminder request. Check this '\n-                    \"command's help page for allowed syntax.\"\n+                    \"command's help page for allowed syntax.\",\n+                    delete_after=6\n                 )\n \n             if td.total_seconds() < 30:\n                 return await self.send_with_disclaimer(\n                     ctx, 'You must set a reminder lasting for at '\n-                    'least 30 seconds!')\n+                    'least 30 seconds.', delete_after=6)\n             elif not content:\n                 return await self.send_with_disclaimer(\n-                    ctx, 'You must have a message with your reminder!')\n+                    ctx, 'You must have a message with your reminder.',\n+                    delete_after=6\n+                )\n \n             # Round seconds down if td does not specify seconds\n             if td.seconds % 60 == 0:\n@@ -148,8 +151,7 @@ async def client_addreminder(self, ctx, *, time_and_reminder):\n             utcdue = utcnow + td\n \n             await self.add_reminder(\n-                ctx.author.id, utcdue, content,\n-                add_user=True\n+                ctx.author.id, utcdue, content\n             )\n \n             await self.send_with_disclaimer(\n@@ -164,7 +166,7 @@ async def client_addreminder(self, ctx, *, time_and_reminder):\n         else:\n             await self.send_with_disclaimer(\n                 ctx, 'Sorry, but you have reached your maximum limit '\n-                'of 5 reminders.'\n+                'of 5 reminders.', delete_after=6\n             )\n \n \n@@ -183,13 +185,13 @@ async def client_removereminder(self, ctx, index: int):\n \n         if len(reminder_list) == 0:\n             return await self.send_with_disclaimer(\n-                ctx, \"You already don't have any reminders.\")\n+                ctx, \"You already don't have any reminders.\", delete_after=6)\n \n         try:\n             reminder = reminder_list[index - 1]\n         except IndexError:\n             await self.send_with_disclaimer(\n-                ctx, 'That reminder index does not exist.')\n+                ctx, 'That reminder index does not exist.', delete_after=6)\n         else:\n             await self.delete_reminder_by_id(reminder['reminder_id'])\n             await self.send_with_disclaimer(\n@@ -212,23 +214,24 @@ async def client_removereminders(self, ctx, indices):\n \n         if len(reminder_list) == 0:\n             return await self.send_with_disclaimer(\n-                ctx, \"You already don't have any reminders.\")\n+                ctx, \"You already don't have any reminders.\", delete_after=6)\n \n         if indices.lower() == 'all':\n             for reminder in reminder_list:\n                 await self.delete_reminder_by_id(reminder['reminder_id'])\n             await self.send_with_disclaimer(\n-                ctx, 'Reminders successfully deleted!')\n+                ctx, 'Reminders successfully deleted!', delete_after=6)\n \n         else:\n             start, end = [int(n) for n in indices.split('-')]\n             start -= 1\n             if start < 0:\n                 return await self.send_with_disclaimer(\n-                    ctx, 'Start must be 1 or greater.')\n+                    ctx, 'Start must be 1 or greater.', delete_after=6)\n             elif end > len(reminder_list):\n                 return await self.send_with_disclaimer(\n-                    ctx, f'End must only go up to {len(reminder_list)}.')\n+                    ctx, f'End must only go up to {len(reminder_list)}.',\n+                    delete_after=6)\n \n             for i in range(start, end):\n                 reminder = reminder_list[i]\n@@ -250,17 +253,17 @@ async def client_showreminder(self, ctx, index: int):\n \n         if len(reminder_list) == 0:\n             return await self.send_with_disclaimer(\n-                ctx, \"You don't have any reminders.\")\n+                ctx, \"You don't have any reminders.\", delete_after=6)\n \n         if index < 1:\n             return await self.send_with_disclaimer(\n-                ctx, 'Index must be 1 or greater.')\n+                ctx, 'Index must be 1 or greater.', delete_after=6)\n \n         try:\n             reminder = reminder_list[index - 1]\n         except IndexError:\n             await self.send_with_disclaimer(\n-                ctx, 'That index does not exist.')\n+                ctx, 'That index does not exist.', delete_after=6)\n         else:\n             utcdue = datetime.datetime.fromisoformat(reminder['due'])\n             embed = discord.Embed(\n@@ -294,12 +297,12 @@ async def client_showreminders(self, ctx):\n \n         if len(reminder_list) == 0:\n             return await self.send_with_disclaimer(\n-                ctx, \"You don't have any reminders.\")\n+                ctx, \"You don't have any reminders.\", delete_after=6)\n \n         # Create fields for each reminder, limiting them\n         # to 140 characters\/5 lines\n         fields = [\n-            utils.truncate_message(reminder['content'], 140, size_lines=5)\n+            utils.truncate_message(reminder['content'], 140, max_lines=5)\n             for reminder in reminder_list\n         ]\n         color = utils.get_user_color(ctx.author)\ndiff --git a\/bot\/commands\/undefined.py b\/bot\/commands\/undefined.py\nindex 959d416..786ce8c 100644\n--- a\/bot\/commands\/undefined.py\n+++ b\/bot\/commands\/undefined.py\n@@ -1,24 +1,16 @@\n import asyncio\n import calendar\n-import collections\n-from concurrent.futures import ThreadPoolExecutor\n-import csv\n-import json\n-import math\n import random\n import time\n-import typing\n+from typing import Union\n \n import discord\n from discord.ext import commands\n-import inflect\n \n-from bot import checks\n-from bot import settings\n+from bot.classes.confirmation import AdaptiveConfirmation\n+from bot.database import GuildDatabase\n from bot import utils\n \n-inflector = inflect.engine()\n-\n WORDLIST_PATH = 'data\/wordlist.txt'\n \n # goodday command\n@@ -39,206 +31,27 @@\n     WORDLIST = set(f.read().split())\n \n \n-# phasmophobia commands\n-class Ghost:\n-    __slots__ = ('name', 'evidences', 'url')\n-\n-    def __init__(self, name, evidences, url):\n-        self.name = name\n-        self.evidences = evidences\n-        self.url = url\n-\n-\n-GHOST_EVIDENCE = [\n-    Ghost('Banshee',\n-          ('EMF Level 5', 'Fingerprints', 'Freezing Temperatures'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Banshee'),\n-    Ghost('Demon',\n-          ('Freezing Temperatures', 'Ghost Writing', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Demon'),\n-    Ghost('Jinn',\n-          ('EMF Level 5', 'Ghost Orb', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Jinn'),\n-    Ghost('Mare',\n-          ('Freezing Temperatures', 'Ghost Orb', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Mare'),\n-    Ghost('Oni',\n-          ('EMF Level 5', 'Ghost Writing', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Oni'),\n-    Ghost('Phantom',\n-          ('EMF Level 5', 'Freezing Temperatures', 'Ghost Orb'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Phantom'),\n-    Ghost('Poltergeist',\n-          ('Fingerprints', 'Ghost Orb', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Poltergeist'),\n-    Ghost('Revenant',\n-          ('EMF Level 5', 'Fingerprints', 'Ghost Writing'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Revenant'),\n-    Ghost('Shade',\n-          ('EMF Level 5', 'Ghost Orb', 'Ghost Writing'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Shade'),\n-    Ghost('Spirit',\n-          ('Fingerprints', 'Ghost Writing', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Spirit'),\n-    Ghost('Wraith',\n-          ('Fingerprints', 'Freezing Temperatures', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Wraith'),\n-    Ghost('Yurei',\n-          ('Freezing Temperatures', 'Ghost Orb', 'Ghost Writing'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Yurei')\n-]\n-EVIDENCES = [\n-    'EMF Level 5', 'Freezing Temperatures', 'Fingerprints',\n-    'Ghost Orb', 'Ghost Writing', 'Spirit Box'\n-]\n-\n-\n-def phasmophobia_match_ghost_evidence(evidences):\n-    possible_ghosts = GHOST_EVIDENCE\n-\n-    for e in evidences:\n-        new_ghosts = []\n-\n-        for g in possible_ghosts:\n-            if e.lower() in [gev.lower() for gev in g.evidences]:\n-                new_ghosts.append(g)\n-\n-        possible_ghosts = new_ghosts\n-\n-        if len(possible_ghosts) == 0:\n-            return possible_ghosts\n-\n-    return possible_ghosts\n-\n-\n-# unturned commands\n-class UnturnedItem:\n-    __slots__ = ('id', 'name', 'rarity', 'url', 'dimensions', 'recipe_data')\n-\n-    def __init__(self, id_, name, rarity, url, dimensions, recipe_data):\n-        self.id = id_\n-        self.name = name\n-        self.rarity = rarity\n-        self.url = url\n-        self.dimensions = dimensions\n-        self.recipe_data = recipe_data\n-\n-    def __repr__(self):\n-        return '{}({!r}, {!r})'.format(\n-            self.__class__.__name__,\n-            self.id,\n-            self.name\n-        )\n-\n-\n-class UnturnedDatabase:\n-    UNTURNED_ITEM_IDS_PATH = 'data\/unturned_item_ids.csv'\n-    UNTURNED_ITEM_RECIPES_PATH = 'data\/unturned_recipes.json'\n-\n-    def __init__(self, items):\n-        self.items = items\n-\n-    @classmethod\n-    def _get_items_from_files(cls):\n-        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:\n-            recipes = json.load(f)\n-\n-        items = {}\n-        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:\n-            reader = csv.reader(f)\n-            header = next(reader)\n-            for id_, name, rarity, url in reader:\n-                rec = recipes.get(id_)\n-                dimensions = rec['dimensions'] if rec else None\n-                recipe_data = (\n-                    {'primitive': rec['primitive'],\n-                     'recipes': rec['recipes']}\n-                    if rec else None\n-                )\n-                id_ = int(id_)\n-                items[id_] = UnturnedItem(\n-                    id_, name, rarity, url, dimensions, recipe_data)\n-\n-        return items\n-\n-    @classmethod\n-    async def _get_items_from_files_nonblocking(cls):\n-        executor = ThreadPoolExecutor()\n-        loop = asyncio.get_running_loop()\n-\n-        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:\n-            recipes = json.loads(await loop.run_in_executor(executor, f.read))\n-\n-        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:\n-            raw_lines = await loop.run_in_executor(executor, f.readlines)\n-\n-        items = {}\n-        reader = csv.reader(raw_lines)\n-        next(reader)  # skip header\n-\n-        for ID, name, rarity, url in reader:\n-            rec = recipes.get(ID)\n-            dimensions = rec['dimensions'] if rec else None\n-            recipe_data = (\n-                {'primitive': rec['primitive'],\n-                 'recipes': rec['recipes']}\n-                if rec else None\n-            )\n-\n-            ID = int(ID)\n-            items[ID] = UnturnedItem(ID, name, rarity, url,\n-                                     dimensions, recipe_data)\n-\n-        return items\n-\n-    def reload_items(self):\n-        \"\"\"Regenerate self.items from the data files.\"\"\"\n-        self.items = self._get_items_from_files()\n-\n-    async def reload_items_nonblocking(self):\n-        \"\"\"Regenerate self.items from the data files.\n-        Uses a thread pool to read files.\"\"\"\n-        self.items = await self._get_items_from_files_nonblocking()\n-\n-    def unturned_get_item(self, search):\n-        \"\"\"Search for an item from UNTURNED_ITEM_IDS either by name or ID.\n-\n-        Returns:\n-            List[UnturnedItem]: multiple matches were found.\n-            None: no matches were found.\n-            UnturnedItem: the search term matches one item.\n-\n-        \"\"\"\n-        def get_item_by_name(name):\n-            result = discord.utils.get(self.items.values(), name=name)\n-            if result is None:\n-                raise ValueError(f'Could not find an item with that name.')\n-            return result\n-\n-        # Search by ID\n-        try:\n-            item_id = int(search)\n-        except ValueError:\n-            pass\n-        else:\n-            return self.items.get(item_id)\n-\n-        # Search by name\n-        result = utils.fuzzy_match_word(\n-            search, tuple(entry.name for entry in self.items.values()),\n-            return_possible=True\n-        )\n-\n-        if isinstance(result, str):\n-            return get_item_by_name(result)\n-        elif isinstance(result, collections.abc.Iterable):\n-            return [get_item_by_name(name) for name in result]\n-        elif result is None:\n-            return\n-\n-    @classmethod\n-    def from_files(cls):\n-        return cls(cls._get_items_from_files())\n+# upsidedown text command\n+# sources: https:\/\/www.upsidedowntext.com\/unicode\n+#          https:\/\/text-symbols.com\/upside-down\/\n+UPSIDEDOWN_MAPPING = {\n+    'a': '\u0250', 'b': 'q', 'c': '\u0254', 'd': 'p', 'e': '\u01dd',\n+    'f': '\u025f', 'g': '\u0183', 'h': '\u0265', 'i': '\u1d09', 'j': '\u027e',\n+    'k': '\u029e', 'l': 'l', 'm': '\u026f', 'n': 'u', 'o': 'o',\n+    'p': 'd', 'q': 'b', 'r': '\u0279', 's': 's', 't': '\u0287',\n+    'u': 'n', 'v': '\u028c', 'w': '\u028d', 'x': 'x', 'y': '\u028e',\n+    'z': 'z', 'A': '\u2200', 'B': '\ua4ed', 'C': '\u0186', 'D': '\u15e1',\n+    'E': '\u018e', 'F': '\u2132', 'G': '\u05e4', 'H': 'H', 'I': 'I',\n+    'J': '\u148b', 'K': '\ua4d8', 'L': '\u2142', 'M': 'W', 'N': 'N',\n+    'O': 'O', 'P': '\u0500', 'Q': '\ua779', 'R': '\ua4e4', 'S': 'S',\n+    'T': '\ua4d5', 'U': '\u2229', 'V': '\u0245', 'W': 'M', 'X': 'X',\n+    'Y': '\u2144', 'Z': 'Z', '0': '0', '1': '\u21c2', '2': '\u218a',\n+    '3': '\u0190', '4': '\u07e4', '5': '\u03db', '6': '9', '7': '\ud835\ude13',\n+    '8': '9', '9': '6', '\"': ',,', \"'\": ',', '`': ',',\n+    '(': ')', ')': '(', '[': ']', ']': '[', '{': '}',\n+    '}': '{', '<': '>', '>': '<', '&': '\u214b', '_': '\u203e',\n+    ',': '`', '.': '\u02d9', '!': '\u00a1', '?': '\u00bf'\n+}\n \n \n # dmtest\/test command\n@@ -283,12 +96,12 @@ def generate_test_message():\n \n \n class Undefined(commands.Cog):\n+    \"\"\"Uncategorized commands.\"\"\"\n     qualified_name = 'Undefined'\n-    description = 'Uncategorized commands.'\n \n     def __init__(self, bot):\n         self.bot = bot\n-        self.unturneddb = UnturnedDatabase.from_files()\n+        self.guilddb = GuildDatabase\n \n \n \n@@ -388,604 +201,65 @@ async def client_goodday(self, ctx):\n         await asyncio.sleep(3)\n         # Print goodday message\n         if hour >= CLIENT_GOODDAY_VARS['evening'] \\\n-           or hour <= CLIENT_GOODDAY_VARS['night']: await ctx.send(\n-            CLIENT_GOODDAY_VARS['nightmessage'])\n-        elif hour <= CLIENT_GOODDAY_VARS['morning']: await ctx.send(\n-            CLIENT_GOODDAY_VARS['morningmessage'])\n-        elif hour <= CLIENT_GOODDAY_VARS['afternoon']: await ctx.send(\n-            CLIENT_GOODDAY_VARS['afternoonmessage'])\n-        elif hour <= CLIENT_GOODDAY_VARS['evening']: await ctx.send(\n-            CLIENT_GOODDAY_VARS['eveningmessage'])\n-\n-\n-\n-\n-\n-    @commands.group(name='phasmophobia', invoke_without_command=True)\n-    async def client_phasmophobia(self, ctx):\n-        \"\"\"Commands related to the game Phasmophobia.\"\"\"\n-\n-\n-    @client_phasmophobia.command(name='evidence')\n-    @commands.cooldown(3, 10, commands.BucketType.user)\n-    async def client_phasmophobia_ghost_evidence(self, ctx, *, evidences):\n-        \"\"\"Determine the ghost(s) based on evidence.\n-Example usage:\n-    <command> emf level 5, fingerprints, freezing temp\n-Available evidences:\n-EMF Level 5\n-Freezing Temperatures\n-Fingerprints\n-Ghost Orb\n-Ghost Writing\n-Spirit Box\"\"\"\n-        def show_evidence(evidences, has_corrected):\n-            if not has_corrected:\n-                return ''\n-            return f\" ({', '.join(evidences)})\"\n-\n-        evidences = [s.strip() for s in evidences.split(',') if s.strip()]\n-\n-        # Fuzzy match the evidence\n-        corrected_evidence = False\n-        for i, e in enumerate(evidences):\n-            match = utils.fuzzy_match_word(e, EVIDENCES)\n-            if not match:\n-                return await ctx.send(f'Unknown evidence: \"{e}\"')\n-            elif match == e:\n-                continue\n-            evidences[i] = match\n-            corrected_evidence = True\n-\n-        # Determine ghosts\n-        ghosts = phasmophobia_match_ghost_evidence(evidences)\n-\n-        title = None\n-        embed = None\n-        if not ghosts:\n-            title = 'No ghosts match the given evidence{}.'.format(\n-                show_evidence(evidences, corrected_evidence)\n-            )\n-        elif len(ghosts) == 1:\n-            title = 'One ghost matches the given evidence{}:'.format(\n-                show_evidence(evidences, corrected_evidence)\n-            )\n-\n-            g = ghosts[0]\n-            embed = discord.Embed(\n-                description='[{}]({})'.format(g.name, g.url),\n-                color=utils.get_bot_color()\n-            )\n-        else:\n-            title = '{} ghosts match the given evidence{}:'.format(\n-                inflector.number_to_words(\n-                    len(ghosts), threshold=10).capitalize(),\n-                show_evidence(evidences, corrected_evidence)\n-            )\n+           or hour <= CLIENT_GOODDAY_VARS['night']:\n+            await ctx.send(CLIENT_GOODDAY_VARS['nightmessage'])\n+        elif hour <= CLIENT_GOODDAY_VARS['morning']:\n+            await ctx.send(CLIENT_GOODDAY_VARS['morningmessage'])\n+        elif hour <= CLIENT_GOODDAY_VARS['afternoon']:\n+            await ctx.send(CLIENT_GOODDAY_VARS['afternoonmessage'])\n+        elif hour <= CLIENT_GOODDAY_VARS['evening']:\n+            await ctx.send(CLIENT_GOODDAY_VARS['eveningmessage'])\n \n-            embed = discord.Embed(\n-                description='\\n'.join([\n-                    '[{}]({}) ({})'.format(\n-                        g.name, g.url, ', '.join(g.evidences))\n-                    for g in ghosts\n-                ]),\n-                color=utils.get_bot_color()\n-            )\n-\n-        await ctx.send(title, embed=embed)\n-\n-\n-\n-\n-\n-    @commands.command(name='test')\n-    @commands.cooldown(2, 30, commands.BucketType.user)\n-    async def client_test(self, ctx):\n-        await ctx.send(generate_test_message())\n \n \n \n \n+    @commands.command(name='leave')\n+    @commands.has_permissions(manage_guild=True)\n+    @commands.guild_only()\n+    @commands.cooldown(2, 60, commands.BucketType.guild)\n+    async def client_leave(self, ctx):\n+        \"\"\"Ask the bot to leave.\n \n-    @commands.group(name='unturned', invoke_without_command=True)\n-    async def client_unturned(self, ctx):\n-        \"\"\"Commands related to the game Unturned.\"\"\"\n+This will remove data about your server but not any associated user\n+information such as notes or game scores.\"\"\"\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n \n+        confirmed = await prompt.confirm('Are you sure you want me to leave?')\n \n-    @staticmethod\n-    def unturned_could_not_find_item(search):\n-        \"\"\"Create a message for when an item search\n-        does not return anything.\"\"\"\n-        try:\n-            int(search)\n-        except ValueError:\n-            return 'Could not find an item with that name.'\n+        if confirmed:\n+            await prompt.update('Goodbye world!', prompt.emoji_no.color)\n+            await ctx.guild.leave()\n+            # TODO: remove user information after some time\n+            await self.guilddb.remove_guild(ctx.guild.id)\n         else:\n-            return 'Could not find an item with that ID.'\n+            await prompt.update('Thanks for keeping me along!',\n+                                prompt.emoji_yes.color)\n \n \n-    @staticmethod\n-    def unturned_get_rarity_color(rarity):\n-        \"\"\"Return the color for a given item rarity.\n \n-        Args:\n-            UnturnedItem\n \n-        Returns:\n-            int\n \n-        \"\"\"\n-        return ( 0x777777 if rarity == 'Common'\n-            else 0x71BA51 if rarity == 'Uncommon'\n-            else 0x3D8EB9 if rarity == 'Rare'\n-            else 0x8870FF if rarity == 'Epic'\n-            else 0xD33257 if rarity == 'Legendary'\n-            else 0x637C63\n-        )\n-\n-\n-    @staticmethod\n-    def unturned_multiple_matches(results, *, threshold=5):\n-        \"\"\"Create a message and embed showing multiple matches.\n-\n-        Args:\n-            List[UnturnedItem]\n-\n-        Returns:\n-            Tuple[str, discord.Embed]\n-\n-        \"\"\"\n-        # List the first five possible matches\n-        amount = len(results)\n-        results = results[:threshold]\n-\n-        description = '\\n'.join([entry.name for entry in results])\n-        if amount > threshold:\n-            description += '\\n...'\n-\n-        embed = discord.Embed(\n-            color=utils.get_bot_color(),\n-            description=description\n-        )\n-\n-        content = '{} items were matched:'.format(\n-            inflector.number_to_words(amount, threshold=10).capitalize()\n-        )\n-\n-        return content, embed\n-\n-\n-    @client_unturned.command(name='item', aliases=['i'])\n-    @commands.cooldown(3, 10, commands.BucketType.user)\n-    async def client_unturned_item(self, ctx, *, item):\n-        \"\"\"Search for an Unturned item by ID or name.\n-Information was pre-scraped from https:\/\/unturneditems.com\/.\n-Up to date as of 3.20.15.0.\"\"\"\n-        def item_embed(entry):\n-            id_, name, rarity, url, dimensions, recipe_data = (\n-                entry.id, entry.name, entry.rarity, entry.url,\n-                entry.dimensions, entry.recipe_data\n-            )\n-\n-            description = (\n-                f'[**{name}**]({url})\\n'\n-                f'ID: {id_}\\n'\n-                f'Rarity: {rarity}\\n'\n-            )\n-\n-            if dimensions is not None:\n-                description += f'Dimensions: {dimensions[0]}x{dimensions[1]}\\n'\n-\n-            if recipe_data is not None:\n-                # List every recipe\n-                recipes_str = []\n-                for recipe in recipe_data['recipes']:\n-                    amount, items_raw, skills = (\n-                        recipe['amount'], recipe['recipe'], recipe['skills']\n-                    )\n-                    # Distinguish between consumed and required items\n-                    items_consumed, items_required = [], []\n-                    for raw_id, quantity in items_raw:\n-                        item = self.unturneddb.unturned_get_item(raw_id)\n-                        if quantity == 0:\n-                            items_required.append(item.name)\n-                        else:\n-                            items_consumed.append((item, quantity))\n-\n-                    rec_str = ''\n-                    first = True\n-                    # List consumed items\n-                    for item in items_consumed:\n-                        rec_str += '> '\n-                        if not first:\n-                            rec_str += '+ '\n-                        rec_str += f'{item[1]} x {item[0].name}\\n'\n-                        first = False\n-\n-                    # Show product\n-                    rec_str += f'> = {amount} x {name}\\n'\n-\n-                    if items_required:\n-                        rec_str += '> (Uses {})\\n'.format(\n-                            inflector.join(items_required)\n-                        )\n-\n-                    requires = skills.copy()\n-\n-                    # Include other conditions in requirements\n-                    if recipe['requires_heat']:\n-                        requires.append('Heat')\n-\n-                    if requires:\n-                        rec_str += f'> (Requires {inflector.join(requires)})\\n'\n-\n-                    recipes_str.append(rec_str)\n-\n-                recipes_str = '> OR:\\n'.join(recipes_str)\n-\n-                if recipes_str:\n-                    description += f'Recipes:\\n{recipes_str}\\n'\n-\n-            return discord.Embed(\n-                color=self.unturned_get_rarity_color(rarity),\n-                description=description\n-            ).set_thumbnail(\n-                url=f'https:\/\/unturneditems.com\/media\/{id_}.png'\n-            )\n-\n-        result = self.unturneddb.unturned_get_item(item)\n-\n-        if isinstance(result, list):\n-            content, embed = self.unturned_multiple_matches(result)\n-\n-            await ctx.send(content, embed=embed)\n-        elif result is None:\n-            await ctx.send(self.unturned_could_not_find_item(item))\n-        else:\n-            await ctx.send(embed=item_embed(result))\n-\n-\n-    @client_unturned.command(name='craft', aliases=['c'])\n-    @commands.cooldown(3, 10, commands.BucketType.user)\n-    async def client_unturned_craft(\n-            self, ctx, amount: typing.Optional[int] = 1, *, item):\n-        \"\"\"Get the materials required to craft an item.\n-\n-amount: The number of the given item to craft. This parameter must be included.\n-item: The name or ID of the item to look up.\n-\n-Note: There are only a few items with recipe data since I have to manually enter this myself.\"\"\"\n-        def get_recipe_requirements(item, amount=None, frontier=None):\n-            \"\"\"Return the requirements for a recipe.\n-\n-            Dictionary returned is structured like so:\n-                'tree': [\n-                    [item, amount,\n-                     [...],\n-                     {'other': True, ...}],\n-                    ...\n-                ],\n-                # stores the tree structure that is being pathed\n-                'remainders': [[item, amount], ...],\n-                # any excess materials\n-                'skills': {'Crafting': 3, ...},\n-                # all skills that are needed\n-                'other': {'requires_heat': True, ...},\n-                # other information about the recipe\n-                'total_raw': [[item, amount], ...],\n-                # contains all the raw materials required\n-\n-            The design is to navigate through the item's recipe tree,\n-            recursively acquiring materials from the recipe of each\n-            material in the item.\n-            This lends to several considerations:\n-                1. How are skills acquired?\n-                2. What if a recipe produces extra items?\n-                3. What if an item is marked as primitive?\n-                4. What if a recipe is cyclic? (as in a recipe of an item\n-                    has that same item in its recipe)\n-\n-            1. Skills are stored in a dictionary where the key is the name\n-            of the skill, and the value being the level.\n-            When a recursive call returns a dictionary, it is merged\n-            into the current stack's skills, keeping the maximum level of each\n-            skill.\n-\n-            2. Extra items are stored as a list containing pairs of items\n-            and their amount. The items are initially non-unique but at\n-            the top level, the amounts are aggregated together by mapping\n-            the item ID to their amount, and then converted back into a list.\n-\n-            3. Primitive items like Metal Scrap means that their recipes\n-            should not be recursed into. [...]\n-\n-            [incomplete documentation]\n-            \"\"\"\n-            def create_output(*, tree=None, remainders=None,\n-                              skills=None, total_raw=None,\n-                              other=None):\n-                d = {\n-                    'tree': tree if tree is not None else [],\n-                    'remainders': remainders if remainders is not None else [],\n-                    'skills': skills if skills is not None else {},\n-                    'other': other if other is not None else {}\n-                }\n-                if total_raw is not None:\n-                    d['total_raw'] = total_raw\n-                return d\n-\n-            def parse_skills(skills):\n-                skill_dict = {}\n-                for s in skills:\n-                    skill_name, level = s.split()\n-                    skill_dict[skill_name] = int(level)\n-                return skill_dict\n-\n-            def get_total_raw(tree):\n-                \"Recursively summarize the raw materials of a tree.\"\n-                materials = {}\n-                if not tree:\n-                    return materials\n-                for item, amount, branch, _other in tree:\n-                    if branch:\n-                        # Item is broken down into more materials\n-                        branch_raw = get_total_raw(branch)\n-                        if branch_raw:\n-                            for item_id, item_and_amount in branch_raw.items():\n-                                item, amount = item_and_amount\n-                                materials.setdefault(item_id, [item, 0])\n-                                materials[item_id][1] += amount\n-                    else:\n-                        # Leaf node; must be primitive\/uncraftable; store it\n-                        materials.setdefault(item.id, [item, 0])\n-                        materials[item.id][1] += amount\n-                return materials\n-\n-            top_level = frontier is None\n-\n-            if (    item.recipe_data is None\n-                    or not item.recipe_data['recipes']\n-                    or item.recipe_data['primitive'] and not top_level):\n-                # No recipes\/primitive item\n-                if top_level:\n-                    return create_output(total_raw=[[item, amount]])\n-                return create_output()\n-\n-            recipe = item.recipe_data['recipes'][0]\n-            # TODO: using only the first recipe will add limitations to\n-            # how it figures out the requirements (ignoring other recipes\n-            # that could work) but since most items only have one recipe,\n-            # this generally won't have any issue\n-\n-            materials, amount_produced = recipe['recipe'], recipe['amount']\n-\n-            other = {'requires_heat': recipe.get('requires_heat', False)}\n-\n-            if amount is None:\n-                amount = recipe['amount']\n-\n-            if amount == 0:\n-                # Item is only required but not consumed\n-                if top_level:\n-                    raise ValueError('amount cannot be 0')\n-                return create_output()\n-\n-            if top_level:\n-                frontier = set()\n-\n-            if item.id in frontier:\n-                # Item already seen; do not recurse into its recipes\n-                return create_output(tree=[[item, amount, [], other]])\n-\n-            frontier.add(item.id)\n-\n-            tree = []\n-            remainders = []\n-\n-            # Parse skills into their name and level\n-            skills = parse_skills(recipe['skills'])\n-\n-            if amount % amount_produced != 0:\n-                # Recipe will result in excess produce\n-                remainders.append((item, amount % amount_produced))\n-\n-            # Recursively get requirements of recipe materials\n-            for mat_id, mat_amount in materials:\n-                mat = self.unturneddb.unturned_get_item(mat_id)\n-                if mat is None:\n-                    raise ValueError(\n-                        f'unknown item in recipe: {mat_id}')\n-\n-                branched_frontier = frontier.copy()\n-\n-                amount_to_craft = math.ceil(\n-                    amount \/ amount_produced) * mat_amount\n-\n-                mat_req = get_recipe_requirements(\n-                    mat,\n-                    amount_to_craft,\n-                    branched_frontier\n-                )\n-\n-                tree.append(\n-                    [mat, amount_to_craft, mat_req['tree'], mat_req['other']]\n-                )\n-\n-                remainders.extend(mat_req['remainders'])\n-\n-                # Collect skills\n-                for name, level in mat_req['skills'].items():\n-                    skills.setdefault(name, 0)\n-                    skills[name] = max(skills[name], level)\n-\n-                # Collect other booleans if top level\n-                if top_level:\n-                    for k, v in mat_req['other'].items():\n-                        other.setdefault(k, False)\n-                        other[k] = max(other[k], v)\n-\n-            # collect items\n-            if top_level:\n-                total_raw = list(get_total_raw(tree).values())\n-\n-                collected_remainders = {}\n-                for mat, mat_amount in remainders:\n-                    collected_remainders.setdefault(mat.id, [mat, 0])\n-                    collected_remainders[mat.id][1] += mat_amount\n-                collected_remainders = list(collected_remainders.values())\n-\n-                return create_output(\n-                    tree=tree,\n-                    remainders=collected_remainders,\n-                    skills=skills,\n-                    total_raw=total_raw,\n-                    other=other\n-                )\n-            return create_output(\n-                tree=tree,\n-                remainders=remainders,\n-                skills=skills,\n-                other=other\n-            )\n-\n-        def humanize_other(other):\n-            \"\"\"Convert a dictionary of other booleans from\n-            get_recipe_requirements into a list of human-readable strings.\"\"\"\n-            d = {'requires_heat': 'Heat'}\n-            s = []\n-            for k, v in other.items():\n-                if v:\n-                    s.append(d[k])\n-            return s\n-\n-        def tree_str(tree, level=1):\n-            \"\"\"Example tree produced by get_recipe_requirements:\n-\n-            Wire:\n-            [\n-             Metal Bar, 3, [[Metal Scrap, 2, []],\n-                            [Blowtorch, 0]],\n-             Blowtorch, 0, []\n-            ]\n-\n-            \"\"\"\n-            if not tree:\n-                return tree\n-\n-            s = []\n-            indent = '> ' * level\n-\n-            for item, amount, branch, other in tree:\n-                if amount:\n-                    # Skip unconsumed items, those are handled separately\n-                    s.append(f'{indent}{amount} x {item.name}')\n-\n-                for other_str in humanize_other(other):\n-                    s.append(f\"{'> ' * (level + 1)}{other_str}\")\n-\n-                s.extend(tree_str(branch, level=level + 1))\n-\n-            return s\n-\n-        result = self.unturneddb.unturned_get_item(item)\n-\n-        if isinstance(result, list):\n-            content, embed = self.unturned_multiple_matches(result)\n-\n-            return await ctx.send(content, embed=embed)\n-        elif result is None:\n-            return await ctx.send(self.unturned_could_not_find_item(item))\n-\n-        if result.recipe_data is None:\n-            return await ctx.send(\n-                \"Unfortunately I don't have the recipe data for this.\")\n-\n-        if amount <= 0:\n-            return await ctx.send(\n-                embed=discord.Embed(\n-                    color=utils.get_bot_color(),\n-                    description=(\n-                        f'{result.name}\\n'\n-                        f'ID: {result.id}\\n'\n-                        'Total raw:\\n**nothing**'\n-                    )\n-                ).set_thumbnail(\n-                    url=f'https:\/\/unturneditems.com\/media\/{result.id}.png'\n-                )\n-            )\n-\n-        requirements = get_recipe_requirements(result, amount)\n-        tree = requirements['tree']\n-        remainders = requirements['remainders']\n-        skills = requirements['skills']\n-        total_raw = requirements['total_raw']\n-\n-        # Fix inflector sometimes not properly pluralizing the name\n-        # if it starts with a capital letter\n-        is_name_capitalized = result.name[0].isupper()\n-        plural_name = result.name\n-        plural_name = plural_name[0].lower() + plural_name[1:]\n-        plural_name = inflector.plural(plural_name, amount)\n-        if is_name_capitalized:\n-            plural_name = plural_name[0].upper() + plural_name[1:]\n-\n-        description = (\n-            f'{amount} {plural_name}\\n'\n-            f'ID: {result.id}\\n'\n-        )\n+    @commands.command(name='test')\n+    @commands.cooldown(2, 30, commands.BucketType.user)\n+    async def client_test(self, ctx):\n+        await ctx.send(generate_test_message())\n \n-        if tree:\n-            description += \"Recipe tree:\\n{}\\n\".format(\n-                '\\n'.join(tree_str(tree))\n-            )\n-        # Else item is primitive\/has no recipes\n \n-        items_consumed, items_required = [], []\n-        for item, quantity in total_raw:\n-            if quantity == 0:\n-                items_required.append(item.name)\n-            else:\n-                items_consumed.append((item, quantity))\n-\n-        description += 'Total raw:\\n'\n-\n-        # List consumed and required items\n-        for item, amount in items_consumed:\n-            description += f'> {amount} x {item.name}\\n'\n-        for item in items_required:\n-            description += f'> {item}\\n'\n-\n-        # List excess material\n-        if remainders:\n-            description += 'Remainders:\\n'\n-            for item, amount in remainders:\n-                description += f'> {amount} x {item.name}\\n'\n-\n-        # Parse skill dict back into list of strings\n-        # and add other conditions here\n-        requires = [f'{k} {v}' for k, v in skills.items()]\n-        requires.extend(humanize_other(requirements['other']))\n-\n-        if requires:\n-            description += f'Requires {inflector.join(requires)}\\n'\n-\n-        embed = discord.Embed(\n-            color=self.unturned_get_rarity_color(result.rarity),\n-            description=description\n-        ).set_thumbnail(\n-            url=f'https:\/\/unturneditems.com\/media\/{result.id}.png'\n-        )\n \n-        await ctx.send(embed=embed)\n \n \n-    @client_unturned.command(name='reload')\n-    @checks.is_bot_admin()\n-    @commands.cooldown(1, 20, commands.BucketType.default)\n-    async def client_unturned_reload_db(self, ctx):\n-        \"\"\"Reload the item database.\"\"\"\n-        await self.unturneddb.reload_items_nonblocking()\n-        await ctx.send('Item database reloaded.')\n+    @commands.command(name='rotate', aliases=('flip', 'upsidedown'))\n+    @commands.cooldown(4, 10, commands.BucketType.user)\n+    async def client_upsidedowntext(self, ctx, *, message):\n+        \"\"\"Rotate your text 180 degrees using unicode letters.\n+Supports a-z 0-9 ,.!?\"'` ()[]{}<> and &_.\n+Any other characters will be passed through.\"\"\"\n+        s = []\n+        for c in reversed(message):\n+            s.append(UPSIDEDOWN_MAPPING.get(c, c))\n+        s = ''.join(s)\n+        await ctx.send(s)\n \n \n \ndiff --git a\/bot\/commands\/uptime.py b\/bot\/commands\/uptime.py\nnew file mode 100644\nindex 0000000..0afb46a\n--- \/dev\/null\n+++ b\/bot\/commands\/uptime.py\n@@ -0,0 +1,98 @@\n+import datetime\n+\n+from discord.ext import commands\n+\n+\n+class Uptime(commands.Cog):\n+    \"\"\"Track the uptime of the bot.\"\"\"\n+    qualified_name = 'Uptime'\n+\n+    UPTIME_ALLOWED_DOWNTIME = 10\n+\n+    def __init__(self, bot):\n+        self.bot = bot\n+\n+\n+\n+\n+\n+    def update_last_connect(self, *, force_update=False):\n+        if not self.bot.uptime_is_online:\n+            # Calculate downtime\n+            now = datetime.datetime.now().astimezone()\n+            diff = now - self.bot.uptime_last_disconnect\n+\n+            # Only update last connect if downtime was long,\n+            # else record the downtime\n+            if force_update or (diff.total_seconds()\n+                                > self.UPTIME_ALLOWED_DOWNTIME):\n+                self.bot.uptime_last_connect = now\n+                self.bot.uptime_last_connect_adjusted = now\n+                self.bot.uptime_total_downtime = datetime.timedelta()\n+\n+                if force_update:\n+                    print('Uptime: forced uptime reset')\n+                else:\n+                    print(\n+                        'Uptime: Downtime of {} seconds exceeded allowed '\n+                        'downtime ({} seconds); resetting uptime'.format(\n+                            diff.total_seconds(),\n+                            self.UPTIME_ALLOWED_DOWNTIME\n+                        )\n+                    )\n+            else:\n+                self.bot.uptime_total_downtime += diff\n+                self.bot.uptime_last_connect_adjusted = (\n+                    self.bot.uptime_last_connect\n+                    + self.bot.uptime_total_downtime\n+                )\n+                print('Uptime:', 'Recorded downtime of',\n+                      diff.total_seconds(), 'seconds')\n+\n+            self.bot.uptime_is_online = True\n+\n+\n+    @commands.Cog.listener()\n+    async def on_command_completion(self, ctx):\n+        \"\"\"Used for tracking processed commands.\"\"\"\n+        self.bot.info_processed_commands[ctx.command.qualified_name] += 1\n+\n+    @commands.Cog.listener()\n+    async def on_connect(self):\n+        \"\"\"Used for uptime tracking.\n+\n+        Triggered when waking up from computer sleep.\n+        As there is no way to tell how long the computer went for sleep,\n+        this forces the last_connect time to be updated.\n+\n+        \"\"\"\n+        self.update_last_connect(force_update=True)\n+\n+\n+    @commands.Cog.listener()\n+    async def on_disconnect(self):\n+        \"\"\"Used for uptime tracking.\"\"\"\n+        self.bot.uptime_last_disconnect = datetime.datetime.now().astimezone()\n+        self.bot.uptime_is_online = False\n+\n+\n+    @commands.Cog.listener()\n+    async def on_resumed(self):\n+        \"\"\"Used for uptime tracking.\n+\n+        Triggered when reconnecting from an internet loss.\n+\n+        \"\"\"\n+        self.update_last_connect()\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+def setup(bot):\n+    bot.add_cog(Uptime(bot))\ndiff --git a\/bot\/converters.py b\/bot\/converters.py\nnew file mode 100644\nindex 0000000..aeefe89\n--- \/dev\/null\n+++ b\/bot\/converters.py\n@@ -0,0 +1,101 @@\n+import discord\n+from discord.ext import commands\n+import emoji\n+\n+__all__ = ('CommandConverter', 'UnicodeEmojiConverter')\n+\n+\n+class CommandConverter(commands.Converter):\n+    \"\"\"Converts to a Command.\n+\n+    Args:\n+        run_checks (bool): If True, checks if the bot can run with the\n+            given command and context. Otherwise returns the command\n+            regardless if the user is able to run it.\n+\n+    \"\"\"\n+    def __init__(self, run_checks=True):\n+        self.run_checks = True\n+\n+    async def can_run(self, ctx, command, *, call_once=False):\n+        \"\"\"A variant of Command.can_run() that doesn't check if\n+        the command is disabled.\"\"\"\n+        if not self.run_checks:\n+            return True\n+\n+        original = ctx.command\n+        ctx.command = command\n+\n+        try:\n+            if not await ctx.bot.can_run(ctx, call_once=call_once):\n+                return False\n+\n+            cog = command.cog\n+            if cog is not None:\n+                local_check = commands.Cog._get_overridden_method(cog.cog_check)\n+                if local_check is not None:\n+                    ret = await discord.utils.maybe_coroutine(local_check, ctx)\n+                    if not ret:\n+                        return False\n+\n+            predicates = command.checks\n+            if not predicates:\n+                # since we have no checks, then we just return True.\n+                return True\n+\n+            return await discord.utils.async_all(\n+                predicate(ctx) for predicate in predicates)\n+        finally:\n+            ctx.command = original\n+\n+    async def convert(self, ctx, argument):\n+        \"\"\"\n+        Args:\n+            ctx (commands.Context)\n+            argument (str)\n+\n+        Returns:\n+            commands.Command\n+\n+        Raises:\n+            BadArgument\n+\n+        \"\"\"\n+        c = ctx.bot.get_command(argument)\n+        try:\n+            if c is None:\n+                raise commands.BadArgument(\n+                    f'Could not convert \"{argument}\" into a command.')\n+            elif not await self.can_run(ctx, c):\n+                raise commands.BadArgument(f'The user cannot use \"{argument}\".')\n+        except commands.CheckFailure as e:\n+            raise commands.BadArgument(str(e)) from e\n+        return c\n+\n+\n+class UnicodeEmojiConverter(commands.Converter):\n+    \"\"\"Converts to a string unicode emoji.\n+\n+    This merely just uses a lookup table to verify if the argument\n+    is a unicode emoji; no other conversion is done.\n+\n+    Args:\n+        partial_emoji (bool): If True, returns a discord.PartialEmoji\n+            instead of just the emoji as a string.\n+\n+    Returns:\n+        PartialEmoji\n+        str\n+\n+    \"\"\"\n+    def __init__(self, partial_emoji=False):\n+        self.partial_emoji = partial_emoji\n+\n+    async def convert(self, ctx, argument):\n+        if argument in emoji.UNICODE_EMOJI_ALIAS_ENGLISH:\n+            if self.partial_emoji:\n+                return discord.PartialEmoji(name=argument)\n+            return argument\n+\n+        raise commands.BadArgument(\n+            f'Could not convert \"{argument}\" into a unicode emoji.')\ndiff --git a\/bot\/database\/__init__.py b\/bot\/database\/__init__.py\nindex c016c84..88277c0 100644\n--- a\/bot\/database\/__init__.py\n+++ b\/bot\/database\/__init__.py\n@@ -1,7 +1,13 @@\n from .database import Database\n-from .dbsetup import DATABASE_IRISH, DATABASE_USERS, get_prefix, setup\n-from .irishdatabase import IrishDatabase\n-from .notedatabase import NoteDatabase\n-from .prefixdatabase import PrefixDatabase\n-from .reminderdatabase import ReminderDatabase\n-from .userdatabase import UserDatabase\n+from .dbsetup import (\n+    DATABASE_IRISH, DATABASE_USERS,\n+    GameDatabase, GuildDatabase, IrishDatabase, NoteDatabase, PrefixDatabase,\n+    ReminderDatabase, UserDatabase, get_prefix, setup\n+)\n+from . import gamedatabase\n+from . import guilddatabase\n+from . import irishdatabase\n+from . import notedatabase\n+from . import prefixdatabase\n+from . import reminderdatabase\n+from . import userdatabase\ndiff --git a\/bot\/database\/database.py b\/bot\/database\/database.py\nindex b022795..65f174b 100644\n--- a\/bot\/database\/database.py\n+++ b\/bot\/database\/database.py\n@@ -3,38 +3,27 @@\n import aiosqlite\n \n \n-class Singleton(type):\n-    # https:\/\/stackoverflow.com\/q\/6760685\n-    _instances = {}\n-    def __call__(cls, *args, **kwargs):\n-        if cls not in cls._instances:\n-            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n-        return cls._instances[cls]\n-\n-\n-class Database(metaclass=Singleton):\n+class Database:\n     \"\"\"Provide a higher-level interface to a database.\n \n     Methods:\n         add_row(table, row)\n         delete_rows(table, *, where)\n-        get_rows(table, *columns, where=None, as_Row=True)\n+        get_one(table, *, where, as_row=True)\n+        get_rows(table, *, where, as_row=True)\n         update_rows(table, row, *, where)\n+        yield_rows(table, *, where)\n \n         vacuum()\n \n         row_to_dict(Row)\n \n     \"\"\"\n-    # FIXME: using Singleton is probably a dumb way of making sure\n-    # caches of subclasses are preserved across instantiations;\n-    # why not just have dbsetup create all the instances?\n     __slots__ = ['path', 'last_change']\n \n     PRAGMAS = 'PRAGMA foreign_keys = 1'\n \n     def __init__(self, path):\n-        \"\"\"Create a Database with a path to a given sqlite db file.\"\"\"\n         self.path = path\n         self.set_last_change(datetime.datetime.now(), table=None)\n \n@@ -111,10 +100,10 @@ async def delete_rows(self, table: str, *, where: str, pop=False):\n         if pop:\n             return rows\n \n-    async def get_one(self, table: str, *, where: str = '1', as_Row=True):\n+    async def get_one(self, table: str, *, where: str = '1', as_row=True):\n         \"\"\"Get one row from a table.\n \n-        If as_Row, rows will be returned as aiosqlite.Row objects.\n+        If as_row, rows will be returned as aiosqlite.Row objects.\n         Otherwise, rows are returned as tuples.\n \n         Returns:\n@@ -125,7 +114,7 @@ async def get_one(self, table: str, *, where: str = '1', as_Row=True):\n         \"\"\"\n         async with aiosqlite.connect(self.path) as db:\n             await db.execute(self.PRAGMAS)\n-            if as_Row:\n+            if as_row:\n                 db.row_factory = aiosqlite.Row\n \n             c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n@@ -135,7 +124,7 @@ async def get_one(self, table: str, *, where: str = '1', as_Row=True):\n \n         return row\n \n-    async def get_rows(self, table: str, *, where: str = '1', as_Row=True):\n+    async def get_rows(self, table: str, *, where: str = '1', as_row=True):\n         \"\"\"Get a list of rows from a table.\n \n         Args:\n@@ -143,7 +132,7 @@ async def get_rows(self, table: str, *, where: str = '1', as_Row=True):\n             where (Optional[str]):\n                 An optional parameter specifying a condition.\n                 By default, returns all rows in the table.\n-            as_Row (bool):\n+            as_row (bool):\n                 If True, rows will be returned as aiosqlite.Row objects.\n                 Otherwise, rows are returned as tuples.\n \n@@ -154,7 +143,7 @@ async def get_rows(self, table: str, *, where: str = '1', as_Row=True):\n         \"\"\"\n         async with aiosqlite.connect(self.path) as db:\n             await db.execute(self.PRAGMAS)\n-            if as_Row:\n+            if as_row:\n                 db.row_factory = aiosqlite.Row\n \n             c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n@@ -164,7 +153,7 @@ async def get_rows(self, table: str, *, where: str = '1', as_Row=True):\n         return rows\n \n     async def update_rows(self, table: str, row: dict, *, where: str):\n-        \"Update one or more rows in a table.\"\n+        \"\"\"Update one or more rows in a table.\"\"\"\n \n         def create_placeholders(row: dict) -> (str, list):\n             \"\"\"Create the placeholders for setting keys.\n@@ -191,8 +180,13 @@ def create_placeholders(row: dict) -> (str, list):\n \n         self.set_last_change(datetime.datetime.now(), table)\n \n+    async def vacuum(self):\n+        \"\"\"Vacuum the database.\"\"\"\n+        async with aiosqlite.connect(self.path) as db:\n+            await db.execute('VACUUM')\n+\n     async def yield_rows(\n-            self, table: str, *, where: str = '1', as_Row=True):\n+            self, table: str, *, where: str = '1', as_row=True):\n         \"\"\"Yield a list of rows from a table.\n \n         Args:\n@@ -200,7 +194,7 @@ async def yield_rows(\n             where (Optional[str]):\n                 An optional parameter specifying a condition.\n                 By default, yields all rows in the table.\n-            as_Row (bool):\n+            as_row (bool):\n                 If True, rows will be returned as aiosqlite.Row objects.\n                 Otherwise, rows are returned as tuples.\n \n@@ -211,7 +205,7 @@ async def yield_rows(\n         \"\"\"\n         async with aiosqlite.connect(self.path) as db:\n             await db.execute(self.PRAGMAS)\n-            if as_Row:\n+            if as_row:\n                 db.row_factory = aiosqlite.Row\n \n             c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n@@ -221,9 +215,9 @@ async def yield_rows(\n             await c.close()\n \n     @staticmethod\n-    def row_to_dict(Row):\n-        \"Convert an aiosqlite.Row into a dictionary.\"\n+    def row_to_dict(row):\n+        \"\"\"Convert an aiosqlite.Row into a dictionary.\"\"\"\n         d = {}\n-        for k, v in zip(Row.keys(), Row):\n+        for k, v in zip(row.keys(), row):\n             d[k] = v\n         return d\ndiff --git a\/bot\/database\/dbsetup.py b\/bot\/database\/dbsetup.py\nindex 434050b..10a4d7f 100644\n--- a\/bot\/database\/dbsetup.py\n+++ b\/bot\/database\/dbsetup.py\n@@ -5,6 +5,7 @@\n from discord.ext import commands\n \n from . import database\n+from . import gamedatabase\n from . import guilddatabase\n from . import irishdatabase\n from . import notedatabase\n@@ -12,10 +13,19 @@\n from . import reminderdatabase\n from . import userdatabase\n from bot import settings\n+from bot import utils\n \n DATABASE_USERS = '.\/data\/userdb.db'\n DATABASE_IRISH = '.\/data\/irishdb.db'\n \n+GameDatabase = gamedatabase.GameDatabase(DATABASE_USERS)\n+GuildDatabase = guilddatabase.GuildDatabase(DATABASE_USERS)\n+IrishDatabase = irishdatabase.IrishDatabase(DATABASE_IRISH)\n+NoteDatabase = notedatabase.NoteDatabase(DATABASE_USERS)\n+PrefixDatabase = prefixdatabase.PrefixDatabase(DATABASE_USERS)\n+ReminderDatabase = reminderdatabase.ReminderDatabase(DATABASE_USERS)\n+UserDatabase = userdatabase.UserDatabase(DATABASE_USERS)\n+\n \n def get_prefix():\n     \"\"\"Return a function for getting the bot prefix.\n@@ -27,12 +37,10 @@ def get_prefix():\n         commands.Bot(command_prefix=get_prefix())\n \n     \"\"\"\n-    db = prefixdatabase.PrefixDatabase(DATABASE_USERS)\n-\n     async def inner(bot, message):\n         guild = message.guild\n \n-        # If in DMs, get default prefix or use prefix-less invokation\n+        # If in DMs, get default prefix\n         if guild is None:\n             return commands.when_mentioned_or(\n                 settings.get_setting('default_prefix')\n@@ -40,8 +48,8 @@ async def inner(bot, message):\n \n         # Else, fetch guild prefix\n         guild_id = guild.id\n-        await db.add_prefix(guild_id, add_guild=True)\n-        prefix = await db.get_prefix(guild_id)\n+        await PrefixDatabase.add_prefix(guild_id, add_guild=True)\n+        prefix = await PrefixDatabase.get_prefix(guild_id)\n \n         if prefix is not None:\n             return commands.when_mentioned_or(prefix)(bot, message)\n@@ -52,20 +60,24 @@ async def inner(bot, message):\n \n def setup_database_users(connection):\n     \"Setup the tables for the Users database.\"\n-    userdatabase.setup(connection)\n-    notedatabase.setup(connection)\n-    reminderdatabase.setup(connection)\n-    print('Verified user database')\n-    guilddatabase.setup(connection)\n-    prefixdatabase.setup(connection)\n-    print('Verified guild database')\n+    with utils.update_text('Verifying user database',\n+                           'Verified user database'):\n+        userdatabase.setup(connection)\n+        notedatabase.setup(connection)\n+        reminderdatabase.setup(connection)\n+        gamedatabase.setup(connection)\n+    with utils.update_text('Verifying guild database',\n+                           'Verified guild database'):\n+        guilddatabase.setup(connection)\n+        prefixdatabase.setup(connection)\n \n \n-def setup_database_guild_specific():\n-    irishdatabase.setup(sqlite3.connect(DATABASE_IRISH))\n-    print('Verified guild-specific databases')\n+def setup_database_guild_specific(connection):\n+    with utils.update_text('Verifying guild-specific databases',\n+                           'Verified guild-specific databases'):\n+        irishdatabase.setup(connection)\n \n \n def setup():\n     setup_database_users(sqlite3.connect(DATABASE_USERS))\n-    setup_database_guild_specific()\n+    setup_database_guild_specific(sqlite3.connect(DATABASE_IRISH))\ndiff --git a\/bot\/database\/gamedatabase.py b\/bot\/database\/gamedatabase.py\nnew file mode 100644\nindex 0000000..97872b2\n--- \/dev\/null\n+++ b\/bot\/database\/gamedatabase.py\n@@ -0,0 +1,85 @@\n+\"\"\"A database for the Irish Squad server.\n+\n+This stores its own users.\n+\"\"\"\n+from . import database as db\n+from . import userdatabase as user_db\n+\n+TABLE_BLACKJACK = \"\"\"\n+CREATE TABLE IF NOT EXISTS Blackjack (\n+    user_id INTEGER NOT NULL,\n+    played INTEGER NOT NULL DEFAULT 0,\n+    wins INTEGER NOT NULL DEFAULT 0,\n+    losses INTEGER NOT NULL DEFAULT 0,\n+    blackjacks INTEGER NOT NULL DEFAULT 0,\n+    FOREIGN KEY(user_id) REFERENCES Users(id)\n+        ON DELETE CASCADE\n+)\"\"\"\n+\n+\n+class BlackjackDatabase(user_db.UserDatabase):\n+    \"\"\"Provide an interface to the Blackjack table.\"\"\"\n+\n+    async def change(\n+            self, column: str, user_id: int, number: int, *, add_user=True):\n+        \"\"\"Add or subtract X from a column.\n+\n+        Note that this has no restraints.\n+\n+        Args:\n+            column (str): The name of the column to change.\n+            user_id (int)\n+            number (int): The number of losses to add. Can be negative.\n+            add_user (bool)\n+\n+        \"\"\"\n+        user_id = int(user_id)\n+\n+        row = await self.get_blackjack_row(user_id, add_user=add_user)\n+\n+        return await self.update_rows(\n+            'Blackjack',\n+            {column: row[column] + number},\n+            where=f'user_id={user_id}'\n+        )\n+\n+    async def delete_data(self, user_id: int):\n+        \"\"\"Delete a user's blackjack data.\"\"\"\n+        user_id = int(user_id)\n+        await self.delete_rows('Blackjack', where=f'user_id={user_id}')\n+\n+    async def get_blackjack_row(self, user_id: int, *, add_user=True):\n+        user_id = int(user_id)\n+\n+        if add_user:\n+            await self.add_user(user_id)\n+\n+        row = await self.get_one('Blackjack', where=f'user_id={user_id}')\n+        if row is None:\n+            if not await self.has_user(user_id):\n+                raise ValueError(\n+                    f'User {user_id!r} does not exist in the database')\n+            else:\n+                await self.add_row('Blackjack', {'user_id': user_id})\n+                row = await self.get_one('Blackjack', where=f'user_id={user_id}')\n+        return row\n+\n+\n+class GameDatabase(db.Database):\n+    \"\"\"Provide an interface to the various tables available.\"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.blackjack = BlackjackDatabase(*args, **kwargs)\n+\n+    async def delete_data(self, user_id: int):\n+        \"\"\"Delete a user's data for all games.\"\"\"\n+        user_id = int(user_id)\n+\n+        await self.blackjack.delete_data(user_id)\n+\n+\n+def setup(connection):\n+    \"Set up the game tables with a sqlite3 connection.\"\n+    with connection as conn:\n+        conn.execute(TABLE_BLACKJACK)\ndiff --git a\/bot\/database\/guilddatabase.py b\/bot\/database\/guilddatabase.py\nindex 75dcaba..6d3f0b0 100644\n--- a\/bot\/database\/guilddatabase.py\n+++ b\/bot\/database\/guilddatabase.py\n@@ -15,10 +15,12 @@\n \n \n class GuildDatabase(db.Database):\n-    \"Provide an interface to a database with a guilds table.\"\n+    \"\"\"Provide an interface to a database with a guilds table.\"\"\"\n \n     async def has_guild(self, guild_id: int):\n-        \"Test if a guild_id exists in the database.\"\n+        \"\"\"Test if a guild_id exists in the database.\"\"\"\n+        guild_id = int(guild_id)\n+\n         return await self.get_guild(guild_id) is not None\n \n     async def add_guild(self, guild_id: int):\n@@ -27,10 +29,12 @@ async def add_guild(self, guild_id: int):\n         guild_id is not escaped.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         if not await self.has_guild(guild_id):\n             return await self.add_row('Guilds', {'id': guild_id})\n \n-    async def get_guild(self, guild_id: int, *, as_Row=True):\n+    async def get_guild(self, guild_id: int, *, as_row=True):\n         \"\"\"Get a guild record from the database.\n \n         If the guild is not found, returns None.\n@@ -38,8 +42,10 @@ async def get_guild(self, guild_id: int, *, as_Row=True):\n         guild_id is not escaped.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         return await self.get_one(\n-            'Guilds', where=f'id={guild_id}', as_Row=as_Row)\n+            'Guilds', where=f'id={guild_id}', as_row=as_row)\n \n     async def remove_guild(self, guild_id: int):\n         \"\"\"Remove a guild from the database.\n@@ -47,10 +53,12 @@ async def remove_guild(self, guild_id: int):\n         guild_id is not escaped.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         await self.delete_rows('Guilds', where=f'id={guild_id}')\n \n \n def setup(connection):\n-    \"Set up the guilds table for a sqlite3 connection.\"\n+    \"\"\"Set up the guilds table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n         conn.execute(TABLE_GUILDS)\ndiff --git a\/bot\/database\/irishdatabase.py b\/bot\/database\/irishdatabase.py\nindex da29b27..995d225 100644\n--- a\/bot\/database\/irishdatabase.py\n+++ b\/bot\/database\/irishdatabase.py\n@@ -2,7 +2,6 @@\n \n This stores its own users.\n \"\"\"\n-from . import database as db\n from . import userdatabase as user_db\n \n TABLE_USERS = \"\"\"\n@@ -17,13 +16,14 @@\n     user_id INTEGER NOT NULL,\n     amount INTEGER NOT NULL DEFAULT 0,\n     FOREIGN KEY(user_id) REFERENCES Users(id)\n+        ON DELETE CASCADE\n )\"\"\"\n \n \n class ChargeDatabase(user_db.UserDatabase):\n     \"\"\"Provide an interface to the Charges table.\"\"\"\n \n-    async def add_charges(self, user_id: int, amount: int, *, add_user=False):\n+    async def add_charges(self, user_id: int, amount: int, *, add_user=True):\n         \"\"\"Add charges for a user.\n \n         Args:\n@@ -34,10 +34,9 @@ async def add_charges(self, user_id: int, amount: int, *, add_user=False):\n                 Otherwise, the user_id foreign key can be violated.\n \n         \"\"\"\n-        if add_user:\n-            await self.add_user(user_id)\n+        user_id = int(user_id)\n \n-        charges = await self.get_charges(user_id)\n+        charges = await self.get_charges(user_id, add_user=add_user)\n \n         return await self.update_rows(\n             'Charges',\n@@ -47,7 +46,9 @@ async def add_charges(self, user_id: int, amount: int, *, add_user=False):\n \n     async def delete_charges(self, user_id: int):\n         \"\"\"Delete a user's charges entry.\"\"\"\n-        await self.delete_rows('Charges', where=f'note_id={note_id}')\n+        user_id = int(user_id)\n+\n+        await self.delete_rows('Charges', where=f'user_id={user_id}')\n \n     async def subtract_charges(self, user_id: int, amount: int,\n                                *, add_user=False):\n@@ -63,10 +64,9 @@ async def subtract_charges(self, user_id: int, amount: int,\n                 Otherwise, the user_id foreign key can be violated.\n \n         \"\"\"\n-        if add_user:\n-            await self.add_user(user_id)\n+        user_id = int(user_id)\n \n-        charges = await self.get_charges(user_id)\n+        charges = await self.get_charges(user_id, add_user=add_user)\n \n         return await self.update_rows(\n             'Charges',\n@@ -78,12 +78,14 @@ async def get_charges(self, user_id: int, add_user=True):\n         \"\"\"Get the number of charges a user has.\n \n         Args:\n-            user_id (int): The id of the user to get notes from.\n+            user_id (int): The id of the user to get their number of charges.\n             add_user (bool):\n                 If True, automatically adds the user_id to the Users table.\n                 Otherwise, the user_id foreign key can be violated.\n \n         \"\"\"\n+        user_id = int(user_id)\n+\n         if add_user:\n             await self.add_user(user_id)\n \n@@ -103,7 +105,7 @@ class IrishDatabase(ChargeDatabase):\n \n \n def setup(connection):\n-    \"Set up the Users table for a sqlite3 connection.\"\n+    \"\"\"Set up the Irish Squad tables with a sqlite3 connection.\"\"\"\n     with connection as conn:\n         conn.execute(TABLE_USERS)\n         conn.execute(TABLE_CHARGES)\ndiff --git a\/bot\/database\/notedatabase.py b\/bot\/database\/notedatabase.py\nindex 538de08..fa3d1f1 100644\n--- a\/bot\/database\/notedatabase.py\n+++ b\/bot\/database\/notedatabase.py\n@@ -3,6 +3,8 @@\n Table dependencies:\n     Users\n \"\"\"\n+import datetime\n+\n from . import userdatabase as user_db\n \n TABLE_NOTES = \"\"\"\n@@ -12,15 +14,16 @@\n     time_of_entry TIMESTAMP,\n     content TEXT NOT NULL,\n     FOREIGN KEY(user_id) REFERENCES Users(id)\n+        ON DELETE CASCADE\n );\n \"\"\"\n \n \n class NoteDatabase(user_db.UserDatabase):\n-    \"Provide an interface to a UserDatabase with a Notes table.\"\n+    \"\"\"Provide an interface to a UserDatabase with a Notes table.\"\"\"\n \n-    async def add_note(self, user_id: int, time_of_entry,\n-            content: str, *, add_user=False):\n+    async def add_note(self, user_id: int, time_of_entry: datetime.datetime,\n+                       content: str, *, add_user=True):\n         \"\"\"Add a note to the Notes table.\n \n         Args:\n@@ -32,6 +35,9 @@ async def add_note(self, user_id: int, time_of_entry,\n                 Otherwise, the user_id foreign key can be violated.\n \n         \"\"\"\n+        user_id = int(user_id)\n+        content = str(content)\n+\n         if add_user:\n             await self.add_user(user_id)\n \n@@ -55,33 +61,32 @@ async def delete_note_by_note_id(self, note_id: int, pop=False):\n             List[aiosqlite.Row]: A list of deleted entries if pop is True.\n \n         \"\"\"\n+        note_id = int(note_id)\n         return await self.delete_rows(\n             'Notes', where=f'note_id={note_id}', pop=pop)\n \n     async def delete_note_by_user_id(self, user_id: int, entry_num: int):\n-        \"\"\"Delete a note from the Notes table by user_id and entry_num.\n-\n-        user_id is not escaped.\n+        \"\"\"Delete a note from the Notes table by user_id and entry_num.\"\"\"\n+        user_id = int(user_id)\n \n-        \"\"\"\n-        notes = self.get_notes(user_id)\n+        notes = await self.get_notes(user_id)\n         note_id = notes[entry_num]['note_id']\n         await self.delete_rows('Notes', where=f'note_id={note_id}')\n \n-    async def get_notes(self, user_id: int, *, as_Row=True):\n+    async def get_notes(self, user_id: int, *, as_row=True):\n         \"\"\"Get one or more notes for a user.\n \n-        user_id is not escaped.\n-\n         Args:\n             user_id (int): The id of the user to get notes from.\n+            as_row (bool)\n \n         \"\"\"\n+        user_id = int(user_id)\n         return await self.get_rows(\n-            'Notes', where=f'user_id={user_id}', as_Row=as_Row)\n+            'Notes', where=f'user_id={user_id}', as_row=as_row)\n \n \n def setup(connection):\n-    \"Set up the Notes table for a sqlite3 connection.\"\n+    \"\"\"Set up the Notes table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n         conn.execute(TABLE_NOTES)\ndiff --git a\/bot\/database\/prefixdatabase.py b\/bot\/database\/prefixdatabase.py\nindex 33d128f..5b2ce1b 100644\n--- a\/bot\/database\/prefixdatabase.py\n+++ b\/bot\/database\/prefixdatabase.py\n@@ -11,12 +11,13 @@\n     guild_id INTEGER NOT NULL,\n     prefix TEXT NOT NULL,\n     FOREIGN KEY(guild_id) REFERENCES Guilds(id)\n+        ON DELETE CASCADE\n );\n \"\"\"\n \n \n class PrefixDatabase(guild_db.GuildDatabase):\n-    \"Provide an interface to a GuildDatabase with a Prefixes table.\"\n+    \"\"\"Provide an interface to a GuildDatabase with a Prefixes table.\"\"\"\n \n     __slots__ = ['prefix_cache']\n \n@@ -27,7 +28,9 @@ def __init__(self, *args, **kwargs):\n         self.prefix_cache = {}\n \n     async def has_prefix(self, guild_id: int):\n-        \"Test if a prefix for a guild exists in the database.\"\n+        \"\"\"Test if a prefix for a guild exists in the database.\"\"\"\n+        guild_id = int(guild_id)\n+\n         return await self.get_prefix(guild_id) is not None\n \n     async def add_prefix(\n@@ -45,6 +48,8 @@ async def add_prefix(\n                 Otherwise, the guild_id foreign key can be violated.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         if prefix is None:\n             prefix = settings.get_setting('default_prefix')\n \n@@ -79,6 +84,8 @@ async def delete_prefix(self, guild_id: int, pop=False):\n             List[aiosqlite.Row]: A list of deleted entries if pop is True.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         prefixes = await self.delete_rows(\n             'Prefixes', where=f'guild_id={guild_id}', pop=pop)\n \n@@ -86,7 +93,7 @@ async def delete_prefix(self, guild_id: int, pop=False):\n \n         return prefixes\n \n-    async def get_prefix(self, guild_id: int, *, as_Row=True):\n+    async def get_prefix(self, guild_id: int, *, as_row=True):\n         \"\"\"Get the prefix for a guild.\n \n         guild_id is not escaped.\n@@ -95,12 +102,14 @@ async def get_prefix(self, guild_id: int, *, as_Row=True):\n             str\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         prefix = self.prefix_cache.get(guild_id)\n         if prefix is not None:\n             return prefix\n \n         query = await self.get_one(\n-            'Prefixes', where=f'guild_id={guild_id}', as_Row=as_Row)\n+            'Prefixes', where=f'guild_id={guild_id}', as_row=as_row)\n \n         if query is None:\n             return\n@@ -110,15 +119,15 @@ async def get_prefix(self, guild_id: int, *, as_Row=True):\n         self.prefix_cache[guild_id] = prefix\n \n         return prefix\n-        \n \n-    async def update_prefix(\n-            self, guild_id: int, prefix: str):\n+    async def update_prefix(self, guild_id: int, prefix: str):\n         \"\"\"Update a prefix for a guild.\n \n         The prefix is constrained by PREFIX_SIZE_LIMIT.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         if len(prefix) > self.PREFIX_SIZE_LIMIT:\n             raise ValueError(\n                 f'Prefix cannot be over {self.PREFIX_SIZE_LIMIT:,} '\n@@ -132,6 +141,6 @@ async def update_prefix(\n \n \n def setup(connection):\n-    \"Set up the prefixes table for a sqlite3 connection.\"\n+    \"\"\"Set up the prefixes table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n         conn.execute(TABLE_PREFIXES)\ndiff --git a\/bot\/database\/reminderdatabase.py b\/bot\/database\/reminderdatabase.py\nindex 24f59d3..eeace3c 100644\n--- a\/bot\/database\/reminderdatabase.py\n+++ b\/bot\/database\/reminderdatabase.py\n@@ -12,15 +12,16 @@\n     due TIMESTAMP,\n     content TEXT NOT NULL,\n     FOREIGN KEY(user_id) REFERENCES Users(id)\n+        ON DELETE CASCADE\n );\n \"\"\"\n \n \n class ReminderDatabase(user_db.UserDatabase):\n-    \"Provide an interface to a UserDatabase with a Reminders table.\"\n+    \"\"\"Provide an interface to a UserDatabase with a Reminders table.\"\"\"\n \n     async def add_reminder(self, user_id: int, due,\n-            content: str, *, add_user=False):\n+                           content: str, *, add_user=True):\n         \"\"\"Add a reminder to the Reminders table.\n \n         Args:\n@@ -32,6 +33,8 @@ async def add_reminder(self, user_id: int, due,\n                 Otherwise, the user_id foreign key can be violated.\n \n         \"\"\"\n+        user_id = int(user_id)\n+\n         if add_user:\n             await self.add_user(user_id)\n \n@@ -56,6 +59,8 @@ async def delete_reminder_by_id(\n             List[aiosqlite.Row]: A list of deleted entries if pop is True.\n \n         \"\"\"\n+        reminder_id = int(reminder_id)\n+\n         return await self.delete_rows(\n             'Reminders', where=f'reminder_id={reminder_id}', pop=pop)\n \n@@ -66,25 +71,30 @@ async def delete_reminder_by_user_id(\n         user_id is not escaped.\n \n         \"\"\"\n-        reminders = self.get_reminders(user_id)\n+        user_id = int(user_id)\n+\n+        reminders = await self.get_reminders(user_id)\n         reminder_id = reminders[entry_num]['reminder_id']\n         await self.delete_rows(\n             'Reminders', where=f'reminder_id={reminder_id}')\n \n-    async def get_reminders(self, user_id: int, *, as_Row=True):\n+    async def get_reminders(self, user_id: int, *, as_row=True):\n         \"\"\"Get one or more reminders for a user.\n \n         user_id is not escaped.\n \n         Args:\n             user_id (int): The id of the user to get reminders from.\n+            as_row (bool)\n \n         \"\"\"\n+        user_id = int(user_id)\n+\n         return await self.get_rows(\n-            'Reminders', where=f'user_id={user_id}', as_Row=as_Row)\n+            'Reminders', where=f'user_id={user_id}', as_row=as_row)\n \n \n def setup(connection):\n-    \"Set up the Reminders table for a sqlite3 connection.\"\n+    \"\"\"Set up the Reminders table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n         conn.execute(TABLE_REMINDERS)\ndiff --git a\/bot\/database\/userdatabase.py b\/bot\/database\/userdatabase.py\nindex 8bb2d11..bc28699 100644\n--- a\/bot\/database\/userdatabase.py\n+++ b\/bot\/database\/userdatabase.py\n@@ -15,42 +15,40 @@\n \n \n class UserDatabase(db.Database):\n-    \"Provide an interface to a database with a Users table.\"\n+    \"\"\"Provide an interface to a database with a Users table.\"\"\"\n \n     async def has_user(self, user_id: int):\n-        \"Test if a user_id exists in the database.\"\n+        \"\"\"Test if a user_id exists in the database.\"\"\"\n+        user_id = int(user_id)\n+\n         return await self.get_user(user_id) is not None\n \n     async def add_user(self, user_id: int):\n-        \"\"\"Add a user to the database if the user does not exist.\n-\n-        user_id is not escaped.\n+        \"\"\"Add a user to the database if the user does not exist.\"\"\"\n+        user_id = int(user_id)\n \n-        \"\"\"\n         if not await self.has_user(user_id):\n             return await self.add_row('Users', {'id': user_id})\n \n-    async def get_user(self, user_id: int, *, as_Row=True):\n+    async def get_user(self, user_id: int, *, as_row=True):\n         \"\"\"Get a user record from the database.\n \n         If the user is not found, returns None.\n \n-        user_id is not escaped.\n-\n         \"\"\"\n+        user_id = int(user_id)\n+\n         return await self.get_one(\n-            'Users', where=f'id={user_id}', as_Row=as_Row)\n+            'Users', where=f'id={user_id}', as_row=as_row)\n \n     async def remove_user(self, user_id: int):\n-        \"\"\"Remove a user from the database.\n-\n-        user_id is not escaped.\n+        \"\"\"Remove a user from the database.\"\"\"\n+        user_id = int(user_id)\n \n-        \"\"\"\n         await self.delete_rows('Users', where=f'id={user_id}')\n \n \n def setup(connection):\n-    \"Set up the Users table for a sqlite3 connection.\"\n+    \"\"\"Set up the Users table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n         conn.execute(TABLE_USERS)\ndiff --git a\/bot\/eventhandlers.py b\/bot\/eventhandlers.py\nindex 7b7c7b4..89efaf2 100644\n--- a\/bot\/eventhandlers.py\n+++ b\/bot\/eventhandlers.py\n@@ -18,9 +18,11 @@\n     'on_resumed',\n ]\n \n-COMMAND_ERROR_IGNORE_EXCEPTIONS = (\n-    commands.CommandNotFound, commands.CheckFailure)\n+COMMAND_ERROR_IGNORE_EXCEPTIONS = (commands.CommandNotFound,)\n # Prevents errors from being processed in this set of exceptions\n+COMMAND_ERROR_IGNORE_EXCEPTIONS_AFTER = (commands.CheckFailure,)\n+# Same as above except this prevents raising the error if the exception\n+# was not matched. Helpful for ignoring superclasses of exceptions.\n COMMAND_ERROR_CALLBACK_BLACKLIST = frozenset()\n # Prevents errors from being processed in this set of commands,\n # specified by the callback name of the command ('client_execute', etc.)\n@@ -139,6 +141,8 @@ def __init__(self, errors_to_cooldowns):\n         }\n \n     def check_user(self, ctx, error):\n+        \"\"\"Check if a user is ratelimited for an exception.\n+        Returns True if they are ratelimited.\"\"\"\n         mapping = self.error_mapping.get(type(error))\n         if mapping is None:\n             return False\n@@ -156,6 +160,7 @@ def check_user(self, ctx, error):\n     commands.MissingPermissions: None,\n     commands.MissingRole: None,\n     commands.NoPrivateMessage: None,\n+    commands.PrivateMessageOnly: None,\n     commands.NotOwner: None,\n     commands.UserInputError: (5, 30, commands.BucketType.user),\n     checks.UserOnCooldown: (1, 5, commands.BucketType.user),\n@@ -212,15 +217,13 @@ async def on_resumed():\n \n \n async def on_command_error(ctx, error):\n+    error_unpacked = getattr(error, 'original', error)\n     if isinstance(error, COMMAND_ERROR_IGNORE_EXCEPTIONS):\n         return\n     elif ctx.command.callback.__name__ in COMMAND_ERROR_CALLBACK_BLACKLIST:\n         # command is to be ignored\n         return\n-    elif (isinstance(error, ERRORS_TO_LIMIT)\n-          or hasattr(error, 'original')\n-          and isinstance(error.original, ERRORS_TO_LIMIT)):\n-        error_unpacked = getattr(error, 'original', error)\n+    elif isinstance(error_unpacked, ERRORS_TO_LIMIT):\n         if command_error_limiter.check_user(ctx, error_unpacked):\n             # user is rate limited on receiving a particular error\n             return\n@@ -336,7 +339,8 @@ def missing_x_to_run(x, missing_perms):\n         # error.param is instance of inspect.Parameter\n         await ctx.send('Expected a boolean answer for parameter '\n                        f'\"{error.param.name}\".\\n'\n-                       f'Usage: `{get_command_signature()}`')\n+                       f'Usage: `{get_command_signature()}`',\n+                       delete_after=10)\n     elif isinstance(error, commands.BotMissingPermissions):\n         await ctx.send(\n             'I am {}'.format(\n@@ -344,62 +348,66 @@ def missing_x_to_run(x, missing_perms):\n                     'permission',\n                     convert_perms_to_english(error.missing_perms)\n                 )\n-            )\n+            ),\n+            delete_after=10\n         )\n     elif isinstance(error, (\n             commands.BotMissingRole,\n             commands.BotMissingAnyRole)):\n-        await ctx.send('I am {}'.format(\n-            missing_x_to_run('role', convert_roles(error.missing_perms))\n-        ))\n-    # elif isinstance(error, commands.CommandNotFound):\n-    #     Command \"x\" is not found\n-    #     await ctx.send('Unknown command: {}'.format(\n-    #         error.args[0].split()[1].strip('\"')\n-    #     ))\n-    #     pass\n+        await ctx.send(\n+            'I am {}'.format(\n+                missing_x_to_run('role', convert_roles(error.missing_roles))\n+            ),\n+            delete_after=10\n+        )\n     elif isinstance(error, commands.ChannelNotFound):\n-        await ctx.send('I cannot find the given channel.')\n+        await ctx.send('I cannot find the given channel '\n+                       f'\"{error.argument}\".', delete_after=8)\n     elif isinstance(error, commands.ChannelNotReadable):\n-        await ctx.send('I cannot read messages in the channel.')\n+        await ctx.send('I cannot read messages in the channel '\n+                       f'{error.argument.mention}.', delete_after=8)\n     elif isinstance(error, commands.CommandOnCooldown):\n         embed = discord.Embed(\n             color=utils.get_bot_color()\n         ).set_footer(\n             text=inflector.inflect(\n                 'You can retry in {0} plural(\"second\", {0}).'.format(\n-                    float(f'{error.retry_after:.2g}')\n+                    round(error.retry_after * 10) \/ 10\n                 )\n             ),\n-            icon_url=str(ctx.author.avatar_url)\n+            icon_url=ctx.author.avatar_url\n         )\n \n         embed.description = get_cooldown_description(ctx, error)\n \n-        await ctx.send(embed=embed)\n+        await ctx.send(embed=embed, delete_after=min(error.retry_after, 20))\n     elif isinstance(error, commands.DisabledCommand):\n-        await ctx.send('This command is currently disabled.')\n+        await ctx.send('This command is currently disabled.', delete_after=10)\n     elif isinstance(error, commands.EmojiNotFound):\n-        await ctx.send(f'I cannot find the given emoji \"{error.argument}\"')\n+        await ctx.send(f'I cannot find the given emoji \"{error.argument}\"',\n+                       delete_after=10)\n     elif isinstance(error, commands.ExpectedClosingQuoteError):\n-        await ctx.send('Expected a closing quotation mark.')\n+        await ctx.send('Expected a closing quotation mark.',\n+                       delete_after=10)\n     elif isinstance(error, commands.InvalidEndOfQuotedStringError):\n-        await ctx.send('Expected a space after a closing quotation mark.')\n+        await ctx.send('Expected a space after a closing quotation mark.',\n+                       delete_after=10)\n     elif isinstance(error, commands.MaxConcurrencyReached):\n         embed = discord.Embed(\n             color=utils.get_bot_color()\n         ).set_footer(\n             text=get_concurrency_description(ctx, error),\n-            icon_url=str(ctx.author.avatar_url)\n+            icon_url=ctx.author.avatar_url\n         )\n \n         await ctx.send(embed=embed)\n     elif isinstance(error, commands.MessageNotFound):\n-        await ctx.send('I cannot find the given message.')\n+        await ctx.send('I cannot find the given message.', delete_after=10)\n     elif isinstance(error, commands.MissingRequiredArgument):\n         # error.param is instance of inspect.Parameter\n         await ctx.send(f'Missing argument \"{error.param.name}\"\\n'\n-                       f'Usage: `{get_command_signature()}`')\n+                       f'Usage: `{get_command_signature()}`',\n+                       delete_after=10)\n     elif isinstance(error, commands.MissingPermissions):\n         await ctx.send(\n             'You are {}'.format(\n@@ -407,31 +415,39 @@ def missing_x_to_run(x, missing_perms):\n                     'permission',\n                     convert_perms_to_english(error.missing_perms)\n                 )\n-            )\n+            ),\n+            delete_after=10\n         )\n     elif isinstance(error, (commands.MissingRole,\n                             commands.MissingAnyRole)):\n-        await ctx.send('You are {}'.format(\n-            missing_x_to_run('role', convert_roles(error.missing_perms))\n-        ))\n+        await ctx.send(\n+            'You are {}'.format(\n+                missing_x_to_run('role', convert_roles(error.missing_roles))\n+            ),\n+            delete_after=10\n+        )\n     elif isinstance(error, commands.NoPrivateMessage):\n-        await ctx.send('You must be in a server to use this command.')\n+        await ctx.send('You must be in a server to use this command.',\n+                       delete_after=10)\n     elif isinstance(error, (\n             commands.NotOwner, checks.InvalidBotOwner,\n             checks.InvalidBotAdmin)):\n-        # await ctx.send('This command is for the bot owner only.')\n-        await ctx.send(get_denied_message())\n+        await ctx.send(get_denied_message(), delete_after=6)\n     elif isinstance(error, commands.NSFWChannelRequired):\n-        await ctx.send('The given channel must be marked as NSFW.')\n+        await ctx.send('The channel must be marked as NSFW.', delete_after=10)\n+    elif isinstance(error, commands.PrivateMessageOnly):\n+        await ctx.send('You must be in DMs to use this command.',\n+                       delete_after=10)\n     elif isinstance(error, commands.UnexpectedQuoteError):\n-        await ctx.send('Did not expect a quotation mark.')\n+        await ctx.send('Did not expect a quotation mark.', delete_after=10)\n     elif isinstance(error, (commands.UserNotFound,\n                             commands.MemberNotFound)):\n-        await ctx.send('I cannot find the given user.')\n+        await ctx.send('I cannot find the given user.', delete_after=10)\n     elif isinstance(error, commands.UserInputError):\n         # NOTE: This is a superclass of several other errors\n         await ctx.send('Failed to parse your parameters.\\n'\n-                       f'Usage: `{get_command_signature()}`')\n+                       f'Usage: `{get_command_signature()}`',\n+                       delete_after=10)\n     elif isinstance(error, checks.UserOnCooldown):\n         # User has invoked too many commands\n         embed = discord.Embed(\n@@ -439,20 +455,19 @@ def missing_x_to_run(x, missing_perms):\n         ).set_footer(\n             text=inflector.inflect(\n                 'You are using commands too frequently. '\n-                'You can retry in {0:.2g} plural(\"second\", {0}).'.format(\n-                    error.retry_after)\n+                'You can retry in {0} plural(\"second\", {0}).'.format(\n+                    round(error.retry_after * 10) \/ 10)\n             ),\n-            icon_url=str(ctx.author.avatar_url)\n+            icon_url=ctx.author.avatar_url\n         )\n \n-        await ctx.send(embed=embed)\n-    elif (isinstance(error, commands.CommandInvokeError)\n-          and isinstance(error.original, discord.Forbidden)\n-          and error.original.code == 50007):\n+        await ctx.send(embed=embed, delete_after=min(error.retry_after, 20))\n+    elif (isinstance(error_unpacked, discord.Forbidden)\n+          and error_unpacked.code == 50007):\n         # Cannot send messages to this user\n         await ctx.send('I tried DMing you but you have your DMs '\n-                       'disabled for this server.')\n-    else:\n+                       'disabled for this server.', delete_after=10)\n+    elif not isinstance(error, COMMAND_ERROR_IGNORE_EXCEPTIONS_AFTER):\n         raise error\n \n \ndiff --git a\/bot\/settings.py b\/bot\/settings.py\nindex 06b4fc0..77f11dd 100644\n--- a\/bot\/settings.py\n+++ b\/bot\/settings.py\n@@ -182,7 +182,8 @@ def setup():\n         'message_size': 2000,\n         'message_limit': 1,\n         'owner_ids': [153551102443257856, ],\n-        'print_error_mode': 'raise'  # raise, print, None\n+        'print_error_mode': 'raise',  # raise, print, None\n+        'slash_guild_ids': []\n     }\n \n     def generate_settings(filename):\ndiff --git a\/bot\/utils.py b\/bot\/utils.py\nindex 1402e29..6bf073e 100644\n--- a\/bot\/utils.py\n+++ b\/bot\/utils.py\n@@ -1,27 +1,32 @@\n+import contextlib\n import datetime\n import decimal\n import itertools  # rawincount()\n import math\n import pathlib    # exception_message()\n-import string\n import sys        # exception_message()\n import traceback  # exception_message()\n+from typing import List, Iterable, Union, Optional\n \n from dateutil.relativedelta import relativedelta\n import discord\n+from discord.ext.commands.view import StringView\n import inflect\n+import prettify_exceptions\n \n from bot import settings\n from bot.other import discordlogger\n \n inflector = inflect.engine()\n \n+logger = discordlogger.get_logger()\n+\n # Whitelist Digits, Decimal Point, Main Arithmetic,\n # Order of Operations, Function Arithmetic (modulus,),\n # Binary Arithmetic (bitwise NOT, OR, AND, XOR, shifts)\n # Scientific Notation, and Imaginary Part for evaluate command\n-CLIENT_EVALUATE_WHITELIST = set(\n-    string.digits\n+SAFE_EVAL_WHITELIST = frozenset(\n+    '0123456789'\n     + '.'\n     + '*\/+-'\n     + '%'\n@@ -32,11 +37,11 @@\n     + 'j'\n )\n \n-logger = discordlogger.get_logger()\n-\n \n def convert_base(base_in: int, base_out: int, n,\n-        mapping='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n+                 mapping=('0123456789'\n+                          'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n+                          'abcdefghijklmnopqrstuvwxyz-_')):\n     \"\"\"Converts a number to another base.\n     Accepted bases are 2, 36, and all in-between.\n     Base 36 uses 0-9 and a-z (case-insensitive).\n@@ -54,15 +59,13 @@ def convert_base(base_in: int, base_out: int, n,\n     elif min(base_in, base_out) < 2:\n         raise ValueError('Given base is less than 2.')\n \n-    if base_out == 10 and base_in <= 36 \\\n-           and mapping == '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n-        # int() already represents in base 10, use that for optimization\n-        # unless base_in is larger than int()'s maximum base allowed\n-        # or the mapping is different that what int() uses\n-        # (\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n+    mapping_normal = mapping.startswith('0123456789ABCDEFGHJIKLMNOPQRSTUVWXYZ')\n+\n+    if base_out == 10 and base_in <= 36 and mapping_normal:\n+        # use int() for optimization\n         return int(n, base_in)\n \n-    if base_in <= 36 and mapping:\n+    if base_in <= 36 and mapping_normal:\n         n_int = int(n, base_in)\n     else:\n         n_int = 0\n@@ -85,8 +88,9 @@ def datetime_difference(current, prior):\n     return relativedelta(current, prior)\n \n \n-def fuzzy_match_word(s, choices, return_possible=False):\n-    \"\"\"Matches a string with a given evidence by token (case-insensitive).\n+def fuzzy_match_word(s, choices: Iterable[str], return_possible=False) \\\n+        -> Optional[Union[str, List[str]]]:\n+    \"\"\"Matches a string to given choices by token (case-insensitive).\n \n     Choices can be matched even if the given string has tokens out of order:\n         >>> fuzzy_match_word('orb ghost', ['Ghost Orb', 'Ghost Writing'])\n@@ -101,13 +105,14 @@ def fuzzy_match_word(s, choices, return_possible=False):\n             a list of those matches will be returned.\n \n     Returns:\n-        None\n+        None: Returned if there are multiple matches and\n+              `return_possible` is False.\n         str\n-        List[str]:\n-            Returned if `return_possible` and there are multiple matches.\n+        List[str]: Returned if there are multiple matches and\n+                   `return_possible` is True.\n \n     \"\"\"\n-    possible = choices\n+    possible = list(choices) if not isinstance(choices, list) else choices\n     possible_lower = [s.lower() for s in possible]\n \n     # See if the phrase already exists\n@@ -138,6 +143,28 @@ def fuzzy_match_word(s, choices, return_possible=False):\n     return possible if return_possible and possible else None\n \n \n+def parse_var_positional(s):\n+    \"\"\"Parse a string in the same way as done in a command *args.\n+\n+    Returns:\n+        List[str]\n+\n+    Raises:\n+        discord.ext.commands.ExpectedClosingQuoteError\n+        discord.ext.commands.InvalidEndOfQuotedStringError\n+        discord.ext.commands.UnexpectedQuoteError\n+\n+    \"\"\"\n+    view = StringView(s)\n+    words = []\n+    while not view.eof:\n+        view.skip_ws()\n+        w = view.get_quoted_word()\n+        if w != ' ':\n+            words.append(w)\n+    return words\n+\n+\n def timedelta_string(\n         diff,\n         years=True, months=True, weeks=True, days=True,\n@@ -252,6 +279,26 @@ def exception_message(\n     return msg\n \n \n+def exception_message_pretty(\n+        exc_type=None, exc_value=None, exc_traceback=None,\n+        header: str = '', log_handler=logger) -> str:\n+    \"\"\"Create a traceback message using the prettify_exceptions module.\n+    This acts similar to `exception_message`.\"\"\"\n+    if exc_type is None and exc_value is None and exc_traceback is None:\n+        exc_type, exc_value, exc_traceback = sys.exc_info()\n+    elif exc_type is None or exc_value is None or exc_traceback is None:\n+        raise ValueError('An exception type\/value\/traceback was passed '\n+                         'but is missing the other values')\n+\n+    if log_handler is not None:\n+        log_handler.exception('')\n+\n+    return '\\n'.join(\n+        prettify_exceptions.DefaultFormatter().format_exception(\n+            exc_type, exc_value, exc_traceback)\n+    )\n+\n+\n def gcd(a, b='high'):\n     \"\"\"Calculate the Greatest Common Divisor of a and b.\n \n@@ -277,13 +324,13 @@ def gcd(a, b='high'):\n \n \n def get_bot_color():\n-    \"Return the bot's color from settings.\"\n+    \"\"\"Return the bot's color from settings.\"\"\"\n     return int(settings.get_setting('bot_color'), 16)\n \n \n def get_user_color(\n         user, default_color=None):\n-    \"Return a user's role color if they are in a guild, else default_color.\"\n+    \"\"\"Return a user's role color if they are in a guild, else default_color.\"\"\"\n     return (\n         user.color if isinstance(user, discord.Member)\n         else default_color if default_color is not None\n@@ -373,82 +420,141 @@ def rawincount(filename):\n \n def safe_eval(x):\n     \"\"\"Filters a string before evaluating.\n-Uses CLIENT_EVALUATE_WHITELIST as the filter.\"\"\"\n+Uses SAFE_EVAL_WHITELIST as the filter.\"\"\"\n     return num(eval(\n-        ''.join([char for char in x if char in CLIENT_EVALUATE_WHITELIST])\n+        ''.join([char for char in x if char in SAFE_EVAL_WHITELIST])\n     ))\n \n \n def truncate_message(\n-        message, size=2000, size_lines=None, placeholder='[...]'):\n+        message: str, max_size: int = 2000, max_lines: Optional[int] = None,\n+        placeholder: str = '[...]') -> str:\n     \"\"\"Truncate a message to a given amount of characters or lines.\n \n     This should be used when whitespace needs to be retained as\n     `textwrap.shorten` will collapse whitespace.\n \n-    Message is stripped of whitespace.\n+    Message is stripped of whitespace initially, then after cutting the\n+    message to just under max_size, trailing whitespace is stripped.\n+\n+    The placeholder will be prefixed with a newline if the trailing whitespace\n+    that was stripped includes a newline, or if excess lines were removed.\n+    Otherwise it will prefix with a space.\n+\n+    The placeholder will not be prefixed if it would exceed the max_size.\n+        >>> truncate_message('Hello world!', 11, placeholder='[...]')\n+        'Hello [...]'\n+        >>> truncate_message('Hello world!', 10, placeholder='[...]')\n+        'Hello[...]'\n+\n+    If the message is completely wiped and the placeholder exceeds max_size,\n+    an empty string is returned.\n+        >>> truncate_message('Hello world!', 5, placeholder='[...]')\n+        '[...]'\n+        >>> truncate_message('Hello world!', 4, placeholder='[...]')\n+        ''\n+\n+    Args:\n+        message (str): The message to truncate.\n+        max_size (int): The max length the message can be.\n+        max_lines (Optional[int]): The max number of lines\n+            the message can have.\n+        placeholder (str): The placeholder to append if the message\n+            gets truncated.\n+\n+    Returns:\n+        str\n \n     \"\"\"\n-    message = message.strip()\n+    def get_trailing_whitespace(s):\n+        stripped = s.rstrip()\n+        whitespace = s[len(stripped):]\n+        return stripped, whitespace\n+\n+    # Check arguments\n+    if max_size < 0:\n+        raise ValueError(f'Max size cannot be negative ({max_size!r})')\n+    elif max_size == 0:\n+        return ''\n+    if max_lines is not None:\n+        if max_lines < 0:\n+            raise ValueError(f'Max lines cannot be negative ({max_lines!r})')\n+        elif max_lines == 0:\n+            return ''\n \n-    in_code_block = 0\n+    message = message.strip()\n \n+    # Check if the message needs to be truncated\n+    under_size = len(message) <= max_size\n+    if under_size and max_lines is None:\n+        return message\n     lines = message.split('\\n')\n-    chars = 0\n-    for line_i, line in enumerate(lines):\n-        if size_lines is not None and line_i == size_lines:\n-            # Reached maximum lines\n-            break\n+    excess_lines = len(lines) - max_lines if max_lines is not None else 0\n+    if max_lines is not None:\n+        if under_size and excess_lines <= 0:\n+            return message\n+        else:\n+            # Remove excess lines\n+            for _ in range(excess_lines):\n+                lines.pop()\n \n+    in_code_block = 0\n+    placeholder_len = len(placeholder)\n+    length = 0\n+    placeholder_prefix = '\\n' if excess_lines > 0 else ' '\n+    # Find the line that exceeds max_size\n+    for line_i, line in enumerate(lines):\n         in_code_block = (in_code_block + line.count('```')) % 2\n \n-        new_chars = chars + len(line)\n-        if new_chars > size:\n-            # This line exceeds max size; truncate it by word\n-            words = line.split(' ')\n-            last_word = len(words) - 1  # for compensating space split\n-            line_chars = chars\n-\n-            for word_i, word in enumerate(words):\n-                new_line_chars = line_chars + len(word)\n-\n-                if new_line_chars > (\n-                        size - len(placeholder)\n-                        - in_code_block * 3):\n-                    # This word exceeds the max size; truncate to here\n-                    break\n-\n-                if word_i != last_word:\n-                    new_line_chars += 1\n-\n-                line_chars = new_line_chars\n-            else:\n-                raise RuntimeError(f'line {line_i:,} exceeded max size but '\n-                                   'failed to determine where to '\n-                                   'truncate the line')\n-\n-            if word_i == 0:\n-                # Line becomes empty; go back to last line\n-                # and add placeholder\n-                break\n-            else:\n-                # Truncate line and return new message\n-                line = ' '.join(words[:word_i] + [placeholder])\n-                return (\n-                    '\\n'.join(lines[:line_i] + [line])\n-                    + '```' * in_code_block\n-                )\n+        new_length = length + len(line)\n+        # Adjust size to compensate for newlines, length of placeholder,\n+        # and completing the code block if needed\n+        max_size_adjusted = (max_size - line_i - placeholder_len\n+                             - in_code_block * 3)\n+\n+        if new_length > max_size_adjusted:\n+            # This line exceeds max_size_adjusted\n+            placeholder_prefix = ' ' if line else '\\n'\n+            if line:\n+                # Find the word that exceeds the length\n+                words = line.split(' ')\n+                words_len = len(words)\n+                length_sub = length\n+                wi = 0\n+                if words_len > 1:\n+                    for wi, w in enumerate(words):\n+                        # NOTE: This for-loop should always break\n+                        length_sub += len(w)\n+\n+                        if length_sub > max_size_adjusted:\n+                            # This word exceeds the max size; truncate to here\n+                            break\n+\n+                        if wi != words_len:\n+                            length_sub += 1  # Add 1 for space\n+\n+                # Replace with truncated line\n+                line = ' '.join(words[:wi])\n+                lines[line_i] = line\n+            break\n         else:\n-            chars = new_chars\n-    else:\n-        # Message did not exceed max size or lines; no truncation\n-        return message\n-    # Message exceeded max lines but not max size; truncate to line\n-    return (\n-        '\\n'.join(lines[:line_i])\n-        + f' {placeholder}'\n-        + '```' * in_code_block\n-    )\n+            length = new_length\n+\n+    # Join lines together\n+    final = '\\n'.join(lines[:line_i + 1])\n+\n+    # Strip trailing whitespace\n+    final, whitespace = get_trailing_whitespace(final)\n+    final_len = len(final) + placeholder_len + in_code_block * 3\n+    if '\\n' in whitespace:\n+        placeholder_prefix = '\\n'\n+    if not final or final_len + len(placeholder_prefix) > max_size:\n+        placeholder_prefix = ''\n+        if final_len > max_size:\n+            return ''\n+\n+    return (f'{final}{placeholder_prefix}{placeholder}'\n+            f\"{'```' * in_code_block}\")\n \n \n # Decorators\n@@ -467,3 +573,20 @@ async def wrapper(*args, **kwargs):\n             print('\\t' + repr(args[2]))\n             await func(*args, **kwargs)\n     return wrapper\n+\n+\n+# Context managers\n+@contextlib.contextmanager\n+def update_text(before, after):\n+    \"\"\"A context manager for printing one line of text and at the end,\n+    writing over it.\"\"\"\n+    after += ' ' * (len(before) - len(after))\n+    try:\n+        yield print(before, end='\\r', flush=True)\n+    finally:\n+        print(after)\n+\n+\n+def iterable_has(iterable, *args):\n+    \"\"\"Used for parsing *args in commands.\"\"\"\n+    return any(s in iterable for s in args)\ndiff --git a\/data\/discord.mplstyle b\/data\/discord.mplstyle\nnew file mode 100644\nindex 0000000..a59957e\n--- \/dev\/null\n+++ b\/data\/discord.mplstyle\n@@ -0,0 +1,61 @@\n+### Stylesheet themed for Discord\n+\n+### FONT\n+#\n+# font properties used by text.Text.  See\n+# http:\/\/matplotlib.org\/api\/font_manager_api.html for more\n+# information on font properties.  The 6 font properties used for font\n+# matching are given below with their default values.\n+\n+font.family         : calibri\n+font.style          : normal\n+font.variant        : normal\n+font.weight         : normal\n+font.stretch        : normal\n+# note that font.size controls default text sizes.  To configure\n+# special text sizes tick labels, axes, labels, title, etc, see the rc\n+# settings for axes and ticks. Special text sizes can be defined\n+# relative to font.size, using the following values: xx-small, x-small,\n+# small, medium, large, x-large, xx-large, larger, or smaller\n+font.size           : 12\n+\n+### AXES\n+# default face and edge color, default tick sizes,\n+# default fontsizes for ticklabels, and so on.  See\n+# http:\/\/matplotlib.org\/api\/axes_api.html#module-matplotlib.axes\n+axes.facecolor      : 00000000\n+axes.titlesize      : 18      # fontsize of the axes title\n+axes.labelsize      : 16      # fontsize of the x any y labels\n+axes.spines.right   : False\n+axes.spines.top     : False\n+\n+### TICKS\n+# see http:\/\/matplotlib.org\/api\/axis_api.html#matplotlib.axis.Tick\n+\n+xtick.labelsize      : 16     # fontsize of the tick labels\n+ytick.labelsize      : 16\n+\n+### Legend\n+legend.shadow        : True\n+legend.frameon       : True       # whether or not to draw a frame around legend\n+legend.facecolor     : 36393F4D   # (when 'inherit', uses axes.facecolor)\n+legend.edgecolor     : 36393F4D   # (when 'inherit', uses axes.edgecolor)\n+\n+### FIGURE\n+# See http:\/\/matplotlib.org\/api\/figure_api.html#matplotlib.figure.Figure\n+figure.facecolor : 36393F4D\n+figure.edgecolor : w       # figure edgecolor\n+figure.autolayout : False  # When True, automatically adjust subplot\n+                           # parameters to make the plot fit the figure\n+figure.frameon : True\n+\n+# The figure subplot parameters.  All dimensions are a fraction of the\n+# figure width or height\n+figure.subplot.left    : 0.125  # the left side of the subplots of the figure\n+figure.subplot.right   : 0.9    # the right side of the subplots of the figure\n+figure.subplot.bottom  : 0.1    # the bottom of the subplots of the figure\n+figure.subplot.top     : 0.9    # the top of the subplots of the figure\n+figure.subplot.wspace  : 0.2    # the amount of width reserved for space between subplots,\n+                                # expressed as a fraction of the average axis width\n+figure.subplot.hspace  : 0.2    # the amount of height reserved for space between subplots,\n+                                # expressed as a fraction of the average axis height\ndiff --git a\/main.py b\/main.py\nindex 8f45a4a..9628f24 100644\n--- a\/main.py\n+++ b\/main.py\n@@ -7,6 +7,10 @@\n \n import discord\n from discord.ext import commands\n+import discord_slash as dslash\n+import matplotlib\n+import matplotlib.pyplot as plt\n+import matplotlib.style as mplstyle\n \n from bot import checks\n from bot import database\n@@ -17,22 +21,26 @@\n from bot.other import discordlogger\n \n cogs = [\n-    'bot.commands.administrative',\n-    'bot.commands.background',\n-    'bot.commands.ciphers',\n-    'bot.commands.embedding',\n-    'bot.commands.games',\n-    'bot.commands.graphing',\n-    'bot.commands.guildirish',\n-    'bot.commands.images',\n-    'bot.commands.info',\n-    'bot.commands.notes',\n-    'bot.commands.prefix',\n-    'bot.commands.mathematics',\n-    'bot.commands.randomization',\n-    'bot.commands.reminders',\n-    'bot.commands.undefined',\n+    f'bot.commands.{c}' for c in (\n+        'administrative',\n+        'background',\n+        'ciphers',\n+        'embedding',\n+        'games',\n+        'graphing',\n+        'guildirish',\n+        'images',\n+        'info',\n+        'mathematics',\n+        'notes',\n+        'prefix',\n+        'randomization',\n+        'reminders',\n+        'undefined',\n+        'uptime',\n+    )\n ]\n+cogs.extend(('jishaku',))\n \n disabled_intents = [\n     'bans', 'integrations', 'webhooks', 'invites',\n@@ -40,6 +48,16 @@\n ]\n \n \n+\n+class Bot(commands.Bot):\n+    \"\"\"A custom version of Bot that allows case-insensitive references\n+    to cogs. See \"?tag case insensitive cogs\" on the discord.py server.\n+    \"\"\"\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self._BotBase__cogs = commands.core._CaseInsensitiveDict()\n+\n+\n async def main():\n     start_time = time.perf_counter()\n \n@@ -54,6 +72,10 @@ async def main():\n     # Set up databases\n     database.setup()\n \n+    # Use a non-GUI based backend for matplotlib\n+    matplotlib.use('Agg')\n+    mplstyle.use(['data\/discord.mplstyle', 'fast'])\n+\n     # Set up client\n     TOKEN = os.getenv('PyDiscordBotToken')\n     logger = discordlogger.get_logger()\n@@ -65,41 +87,49 @@ async def main():\n     for attr in disabled_intents:\n         setattr(intents, attr, False)\n \n-    bot = commands.Bot(\n+    bot = Bot(\n         command_prefix=database.get_prefix(),\n         help_command=helpcommand.HelpCommand(),\n         intents=intents\n     )\n \n-    checks.setup(bot)\n-    print('Initialized global checks')\n-    eventhandlers.setup(bot)\n-    print('Registered event handlers')\n+    with utils.update_text('Initializing global checks',\n+                           'Initialized global checks'):\n+        checks.setup(bot)\n+    with utils.update_text('Registering event handlers',\n+                           'Registered event handlers'):\n+        eventhandlers.setup(bot)\n \n     # Add botvars\n-    bot.info_bootup_time = 0\n-    bot.info_processed_commands = collections.defaultdict(int)\n-    bot.uptime_last_connect = datetime.datetime.now().astimezone()\n-    bot.uptime_last_connect_adjusted = bot.uptime_last_connect\n-    bot.uptime_last_disconnect = bot.uptime_last_connect\n-    bot.uptime_total_downtime = datetime.timedelta()\n-    bot.uptime_is_online = False\n-    print('Added botvars')\n-\n-    # Create task to calculate bootup time\n-    async def bootup_time(bot, start_time):\n-        await bot.wait_until_ready()\n-        bot.info_bootup_time = time.perf_counter() - start_time\n+    with utils.update_text('Adding botvars',\n+                           'Added botvars'):\n+        bot.info_bootup_time = 0\n+        bot.info_processed_commands = collections.defaultdict(int)\n+        bot.uptime_last_connect = datetime.datetime.now().astimezone()\n+        bot.uptime_last_connect_adjusted = bot.uptime_last_connect\n+        bot.uptime_last_disconnect = bot.uptime_last_connect\n+        bot.uptime_total_downtime = datetime.timedelta()\n+        bot.uptime_is_online = False\n+\n+    # Setup slash command system\n+    with utils.update_text('Adding slash command extension',\n+                           'Added slash command extension'):\n+        bot.slash = dslash.SlashCommand(bot, sync_commands=True, sync_on_cog_reload=True)\n \n     # Load extensions\n     for i, name in enumerate(cogs, start=1):\n+        print(f'Loading extension {i}\/{len(cogs)}', end='\\r', flush=True)\n         bot.load_extension(name)\n-        print(f'Loaded extension {i}\/{len(cogs)}', end='\\r', flush=True)\n-    print()\n+    print(f'Loaded all extensions         ')\n \n     # Clean up\n     del parser, args, attr, i, name\n \n+    async def bootup_time(bot, start_time):\n+        \"\"\"Calculate the bootup time of the bot.\"\"\"\n+        await bot.wait_until_ready()\n+        bot.info_bootup_time = time.perf_counter() - start_time\n+\n     # Create tasks\n     loop = asyncio.get_running_loop()\n \ndiff --git a\/requirements.txt b\/requirements.txt\nindex a22b1ed..beb6aef 100644\n--- a\/requirements.txt\n+++ b\/requirements.txt\n@@ -1,14 +1,20 @@\n aiohttp==3.6.2\n aiosqlite==0.15.0\n+astunparse==1.6.3\n async-timeout==3.0.1\n attrs==19.3.0\n+braceexpand==0.1.6\n chardet==3.0.4\n cycler==0.10.0\n-discord.py==1.5.1\n+discord-py-slash-command==1.0.9.4\n+discord.py==1.6.0\n disputils==0.1.3\n+emoji==1.2.0\n humanize==3.1.0\n idna==2.10\n+import-expression==1.1.4\n inflect==5.0.2\n+jishaku==1.20.0.220\n kiwisolver==1.3.1\n matplotlib==3.3.3\n multidict==4.7.6\n@@ -16,6 +22,7 @@ numpy==1.19.4\n packaging==20.4\n Pillow==8.0.1\n Pint==0.14\n+prettify.py @ git+https:\/\/github.com\/ShineyDev\/prettify.py@735d007b72f06256b3c4dfc4692f32a1011315db\n psutil==5.7.3\n pyparsing==2.4.7\n python-dateutil==2.8.1\ndiff --git a\/runloop.bat b\/runloop.bat\nnew file mode 100644\nindex 0000000..c490e57\n--- \/dev\/null\n+++ b\/runloop.bat\n@@ -0,0 +1,22 @@\n+@echo off\n+\n+:: Argument parsing\n+:: https:\/\/stackoverflow.com\/a\/3981086\n+SET args=\n+:parse\n+if NOT [%1]==[] (\n+\tSET args=%args% %1\n+\tSHIFT\n+\tGOTO parse\n+)\n+\n+:: Run the script\n+:run\n+\".venv\\Scripts\\python.exe\" \"main.py\" %args%\n+IF EXIST \"RESTART\" (\n+\tDEL \"RESTART\"\n+\tGOTO run\n+)\n+\n+:: The bot will generate a file indicating if it wants to restart.\n+:: If that file exists, delete it and run the script again\ndiff --git a\/settings.json b\/settings.json\nindex 07c931e..5e0349e 100644\n--- a\/settings.json\n+++ b\/settings.json\n@@ -100,5 +100,9 @@\n     \"owner_ids\": [\n         153551102443257856\n     ],\n-    \"print_error_mode\": \"raise\"\n+    \"print_error_mode\": \"raise\",\n+    \"slash_guild_ids\": [\n+        297463612870492160,\n+        456838870731063296\n+    ]\n }\n\\ No newline at end of file\n","files":{"\/bot\/checks.py":{"changes":[{"diff":"\n \n from bot import settings\n \n-COMMAND_COOLDOWN_SETTINGS = (15, 42, commands.BucketType.user)\n-\n-global_checks_wrapped = [\n-    'command_cooldown',\n-]\n-\n-GlobalCheckPredicate = collections.namedtuple(\n-    'GlobalCheckPredicate', ['predicate', 'call_once'],\n-    defaults={'call_once': False}\n-)\n-\n \n # Errors\n-class UserOnCooldown(commands.CheckFailure):\n+class UserOnCooldown(commands.CommandError):\n     \"\"\"Raised when a user has invoked too many commands\n     and is being globally ratelimited.\"\"\"\n     __slots__ = ('retry_after',)\n","add":1,"remove":12,"filename":"\/bot\/checks.py","badparts":["COMMAND_COOLDOWN_SETTINGS = (15, 42, commands.BucketType.user)","global_checks_wrapped = [","    'command_cooldown',","]","GlobalCheckPredicate = collections.namedtuple(","    'GlobalCheckPredicate', ['predicate', 'call_once'],","    defaults={'call_once': False}",")","class UserOnCooldown(commands.CheckFailure):"],"goodparts":["class UserOnCooldown(commands.CommandError):"]},{"diff":"\n     \"\"\"Raised when a command requires the user to be in ADMIN_IDS.\"\"\"\n \n \n-# Global checks\n-def command_cooldown(bot):\n-    mapping = commands.CooldownMapping.from_cooldown(\n-        *COMMAND_COOLDOWN_SETTINGS)\n-\n-    async def predicate(ctx):\n-        bucket = mapping.get_bucket(ctx.message)\n-        if bucket.update_rate_limit():\n-            # user is rate limited\n-            raise UserOnCooldown(\n-                bucket.get_retry_after(),\n-                'User is using commands too frequently.'\n-            )\n-        return True\n-\n-    return GlobalCheckPredicate(predicate, call_once=True)\n-\n-\n # Checks\n def is_bot_admin():\n     async def predicate(ctx):\n","add":0,"remove":18,"filename":"\/bot\/checks.py","badparts":["def command_cooldown(bot):","    mapping = commands.CooldownMapping.from_cooldown(","        *COMMAND_COOLDOWN_SETTINGS)","    async def predicate(ctx):","        bucket = mapping.get_bucket(ctx.message)","        if bucket.update_rate_limit():","            raise UserOnCooldown(","                bucket.get_retry_after(),","                'User is using commands too frequently.'","            )","        return True","    return GlobalCheckPredicate(predicate, call_once=True)"],"goodparts":[]},{"diff":"\n     return commands.check(predicate)\n \n \n+class Checks(commands.Cog):\n+    \"\"\"Global bot checks.\"\"\"\n+\n+    GLOBAL_COOLDOWN_SETTINGS = (15, 60, commands.BucketType.user)\n+\n+    def __init__(self, bot, *, global_cooldown_settings=None):\n+        \"\"\"\n+        Args:\n+            bot (commands.Bot): The discord bot.\n+            global_cooldown_settings (Optional[Tuple[int, int, commands.BucketType]]):\n+                The settings to use for the global cooldown (rate, per, type).\n+                Defaults to self.GLOBAL_COOLDOWN_SETTINGS.\n+\n+        \"\"\"\n+        self.bot = bot\n+\n+        if global_cooldown_settings is None:\n+            global_cooldown_settings = self.GLOBAL_COOLDOWN_SETTINGS\n+        self.global_cooldown = commands.CooldownMapping.from_cooldown(\n+            *global_cooldown_settings)\n+\n+    def bot_check_once(self, ctx):\n+        # Global cooldown\n+        bucket = self.global_cooldown.get_bucket(ctx.message)\n+        if bucket.update_rate_limit():\n+            raise UserOnCooldown(\n+                bucket.get_retry_after(),\n+                'User is using commands too frequently.'\n+            )\n+\n+        return True\n+\n+\n def setup(bot):\n-    for check in global_checks_wrapped:\n-        predicate, call_once = globals()[check](bot)\n-        bot.add_check(predicate, call_once=call_once)\n+    bot.add_cog(Checks(bot))","add":34,"remove":3,"filename":"\/bot\/checks.py","badparts":["    for check in global_checks_wrapped:","        predicate, call_once = globals()[check](bot)","        bot.add_check(predicate, call_once=call_once)"],"goodparts":["class Checks(commands.Cog):","    \"\"\"Global bot checks.\"\"\"","    GLOBAL_COOLDOWN_SETTINGS = (15, 60, commands.BucketType.user)","    def __init__(self, bot, *, global_cooldown_settings=None):","        \"\"\"","        Args:","            bot (commands.Bot): The discord bot.","            global_cooldown_settings (Optional[Tuple[int, int, commands.BucketType]]):","                The settings to use for the global cooldown (rate, per, type).","                Defaults to self.GLOBAL_COOLDOWN_SETTINGS.","        \"\"\"","        self.bot = bot","        if global_cooldown_settings is None:","            global_cooldown_settings = self.GLOBAL_COOLDOWN_SETTINGS","        self.global_cooldown = commands.CooldownMapping.from_cooldown(","            *global_cooldown_settings)","    def bot_check_once(self, ctx):","        bucket = self.global_cooldown.get_bucket(ctx.message)","        if bucket.update_rate_limit():","            raise UserOnCooldown(","                bucket.get_retry_after(),","                'User is using commands too frequently.'","            )","        return True","    bot.add_cog(Checks(bot))"]}],"source":"\nimport collections from discord.ext import commands from bot import settings COMMAND_COOLDOWN_SETTINGS=(15, 42, commands.BucketType.user) global_checks_wrapped=[ 'command_cooldown', ] GlobalCheckPredicate=collections.namedtuple( 'GlobalCheckPredicate',['predicate', 'call_once'], defaults={'call_once': False} ) class UserOnCooldown(commands.CheckFailure): \"\"\"Raised when a user has invoked too many commands and is being globally ratelimited.\"\"\" __slots__=('retry_after',) def __init__(self, retry_after, *args, **kwargs): super().__init__(*args, **kwargs) self.retry_after=retry_after class InvalidIdentification(commands.CheckFailure): \"\"\"The base class for invalid identifications.\"\"\" class InvalidBotOwner(InvalidIdentification): \"\"\"Raised when a command requires the user to be in OWNER_IDS.\"\"\" class InvalidBotAdmin(InvalidIdentification): \"\"\"Raised when a command requires the user to be in ADMIN_IDS.\"\"\" def command_cooldown(bot): mapping=commands.CooldownMapping.from_cooldown( *COMMAND_COOLDOWN_SETTINGS) async def predicate(ctx): bucket=mapping.get_bucket(ctx.message) if bucket.update_rate_limit(): raise UserOnCooldown( bucket.get_retry_after(), 'User is using commands too frequently.' ) return True return GlobalCheckPredicate(predicate, call_once=True) def is_bot_admin(): async def predicate(ctx): if ctx.author.id in settings.get_setting('admin_ids'): return True else: raise InvalidBotAdmin( f\"{ctx.author} is not registered as one of the bot's admins.\") return commands.check(predicate) def is_bot_owner(): async def predicate(ctx): if( ctx.author.id in settings.get_setting('owner_ids') or await ctx.bot.is_owner(ctx.author)): return True else: raise InvalidBotOwner( f\"{ctx.author} is not registered as one of the bot's owners.\") return commands.check(predicate) def is_in_guild(guild_id): async def predicate(ctx): guild=ctx.bot.get_guild(guild_id) if guild is None: return False return guild.get_member(ctx.author.id) is not None return commands.check(predicate) def setup(bot): for check in global_checks_wrapped: predicate, call_once=globals()[check](bot) bot.add_check(predicate, call_once=call_once) ","sourceWithComments":"import collections\n\nfrom discord.ext import commands\n\nfrom bot import settings\n\nCOMMAND_COOLDOWN_SETTINGS = (15, 42, commands.BucketType.user)\n\nglobal_checks_wrapped = [\n    'command_cooldown',\n]\n\nGlobalCheckPredicate = collections.namedtuple(\n    'GlobalCheckPredicate', ['predicate', 'call_once'],\n    defaults={'call_once': False}\n)\n\n\n# Errors\nclass UserOnCooldown(commands.CheckFailure):\n    \"\"\"Raised when a user has invoked too many commands\n    and is being globally ratelimited.\"\"\"\n    __slots__ = ('retry_after',)\n\n    def __init__(self, retry_after, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.retry_after = retry_after\n\n\nclass InvalidIdentification(commands.CheckFailure):\n    \"\"\"The base class for invalid identifications.\"\"\"\n\n\nclass InvalidBotOwner(InvalidIdentification):\n    \"\"\"Raised when a command requires the user to be in OWNER_IDS.\"\"\"\n\n\nclass InvalidBotAdmin(InvalidIdentification):\n    \"\"\"Raised when a command requires the user to be in ADMIN_IDS.\"\"\"\n\n\n# Global checks\ndef command_cooldown(bot):\n    mapping = commands.CooldownMapping.from_cooldown(\n        *COMMAND_COOLDOWN_SETTINGS)\n\n    async def predicate(ctx):\n        bucket = mapping.get_bucket(ctx.message)\n        if bucket.update_rate_limit():\n            # user is rate limited\n            raise UserOnCooldown(\n                bucket.get_retry_after(),\n                'User is using commands too frequently.'\n            )\n        return True\n\n    return GlobalCheckPredicate(predicate, call_once=True)\n\n\n# Checks\ndef is_bot_admin():\n    async def predicate(ctx):\n        if ctx.author.id in settings.get_setting('admin_ids'):\n            return True\n        else:\n            raise InvalidBotAdmin(\n                f\"{ctx.author} is not registered as one of the bot's admins.\")\n\n    return commands.check(predicate)\n\n\ndef is_bot_owner():\n    async def predicate(ctx):\n        if (    ctx.author.id in settings.get_setting('owner_ids')\n                or await ctx.bot.is_owner(ctx.author)):\n            return True\n        else:\n            raise InvalidBotOwner(\n                f\"{ctx.author} is not registered as one of the bot's owners.\")\n\n    return commands.check(predicate)\n\n\ndef is_in_guild(guild_id):\n    async def predicate(ctx):\n        guild = ctx.bot.get_guild(guild_id)\n        if guild is None:\n            return False\n\n        return guild.get_member(ctx.author.id) is not None\n\n    return commands.check(predicate)\n\n\ndef setup(bot):\n    for check in global_checks_wrapped:\n        predicate, call_once = globals()[check](bot)\n        bot.add_check(predicate, call_once=call_once)\n"},"\/bot\/classes\/confirmation.py":{"changes":[{"diff":"\n+import abc\n import asyncio\n from dataclasses import dataclass\n+from typing import Optional\n \n import discord\n \n \n-@dataclass\n+@dataclass(frozen=True)\n class ConfirmationEmoji:\n     emoji: str\n     color: int\n","add":3,"remove":1,"filename":"\/bot\/classes\/confirmation.py","badparts":["@dataclass"],"goodparts":["import abc","from typing import Optional","@dataclass(frozen=True)"]}],"source":"\nimport asyncio from dataclasses import dataclass import discord @dataclass class ConfirmationEmoji: emoji: str color: int @property def colour(self): return self.color class Confirmation: def __init__(self, ctx, color=0): self.ctx=ctx self.color=color self.embed=discord.Embed( color=color ).set_author( name=ctx.author.display_name, icon_url=ctx.author.avatar_url ) self.emoji_yes=ConfirmationEmoji( '\\N{WHITE HEAVY CHECK MARK}', 0x77B255) self.emoji_no=ConfirmationEmoji( '\\N{CROSS MARK}', 0xDD2E44) self.message=None async def confirm(self, title: str, timeout=30): \"\"\"Ask the user to confirm. Returns: bool: The choice the user picked. None: Timed out. \"\"\" async def clear_reactions(message): try: await message.clear_reactions() except discord.Forbidden: pass ctx=self.ctx self.embed.title=title message=await ctx.send(embed=self.embed) self.message=message emoji=[self.emoji_yes.emoji, self.emoji_no.emoji] for e in emoji: await message.add_reaction(e) def check(r, u): return(r.message==message and u==ctx.author and r.emoji in emoji) try: reaction, user=await ctx.bot.wait_for( 'reaction_add', check=check, timeout=timeout ) except asyncio.TimeoutError: return None else: return reaction.emoji==self.emoji_yes.emoji finally: await clear_reactions(message) async def update(self, title: str, color=None): self.embed.title=title if color is not None: self.embed.color=color await self.message.edit(embed=self.embed) ","sourceWithComments":"import asyncio\nfrom dataclasses import dataclass\n\nimport discord\n\n\n@dataclass\nclass ConfirmationEmoji:\n    emoji: str\n    color: int\n\n    @property\n    def colour(self):\n        return self.color\n\n\nclass Confirmation:\n    def __init__(self, ctx, color=0):\n        self.ctx = ctx\n        self.color = color\n        self.embed = discord.Embed(\n            color=color\n        ).set_author(\n            name=ctx.author.display_name,\n            icon_url=ctx.author.avatar_url\n        )\n        self.emoji_yes = ConfirmationEmoji(\n            '\\N{WHITE HEAVY CHECK MARK}', 0x77B255)\n        self.emoji_no = ConfirmationEmoji(\n            '\\N{CROSS MARK}', 0xDD2E44)\n        self.message = None\n\n    async def confirm(self, title: str, timeout=30):\n        \"\"\"Ask the user to confirm.\n\n        Returns:\n            bool: The choice the user picked.\n            None: Timed out.\n\n        \"\"\"\n        async def clear_reactions(message):\n            try:\n                await message.clear_reactions()\n            except discord.Forbidden:\n                pass\n\n        ctx = self.ctx\n\n        self.embed.title = title\n\n        # Send prompt\n        message = await ctx.send(embed=self.embed)\n        self.message = message\n\n        # Add reactions\n        emoji = [self.emoji_yes.emoji, self.emoji_no.emoji]\n        for e in emoji:\n            await message.add_reaction(e)\n\n        # Wait for response\n        def check(r, u):\n            return (r.message == message and u == ctx.author\n                    and r.emoji in emoji)\n\n        try:\n            reaction, user = await ctx.bot.wait_for(\n                'reaction_add', check=check, timeout=timeout\n            )\n        except asyncio.TimeoutError:\n            return None\n        else:\n            return reaction.emoji == self.emoji_yes.emoji\n        finally:\n            await clear_reactions(message)\n\n    async def update(self, title: str, color=None):\n        self.embed.title = title\n        if color is not None:\n            self.embed.color = color\n\n        await self.message.edit(embed=self.embed)\n"},"\/bot\/classes\/games\/multimath.py":{"changes":[{"diff":"\n import asyncio\n import collections\n-import math\n import operator\n import random\n \n","add":0,"remove":1,"filename":"\/bot\/classes\/games\/multimath.py","badparts":["import math"],"goodparts":[]},{"diff":"\n             channel (Optional[discord.TextChannel]):\n                 The channel to send the message to.\n                 If None, uses `self._ctx.channel`.\n-            users (Optional[Union[True, List[discord.User]]]):\n+            users (Optional[List[discord.User]]):\n                 A list of users that can participate in the game.\n-                If None, the author of self._ctx will be the only participant.\n-                If True, anyone can participate.\n+                If None, anyone can participate.\n         \"\"\"\n         async def finish_and_show_score(header, last_answerer=None):\n             \"Display the final score and who got it wrong >:(\"\n","add":2,"remove":3,"filename":"\/bot\/classes\/games\/multimath.py","badparts":["            users (Optional[Union[True, List[discord.User]]]):","                If None, the author of self._ctx will be the only participant.","                If True, anyone can participate."],"goodparts":["            users (Optional[List[discord.User]]):","                If None, anyone can participate."]},{"diff":"\n                 [header, embed_finish.description])\n             await message.edit(embed=embed_finish)\n \n-        if users is None:\n-            # Allow only caller\n-            users = [self._ctx.author]\n-        elif users is True:\n-            # Allow all participants\n-            users = None\n         if channel is None:\n             # Assumes game to be started in the caller's channel\n             channel = self._ctx.chan","add":0,"remove":6,"filename":"\/bot\/classes\/games\/multimath.py","badparts":["        if users is None:","            users = [self._ctx.author]","        elif users is True:","            users = None"],"goodparts":[]}],"source":"\nimport asyncio import collections import math import operator import random import discord import inflect from bot.classes.get_reaction import get_reaction from bot import settings inflector=inflect.engine() Operator=collections.namedtuple('Operator',['symbol', 'func']) OPERATORS=( Operator('+', operator.add), Operator('-', operator.sub), Operator('*', operator.mul), Operator('\/', operator.truediv) ) class MultimathGame: precision=2 def __init__( self, *, color=0x000000): self.a=0 self.b=0 self.op=None self.ans=0 self.question_count=0 self.color=color def answer_question(self, user_answer): \"\"\" Returns: Tuple[bool, str]: A boolean indicating whether the answer was correct, along with a message to edit the embed with. \"\"\" user_answer=round(user_answer, self.precision) if user_answer==self.ans: return True, 'Correct!' return False,(f'{user_answer:g} was incorrect; ' f'the answer was{self.ans:g}!') def embed_begin(self, ctx, users): \"\"\"Return an Embed to be used as the beginning of the game. Args: ctx(commands.Context): The command context. This is used to know who started the game. users(Optional[List[discord.User]]): A list of users to show in the beginning message. If None, everyone is allowed. Returns: discord.Embed \"\"\" description=['React to the emojis to answer the question!'] if users is None: title=f'Multimath started by{ctx.author.name}' description.append('Allowed users: everyone') else: users=[u for u in users if not u.bot] if len(users)==1 and users[0]==ctx.author: title=f'Multimath started for{users[0].name}' description.append(f'Allowed users:{users[0].name}') else: title=f'Multimath started by{ctx.author.name}' description.append( 'Allowed users:{}'.format( inflector.join([u.name for u in users]) ) ) return discord.Embed( title=title, description='\\n'.join(description), color=self.color ) def embed_finish(self, user: discord.User): score=self.question_count -1 return discord.Embed( title=f'Multimath finished by{user.name}', description=f'Final score:{score:,}', color=self.color ) def embed_question(self, answers: dict, time_to_answer): description=(f'Time to answer:{time_to_answer:,g}s\\n' f'What is{self.a}{self.op.symbol}{self.b}?\\n') description +='\\n'.join( f'{emoji}:{ans:g}' for emoji, ans in answers.items()) return discord.Embed( title=f'Question{self.question_count:,}', description=description, color=self.color ) def generate_values(self): self.question_count +=1 self.a=random.randint(1, 10) self.b=random.randint(1, 10) self.op=random.choice(OPERATORS) self.ans=round(self.op.func(self.a, self.b), self.precision) if self.ans==int(self.ans): self.ans=int(self.ans) return self.a, self.b, self.op, self.ans def generate_false_answers(self, amount: int=1, deviation: int=20): \"Generate numbers close to self.ans.\" is_decimal=isinstance(self.ans, float) rounder=10 ** self.precision if is_decimal and self.op.symbol=='\/': deviation=1 if self.ans <=deviation: if self.ans > 0: middle=random.uniform(0, self.ans) else: middle=random.uniform(deviation -self.ans, deviation) else: middle=random.uniform(0, deviation) else: middle=random.randint(0, deviation) lower, upper=self.ans -middle, self.ans +deviation -middle possible_answers=range( round(lower * rounder), round(upper * rounder) +1 ) if len(possible_answers) -1 < amount: raise ValueError( f'Cannot generate{amount} answers when deviation of ' f'{deviation} only allows for{len(possible_answers) -1} ' 'invalid answers' ) integers=amount \/\/ 2 answers={self.ans} while len(answers) -1 < amount: n=random.randint( possible_answers.start, possible_answers.stop ) \/ rounder if not is_decimal and integers and random.randint(0, 1): n=round(n) integers -=1 answers.add(n) answers.remove(self.ans) return list(answers) class BotMultimathGame: def __init__(self, ctx, options=['\ud83c\udde6', '\ud83c\udde7', '\ud83c\udde8', '\ud83c\udde9', '\ud83c\uddea']): self._ctx=ctx self._client=ctx.bot self.options=options self.game=MultimathGame( color=int(settings.get_setting('bot_color'), 16) ) async def run(self, *, channel=None, users=None): \"\"\" Args: channel(Optional[discord.TextChannel]): The channel to send the message to. If None, uses `self._ctx.channel`. users(Optional[Union[True, List[discord.User]]]): A list of users that can participate in the game. If None, the author of self._ctx will be the only participant. If True, anyone can participate. \"\"\" async def finish_and_show_score(header, last_answerer=None): \"Display the final score and who got it wrong >:(\" if last_answerer is None: last_answerer=self._ctx.author embed_finish=self.game.embed_finish(last_answerer) embed_finish.description='\\n'.join( [header, embed_finish.description]) await message.edit(embed=embed_finish) if users is None: users=[self._ctx.author] elif users is True: users=None if channel is None: channel=self._ctx.channel message=await channel.send( embed=self.game.embed_begin(self._ctx, users) ) for emoji in self.options: await message.add_reaction(emoji) time_to_answer=10 time_intermission=3 reaction=user=None await asyncio.sleep(2) while True: self.game.generate_values() answers=self.game.generate_false_answers( len(self.options) -1) answers.append(self.game.ans) random.shuffle(answers) answers_dict={ emoji: answer for emoji, answer in zip(self.options, answers)} embed_question=self.game.embed_question( answers_dict, time_to_answer) await message.edit(embed=embed_question) is_correct=False try: reaction, user=await get_reaction( self._client, message, self.options, users, timeout=time_to_answer ) except asyncio.TimeoutError: response=f'Too late!{time_to_answer:,g} seconds have passed!' await message.edit(embed=discord.Embed( title=embed_question.title, description=response, color=self.game.color )) else: user_answer=answers_dict[reaction.emoji] is_correct, response=self.game.answer_question(user_answer) embed_answer=discord.Embed( title=embed_question.title, description=response, color=self.game.color ) await message.edit(embed=embed_answer) await asyncio.sleep(time_intermission) if is_correct: time_to_answer=round(max(3, time_to_answer -1), 2) time_intermission=max(1, time_intermission -0.15) else: response='Expression:{}{}{}\\n{}'.format( self.game.a, self.game.op.symbol, self.game.b, response ) return await finish_and_show_score(response, user) ","sourceWithComments":"import asyncio\nimport collections\nimport math\nimport operator\nimport random\n\nimport discord\nimport inflect\n\nfrom bot.classes.get_reaction import get_reaction\nfrom bot import settings\n\ninflector = inflect.engine()\n\nOperator = collections.namedtuple('Operator', ['symbol', 'func'])\n\nOPERATORS = (\n    Operator('+', operator.add),\n    Operator('-', operator.sub),\n    Operator('*', operator.mul),\n    Operator('\/', operator.truediv)\n)\n\n\nclass MultimathGame:\n\n    precision = 2\n\n    def __init__(\n            self, *,\n            color=0x000000):\n        self.a = 0\n        self.b = 0\n        self.op = None\n        self.ans = 0\n\n        self.question_count = 0\n\n        self.color = color\n\n    def answer_question(self, user_answer):\n        \"\"\"\n        Returns:\n            Tuple[bool, str]: A boolean indicating whether the answer\n                was correct, along with a message to edit the embed\n                with.\n        \"\"\"\n        user_answer = round(user_answer, self.precision)\n        if user_answer == self.ans:\n            return True, 'Correct!'\n        return False, (f'{user_answer:g} was incorrect; '\n                       f'the answer was {self.ans:g}!')\n\n    def embed_begin(self, ctx, users):\n        \"\"\"Return an Embed to be used as the beginning of the game.\n\n        Args:\n            ctx (commands.Context): The command context.\n                This is used to know who started the game.\n            users (Optional[List[discord.User]]):\n                A list of users to show in the beginning message.\n                If None, everyone is allowed.\n\n        Returns:\n            discord.Embed\n\n        \"\"\"\n        description = ['React to the emojis to answer the question!']\n        if users is None:\n            title = f'Multimath started by {ctx.author.name}'\n            description.append('Allowed users: everyone')\n        else:\n            users = [u for u in users if not u.bot]\n            if len(users) == 1 and users[0] == ctx.author:\n                title = f'Multimath started for {users[0].name}'\n                description.append(f'Allowed users: {users[0].name}')\n            else:\n                title = f'Multimath started by {ctx.author.name}'\n                description.append(\n                    'Allowed users: {}'.format(\n                        inflector.join([u.name for u in users])\n                    )\n                )\n\n        return discord.Embed(\n            title=title,\n            description='\\n'.join(description),\n            color=self.color\n        )\n\n    def embed_finish(self, user: discord.User):\n        score = self.question_count - 1\n        return discord.Embed(\n            title=f'Multimath finished by {user.name}',\n            description=f'Final score: {score:,}',\n            color=self.color\n        )\n\n    def embed_question(self, answers: dict, time_to_answer):\n        description = (f'Time to answer: {time_to_answer:,g}s\\n'\n                       f'What is {self.a} {self.op.symbol} {self.b}?\\n')\n        description += '\\n'.join(\n            f'{emoji}: {ans:g}' for emoji, ans in answers.items())\n\n        return discord.Embed(\n            title=f'Question {self.question_count:,}',\n            description=description,\n            color=self.color\n        )\n\n    def generate_values(self):\n        self.question_count += 1\n        self.a = random.randint(1, 10)\n        self.b = random.randint(1, 10)\n        self.op = random.choice(OPERATORS)\n        self.ans = round(self.op.func(self.a, self.b), self.precision)\n        if self.ans == int(self.ans):\n            # no decimal, turn to integer\n            self.ans = int(self.ans)\n\n        return self.a, self.b, self.op, self.ans\n\n    def generate_false_answers(self, amount: int = 1, deviation: int = 20):\n        \"Generate numbers close to self.ans.\"\n        is_decimal = isinstance(self.ans, float)\n        rounder = 10 ** self.precision  # Used to round off decimals\n\n        if is_decimal and self.op.symbol == '\/':\n            # Decimal answer from division; reduce deviation so answers\n            # are harder to figure out and also make sure that the\n            # bounds match the sign of the real answer\n            deviation = 1\n            if self.ans <= deviation:\n                if self.ans > 0:\n                    middle = random.uniform(0, self.ans)\n                else:\n                    middle = random.uniform(deviation - self.ans, deviation)\n            else:\n                middle = random.uniform(0, deviation)\n        else:\n            middle = random.randint(0, deviation)\n\n        lower, upper = self.ans - middle, self.ans + deviation - middle\n\n        # Generate a range of possible answers\n        possible_answers = range(\n            round(lower * rounder),\n            round(upper * rounder) + 1\n        )\n\n        # Check if there are enough possibilities to generate `amount` answers\n        # (subtract 1 to account for the real answer always existing)\n        if len(possible_answers) - 1 < amount:\n            raise ValueError(\n                f'Cannot generate {amount} answers when deviation of '\n                f'{deviation} only allows for {len(possible_answers) - 1} '\n                'invalid answers'\n            )\n\n        integers = amount \/\/ 2\n        # For rounding at most half the generated numbers if the real\n        # answer is an integer\n\n        answers = {self.ans}\n        while len(answers) - 1 < amount:\n            n = random.randint(\n                possible_answers.start,\n                possible_answers.stop\n            ) \/ rounder\n            # 50% chance to round number to integer\n            if not is_decimal and integers and random.randint(0, 1):\n                n = round(n)\n                integers -= 1\n\n            answers.add(n)\n\n        answers.remove(self.ans)\n        return list(answers)\n\n\nclass BotMultimathGame:\n    def __init__(self, ctx, options=['\ud83c\udde6', '\ud83c\udde7', '\ud83c\udde8', '\ud83c\udde9', '\ud83c\uddea']):\n        self._ctx = ctx\n        self._client = ctx.bot\n        self.options = options\n\n        self.game = MultimathGame(\n            color=int(settings.get_setting('bot_color'), 16)\n        )\n\n    async def run(self, *, channel=None, users=None):\n        \"\"\"\n        Args:\n            channel (Optional[discord.TextChannel]):\n                The channel to send the message to.\n                If None, uses `self._ctx.channel`.\n            users (Optional[Union[True, List[discord.User]]]):\n                A list of users that can participate in the game.\n                If None, the author of self._ctx will be the only participant.\n                If True, anyone can participate.\n        \"\"\"\n        async def finish_and_show_score(header, last_answerer=None):\n            \"Display the final score and who got it wrong >:(\"\n            if last_answerer is None:\n                last_answerer = self._ctx.author\n            embed_finish = self.game.embed_finish(last_answerer)\n            embed_finish.description = '\\n'.join(\n                [header, embed_finish.description])\n            await message.edit(embed=embed_finish)\n\n        if users is None:\n            # Allow only caller\n            users = [self._ctx.author]\n        elif users is True:\n            # Allow all participants\n            users = None\n        if channel is None:\n            # Assumes game to be started in the caller's channel\n            channel = self._ctx.channel\n\n        message = await channel.send(\n            embed=self.game.embed_begin(self._ctx, users)\n        )\n\n        for emoji in self.options:\n            await message.add_reaction(emoji)\n\n        time_to_answer = 10\n        time_intermission = 3\n        reaction = user = None\n\n        await asyncio.sleep(2)\n\n        # Begin playing\n        while True:\n            # Generate question\n            self.game.generate_values()\n            answers = self.game.generate_false_answers(\n                len(self.options) - 1)\n            answers.append(self.game.ans)\n            random.shuffle(answers)\n            answers_dict = {\n                emoji: answer for emoji, answer in zip(self.options, answers)}\n\n            # Ask question\n            embed_question = self.game.embed_question(\n                answers_dict, time_to_answer)\n            await message.edit(embed=embed_question)\n\n            is_correct = False\n            try:\n                reaction, user = await get_reaction(\n                    self._client, message,\n                    self.options, users,\n                    timeout=time_to_answer\n                )\n            except asyncio.TimeoutError:\n                # Timed out!\n                response = f'Too late! {time_to_answer:,g} seconds have passed!'\n                await message.edit(embed=discord.Embed(\n                    title=embed_question.title,\n                    description=response,\n                    color=self.game.color\n                ))\n            else:\n                # Get response\n                user_answer = answers_dict[reaction.emoji]\n                is_correct, response = self.game.answer_question(user_answer)\n\n                # Respond with answer\n                embed_answer = discord.Embed(\n                    title=embed_question.title,\n                    description=response,\n                    color=self.game.color\n                )\n                await message.edit(embed=embed_answer)\n\n            await asyncio.sleep(time_intermission)\n\n            if is_correct:\n                # Reduce time to answer\n                # NOTE: keep time_to_answer rounded to 2 places so it\n                # displays nicely\n                time_to_answer = round(max(3, time_to_answer - 1), 2)\n                time_intermission = max(1, time_intermission - 0.15)\n            else:\n                response = 'Expression: {} {} {}\\n{}'.format(\n                    self.game.a,\n                    self.game.op.symbol,\n                    self.game.b,\n                    response\n                )\n                return await finish_and_show_score(response, user)\n"},"\/bot\/classes\/get_reaction.py":{"changes":[{"diff":"\n         reactions (Optional[List[Union[Emoji, PartialEmoji, str]]]):\n             Returns only reaction changes within this list.\n             If None, returns any reaction change.\n-        timeout (Optional[float]): The timeout period.\n-            Raises TimeoutError.\n         users (Optional[List[discord.User]]): A list of users\n             that are allowed to react to the message.\n             If None, returns any user's reaction change.\n","add":0,"remove":2,"filename":"\/bot\/classes\/get_reaction.py","badparts":["        timeout (Optional[float]): The timeout period.","            Raises TimeoutError."],"goodparts":[]}],"source":"\nimport asyncio import discord async def get_reaction(client, message, reactions=None, users=None, *, timeout=None): \"\"\"Return(reaction, user) whenever a reaction is added or removed. See https:\/\/stackoverflow.com\/a\/59433241 on awaiting multiple events. Args: client(discord.Client): The client\/bot. message(discord.Message): The message to watch for reactions. reactions(Optional[List[Union[Emoji, PartialEmoji, str]]]): Returns only reaction changes within this list. If None, returns any reaction change. timeout(Optional[float]): The timeout period. Raises TimeoutError. users(Optional[List[discord.User]]): A list of users that are allowed to react to the message. If None, returns any user's reaction change. timeout(Optional[float]): The timeout period. Raises TimeoutError. Returns: Tuple[discord.Reaction, discord.User] Raises: TimeoutError \"\"\" def check(r: discord.Reaction, u: discord.User): result=r.message.id==message.id if reactions: result=result and r.emoji in reactions if users: result=result and u.id in(u1.id for u1 in users) return result pending_tasks=[ client.wait_for('reaction_add', check=check), client.wait_for('reaction_remove', check=check), ] try: completed_tasks, pending_tasks=await asyncio.wait( pending_tasks, return_when=asyncio.FIRST_COMPLETED, timeout=timeout ) result=completed_tasks.pop().result() except KeyError: raise asyncio.TimeoutError( 'Timed out while waiting for reaction change') else: return result finally: for task in pending_tasks: task.cancel() for task in completed_tasks: task.exception() ","sourceWithComments":"import asyncio\n\nimport discord\n\n\nasync def get_reaction(client, message, reactions=None,\n                       users=None, *, timeout=None):\n    \"\"\"Return (reaction, user) whenever a reaction is added or removed.\n\n    See https:\/\/stackoverflow.com\/a\/59433241 on awaiting multiple events.\n\n    Args:\n        client (discord.Client): The client\/bot.\n        message (discord.Message): The message to watch for reactions.\n        reactions (Optional[List[Union[Emoji, PartialEmoji, str]]]):\n            Returns only reaction changes within this list.\n            If None, returns any reaction change.\n        timeout (Optional[float]): The timeout period.\n            Raises TimeoutError.\n        users (Optional[List[discord.User]]): A list of users\n            that are allowed to react to the message.\n            If None, returns any user's reaction change.\n        timeout (Optional[float]): The timeout period.\n            Raises TimeoutError.\n\n    Returns:\n        Tuple[discord.Reaction, discord.User]\n\n    Raises:\n        TimeoutError\n\n    \"\"\"\n    def check(r: discord.Reaction, u: discord.User):\n        result = r.message.id == message.id\n\n        if reactions:\n            result = result and r.emoji in reactions\n        if users:\n            result = result and u.id in (u1.id for u1 in users)\n\n        return result\n\n    pending_tasks = [\n        client.wait_for('reaction_add', check=check),\n        client.wait_for('reaction_remove', check=check),\n    ]\n    try:\n        completed_tasks, pending_tasks = await asyncio.wait(\n            pending_tasks, return_when=asyncio.FIRST_COMPLETED,\n            timeout=timeout\n        )\n        result = completed_tasks.pop().result()\n    except KeyError:\n        # Timed out!\n        raise asyncio.TimeoutError(\n            'Timed out while waiting for reaction change')\n    else:\n        return result\n    finally:\n        for task in pending_tasks:\n            task.cancel()\n        # If any exception happened in any other done tasks\n        # we don't care about the exception, but don't want the noise of\n        # non-retrieved exceptions\n        for task in completed_tasks:\n            task.exception()\n"},"\/bot\/commands\/administrative.py":{"changes":[{"diff":"\n import io\n import textwrap\n import time\n-import typing\n+from typing import Optional\n \n import discord\n from discord.ext import commands\n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["import typing"],"goodparts":["from typing import Optional"]},{"diff":"\n import numpy as np\n \n-from bot import checks\n-from bot import settings\n-from bot import utils\n+from bot.classes.confirmation import AdaptiveConfirmation\n from bot.other import discordlogger\n+from bot import checks, converters, settings, utils\n \n \n def get_user_for_log(ctx):\n     return f'{ctx.author} ({ctx.author.id})'\n \n \n+def send_restart_signal():\n+    \"\"\"Create a file named RESTART that the batch file running the script\n+    loop should detect and recognize to rerun the bot again.\"\"\"\n+    open('RESTART', 'w').close()\n+\n+\n+class BucketTypeConverter(commands.Converter):\n+    async def convert(self, ctx, argument):\n+        try:\n+            # Convert by number\n+            return commands.BucketType(argument)\n+        except ValueError:\n+            try:\n+                # Convert by enum name\n+                return getattr(commands.BucketType, argument)\n+            except AttributeError:\n+                raise commands.BadArgument(f'{argument!r} is not a valid BucketType')\n+\n+\n class Administrative(commands.Cog):\n+    \"\"\"Administrative commands available for owners\/admins.\"\"\"\n     qualified_name = 'Administrative'\n-    description = 'Administrative commands available for owners\/admins.'\n \n     def __init__(self, bot):\n         self.bot = bot\n","add":22,"remove":4,"filename":"\/bot\/commands\/administrative.py","badparts":["from bot import checks","from bot import settings","from bot import utils","    description = 'Administrative commands available for owners\/admins.'"],"goodparts":["from bot.classes.confirmation import AdaptiveConfirmation","from bot import checks, converters, settings, utils","def send_restart_signal():","    \"\"\"Create a file named RESTART that the batch file running the script","    loop should detect and recognize to rerun the bot again.\"\"\"","    open('RESTART', 'w').close()","class BucketTypeConverter(commands.Converter):","    async def convert(self, ctx, argument):","        try:","            return commands.BucketType(argument)","        except ValueError:","            try:","                return getattr(commands.BucketType, argument)","            except AttributeError:","                raise commands.BadArgument(f'{argument!r} is not a valid BucketType')","    \"\"\"Administrative commands available for owners\/admins.\"\"\""]},{"diff":"\n     @checks.is_bot_owner()\n     async def client_block(self, ctx, x: int = 20):\n         \"\"\"Block the operation of the bot.\"\"\"\n-        await ctx.send(f'Blocking for {x} seconds.')\n+        message = await ctx.send(f'Blocking for {x} seconds.')\n         time.sleep(x)\n-        await ctx.send('Finished blocking.')\n+        await message.edit(content='Finished blocking.')\n \n \n-    @client_block.error\n-    async def client_block_error(self, ctx, error):\n-        error = getattr(error, 'original', error)\n-        if isinstance(error, checks.InvalidBotOwner):\n-            await ctx.send(get_denied_message())\n \n \n \n+    @commands.group(name='cooldown', invoke_without_command=True)\n+    @checks.is_bot_admin()\n+    async def client_cooldown(self, ctx):\n+        \"\"\"Modify a command's cooldown.\"\"\"\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n+\n+\n+    @client_cooldown.command(name='update')\n+    async def client_cooldown_update(\n+            self, ctx,\n+            command: converters.CommandConverter,\n+            rate: Optional[int] = None,\n+            per: Optional[float] = None,\n+            type: BucketTypeConverter = None):\n+        \"\"\"Update a command's cooldown.\"\"\"\n+        type: commands.BucketType\n+        command: commands.Command\n+\n+        # Fill missing arguments\n+        old_cool: commands.CooldownMapping = command._buckets\n+        if old_cool.valid:\n+            rate = old_cool._cooldown.rate if rate is None else rate\n+            per = old_cool._cooldown.per if per is None else per\n+            type = old_cool._cooldown.type if type is None else type\n+\n+        # Default arguments\n+        if type is None:\n+            type = commands.BucketType.default\n+\n+        # Check arguments\n+        if rate is None:\n+            return await ctx.send(\n+                'There is no cooldown; `rate` must be specified.',\n+                delete_after=10\n+            )\n+        elif rate < 1:\n+            return await ctx.send('`rate` cannot be below 1.', delete_after=10)\n+        elif per is None:\n+            return await ctx.send(\n+                'There is no cooldown; `per` must be specified.',\n+                delete_after=10\n+            )\n+        elif per < 0:\n+            return await ctx.send('`per` cannot be negative.', delete_after=10)\n+\n+        buckets = commands.CooldownMapping(commands.Cooldown(rate, per, type))\n+        command._buckets = buckets\n+\n+        await ctx.send(f'Updated cooldown for {command.name}.')\n+\n+\n+    @client_cooldown.command(name='reset')\n+    async def client_cooldown_reset(self, ctx,\n+                                    everyone: Optional[bool] = False,\n+                                    *, command: converters.CommandConverter):\n+        \"\"\"Reset a command's cooldown.\n+\n+everyone: If true, this will reset everyone's cooldown. Otherwise it only\n+resets your cooldown.\n+command: The name of the command to reset.\"\"\"\n+        command: commands.Command\n+\n+        if not command._buckets.valid:\n+            return await ctx.send('This command does not have a cooldown.',\n+                                  delete_after=10)\n+\n+        if everyone:\n+            buckets = command._buckets\n+            buckets._cache.clear()\n+        else:\n+            command.reset_cooldown(ctx)\n+\n+        await ctx.send(f'Resetted cooldown for {command.name}.')\n+\n+\n+    @client_cooldown.command(name='remove')\n+    async def client_cooldown_remove(\n+            self, ctx, *, command: converters.CommandConverter):\n+        \"\"\"Remove a command's cooldown.\"\"\"\n+        command: commands.Command\n \n+        if not command._buckets.valid:\n+            return await ctx.send('This command does not have a cooldown.',\n+                                  delete_after=10)\n \n-    @commands.command(name='cooldown')\n+        buckets = commands.CooldownMapping(None)\n+        command._buckets = buckets\n+\n+        await ctx.send(f'Removed cooldown for {command.name}.')\n+\n+\n+\n+\n+\n+    @commands.group(name='concurrency', invoke_without_command=True)\n     @checks.is_bot_admin()\n-    async def client_cooldown(self, ctx, *, command):\n-        \"\"\"Reset your cooldown for a command.\n+    async def client_concurrency(self, ctx):\n+        \"\"\"Modify a command's max concurrency.\"\"\"\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n+\n+\n+    @client_concurrency.command(name='update')\n+    async def client_concurrency_update(\n+            self, ctx,\n+            command: converters.CommandConverter,\n+            number: Optional[int] = None,\n+            per: Optional[BucketTypeConverter] = None,\n+            wait: bool = None):\n+        \"\"\"Update a command's concurrency limit.\"\"\"\n+        command: commands.Command\n+\n+        # Fill missing arguments\n+        old_con: commands.MaxConcurrency = command._max_concurrency\n+        if old_con is not None:\n+            number = old_con.number if number is None else number\n+            per = old_con.per if per is None else number\n+            wait = old_con.wait if wait is None else wait\n+\n+        # Default arguments\n+        if per is None:\n+            per = commands.BucketType.default\n+        if wait is None:\n+            wait = False\n+\n+        # Check arguments\n+        if number is None:\n+            return await ctx.send(\n+                'There is no concurrency limit; `number` must be specified.',\n+                delete_after=10\n+            )\n+        elif number < 1:\n+            return await ctx.send('`number` cannot be below 1.', delete_after=10)\n+\n+        con = commands.MaxConcurrency(number, per=per, wait=wait)\n+        command._max_concurrency = con\n+        # NOTE: no need to worry about race conditions since MaxConcurrency.release()\n+        # excepts KeyError if the bucket does not exist\n \n-Will reset cooldowns for all subcommands in a group.\"\"\"\n-        com = self.bot.get_command(command)\n+        await ctx.send(f'Updated concurrency limits for {command.name}.')\n \n-        if com is None:\n-            await ctx.send('Unknown command.')\n \n-        com.reset_cooldown(ctx)\n+    @client_concurrency.command(name='remove')\n+    async def client_concurrency_remove(self, ctx, *,\n+                                        command: converters.CommandConverter):\n+        \"\"\"Remove a command's max concurrency limit.\"\"\"\n+        command: commands.Command\n+\n+        if command._max_concurrency is None:\n+            return await ctx.send(\n+                'This command does not have a max concurrency limit.',\n+                delete_after=10\n+            )\n \n-        await ctx.send('Cooldown reset.')\n+        command._max_concurrency = None\n+        await ctx.send(f'Removed concurrency limits for {command.name}.')\n \n \n \n","add":152,"remove":16,"filename":"\/bot\/commands\/administrative.py","badparts":["        await ctx.send(f'Blocking for {x} seconds.')","        await ctx.send('Finished blocking.')","    @client_block.error","    async def client_block_error(self, ctx, error):","        error = getattr(error, 'original', error)","        if isinstance(error, checks.InvalidBotOwner):","            await ctx.send(get_denied_message())","    @commands.command(name='cooldown')","    async def client_cooldown(self, ctx, *, command):","        \"\"\"Reset your cooldown for a command.","Will reset cooldowns for all subcommands in a group.\"\"\"","        com = self.bot.get_command(command)","        if com is None:","            await ctx.send('Unknown command.')","        com.reset_cooldown(ctx)","        await ctx.send('Cooldown reset.')"],"goodparts":["        message = await ctx.send(f'Blocking for {x} seconds.')","        await message.edit(content='Finished blocking.')","    @commands.group(name='cooldown', invoke_without_command=True)","    @checks.is_bot_admin()","    async def client_cooldown(self, ctx):","        \"\"\"Modify a command's cooldown.\"\"\"","        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',","                       delete_after=6)","    @client_cooldown.command(name='update')","    async def client_cooldown_update(","            self, ctx,","            command: converters.CommandConverter,","            rate: Optional[int] = None,","            per: Optional[float] = None,","            type: BucketTypeConverter = None):","        \"\"\"Update a command's cooldown.\"\"\"","        type: commands.BucketType","        command: commands.Command","        old_cool: commands.CooldownMapping = command._buckets","        if old_cool.valid:","            rate = old_cool._cooldown.rate if rate is None else rate","            per = old_cool._cooldown.per if per is None else per","            type = old_cool._cooldown.type if type is None else type","        if type is None:","            type = commands.BucketType.default","        if rate is None:","            return await ctx.send(","                'There is no cooldown; `rate` must be specified.',","                delete_after=10","            )","        elif rate < 1:","            return await ctx.send('`rate` cannot be below 1.', delete_after=10)","        elif per is None:","            return await ctx.send(","                'There is no cooldown; `per` must be specified.',","                delete_after=10","            )","        elif per < 0:","            return await ctx.send('`per` cannot be negative.', delete_after=10)","        buckets = commands.CooldownMapping(commands.Cooldown(rate, per, type))","        command._buckets = buckets","        await ctx.send(f'Updated cooldown for {command.name}.')","    @client_cooldown.command(name='reset')","    async def client_cooldown_reset(self, ctx,","                                    everyone: Optional[bool] = False,","                                    *, command: converters.CommandConverter):","        \"\"\"Reset a command's cooldown.","everyone: If true, this will reset everyone's cooldown. Otherwise it only","resets your cooldown.","command: The name of the command to reset.\"\"\"","        command: commands.Command","        if not command._buckets.valid:","            return await ctx.send('This command does not have a cooldown.',","                                  delete_after=10)","        if everyone:","            buckets = command._buckets","            buckets._cache.clear()","        else:","            command.reset_cooldown(ctx)","        await ctx.send(f'Resetted cooldown for {command.name}.')","    @client_cooldown.command(name='remove')","    async def client_cooldown_remove(","            self, ctx, *, command: converters.CommandConverter):","        \"\"\"Remove a command's cooldown.\"\"\"","        command: commands.Command","        if not command._buckets.valid:","            return await ctx.send('This command does not have a cooldown.',","                                  delete_after=10)","        buckets = commands.CooldownMapping(None)","        command._buckets = buckets","        await ctx.send(f'Removed cooldown for {command.name}.')","    @commands.group(name='concurrency', invoke_without_command=True)","    async def client_concurrency(self, ctx):","        \"\"\"Modify a command's max concurrency.\"\"\"","        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',","                       delete_after=6)","    @client_concurrency.command(name='update')","    async def client_concurrency_update(","            self, ctx,","            command: converters.CommandConverter,","            number: Optional[int] = None,","            per: Optional[BucketTypeConverter] = None,","            wait: bool = None):","        \"\"\"Update a command's concurrency limit.\"\"\"","        command: commands.Command","        old_con: commands.MaxConcurrency = command._max_concurrency","        if old_con is not None:","            number = old_con.number if number is None else number","            per = old_con.per if per is None else number","            wait = old_con.wait if wait is None else wait","        if per is None:","            per = commands.BucketType.default","        if wait is None:","            wait = False","        if number is None:","            return await ctx.send(","                'There is no concurrency limit; `number` must be specified.',","                delete_after=10","            )","        elif number < 1:","            return await ctx.send('`number` cannot be below 1.', delete_after=10)","        con = commands.MaxConcurrency(number, per=per, wait=wait)","        command._max_concurrency = con","        await ctx.send(f'Updated concurrency limits for {command.name}.')","    @client_concurrency.command(name='remove')","    async def client_concurrency_remove(self, ctx, *,","                                        command: converters.CommandConverter):","        \"\"\"Remove a command's max concurrency limit.\"\"\"","        command: commands.Command","        if command._max_concurrency is None:","            return await ctx.send(","                'This command does not have a max concurrency limit.',","                delete_after=10","            )","        command._max_concurrency = None","        await ctx.send(f'Removed concurrency limits for {command.name}.')"]},{"diff":"\n     @commands.command(name='execute')\n     @checks.is_bot_owner()\n     async def client_execute(\n-            self, ctx, sendIOtoDM: typing.Optional[bool] = False, *, x: str):\n+            self, ctx, sendIOtoDM: Optional[bool] = False, *, x: str):\n         \"\"\"Run python code in an async condition.\n Graphs can be generated if a Figure is returned.\n \n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["            self, ctx, sendIOtoDM: typing.Optional[bool] = False, *, x: str):"],"goodparts":["            self, ctx, sendIOtoDM: Optional[bool] = False, *, x: str):"]},{"diff":"\n     async def client_clearsettingscache(self, ctx):\n         \"\"\"Clear the settings cache.\"\"\"\n         settings.clear_cache()\n-        await ctx.send('Cleared cache.')\n+        await ctx.send('Cleared cache.', delete_after=10)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["        await ctx.send('Cleared cache.')"],"goodparts":["        await ctx.send('Cleared cache.', delete_after=10)"]},{"diff":"\n     @commands.cooldown(2, 40, commands.BucketType.default)\n     async def client_presence(self, ctx):\n         \"\"\"Commands to change the bot's presence. Restricted to admins.\"\"\"\n-        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n \n \n     @client_presence.command(name='competing')\n","add":2,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')"],"goodparts":["        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',","                       delete_after=6)"]},{"diff":"\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(\n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["                await ctx.send('Unknown status given.')"],"goodparts":["                await ctx.send('Unknown status given.', delete_after=8)"]},{"diff":"\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(\n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["                await ctx.send('Unknown status given.')"],"goodparts":["                await ctx.send('Unknown status given.', delete_after=8)"]},{"diff":"\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(name='listening')\n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["                await ctx.send('Unknown status given.')"],"goodparts":["                await ctx.send('Unknown status given.', delete_after=8)"]},{"diff":"\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(\n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["                await ctx.send('Unknown status given.')"],"goodparts":["                await ctx.send('Unknown status given.', delete_after=8)"]},{"diff":"\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n     @client_presence.command(\n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["                await ctx.send('Unknown status given.')"],"goodparts":["                await ctx.send('Unknown status given.', delete_after=8)"]},{"diff":"\n         error = getattr(error, 'original', error)\n         if isinstance(error, commands.BadArgument):\n             if 'parse_status' in str(error):\n-                await ctx.send('Unknown status given.')\n+                await ctx.send('Unknown status given.', delete_after=8)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/administrative.py","badparts":["                await ctx.send('Unknown status given.')"],"goodparts":["                await ctx.send('Unknown status given.', delete_after=8)"]},{"diff":"\n         error = getattr(error, 'original', error)\n         if isinstance(error, AttributeError):\n             if \"'NoneType' object has no attribute\" in str(error):\n-                await ctx.send('I cannot find the given channel.')\n+                await ctx.send('I cannot find the given channel.', delete_after=8)\n         elif isinstance(error, discord.Forbidden):\n-            await ctx.send('I cannot access this given channel.')\n+            await ctx.send('I cannot access this given channel.', delete_after=8)\n+\n+\n+\n+\n+\n+    @commands.command(name='restart')\n+    @checks.is_bot_owner()\n+    async def client_restart(self, ctx):\n+        \"\"\"Restarts the bot.\"\"\"\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n+\n+        confirmed = await prompt.confirm(\n+            'Are you sure you want to RESTART the bot?')\n+\n+        if confirmed:\n+            await prompt.update('Restarting.', prompt.emoji_yes.color)\n+            send_restart_signal()\n+            print(f'Initiating restart by {get_user_for_log(ctx)}')\n+            await self.bot.logout()\n+        else:\n+            await prompt.update('Cancelled restart.', prompt.emoji_no.color)\n \n \n \n","add":23,"remove":2,"filename":"\/bot\/commands\/administrative.py","badparts":["                await ctx.send('I cannot find the given channel.')","            await ctx.send('I cannot access this given channel.')"],"goodparts":["                await ctx.send('I cannot find the given channel.', delete_after=8)","            await ctx.send('I cannot access this given channel.', delete_after=8)","    @commands.command(name='restart')","    @checks.is_bot_owner()","    async def client_restart(self, ctx):","        \"\"\"Restarts the bot.\"\"\"","        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())","        confirmed = await prompt.confirm(","            'Are you sure you want to RESTART the bot?')","        if confirmed:","            await prompt.update('Restarting.', prompt.emoji_yes.color)","            send_restart_signal()","            print(f'Initiating restart by {get_user_for_log(ctx)}')","            await self.bot.logout()","        else:","            await prompt.update('Cancelled restart.', prompt.emoji_no.color)"]},{"diff":"\n \n     @commands.command(\n         name='shutdown',\n-        brief='Shutdown the bot.',\n         aliases=('close', 'exit', 'quit', 'stop'))\n     @checks.is_bot_owner()\n     async def client_shutdown(self, ctx):\n-        \"\"\"Shuts down the bot.\"\"\"\n-        print('Shutting down')\n-        await ctx.send('Shutting down.')\n-        await self.bot.logout()\n+        \"\"\"Shutdown the bot.\"\"\"\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n+\n+        confirmed = await prompt.confirm(\n+            'Are you sure you want to SHUTDOWN the bot?')\n+\n+        if confirmed:\n+            await prompt.update('Shutting down.', prompt.emoji_yes.color)\n+            print(f'Initiating shutdown by {get_user_for_log(ctx)}')\n+            await self.bot.logout()\n+        else:\n+            await prompt.update('Cancelled shutdown.', prompt.emoji_no.color)\n","add":12,"remove":5,"filename":"\/bot\/commands\/administrative.py","badparts":["        brief='Shutdown the bot.',","        \"\"\"Shuts down the bot.\"\"\"","        print('Shutting down')","        await ctx.send('Shutting down.')","        await self.bot.logout()"],"goodparts":["        \"\"\"Shutdown the bot.\"\"\"","        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())","        confirmed = await prompt.confirm(","            'Are you sure you want to SHUTDOWN the bot?')","        if confirmed:","            await prompt.update('Shutting down.', prompt.emoji_yes.color)","            print(f'Initiating shutdown by {get_user_for_log(ctx)}')","            await self.bot.logout()","        else:","            await prompt.update('Cancelled shutdown.', prompt.emoji_no.color)"]}],"source":"\n\"\"\" The \"execute\" command is in part from RoboDanny which is released under MPL-2.0. See https:\/\/www.mozilla.org\/en-US\/MPL\/2.0\/ for full license details. \"\"\" import contextlib import io import textwrap import time import typing import discord from discord.ext import commands import matplotlib import matplotlib.pyplot as plt import numpy as np from bot import checks from bot import settings from bot import utils from bot.other import discordlogger def get_user_for_log(ctx): return f'{ctx.author}({ctx.author.id})' class Administrative(commands.Cog): qualified_name='Administrative' description='Administrative commands available for owners\/admins.' def __init__(self, bot): self.bot=bot self._last_result=None @commands.command(name='block') @checks.is_bot_owner() async def client_block(self, ctx, x: int=20): \"\"\"Block the operation of the bot.\"\"\" await ctx.send(f'Blocking for{x} seconds.') time.sleep(x) await ctx.send('Finished blocking.') @client_block.error async def client_block_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, checks.InvalidBotOwner): await ctx.send(get_denied_message()) @commands.command(name='cooldown') @checks.is_bot_admin() async def client_cooldown(self, ctx, *, command): \"\"\"Reset your cooldown for a command. Will reset cooldowns for all subcommands in a group.\"\"\" com=self.bot.get_command(command) if com is None: await ctx.send('Unknown command.') com.reset_cooldown(ctx) await ctx.send('Cooldown reset.') @staticmethod def cleanup_code(content): \"\"\"Automatically removes code blocks from the code. Based off of RoboDanny\/rewrite\/cogs\/admin.py. \"\"\" if content.startswith('```') and content.endswith('```'): return content.lstrip('```py').strip('```').strip() return content @commands.command(name='execute') @checks.is_bot_owner() async def client_execute( self, ctx, sendIOtoDM: typing.Optional[bool]=False, *, x: str): \"\"\"Run python code in an async condition. Graphs can be generated if a Figure is returned. Based off of https:\/\/repl.it\/@AllAwesome497\/ASB-DEV-again and RoboDanny.\"\"\" async def send(*args, **kwargs): if sendIOtoDM: return await ctx.author.send(*args, **kwargs) await ctx.send(*args, **kwargs) x=self.cleanup_code(x) to_compile=f'async def func():\\n{textwrap.indent(x, \" \")}' environment={ 'discord': discord, 'commands': commands, 'bot': self.bot, 'ctx': ctx, 'matplotlib': matplotlib, 'plt': plt, 'np': np, '_': self._last_result } log=f'Executing code by{get_user_for_log(ctx)}:\\n{to_compile}' discordlogger.get_logger().warning(log) print(log) try: exec(to_compile, environment) except Exception as e: return await ctx.send( 'Failed during compilation:\\n`{}`'.format( discord.utils.escape_markdown( f'{e.__class__.__name__}:{e}' ) ) ) f=io.StringIO() try: with contextlib.redirect_stdout(f): result=await environment['func']() except Exception: error_message=utils.exception_message() return await ctx.send(f'```py\\n{error_message}```') image=None if isinstance(result, matplotlib.figure.Figure): image=io.BytesIO() result.savefig( image, format='png', bbox_inches='tight', pad_inches=0) image.seek(0) image=discord.File(image, 'Graph.png') result=None out=f.getvalue() +f'{result}' *(result is not None) out=utils.truncate_message(out, 1991) if out: await send(f'```py\\n{out}```', file=image) elif image is not None: await send(file=image) @commands.command(name='clearsettingscache') @checks.is_bot_owner() async def client_clearsettingscache(self, ctx): \"\"\"Clear the settings cache.\"\"\" settings.clear_cache() await ctx.send('Cleared cache.') @commands.group(name='presence', invoke_without_command=True) @checks.is_bot_admin() @commands.cooldown(2, 40, commands.BucketType.default) async def client_presence(self, ctx): \"\"\"Commands to change the bot's presence. Restricted to admins.\"\"\" await ctx.send(f'Unknown{ctx.command.name} subcommand given.') @client_presence.command(name='competing') async def client_competing(self, ctx, status: utils.parse_status='online', *, title=None): \"\"\"Sets the competing message. status: The status to set for the bot. title: The title to show.\"\"\" if title is None: return await self.bot.change_presence(activity=None) activity=discord.Activity( name=title, type=discord.ActivityType.competing) await self.bot.change_presence( activity=activity, status=status) @client_competing.error async def client_competing_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, commands.BadArgument): if 'parse_status' in str(error): await ctx.send('Unknown status given.') @client_presence.command( name='playing') async def client_playing(self, ctx, status: utils.parse_status='online', *, title=None): \"\"\"Sets the playing message. status: The status to set for the bot. title: The title to show.\"\"\" if title is None: return await self.bot.change_presence(activity=None) game=discord.Game(name=title) await self.bot.change_presence( activity=game, status=status) @client_playing.error async def client_playing_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, commands.BadArgument): if 'parse_status' in str(error): await ctx.send('Unknown status given.') @client_presence.command( name='streaming') async def client_streaming(self, ctx, status: utils.parse_status='online', title=None, url='https:\/\/www.twitch.tv\/thegamecracks'): \"\"\"Sets the streaming message. status: The status to set for the bot. title: The title to show. Use \"quotations\" to specify the title. url: The url to link to when streaming. Defaults to \\ https:\/\/www.twitch.tv\/thegamecracks.\"\"\" if title is None: return await self.bot.change_presence(activity=None) game=discord.Streaming(name=title, url=url) await self.bot.change_presence( activity=game, status=status) @client_streaming.error async def client_streaming_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, commands.BadArgument): if 'parse_status' in str(error): await ctx.send('Unknown status given.') @client_presence.command(name='listening') async def client_listening(self, ctx, status: utils.parse_status='online', *, title=None): \"\"\"Sets the listening message. status: The status to set for the bot. title: The title to show.\"\"\" if title is None: return await self.bot.change_presence(activity=None) activity=discord.Activity( name=title, type=discord.ActivityType.listening) await self.bot.change_presence( activity=activity, status=status) @client_listening.error async def client_listening_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, commands.BadArgument): if 'parse_status' in str(error): await ctx.send('Unknown status given.') @client_presence.command( name='watching') async def client_watching(self, ctx, status: utils.parse_status='online', *, title=None): \"\"\"Sets the watching message. status: The status to set for the bot. title: The title to show.\"\"\" if title is None: return await self.bot.change_presence(activity=None) activity=discord.Activity( name=title, type=discord.ActivityType.watching) await self.bot.change_presence( activity=activity, status=status) @client_watching.error async def client_watching_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, commands.BadArgument): if 'parse_status' in str(error): await ctx.send('Unknown status given.') @client_presence.command( name='status', aliases=('state',)) @commands.cooldown(2, 40, commands.BucketType.default) async def client_status(self, ctx, status: utils.parse_status='online'): \"\"\"Sets the current status. Options: online, on idle, away dnd invisible, offline, off This removes any activity the bot currently has.\"\"\" await self.bot.change_presence(status=status) @client_status.error async def client_status_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, commands.BadArgument): if 'parse_status' in str(error): await ctx.send('Unknown status given.') @commands.command( name='reload') @checks.is_bot_owner() @commands.cooldown(2, 10, commands.BucketType.user) async def client_ext_reload(self, ctx, extension): \"\"\"Reload an extension. https:\/\/repl.it\/@AllAwesome497\/ASB-DEV-again used as reference.\"\"\" logger=discordlogger.get_logger() def reload(ext): try: self.bot.unload_extension(ext) except commands.errors.ExtensionNotFound: return 'Could not find the extension.' except commands.errors.NoEntryPointError: return 'This extension is missing a setup.' except commands.errors.ExtensionNotLoaded: pass try: self.bot.load_extension(ext) except(ModuleNotFoundError, commands.errors.ExtensionNotFound): return 'Could not find the extension.' except commands.errors.NoEntryPointError: return 'This extension is missing a setup.' except commands.errors.CommandInvokeError: return 'This extension failed to be reloaded.' if extension=='all': for ext in list(self.bot.extensions): result=reload(ext) if result is not None: return await ctx.send(result) else: logger.info( f'All extensions reloaded by{get_user_for_log(ctx)}') await ctx.send('Extensions have been reloaded.') else: logger.info(f'Attempting to reload{extension} extension ' f'by{get_user_for_log(ctx)}') result=reload(extension) if result is not None: await ctx.send(result) else: await ctx.send('Extension has been reloaded.') @commands.command( name='send') @checks.is_bot_admin() @commands.cooldown(2, 10, commands.BucketType.user) async def client_sendmessage(self, ctx, channelID, *, message): \"\"\"Sends a message to a given channel. Restricted to admins. BUG(2020\/06\/21): An uneven amount of colons will prevent custom emoji from being detected.\"\"\" def convert_emojis_in_message(message, guild): def partition_emoji(s, start=0): \"\"\"Find a substring encapsulated in colons and partition it, stripping the colons.\"\"\" left=s.find(':', start) right=s.find(':', left +1) if left==-1 or right==-1: return None return s[:left], s[left +1:right], s[right +1:] emojis={e.name: e for e in guild.emojis} parts=[] while message: search=partition_emoji(message) if search is None: parts.append(message) break left, e, message=search parts.append(left) parts.append(e) for i in range(1, len(parts), 2): name=parts[i] e=emojis.get(name) if e is not None: parts[i]=f'<:{name}:{e.id}>' return ''.join(parts) if channelID=='here': channel=ctx.channel else: channel=self.bot.get_channel(int(channelID)) message=convert_emojis_in_message(message, channel.guild) await channel.send(message) @client_sendmessage.error async def client_sendmessage_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, AttributeError): if \"'NoneType' object has no attribute\" in str(error): await ctx.send('I cannot find the given channel.') elif isinstance(error, discord.Forbidden): await ctx.send('I cannot access this given channel.') @commands.command( name='shutdown', brief='Shutdown the bot.', aliases=('close', 'exit', 'quit', 'stop')) @checks.is_bot_owner() async def client_shutdown(self, ctx): \"\"\"Shuts down the bot.\"\"\" print('Shutting down') await ctx.send('Shutting down.') await self.bot.logout() def setup(bot): bot.add_cog(Administrative(bot)) ","sourceWithComments":"\"\"\"\nThe \"execute\" command is in part from RoboDanny which is released under MPL-2.0.\nSee https:\/\/www.mozilla.org\/en-US\/MPL\/2.0\/ for full license details.\n\"\"\"\nimport contextlib\nimport io\nimport textwrap\nimport time\nimport typing\n\nimport discord\nfrom discord.ext import commands\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom bot import checks\nfrom bot import settings\nfrom bot import utils\nfrom bot.other import discordlogger\n\n\ndef get_user_for_log(ctx):\n    return f'{ctx.author} ({ctx.author.id})'\n\n\nclass Administrative(commands.Cog):\n    qualified_name = 'Administrative'\n    description = 'Administrative commands available for owners\/admins.'\n\n    def __init__(self, bot):\n        self.bot = bot\n        self._last_result = None  # Used in execute command\n\n\n\n\n\n    @commands.command(name='block')\n    @checks.is_bot_owner()\n    async def client_block(self, ctx, x: int = 20):\n        \"\"\"Block the operation of the bot.\"\"\"\n        await ctx.send(f'Blocking for {x} seconds.')\n        time.sleep(x)\n        await ctx.send('Finished blocking.')\n\n\n    @client_block.error\n    async def client_block_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, checks.InvalidBotOwner):\n            await ctx.send(get_denied_message())\n\n\n\n\n\n    @commands.command(name='cooldown')\n    @checks.is_bot_admin()\n    async def client_cooldown(self, ctx, *, command):\n        \"\"\"Reset your cooldown for a command.\n\nWill reset cooldowns for all subcommands in a group.\"\"\"\n        com = self.bot.get_command(command)\n\n        if com is None:\n            await ctx.send('Unknown command.')\n\n        com.reset_cooldown(ctx)\n\n        await ctx.send('Cooldown reset.')\n\n\n\n\n\n    @staticmethod\n    def cleanup_code(content):\n        \"\"\"Automatically removes code blocks from the code.\n\n        Based off of RoboDanny\/rewrite\/cogs\/admin.py.\n\n        \"\"\"\n        # remove ```py\\n``` or ```py```\n        if content.startswith('```') and content.endswith('```'):\n            return content.lstrip('```py').strip('```').strip()\n        return content\n\n\n    @commands.command(name='execute')\n    @checks.is_bot_owner()\n    async def client_execute(\n            self, ctx, sendIOtoDM: typing.Optional[bool] = False, *, x: str):\n        \"\"\"Run python code in an async condition.\nGraphs can be generated if a Figure is returned.\n\nBased off of https:\/\/repl.it\/@AllAwesome497\/ASB-DEV-again and RoboDanny.\"\"\"\n        async def send(*args, **kwargs):\n            # Send to either DM or channel based on sendIOtoDM\n            if sendIOtoDM:\n                return await ctx.author.send(*args, **kwargs)\n            await ctx.send(*args, **kwargs)\n\n        # Remove code blocks\n        x = self.cleanup_code(x)\n\n        # Compile the code as an async function\n        # See RoboDanny admin.py cog\n        to_compile = f'async def func():\\n{textwrap.indent(x, \"  \")}'\n\n        environment = {\n            'discord': discord,\n            'commands': commands,\n            'bot': self.bot,\n            'ctx': ctx,\n            'matplotlib': matplotlib,\n            'plt': plt,\n            'np': np,\n            '_': self._last_result\n        }\n\n        # Log before compilation\n        log = f'Executing code by {get_user_for_log(ctx)}:\\n {to_compile}'\n        discordlogger.get_logger().warning(log)\n        print(log)\n\n        try:\n            exec(to_compile, environment)\n        except Exception as e:\n            return await ctx.send(\n                'Failed during compilation:\\n`{}`'.format(\n                    discord.utils.escape_markdown(\n                        f'{e.__class__.__name__}: {e}'\n                    )\n                )\n            )\n\n        # Run code and store output\n        f = io.StringIO()\n        try:\n            with contextlib.redirect_stdout(f):\n                result = await environment['func']()\n        except Exception:\n            error_message = utils.exception_message()\n            return await ctx.send(f'```py\\n{error_message}```')\n\n        # If matplotlib figure was returned, generate an image from it\n        image = None\n        if isinstance(result, matplotlib.figure.Figure):\n            image = io.BytesIO()\n            result.savefig(\n                image, format='png', bbox_inches='tight', pad_inches=0)\n            image.seek(0)\n            image = discord.File(image, 'Graph.png')\n            result = None\n\n        # Get output and truncate it, and display result if its not None\n        out = f.getvalue() + f'{result}' * (result is not None)\n        out = utils.truncate_message(out, 1991)  # -9 to add code blocks\n\n        # Return output\n        if out:\n            await send(f'```py\\n{out}```', file=image)\n        elif image is not None:\n            await send(file=image)\n\n\n\n\n\n    @commands.command(name='clearsettingscache')\n    @checks.is_bot_owner()\n    async def client_clearsettingscache(self, ctx):\n        \"\"\"Clear the settings cache.\"\"\"\n        settings.clear_cache()\n        await ctx.send('Cleared cache.')\n\n\n\n\n\n    @commands.group(name='presence', invoke_without_command=True)\n    @checks.is_bot_admin()\n    @commands.cooldown(2, 40, commands.BucketType.default)\n    async def client_presence(self, ctx):\n        \"\"\"Commands to change the bot's presence. Restricted to admins.\"\"\"\n        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n\n\n    @client_presence.command(name='competing')\n    async def client_competing(self, ctx,\n            status: utils.parse_status = 'online', *, title=None):\n        \"\"\"Sets the competing message.\nstatus: The status to set for the bot.\ntitle: The title to show.\"\"\"\n        if title is None:\n            return await self.bot.change_presence(activity=None)\n\n        activity = discord.Activity(\n            name=title, type=discord.ActivityType.competing)\n\n        await self.bot.change_presence(\n            activity=activity, status=status)\n\n\n    @client_competing.error\n    async def client_competing_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, commands.BadArgument):\n            if 'parse_status' in str(error):\n                await ctx.send('Unknown status given.')\n\n\n    @client_presence.command(\n        name='playing')\n    async def client_playing(self, ctx,\n            status: utils.parse_status = 'online', *, title=None):\n        \"\"\"Sets the playing message.\nstatus: The status to set for the bot.\ntitle: The title to show.\"\"\"\n        if title is None:\n            return await self.bot.change_presence(activity=None)\n\n        game = discord.Game(name=title)\n\n        await self.bot.change_presence(\n            activity=game, status=status)\n\n\n    @client_playing.error\n    async def client_playing_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, commands.BadArgument):\n            if 'parse_status' in str(error):\n                await ctx.send('Unknown status given.')\n\n\n    @client_presence.command(\n        name='streaming')\n    async def client_streaming(self, ctx,\n        status: utils.parse_status = 'online',\n        title=None,\n            url='https:\/\/www.twitch.tv\/thegamecracks'):\n        \"\"\"Sets the streaming message.\nstatus: The status to set for the bot.\ntitle: The title to show. Use \"quotations\" to specify the title.\nurl: The url to link to when streaming. Defaults to \\\nhttps:\/\/www.twitch.tv\/thegamecracks .\"\"\"\n        if title is None:\n            return await self.bot.change_presence(activity=None)\n\n        game = discord.Streaming(name=title, url=url)\n\n        await self.bot.change_presence(\n            activity=game, status=status)\n\n\n    @client_streaming.error\n    async def client_streaming_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, commands.BadArgument):\n            if 'parse_status' in str(error):\n                await ctx.send('Unknown status given.')\n\n\n    @client_presence.command(name='listening')\n    async def client_listening(self, ctx,\n            status: utils.parse_status = 'online', *, title=None):\n        \"\"\"Sets the listening message.\nstatus: The status to set for the bot.\ntitle: The title to show.\"\"\"\n        if title is None:\n            return await self.bot.change_presence(activity=None)\n\n        activity = discord.Activity(\n            name=title, type=discord.ActivityType.listening)\n\n        await self.bot.change_presence(\n            activity=activity, status=status)\n\n\n    @client_listening.error\n    async def client_listening_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, commands.BadArgument):\n            if 'parse_status' in str(error):\n                await ctx.send('Unknown status given.')\n\n\n    @client_presence.command(\n        name='watching')\n    async def client_watching(self, ctx,\n            status: utils.parse_status = 'online', *, title=None):\n        \"\"\"Sets the watching message.\nstatus: The status to set for the bot.\ntitle: The title to show.\"\"\"\n        if title is None:\n            return await self.bot.change_presence(activity=None)\n\n        activity = discord.Activity(\n            name=title, type=discord.ActivityType.watching)\n\n        await self.bot.change_presence(\n            activity=activity, status=status)\n\n\n    @client_watching.error\n    async def client_watching_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, commands.BadArgument):\n            if 'parse_status' in str(error):\n                await ctx.send('Unknown status given.')\n\n\n    @client_presence.command(\n        name='status',\n        aliases=('state',))\n    @commands.cooldown(2, 40, commands.BucketType.default)\n    async def client_status(self, ctx, status: utils.parse_status = 'online'):\n        \"\"\"Sets the current status.\nOptions:\n    online, on\n    idle, away\n    dnd\n    invisible, offline, off\nThis removes any activity the bot currently has.\"\"\"\n        await self.bot.change_presence(status=status)\n\n\n    @client_status.error\n    async def client_status_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, commands.BadArgument):\n            if 'parse_status' in str(error):\n                await ctx.send('Unknown status given.')\n\n\n\n\n\n    @commands.command(\n        name='reload')\n    @checks.is_bot_owner()\n    @commands.cooldown(2, 10, commands.BucketType.user)\n    async def client_ext_reload(self, ctx, extension):\n        \"\"\"Reload an extension.\nhttps:\/\/repl.it\/@AllAwesome497\/ASB-DEV-again used as reference.\"\"\"\n        logger = discordlogger.get_logger()\n\n        def reload(ext):\n            # Unload extension if possible then load extension\n            try:\n                self.bot.unload_extension(ext)\n            except commands.errors.ExtensionNotFound:\n                return 'Could not find the extension.'\n            except commands.errors.NoEntryPointError:\n                return 'This extension is missing a setup.'\n            except commands.errors.ExtensionNotLoaded:\n                pass\n            try:\n                self.bot.load_extension(ext)\n            except (ModuleNotFoundError, commands.errors.ExtensionNotFound):\n                return 'Could not find the extension.'\n            except commands.errors.NoEntryPointError:\n                return 'This extension is missing a setup.'\n            except commands.errors.CommandInvokeError:\n                return 'This extension failed to be reloaded.'\n\n        if extension == 'all':\n            # NOTE: must cast dict into list as extensions is mutated\n            # during reloading\n            for ext in list(self.bot.extensions):\n                result = reload(ext)\n                if result is not None:\n                    return await ctx.send(result)\n            else:\n                logger.info(\n                    f'All extensions reloaded by {get_user_for_log(ctx)}')\n                await ctx.send('Extensions have been reloaded.')\n        else:\n            logger.info(f'Attempting to reload {extension} extension '\n                        f'by {get_user_for_log(ctx)}')\n            result = reload(extension)\n            if result is not None:\n                await ctx.send(result)\n            else:\n                await ctx.send('Extension has been reloaded.')\n\n\n\n\n\n    @commands.command(\n        name='send')\n    @checks.is_bot_admin()\n    @commands.cooldown(2, 10, commands.BucketType.user)\n    async def client_sendmessage(self, ctx, channelID, *, message):\n        \"\"\"Sends a message to a given channel. Restricted to admins.\n\nBUG (2020\/06\/21): An uneven amount of colons will prevent\n    custom emoji from being detected.\"\"\"\n\n        def convert_emojis_in_message(message, guild):\n\n            def partition_emoji(s, start=0):\n                \"\"\"Find a substring encapsulated in colons\n                and partition it, stripping the colons.\"\"\"\n                left = s.find(':', start)\n                right = s.find(':', left + 1)\n                if left == -1 or right == -1:\n                    return None\n                return s[:left], s[left + 1:right], s[right + 1:]\n\n            # NOTE: While not very memory efficient to create a dictionary\n            # of emojis, the send command is sparsely used\n            emojis = {e.name: e for e in guild.emojis}\n\n            # BUG: Emojis not separated from other words by spaces don't\n            # get seen\n##            word_list = message.split(' ')\n##\n##            for i, word in enumerate(word_list):\n##                if word.startswith(':') and word.endswith(':'):\n##                    word = word[1:-1]\n##\n##                    e = emojis.get(word, None)\n##\n##                    if e is not None:\n##                        # Emoji found; replace word with converted text\n##                        word_list[i] = '<:{}:{}>'.format(word, e.id)\n##\n##            return ' '.join(word_list)\n\n            # BUG: this revision breaks when there are an odd number of colons\n            # NOTE: After this, `message` will no longer contain\n            # the original message\n            parts = []\n            while message:\n                search = partition_emoji(message)\n                if search is None:\n                    parts.append(message)\n                    break\n                left, e, message = search\n                parts.append(left)\n                parts.append(e)\n\n            # Iterate through the emojis found in the message\n            # NOTE: `parts` should always have an odd length\n            # (1 for no emoji, then 2 * [# of emoji] + 1)\n            for i in range(1, len(parts), 2):\n                name = parts[i]\n                # Search for custom emoji with matching names\n                e = emojis.get(name)\n\n                if e is not None:\n                    # Emoji found; replace word with converted text\n                    parts[i] = f'<:{name}:{e.id}>'\n\n            return ''.join(parts)\n\n        if channelID == 'here':\n            channel = ctx.channel\n        else:\n            channel = self.bot.get_channel(int(channelID))\n        message = convert_emojis_in_message(message, channel.guild)\n        # NOTE: Emoji conversion could result in an oversized message.\n        await channel.send(message)\n\n\n    @client_sendmessage.error\n    async def client_sendmessage_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, AttributeError):\n            if \"'NoneType' object has no attribute\" in str(error):\n                await ctx.send('I cannot find the given channel.')\n        elif isinstance(error, discord.Forbidden):\n            await ctx.send('I cannot access this given channel.')\n\n\n\n\n\n    @commands.command(\n        name='shutdown',\n        brief='Shutdown the bot.',\n        aliases=('close', 'exit', 'quit', 'stop'))\n    @checks.is_bot_owner()\n    async def client_shutdown(self, ctx):\n        \"\"\"Shuts down the bot.\"\"\"\n        print('Shutting down')\n        await ctx.send('Shutting down.')\n        await self.bot.logout()\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Administrative(bot))\n"},"\/bot\/commands\/background.py":{"changes":[{"diff":"\n # Since the settings file is used as an argument to decorators which are\n # evaluated at runtime, the file must be set up\n class Tasks(commands.Cog):\n+    \"\"\"Commands for controlling background tasks.\"\"\"\n     qualified_name = 'Tasks'\n-    description = 'Commands for controlling background tasks.'\n \n     def __init__(self, bot):\n         self.bot = bot\n","add":1,"remove":1,"filename":"\/bot\/commands\/background.py","badparts":["    description = 'Commands for controlling background tasks.'"],"goodparts":["    \"\"\"Commands for controlling background tasks.\"\"\""]},{"diff":"\n     @checks.is_bot_admin()\n     async def random_presence_toggle(self, ctx, toggle: bool):\n         if toggle:\n-            try:\n+            if not self.random_precense.is_running():\n                 self.random_presence.start()\n-            except RuntimeError:\n-                return await ctx.send('The task is already running.')\n+            else:\n+                return await ctx.send(\n+                    'The task is already running.', delete_after=6)\n \n             min_delay = settings.get_setting('bgtask_RandomPresenceMinDelay')\n             max_delay = settings.get_setting('bgtask_RandomPresenceMaxDelay')\n","add":4,"remove":3,"filename":"\/bot\/commands\/background.py","badparts":["            try:","            except RuntimeError:","                return await ctx.send('The task is already running.')"],"goodparts":["            if not self.random_precense.is_running():","            else:","                return await ctx.send(","                    'The task is already running.', delete_after=6)"]},{"diff":"\n                     max_delay\n                 )\n             )\n-        else:\n+        elif self.random_precense.is_running():\n             self.random_presence.cancel()\n             print('Disabled random presence')\n             await ctx.send('Turned off random presence changes.')\n+        else:\n+            await ctx.send('The task is not running.', delete_after=6)","add":3,"remove":1,"filename":"\/bot\/commands\/background.py","badparts":["        else:"],"goodparts":["        elif self.random_precense.is_running():","        else:","            await ctx.send('The task is not running.', delete_after=6)"]}],"source":"\nimport asyncio import random import time import discord from discord.ext import commands, tasks from bot import checks from bot import settings from bot import utils class Tasks(commands.Cog): qualified_name='Tasks' description='Commands for controlling background tasks.' def __init__(self, bot): self.bot=bot self.list_guilds.start() if settings.get_setting('bgtask_RandomPresenceOnStartup'): self.random_presence.start() def cog_unload(self): self.list_guilds.cancel() self.random_presence.cancel() @staticmethod def timestamp(): \"\"\"Show the current time.\"\"\" return time.strftime( 'Timestamp: %c', time.localtime() ) @tasks.loop(seconds=settings.get_setting('bgtask_ListGuildsDelay')) async def list_guilds(self): \"\"\"Periodically lists all guilds the bot is in.\"\"\" print(self.timestamp()) print('Current guilds:') for guild in self.bot.guilds: print(guild.name) print() @list_guilds.before_loop async def before_list_guilds(self): await self.bot.wait_until_ready() @tasks.loop() async def random_presence(self): \"\"\"Periodically change current presence. Format: { 'status': 'online', 'activity': 'playing', 'title': 'something', 'url': 'DEFAULT_STREAMING_URL' } \"\"\" def print_presence(pres): activity=pres.get('activity') title=pres.get('title') url=pres.get('url') status=pres.get('status') message=['Random Presence: '] if activity is None: message.append('cleared activity') elif activity=='listening': message.append(f'listening to{title}') elif activity=='playing': message.append(f'playing{title}') elif activity=='streaming': message.append(f'streaming{title} to{url}') elif activity=='watching': message.append(f'watching{title}') elif activity=='competing': message.append(f'competing in{title}') if status==discord.Status.online: message.append(', status: online') elif status==discord.Status.idle: message.append(', status: idle') elif status==discord.Status.dnd: message.append(', status: dnd') elif status==discord.Status.invisible: message.append(', status: invisible') print(''.join(message)) while not self.bot.is_closed(): try: pres=random.choice( settings.get_setting('bgtask_RandomPresences') ) except IndexError: print('No random presences in settings; ' 'ending random presence task') return status=pres.get('status') if status is not None: status=utils.parse_status(status) elif random.randint(1, 100) <=settings.get_setting( 'bgtask_RandomPresenceRandomStatusChance'): status=random.choice( (discord.Status.idle, discord.Status.dnd) ) else: status=discord.Status.online activity=pres.get('activity') if activity=='listening': activity=discord.Activity( name=pres['title'], type=discord.ActivityType.listening) elif activity=='playing': activity=discord.Game(name=pres['title']) elif activity=='streaming': if 'url' not in pres: url=settings.get_setting('default_StreamingURL') activity=discord.Streaming( name=pres['title'], url=url) elif activity=='watching': activity=discord.Activity( name=pres['title'], type=discord.ActivityType.watching) elif activity=='competing': activity=discord.Activity( name=pres['title'], type=discord.ActivityType.competing) print(self.timestamp()) print_presence(pres) await self.bot.change_presence( activity=activity, status=status) min_delay=settings.get_setting('bgtask_RandomPresenceMinDelay') max_delay=settings.get_setting('bgtask_RandomPresenceMaxDelay') await asyncio.sleep(random.randint( min_delay, max_delay)) @random_presence.before_loop async def before_random_presence(self): await self.bot.wait_until_ready() @commands.command( name='randompresence', brief='Toggles random presence changes.', aliases=('randpres', 'randpresence')) @checks.is_bot_admin() async def random_presence_toggle(self, ctx, toggle: bool): if toggle: try: self.random_presence.start() except RuntimeError: return await ctx.send('The task is already running.') min_delay=settings.get_setting('bgtask_RandomPresenceMinDelay') max_delay=settings.get_setting('bgtask_RandomPresenceMaxDelay') print('Enabled random presence') await ctx.send( 'Now randomly changing presence ' 'every{}-{} seconds.'.format( min_delay, max_delay ) ) else: self.random_presence.cancel() print('Disabled random presence') await ctx.send('Turned off random presence changes.') def setup(bot): bot.add_cog(Tasks(bot)) ","sourceWithComments":"import asyncio\nimport random\nimport time\n\nimport discord\nfrom discord.ext import commands, tasks\n\nfrom bot import checks\nfrom bot import settings\nfrom bot import utils\n\n\n# Since the settings file is used as an argument to decorators which are\n# evaluated at runtime, the file must be set up\nclass Tasks(commands.Cog):\n    qualified_name = 'Tasks'\n    description = 'Commands for controlling background tasks.'\n\n    def __init__(self, bot):\n        self.bot = bot\n\n        self.list_guilds.start()\n        if settings.get_setting('bgtask_RandomPresenceOnStartup'):\n            self.random_presence.start()\n\n    def cog_unload(self):\n        self.list_guilds.cancel()\n        self.random_presence.cancel()\n\n    @staticmethod\n    def timestamp():\n        \"\"\"Show the current time.\"\"\"\n        return time.strftime(\n            'Timestamp: %c',\n            time.localtime()\n        )\n\n\n\n\n\n    @tasks.loop(seconds=settings.get_setting('bgtask_ListGuildsDelay'))\n    async def list_guilds(self):\n        \"\"\"Periodically lists all guilds the bot is in.\"\"\"\n        print(self.timestamp())\n        print('Current guilds:')\n        for guild in self.bot.guilds:\n            print(guild.name)\n        print()\n\n    @list_guilds.before_loop\n    async def before_list_guilds(self):\n        await self.bot.wait_until_ready()\n\n\n\n\n\n    @tasks.loop()\n    async def random_presence(self):\n        \"\"\"Periodically change current presence.\n\n        Format:\n            {\n                'status':   'online',\n                'activity': 'playing',\n                'title':    'something',\n                'url':      'DEFAULT_STREAMING_URL'  # only-when-streaming\n            }\n\n        \"\"\"\n        def print_presence(pres):\n            activity = pres.get('activity')\n            title = pres.get('title')\n            url = pres.get('url')\n            status = pres.get('status')\n            message = ['Random Presence: ']\n            if activity is None:\n                message.append('cleared activity')\n            elif activity == 'listening':\n                message.append(f'listening to {title}')\n            elif activity == 'playing':\n                message.append(f'playing {title}')\n            elif activity == 'streaming':\n                message.append(f'streaming {title} to {url}')\n            elif activity == 'watching':\n                message.append(f'watching {title}')\n            elif activity == 'competing':\n                message.append(f'competing in {title}')\n\n            if status == discord.Status.online:\n                message.append(', status: online')\n            elif status == discord.Status.idle:\n                message.append(', status: idle')\n            elif status == discord.Status.dnd:\n                message.append(', status: dnd')\n            elif status == discord.Status.invisible:\n                message.append(', status: invisible')\n\n            print(''.join(message))\n\n        while not self.bot.is_closed():\n            try:\n                pres = random.choice(\n                    settings.get_setting('bgtask_RandomPresences')\n                )\n            except IndexError:\n                print('No random presences in settings; '\n                      'ending random presence task')\n                return\n\n            # Parse status, otherwise use online\/randomly pick one\n            status = pres.get('status')\n            if status is not None:\n                status = utils.parse_status(status)\n            elif random.randint(1, 100) <= settings.get_setting(\n                    'bgtask_RandomPresenceRandomStatusChance'):\n                status = random.choice(\n                    (discord.Status.idle, discord.Status.dnd)\n                )\n            else:\n                status = discord.Status.online\n\n            # Parse activity\n            activity = pres.get('activity')\n            if activity == 'listening':\n                activity = discord.Activity(\n                    name=pres['title'], type=discord.ActivityType.listening)\n            elif activity == 'playing':\n                activity = discord.Game(name=pres['title'])\n            elif activity == 'streaming':\n                if 'url' not in pres:\n                    url = settings.get_setting('default_StreamingURL')\n                activity = discord.Streaming(\n                    name=pres['title'], url=url)\n            elif activity == 'watching':\n                activity = discord.Activity(\n                    name=pres['title'], type=discord.ActivityType.watching)\n            elif activity == 'competing':\n                activity = discord.Activity(\n                    name=pres['title'], type=discord.ActivityType.competing)\n\n            # Change presence\n            print(self.timestamp())\n            print_presence(pres)\n            await self.bot.change_presence(\n                activity=activity, status=status)\n\n            # Sleep\n            min_delay = settings.get_setting('bgtask_RandomPresenceMinDelay')\n            max_delay = settings.get_setting('bgtask_RandomPresenceMaxDelay')\n            await asyncio.sleep(random.randint(\n                min_delay, max_delay))\n\n    @random_presence.before_loop\n    async def before_random_presence(self):\n        await self.bot.wait_until_ready()\n\n    @commands.command(\n        name='randompresence',\n        brief='Toggles random presence changes.',\n        aliases=('randpres', 'randpresence'))\n    @checks.is_bot_admin()\n    async def random_presence_toggle(self, ctx, toggle: bool):\n        if toggle:\n            try:\n                self.random_presence.start()\n            except RuntimeError:\n                return await ctx.send('The task is already running.')\n\n            min_delay = settings.get_setting('bgtask_RandomPresenceMinDelay')\n            max_delay = settings.get_setting('bgtask_RandomPresenceMaxDelay')\n            print('Enabled random presence')\n            await ctx.send(\n                'Now randomly changing presence '\n                'every {}-{} seconds.'.format(\n                    min_delay,\n                    max_delay\n                )\n            )\n        else:\n            self.random_presence.cancel()\n            print('Disabled random presence')\n            await ctx.send('Turned off random presence changes.')\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Tasks(bot))\n"},"\/bot\/commands\/ciphers.py":{"changes":[{"diff":"\n \n \n class Ciphers(commands.Cog):\n+    \"\"\"Commands for encoding\/decoding text.\"\"\"\n     qualified_name = 'Ciphers'\n-    description = 'Commands for encoding\/decoding text.'\n \n     def __init__(self, bot):\n         self.bot = bot\n","add":1,"remove":1,"filename":"\/bot\/commands\/ciphers.py","badparts":["    description = 'Commands for encoding\/decoding text.'"],"goodparts":["    \"\"\"Commands for encoding\/decoding text.\"\"\""]},{"diff":"\n This will be the ciphertext.\"\"\"\n         # Test if key is in valid range\n         if key < 2 or key > len(string) \/\/ 2:\n-            return await ctx.send('Key is out of range.')\n+            return await ctx.send('Key is out of range.', delete_after=8)\n \n         await ctx.send(self.ciphercolumnar(key, string))\n \n","add":1,"remove":1,"filename":"\/bot\/commands\/ciphers.py","badparts":["            return await ctx.send('Key is out of range.')"],"goodparts":["            return await ctx.send('Key is out of range.', delete_after=8)"]},{"diff":"\n         brief='The One-time Pad Cipher.',\n         aliases=('otpc',))\n     @commands.cooldown(1, 3, commands.BucketType.member)\n-    async def client_cipherotp(self, ctx, mode: str, text: str, key: str):\n+    async def client_cipherotp(self, ctx, mode: commands.clean_content,\n+                               text: str, key: str):\n         \"\"\"Cipher\/decipher alphanumeric text (excluding spaces) \\\n using the one-time pad cipher.\n+\n mode: Indicate whether to cipher or decipher the text\n- (\"cipher\"\/\"ci\", \"decipher\"\/\"de\").\n+ (\"encode\"\/\"en\", \"decode\"\/\"de\").\n text: The text to cipher\/decipher.\n key: The one time key to use.\"\"\"\n         mode = mode.casefold()\n \n-        if mode in ('cipher', 'ci'):\n+        if mode in ('encode', 'en'):\n             mode = False\n-        elif mode in ('decipher', 'de'):\n+        elif mode in ('decode', 'de'):\n             mode = True\n         else:\n-            return await ctx.send('Mode must be either \"cipher\" or \"decipher\"')\n+            return await ctx.send('Unknown mode \"{mode}\"', delete_after=6)\n \n         await ctx.send(self.cipherotp(text, key, mode))\n \n","add":7,"remove":5,"filename":"\/bot\/commands\/ciphers.py","badparts":["    async def client_cipherotp(self, ctx, mode: str, text: str, key: str):"," (\"cipher\"\/\"ci\", \"decipher\"\/\"de\").","        if mode in ('cipher', 'ci'):","        elif mode in ('decipher', 'de'):","            return await ctx.send('Mode must be either \"cipher\" or \"decipher\"')"],"goodparts":["    async def client_cipherotp(self, ctx, mode: commands.clean_content,","                               text: str, key: str):"," (\"encode\"\/\"en\", \"decode\"\/\"de\").","        if mode in ('encode', 'en'):","        elif mode in ('decode', 'de'):","            return await ctx.send('Unknown mode \"{mode}\"', delete_after=6)"]},{"diff":"\n         brief='The morse code encrypter\/decrypter.',\n         aliases=('morse', 'mc', 'mcode'))\n     @commands.cooldown(1, 3, commands.BucketType.member)\n-    async def client_morsecode(self, ctx,\n-        mode: str, spacing: str, *, string: str):\n+    async def client_morsecode(\n+            self, ctx, mode: commands.clean_content,\n+            spacing: commands.clean_content, *, string: str):\n         \"\"\"Translates text to morse code and back.\n-mode: Either \"encode\"\/\"en\" or \"decode\"\/\"de\". Selects between encoding and decoding.\n-spacing: Either \"space\"\/\"spaces\" or \"bar\"\/\"bars\". Selects between using \" \"\/\" \/ \" and \"|\"\/\"||\" to show letter and word gaps.\n-string: The text or morse code to encrypt\/decrypt.\n Allowed characters:\n     abcdefghijklmnopqrstuvwxyz 0123456789,;.:?!()+-\/=@&_'\"\n Prosigns that are encoded and decoded cleanly:\n","add":3,"remove":5,"filename":"\/bot\/commands\/ciphers.py","badparts":["    async def client_morsecode(self, ctx,","        mode: str, spacing: str, *, string: str):","mode: Either \"encode\"\/\"en\" or \"decode\"\/\"de\". Selects between encoding and decoding.","spacing: Either \"space\"\/\"spaces\" or \"bar\"\/\"bars\". Selects between using \" \"\/\" \/ \" and \"|\"\/\"||\" to show letter and word gaps.","string: The text or morse code to encrypt\/decrypt."],"goodparts":["    async def client_morsecode(","            self, ctx, mode: commands.clean_content,","            spacing: commands.clean_content, *, string: str):"]},{"diff":"\n     <BT>  New paragraph           -> =\n     <KN>  Invite specific station -> (\n     <SN>  Understood (alternate form <VE> can be used, but decodes to <SN>)\n-Other characters will be passed through.\"\"\"\n+Other characters will be passed through.\n+\n+mode: Either \"encode\"\/\"en\" or \"decode\"\/\"de\". Selects between encoding and decoding.\n+spacing: Either \"space\"\/\"spaces\" or \"bar\"\/\"bars\". Selects between using \" \"\/\" \/ \" and \"|\"\/\"||\" to show letter and word gaps.\n+string: The text or morse code to encrypt\/decrypt.\"\"\"\n         mode = mode.casefold()\n         spacing = spacing.casefold()\n \n","add":5,"remove":1,"filename":"\/bot\/commands\/ciphers.py","badparts":["Other characters will be passed through.\"\"\""],"goodparts":["Other characters will be passed through.","mode: Either \"encode\"\/\"en\" or \"decode\"\/\"de\". Selects between encoding and decoding.","spacing: Either \"space\"\/\"spaces\" or \"bar\"\/\"bars\". Selects between using \" \"\/\" \/ \" and \"|\"\/\"||\" to show letter and word gaps.","string: The text or morse code to encrypt\/decrypt.\"\"\""]},{"diff":"\n         elif mode in ('decode', 'de'):\n             decoding = True\n         else:\n-            raise ValueError(f'Unknown mode {mode!r}')\n+            return await ctx.send(f'Unknown mode \"{mode}\"', delete_after=6)\n \n         if spacing in ('space', 'spaces'):\n             character_gap = ' '\n","add":1,"remove":1,"filename":"\/bot\/commands\/ciphers.py","badparts":["            raise ValueError(f'Unknown mode {mode!r}')"],"goodparts":["            return await ctx.send(f'Unknown mode \"{mode}\"', delete_after=6)"]},{"diff":"\n             character_gap = '|'\n             space_char = '||'\n         else:\n-            raise ValueError(f'Unknown spacing {spacing!r}')\n+            return await ctx.send(\n+                f'Unknown spacing \"{spacing}\"', delete_after=6)\n \n         message = self.morsecode(\n             decoding, string,\n","add":2,"remove":1,"filename":"\/bot\/commands\/ciphers.py","badparts":["            raise ValueError(f'Unknown spacing {spacing!r}')"],"goodparts":["            return await ctx.send(","                f'Unknown spacing \"{spacing}\"', delete_after=6)"]},{"diff":"\n         await ctx.send(f'```\\n{message}```')\n \n \n-    @client_morsecode.error\n-    async def client_morsecode_error(self, ctx, error):\n-        error = getattr(error, 'original', error)\n-        if isinstance(error, ValueError):\n-            await ctx.send(str(error))\n-\n-\n     @commands.command(\n         name='morsecodetable',\n         brief='The interational morse code table.',\n","add":0,"remove":7,"filename":"\/bot\/commands\/ciphers.py","badparts":["    @client_morsecode.error","    async def client_morsecode_error(self, ctx, error):","        error = getattr(error, 'original', error)","        if isinstance(error, ValueError):","            await ctx.send(str(error))"],"goodparts":[]},{"diff":"\n         name='vigenerecipher',\n         brief='The Vigenere Cipher.')\n     @commands.cooldown(1, 3, commands.BucketType.member)\n-    async def client_vigenerecipher(self, ctx,\n-        mode: str, key: str, *, text: str):\n+    async def client_vigenerecipher(\n+            self, ctx, mode: commands.clean_content, key: str, *, text: str):\n         \"\"\"Encrypt.\n+\n mode: Either \"encrypt\"\/\"en\" or \"decrypt\"\/\"de\". Selects between encrypting and decrypting.\n key: The key to use.\n text: The text to encrypt\/decrypt.\"\"\"\n","add":3,"remove":2,"filename":"\/bot\/commands\/ciphers.py","badparts":["    async def client_vigenerecipher(self, ctx,","        mode: str, key: str, *, text: str):"],"goodparts":["    async def client_vigenerecipher(","            self, ctx, mode: commands.clean_content, key: str, *, text: str):"]},{"diff":"\n         elif mode in ('decrypt', 'de'):\n             decrypting = True\n         else:\n-            raise ValueError(f'Unknown mode {mode!r}')\n+            return await ctx.send(f'Unknown mode \"{mode}\"', delete_after=6)\n \n         await ctx.send(\n             '```' + self.ciphervigenere(text, key, decrypting) + '```')\n \n \n-    @client_vigenerecipher.error\n-    async def client_vigenerecipher_error(self, ctx, error):\n-        error = getattr(error, 'original', error)\n-        if isinstance(error, ValueError):\n-            await ctx.send(str(error))\n-\n","add":1,"remove":7,"filename":"\/bot\/commands\/ciphers.py","badparts":["            raise ValueError(f'Unknown mode {mode!r}')","    @client_vigenerecipher.error","    async def client_vigenerecipher_error(self, ctx, error):","        error = getattr(error, 'original', error)","        if isinstance(error, ValueError):","            await ctx.send(str(error))"],"goodparts":["            return await ctx.send(f'Unknown mode \"{mode}\"', delete_after=6)"]}],"source":"\nimport itertools import string from discord.ext import commands from bot import utils CIPHER_ATBASH_TABLE=str.maketrans( string.ascii_letters, string.ascii_lowercase[::-1] +string.ascii_uppercase[::-1]) CIPHER_OTP_CHARS='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' MORSECODE_DICTIONARY_STRING=\"\"\"\\ Source: https:\/\/morsecode.world\/international\/morse.html \"a\":.- \"b\": -... \"c\": -.-. \"d\": -.. \"e\":. \"f\":..-. \"g\": --. \"h\":.... \"i\":.. \"j\":.--- \"k\": -.- \"l\":.-.. \"m\": -- \"n\": -. \"o\": --- \"p\":.--. \"q\": --.- \"r\":.-. \"s\":... \"t\": - \"u\":..- \"v\":...- \"w\":.-- \"x\": -..- \"y\": -.-- \"z\": --.. \"0\": ----- \"1\":.---- \"2\":..--- \"3\":...-- \"4\":....- \"5\":..... \"6\": -.... \"7\": --... \"8\": ---.. \"9\": ----. \",\": --..-- \";\": -.-.-. \".\":.-.-.- \":\": ---... \"?\":..--.. \"!\": -.-.-- \"(\": -.--. \")\": -.--.- \"+\":.-.-. \"-\": -....- \"\/\": -..-. \"=\": -...- \"@\":.--.-. \"&\":.-... \"_\":..--.- \"'\":.----. '\"':.-..-. <new line>:.-.- \"<AA>\":.-.- New line(\"\\\\n\") \"<AR>\":.-.-. End of message(\"+\") \"<AS>\":.-... Wait(\"&\") \"<BK>\": -...-.- Break \"<BT>\": -...- New paragraph(\"=\") \"<CL>\": -.-..-.. Going off the air(clear) \"<CT>\": -.-.- Start copying \"<DO>\": -..--- Change to wabun code \"<KN>\": -.--. Invite specific station(\"(\") \"<SK>\":...-.- End of transmission \"<SN>\":...-. Understood(can also be read as <VE>) \"<SOS>\":...---... Distress message\"\"\" MORSECODE_DICTIONARY={ ':': '---...', ',': '--..--', ')': '-.--.-', '!': '-.-.--', ';': '-.-.-.', '-': '-....-', \"'\": '.----.', '@': '.--.-.', '.': '.-.-.-', '\"': '.-..-.', '_': '..--.-', '?': '..--..', '(': '-.--.', '\/': '-..-.', '=': '-...-', '+': '.-.-.', '&': '.-...', '0': '-----', '9': '----.', '8': '---..', '7': '--...', '6': '-....', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', 'q': '--.-', 'z': '--..', 'y': '-.--', 'c': '-.-.', 'x': '-..-', 'b': '-...', 'j': '.---', 'p': '.--.', '\\n': '.-.-', 'l': '.-..', 'f': '..-.', 'v': '...-', 'h': '....', 'o': '---', 'g': '--.', 'k': '-.-', 'd': '-..', 'w': '.--', 'r': '.-.', 'u': '..-', 's': '...', 'm': '--', 'n': '-.', 'a': '.-', 'i': '..', 't': '-', 'e': '.', } MORSECODE_DICTIONARY_INVERTED={v: k for k, v in MORSECODE_DICTIONARY.items()} MORSECODE_PLACEHOLDERS=str.maketrans({'.': '\u25cf', '-': '\u2501'}) MORSECODE_PLACEHOLDERS_INVERTED=str.maketrans( {v: k for k, v in MORSECODE_PLACEHOLDERS.items()} ) MORSECODE_PROSIGNS={ '<SOS>': '\u25cf\u25cf\u25cf\u2501\u2501\u2501\u25cf\u25cf\u25cf', '<CL>': '\u2501\u25cf\u2501\u25cf\u25cf\u2501\u25cf\u25cf', '<BK>': '\u2501\u25cf\u25cf\u25cf\u2501\u25cf\u2501', '<DO>': '\u2501\u25cf\u25cf\u2501\u2501\u2501', '<SK>': '\u25cf\u25cf\u25cf\u2501\u25cf\u2501', '<CT>': '\u2501\u25cf\u2501\u25cf\u2501', '<VE>': '\u25cf\u25cf\u25cf\u2501\u25cf', '<SN>': '\u25cf\u25cf\u25cf\u2501\u25cf', } MORSECODE_PROSIGNS_INVERTED={ v.translate(MORSECODE_PLACEHOLDERS_INVERTED): k for k, v in MORSECODE_PROSIGNS.items() } MORSECODE_PROSIGNS_ENCODE_ONLY={ '<KN>': '\u2501\u25cf\u2501\u2501\u25cf', '<BT>': '\u2501\u25cf\u25cf\u25cf\u2501', '<AR>': '\u25cf\u2501\u25cf\u2501\u25cf', '<AS>': '\u25cf\u2501\u25cf\u25cf\u25cf', '<AA>': '\u25cf\u2501\u25cf\u2501', } class Ciphers(commands.Cog): qualified_name='Ciphers' description='Commands for encoding\/decoding text.' def __init__(self, bot): self.bot=bot @staticmethod def ciphercaesar(shift: int, text: str): alphabet=string.ascii_lowercase ciphertext=[] for char in text: uppercase=char.isupper() char=char.lower() if char in alphabet: char=alphabet[(ord(char) -97 +shift) % 26] if uppercase: char=char.upper() ciphertext.append(char) else: ciphertext.append(char) return ''.join(ciphertext) @commands.command( name='caesarcipher', brief='The Caesar Cipher.', aliases=('ciphercaesar', 'caesarcode', 'caesarshift')) @commands.cooldown(2, 5, commands.BucketType.member) async def client_ciphercaesar(self, ctx, shift: int, *, string: str): \"\"\"Takes an amount of letters to shift and a string. shift: An integer amount of letters to shift. Can be a negative integer. string: A string to cipher.\"\"\" await ctx.send(self.ciphercaesar(shift, string)) @staticmethod def cipheratbash(string: str): return string.translate(CIPHER_ATBASH_TABLE) @commands.command( name='atbashcipher', brief='The Atbash Cipher.', aliases=('atbcipher', 'atbc', 'atbash')) @commands.cooldown(1, 3, commands.BucketType.member) async def client_atbash(self, ctx, *, string: str): \"\"\"Takes a string and maps each letter to the reverse alphabet.\"\"\" await ctx.send(self.cipheratbash(string)) @commands.command( name='reversecipher', brief='The Reverse Cipher.', aliases=('reverse',)) async def client_cipherreverse(self, ctx, *, string: str): \"\"\"Takes a string and reverses it. string: A string to cipher.\"\"\" result=string[::-1] await ctx.send(result) @staticmethod def ciphercolumnar(key: int, s: str): \"\"\"devwizard's version: out=\"\".join([ s[key*y +x] for x in range(key) for y in range((len(s) +key -1) \/\/ key) if key*y +x < len(s) ]) thegamecracks's version: result=[] width=(len(string) +key -1) \/\/ key for x in range(key): for y in range(width): numericCoordinate=y*key +x if numericCoordinate < len(string): result.append(string[numericCoordinate])\"\"\" return \"\".join([ s[key*y +x] for x in range(key) for y in range((len(s) +key -1) \/\/ key) if key*y +x < len(s) ]) @commands.command( name='columnarcipher', brief='The Columnar Transposition Cipher.', aliases=('transcipher', 'tpcipher')) @commands.cooldown(1, 3, commands.BucketType.member) async def client_ciphercolumnar(self, ctx, key: int, *, string: str): \"\"\"See http:\/\/inventwithpython.com\/cracking\/chapter7.html key: The integer key to use in the cipher. Must be between 2 and half the message size. string: A string to cipher. 1. Count the number of characters in the message. 2. Draw a row of a number of boxes equal to the key(for example, 8 boxes for a key of 8). 3. Start filling in the boxes from left to right, entering one character per box. 4. When you run out of boxes but still have more characters, add another row of boxes. 5. When you reach the last character, shade in the unused boxes in the last row. 6. Starting from the top left and going down each column, write out the characters. When you get to the bottom of a column, move to the next column to the right. Skip any shaded boxes. This will be the ciphertext.\"\"\" if key < 2 or key > len(string) \/\/ 2: return await ctx.send('Key is out of range.') await ctx.send(self.ciphercolumnar(key, string)) @staticmethod def cipherotp(text: str, key: str, decipher: bool): text=text.upper() key=key.upper() cipher_otp_chars_length=len(CIPHER_OTP_CHARS) char_map=tuple(zip(text, key)) for char, key_char in char_map: if char not in CIPHER_OTP_CHARS: raise ValueError( f'Invalid character{char!r} given; ' 'must be an alphanumeric character') if key_char not in CIPHER_OTP_CHARS: raise ValueError( f'Invalid key character{key_char!r} given; ' 'must be an alphanumeric character') if decipher: return ''.join([ CIPHER_OTP_CHARS[ (CIPHER_OTP_CHARS.index(char) -CIPHER_OTP_CHARS.index(key_char) ) % cipher_otp_chars_length] for char, key_char in char_map]) else: return ''.join([ CIPHER_OTP_CHARS[ (CIPHER_OTP_CHARS.index(char) +CIPHER_OTP_CHARS.index(key_char) ) % cipher_otp_chars_length] for char, key_char in char_map]) @commands.command( name='otpcipher', brief='The One-time Pad Cipher.', aliases=('otpc',)) @commands.cooldown(1, 3, commands.BucketType.member) async def client_cipherotp(self, ctx, mode: str, text: str, key: str): \"\"\"Cipher\/decipher alphanumeric text(excluding spaces) \\ using the one-time pad cipher. mode: Indicate whether to cipher or decipher the text (\"cipher\"\/\"ci\", \"decipher\"\/\"de\"). text: The text to cipher\/decipher. key: The one time key to use.\"\"\" mode=mode.casefold() if mode in('cipher', 'ci'): mode=False elif mode in('decipher', 'de'): mode=True else: return await ctx.send('Mode must be either \"cipher\" or \"decipher\"') await ctx.send(self.cipherotp(text, key, mode)) @staticmethod def morsecode(decoding, s, character_gap=' ', space_char=' \/ '): \"\"\"Converts between alphanumeric characters and morse code. `character_gap` always decodes to nothing, and `space_char` always decodes to a space. Args: decoding(bool): Decodes the message. s(str): The message to encode or decode. character_gap(str): The string that represents the pause between characters in morse code. space_char(str): The string that represents the space character. Returns: str \"\"\" def encode_prosigns(word): def _replace(): nonlocal word i=word.find(k) while i !=-1: new=[word[:i]] if i !=0: new.append(character_gap) new.append(v) new.append(word[i +len(k):]) word=''.join(new) i=word.find(k) for k, v in MORSECODE_PROSIGNS.items(): _replace() for k, v in MORSECODE_PROSIGNS_ENCODE_ONLY.items(): _replace() return word def encode_word(word): word=encode_prosigns(word) word=[MORSECODE_DICTIONARY.get(c, c) for c in word] for i, c in enumerate(word): if c not in('\u25cf', '\u2501') and c !=character_gap and i !=0: word[i]='{}{}'.format(character_gap, c) return ''.join(word) if not s: return '' newline_encoding=MORSECODE_DICTIONARY['\\n'] s=s.translate(MORSECODE_PLACEHOLDERS_INVERTED) if decoding: s=s.split(space_char) for i, word in enumerate(s): prosign=MORSECODE_PROSIGNS_INVERTED.get(word) if prosign is not None: s[i]=prosign else: decode=[] for c in word.split(character_gap): decode_char=MORSECODE_DICTIONARY_INVERTED.get(c) if decode_char is not None: decode.append(decode_char) else: decode.append( MORSECODE_PROSIGNS_INVERTED.get(c, c) ) s[i]=''.join(decode) return ' '.join(s).upper() else: s=s.lower().split(' ') for i, word in enumerate(s): prosign=MORSECODE_PROSIGNS.get(word) if prosign is None: prosign=MORSECODE_PROSIGNS_ENCODE_ONLY.get(word) if prosign is not None: s[i]=prosign.translate(MORSECODE_PLACEHOLDERS_INVERTED) elif '\\n' in word: left, right=word.split('\\n', 1) s[i]='{}{gap}{}{gap}{}'.format( encode_word(left), newline_encoding, encode_word(right), gap=character_gap ) else: word=encode_word(word) s[i]=word.translate(MORSECODE_PLACEHOLDERS_INVERTED) return space_char.join(s) @commands.command( name='morsecode', brief='The morse code encrypter\/decrypter.', aliases=('morse', 'mc', 'mcode')) @commands.cooldown(1, 3, commands.BucketType.member) async def client_morsecode(self, ctx, mode: str, spacing: str, *, string: str): \"\"\"Translates text to morse code and back. mode: Either \"encode\"\/\"en\" or \"decode\"\/\"de\". Selects between encoding and decoding. spacing: Either \"space\"\/\"spaces\" or \"bar\"\/\"bars\". Selects between using \" \"\/\" \/ \" and \"|\"\/\"||\" to show letter and word gaps. string: The text or morse code to encrypt\/decrypt. Allowed characters: abcdefghijklmnopqrstuvwxyz 0123456789,;.:?!()+-\/=@&_'\" Prosigns that are encoded and decoded cleanly: <BK> Break <CL> Going off the air(\"clear\") <CT> Start copying <DO> Change to wabun code <SK> End of transmission <SOS> Distress message Prosigns that are decoded differently: <AA> New line -> an actual new line <AR> End of message -> + <AS> Wait -> & <BT> New paragraph ->= <KN> Invite specific station ->( <SN> Understood(alternate form <VE> can be used, but decodes to <SN>) Other characters will be passed through.\"\"\" mode=mode.casefold() spacing=spacing.casefold() if mode in('encode', 'en'): decoding=False elif mode in('decode', 'de'): decoding=True else: raise ValueError(f'Unknown mode{mode!r}') if spacing in('space', 'spaces'): character_gap=' ' space_char=' \/ ' elif spacing in('bar', 'bars'): character_gap='|' space_char='||' else: raise ValueError(f'Unknown spacing{spacing!r}') message=self.morsecode( decoding, string, character_gap, space_char ) await ctx.send(f'```\\n{message}```') @client_morsecode.error async def client_morsecode_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, ValueError): await ctx.send(str(error)) @commands.command( name='morsecodetable', brief='The interational morse code table.', aliases=('mcodetable', 'mct', 'morsetable')) @commands.cooldown(1, 60, commands.BucketType.user) async def client_morsecodetable(self, ctx): \"\"\"DMs the interational morse code table.\"\"\" await ctx.author.send('```' +MORSECODE_DICTIONARY_STRING +'```') @staticmethod def ciphervigenere(text: str, key: str, decipher: bool): alphabet=string.ascii_lowercase decipher=int(decipher) key=itertools.cycle([ord(c) -97 for c in key.lower()]) text_cipher=[] for char in text: uppercase=char.isupper() char=char.lower() if char in alphabet: shift=-next(key) if decipher else next(key) char=alphabet[(ord(char) -97 +shift) % 26] if uppercase: char=char.upper() text_cipher.append(char) else: text_cipher.append(char) return ''.join(text_cipher) @commands.command( name='vigenerecipher', brief='The Vigenere Cipher.') @commands.cooldown(1, 3, commands.BucketType.member) async def client_vigenerecipher(self, ctx, mode: str, key: str, *, text: str): \"\"\"Encrypt. mode: Either \"encrypt\"\/\"en\" or \"decrypt\"\/\"de\". Selects between encrypting and decrypting. key: The key to use. text: The text to encrypt\/decrypt.\"\"\" mode=mode.casefold() if mode in('encrypt', 'en'): decrypting=False elif mode in('decrypt', 'de'): decrypting=True else: raise ValueError(f'Unknown mode{mode!r}') await ctx.send( '```' +self.ciphervigenere(text, key, decrypting) +'```') @client_vigenerecipher.error async def client_vigenerecipher_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, ValueError): await ctx.send(str(error)) def setup(bot): bot.add_cog(Ciphers(bot)) ","sourceWithComments":"import itertools\nimport string\n\nfrom discord.ext import commands\n\nfrom bot import utils\n\nCIPHER_ATBASH_TABLE = str.maketrans(\n    string.ascii_letters,\n    string.ascii_lowercase[::-1] + string.ascii_uppercase[::-1])\nCIPHER_OTP_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\nMORSECODE_DICTIONARY_STRING = \"\"\"\\\nSource: https:\/\/morsecode.world\/international\/morse.html\n\"a\" : .-\n\"b\" : -...\n\"c\" : -.-.\n\"d\" : -..\n\"e\" : .\n\"f\" : ..-.\n\"g\" : --.\n\"h\" : ....\n\"i\" : ..\n\"j\" : .---\n\"k\" : -.-\n\"l\" : .-..\n\"m\" : --\n\"n\" : -.\n\"o\" : ---\n\"p\" : .--.\n\"q\" : --.-\n\"r\" : .-.\n\"s\" : ...\n\"t\" : -\n\"u\" : ..-\n\"v\" : ...-\n\"w\" : .--\n\"x\" : -..-\n\"y\" : -.--\n\"z\" : --..\n\"0\" : -----\n\"1\" : .----\n\"2\" : ..---\n\"3\" : ...--\n\"4\" : ....-\n\"5\" : .....\n\"6\" : -....\n\"7\" : --...\n\"8\" : ---..\n\"9\" : ----.\n\",\" : --..--\n\";\" : -.-.-.\n\".\" : .-.-.-\n\":\" : ---...\n\"?\" : ..--..\n\"!\" : -.-.--\n\"(\" : -.--.\n\")\" : -.--.-\n\"+\" : .-.-.\n\"-\" : -....-\n\"\/\" : -..-.\n\"=\" : -...-\n\"@\" : .--.-.\n\"&\" : .-...\n\"_\" : ..--.-\n\"'\" : .----.\n'\"' : .-..-.\n<new line> : .-.-\n\"<AA>\": .-.-        New line (\"\\\\n\")\n\"<AR>\": .-.-.       End of message (\"+\")\n\"<AS>\": .-...       Wait (\"&\")\n\"<BK>\": -...-.-     Break\n\"<BT>\": -...-       New paragraph (\"=\")\n\"<CL>\": -.-..-..    Going off the air (clear)\n\"<CT>\": -.-.-       Start copying\n\"<DO>\": -..---      Change to wabun code\n\"<KN>\": -.--.       Invite specific station (\"(\")\n\"<SK>\": ...-.-      End of transmission\n\"<SN>\": ...-.       Understood (can also be read as <VE>)\n\"<SOS>\": ...---...  Distress message\"\"\"\nMORSECODE_DICTIONARY = {\n    ':': '---...',\n    ',': '--..--',\n    ')': '-.--.-',\n    '!': '-.-.--',\n    ';': '-.-.-.',\n    '-': '-....-',\n    \"'\": '.----.',\n    '@': '.--.-.',\n    '.': '.-.-.-',\n    '\"': '.-..-.',\n    '_': '..--.-',\n    '?': '..--..',\n    '(': '-.--.',\n    '\/': '-..-.',\n    '=': '-...-',\n    '+': '.-.-.',\n    '&': '.-...',\n    '0': '-----',\n    '9': '----.',\n    '8': '---..',\n    '7': '--...',\n    '6': '-....',\n    '1': '.----',\n    '2': '..---',\n    '3': '...--',\n    '4': '....-',\n    '5': '.....',\n    'q': '--.-',\n    'z': '--..',\n    'y': '-.--',\n    'c': '-.-.',\n    'x': '-..-',\n    'b': '-...',\n    'j': '.---',\n    'p': '.--.',\n    '\\n': '.-.-',\n    'l': '.-..',\n    'f': '..-.',\n    'v': '...-',\n    'h': '....',\n    'o': '---',\n    'g': '--.',\n    'k': '-.-',\n    'd': '-..',\n    'w': '.--',\n    'r': '.-.',\n    'u': '..-',\n    's': '...',\n    'm': '--',\n    'n': '-.',\n    'a': '.-',\n    'i': '..',\n    't': '-',\n    'e': '.',\n}\nMORSECODE_DICTIONARY_INVERTED = {v: k for k, v in MORSECODE_DICTIONARY.items()}\n\nMORSECODE_PLACEHOLDERS = str.maketrans({'.': '\u25cf', '-': '\u2501'})\nMORSECODE_PLACEHOLDERS_INVERTED = str.maketrans(\n    {v: k for k, v in MORSECODE_PLACEHOLDERS.items()}\n)\nMORSECODE_PROSIGNS = {\n    '<SOS>': '\u25cf\u25cf\u25cf\u2501\u2501\u2501\u25cf\u25cf\u25cf',\n    '<CL>': '\u2501\u25cf\u2501\u25cf\u25cf\u2501\u25cf\u25cf',\n    '<BK>': '\u2501\u25cf\u25cf\u25cf\u2501\u25cf\u2501',\n    '<DO>': '\u2501\u25cf\u25cf\u2501\u2501\u2501',\n    '<SK>': '\u25cf\u25cf\u25cf\u2501\u25cf\u2501',\n    '<CT>': '\u2501\u25cf\u2501\u25cf\u2501',\n    '<VE>': '\u25cf\u25cf\u25cf\u2501\u25cf',\n    '<SN>': '\u25cf\u25cf\u25cf\u2501\u25cf',\n}\nMORSECODE_PROSIGNS_INVERTED = {\n    v.translate(MORSECODE_PLACEHOLDERS_INVERTED): k\n    for k, v in MORSECODE_PROSIGNS.items()\n}\nMORSECODE_PROSIGNS_ENCODE_ONLY = {\n    '<KN>': '\u2501\u25cf\u2501\u2501\u25cf',\n    '<BT>': '\u2501\u25cf\u25cf\u25cf\u2501',\n    '<AR>': '\u25cf\u2501\u25cf\u2501\u25cf',\n    '<AS>': '\u25cf\u2501\u25cf\u25cf\u25cf',\n    '<AA>': '\u25cf\u2501\u25cf\u2501',\n}\n\n\nclass Ciphers(commands.Cog):\n    qualified_name = 'Ciphers'\n    description = 'Commands for encoding\/decoding text.'\n\n    def __init__(self, bot):\n        self.bot = bot\n\n    @staticmethod\n    def ciphercaesar(shift: int, text: str):\n        # a = ord('a')  # Ordinal of 'a' to allow letters to loop\n\n        # return ''.join(\n        #     chr((ord(c) - a + shift) % 26 + a)  # Shift char by shift\n        #     if 'a' <= c <= 'z'  # Shift char only if a lowercase letter\n        #     else c  # If not lowercase letter, do not shift it\n        #     for c in string.lower()\n        #     )\n        alphabet = string.ascii_lowercase\n\n        ciphertext = []\n        for char in text:\n            # Store uppercase for when shifting char\n            uppercase = char.isupper()\n\n            char = char.lower()\n\n            if char in alphabet:\n                # Shift char\n                char = alphabet[(ord(char) - 97 + shift) % 26]\n                if uppercase:\n                    char = char.upper()\n\n                ciphertext.append(char)\n            else:\n                # Pass-through char\n                ciphertext.append(char)\n\n        return ''.join(ciphertext)\n\n\n    @commands.command(\n        name='caesarcipher',\n        brief='The Caesar Cipher.',\n        aliases=('ciphercaesar', 'caesarcode', 'caesarshift'))\n    @commands.cooldown(2, 5, commands.BucketType.member)\n    async def client_ciphercaesar(self, ctx, shift: int, *, string: str):\n        \"\"\"Takes an amount of letters to shift and a string.\nshift: An integer amount of letters to shift. Can be a negative integer.\nstring: A string to cipher.\"\"\"\n        await ctx.send(self.ciphercaesar(shift, string))\n\n\n\n\n\n    @staticmethod\n    def cipheratbash(string: str):\n        return string.translate(CIPHER_ATBASH_TABLE)\n\n\n    @commands.command(\n        name='atbashcipher',\n        brief='The Atbash Cipher.',\n        aliases=('atbcipher', 'atbc', 'atbash'))\n    @commands.cooldown(1, 3, commands.BucketType.member)\n    async def client_atbash(self, ctx, *, string: str):\n        \"\"\"Takes a string and maps each letter to the reverse alphabet.\"\"\"\n        await ctx.send(self.cipheratbash(string))\n\n\n\n\n\n    @commands.command(\n        name='reversecipher',\n        brief='The Reverse Cipher.',\n        aliases=('reverse',))\n    async def client_cipherreverse(self, ctx, *, string: str):\n        \"\"\"Takes a string and reverses it.\nstring: A string to cipher.\"\"\"\n        result = string[::-1]\n\n        await ctx.send(result)\n\n\n\n\n\n    @staticmethod\n    def ciphercolumnar(key: int, s: str):\n        \"\"\"devwizard's version:\nout = \"\".join([\n    s[key*y + x]\n    for x in range(key)\n    for y in range((len(s) + key - 1) \/\/ key)\n    if key*y + x < len(s)\n])\nthegamecracks's version:\nresult = []\nwidth = (len(string) + key - 1) \/\/ key\n\nfor x in range(key):\n    for y in range(width):\n        numericCoordinate = y*key + x\n        if numericCoordinate < len(string):\n            result.append(string[numericCoordinate])\"\"\"\n        return \"\".join([\n            s[key*y + x]\n            for x in range(key)\n            for y in range((len(s) + key - 1) \/\/ key)\n            if key*y + x < len(s)\n        ])\n\n\n    @commands.command(\n        name='columnarcipher',\n        brief='The Columnar Transposition Cipher.',\n        aliases=('transcipher', 'tpcipher'))\n    @commands.cooldown(1, 3, commands.BucketType.member)\n    async def client_ciphercolumnar(self, ctx, key: int, *, string: str):\n        \"\"\"See http:\/\/inventwithpython.com\/cracking\/chapter7.html\nkey: The integer key to use in the cipher.\n Must be between 2 and half the message size.\nstring: A string to cipher.\n\n1. Count the number of characters in the message.\n2. Draw a row of a number of boxes equal to the key (for example, 8 boxes\nfor a key of 8).\n3. Start filling in the boxes from left to right, entering\none character per box.\n4. When you run out of boxes but still have more characters,\nadd another row of boxes.\n5. When you reach the last character, shade in the unused boxes\nin the last row.\n6. Starting from the top left and going down each column,\nwrite out the characters. When you get to the bottom of a column,\nmove to the next column to the right. Skip any shaded boxes.\nThis will be the ciphertext.\"\"\"\n        # Test if key is in valid range\n        if key < 2 or key > len(string) \/\/ 2:\n            return await ctx.send('Key is out of range.')\n\n        await ctx.send(self.ciphercolumnar(key, string))\n\n\n\n\n\n    @staticmethod\n    def cipherotp(text: str, key: str, decipher: bool):\n        text = text.upper()\n        key = key.upper()\n        cipher_otp_chars_length = len(CIPHER_OTP_CHARS)\n        char_map = tuple(zip(text, key))\n\n        for char, key_char in char_map:\n            if char not in CIPHER_OTP_CHARS:\n                raise ValueError(\n                    f'Invalid character {char!r} given; '\n                    'must be an alphanumeric character')\n            if key_char not in CIPHER_OTP_CHARS:\n                raise ValueError(\n                    f'Invalid key character {key_char!r} given; '\n                    'must be an alphanumeric character')\n\n        if decipher:\n            return ''.join([\n                CIPHER_OTP_CHARS[\n                    (CIPHER_OTP_CHARS.index(char)\n                     - CIPHER_OTP_CHARS.index(key_char)\n                     ) % cipher_otp_chars_length]\n                for char, key_char in char_map])\n        else:\n            return ''.join([\n                CIPHER_OTP_CHARS[\n                    (CIPHER_OTP_CHARS.index(char)\n                     + CIPHER_OTP_CHARS.index(key_char)\n                     ) % cipher_otp_chars_length]\n                for char, key_char in char_map])\n\n\n    @commands.command(\n        name='otpcipher',\n        brief='The One-time Pad Cipher.',\n        aliases=('otpc',))\n    @commands.cooldown(1, 3, commands.BucketType.member)\n    async def client_cipherotp(self, ctx, mode: str, text: str, key: str):\n        \"\"\"Cipher\/decipher alphanumeric text (excluding spaces) \\\nusing the one-time pad cipher.\nmode: Indicate whether to cipher or decipher the text\n (\"cipher\"\/\"ci\", \"decipher\"\/\"de\").\ntext: The text to cipher\/decipher.\nkey: The one time key to use.\"\"\"\n        mode = mode.casefold()\n\n        if mode in ('cipher', 'ci'):\n            mode = False\n        elif mode in ('decipher', 'de'):\n            mode = True\n        else:\n            return await ctx.send('Mode must be either \"cipher\" or \"decipher\"')\n\n        await ctx.send(self.cipherotp(text, key, mode))\n\n\n\n\n\n    @staticmethod\n    def morsecode(decoding, s, character_gap=' ', space_char=' \/ '):\n        \"\"\"Converts between alphanumeric characters and morse code.\n\n        `character_gap` always decodes to nothing,\n        and `space_char` always decodes to a space.\n\n        Args:\n            decoding (bool): Decodes the message.\n            s (str): The message to encode or decode.\n            character_gap (str): The string that represents the pause\n                between characters in morse code.\n            space_char (str): The string that represents the space character.\n\n        Returns:\n            str\n\n        \"\"\"\n        def encode_prosigns(word):\n            def _replace():\n                nonlocal word\n                i = word.find(k)\n                while i != -1:\n                    new = [word[:i]]\n                    if i != 0:\n                        new.append(character_gap)\n                    new.append(v)\n                    new.append(word[i + len(k):])\n                    word = ''.join(new)\n                    i = word.find(k)\n\n            for k, v in MORSECODE_PROSIGNS.items():\n                _replace()\n            for k, v in MORSECODE_PROSIGNS_ENCODE_ONLY.items():\n                _replace()\n            return word\n\n        def encode_word(word):\n            word = encode_prosigns(word)\n            word = [MORSECODE_DICTIONARY.get(c, c) for c in word]\n            for i, c in enumerate(word):\n                if c not in ('\u25cf', '\u2501') and c != character_gap and i != 0:\n                    word[i] = '{}{}'.format(character_gap, c)\n            return ''.join(word)\n\n        if not s:\n            return ''\n\n        newline_encoding = MORSECODE_DICTIONARY['\\n']\n\n        # Replace unicode dots and dashes with ascii versions,\n        # allowing the user to decode unicode strings\n        s = s.translate(MORSECODE_PLACEHOLDERS_INVERTED)\n\n        if decoding:\n            s = s.split(space_char)\n            for i, word in enumerate(s):\n                prosign = MORSECODE_PROSIGNS_INVERTED.get(word)\n                if prosign is not None:\n                    s[i] = prosign\n                else:\n                    decode = []\n                    for c in word.split(character_gap):\n                        decode_char = MORSECODE_DICTIONARY_INVERTED.get(c)\n                        if decode_char is not None:\n                            decode.append(decode_char)\n                        else:\n                            decode.append(\n                                MORSECODE_PROSIGNS_INVERTED.get(c, c)\n                            )\n                    s[i] = ''.join(decode)\n            return ' '.join(s).upper()\n        else:\n            s = s.lower().split(' ')\n            for i, word in enumerate(s):\n                prosign = MORSECODE_PROSIGNS.get(word)\n                if prosign is None:\n                    prosign = MORSECODE_PROSIGNS_ENCODE_ONLY.get(word)\n\n                if prosign is not None:\n                    s[i] = prosign.translate(MORSECODE_PLACEHOLDERS_INVERTED)\n                elif '\\n' in word:\n                    # Break up the word and encode the newline\n                    left, right = word.split('\\n', 1)\n\n                    s[i] = '{}{gap}{}{gap}{}'.format(\n                        encode_word(left),\n                        newline_encoding,\n                        encode_word(right),\n                        gap=character_gap\n                    )\n                else:\n                    word = encode_word(word)\n                    s[i] = word.translate(MORSECODE_PLACEHOLDERS_INVERTED)\n            return space_char.join(s)\n\n\n    @commands.command(\n        name='morsecode',\n        brief='The morse code encrypter\/decrypter.',\n        aliases=('morse', 'mc', 'mcode'))\n    @commands.cooldown(1, 3, commands.BucketType.member)\n    async def client_morsecode(self, ctx,\n        mode: str, spacing: str, *, string: str):\n        \"\"\"Translates text to morse code and back.\nmode: Either \"encode\"\/\"en\" or \"decode\"\/\"de\". Selects between encoding and decoding.\nspacing: Either \"space\"\/\"spaces\" or \"bar\"\/\"bars\". Selects between using \" \"\/\" \/ \" and \"|\"\/\"||\" to show letter and word gaps.\nstring: The text or morse code to encrypt\/decrypt.\nAllowed characters:\n    abcdefghijklmnopqrstuvwxyz 0123456789,;.:?!()+-\/=@&_'\"\nProsigns that are encoded and decoded cleanly:\n    <BK>  Break\n    <CL>  Going off the air (\"clear\")\n    <CT>  Start copying\n    <DO>  Change to wabun code\n    <SK>  End of transmission\n    <SOS> Distress message\nProsigns that are decoded differently:\n    <AA>  New line                -> an actual new line\n    <AR>  End of message          -> +\n    <AS>  Wait                    -> &\n    <BT>  New paragraph           -> =\n    <KN>  Invite specific station -> (\n    <SN>  Understood (alternate form <VE> can be used, but decodes to <SN>)\nOther characters will be passed through.\"\"\"\n        mode = mode.casefold()\n        spacing = spacing.casefold()\n\n        if mode in ('encode', 'en'):\n            decoding = False\n        elif mode in ('decode', 'de'):\n            decoding = True\n        else:\n            raise ValueError(f'Unknown mode {mode!r}')\n\n        if spacing in ('space', 'spaces'):\n            character_gap = ' '\n            space_char = ' \/ '\n        elif spacing in ('bar', 'bars'):\n            character_gap = '|'\n            space_char = '||'\n        else:\n            raise ValueError(f'Unknown spacing {spacing!r}')\n\n        message = self.morsecode(\n            decoding, string,\n            character_gap, space_char\n        )\n\n        await ctx.send(f'```\\n{message}```')\n\n\n    @client_morsecode.error\n    async def client_morsecode_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, ValueError):\n            await ctx.send(str(error))\n\n\n    @commands.command(\n        name='morsecodetable',\n        brief='The interational morse code table.',\n        aliases=('mcodetable', 'mct', 'morsetable'))\n    @commands.cooldown(1, 60, commands.BucketType.user)\n    async def client_morsecodetable(self, ctx):\n        \"\"\"DMs the interational morse code table.\"\"\"\n        await ctx.author.send('```' + MORSECODE_DICTIONARY_STRING + '```')\n\n\n\n\n\n    @staticmethod\n    def ciphervigenere(text: str, key: str, decipher: bool):\n        alphabet = string.ascii_lowercase\n        decipher = int(decipher)\n\n        # Convert key into numbers in an endless generator\n        key = itertools.cycle([ord(c) - 97 for c in key.lower()])\n\n        text_cipher = []\n        for char in text:\n            # Store uppercase for when shifting char\n            uppercase = char.isupper()\n\n            char = char.lower()\n\n            if char in alphabet:\n                # Shift char\n                shift = -next(key) if decipher else next(key)\n                char = alphabet[(ord(char) - 97 + shift) % 26]\n                if uppercase:\n                    char = char.upper()\n\n                text_cipher.append(char)\n            else:\n                # Pass-through char\n                text_cipher.append(char)\n\n        return ''.join(text_cipher)\n\n\n    @commands.command(\n        name='vigenerecipher',\n        brief='The Vigenere Cipher.')\n    @commands.cooldown(1, 3, commands.BucketType.member)\n    async def client_vigenerecipher(self, ctx,\n        mode: str, key: str, *, text: str):\n        \"\"\"Encrypt.\nmode: Either \"encrypt\"\/\"en\" or \"decrypt\"\/\"de\". Selects between encrypting and decrypting.\nkey: The key to use.\ntext: The text to encrypt\/decrypt.\"\"\"\n        mode = mode.casefold()\n\n        if mode in ('encrypt', 'en'):\n            decrypting = False\n        elif mode in ('decrypt', 'de'):\n            decrypting = True\n        else:\n            raise ValueError(f'Unknown mode {mode!r}')\n\n        await ctx.send(\n            '```' + self.ciphervigenere(text, key, decrypting) + '```')\n\n\n    @client_vigenerecipher.error\n    async def client_vigenerecipher_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, ValueError):\n            await ctx.send(str(error))\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Ciphers(bot))\n"},"\/bot\/commands\/embedding.py":{"changes":[{"diff":"\n import collections\n import datetime\n import functools\n+import re\n \n import discord\n from discord.ext import commands\n+from discord_slash.utils import manage_commands\n+from discord_slash import cog_ext as dslash_cog\n+from discord_slash import SlashContext\n+import discord_slash as dslash\n \n from bot import utils\n \n \n class Embedding(commands.Cog):\n+    \"\"\"Commands for creating embeds.\"\"\"\n     qualified_name = 'Embedding'\n-    description = 'Commands for creating embeds.'\n \n     embed_specs = {\n         'title':    ('--title', '-T'),\n","add":6,"remove":1,"filename":"\/bot\/commands\/embedding.py","badparts":["    description = 'Commands for creating embeds.'"],"goodparts":["import re","from discord_slash.utils import manage_commands","from discord_slash import cog_ext as dslash_cog","from discord_slash import SlashContext","import discord_slash as dslash","    \"\"\"Commands for creating embeds.\"\"\""]},{"diff":"\n             *parameters):\n         \"\"\"Create an embed.\n Example:\n-    embed 0xDDA212 \"description with \\\\\"quotes\\\\\"\" --title \"Title\"\n-If you want to stop links from being embedded in your message,\n+> embed 0xDDA212 \"description with \\\\\\\\\"quotes\\\\\\\\\"\" --title \"Title\"\n+If you want to stop links from being embedded in your command,\n you can use code block tags like so:\n-    embed FFCC22 description `\u200b`\u200b` --title Title `\u200b`\u200b`\n+> embed FFCC22 description \\`\\`\u200b\\` --title Title \\`\\`\\`\n \n -T  --title        \"<text>\"\n -TU --titleurl     <url>\n","add":3,"remove":3,"filename":"\/bot\/commands\/embedding.py","badparts":["    embed 0xDDA212 \"description with \\\\\"quotes\\\\\"\" --title \"Title\"","If you want to stop links from being embedded in your message,","    embed FFCC22 description `\u200b`\u200b` --title Title `\u200b`\u200b`","T  --title        \"<text>\"","TU --titleurl     <url>"],"goodparts":["> embed 0xDDA212 \"description with \\\\\\\\\"quotes\\\\\\\\\"\" --title \"Title\"","If you want to stop links from being embedded in your command,","> embed FFCC22 description \\`\\`\u200b\\` --title Title \\`\\`\\`"]},{"diff":"\n             embed_dict['fields'] = list(fields.values())\n         embed = discord.Embed.from_dict(embed_dict)\n         embed.timestamp = datetime.datetime.now().astimezone()\n-        await ctx.send(embed=embed)\n+        try:\n+            await ctx.send(embed=embed)\n+        except discord.HTTPException as e:\n+            await ctx.send(\n+                f'There was an error with your embed parameters: {e.text}',\n+                delete_after=10\n+            )\n \n \n \n","add":7,"remove":1,"filename":"\/bot\/commands\/embedding.py","badparts":["        await ctx.send(embed=embed)"],"goodparts":["        try:","            await ctx.send(embed=embed)","        except discord.HTTPException as e:","            await ctx.send(","                f'There was an error with your embed parameters: {e.text}',","                delete_after=10","            )"]},{"diff":"\n         \"\"\"Commands for using the Embed's hyperlink feature.\n \n These commands only work in servers.\"\"\"\n-        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n         ctx.command.reset_cooldown(ctx)\n \n \n","add":2,"remove":1,"filename":"\/bot\/commands\/embedding.py","badparts":["        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')"],"goodparts":["        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',","                       delete_after=6)"]},{"diff":"\n You will be DM'd for your parameters.\"\"\"\n         async def cancel_message(message):\n             await message.edit(\n-                content=f'~~{message.content}~~ Canceled hyperlink.')\n+                content=f'~~{message.content}~~ Canceled hyperlink.',\n+                delete_after=10\n+            )\n \n         def check(message):\n-            \"Wait for a message in the author's DMs.\"\n             return message.channel == ctx.author.dm_channel\n \n         link_request = await ctx.author.send(\n","add":3,"remove":2,"filename":"\/bot\/commands\/embedding.py","badparts":["                content=f'~~{message.content}~~ Canceled hyperlink.')","            \"Wait for a message in the author's DMs.\""],"goodparts":["                content=f'~~{message.content}~~ Canceled hyperlink.',","                delete_after=10","            )"]},{"diff":"\n You will be DM'd for your parameters.\"\"\"\n         async def cancel_message(message):\n             await message.edit(\n-                content=f'~~{message.content}~~ Canceled hyperlink.')\n+                content=f'~~{message.content}~~ Canceled hyperlink.',\n+                delete_after=10\n+            )\n \n         def check(message):\n-            \"Wait for a message in the author's DMs.\"\n             return message.channel == ctx.author.dm_channel\n \n         message_request = await ctx.author.send(\n","add":3,"remove":2,"filename":"\/bot\/commands\/embedding.py","badparts":["                content=f'~~{message.content}~~ Canceled hyperlink.')","            \"Wait for a message in the author's DMs.\""],"goodparts":["                content=f'~~{message.content}~~ Canceled hyperlink.',","                delete_after=10","            )"]}],"source":"\nimport asyncio import collections import datetime import functools import discord from discord.ext import commands from bot import utils class Embedding(commands.Cog): qualified_name='Embedding' description='Commands for creating embeds.' embed_specs={ 'title': ('--title', '-T'), 'titleurl':('--titleurl', '-TU'), 'footer': ('--footer', '-F'), 'footericon':('--footericon', '-FU'), 'image': ('--image', '-I'), 'thumbnail': ('--thumbnail', '-TN'), 'author': ('--author', '-A'), 'authorurl': ('--authorurl', '-AU') } def __init__(self, bot): self.bot=bot @commands.command( name='embed', brief='Create an embed.') @commands.cooldown(3, 30, commands.BucketType.channel) async def client_createembed( self, ctx, color: functools.partial(int, base=16), description, *parameters): \"\"\"Create an embed. Example: embed 0xDDA212 \"description with \\\\\"quotes\\\\\"\" --title \"Title\" If you want to stop links from being embedded in your message, you can use code block tags like so: embed FFCC22 description `\u200b`\u200b` --title Title `\u200b`\u200b` -T --title \"<text>\" -TU --titleurl <url> -F --footer \"<text>\" -FU --footericon <url> -I --image <url> -TN --thumbnail <url> -A --author \"<text>\" -AU --authorurl <url> -FI --field<n> \"<subtitle>\" -FT --fieldtext<n> \"<text>\" -FO --fieldnotinline<n> Note: Field title and text must both be specified. These are the limits set by Discord: Title: 256 characters Description: 2048 characters Fields: 25 fields Field Name: 256 characters Field Text: 1024 characters Footer: 2048 characters Author Name: 256 characters Total Limit: 6000 characters\"\"\" def char_separate_num(string): chars, nums=[],[] for c in string: if c.isdigit(): nums.append(c) else: chars.append(c) return ''.join(chars), ''.join(nums) def default_field(field_num): fields.setdefault( field_num,{'inline': True, 'name': '', 'value': ''} ) args=collections.deque(parameters) del parameters embed_dict={'color': color, 'description': description} fields={} while args: argv=args.popleft() if argv=='```': continue elif argv in self.embed_specs['title']: embed_dict['title']=args.popleft() elif argv in self.embed_specs['titleurl']: embed_dict['url']=args.popleft() elif argv in self.embed_specs['footer']: embed_dict.setdefault('footer',{}) embed_dict['footer']['text']=args.popleft() elif argv in self.embed_specs['footericon']: embed_dict.setdefault('footer',{}) embed_dict['footer']['icon_url']=args.popleft() elif argv in self.embed_specs['image']: embed_dict['image']={'url': args.popleft()} elif argv in self.embed_specs['thumbnail']: embed_dict['thumbnail']={'url': args.popleft()} elif argv in self.embed_specs['author']: embed_dict.setdefault('author',{}) embed_dict['author']['name']=args.popleft() elif argv in self.embed_specs['authorurl']: embed_dict.setdefault('author',{}) embed_dict['author']['url']=args.popleft() else: chars, num=char_separate_num(argv) if chars=='--field' \\ or chars=='-FI': value=args.popleft() default_field(num) fields[num]['name']=value elif chars=='--fieldtext' \\ or chars=='-FT': value=args.popleft() default_field(num) fields[num]['value']=value elif chars=='--fieldnotinline' \\ or chars=='-FO': default_field(num) fields[num]['inline']=False if fields: embed_dict['fields']=list(fields.values()) embed=discord.Embed.from_dict(embed_dict) embed.timestamp=datetime.datetime.now().astimezone() await ctx.send(embed=embed) @commands.group(name='hyperlink', invoke_without_command=True) @commands.guild_only() @commands.cooldown(1, 10, commands.BucketType.member) async def client_hyperlink(self, ctx): \"\"\"Commands for using the Embed's hyperlink feature. These commands only work in servers.\"\"\" await ctx.send(f'Unknown{ctx.command.name} subcommand given.') ctx.command.reset_cooldown(ctx) @client_hyperlink.command(name='procedure') @commands.guild_only() async def client_hyperlink_procedure(self, ctx): \"\"\"Create a hyperlink with custom display text in two steps. You will be DM'd for your parameters.\"\"\" async def cancel_message(message): await message.edit( content=f'~~{message.content}~~ Canceled hyperlink.') def check(message): \"Wait for a message in the author's DMs.\" return message.channel==ctx.author.dm_channel link_request=await ctx.author.send( 'What link would you like to show?') try: link=await ctx.bot.wait_for( 'message', check=check, timeout=30) except asyncio.TimeoutError: return await cancel_message(link_request) if link.author !=ctx.author: return await cancel_message(link_request) text_request=await ctx.author.send( 'What display text would you like the link to have?') try: text=await ctx.bot.wait_for( 'message', check=check, timeout=30) except asyncio.TimeoutError: await cancel_message(link_request) return await cancel_message(text_request) link=discord.utils.escape_markdown(link.content) text=text.content embed=discord.Embed( title=f'{ctx.author.display_name}', description=f'[{text}]({link})', color=utils.get_user_color(ctx.author), timestamp=datetime.datetime.now().astimezone() ) await ctx.send(embed=embed) @client_hyperlink.command( name='quick', description='Create an embed directly out of a message.') @commands.guild_only() async def client_hyperlink_quick(self, ctx): \"\"\"Create an embed directly out of a message, allowing hyperlinks via markdown formatting. To create hyperlinks with custom display text: text[display text](https:\/\/mylink.com\/) text Make sure there's a space before and after the hyperlink. You will be DM'd for your parameters.\"\"\" async def cancel_message(message): await message.edit( content=f'~~{message.content}~~ Canceled hyperlink.') def check(message): \"Wait for a message in the author's DMs.\" return message.channel==ctx.author.dm_channel message_request=await ctx.author.send( 'Send your message here to embed it:') try: message=await ctx.bot.wait_for( 'message', check=check, timeout=30) except asyncio.TimeoutError: return await cancel_message(message_request) if message.author !=ctx.author: return await cancel_message(message_request) embed=discord.Embed( title=f'{ctx.author.display_name}', description=message.content, color=utils.get_user_color(ctx.author), timestamp=datetime.datetime.now().astimezone() ) await ctx.send(embed=embed) def setup(bot): bot.add_cog(Embedding(bot)) ","sourceWithComments":"import asyncio\nimport collections\nimport datetime\nimport functools\n\nimport discord\nfrom discord.ext import commands\n\nfrom bot import utils\n\n\nclass Embedding(commands.Cog):\n    qualified_name = 'Embedding'\n    description = 'Commands for creating embeds.'\n\n    embed_specs = {\n        'title':    ('--title', '-T'),\n        'titleurl': ('--titleurl', '-TU'),\n        'footer':     ('--footer', '-F'),\n        'footericon': ('--footericon', '-FU'),\n        'image':        ('--image', '-I'),\n        'thumbnail':        ('--thumbnail', '-TN'),\n        'author':             ('--author', '-A'),\n        'authorurl':          ('--authorurl', '-AU')\n    }\n\n    def __init__(self, bot):\n        self.bot = bot\n\n\n\n\n\n    @commands.command(\n        name='embed',\n        brief='Create an embed.')\n    @commands.cooldown(3, 30, commands.BucketType.channel)\n    async def client_createembed(\n            self, ctx,\n            color: functools.partial(int, base=16),\n            description,\n            *parameters):\n        \"\"\"Create an embed.\nExample:\n    embed 0xDDA212 \"description with \\\\\"quotes\\\\\"\" --title \"Title\"\nIf you want to stop links from being embedded in your message,\nyou can use code block tags like so:\n    embed FFCC22 description `\u200b`\u200b` --title Title `\u200b`\u200b`\n\n-T  --title        \"<text>\"\n-TU --titleurl     <url>\n-F  --footer       \"<text>\"\n-FU --footericon   <url>\n-I  --image        <url>\n-TN --thumbnail    <url>\n-A  --author       \"<text>\"\n-AU --authorurl    <url>\n-FI --field<n>     \"<subtitle>\"\n-FT --fieldtext<n> \"<text>\"\n-FO --fieldnotinline<n>\nNote: Field title and text must both be specified.\n\nThese are the limits set by Discord:\n          Title: 256 characters\n    Description: 2048 characters\n         Fields: 25 fields\n     Field Name: 256 characters\n     Field Text: 1024 characters\n         Footer: 2048 characters\n    Author Name: 256 characters\n    Total Limit: 6000 characters\"\"\"\n        def char_separate_num(string):\n            chars, nums = [], []\n            for c in string:\n                if c.isdigit():\n                    nums.append(c)\n                else:\n                    chars.append(c)\n            return ''.join(chars), ''.join(nums)\n\n        def default_field(field_num):\n            fields.setdefault(\n                field_num, {'inline': True, 'name': '', 'value': ''}\n            )\n\n        args = collections.deque(parameters)\n        del parameters\n\n        embed_dict = {'color': color, 'description': description}\n        fields = {}\n        while args:\n            argv = args.popleft()\n\n            if argv == '```':\n                # Code block formatting used by user to hide links\n                continue\n\n            elif argv in self.embed_specs['title']:\n                embed_dict['title'] = args.popleft()\n\n            elif argv in self.embed_specs['titleurl']:\n                embed_dict['url'] = args.popleft()\n\n            elif argv in self.embed_specs['footer']:\n                embed_dict.setdefault('footer', {})\n                embed_dict['footer']['text'] = args.popleft()\n\n            elif argv in self.embed_specs['footericon']:\n                embed_dict.setdefault('footer', {})\n                embed_dict['footer']['icon_url'] = args.popleft()\n\n            elif argv in self.embed_specs['image']:\n                embed_dict['image'] = {'url': args.popleft()}\n\n            elif argv in self.embed_specs['thumbnail']:\n                embed_dict['thumbnail'] = {'url': args.popleft()}\n\n            elif argv in self.embed_specs['author']:\n                embed_dict.setdefault('author', {})\n                embed_dict['author']['name'] = args.popleft()\n\n            elif argv in self.embed_specs['authorurl']:\n                embed_dict.setdefault('author', {})\n                embed_dict['author']['url'] = args.popleft()\n\n            else:\n                chars, num = char_separate_num(argv)\n                if chars == '--field' \\\n                        or chars == '-FI':\n                    value = args.popleft()\n                    default_field(num)\n                    fields[num]['name'] = value\n\n                elif chars == '--fieldtext' \\\n                        or chars == '-FT':\n                    value = args.popleft()\n                    default_field(num)\n                    fields[num]['value'] = value\n\n                elif chars == '--fieldnotinline' \\\n                        or chars == '-FO':\n                    default_field(num)\n                    fields[num]['inline'] = False\n\n        if fields:\n            embed_dict['fields'] = list(fields.values())\n        embed = discord.Embed.from_dict(embed_dict)\n        embed.timestamp = datetime.datetime.now().astimezone()\n        await ctx.send(embed=embed)\n\n\n\n\n\n    @commands.group(name='hyperlink', invoke_without_command=True)\n    @commands.guild_only()\n    @commands.cooldown(1, 10, commands.BucketType.member)\n    async def client_hyperlink(self, ctx):\n        \"\"\"Commands for using the Embed's hyperlink feature.\n\nThese commands only work in servers.\"\"\"\n        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n        ctx.command.reset_cooldown(ctx)\n\n\n    @client_hyperlink.command(name='procedure')\n    @commands.guild_only()\n    async def client_hyperlink_procedure(self, ctx):\n        \"\"\"Create a hyperlink with custom display text in two steps.\n\nYou will be DM'd for your parameters.\"\"\"\n        async def cancel_message(message):\n            await message.edit(\n                content=f'~~{message.content}~~ Canceled hyperlink.')\n\n        def check(message):\n            \"Wait for a message in the author's DMs.\"\n            return message.channel == ctx.author.dm_channel\n\n        link_request = await ctx.author.send(\n            'What link would you like to show?')\n\n        # Get link from user\n        try:\n            link = await ctx.bot.wait_for(\n                'message', check=check, timeout=30)\n        except asyncio.TimeoutError:\n            # User took too long to respond\n            return await cancel_message(link_request)\n\n        if link.author != ctx.author:\n            # Bot DM'd the user; cancel hyperlink command\n            return await cancel_message(link_request)\n\n        # TODO: Verify link with regex\n\n        text_request = await ctx.author.send(\n            'What display text would you like the link to have?')\n\n        # Get display text from user\n        try:\n            text = await ctx.bot.wait_for(\n                'message', check=check, timeout=30)\n        except asyncio.TimeoutError:\n            await cancel_message(link_request)\n            return await cancel_message(text_request)\n\n        # Escape markdown (mentions don't work in embeds so no need to escape)\n        link = discord.utils.escape_markdown(link.content)\n        text = text.content\n\n        embed = discord.Embed(\n            title=f'{ctx.author.display_name}',\n            description=f'[{text}]({link})',\n            color=utils.get_user_color(ctx.author),\n            timestamp=datetime.datetime.now().astimezone()\n        )\n\n        await ctx.send(embed=embed)\n\n\n    @client_hyperlink.command(\n        name='quick',\n        description='Create an embed directly out of a message.')\n    @commands.guild_only()\n    async def client_hyperlink_quick(self, ctx):\n        \"\"\"Create an embed directly out of a message, allowing hyperlinks via markdown formatting.\nTo create hyperlinks with custom display text:\n    text [display text](https:\/\/mylink.com\/) text\nMake sure there's a space before and after the hyperlink.\n\nYou will be DM'd for your parameters.\"\"\"\n        async def cancel_message(message):\n            await message.edit(\n                content=f'~~{message.content}~~ Canceled hyperlink.')\n\n        def check(message):\n            \"Wait for a message in the author's DMs.\"\n            return message.channel == ctx.author.dm_channel\n\n        message_request = await ctx.author.send(\n            'Send your message here to embed it:')\n\n        # Get message from user\n        try:\n            message = await ctx.bot.wait_for(\n                'message', check=check, timeout=30)\n        except asyncio.TimeoutError:\n            # User took too long to respond\n            return await cancel_message(message_request)\n\n        if message.author != ctx.author:\n            # Bot DM'd the user; cancel hyperlink command\n            return await cancel_message(message_request)\n\n        embed = discord.Embed(\n            title=f'{ctx.author.display_name}',\n            description=message.content,\n            color=utils.get_user_color(ctx.author),\n            timestamp=datetime.datetime.now().astimezone()\n        )\n\n        await ctx.send(embed=embed)\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Embedding(bot))\n"},"\/bot\/commands\/games.py":{"changes":[{"diff":"\n import asyncio\n+import collections\n+import csv\n+import json\n+import math\n+import random\n+from concurrent.futures.thread import ThreadPoolExecutor\n+from typing import Optional, List, Union\n \n import discord\n from discord.ext import commands\n+import inflect\n \n-from bot.classes.games import multimath\n+from bot.classes.confirmation import AdaptiveConfirmation\n+from bot.classes.games import blackjack, multimath\n+from bot.classes.get_reaction import get_reaction\n from bot.classes import paginator\n+from bot.database import GameDatabase\n+from bot import checks, utils\n+\n+inflector = inflect.engine()\n+\n+\n+# phasmophobia commands\n+class Ghost:\n+    __slots__ = ('name', 'evidences', 'url')\n+\n+    def __init__(self, name, evidences, url):\n+        self.name = name\n+        self.evidences = evidences\n+        self.url = url\n+\n+\n+GHOST_EVIDENCE = [\n+    Ghost('Banshee',\n+          ('EMF Level 5', 'Fingerprints', 'Freezing Temperatures'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Banshee'),\n+    Ghost('Demon',\n+          ('Freezing Temperatures', 'Ghost Writing', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Demon'),\n+    Ghost('Jinn',\n+          ('EMF Level 5', 'Ghost Orb', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Jinn'),\n+    Ghost('Mare',\n+          ('Freezing Temperatures', 'Ghost Orb', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Mare'),\n+    Ghost('Oni',\n+          ('EMF Level 5', 'Ghost Writing', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Oni'),\n+    Ghost('Phantom',\n+          ('EMF Level 5', 'Freezing Temperatures', 'Ghost Orb'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Phantom'),\n+    Ghost('Poltergeist',\n+          ('Fingerprints', 'Ghost Orb', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Poltergeist'),\n+    Ghost('Revenant',\n+          ('EMF Level 5', 'Fingerprints', 'Ghost Writing'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Revenant'),\n+    Ghost('Shade',\n+          ('EMF Level 5', 'Ghost Orb', 'Ghost Writing'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Shade'),\n+    Ghost('Spirit',\n+          ('Fingerprints', 'Ghost Writing', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Spirit'),\n+    Ghost('Wraith',\n+          ('Fingerprints', 'Freezing Temperatures', 'Spirit Box'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Wraith'),\n+    Ghost('Yurei',\n+          ('Freezing Temperatures', 'Ghost Orb', 'Ghost Writing'),\n+          'https:\/\/phasmophobia.fandom.com\/wiki\/Yurei')\n+]\n+EVIDENCES = [\n+    'EMF Level 5', 'Freezing Temperatures', 'Fingerprints',\n+    'Ghost Orb', 'Ghost Writing', 'Spirit Box'\n+]\n+\n+\n+def phasmophobia_match_ghost_evidence(evidences):\n+    possible_ghosts = GHOST_EVIDENCE\n+\n+    for e in evidences:\n+        new_ghosts = []\n+\n+        for g in possible_ghosts:\n+            if e.lower() in [gev.lower() for gev in g.evidences]:\n+                new_ghosts.append(g)\n+\n+        possible_ghosts = new_ghosts\n+\n+        if len(possible_ghosts) == 0:\n+            return possible_ghosts\n+\n+    return possible_ghosts\n+\n+\n+# unturned commands\n+class UnturnedItem:\n+    __slots__ = ('id', 'name', 'rarity', 'url', 'dimensions', 'recipe_data')\n+\n+    def __init__(self, id_, name, rarity, url, dimensions, recipe_data):\n+        self.id = id_\n+        self.name = name\n+        self.rarity = rarity\n+        self.url = url\n+        self.dimensions = dimensions\n+        self.recipe_data = recipe_data\n+\n+    def __repr__(self):\n+        return '{}({!r}, {!r})'.format(\n+            self.__class__.__name__,\n+            self.id,\n+            self.name\n+        )\n+\n+\n+class UnturnedDatabase:\n+    UNTURNED_ITEM_IDS_PATH = 'data\/unturned_item_ids.csv'\n+    UNTURNED_ITEM_RECIPES_PATH = 'data\/unturned_recipes.json'\n+\n+    def __init__(self, items):\n+        self.items = items\n+\n+    @classmethod\n+    def _get_items_from_files(cls):\n+        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:\n+            recipes = json.load(f)\n+\n+        items = {}\n+        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:\n+            reader = csv.reader(f)\n+            header = next(reader)\n+            for id_, name, rarity, url in reader:\n+                rec = recipes.get(id_)\n+                dimensions = rec['dimensions'] if rec else None\n+                recipe_data = (\n+                    {'primitive': rec['primitive'],\n+                     'recipes': rec['recipes']}\n+                    if rec else None\n+                )\n+                id_ = int(id_)\n+                items[id_] = UnturnedItem(\n+                    id_, name, rarity, url, dimensions, recipe_data)\n+\n+        return items\n+\n+    @classmethod\n+    async def _get_items_from_files_nonblocking(cls):\n+        executor = ThreadPoolExecutor()\n+        loop = asyncio.get_running_loop()\n+\n+        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:\n+            recipes = json.loads(await loop.run_in_executor(executor, f.read))\n+\n+        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:\n+            raw_lines = await loop.run_in_executor(executor, f.readlines)\n+\n+        items = {}\n+        reader = csv.reader(raw_lines)\n+        next(reader)  # skip header\n+\n+        for ID, name, rarity, url in reader:\n+            rec = recipes.get(ID)\n+            dimensions = rec['dimensions'] if rec else None\n+            recipe_data = (\n+                {'primitive': rec['primitive'],\n+                 'recipes': rec['recipes']}\n+                if rec else None\n+            )\n+\n+            ID = int(ID)\n+            items[ID] = UnturnedItem(ID, name, rarity, url,\n+                                     dimensions, recipe_data)\n+\n+        return items\n+\n+    def reload_items(self):\n+        \"\"\"Regenerate self.items from the data files.\"\"\"\n+        self.items = self._get_items_from_files()\n+\n+    async def reload_items_nonblocking(self):\n+        \"\"\"Regenerate self.items from the data files.\n+        Uses a thread pool to read files.\"\"\"\n+        self.items = await self._get_items_from_files_nonblocking()\n+\n+    def unturned_get_item(self, search: str) \\\n+            -> Optional[Union[UnturnedItem, List[UnturnedItem]]]:\n+        \"\"\"Search for an item from UNTURNED_ITEM_IDS either by name or ID.\n+\n+        Returns:\n+            List[UnturnedItem]: multiple matches were found.\n+            None: no matches were found.\n+            UnturnedItem: the search term matches one item.\n+\n+        \"\"\"\n+        def get_item_by_name(name):\n+            result = discord.utils.get(self.items.values(), name=name)\n+            if result is None:\n+                raise ValueError(f'Could not find an item with that name.')\n+            return result\n+\n+        # Search by ID\n+        try:\n+            item_id = int(search)\n+        except ValueError:\n+            pass\n+        else:\n+            return self.items.get(item_id)\n+\n+        # Search by name\n+        result = utils.fuzzy_match_word(\n+            search, tuple(entry.name for entry in self.items.values()),\n+            return_possible=True\n+        )\n+\n+        if isinstance(result, str):\n+            return get_item_by_name(result)\n+        elif isinstance(result, collections.abc.Iterable):\n+            return [get_item_by_name(name) for name in result]\n+        elif result is None:\n+            return\n+\n+    @classmethod\n+    def from_files(cls):\n+        return cls(cls._get_items_from_files())\n \n \n class Games(commands.Cog):\n+    \"\"\"Commands with interactive games and related to other games.\"\"\"\n     qualified_name = 'Games'\n-    description = 'Commands with interactive games.'\n+\n+    BLACKJACK_SESSION_LENGTH = 30\n+    # The number of rounds that can be played in a single session.\n+    BLACKJACK_SHUFFLE_SIZE = 0.5\n+    # The percentage at which the deck size is too small\n+    # and should be shuffled. The lower, the less frequent the shuffling.\n \n     def __init__(self, bot):\n         self.bot = bot\n+        self.gamedb = GameDatabase\n+        self.unturneddb = UnturnedDatabase.from_files()\n \n \n \n \n \n     @commands.command(name='testpages')\n-    @commands.max_concurrency(1, commands.BucketType.channel)\n+    @commands.is_owner()\n     async def client_testpages(self, ctx):\n-        \"Create a simple paginator.\"\n+        \"\"\"Create a simple paginator.\"\"\"\n         embeds = [\n             discord.Embed(title=\"test page 1\",\n                 description=\"This is just some test content!\", color=0x115599),\n","add":229,"remove":4,"filename":"\/bot\/commands\/games.py","badparts":["from bot.classes.games import multimath","    description = 'Commands with interactive games.'","    @commands.max_concurrency(1, commands.BucketType.channel)","        \"Create a simple paginator.\""],"goodparts":["import collections","import csv","import json","import math","import random","from concurrent.futures.thread import ThreadPoolExecutor","from typing import Optional, List, Union","import inflect","from bot.classes.confirmation import AdaptiveConfirmation","from bot.classes.games import blackjack, multimath","from bot.classes.get_reaction import get_reaction","from bot.database import GameDatabase","from bot import checks, utils","inflector = inflect.engine()","class Ghost:","    __slots__ = ('name', 'evidences', 'url')","    def __init__(self, name, evidences, url):","        self.name = name","        self.evidences = evidences","        self.url = url","GHOST_EVIDENCE = [","    Ghost('Banshee',","          ('EMF Level 5', 'Fingerprints', 'Freezing Temperatures'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Banshee'),","    Ghost('Demon',","          ('Freezing Temperatures', 'Ghost Writing', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Demon'),","    Ghost('Jinn',","          ('EMF Level 5', 'Ghost Orb', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Jinn'),","    Ghost('Mare',","          ('Freezing Temperatures', 'Ghost Orb', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Mare'),","    Ghost('Oni',","          ('EMF Level 5', 'Ghost Writing', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Oni'),","    Ghost('Phantom',","          ('EMF Level 5', 'Freezing Temperatures', 'Ghost Orb'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Phantom'),","    Ghost('Poltergeist',","          ('Fingerprints', 'Ghost Orb', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Poltergeist'),","    Ghost('Revenant',","          ('EMF Level 5', 'Fingerprints', 'Ghost Writing'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Revenant'),","    Ghost('Shade',","          ('EMF Level 5', 'Ghost Orb', 'Ghost Writing'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Shade'),","    Ghost('Spirit',","          ('Fingerprints', 'Ghost Writing', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Spirit'),","    Ghost('Wraith',","          ('Fingerprints', 'Freezing Temperatures', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Wraith'),","    Ghost('Yurei',","          ('Freezing Temperatures', 'Ghost Orb', 'Ghost Writing'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Yurei')","]","EVIDENCES = [","    'EMF Level 5', 'Freezing Temperatures', 'Fingerprints',","    'Ghost Orb', 'Ghost Writing', 'Spirit Box'","]","def phasmophobia_match_ghost_evidence(evidences):","    possible_ghosts = GHOST_EVIDENCE","    for e in evidences:","        new_ghosts = []","        for g in possible_ghosts:","            if e.lower() in [gev.lower() for gev in g.evidences]:","                new_ghosts.append(g)","        possible_ghosts = new_ghosts","        if len(possible_ghosts) == 0:","            return possible_ghosts","    return possible_ghosts","class UnturnedItem:","    __slots__ = ('id', 'name', 'rarity', 'url', 'dimensions', 'recipe_data')","    def __init__(self, id_, name, rarity, url, dimensions, recipe_data):","        self.id = id_","        self.name = name","        self.rarity = rarity","        self.url = url","        self.dimensions = dimensions","        self.recipe_data = recipe_data","    def __repr__(self):","        return '{}({!r}, {!r})'.format(","            self.__class__.__name__,","            self.id,","            self.name","        )","class UnturnedDatabase:","    UNTURNED_ITEM_IDS_PATH = 'data\/unturned_item_ids.csv'","    UNTURNED_ITEM_RECIPES_PATH = 'data\/unturned_recipes.json'","    def __init__(self, items):","        self.items = items","    @classmethod","    def _get_items_from_files(cls):","        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:","            recipes = json.load(f)","        items = {}","        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:","            reader = csv.reader(f)","            header = next(reader)","            for id_, name, rarity, url in reader:","                rec = recipes.get(id_)","                dimensions = rec['dimensions'] if rec else None","                recipe_data = (","                    {'primitive': rec['primitive'],","                     'recipes': rec['recipes']}","                    if rec else None","                )","                id_ = int(id_)","                items[id_] = UnturnedItem(","                    id_, name, rarity, url, dimensions, recipe_data)","        return items","    @classmethod","    async def _get_items_from_files_nonblocking(cls):","        executor = ThreadPoolExecutor()","        loop = asyncio.get_running_loop()","        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:","            recipes = json.loads(await loop.run_in_executor(executor, f.read))","        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:","            raw_lines = await loop.run_in_executor(executor, f.readlines)","        items = {}","        reader = csv.reader(raw_lines)","        next(reader)  # skip header","        for ID, name, rarity, url in reader:","            rec = recipes.get(ID)","            dimensions = rec['dimensions'] if rec else None","            recipe_data = (","                {'primitive': rec['primitive'],","                 'recipes': rec['recipes']}","                if rec else None","            )","            ID = int(ID)","            items[ID] = UnturnedItem(ID, name, rarity, url,","                                     dimensions, recipe_data)","        return items","    def reload_items(self):","        \"\"\"Regenerate self.items from the data files.\"\"\"","        self.items = self._get_items_from_files()","    async def reload_items_nonblocking(self):","        \"\"\"Regenerate self.items from the data files.","        Uses a thread pool to read files.\"\"\"","        self.items = await self._get_items_from_files_nonblocking()","    def unturned_get_item(self, search: str) \\","            -> Optional[Union[UnturnedItem, List[UnturnedItem]]]:","        \"\"\"Search for an item from UNTURNED_ITEM_IDS either by name or ID.","        Returns:","            List[UnturnedItem]: multiple matches were found.","            None: no matches were found.","            UnturnedItem: the search term matches one item.","        \"\"\"","        def get_item_by_name(name):","            result = discord.utils.get(self.items.values(), name=name)","            if result is None:","                raise ValueError(f'Could not find an item with that name.')","            return result","        try:","            item_id = int(search)","        except ValueError:","            pass","        else:","            return self.items.get(item_id)","        result = utils.fuzzy_match_word(","            search, tuple(entry.name for entry in self.items.values()),","            return_possible=True","        )","        if isinstance(result, str):","            return get_item_by_name(result)","        elif isinstance(result, collections.abc.Iterable):","            return [get_item_by_name(name) for name in result]","        elif result is None:","            return","    @classmethod","    def from_files(cls):","        return cls(cls._get_items_from_files())","    \"\"\"Commands with interactive games and related to other games.\"\"\"","    BLACKJACK_SESSION_LENGTH = 30","    BLACKJACK_SHUFFLE_SIZE = 0.5","        self.gamedb = GameDatabase","        self.unturneddb = UnturnedDatabase.from_files()","    @commands.is_owner()","        \"\"\"Create a simple paginator.\"\"\""]}],"source":"\nimport asyncio import discord from discord.ext import commands from bot.classes.games import multimath from bot.classes import paginator class Games(commands.Cog): qualified_name='Games' description='Commands with interactive games.' def __init__(self, bot): self.bot=bot @commands.command(name='testpages') @commands.max_concurrency(1, commands.BucketType.channel) async def client_testpages(self, ctx): \"Create a simple paginator.\" embeds=[ discord.Embed(title=\"test page 1\", description=\"This is just some test content!\", color=0x115599), discord.Embed(title=\"test page 2\", description=\"Nothing interesting here.\", color=0x5599ff), discord.Embed(title=\"test page 3\", description=\"Why are you still here?\", color=0x191638) ] pages=paginator.RemovableReactBotEmbedPaginator( ctx, embeds) await pages.run() @commands.command(name='multimath') @commands.max_concurrency(1, commands.BucketType.channel) async def client_multimath( self, ctx, players='only me', members: commands.Greedy[discord.User]=None): \"\"\"Answer simple multiple-choice math expressions. If the first parameter says \"allow\", you can then specify which other members are allowed to play, by mention or name: > multimath allow Alice If no members are specified after \"allow\", anyone can play: > multimath allow Otherwise, only you can play: > multimath\"\"\" if 'allow' in players.lower(): if members: users=members users.append(ctx.author) else: users=True else: if members: ctx.command.reset_cooldown(ctx) return await ctx.send( 'You cannot specify which members can play if you do ' 'not allow others. See the help message for more info.' ) else: users=None game=multimath.BotMultimathGame(ctx) await game.run(users=users) def setup(bot): bot.add_cog(Games(bot)) ","sourceWithComments":"import asyncio\n\nimport discord\nfrom discord.ext import commands\n\nfrom bot.classes.games import multimath\nfrom bot.classes import paginator\n\n\nclass Games(commands.Cog):\n    qualified_name = 'Games'\n    description = 'Commands with interactive games.'\n\n    def __init__(self, bot):\n        self.bot = bot\n\n\n\n\n\n    @commands.command(name='testpages')\n    @commands.max_concurrency(1, commands.BucketType.channel)\n    async def client_testpages(self, ctx):\n        \"Create a simple paginator.\"\n        embeds = [\n            discord.Embed(title=\"test page 1\",\n                description=\"This is just some test content!\", color=0x115599),\n            discord.Embed(title=\"test page 2\",\n                description=\"Nothing interesting here.\", color=0x5599ff),\n            discord.Embed(title=\"test page 3\",\n                description=\"Why are you still here?\", color=0x191638)\n        ]\n\n        pages = paginator.RemovableReactBotEmbedPaginator(\n            ctx, embeds)\n        await pages.run()\n\n\n\n\n\n    @commands.command(name='multimath')\n    @commands.max_concurrency(1, commands.BucketType.channel)\n    async def client_multimath(\n            self, ctx,\n            players='only me',\n            members: commands.Greedy[discord.User] = None):\n        \"\"\"Answer simple multiple-choice math expressions.\n\nIf the first parameter says \"allow\", you can then specify which other members are allowed to play, by mention or name:\n> multimath allow Alice#1234 Bob\nIf no members are specified after \"allow\", anyone can play:\n> multimath allow\nOtherwise, only you can play:\n> multimath\"\"\"\n        if 'allow' in players.lower():\n            if members:\n                # Player whitelist\n                users = members\n                users.append(ctx.author)\n            else:\n                # All players\n                users = True\n        else:\n            if members:\n                # Argument error\n                ctx.command.reset_cooldown(ctx)\n                return await ctx.send(\n                    'You cannot specify which members can play if you do '\n                    'not allow others. See the help message for more info.'\n                )\n            else:\n                # Solo\n                users = None\n\n        game = multimath.BotMultimathGame(ctx)\n\n        await game.run(users=users)\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Games(bot))\n"},"\/bot\/commands\/graphing.py":{"changes":[{"diff":"\n \n \n+def format_dollars(dollars: decimal.Decimal):\n+    dollars = round_dollars(dollars)\n+    sign = '-' if dollars < 0 else ''\n+    dollar_part = abs(int(dollars))\n+    cent_part = abs(int(dollars % 1 * 100))\n+    return '{}${:,}.{:02d}'.format(sign, dollar_part, cent_part)\n+\n+\n+class DollarConverter(commands.Converter):\n+    \"\"\"A decimal.Decimal converter that strips leading dollar signs\n+    and can round to the nearest cent.\"\"\"\n+\n+    def __init__(self, *, nearest_cent=True):\n+        super().__init__()\n+        self.nearest_cent = nearest_cent\n+\n+    async def convert(self, ctx, arg):\n+        arg = arg.lower()\n+        thousands = 1000 if arg.endswith('k') else 1\n+        arg = arg.replace(',', '').lstrip('$').rstrip('k')\n+        try:\n+            d = decimal.Decimal(arg) * thousands\n+        except decimal.InvalidOperation:\n+            raise commands.BadArgument(f'Dollar syntax error: {arg!r}')\n+        return round_dollars(d) if self.nearest_cent else d\n+\n+\n+class PercentConverter(commands.Converter):\n+    \"\"\"A decimal.Decimal converter that supports specifying percentages.\"\"\"\n+    async def convert(self, ctx, arg):\n+        try:\n+            if arg.endswith('%'):\n+                arg = arg.rstrip('%')\n+                return decimal.Decimal(arg) \/ 100\n+            return decimal.Decimal(arg)\n+        except decimal.InvalidOperation:\n+            raise commands.BadArgument(f'Decimal syntax error: {arg!r}')\n+\n+\n+def round_dollars(d) -> decimal.Decimal:\n+    \"\"\"Round a number-like object to the nearest cent.\"\"\"\n+    cent = decimal.Decimal('0.01')\n+    return decimal.Decimal(d).quantize(cent, rounding=decimal.ROUND_HALF_UP)\n+\n+\n class Graphing(commands.Cog):\n+    \"\"\"Commands for graphing things.\n+Most of the text-related commands can support obtaining text using:\n+the \"text\" parameter; file attachment; replying to a message;\n+or the last message that was sent.\"\"\"\n     qualified_name = 'Graphing'\n-    description = (\n-        'Commands for graphing things.\\n'\n-        'Most of the text-related commands can support obtaining text by: '\n-        'the \"text\" parameter; file attachment; replying to a message; '\n-        'or the last message that was sent.'\n-    )\n \n     TEXT_ANALYSIS_FILESIZE_LIMIT = 300_000\n     # Maximum file size allowed for client_frequencyanalysis in number of bytes\n","add":49,"remove":6,"filename":"\/bot\/commands\/graphing.py","badparts":["    description = (","        'Commands for graphing things.\\n'","        'Most of the text-related commands can support obtaining text by: '","        'the \"text\" parameter; file attachment; replying to a message; '","        'or the last message that was sent.'","    )"],"goodparts":["def format_dollars(dollars: decimal.Decimal):","    dollars = round_dollars(dollars)","    sign = '-' if dollars < 0 else ''","    dollar_part = abs(int(dollars))","    cent_part = abs(int(dollars % 1 * 100))","    return '{}${:,}.{:02d}'.format(sign, dollar_part, cent_part)","class DollarConverter(commands.Converter):","    \"\"\"A decimal.Decimal converter that strips leading dollar signs","    and can round to the nearest cent.\"\"\"","    def __init__(self, *, nearest_cent=True):","        super().__init__()","        self.nearest_cent = nearest_cent","    async def convert(self, ctx, arg):","        arg = arg.lower()","        thousands = 1000 if arg.endswith('k') else 1","        arg = arg.replace(',', '').lstrip('$').rstrip('k')","        try:","            d = decimal.Decimal(arg) * thousands","        except decimal.InvalidOperation:","            raise commands.BadArgument(f'Dollar syntax error: {arg!r}')","        return round_dollars(d) if self.nearest_cent else d","class PercentConverter(commands.Converter):","    \"\"\"A decimal.Decimal converter that supports specifying percentages.\"\"\"","    async def convert(self, ctx, arg):","        try:","            if arg.endswith('%'):","                arg = arg.rstrip('%')","                return decimal.Decimal(arg) \/ 100","            return decimal.Decimal(arg)","        except decimal.InvalidOperation:","            raise commands.BadArgument(f'Decimal syntax error: {arg!r}')","def round_dollars(d) -> decimal.Decimal:","    \"\"\"Round a number-like object to the nearest cent.\"\"\"","    cent = decimal.Decimal('0.01')","    return decimal.Decimal(d).quantize(cent, rounding=decimal.ROUND_HALF_UP)","    \"\"\"Commands for graphing things.","Most of the text-related commands can support obtaining text using:","the \"text\" parameter; file attachment; replying to a message;","or the last message that was sent.\"\"\""]},{"diff":"\n         if not text and ref is not None:\n             # Try recursing into the message the user replied to.\n             # First check the cache, then fetch the message\n-            message = None\n-            if ref.cached_message is not None:\n-                message = ref.cached_message\n-            elif perms.read_message_history:\n-                channel = self.bot.get_channel(ref.channel_id)\n-                if channel is not None:\n-                    message = await channel.fetch_message(ref.message_id)\n+            message = ref.resolved\n \n-            if message is not None:\n-                ref_text = await self.get_text(ctx, text, message=message)\n-\n-                if ref_text[0] is True:\n-                    return ref_text\n+            if isinstance(message, discord.DeletedReferencedMessage):\n+                return False, 'The given message was deleted.'\n+            elif message is None:\n+                return False, 'Could not resolve your replied message.'\n+            else:\n+                return await self.get_text(ctx, text, message=message)\n \n         if not text and perms.read_message_history:\n             # Try recursing into the last message sent\n","add":7,"remove":12,"filename":"\/bot\/commands\/graphing.py","badparts":["            message = None","            if ref.cached_message is not None:","                message = ref.cached_message","            elif perms.read_message_history:","                channel = self.bot.get_channel(ref.channel_id)","                if channel is not None:","                    message = await channel.fetch_message(ref.message_id)","            if message is not None:","                ref_text = await self.get_text(ctx, text, message=message)","                if ref_text[0] is True:","                    return ref_text"],"goodparts":["            message = ref.resolved","            if isinstance(message, discord.DeletedReferencedMessage):","                return False, 'The given message was deleted.'","            elif message is None:","                return False, 'Could not resolve your replied message.'","            else:","                return await self.get_text(ctx, text, message=message)"]},{"diff":"\n         # Force integer ticks\n         ax.yaxis.set_major_locator(MaxNLocator(integer=True))\n \n-        # Set fonts\n+        # Set colors and add shadow to labels\n         for item in ([ax.title, ax.xaxis.label, ax.yaxis.label]\n                      + ax.get_xticklabels() + ax.get_yticklabels()):\n-            item.set_family('calibri')\n-            item.set_fontsize(18)\n             item.set_color(bot_color)\n-            # Add shadow\n             item.set_path_effects([\n                 path_effects.withSimplePatchShadow(\n                     offset=(1, -1),\n","add":1,"remove":4,"filename":"\/bot\/commands\/graphing.py","badparts":["            item.set_family('calibri')","            item.set_fontsize(18)"],"goodparts":[" ax.get_xticklabels() + ax.get_yticklabels()):"]},{"diff":"\n                 )\n             ])\n \n-        # Create transparent background\n-        ax.set_facecolor('#00000000')\n-        fig.patch.set_facecolor('#36393F4D')\n-\n-        # Hide the right and top spines\n-        ax.spines['right'].set_visible(False)\n-        ax.spines['top'].set_visible(False)\n         # Color the spines and ticks\n         for spine in ax.spines.values():\n             spine.set_color(bot_color)\n","add":0,"remove":7,"filename":"\/bot\/commands\/graphing.py","badparts":["        ax.set_facecolor('#00000000')","        fig.patch.set_facecolor('#36393F4D')","        ax.spines['right'].set_visible(False)","        ax.spines['top'].set_visible(False)"],"goodparts":[]},{"diff":"\n         # Add labels\n         if len(words) <= len(top_words):\n             ax.set_title(\n-                f'Top Words ({total_words:,} total)\\n'\n+                f'Word Count ({total_words:,} total)\\n'\n                 f'for {ctx.author.display_name}\\n'\n             )\n         else:\n","add":1,"remove":1,"filename":"\/bot\/commands\/graphing.py","badparts":["                f'Top Words ({total_words:,} total)\\n'"],"goodparts":["                f'Word Count ({total_words:,} total)\\n'"]},{"diff":"\n             )\n         # NOTE: newline is appended at the end just to pad it from the labels\n \n-        # Set fonts\n+        # Set font styles\n         all_text = texts + autotexts\n         for item in ([ax.title] + all_text):\n-            item.set_family('calibri')\n             item.set_color(bot_color)\n-        ax.title.set_fontsize(18)\n         for item in all_text:\n             # Add shadow\n             item.set_path_effects([\n","add":1,"remove":3,"filename":"\/bot\/commands\/graphing.py","badparts":["            item.set_family('calibri')","        ax.title.set_fontsize(18)"],"goodparts":[]},{"diff":"\n         for item in autotexts:\n             item.set_fontsize(12)\n \n-        # Create transparent background\n-        ax.set_facecolor('#00000000')\n-        fig.patch.set_facecolor('#36393F4D')\n-\n         f = io.BytesIO()\n         fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0)\n         # bbox_inches, pad_inches: removes padding around the graph\n \n+        plt.close(fig)\n         return f\n \n \n","add":1,"remove":4,"filename":"\/bot\/commands\/graphing.py","badparts":["        ax.set_facecolor('#00000000')","        fig.patch.set_facecolor('#36393F4D')"],"goodparts":["        plt.close(fig)"]},{"diff":"\n         # we have data for.\n         ax.set_yticks(yticks)\n \n-        # Set fonts\n+        # Set colors\n         for item in ([ax.xaxis.label, ax.yaxis.label, ax.zaxis.label]\n                      + ax.get_xticklabels() + ax.get_yticklabels()\n                      + ax.get_zticklabels()):\n-            item.set_family('calibri')\n             item.set_color(bot_color)\n \n         # Set spine and pane colors\n","add":1,"remove":2,"filename":"\/bot\/commands\/graphing.py","badparts":["            item.set_family('calibri')"],"goodparts":[" ax.get_xticklabels() + ax.get_yticklabels()"," ax.get_zticklabels()):"]},{"diff":"\n         # Set tick colors\n         ax.tick_params(colors=bot_color)\n \n-        # Create transparent background\n-        ax.set_facecolor('#00000000')\n-        fig.patch.set_facecolor('#36393F4D')\n-\n         return fig, ax\n \n \n","add":0,"remove":4,"filename":"\/bot\/commands\/graphing.py","badparts":["        ax.set_facecolor('#00000000')","        fig.patch.set_facecolor('#36393F4D')"],"goodparts":[]},{"diff":"\n         loop = asyncio.get_running_loop()\n \n         if duration < 1:\n-            return await ctx.send('Duration must be at least 1 second.')\n+            return await ctx.send(\n+                'Duration must be at least 1 second.', delete_after=6)\n         if frames < 1:\n-            return await ctx.send('There must be at least 1 frame.')\n+            return await ctx.send(\n+                'There must be at least 1 frame.', delete_after=6)\n \n         func = functools.partial(\n             self.test_bar_graphs_3d_gif,\n","add":4,"remove":2,"filename":"\/bot\/commands\/graphing.py","badparts":["            return await ctx.send('Duration must be at least 1 second.')","            return await ctx.send('There must be at least 1 frame.')"],"goodparts":["            return await ctx.send(","                'Duration must be at least 1 second.', delete_after=6)","            return await ctx.send(","                'There must be at least 1 frame.', delete_after=6)"]},{"diff":"\n         filesize = Path(fp).stat().st_size\n         if filesize > filesize_limit:\n             return await ctx.send(\n-                'Unfortunately the file is too large to upload.')\n+                'Unfortunately the file is too large to upload.',\n+                delete_after=10\n+            )\n \n         with open(fp, 'rb') as f:\n             await ctx.send(file=discord.File(f, '3D Graph Animation T","add":3,"remove":1,"filename":"\/bot\/commands\/graphing.py","badparts":["                'Unfortunately the file is too large to upload.')"],"goodparts":["                'Unfortunately the file is too large to upload.',","                delete_after=10","            )"]}],"source":"\nimport asyncio import collections import contextlib import functools import io from pathlib import Path import random import string import textwrap import typing import warnings import aiohttp import discord from discord.ext import commands import humanize import matplotlib import matplotlib.animation as animation import matplotlib.patheffects as path_effects import matplotlib.pyplot as plt from matplotlib.ticker import MaxNLocator import numpy as np from bot import checks from bot import utils class Graphing(commands.Cog): qualified_name='Graphing' description=( 'Commands for graphing things.\\n' 'Most of the text-related commands can support obtaining text by: ' 'the \"text\" parameter; file attachment; replying to a message; ' 'or the last message that was sent.' ) TEXT_ANALYSIS_FILESIZE_LIMIT=300_000 WORD_COUNT_NUM_TO_SHOW=15 TEXT_SHADOW_ALPHA=0.6 TEST_3D_GRAPH_ANIMATION_PATH='data\/3D Graph Animation Test.gif' def __init__(self, bot): self.bot=bot async def get_text(self, ctx, text: str, *, message=None): \"\"\"Obtain text from the user either in an attachment or from the text argument. Lookup strategy: 1. Check the invoker's attachments for downloadable text files 2. Check the invoker's content 3. Check the referenced message's attachments(if available) 4. Check the referenced message's content 5. Check the last message's attachments(before the invokation) 6. Check the last message's content Note that steps 3-6 are done via recursion. Returns: Tuple[bool, str]: The boolean indicates whether it was successful at getting the input or not. If False, the following string should be sent to the user. \"\"\" using_ctx_message=message is None if message is None: message=ctx.message if message.attachments: a=message.attachments[0] if a.width is not None: return False, 'Attachment must be a text file.' if a.size >=self.TEXT_ANALYSIS_FILESIZE_LIMIT: return( False, 'Unfortunately I cannot analyse files ' 'over{} in size.'.format( humanize.naturalsize( self.TEXT_ANALYSIS_FILESIZE_LIMIT ) ) ) text=(await a.read()).decode('utf-8') if message is not None and not using_ctx_message and not text: text=message.content if not text: return False, 'There is no text to analyse.' ref=ctx.message.reference perms=ctx.me.permissions_in(ctx.channel) if not text and ref is not None: message=None if ref.cached_message is not None: message=ref.cached_message elif perms.read_message_history: channel=self.bot.get_channel(ref.channel_id) if channel is not None: message=await channel.fetch_message(ref.message_id) if message is not None: ref_text=await self.get_text(ctx, text, message=message) if ref_text[0] is True: return ref_text if not text and perms.read_message_history: message=await ctx.channel.history( limit=1, before=ctx.message).flatten() if message: ref_text=await self.get_text(ctx, text, message=message[0]) if ref_text[0] is True: return ref_text if not text: response='There is no text to analyse.' if not perms.read_message_history: if ref is not None: response=( 'I need the Read Message History permission to be ' 'able to read the message you replied to.' ) else: response=( 'I need the Read Message History permission to be ' 'able to read the last message that was sent.' ) return False, response lowered_text=text.lower() if not any(c in lowered_text for c in string.ascii_lowercase): return False, 'There are no english letters in this text.' return True, text def frequency_analysis(self, ctx, text): \"\"\"Create a frequency analysis graph of a given text. Args: ctx(discord.ext.commands.Context) text(str) Returns: BytesIO \"\"\" bot_color=' text=text.lower() char_count=[text.count(c) for c in string.ascii_lowercase] max_char_count=max(char_count) letter_colors=plt.cm.hsv( [0.8 * i \/ max_char_count for i in char_count] ) fig, ax=plt.subplots() ax.bar(list(string.ascii_lowercase), char_count, color=letter_colors) ax.tick_params(axis='x', bottom=False) ax.set_title(f'Frequency Analysis for{ctx.author.display_name}') ax.set_xlabel('Letter') ax.set_ylabel('Count') ax.yaxis.set_major_locator(MaxNLocator(integer=True)) for item in([ax.title, ax.xaxis.label, ax.yaxis.label] +ax.get_xticklabels() +ax.get_yticklabels()): item.set_family('calibri') item.set_fontsize(18) item.set_color(bot_color) item.set_path_effects([ path_effects.withSimplePatchShadow( offset=(1, -1), alpha=self.TEXT_SHADOW_ALPHA ) ]) ax.set_facecolor(' fig.patch.set_facecolor(' ax.spines['right'].set_visible(False) ax.spines['top'].set_visible(False) for spine in ax.spines.values(): spine.set_color(bot_color) ax.tick_params(colors=bot_color) f=io.BytesIO() fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0) return f @commands.command( name='analysefrequency', aliases=('analyzefrequency', 'frequencyanalysis')) @commands.cooldown(3, 120, commands.BucketType.channel) @commands.max_concurrency(3, wait=True) async def client_frequencyanalysis(self, ctx, *, text=''): \"\"\"Do a frequency analysis of a given text. This only processes letters from the english alphabet. To see the different methods you can use to provide text, check the help message for this command's category.\"\"\" success, text=await self.get_text(ctx, text) if not success: return await ctx.send(text) await ctx.trigger_typing() loop=asyncio.get_running_loop() with warnings.catch_warnings(): warnings.simplefilter('ignore', UserWarning) f=await loop.run_in_executor( None, self.frequency_analysis, ctx, text) f.seek(0) await ctx.send(file=discord.File(f, 'Frequency Analysis.png')) def word_count_pie(self, ctx, text): \"\"\"Count the number of each word and return a pie chart. Args: ctx(discord.ext.commands.Context) text(str) Returns: BytesIO \"\"\" bot_color=' text=text.lower() alphabet=frozenset(string.ascii_lowercase) chars_after_start=frozenset(\"'\") words=collections.Counter() last_i=0 reading_word=False for i, c in enumerate(text): if c in alphabet or reading_word and c in chars_after_start: reading_word=True else: if reading_word: words[text[last_i:i]] +=1 last_i=i +1 reading_word=False else: if reading_word: words[text[last_i:]] +=1 if not sum(words.values()): raise ValueError( 'text must have some words using the english alphabet') top_words=words.most_common(self.WORD_COUNT_NUM_TO_SHOW) max_word_count=top_words[0][1] sizes=[count \/ max_word_count for word, count in top_words] labels=[f'{word.capitalize()}({count})' for word, count in top_words] word_colors=plt.cm.hsv([ 0.8 * i \/ len(top_words) for i in range(len(sizes), 0, -1) ]) fig, ax=plt.subplots() total_words=sum(words.values()) patches, texts, autotexts=ax.pie( sizes, labels=labels, colors=word_colors, autopct='%1.2g%%', startangle=0 ) ax.axis('equal') if len(words) <=len(top_words): ax.set_title( f'Top Words({total_words:,} total)\\n' f'for{ctx.author.display_name}\\n' ) else: ax.set_title( f'Top{self.WORD_COUNT_NUM_TO_SHOW} Words ' f'({total_words:,} total)\\n' f'for{ctx.author.display_name}\\n' ) all_text=texts +autotexts for item in([ax.title] +all_text): item.set_family('calibri') item.set_color(bot_color) ax.title.set_fontsize(18) for item in all_text: item.set_path_effects([ path_effects.withSimplePatchShadow( offset=(1, -1), alpha=self.TEXT_SHADOW_ALPHA ) ]) for item in texts: item.set_fontsize(16) for item in autotexts: item.set_fontsize(12) ax.set_facecolor(' fig.patch.set_facecolor(' f=io.BytesIO() fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0) return f @commands.command(name='wordcount') @commands.cooldown(3, 120, commands.BucketType.channel) @commands.max_concurrency(3, wait=True) async def client_wordcount(self, ctx, *, text=''): \"\"\"Count the occurrences of each word in a given text. This only processes letters from the english alphabet. To see the different methods you can use to provide text, check the help message for this command's category.\"\"\" success, text=await self.get_text(ctx, text) if not success: return await ctx.send(text) await ctx.trigger_typing() loop=asyncio.get_running_loop() with warnings.catch_warnings(): warnings.simplefilter('ignore', UserWarning) f=await loop.run_in_executor( None, self.word_count_pie, ctx, text) f.seek(0) await ctx.send(file=discord.File(f, 'Word Count Pie Chart.png')) def test_bar_graphs_3d(self): \"\"\"Generates four 2D bar graphs layered in a 3D plot. Code from: https:\/\/matplotlib.org\/3.3.3\/gallery\/mplot3d\/bars3d.html Returns: Tuple[Figure, Axes] \"\"\" bot_color=' fig=plt.figure() ax=fig.add_subplot(111, projection='3d') colors=['r', 'g', 'b', 'y'] yticks=[3, 2, 1, 0] scale=random.uniform(0.2, 100) for c, k in zip(colors, yticks): xs=np.arange(20) ys=np.random.rand(20) * scale ax.bar(xs, ys, zs=k, zdir='y', color=[c] * len(xs), alpha=0.8) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_yticks(yticks) for item in([ax.xaxis.label, ax.yaxis.label, ax.zaxis.label] +ax.get_xticklabels() +ax.get_yticklabels() +ax.get_zticklabels()): item.set_family('calibri') item.set_color(bot_color) for axis in(ax.w_xaxis, ax.w_yaxis, ax.w_zaxis): axis.line.set_color(bot_color) axis.set_pane_color((1, 1, 1, 0.1)) ax.tick_params(colors=bot_color) ax.set_facecolor(' fig.patch.set_facecolor(' return fig, ax def test_bar_graphs_3d_image(self, elevation=None, azimuth=None): \"\"\"Generates a PNG image from test_bar_graphs_3d. Returns: BytesIO \"\"\" fig, ax=self.test_bar_graphs_3d() ax.view_init(elevation, azimuth) f=io.BytesIO() fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0) return f @commands.command(name='test3dgraph') @commands.cooldown(3, 120, commands.BucketType.channel) @commands.max_concurrency(3, wait=True) async def client_test3dgraph( self, ctx, elevation: int=None, azimuth: int=None): \"\"\"Generate a graph with some random data.\"\"\" await ctx.trigger_typing() loop=asyncio.get_running_loop() with warnings.catch_warnings(): warnings.simplefilter('ignore', UserWarning) f=await loop.run_in_executor( None, self.test_bar_graphs_3d_image, elevation, azimuth) f.seek(0) await ctx.send(file=discord.File(f, '3D Graph Test.png')) def test_bar_graphs_3d_gif( self, fp=None, start=300, frames=30, direction=-1, duration=3): \"\"\"Generates a rotating 3D plot GIF from test_bar_graphs_3d. Unfortunately there is no way to save these GIFs into memory, so the file has to be written to disk. Resources: FuncAnimation: https:\/\/matplotlib.org\/api\/_as_gen\/matplotlib.animation.FuncAnimation.html Animating a rotating graph: https:\/\/stackoverflow.com\/questions\/18344934\/animate-a-rotating-3d-graph-in-matplotlib Saving to GIF: https:\/\/holypython.com\/how-to-save-matplotlib-animations-the-ultimate-guide\/ Args: fp(Optional[str]): The filepath to save the animation to. If not supplied, defaults to self.TEST_3D_GRAPH_ANIMATION_PATH. start(float): The azimuth to start at. frames(int): The number of azimuths to generate. direction(Literal[1, -1]): 1: Rotate right -1: Rotate left duration(float): The time in seconds for the animation to last. Returns: str: The filepath that the animation was saved to. \"\"\" if fp is None: fp=self.TEST_3D_GRAPH_ANIMATION_PATH fig, ax=self.test_bar_graphs_3d() def azimuth_rotation(): \"Generates the azimuths rotating around the graph.\" step=direction * 360 \/ frames azimuth=start for _ in range(frames): yield azimuth azimuth +=step def run(data): \"Takes an azimuth from generate_azimuths.\" ax.view_init(elev=30, azim=data) return() anim=animation.FuncAnimation( fig, run, list(azimuth_rotation()), interval=duration \/ frames, blit=True ) anim.save(fp, writer='pillow', fps=frames \/ duration) return fp @commands.command(name='test3dgraphanimation') @commands.cooldown(1, 30, commands.BucketType.default) @commands.max_concurrency(1, wait=True) @checks.is_bot_owner() async def client_test3dgraphanimation( self, ctx, frames: int=30, duration: int=3): \"\"\"Generate an animating graph with some random data.\"\"\" loop=asyncio.get_running_loop() if duration < 1: return await ctx.send('Duration must be at least 1 second.') if frames < 1: return await ctx.send('There must be at least 1 frame.') func=functools.partial( self.test_bar_graphs_3d_gif, frames=frames, duration=duration ) with ctx.typing(): with warnings.catch_warnings(): warnings.simplefilter('ignore', UserWarning) fp=await loop.run_in_executor(None, func) filesize_limit=(ctx.guild.filesize_limit if ctx.guild is not None else 8_000_000) filesize=Path(fp).stat().st_size if filesize > filesize_limit: return await ctx.send( 'Unfortunately the file is too large to upload.') with open(fp, 'rb') as f: await ctx.send(file=discord.File(f, '3D Graph Animation Test.gif')) def setup(bot): bot.add_cog(Graphing(bot)) ","sourceWithComments":"import asyncio\nimport collections\nimport contextlib\nimport functools\nimport io\n##import multiprocessing\nfrom pathlib import Path\nimport random\nimport string\nimport textwrap\nimport typing\nimport warnings\n\nimport aiohttp\nimport discord\nfrom discord.ext import commands\nimport humanize\nimport matplotlib\nimport matplotlib.animation as animation\nimport matplotlib.patheffects as path_effects\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MaxNLocator\nimport numpy as np\n\nfrom bot import checks\nfrom bot import utils\n\n\n##def conn_wrapper(conn, func):\n##    @functools.wraps\n##    def wrapper(*args, **kwargs):\n##        output = func(*args, **kwargs)\n##        conn.send(output)\n##        return output\n##    return wrapper\n\n\nclass Graphing(commands.Cog):\n    qualified_name = 'Graphing'\n    description = (\n        'Commands for graphing things.\\n'\n        'Most of the text-related commands can support obtaining text by: '\n        'the \"text\" parameter; file attachment; replying to a message; '\n        'or the last message that was sent.'\n    )\n\n    TEXT_ANALYSIS_FILESIZE_LIMIT = 300_000\n    # Maximum file size allowed for client_frequencyanalysis in number of bytes\n\n    WORD_COUNT_NUM_TO_SHOW = 15\n    # Number of words to be included in the graph; the rest are aggregated\n    # into one entry\n\n    TEXT_SHADOW_ALPHA = 0.6\n\n    TEST_3D_GRAPH_ANIMATION_PATH = 'data\/3D Graph Animation Test.gif'\n\n    def __init__(self, bot):\n        self.bot = bot\n\n\n\n\n\n    async def get_text(self, ctx, text: str, *, message=None):\n        \"\"\"Obtain text from the user either in an attachment or from\n        the text argument.\n\n        Lookup strategy:\n            1. Check the invoker's attachments for downloadable text files\n            2. Check the invoker's content\n            3. Check the referenced message's attachments (if available)\n            4. Check the referenced message's content\n            5. Check the last message's attachments (before the invokation)\n            6. Check the last message's content\n        Note that steps 3-6 are done via recursion. \n\n        Returns:\n            Tuple[bool, str]:\n                The boolean indicates whether it was successful at getting\n                the input or not. If False, the following string should\n                be sent to the user.\n\n        \"\"\"\n        using_ctx_message = message is None\n        if message is None:\n            message = ctx.message\n\n        if message.attachments:\n            a = message.attachments[0]\n\n            if a.width is not None:\n                # Image\/video file\n                return False, 'Attachment must be a text file.'\n\n            if a.size >= self.TEXT_ANALYSIS_FILESIZE_LIMIT:\n                return (\n                    False, \n                    'Unfortunately I cannot analyse files '\n                    'over {} in size.'.format(\n                        humanize.naturalsize(\n                            self.TEXT_ANALYSIS_FILESIZE_LIMIT\n                        )\n                    )\n                )\n\n            text = (await a.read()).decode('utf-8')\n            # Raises: discord.HTTPException, discord.Forbidden,\n            # discord.NotFound, UnicodeError\n\n        if message is not None and not using_ctx_message and not text:\n            # Check the message content and otherwise if that is empty,\n            # keep it at one level of recursion\n            text = message.content\n            if not text:\n                return False, 'There is no text to analyse.'\n\n        ref = ctx.message.reference\n        perms = ctx.me.permissions_in(ctx.channel)\n\n        if not text and ref is not None:\n            # Try recursing into the message the user replied to.\n            # First check the cache, then fetch the message\n            message = None\n            if ref.cached_message is not None:\n                message = ref.cached_message\n            elif perms.read_message_history:\n                channel = self.bot.get_channel(ref.channel_id)\n                if channel is not None:\n                    message = await channel.fetch_message(ref.message_id)\n\n            if message is not None:\n                ref_text = await self.get_text(ctx, text, message=message)\n\n                if ref_text[0] is True:\n                    return ref_text\n\n        if not text and perms.read_message_history:\n            # Try recursing into the last message sent\n            # (will not work if there is no message before it or\n            #  the bot is missing Read Message History perms)\n            message = await ctx.channel.history(\n                limit=1, before=ctx.message).flatten()\n\n            if message:\n                ref_text = await self.get_text(ctx, text, message=message[0])\n                if ref_text[0] is True:\n                    return ref_text\n\n        if not text:\n            response = 'There is no text to analyse.'\n            if not perms.read_message_history:\n                if ref is not None:\n                    response = (\n                        'I need the Read Message History permission to be '\n                        'able to read the message you replied to.'\n                    )\n                else:\n                    response = (\n                        'I need the Read Message History permission to be '\n                        'able to read the last message that was sent.'\n                    )\n            return False, response\n\n        lowered_text = text.lower()\n        if not any(c in lowered_text for c in string.ascii_lowercase):\n            return False, 'There are no english letters in this text.'\n\n        return True, text\n\n\n\n\n\n##    def frequency_analysis(self, conn, ctx, text):\n    def frequency_analysis(self, ctx, text):\n        \"\"\"Create a frequency analysis graph of a given text.\n\n        Args:\n            ctx (discord.ext.commands.Context)\n            text (str)\n\n        Returns:\n            BytesIO\n\n        \"\"\"\n        bot_color = '#' + hex(utils.get_bot_color())[2:]\n\n        text = text.lower()\n\n        char_count = [text.count(c) for c in string.ascii_lowercase]\n\n        max_char_count = max(char_count)\n        letter_colors = plt.cm.hsv(\n            [0.8 * i \/ max_char_count for i in char_count]\n        )\n\n        fig, ax = plt.subplots()\n\n        # Graph bars\n        ax.bar(list(string.ascii_lowercase),\n               char_count,\n               color=letter_colors)\n\n        # Remove ticks\n        ax.tick_params(axis='x', bottom=False)\n\n        # Add labels\n        ax.set_title(f'Frequency Analysis for {ctx.author.display_name}')\n        ax.set_xlabel('Letter')\n        ax.set_ylabel('Count')\n\n        # Force integer ticks\n        ax.yaxis.set_major_locator(MaxNLocator(integer=True))\n\n        # Set fonts\n        for item in ([ax.title, ax.xaxis.label, ax.yaxis.label]\n                     + ax.get_xticklabels() + ax.get_yticklabels()):\n            item.set_family('calibri')\n            item.set_fontsize(18)\n            item.set_color(bot_color)\n            # Add shadow\n            item.set_path_effects([\n                path_effects.withSimplePatchShadow(\n                    offset=(1, -1),\n                    alpha=self.TEXT_SHADOW_ALPHA\n                )\n            ])\n\n        # Create transparent background\n        ax.set_facecolor('#00000000')\n        fig.patch.set_facecolor('#36393F4D')\n\n        # Hide the right and top spines\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        # Color the spines and ticks\n        for spine in ax.spines.values():\n            spine.set_color(bot_color)\n        ax.tick_params(colors=bot_color)\n\n        f = io.BytesIO()\n        fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0)\n        # bbox_inches, pad_inches: removes padding around the graph\n\n##        conn.send(f)\n        return f\n\n\n    @commands.command(\n        name='analysefrequency',\n        aliases=('analyzefrequency', 'frequencyanalysis'))\n    @commands.cooldown(3, 120, commands.BucketType.channel)\n    @commands.max_concurrency(3, wait=True)\n    async def client_frequencyanalysis(self, ctx, *, text=''):\n        \"\"\"Do a frequency analysis of a given text.\nThis only processes letters from the english alphabet.\n\nTo see the different methods you can use to provide text, check the help message for this command's category.\"\"\"\n        success, text = await self.get_text(ctx, text)\n        if not success:\n            return await ctx.send(text)\n\n        await ctx.trigger_typing()\n\n        loop = asyncio.get_running_loop()\n##\n##        parent_conn, child_conn = multiprocessing.Pipe()\n##        p = multiprocessing.Process(\n##            target=self.frequency_analysis,\n##            args=(child_conn, ctx, text)\n##        )\n##        p.start()\n##\n##        await loop.run_in_executor(None, p.join)\n##        f = parent_conn.recv()\n##        parent_conn.close()\n##        child_conn.close()\n\n        with warnings.catch_warnings():\n            # Suppress warning from matplotlib saying that opening GUI\n            # in alternate thread will likely fail; we are only saving\n            # the figure to be uploaded, not showing it\n            warnings.simplefilter('ignore', UserWarning)\n            f = await loop.run_in_executor(\n                None, self.frequency_analysis, ctx, text)\n        f.seek(0)\n\n        await ctx.send(file=discord.File(f, 'Frequency Analysis.png'))\n\n\n\n\n\n    def word_count_pie(self, ctx, text):\n        \"\"\"Count the number of each word and return a pie chart.\n\n        Args:\n            ctx (discord.ext.commands.Context)\n            text (str)\n\n        Returns:\n            BytesIO\n\n        \"\"\"\n        bot_color = '#' + hex(utils.get_bot_color())[2:]\n\n        text = text.lower()\n\n        alphabet = frozenset(string.ascii_lowercase)\n        chars_after_start = frozenset(\"'\")\n        words = collections.Counter()\n\n        last_i = 0\n        reading_word = False\n        for i, c in enumerate(text):\n            if c in alphabet or reading_word and c in chars_after_start:\n                reading_word = True\n            else:\n                if reading_word:\n                    words[text[last_i:i]] += 1\n                last_i = i + 1\n                reading_word = False\n        else:\n            if reading_word:\n                words[text[last_i:]] += 1\n\n        if not sum(words.values()):\n            raise ValueError(\n                'text must have some words using the english alphabet')\n\n        top_words = words.most_common(self.WORD_COUNT_NUM_TO_SHOW)\n        max_word_count = top_words[0][1]\n\n        sizes = [count \/ max_word_count for word, count in top_words]\n        labels = [f'{word.capitalize()} ({count})'\n                  for word, count in top_words]\n\n        word_colors = plt.cm.hsv([\n            0.8 * i \/ len(top_words)\n            for i in range(len(sizes), 0, -1)\n        ])\n\n        fig, ax = plt.subplots()\n\n        # Graph pie\n        total_words = sum(words.values())\n\n##        if len(words) > len(top_words):\n##            # Words were left out; add an \"other\" size\n##            other_count = total_words - sum(count for word, count in top_words)\n##            sizes.append(other_count \/ total_words)\n##            labels.append(f'Other ({other_count})')\n##            # Use #808080 (grey)\n##            word_colors = np.append(word_colors, [[.5, .5, .5, 1]], 0)\n\n        patches, texts, autotexts = ax.pie(\n            sizes, labels=labels, colors=word_colors, autopct='%1.2g%%',\n            startangle=0\n        )\n        # NOTE: `patches` are the wedges, `texts` are the labels, and\n        # `autotexts` is the autogenerated labels in the wedges from autopct\n\n        ax.axis('equal')  # keeps the pie's size as a circle\n\n        # Add labels\n        if len(words) <= len(top_words):\n            ax.set_title(\n                f'Top Words ({total_words:,} total)\\n'\n                f'for {ctx.author.display_name}\\n'\n            )\n        else:\n            # Words were left out\n            ax.set_title(\n                f'Top {self.WORD_COUNT_NUM_TO_SHOW} Words '\n                f'({total_words:,} total)\\n'\n                f'for {ctx.author.display_name}\\n'\n            )\n        # NOTE: newline is appended at the end just to pad it from the labels\n\n        # Set fonts\n        all_text = texts + autotexts\n        for item in ([ax.title] + all_text):\n            item.set_family('calibri')\n            item.set_color(bot_color)\n        ax.title.set_fontsize(18)\n        for item in all_text:\n            # Add shadow\n            item.set_path_effects([\n                path_effects.withSimplePatchShadow(\n                    offset=(1, -1),\n                    alpha=self.TEXT_SHADOW_ALPHA\n                )\n            ])\n        for item in texts:\n            item.set_fontsize(16)\n        for item in autotexts:\n            item.set_fontsize(12)\n\n        # Create transparent background\n        ax.set_facecolor('#00000000')\n        fig.patch.set_facecolor('#36393F4D')\n\n        f = io.BytesIO()\n        fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0)\n        # bbox_inches, pad_inches: removes padding around the graph\n\n        return f\n\n\n    @commands.command(name='wordcount')\n    @commands.cooldown(3, 120, commands.BucketType.channel)\n    @commands.max_concurrency(3, wait=True)\n    async def client_wordcount(self, ctx, *, text=''):\n        \"\"\"Count the occurrences of each word in a given text.\nThis only processes letters from the english alphabet.\n\nTo see the different methods you can use to provide text, check the help message for this command's category.\"\"\"\n        success, text = await self.get_text(ctx, text)\n        if not success:\n            return await ctx.send(text)\n\n        await ctx.trigger_typing()\n\n        loop = asyncio.get_running_loop()\n\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', UserWarning)\n            f = await loop.run_in_executor(\n                None, self.word_count_pie, ctx, text)\n        f.seek(0)\n\n        await ctx.send(file=discord.File(f, 'Word Count Pie Chart.png'))\n\n\n\n\n\n    def test_bar_graphs_3d(self):\n        \"\"\"Generates four 2D bar graphs layered in a 3D plot.\n\n        Code from: https:\/\/matplotlib.org\/3.3.3\/gallery\/mplot3d\/bars3d.html#sphx-glr-gallery-mplot3d-bars3d-py\n\n        Returns:\n            Tuple[Figure, Axes]\n\n        \"\"\"\n        bot_color = '#' + hex(utils.get_bot_color())[2:]\n\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n\n        colors = ['r', 'g', 'b', 'y']\n        yticks = [3, 2, 1, 0]\n        scale = random.uniform(0.2, 100)\n        for c, k in zip(colors, yticks):\n            # Generate the random data for the y=k 'layer'.\n            xs = np.arange(20)\n            ys = np.random.rand(20) * scale\n\n            # Plot the bar graph given by xs and ys on the plane y=k\n            # with 80% opacity.\n            ax.bar(xs, ys, zs=k, zdir='y', color=[c] * len(xs), alpha=0.8)\n\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_zlabel('Z')\n\n        # On the y axis let's only label the discrete values that\n        # we have data for.\n        ax.set_yticks(yticks)\n\n        # Set fonts\n        for item in ([ax.xaxis.label, ax.yaxis.label, ax.zaxis.label]\n                     + ax.get_xticklabels() + ax.get_yticklabels()\n                     + ax.get_zticklabels()):\n            item.set_family('calibri')\n            item.set_color(bot_color)\n\n        # Set spine and pane colors\n        for axis in (ax.w_xaxis, ax.w_yaxis, ax.w_zaxis):\n            axis.line.set_color(bot_color)\n            axis.set_pane_color((1, 1, 1, 0.1))\n\n        # Set tick colors\n        ax.tick_params(colors=bot_color)\n\n        # Create transparent background\n        ax.set_facecolor('#00000000')\n        fig.patch.set_facecolor('#36393F4D')\n\n        return fig, ax\n\n\n    def test_bar_graphs_3d_image(self, elevation=None, azimuth=None):\n        \"\"\"Generates a PNG image from test_bar_graphs_3d.\n\n        Returns:\n            BytesIO\n\n        \"\"\"\n        fig, ax = self.test_bar_graphs_3d()\n\n        # Rotate graph projection\n        ax.view_init(elevation, azimuth)\n\n        f = io.BytesIO()\n        fig.savefig(f, format='png', bbox_inches='tight', pad_inches=0)\n        # bbox_inches, pad_inches: removes padding around the graph\n\n        return f\n\n\n    @commands.command(name='test3dgraph')\n    @commands.cooldown(3, 120, commands.BucketType.channel)\n    @commands.max_concurrency(3, wait=True)\n    async def client_test3dgraph(\n            self, ctx, elevation: int = None, azimuth: int = None):\n        \"\"\"Generate a graph with some random data.\"\"\"\n        await ctx.trigger_typing()\n\n        loop = asyncio.get_running_loop()\n\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', UserWarning)\n            f = await loop.run_in_executor(\n                None, self.test_bar_graphs_3d_image, elevation, azimuth)\n        f.seek(0)\n\n        await ctx.send(file=discord.File(f, '3D Graph Test.png'))\n\n\n\n\n\n    def test_bar_graphs_3d_gif(\n            self, fp=None, start=300, frames=30, direction=-1, duration=3):\n        \"\"\"Generates a rotating 3D plot GIF from test_bar_graphs_3d.\n\n        Unfortunately there is no way to save these GIFs into memory, so\n        the file has to be written to disk.\n\n        Resources:\n            FuncAnimation: https:\/\/matplotlib.org\/api\/_as_gen\/matplotlib.animation.FuncAnimation.html\n            Animating a rotating graph: https:\/\/stackoverflow.com\/questions\/18344934\/animate-a-rotating-3d-graph-in-matplotlib\n            Saving to GIF: https:\/\/holypython.com\/how-to-save-matplotlib-animations-the-ultimate-guide\/\n\n        Args:\n            fp (Optional[str]): The filepath to save the animation to.\n                If not supplied, defaults to self.TEST_3D_GRAPH_ANIMATION_PATH.\n            start (float): The azimuth to start at.\n            frames (int): The number of azimuths to generate.\n            direction (Literal[1, -1]):\n                 1: Rotate right\n                -1: Rotate left\n            duration (float): The time in seconds for the animation to last.\n\n        Returns:\n            str: The filepath that the animation was saved to.\n\n        \"\"\"\n        if fp is None:\n            fp = self.TEST_3D_GRAPH_ANIMATION_PATH\n        fig, ax = self.test_bar_graphs_3d()\n\n        def azimuth_rotation():\n            \"Generates the azimuths rotating around the graph.\"\n            step = direction * 360 \/ frames\n\n            azimuth = start\n            for _ in range(frames):\n                yield azimuth\n                azimuth += step\n\n        def run(data):\n            \"Takes an azimuth from generate_azimuths.\"\n            ax.view_init(elev=30, azim=data)\n            return ()\n\n        anim = animation.FuncAnimation(\n            fig, run, list(azimuth_rotation()),\n            interval=duration \/ frames,\n            blit=True\n        )\n\n        anim.save(fp, writer='pillow', fps=frames \/ duration)\n\n        return fp\n\n\n    @commands.command(name='test3dgraphanimation')\n    @commands.cooldown(1, 30, commands.BucketType.default)\n    @commands.max_concurrency(1, wait=True)\n    @checks.is_bot_owner()\n    async def client_test3dgraphanimation(\n            self, ctx, frames: int = 30, duration: int = 3):\n        \"\"\"Generate an animating graph with some random data.\"\"\"\n        loop = asyncio.get_running_loop()\n\n        if duration < 1:\n            return await ctx.send('Duration must be at least 1 second.')\n        if frames < 1:\n            return await ctx.send('There must be at least 1 frame.')\n\n        func = functools.partial(\n            self.test_bar_graphs_3d_gif,\n            frames=frames,\n            duration=duration\n        )\n\n        with ctx.typing():\n            with warnings.catch_warnings():\n                warnings.simplefilter('ignore', UserWarning)\n                fp = await loop.run_in_executor(None, func)\n\n        filesize_limit = (ctx.guild.filesize_limit if ctx.guild is not None\n                          else 8_000_000)\n        filesize = Path(fp).stat().st_size\n        if filesize > filesize_limit:\n            return await ctx.send(\n                'Unfortunately the file is too large to upload.')\n\n        with open(fp, 'rb') as f:\n            await ctx.send(file=discord.File(f, '3D Graph Animation Test.gif'))\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Graphing(bot))\n"},"\/bot\/commands\/guildirish.py":{"changes":[{"diff":"\n+from typing import Optional\n+\n import discord\n from discord.ext import commands\n import inflect\n \n-from bot.classes.confirmation import Confirmation\n-from bot.database import IrishDatabase, DATABASE_IRISH\n+from bot.classes.confirmation import AdaptiveConfirmation\n+from bot.database import IrishDatabase\n from bot import checks\n from bot import utils\n \n inflector = inflect.engine()\n \n \n-def has_guild_permissions_dm_safe(*args, **kwargs):\n-    \"\"\"A variant of has_guild_permissions that does not throw NoPrivateMessage\n-    in DMs.\"\"\"\n-    original = commands.has_guild_permissions(*args, **kwargs).predicate\n-    async def predicate(ctx):\n-        return ctx.guild is not None and await original(ctx)\n-    return commands.check(predicate)\n-\n-\n class IrishSquad(commands.Cog):\n+    \"\"\"Commands for Irish Squad.\"\"\"\n     qualified_name = 'Irish Squad'\n-    description = 'Commands for Irish Squad.'\n \n     GUILD_ID = 153553830670368769\n \n+    CHARGE_LEADERBOARD_MAX = 10\n+\n     def __init__(self, bot):\n         self.bot = bot\n-        self.db = IrishDatabase(DATABASE_IRISH)\n+        self.db = IrishDatabase\n \n         if not self.bot.intents.members:\n             self.description += ('\\n**NOTE**: This category will not be '\n                                  'available in DMs at this time.')\n \n \n+    @property\n+    def guild(self) -> Optional[discord.Guild]:\n+        return self.bot.get_guild(self.GUILD_ID)\n+\n+\n     def cog_check(self, ctx):\n         if isinstance(ctx.author, discord.Member):\n             return ctx.author.guild.id == self.GUILD_ID\n \n         # In DMs; check if user is part of the guild\n-        guild = ctx.bot.get_guild(self.GUILD_ID)\n+        # NOTE: this requires members intent\n+        guild = self.guild\n         if guild is None:\n             # RIP\n             return False\n-\n-        # NOTE: this requires members intent\n         return guild.get_member(ctx.author.id) is not None\n \n \n","add":15,"remove":16,"filename":"\/bot\/commands\/guildirish.py","badparts":["from bot.classes.confirmation import Confirmation","from bot.database import IrishDatabase, DATABASE_IRISH","def has_guild_permissions_dm_safe(*args, **kwargs):","    \"\"\"A variant of has_guild_permissions that does not throw NoPrivateMessage","    in DMs.\"\"\"","    original = commands.has_guild_permissions(*args, **kwargs).predicate","    async def predicate(ctx):","        return ctx.guild is not None and await original(ctx)","    return commands.check(predicate)","    description = 'Commands for Irish Squad.'","        self.db = IrishDatabase(DATABASE_IRISH)","        guild = ctx.bot.get_guild(self.GUILD_ID)"],"goodparts":["from typing import Optional","from bot.classes.confirmation import AdaptiveConfirmation","from bot.database import IrishDatabase","    \"\"\"Commands for Irish Squad.\"\"\"","    CHARGE_LEADERBOARD_MAX = 10","        self.db = IrishDatabase","    @property","    def guild(self) -> Optional[discord.Guild]:","        return self.bot.get_guild(self.GUILD_ID)","        guild = self.guild"]},{"diff":"\n                     invoke_without_command=True)\n     async def client_charges(self, ctx):\n         \"\"\"Commands for tracking the amount of charges in the squad.\"\"\"\n-        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n+        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',\n+                       delete_after=6)\n \n \n     @client_charges.command(name='add')\n","add":2,"remove":1,"filename":"\/bot\/commands\/guildirish.py","badparts":["        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')"],"goodparts":["        await ctx.send(f'Unknown {ctx.command.name} subcommand given.',","                       delete_after=6)"]},{"diff":"\n     async def client_addcharges(self, ctx, *, amount: int):\n         \"\"\"Add to the number of charges you have.\"\"\"\n         if amount < 1:\n-            return await ctx.send('You must add at least one charge.')\n+            return await ctx.send('You must add at least one charge.',\n+                                  delete_after=6)\n \n         await ctx.channel.trigger_typing()\n \n","add":2,"remove":1,"filename":"\/bot\/commands\/guildirish.py","badparts":["            return await ctx.send('You must add at least one charge.')"],"goodparts":["            return await ctx.send('You must add at least one charge.',","                                  delete_after=6)"]},{"diff":"\n \n         await ctx.send(\n             inflector.inflect(\n-                \"Added {0} plural('charge', {0})! \"\n-                \"You now have {1} plural('charge', {1}).\".format(\n+                \"Added {0:,} plural('charge', {0})! \"\n+                \"You now have {1:,} plural('charge', {1}).\".format(\n                     amount, new_charges\n                 )\n             )\n","add":2,"remove":2,"filename":"\/bot\/commands\/guildirish.py","badparts":["                \"Added {0} plural('charge', {0})! \"","                \"You now have {1} plural('charge', {1}).\".format("],"goodparts":["                \"Added {0:,} plural('charge', {0})! \"","                \"You now have {1:,} plural('charge', {1}).\".format("]},{"diff":"\n     async def client_removecharges(self, ctx, amount: int):\n         \"\"\"Subtract from the number of charges you have.\"\"\"\n         if amount < 1:\n-            return await ctx.send('You must remove at least one charge.')\n+            return await ctx.send('You must remove at least one charge.',\n+                                  delete_after=6)\n \n         await ctx.channel.trigger_typing()\n \n","add":2,"remove":1,"filename":"\/bot\/commands\/guildirish.py","badparts":["            return await ctx.send('You must remove at least one charge.')"],"goodparts":["            return await ctx.send('You must remove at least one charge.',","                                  delete_after=6)"]},{"diff":"\n \n         if new_charges < 0:\n             return await ctx.send(inflector.inflect(\n-                \"Cannot remove {0} plural('charge', {0}); \"\n-                \"you only have {1} plural('charge', {1}).\".format(\n+                \"Cannot remove {0:,} plural('charge', {0}); \"\n+                \"you only have {1:,} plural('charge', {1}).\".format(\n                     amount, charges)\n             ))\n \n         await self.db.subtract_charges(ctx.author.id, amount)\n         await ctx.send(\n             inflector.inflect(\n-                \"Removed {0} plural('charge', {0})! \"\n-                \"You now have {1} plural('charge', {1}).\".format(\n+                \"Removed {0:,} plural('charge', {0})! \"\n+                \"You now have {1:,} plural('charge', {1}).\".format(\n                     amount, new_charges\n                 )\n             )\n","add":4,"remove":4,"filename":"\/bot\/commands\/guildirish.py","badparts":["                \"Cannot remove {0} plural('charge', {0}); \"","                \"you only have {1} plural('charge', {1}).\".format(","                \"Removed {0} plural('charge', {0})! \"","                \"You now have {1} plural('charge', {1}).\".format("],"goodparts":["                \"Cannot remove {0:,} plural('charge', {0}); \"","                \"you only have {1:,} plural('charge', {1}).\".format(","                \"Removed {0:,} plural('charge', {0})! \"","                \"You now have {1:,} plural('charge', {1}).\".format("]},{"diff":"\n \n \n \n-    @client_charges.command(name='amount')\n+    @client_charges.command(name='number', aliases=('amount',))\n     @commands.cooldown(3, 10, commands.BucketType.user)\n-    async def client_charges_amount(self, ctx, user: discord.Member = None):\n-        \"\"\"Show the amount of charges you or someone else has.\"\"\"\n+    async def client_charges_number(self, ctx, *, user: discord.User = None):\n+        \"\"\"Show the number of charges you or someone else has.\"\"\"\n         await ctx.channel.trigger_typing()\n \n-        user = user if user is not None else ctx.author\n-        charges = await self.db.get_charges(user.id)\n+        if user is None:\n+            user = ctx.author\n+\n+        try:\n+            charges = await self.db.get_charges(user.id, add_user=False)\n+        except ValueError as e:\n+            # Prevents non-members of the guild from being added\n+            # to the database\n+            raise commands.UserNotFound(user) from e\n \n         if user == ctx.author:\n             await ctx.send(inflector.inflect(\n-                \"You have {0} plural('charge', {0}).\".format(charges)\n+                \"You have {0:,} plural('charge', {0}).\".format(charges)\n             ))\n         else:\n             await ctx.send(inflector.inflect(\n-                \"{0} has {1} plural('charge', {1}).\".format(\n+                \"{0} has {1:,} plural('charge', {1}).\".format(\n                     user.display_name, charges)\n             ))\n \n","add":14,"remove":7,"filename":"\/bot\/commands\/guildirish.py","badparts":["    @client_charges.command(name='amount')","    async def client_charges_amount(self, ctx, user: discord.Member = None):","        \"\"\"Show the amount of charges you or someone else has.\"\"\"","        user = user if user is not None else ctx.author","        charges = await self.db.get_charges(user.id)","                \"You have {0} plural('charge', {0}).\".format(charges)","                \"{0} has {1} plural('charge', {1}).\".format("],"goodparts":["    @client_charges.command(name='number', aliases=('amount',))","    async def client_charges_number(self, ctx, *, user: discord.User = None):","        \"\"\"Show the number of charges you or someone else has.\"\"\"","        if user is None:","            user = ctx.author","        try:","            charges = await self.db.get_charges(user.id, add_user=False)","        except ValueError as e:","            raise commands.UserNotFound(user) from e","                \"You have {0:,} plural('charge', {0}).\".format(charges)","                \"{0} has {1:,} plural('charge', {1}).\".format("]},{"diff":"\n \n         total = sum(r['amount'] for r in rows)\n \n-        await ctx.send(inflector.inflect(\n-            \"The squad has a total of {0} plural('charge', {0}).\".format(total)\n-        ))\n+        rows = sorted((r for r in rows if r['amount'] != 0),\n+                      key=lambda r: r['amount'], reverse=True)\n+\n+        description = []\n+        for i, r in enumerate(rows, start=1):\n+            if i > self.CHARGE_LEADERBOARD_MAX:\n+                description.append('...')\n+                break\n+\n+            user = self.bot.get_user(r['user_id'])\n+            mention = user.mention if user is not None else None\n+\n+            description.append(f\"{mention}: {r['amount']:,}\")\n+\n+        embed = None\n+        if description:\n+            embed = discord.Embed(\n+                color=utils.get_bot_color(),\n+                description='\\n'.join(description)\n+            )\n+\n+        await ctx.send(\n+            inflector.inflect(\n+                \"The squad has a total of {0:,} plural('charge', {0}).\".format(\n+                    total)\n+            ),\n+            embed=embed\n+        )\n \n \n \n","add":28,"remove":3,"filename":"\/bot\/commands\/guildirish.py","badparts":["        await ctx.send(inflector.inflect(","            \"The squad has a total of {0} plural('charge', {0}).\".format(total)","        ))"],"goodparts":["        rows = sorted((r for r in rows if r['amount'] != 0),","                      key=lambda r: r['amount'], reverse=True)","        description = []","        for i, r in enumerate(rows, start=1):","            if i > self.CHARGE_LEADERBOARD_MAX:","                description.append('...')","                break","            user = self.bot.get_user(r['user_id'])","            mention = user.mention if user is not None else None","            description.append(f\"{mention}: {r['amount']:,}\")","        embed = None","        if description:","            embed = discord.Embed(","                color=utils.get_bot_color(),","                description='\\n'.join(description)","            )","        await ctx.send(","            inflector.inflect(","                \"The squad has a total of {0:,} plural('charge', {0}).\".format(","                    total)","            ),","            embed=embed","        )"]},{"diff":"\n \n     @client_charges.command(name='reset')\n     @commands.check_any(\n-        has_guild_permissions_dm_safe(manage_guild=True),\n+        commands.has_guild_permissions(manage_guild=True),\n         checks.is_bot_owner()\n     )\n-    @commands.cooldown(1, 60, commands.BucketType.guild)\n+    @commands.cooldown(1, 60)\n     async def client_charges_reset(self, ctx):\n         \"\"\"Reset the number of charges everyone has.\n This requires a confirmation.\"\"\"\n-        prompt = Confirmation(ctx, utils.get_bot_color())\n+        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())\n \n         confirmed = await prompt.confirm(\n             \"Are you sure you want to reset Irish Squad's number of charges?\")\n","add":3,"remove":3,"filename":"\/bot\/commands\/guildirish.py","badparts":["        has_guild_permissions_dm_safe(manage_guild=True),","    @commands.cooldown(1, 60, commands.BucketType.guild)","        prompt = Confirmation(ctx, utils.get_bot_color())"],"goodparts":["        commands.has_guild_permissions(manage_guild=True),","    @commands.cooldown(1, 60)","        prompt = AdaptiveConfirmation(ctx, utils.get_bot_color())"]}],"source":"\nimport discord from discord.ext import commands import inflect from bot.classes.confirmation import Confirmation from bot.database import IrishDatabase, DATABASE_IRISH from bot import checks from bot import utils inflector=inflect.engine() def has_guild_permissions_dm_safe(*args, **kwargs): \"\"\"A variant of has_guild_permissions that does not throw NoPrivateMessage in DMs.\"\"\" original=commands.has_guild_permissions(*args, **kwargs).predicate async def predicate(ctx): return ctx.guild is not None and await original(ctx) return commands.check(predicate) class IrishSquad(commands.Cog): qualified_name='Irish Squad' description='Commands for Irish Squad.' GUILD_ID=153553830670368769 def __init__(self, bot): self.bot=bot self.db=IrishDatabase(DATABASE_IRISH) if not self.bot.intents.members: self.description +=('\\n**NOTE**: This category will not be ' 'available in DMs at this time.') def cog_check(self, ctx): if isinstance(ctx.author, discord.Member): return ctx.author.guild.id==self.GUILD_ID guild=ctx.bot.get_guild(self.GUILD_ID) if guild is None: return False return guild.get_member(ctx.author.id) is not None @commands.group(name='charges', aliases=('charge',), invoke_without_command=True) async def client_charges(self, ctx): \"\"\"Commands for tracking the amount of charges in the squad.\"\"\" await ctx.send(f'Unknown{ctx.command.name} subcommand given.') @client_charges.command(name='add') @commands.cooldown(3, 10, commands.BucketType.user) async def client_addcharges(self, ctx, *, amount: int): \"\"\"Add to the number of charges you have.\"\"\" if amount < 1: return await ctx.send('You must add at least one charge.') await ctx.channel.trigger_typing() await self.db.add_charges(ctx.author.id, amount) new_charges=await self.db.get_charges(ctx.author.id) await ctx.send( inflector.inflect( \"Added{0} plural('charge',{0})! \" \"You now have{1} plural('charge',{1}).\".format( amount, new_charges ) ) ) @client_charges.command(name='remove') @commands.cooldown(3, 10, commands.BucketType.user) async def client_removecharges(self, ctx, amount: int): \"\"\"Subtract from the number of charges you have.\"\"\" if amount < 1: return await ctx.send('You must remove at least one charge.') await ctx.channel.trigger_typing() charges=await self.db.get_charges(ctx.author.id) new_charges=charges -amount if new_charges < 0: return await ctx.send(inflector.inflect( \"Cannot remove{0} plural('charge',{0}); \" \"you only have{1} plural('charge',{1}).\".format( amount, charges) )) await self.db.subtract_charges(ctx.author.id, amount) await ctx.send( inflector.inflect( \"Removed{0} plural('charge',{0})! \" \"You now have{1} plural('charge',{1}).\".format( amount, new_charges ) ) ) @client_charges.command(name='amount') @commands.cooldown(3, 10, commands.BucketType.user) async def client_charges_amount(self, ctx, user: discord.Member=None): \"\"\"Show the amount of charges you or someone else has.\"\"\" await ctx.channel.trigger_typing() user=user if user is not None else ctx.author charges=await self.db.get_charges(user.id) if user==ctx.author: await ctx.send(inflector.inflect( \"You have{0} plural('charge',{0}).\".format(charges) )) else: await ctx.send(inflector.inflect( \"{0} has{1} plural('charge',{1}).\".format( user.display_name, charges) )) @client_charges.command(name='total') @commands.cooldown(2, 10, commands.BucketType.channel) async def client_charges_guildtotal(self, ctx): \"\"\"Show the squad's total charges.\"\"\" await ctx.channel.trigger_typing() rows=await self.db.get_rows('Charges') total=sum(r['amount'] for r in rows) await ctx.send(inflector.inflect( \"The squad has a total of{0} plural('charge',{0}).\".format(total) )) @client_charges.command(name='reset') @commands.check_any( has_guild_permissions_dm_safe(manage_guild=True), checks.is_bot_owner() ) @commands.cooldown(1, 60, commands.BucketType.guild) async def client_charges_reset(self, ctx): \"\"\"Reset the number of charges everyone has. This requires a confirmation.\"\"\" prompt=Confirmation(ctx, utils.get_bot_color()) confirmed=await prompt.confirm( \"Are you sure you want to reset Irish Squad's number of charges?\") if confirmed: await self.db.delete_rows('Charges', where='1') await prompt.update('Completed charge wipe!', prompt.emoji_yes.color) else: await prompt.update('Cancelled charge wipe.', prompt.emoji_no.color) def setup(bot): bot.add_cog(IrishSquad(bot)) ","sourceWithComments":"import discord\nfrom discord.ext import commands\nimport inflect\n\nfrom bot.classes.confirmation import Confirmation\nfrom bot.database import IrishDatabase, DATABASE_IRISH\nfrom bot import checks\nfrom bot import utils\n\ninflector = inflect.engine()\n\n\ndef has_guild_permissions_dm_safe(*args, **kwargs):\n    \"\"\"A variant of has_guild_permissions that does not throw NoPrivateMessage\n    in DMs.\"\"\"\n    original = commands.has_guild_permissions(*args, **kwargs).predicate\n    async def predicate(ctx):\n        return ctx.guild is not None and await original(ctx)\n    return commands.check(predicate)\n\n\nclass IrishSquad(commands.Cog):\n    qualified_name = 'Irish Squad'\n    description = 'Commands for Irish Squad.'\n\n    GUILD_ID = 153553830670368769\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.db = IrishDatabase(DATABASE_IRISH)\n\n        if not self.bot.intents.members:\n            self.description += ('\\n**NOTE**: This category will not be '\n                                 'available in DMs at this time.')\n\n\n    def cog_check(self, ctx):\n        if isinstance(ctx.author, discord.Member):\n            return ctx.author.guild.id == self.GUILD_ID\n\n        # In DMs; check if user is part of the guild\n        guild = ctx.bot.get_guild(self.GUILD_ID)\n        if guild is None:\n            # RIP\n            return False\n\n        # NOTE: this requires members intent\n        return guild.get_member(ctx.author.id) is not None\n\n\n\n\n\n    @commands.group(name='charges', aliases=('charge',),\n                    invoke_without_command=True)\n    async def client_charges(self, ctx):\n        \"\"\"Commands for tracking the amount of charges in the squad.\"\"\"\n        await ctx.send(f'Unknown {ctx.command.name} subcommand given.')\n\n\n    @client_charges.command(name='add')\n    @commands.cooldown(3, 10, commands.BucketType.user)\n    async def client_addcharges(self, ctx, *, amount: int):\n        \"\"\"Add to the number of charges you have.\"\"\"\n        if amount < 1:\n            return await ctx.send('You must add at least one charge.')\n\n        await ctx.channel.trigger_typing()\n\n        await self.db.add_charges(ctx.author.id, amount)\n        new_charges = await self.db.get_charges(ctx.author.id)\n\n        await ctx.send(\n            inflector.inflect(\n                \"Added {0} plural('charge', {0})! \"\n                \"You now have {1} plural('charge', {1}).\".format(\n                    amount, new_charges\n                )\n            )\n        )\n\n\n\n\n\n    @client_charges.command(name='remove')\n    @commands.cooldown(3, 10, commands.BucketType.user)\n    async def client_removecharges(self, ctx, amount: int):\n        \"\"\"Subtract from the number of charges you have.\"\"\"\n        if amount < 1:\n            return await ctx.send('You must remove at least one charge.')\n\n        await ctx.channel.trigger_typing()\n\n        charges = await self.db.get_charges(ctx.author.id)\n        new_charges = charges - amount\n\n        if new_charges < 0:\n            return await ctx.send(inflector.inflect(\n                \"Cannot remove {0} plural('charge', {0}); \"\n                \"you only have {1} plural('charge', {1}).\".format(\n                    amount, charges)\n            ))\n\n        await self.db.subtract_charges(ctx.author.id, amount)\n        await ctx.send(\n            inflector.inflect(\n                \"Removed {0} plural('charge', {0})! \"\n                \"You now have {1} plural('charge', {1}).\".format(\n                    amount, new_charges\n                )\n            )\n        )\n\n\n\n\n\n    @client_charges.command(name='amount')\n    @commands.cooldown(3, 10, commands.BucketType.user)\n    async def client_charges_amount(self, ctx, user: discord.Member = None):\n        \"\"\"Show the amount of charges you or someone else has.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        user = user if user is not None else ctx.author\n        charges = await self.db.get_charges(user.id)\n\n        if user == ctx.author:\n            await ctx.send(inflector.inflect(\n                \"You have {0} plural('charge', {0}).\".format(charges)\n            ))\n        else:\n            await ctx.send(inflector.inflect(\n                \"{0} has {1} plural('charge', {1}).\".format(\n                    user.display_name, charges)\n            ))\n\n\n\n\n\n    @client_charges.command(name='total')\n    @commands.cooldown(2, 10, commands.BucketType.channel)\n    async def client_charges_guildtotal(self, ctx):\n        \"\"\"Show the squad's total charges.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        rows = await self.db.get_rows('Charges')\n\n        total = sum(r['amount'] for r in rows)\n\n        await ctx.send(inflector.inflect(\n            \"The squad has a total of {0} plural('charge', {0}).\".format(total)\n        ))\n\n\n\n\n\n    @client_charges.command(name='reset')\n    @commands.check_any(\n        has_guild_permissions_dm_safe(manage_guild=True),\n        checks.is_bot_owner()\n    )\n    @commands.cooldown(1, 60, commands.BucketType.guild)\n    async def client_charges_reset(self, ctx):\n        \"\"\"Reset the number of charges everyone has.\nThis requires a confirmation.\"\"\"\n        prompt = Confirmation(ctx, utils.get_bot_color())\n\n        confirmed = await prompt.confirm(\n            \"Are you sure you want to reset Irish Squad's number of charges?\")\n\n        if confirmed:\n            await self.db.delete_rows('Charges', where='1')\n\n            await prompt.update('Completed charge wipe!',\n                                prompt.emoji_yes.color)\n        else:\n            await prompt.update('Cancelled charge wipe.',\n                                prompt.emoji_no.color)\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(IrishSquad(bot))\n"},"\/bot\/commands\/helpcommand.py":{"changes":[{"diff":"\n                 the input that caused it,\n                 and the command that doesn't have the requested subcommand.\n         \"\"\"\n-        if isinstance(command, Group) and len(command.all_commands) > 0:\n+        if isinstance(command, commands.Group) and len(command.all_commands) > 0:\n             message = 'Command \"{}\" has no subcommand named {}'.format(\n                 command.qualified_name, string)\n         else:\n","add":1,"remove":1,"filename":"\/bot\/commands\/helpcommand.py","badparts":["        if isinstance(command, Group) and len(command.all_commands) > 0:"],"goodparts":["        if isinstance(command, commands.Group) and len(command.all_commands) > 0:"]},{"diff":"\n                 # haven't recently received one\n                 if not message_length_cooldown.update_rate_limit(ctx.message):\n                     await destination.send(\n-                        'Help message is a bit long; sent it to you in DMs.')\n+                        'Help message is a bit long; sent it to you in DMs.',\n+                        delete_after=8\n+                    )\n         else:\n             await destination.send(content, embed=embed, *args, **kwargs)\n \n","add":3,"remove":1,"filename":"\/bot\/commands\/helpcommand.py","badparts":["                        'Help message is a bit long; sent it to you in DMs.')"],"goodparts":["                        'Help message is a bit long; sent it to you in DMs.',","                        delete_after=8","                    )"]},{"diff":"\n         return embed\n \n     async def get_commands(self):\n-        \"\"\"Return all sorted commands the bot has categorized by sorted cogs.\n+        \"\"\"Return all sorted commands the bot has, categorized by sorted cogs.\n \n         Returns:\n-            List[commands.Cog, List[commands.Command]]\n+            List[Optional[commands.Cog], List[commands.Command]]\n \n         \"\"\"\n         categories = collections.defaultdict(list)\n \n-        for command in await self.filter_commands(self.context.bot.commands):\n-            categories[type(command.cog)].append(command)\n+        for cmd in await self.filter_commands(self.context.bot.commands):\n+            categories[cmd.cog].append(cmd)\n \n         # Create a paired list of of the dictionary\n         categories_list = sorted(\n","add":4,"remove":4,"filename":"\/bot\/commands\/helpcommand.py","badparts":["        \"\"\"Return all sorted commands the bot has categorized by sorted cogs.","            List[commands.Cog, List[commands.Command]]","        for command in await self.filter_commands(self.context.bot.commands):","            categories[type(command.cog)].append(command)"],"goodparts":["        \"\"\"Return all sorted commands the bot has, categorized by sorted cogs.","            List[Optional[commands.Cog], List[commands.Command]]","        for cmd in await self.filter_commands(self.context.bot.commands):","            categories[cmd.cog].append(cmd)"]},{"diff":"\n         )\n \n         # Sort each command by name\n-        for _, commands in categories_list:\n-            commands.sort(key=lambda x: x.qualified_name)\n+        for _, cmds in categories_list:\n+            cmds.sort(key=lambda x: x.qualified_name)\n \n         return categories_list\n \n","add":2,"remove":2,"filename":"\/bot\/commands\/helpcommand.py","badparts":["        for _, commands in categories_list:","            commands.sort(key=lambda x: x.qualified_name)"],"goodparts":["        for _, cmds in categories_list:","            cmds.sort(key=lambda x: x.qualified_name)"]},{"diff":"\n                 cog = self.context.bot.get_cog(string)\n             except (IndexError, ValueError):\n                 # Not a page number request\n-                await self.send(error)\n+                await self.send(error, delete_after=6)\n                 return\n \n         if cog is None:\n","add":1,"remove":1,"filename":"\/bot\/commands\/helpcommand.py","badparts":["                await self.send(error)"],"goodparts":["                await self.send(error, delete_after=6)"]},{"diff":"\n                 embed = await self.create_help_category_page(page_num=page_num)\n             except ValueError as e:\n                 # Invalid page number\n-                await destination.send(str(e))\n+                await destination.send(str(e), delete_after=6)\n             else:\n                 await self.send(embed=embed)\n         else:\n","add":1,"remove":1,"filename":"\/bot\/commands\/helpcommand.py","badparts":["                await destination.send(str(e))"],"goodparts":["                await destination.send(str(e), delete_after=6)"]},{"diff":"\n                 embed = await self.create_help_cog_page(cog, page_num=page_num)\n             except ValueError as e:\n                 # Invalid page number\n-                await destination.send(str(e))\n+                await destination.send(str(e), delete_after=6)\n             else:\n                 await self.send(embed=embed)\n \n","add":1,"remove":1,"filename":"\/bot\/commands\/helpcommand.py","badparts":["                await destination.send(str(e))"],"goodparts":["                await destination.send(str(e), delete_after=6)"]},{"diff":"\n         embed = discord.Embed(\n             title=self.get_command_signature(group),\n             color=utils.get_bot_color(),\n-            description=group.description\n+            description=group.help or group.short_doc\n         )\n \n         # Add fields\n","add":1,"remove":1,"filename":"\/bot\/commands\/helpcommand.py","badparts":["            description=group.description"],"goodparts":["            description=group.help or group.short_doc"]},{"diff":"\n \n     async def send_command_help(self, command):\n         \"Sends help for an individual command.\"\n-        description = f'`{self.get_command_signature(command)}`\\n'\n+        description = [f'`{self.get_command_signature(command)}`\\n']\n \n         if command.help:\n-            description += f'```{command.help}```'\n+            description.append(command.help)\n         elif command.short_doc:\n-            description += f'```{command.short_doc}```'\n+            description.append(command.short_doc)\n         else:\n-            description += 'There is no description for this command.'\n+            description.append('There is no description for this command.')\n \n         embed = discord.Embed(\n             title=command.qualified_name,\n             color=utils.get_bot_color(),\n-            description=description\n+            description=''.join(description)\n         )\n         if command.cog is not None:\n             embed.set_author(name=f'In {command.cog.qualified_name","add":5,"remove":5,"filename":"\/bot\/commands\/helpcommand.py","badparts":["        description = f'`{self.get_command_signature(command)}`\\n'","            description += f'```{command.help}```'","            description += f'```{command.short_doc}```'","            description += 'There is no description for this command.'","            description=description"],"goodparts":["        description = [f'`{self.get_command_signature(command)}`\\n']","            description.append(command.help)","            description.append(command.short_doc)","            description.append('There is no description for this command.')","            description=''.join(description)"]}],"source":"\n\"Reference: https:\/\/gist.github.com\/Gobot1234\/45cad24df63fc144e85a7f8c85812567\" import collections import math import discord from discord.ext import commands from bot import settings from bot import utils message_length_cooldown=commands.CooldownMapping.from_cooldown( 1, 30, commands.BucketType.user) class HelpCommand(commands.HelpCommand): help_categories_per_page=9 help_commands_per_category=5 help_cog_commands_per_page=9 help_message_length_threshold=300 def __init__(self): super().__init__( command_attrs={ 'help': 'Shows help about the bot, a command, or a category', 'cooldown': commands.Cooldown(2, 3, commands.BucketType.user) } ) def command_not_found(self, string): \"\"\"A method called when a command is not found in the help command. Defaults to ``No command called{0} found.`` Args: string(str): The string that contains the invalid command. Note that this has had mentions removed to prevent abuse. Returns: Tuple[str, str]: The error message to show, and the input that caused it. \"\"\" return 'No command called \"{}\" found.'.format(string), string def subcommand_not_found(self, command, string): \"\"\"A method called when a command did not have a subcommand requested in the help command. Defaults to either: -'Command \"{command.qualified_name}\" has no subcommands.' If there is no subcommand in the ``command`` parameter. -'Command \"{command.qualified_name}\" has no subcommand named{string}' If the `command` parameter has subcommands but not one named `string`. Args: command(commands.Command): The command that did not have the subcommand requested. string(str): The string that contains the invalid subcommand. Note that this has had mentions removed to prevent abuse. Returns: Tuple[str, str, commands.Command]: The error message to show, the input that caused it, and the command that doesn't have the requested subcommand. \"\"\" if isinstance(command, Group) and len(command.all_commands) > 0: message='Command \"{}\" has no subcommand named{}'.format( command.qualified_name, string) else: message='Command \"{}\" has no subcommands.'.format( command.qualified_name) return message, string, command async def send(self, content=None, *args, embed=None, **kwargs): \"\"\"Send a message to the user, diverting it to DMs if the message is too long.\"\"\" length=0 if content is not None: length +=len(content) if embed is not None: length +=len(embed) destination=self.get_destination() ctx=self.context if length >=self.help_message_length_threshold: await ctx.author.send(content, embed=embed, *args, **kwargs) if ctx.guild is not None: if not message_length_cooldown.update_rate_limit(ctx.message): await destination.send( 'Help message is a bit long; sent it to you in DMs.') else: await destination.send(content, embed=embed, *args, **kwargs) async def create_help_category_page(self, *, page_num): \"Create an embed showing a page of categories.\" categories: list=await self.get_commands() total_pages=math.ceil( len(categories) \/ self.help_categories_per_page) if page_num not in range(1, total_pages +1): if total_pages==1: raise ValueError('Page number must be 1.') raise ValueError( f'Page number must be between 1 and{total_pages}.') embed=discord.Embed( title=f'Page{page_num}\/{total_pages}', color=utils.get_bot_color(), description=( 'Type{0}help[command] for more info on a command.\\n' 'You can also type{0}help[category] for ' 'more info on a category(do not type spaces in the ' \"category's name).\".format(self.clean_prefix) ) ) fields=[] skip_to=self.help_categories_per_page *(page_num -1) categories_to_add=self.help_categories_per_page for category, commands in categories: if skip_to: skip_to -=1 continue if not categories_to_add: break field_text=[] for i, com in enumerate(commands, 1): if i==self.help_commands_per_category and len(commands) !=i: field_text.append('...') break else: field_text.append(com.qualified_name) field_text='\\n'.join(field_text) fields.append((category.qualified_name, field_text)) categories_to_add -=1 for field in fields: embed.add_field(name=field[0], value=field[1]) return embed async def create_help_cog_page(self, cog, *, page_num): \"Create an embed showing a page of commands in a cog.\" commands=await self.filter_commands(cog.get_commands(), sort=True) total_pages=math.ceil( len(commands) \/ self.help_cog_commands_per_page) if page_num not in range(1, total_pages +1): if total_pages==1: raise ValueError('Page number must be 1.') elif total_pages==0: return discord.Embed( title='Category help unavailable', color=utils.get_bot_color(), description=( 'This category exists, but you cannot access any ' 'of its commands here.' ) ) raise ValueError( f'Page number must be between 1 and{total_pages}.') embed=discord.Embed( title=f'{cog.qualified_name} -Page{page_num}\/{total_pages}', color=utils.get_bot_color(), description=( f'{cog.description}\\nType{self.clean_prefix}help[command] ' 'for more info on a command.' ) ) fields=[] skip_to=self.help_cog_commands_per_page *(page_num -1) categories_to_add=self.help_cog_commands_per_page for com in commands: if skip_to: skip_to -=1 continue if not categories_to_add: break fields.append( (com.qualified_name, com.short_doc if com.short_doc else 'No description.') ) categories_to_add -=1 for field in fields: embed.add_field(name=field[0], value=field[1]) return embed async def get_commands(self): \"\"\"Return all sorted commands the bot has categorized by sorted cogs. Returns: List[commands.Cog, List[commands.Command]] \"\"\" categories=collections.defaultdict(list) for command in await self.filter_commands(self.context.bot.commands): categories[type(command.cog)].append(command) categories_list=sorted( categories.items(), key=lambda x: x[0].qualified_name ) for _, commands in categories_list: commands.sort(key=lambda x: x.qualified_name) return categories_list async def send_error_message(self, error): \"\"\"Sends a help page if the user asks for a specific page. Otherwise, sends an error message. The result of `command_not_found` or `command_has_no_subcommand_found` will be passed here. Args: error(str): The error message to display to the user. Note that this has had mentions removed to prevent abuse. \"\"\" destination=self.get_destination() error, string, *command=error command=command[0] if command else None try: cog, page_num=None, int(string) except ValueError: try: page_num=int(self.context.kwargs['command'].split()[1]) cog=self.context.bot.get_cog(string) except(IndexError, ValueError): await self.send(error) return if cog is None: try: embed=await self.create_help_category_page(page_num=page_num) except ValueError as e: await destination.send(str(e)) else: await self.send(embed=embed) else: try: embed=await self.create_help_cog_page(cog, page_num=page_num) except ValueError as e: await destination.send(str(e)) else: await self.send(embed=embed) async def send_bot_help(self, mapping): \"Sends help when no arguments are given.\" embed=await self.create_help_category_page(page_num=1) await self.send(embed=embed) async def send_cog_help(self, cog): \"Sends help for a specific cog.\" embed=await self.create_help_cog_page(cog, page_num=1) await self.send(embed=embed) async def send_group_help(self, group): \"\"\"Sends help for an individual group. NOTE: Does not support groups containing over 25 commands. \"\"\" embed=discord.Embed( title=self.get_command_signature(group), color=utils.get_bot_color(), description=group.description ) for com in group.commands: embed.add_field( name=com.name, value=com.short_doc if com.short_doc else 'No description.' ) await self.send(embed=embed) async def send_command_help(self, command): \"Sends help for an individual command.\" description=f'`{self.get_command_signature(command)}`\\n' if command.help: description +=f'```{command.help}```' elif command.short_doc: description +=f'```{command.short_doc}```' else: description +='There is no description for this command.' embed=discord.Embed( title=command.qualified_name, color=utils.get_bot_color(), description=description ) if command.cog is not None: embed.set_author(name=f'In{command.cog.qualified_name} category') await self.send(embed=embed) ","sourceWithComments":"\"Reference: https:\/\/gist.github.com\/Gobot1234\/45cad24df63fc144e85a7f8c85812567\"\nimport collections\nimport math\n\nimport discord\nfrom discord.ext import commands\n\nfrom bot import settings\nfrom bot import utils\n\n\nmessage_length_cooldown = commands.CooldownMapping.from_cooldown(\n    1, 30, commands.BucketType.user)\n\nclass HelpCommand(commands.HelpCommand):\n\n    help_categories_per_page = 9  # Max of 25 fields\n    help_commands_per_category = 5\n\n    help_cog_commands_per_page = 9  # Max of 25 fields\n\n    help_message_length_threshold = 300\n    # Maximum allowed characters in a help message before it is sent via DM\n\n    def __init__(self):\n        super().__init__(\n            command_attrs={\n                # This is the command.help string\n                'help': 'Shows help about the bot, a command, or a category',\n                # this is a custom attribute passed to the help command\n                'cooldown': commands.Cooldown(2, 3, commands.BucketType.user)\n            }\n        )\n\n    def command_not_found(self, string):\n        \"\"\"A method called when a command is not found in the help command.\n\n        Defaults to ``No command called {0} found.``\n\n        Args:\n            string (str):\n                The string that contains the invalid command.\n                Note that this has had mentions removed to prevent abuse.\n\n        Returns:\n            Tuple[str, str]:\n                The error message to show, and the input that caused\n                it.\n        \"\"\"\n        return 'No command called \"{}\" found.'.format(string), string\n\n    def subcommand_not_found(self, command, string):\n        \"\"\"A method called when a command did not have a subcommand\n        requested in the help command.\n\n        Defaults to either:\n        - 'Command \"{command.qualified_name}\" has no subcommands.'\n          If there is no subcommand in the ``command`` parameter.\n        - 'Command \"{command.qualified_name}\" has no subcommand named {string}'\n          If the `command` parameter has subcommands\n          but not one named `string`.\n\n        Args:\n            command (commands.Command):\n                The command that did not have the subcommand requested.\n            string (str):\n                The string that contains the invalid subcommand.\n                Note that this has had mentions removed to prevent abuse.\n\n        Returns:\n            Tuple[str, str, commands.Command]:\n                The error message to show,\n                the input that caused it,\n                and the command that doesn't have the requested subcommand.\n        \"\"\"\n        if isinstance(command, Group) and len(command.all_commands) > 0:\n            message = 'Command \"{}\" has no subcommand named {}'.format(\n                command.qualified_name, string)\n        else:\n            message = 'Command \"{}\" has no subcommands.'.format(\n                command.qualified_name)\n\n        return message, string, command\n\n    async def send(self, content=None, *args, embed=None, **kwargs):\n        \"\"\"Send a message to the user, diverting it to DMs\n        if the message is too long.\"\"\"\n        length = 0\n        if content is not None:\n            length += len(content)\n        if embed is not None:\n            length += len(embed)\n\n        destination = self.get_destination()\n        ctx = self.context\n\n        if length >= self.help_message_length_threshold:\n            # Too long; send in DMs\n            await ctx.author.send(content, embed=embed, *args, **kwargs)\n\n            if ctx.guild is not None:\n                # User sent command in server; only give notification if they\n                # haven't recently received one\n                if not message_length_cooldown.update_rate_limit(ctx.message):\n                    await destination.send(\n                        'Help message is a bit long; sent it to you in DMs.')\n        else:\n            await destination.send(content, embed=embed, *args, **kwargs)\n\n    async def create_help_category_page(self, *, page_num):\n        \"Create an embed showing a page of categories.\"\n        categories: list = await self.get_commands()\n\n        total_pages = math.ceil(\n            len(categories) \/ self.help_categories_per_page)\n\n        # Check if page num is valid\n        if page_num not in range(1, total_pages + 1):\n            if total_pages == 1:\n                raise ValueError('Page number must be 1.')\n            raise ValueError(\n                f'Page number must be between 1 and {total_pages}.')\n\n        embed = discord.Embed(\n            title=f'Page {page_num}\/{total_pages}',\n            color=utils.get_bot_color(),\n            description=(\n                'Type {0}help [command] for more info on a command.\\n'\n                'You can also type {0}help [category] for '\n                'more info on a category (do not type spaces in the '\n                \"category's name).\".format(self.clean_prefix)\n            )\n        )\n\n        # Create fields\n        fields = []\n        skip_to = self.help_categories_per_page * (page_num - 1)\n        categories_to_add = self.help_categories_per_page\n        for category, commands in categories:\n            if skip_to:\n                skip_to -= 1\n                continue\n            if not categories_to_add:\n                break\n\n            # Create string listing commands\n            field_text = []\n            for i, com in enumerate(commands, 1):\n                if i == self.help_commands_per_category and len(commands) != i:\n                    # Too many commands to show\n                    field_text.append('...')\n                    break\n                else:\n                    field_text.append(com.qualified_name)\n            field_text = '\\n'.join(field_text)\n\n            fields.append((category.qualified_name, field_text))\n\n            categories_to_add -= 1\n\n        for field in fields:\n            embed.add_field(name=field[0], value=field[1])\n\n        return embed\n\n    async def create_help_cog_page(self, cog, *, page_num):\n        \"Create an embed showing a page of commands in a cog.\"\n        commands = await self.filter_commands(cog.get_commands(), sort=True)\n\n        total_pages = math.ceil(\n            len(commands) \/ self.help_cog_commands_per_page)\n\n        # Check if page num is valid\n        if page_num not in range(1, total_pages + 1):\n            if total_pages == 1:\n                raise ValueError('Page number must be 1.')\n            elif total_pages == 0:\n                # All commands in this cog are hidden\n                return discord.Embed(\n                    title='Category help unavailable',\n                    color=utils.get_bot_color(),\n                    description=(\n                        'This category exists, but you cannot access any '\n                        'of its commands here.'\n                    )\n                )\n            raise ValueError(\n                f'Page number must be between 1 and {total_pages}.')\n\n        embed = discord.Embed(\n            title=f'{cog.qualified_name} - Page {page_num}\/{total_pages}',\n            color=utils.get_bot_color(),\n            description=(\n                f'{cog.description}\\nType {self.clean_prefix}help [command] '\n                'for more info on a command.'\n            )\n        )\n\n        # Create fields\n        fields = []\n        skip_to = self.help_cog_commands_per_page * (page_num - 1)\n        categories_to_add = self.help_cog_commands_per_page\n        for com in commands:\n            if skip_to:\n                skip_to -= 1\n                continue\n            if not categories_to_add:\n                break\n\n            fields.append(\n                (com.qualified_name,\n                 com.short_doc if com.short_doc else 'No description.')\n            )\n\n            categories_to_add -= 1\n\n        for field in fields:\n            embed.add_field(name=field[0], value=field[1])\n\n        return embed\n\n    async def get_commands(self):\n        \"\"\"Return all sorted commands the bot has categorized by sorted cogs.\n\n        Returns:\n            List[commands.Cog, List[commands.Command]]\n\n        \"\"\"\n        categories = collections.defaultdict(list)\n\n        for command in await self.filter_commands(self.context.bot.commands):\n            categories[type(command.cog)].append(command)\n\n        # Create a paired list of of the dictionary\n        categories_list = sorted(\n            categories.items(),\n            key=lambda x: x[0].qualified_name\n        )\n\n        # Sort each command by name\n        for _, commands in categories_list:\n            commands.sort(key=lambda x: x.qualified_name)\n\n        return categories_list\n\n    async def send_error_message(self, error):\n        \"\"\"Sends a help page if the user asks for a specific page.\n        Otherwise, sends an error message.\n\n        The result of `command_not_found` or\n        `command_has_no_subcommand_found` will be passed here.\n\n        Args:\n            error (str):\n                The error message to display to the user. Note that this has\n                had mentions removed to prevent abuse.\n\n        \"\"\"\n        destination = self.get_destination()\n\n        error, string, *command = error\n        command = command[0] if command else None\n\n        try:\n            # Try converting into a page number\n            cog, page_num = None, int(string)\n        except ValueError:\n            try:\n                # Get and try converting page number\n                page_num = int(self.context.kwargs['command'].split()[1])\n                cog = self.context.bot.get_cog(string)\n            except (IndexError, ValueError):\n                # Not a page number request\n                await self.send(error)\n                return\n\n        if cog is None:\n            # User requested a help page\n            try:\n                embed = await self.create_help_category_page(page_num=page_num)\n            except ValueError as e:\n                # Invalid page number\n                await destination.send(str(e))\n            else:\n                await self.send(embed=embed)\n        else:\n            # User requested a cog help page\n            try:\n                embed = await self.create_help_cog_page(cog, page_num=page_num)\n            except ValueError as e:\n                # Invalid page number\n                await destination.send(str(e))\n            else:\n                await self.send(embed=embed)\n\n    async def send_bot_help(self, mapping):\n        \"Sends help when no arguments are given.\"\n        embed = await self.create_help_category_page(page_num=1)\n\n        await self.send(embed=embed)\n\n    async def send_cog_help(self, cog):\n        \"Sends help for a specific cog.\"\n        embed = await self.create_help_cog_page(cog, page_num=1)\n\n        await self.send(embed=embed)\n\n    async def send_group_help(self, group):\n        \"\"\"Sends help for an individual group.\n\n        NOTE: Does not support groups containing over 25 commands.\n\n        \"\"\"\n        embed = discord.Embed(\n            title=self.get_command_signature(group),\n            color=utils.get_bot_color(),\n            description=group.description\n        )\n\n        # Add fields\n        for com in group.commands:\n            embed.add_field(\n                name=com.name,\n                value=com.short_doc if com.short_doc else 'No description.'\n            )\n\n        await self.send(embed=embed)\n\n    async def send_command_help(self, command):\n        \"Sends help for an individual command.\"\n        description = f'`{self.get_command_signature(command)}`\\n'\n\n        if command.help:\n            description += f'```{command.help}```'\n        elif command.short_doc:\n            description += f'```{command.short_doc}```'\n        else:\n            description += 'There is no description for this command.'\n\n        embed = discord.Embed(\n            title=command.qualified_name,\n            color=utils.get_bot_color(),\n            description=description\n        )\n        if command.cog is not None:\n            embed.set_author(name=f'In {command.cog.qualified_name} category')\n\n        await self.send(embed=embed)\n"},"\/bot\/commands\/images.py":{"changes":[{"diff":"\n \n \n class Images(commands.Cog):\n+    \"\"\"Commands for getting images.\"\"\"\n     qualified_name = 'Images'\n-    description = 'Commands for getting images.'\n \n     def __init__(self, bot):\n         self.bot = bot\n","add":1,"remove":1,"filename":"\/bot\/commands\/images.py","badparts":["    description = 'Commands for getting images.'"],"goodparts":["    \"\"\"Commands for getting images.\"\"\""]},{"diff":"\n     async def client_getcatimage(self, ctx):\n         \"\"\"\\N{CAT FACE}\"\"\"\n         if CAT_API_KEY is None:\n-            return await ctx.send('Sorry, but the bot currently cannot '\n-                                  'query for a cat image.')\n+            await ctx.send(\n+                'Sorry, but the bot currently cannot query for a cat image.',\n+                delete_after=10\n+            )\n+            return await asyncio.sleep(10)\n \n         await ctx.trigger_typing()\n \n         try:\n             cat = await query_thatapiguy(CAT_API_URL, CAT_API_KEY)\n         except ValueError as e:\n-            return await ctx.send('Could not get a cat image; '\n-                                  f'status code {e.args[1]}')\n+            return await ctx.send(\n+                f'Could not get a cat image; status code {e.args[1]}',\n+                delete_after=8\n+            )\n \n         await ctx.send(embed=embed_thatapiguy(ctx, cat))\n \n","add":9,"remove":4,"filename":"\/bot\/commands\/images.py","badparts":["            return await ctx.send('Sorry, but the bot currently cannot '","                                  'query for a cat image.')","            return await ctx.send('Could not get a cat image; '","                                  f'status code {e.args[1]}')"],"goodparts":["            await ctx.send(","                'Sorry, but the bot currently cannot query for a cat image.',","                delete_after=10","            )","            return await asyncio.sleep(10)","            return await ctx.send(","                f'Could not get a cat image; status code {e.args[1]}',","                delete_after=8","            )"]},{"diff":"\n     async def client_getdogimage(self, ctx):\n         \"\"\"\\N{DOG FACE}\"\"\"\n         if DOG_API_KEY is None:\n-            return await ctx.send('Sorry, but the bot currently cannot '\n-                                  'query for a dog image.')\n+            await ctx.send(\n+                'Sorry, but the bot currently cannot query for a dog image.',\n+                delete_after=10\n+            )\n+            return await asyncio.sleep(10)\n \n         await ctx.trigger_typing()\n \n         try:\n             dog = await query_thatapiguy(DOG_API_URL, DOG_API_KEY)\n         except ValueError as e:\n-            return await ctx.send('Failed to query a dog image; '\n-                                  f'status code {e.args[1]}')\n+            return await ctx.send(\n+                f'Failed to query a dog image; status code {e.args[1]}',\n+                delete_after=8\n+            )\n \n         await ctx.send(embed=embed_thatapiguy","add":9,"remove":4,"filename":"\/bot\/commands\/images.py","badparts":["            return await ctx.send('Sorry, but the bot currently cannot '","                                  'query for a dog image.')","            return await ctx.send('Failed to query a dog image; '","                                  f'status code {e.args[1]}')"],"goodparts":["            await ctx.send(","                'Sorry, but the bot currently cannot query for a dog image.',","                delete_after=10","            )","            return await asyncio.sleep(10)","            return await ctx.send(","                f'Failed to query a dog image; status code {e.args[1]}',","                delete_after=8","            )"]}],"source":"\nimport json import os import random import aiohttp import discord from discord.ext import commands from bot import utils CAT_API_URL='https:\/\/api.thecatapi.com\/' CAT_API_KEY=os.getenv('PyDiscordBotAPICatKey') DOG_API_URL='https:\/\/api.thedogapi.com\/' DOG_API_KEY=os.getenv('PyDiscordBotAPIDogKey') async def query_thatapiguy(url, key): search='v1\/images\/search?mime_types=jpg,png' async with aiohttp.ClientSession( headers={'x-api-key': key}) as session: async with session.get(url +search) as response: if response.status >=400: raise ValueError(response.status, response.reason) return(await response.json(content_type=None))[0] def embed_thatapiguy(ctx, response: dict): return discord.Embed( color=utils.get_user_color(ctx.author) ).set_footer( text=f'Requested by{ctx.author.name}', icon_url=ctx.author.avatar_url ).set_image( url=response['url'] ) class Images(commands.Cog): qualified_name='Images' description='Commands for getting images.' def __init__(self, bot): self.bot=bot @commands.command(name='meow') @commands.cooldown(1, 20, commands.BucketType.channel) @commands.max_concurrency(3) async def client_getcatimage(self, ctx): \"\"\"\\N{CAT FACE}\"\"\" if CAT_API_KEY is None: return await ctx.send('Sorry, but the bot currently cannot ' 'query for a cat image.') await ctx.trigger_typing() try: cat=await query_thatapiguy(CAT_API_URL, CAT_API_KEY) except ValueError as e: return await ctx.send('Could not get a cat image; ' f'status code{e.args[1]}') await ctx.send(embed=embed_thatapiguy(ctx, cat)) @commands.command(name='woof') @commands.cooldown(1, 20, commands.BucketType.channel) @commands.max_concurrency(3) async def client_getdogimage(self, ctx): \"\"\"\\N{DOG FACE}\"\"\" if DOG_API_KEY is None: return await ctx.send('Sorry, but the bot currently cannot ' 'query for a dog image.') await ctx.trigger_typing() try: dog=await query_thatapiguy(DOG_API_URL, DOG_API_KEY) except ValueError as e: return await ctx.send('Failed to query a dog image; ' f'status code{e.args[1]}') await ctx.send(embed=embed_thatapiguy(ctx, dog)) def setup(bot): bot.add_cog(Images(bot)) ","sourceWithComments":"import json\nimport os\nimport random\n\nimport aiohttp\nimport discord\nfrom discord.ext import commands\n\nfrom bot import utils\n\nCAT_API_URL = 'https:\/\/api.thecatapi.com\/'\nCAT_API_KEY = os.getenv('PyDiscordBotAPICatKey')\nDOG_API_URL = 'https:\/\/api.thedogapi.com\/'\nDOG_API_KEY = os.getenv('PyDiscordBotAPIDogKey')\n\n\nasync def query_thatapiguy(url, key):\n    search = 'v1\/images\/search?mime_types=jpg,png'\n\n    async with aiohttp.ClientSession(\n            headers={'x-api-key': key}) as session:\n        async with session.get(url + search) as response:\n            if response.status >= 400:\n                raise ValueError(response.status, response.reason)\n\n            # Acquire the json, disabling content-type check\n            return (await response.json(content_type=None))[0]\n\n\ndef embed_thatapiguy(ctx, response: dict):\n    return discord.Embed(\n        color=utils.get_user_color(ctx.author)\n    ).set_footer(\n        text=f'Requested by {ctx.author.name}',\n        icon_url=ctx.author.avatar_url\n    ).set_image(\n        url=response['url']\n    )\n\n\nclass Images(commands.Cog):\n    qualified_name = 'Images'\n    description = 'Commands for getting images.'\n\n    def __init__(self, bot):\n        self.bot = bot\n\n\n\n\n\n    @commands.command(name='meow')\n    @commands.cooldown(1, 20, commands.BucketType.channel)\n    @commands.max_concurrency(3)\n    async def client_getcatimage(self, ctx):\n        \"\"\"\\N{CAT FACE}\"\"\"\n        if CAT_API_KEY is None:\n            return await ctx.send('Sorry, but the bot currently cannot '\n                                  'query for a cat image.')\n\n        await ctx.trigger_typing()\n\n        try:\n            cat = await query_thatapiguy(CAT_API_URL, CAT_API_KEY)\n        except ValueError as e:\n            return await ctx.send('Could not get a cat image; '\n                                  f'status code {e.args[1]}')\n\n        await ctx.send(embed=embed_thatapiguy(ctx, cat))\n\n\n\n\n\n    @commands.command(name='woof')\n    @commands.cooldown(1, 20, commands.BucketType.channel)\n    @commands.max_concurrency(3)\n    async def client_getdogimage(self, ctx):\n        \"\"\"\\N{DOG FACE}\"\"\"\n        if DOG_API_KEY is None:\n            return await ctx.send('Sorry, but the bot currently cannot '\n                                  'query for a dog image.')\n\n        await ctx.trigger_typing()\n\n        try:\n            dog = await query_thatapiguy(DOG_API_URL, DOG_API_KEY)\n        except ValueError as e:\n            return await ctx.send('Failed to query a dog image; '\n                                  f'status code {e.args[1]}')\n\n        await ctx.send(embed=embed_thatapiguy(ctx, dog))\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Images(bot))\n"},"\/bot\/commands\/info.py":{"changes":[{"diff":"\n import sys\n import random\n import time\n-import typing\n+from typing import Optional\n \n-from dateutil.relativedelta import relativedelta\n import discord\n from discord.ext import commands\n+from discord_slash.utils import manage_commands\n+from discord_slash import cog_ext as dslash_cog\n+from discord_slash import SlashContext\n+import discord_slash as dslash\n import humanize\n import psutil\n import pytz\n \n-from bot import settings\n-from bot import utils\n-\n-\n-class CommandConverter(commands.Converter):\n-    async def can_run(self, ctx, command):\n-        \"\"\"A variant of command.can_run() that doesn't check if\n-        the command is disabled.\"\"\"\n-        original = ctx.command\n-        ctx.command = command\n-\n-        try:\n-            if not await ctx.bot.can_run(ctx):\n-                return False\n-\n-            cog = command.cog\n-            if cog is not None:\n-                local_check = commands.Cog._get_overridden_method(cog.cog_check)\n-                if local_check is not None:\n-                    ret = await discord.utils.maybe_coroutine(local_check, ctx)\n-                    if not ret:\n-                        return False\n-\n-            predicates = command.checks\n-            if not predicates:\n-                # since we have no checks, then we just return True.\n-                return True\n-\n-            return await discord.utils.async_all(\n-                predicate(ctx) for predicate in predicates)\n-        finally:\n-            ctx.command = original\n-\n-    async def convert(self, ctx, argument):\n-        c = ctx.bot.get_command(argument)\n-        try:\n-            if c is None:\n-                raise commands.BadArgument(\n-                    f'Could not convert \"{argument}\" into a command.')\n-            elif not await self.can_run(ctx, c):\n-                raise commands.BadArgument(f'The user cannot use \"{argument}\".')\n-        except commands.CheckFailure as e:\n-            raise commands.BadArgument(str(e)) from e\n-        return c\n-\n-\n-def iterable_has(iterable, *args):\n-    \"Used for parsing *args in commands.\"\n-    return any(s in iterable for s in args)\n+from bot import converters, settings, utils\n \n \n class Informative(commands.Cog):\n+    \"\"\"Informative commands.\"\"\"\n     qualified_name = 'Informative'\n-    description = 'Informative commands.'\n \n     ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS = False\n     # If True, members of any guild the bot is in can be looked up in DMs.\n","add":7,"remove":52,"filename":"\/bot\/commands\/info.py","badparts":["import typing","from dateutil.relativedelta import relativedelta","from bot import settings","from bot import utils","class CommandConverter(commands.Converter):","    async def can_run(self, ctx, command):","        \"\"\"A variant of command.can_run() that doesn't check if","        the command is disabled.\"\"\"","        original = ctx.command","        ctx.command = command","        try:","            if not await ctx.bot.can_run(ctx):","                return False","            cog = command.cog","            if cog is not None:","                local_check = commands.Cog._get_overridden_method(cog.cog_check)","                if local_check is not None:","                    ret = await discord.utils.maybe_coroutine(local_check, ctx)","                    if not ret:","                        return False","            predicates = command.checks","            if not predicates:","                return True","            return await discord.utils.async_all(","                predicate(ctx) for predicate in predicates)","        finally:","            ctx.command = original","    async def convert(self, ctx, argument):","        c = ctx.bot.get_command(argument)","        try:","            if c is None:","                raise commands.BadArgument(","                    f'Could not convert \"{argument}\" into a command.')","            elif not await self.can_run(ctx, c):","                raise commands.BadArgument(f'The user cannot use \"{argument}\".')","        except commands.CheckFailure as e:","            raise commands.BadArgument(str(e)) from e","        return c","def iterable_has(iterable, *args):","    \"Used for parsing *args in commands.\"","    return any(s in iterable for s in args)","    description = 'Informative commands.'"],"goodparts":["from typing import Optional","from discord_slash.utils import manage_commands","from discord_slash import cog_ext as dslash_cog","from discord_slash import SlashContext","import discord_slash as dslash","from bot import converters, settings, utils","    \"\"\"Informative commands.\"\"\""]},{"diff":"\n \n     DATETIME_DIFFERENCE_PRECISION = {'minutes': False, 'seconds': False}\n \n-    UPTIME_ALLOWED_DOWNTIME = 10\n-\n     COMMANDINFO_BUCKETTYPE_DESCRIPTIONS = {\n         commands.BucketType.default:  'globally',\n         commands.BucketType.user:     'per user',\n","add":0,"remove":2,"filename":"\/bot\/commands\/info.py","badparts":["    UPTIME_ALLOWED_DOWNTIME = 10"],"goodparts":[]},{"diff":"\n \n \n \n-    def update_last_connect(self, *, force_update=False):\n-        if not self.bot.uptime_is_online:\n-            # Calculate downtime\n-            now = datetime.datetime.now().astimezone()\n-            diff = now - self.bot.uptime_last_disconnect\n-\n-            # Only update last connect if downtime was long,\n-            # else record the downtime\n-            if force_update or (diff.total_seconds()\n-                                > self.UPTIME_ALLOWED_DOWNTIME):\n-                self.bot.uptime_last_connect = now\n-                self.bot.uptime_last_connect_adjusted = now\n-                self.bot.uptime_total_downtime = datetime.timedelta()\n-\n-                if force_update:\n-                    print('Uptime: forced uptime reset')\n-                else:\n-                    print(\n-                        'Uptime: Downtime of {} seconds exceeded allowed '\n-                        'downtime ({} seconds); resetting uptime'.format(\n-                            diff.total_seconds(),\n-                            self.UPTIME_ALLOWED_DOWNTIME\n-                        )\n-                    )\n-            else:\n-                self.bot.uptime_total_downtime += diff\n-                self.bot.uptime_last_connect_adjusted = (\n-                    self.bot.uptime_last_connect\n-                    + self.bot.uptime_total_downtime\n-                )\n-                print('Uptime:', 'Recorded downtime of',\n-                      diff.total_seconds(), 'seconds')\n-\n-            self.bot.uptime_is_online = True\n-\n-\n-    @commands.Cog.listener()\n-    async def on_command_completion(self, ctx):\n-        \"\"\"Used for tracking processed commands.\"\"\"\n-        self.bot.info_processed_commands[ctx.command.qualified_name] += 1\n-\n-    @commands.Cog.listener()\n-    async def on_connect(self):\n-        \"\"\"Used for uptime tracking.\n-\n-        Triggered when waking up from computer sleep.\n-        As there is no way to tell how long the computer went for sleep,\n-        this forces the last_connect time to be updated.\n-\n-        \"\"\"\n-        self.update_last_connect(force_update=True)\n-\n-\n-    @commands.Cog.listener()\n-    async def on_disconnect(self):\n-        \"\"\"Used for uptime tracking.\"\"\"\n-        self.bot.uptime_last_disconnect = datetime.datetime.now().astimezone()\n-        self.bot.uptime_is_online = False\n-\n-\n-    @commands.Cog.listener()\n-    async def on_resumed(self):\n-        \"\"\"Used for uptime tracking.\n-\n-        Triggered when reconnecting from an internet loss.\n-\n-        \"\"\"\n-        self.update_last_connect()\n-\n-\n-\n-\n-\n     @commands.command(\n         name='about', aliases=['info'])\n     @commands.cooldown(3, 60, commands.BucketType.guild)\n","add":0,"remove":73,"filename":"\/bot\/commands\/info.py","badparts":["    def update_last_connect(self, *, force_update=False):","        if not self.bot.uptime_is_online:","            now = datetime.datetime.now().astimezone()","            diff = now - self.bot.uptime_last_disconnect","            if force_update or (diff.total_seconds()","                                > self.UPTIME_ALLOWED_DOWNTIME):","                self.bot.uptime_last_connect = now","                self.bot.uptime_last_connect_adjusted = now","                self.bot.uptime_total_downtime = datetime.timedelta()","                if force_update:","                    print('Uptime: forced uptime reset')","                else:","                    print(","                        'Uptime: Downtime of {} seconds exceeded allowed '","                        'downtime ({} seconds); resetting uptime'.format(","                            diff.total_seconds(),","                            self.UPTIME_ALLOWED_DOWNTIME","                        )","                    )","            else:","                self.bot.uptime_total_downtime += diff","                self.bot.uptime_last_connect_adjusted = (","                    self.bot.uptime_last_connect","                    + self.bot.uptime_total_downtime","                )","                print('Uptime:', 'Recorded downtime of',","                      diff.total_seconds(), 'seconds')","            self.bot.uptime_is_online = True","    @commands.Cog.listener()","    async def on_command_completion(self, ctx):","        \"\"\"Used for tracking processed commands.\"\"\"","        self.bot.info_processed_commands[ctx.command.qualified_name] += 1","    @commands.Cog.listener()","    async def on_connect(self):","        \"\"\"Used for uptime tracking.","        Triggered when waking up from computer sleep.","        As there is no way to tell how long the computer went for sleep,","        this forces the last_connect time to be updated.","        \"\"\"","        self.update_last_connect(force_update=True)","    @commands.Cog.listener()","    async def on_disconnect(self):","        \"\"\"Used for uptime tracking.\"\"\"","        self.bot.uptime_last_disconnect = datetime.datetime.now().astimezone()","        self.bot.uptime_is_online = False","    @commands.Cog.listener()","    async def on_resumed(self):","        \"\"\"Used for uptime tracking.","        Triggered when reconnecting from an internet loss.","        \"\"\"","        self.update_last_connect()"],"goodparts":[]},{"diff":"\n \n         await ctx.trigger_typing()\n \n-        field_statistics = (\n-            f\"Bot started at: {start_time.strftime('%Y\/%m\/%d %a %X UTC')}\\n\"\n-        )\n+        field_statistics = [\n+            f\"Bot started at: {start_time.strftime('%Y\/%m\/%d %a %X UTC')}\"\n+        ]\n \n         if self.bot.intents.members:\n             member_count = sum(not u.bot for u in self.bot.users)\n+            s_member_count = f'{member_count:,}'\n         else:\n-            member_count = 'Unavailable'\n+            member_count = sum(g.member_count for g in self.bot.guilds)\n+            s_member_count = f'~{member_count:,}'\n \n         commands_processed = sum(\n             self.bot.info_processed_commands.values()) + 1\n \n-        field_statistics += (\n-            f'# Members: {member_count:,}\\n'\n-            f'# Servers: {len(self.bot.guilds):,}\\n'\n-            f'# Commands: {len(self.bot.commands):,}\\n'\n-            f'# Commands processed: {commands_processed:,}\\n'\n-            f'Python version: {version_python}\\n'\n-            f'D.py version: {discord.__version__}\\n'\n-        )\n+        field_statistics.extend((\n+            f'# Members: {s_member_count}',\n+            f'# Servers: {len(self.bot.guilds):,}',\n+            f'# Commands: {len(self.bot.commands):,}',\n+            f'# Commands processed: {commands_processed:,}',\n+            f'Python version: {version_python}',\n+            f'D.py version: {discord.__version__}'\n+        ))\n \n-        if iterable_has(args, '-S', '--system'):\n+        if utils.iterable_has(args, '-S', '--system'):\n             # Add system information\n             p = self.process\n             with p.oneshot():\n","add":15,"remove":13,"filename":"\/bot\/commands\/info.py","badparts":["        field_statistics = (","            f\"Bot started at: {start_time.strftime('%Y\/%m\/%d %a %X UTC')}\\n\"","        )","            member_count = 'Unavailable'","        field_statistics += (","            f'Python version: {version_python}\\n'","            f'D.py version: {discord.__version__}\\n'","        )","        if iterable_has(args, '-S', '--system'):"],"goodparts":["        field_statistics = [","            f\"Bot started at: {start_time.strftime('%Y\/%m\/%d %a %X UTC')}\"","        ]","            s_member_count = f'{member_count:,}'","            member_count = sum(g.member_count for g in self.bot.guilds)","            s_member_count = f'~{member_count:,}'","        field_statistics.extend((","            f'Python version: {version_python}',","            f'D.py version: {discord.__version__}'","        ))","        if utils.iterable_has(args, '-S', '--system'):"]},{"diff":"\n \n \n \n-    @commands.command(name='commandinfo')\n+    @commands.command(name='commandinfo', aliases=('cinfo',))\n     @commands.cooldown(3, 15, commands.BucketType.user)\n     async def client_commandinfo(self, ctx, *, command):\n         \"\"\"Get statistics about a command.\"\"\"\n-        def get_group_uses(stats, command):\n-            \"Recursively count the uses of a command group.\"\n+        def get_group_uses(stats, cmd):\n+            \"\"\"Recursively count the uses of a command group.\"\"\"\n             uses = 0\n-            for sub in command.commands:\n+            for sub in cmd.commands:\n                 if isinstance(sub, commands.Group):\n                     uses += get_group_uses(stats, sub)\n                 uses += stats[sub.qualified_name]\n","add":4,"remove":4,"filename":"\/bot\/commands\/info.py","badparts":["    @commands.command(name='commandinfo')","        def get_group_uses(stats, command):","            \"Recursively count the uses of a command group.\"","            for sub in command.commands:"],"goodparts":["    @commands.command(name='commandinfo', aliases=('cinfo',))","        def get_group_uses(stats, cmd):","            \"\"\"Recursively count the uses of a command group.\"\"\"","            for sub in cmd.commands:"]},{"diff":"\n \n         # Search for the command\n         try:\n-            command = await CommandConverter().convert(ctx, command)\n+            command = await converters.CommandConverter().convert(ctx, command)\n         except commands.BadArgument:\n-            return await ctx.send(\"That command doesn't exist.\")\n+            return await ctx.send(\"That command doesn't exist.\",\n+                                  delete_after=6)\n \n         # Create a response\n         embed = discord.Embed(\n","add":3,"remove":2,"filename":"\/bot\/commands\/info.py","badparts":["            command = await CommandConverter().convert(ctx, command)","            return await ctx.send(\"That command doesn't exist.\")"],"goodparts":["            command = await converters.CommandConverter().convert(ctx, command)","            return await ctx.send(\"That command doesn't exist.\",","                                  delete_after=6)"]},{"diff":"\n                    else '\\N{NO ENTRY}')\n \n         # Write description\n-        description = ''\n+        description = []\n \n         # Insert cog\n         if command.cog is not None:\n-            description += (\n-                f'Categorized under: __{command.cog.qualified_name}__\\n')\n+            description.append(\n+                f'Categorized under: __{command.cog.qualified_name}__')\n \n         # Insert aliases\n         if len(command.aliases) == 1:\n-            description += f\"Alias: {command.aliases[0]}\\n\"\n+            description.append(f\"Alias: {command.aliases[0]}\")\n         elif len(command.aliases) > 1:\n-            description += f\"Aliases: {', '.join(command.aliases)}\\n\"\n+            description.append(f\"Aliases: {', '.join(command.aliases)}\")\n \n         # Insert parent\n         if command.parent is not None:\n-            description += f'Parent command: {command.parent.name}\\n'\n+            description.append(f'Parent command: {command.parent.name}')\n \n         # Insert enabled status\n-        description += f\"Is enabled: {enabled}\\n\"\n+        description.append(f\"Is enabled: {enabled}\")\n \n         # Insert hidden status\n         if command.hidden:\n-            description += 'Is hidden: \\N{WHITE HEAVY CHECK MARK}\\n'\n+            description.append('Is hidden: \\N{WHITE HEAVY CHECK MARK}')\n \n         # Insert cooldown\n-        cooldown = command._buckets._cooldown\n+        cooldown: commands.Cooldown = command._buckets._cooldown\n         if cooldown is not None:\n             cooldown_type = self.COMMANDINFO_BUCKETTYPE_DESCRIPTIONS.get(\n                 cooldown.type, '')\n-            description += (\n+            description.append(\n                 'Cooldown settings: '\n-                f'{cooldown.rate}\/{cooldown.per:.2g}s {cooldown_type}\\n'\n+                f'{cooldown.rate}\/{cooldown.per:.2g}s {cooldown_type}'\n+            )\n+\n+        # Insert concurrency limit\n+        concurrency: commands.MaxConcurrency = command._max_concurrency\n+        if concurrency is not None:\n+            concurrency_type = self.COMMANDINFO_BUCKETTYPE_DESCRIPTIONS.get(\n+                concurrency.per, '')\n+            concurrency_wait = '(has queue)' if concurrency.wait else ''\n+            description.append(\n+                'Concurrency settings: '\n+                f'{concurrency.number} {concurrency_type} {concurrency_wait}'\n             )\n-        else:\n-            description += 'Cooldown settings: unlimited\\n'\n \n         # Insert uses\n         uses = stats[command.qualified_name]\n","add":22,"remove":13,"filename":"\/bot\/commands\/info.py","badparts":["        description = ''","            description += (","                f'Categorized under: __{command.cog.qualified_name}__\\n')","            description += f\"Alias: {command.aliases[0]}\\n\"","            description += f\"Aliases: {', '.join(command.aliases)}\\n\"","            description += f'Parent command: {command.parent.name}\\n'","        description += f\"Is enabled: {enabled}\\n\"","            description += 'Is hidden: \\N{WHITE HEAVY CHECK MARK}\\n'","        cooldown = command._buckets._cooldown","            description += (","                f'{cooldown.rate}\/{cooldown.per:.2g}s {cooldown_type}\\n'","        else:","            description += 'Cooldown settings: unlimited\\n'"],"goodparts":["        description = []","            description.append(","                f'Categorized under: __{command.cog.qualified_name}__')","            description.append(f\"Alias: {command.aliases[0]}\")","            description.append(f\"Aliases: {', '.join(command.aliases)}\")","            description.append(f'Parent command: {command.parent.name}')","        description.append(f\"Is enabled: {enabled}\")","            description.append('Is hidden: \\N{WHITE HEAVY CHECK MARK}')","        cooldown: commands.Cooldown = command._buckets._cooldown","            description.append(","                f'{cooldown.rate}\/{cooldown.per:.2g}s {cooldown_type}'","            )","        concurrency: commands.MaxConcurrency = command._max_concurrency","        if concurrency is not None:","            concurrency_type = self.COMMANDINFO_BUCKETTYPE_DESCRIPTIONS.get(","                concurrency.per, '')","            concurrency_wait = '(has queue)' if concurrency.wait else ''","            description.append(","                'Concurrency settings: '","                f'{concurrency.number} {concurrency_type} {concurrency_wait}'"]},{"diff":"\n             uses += 1\n \n         if is_group:\n-            description += (\n-                f'# subcommands: {len(command.commands):,}\\n'\n-                f'# uses (including subcommands): {uses:,}\\n'\n-            )\n+            description.extend((\n+                f'# subcommands: {len(command.commands):,}',\n+                f'# uses (including subcommands): {uses:,}'\n+            ))\n         else:\n-            description += f'# uses: {uses:,}\\n'\n+            description.append(f'# uses: {uses:,}')\n \n         # Finalize embed\n-        embed.description = description\n+        embed.description = '\\n'.join(description)\n \n         await ctx.send(embed=embed)\n \n","add":6,"remove":6,"filename":"\/bot\/commands\/info.py","badparts":["            description += (","            )","            description += f'# uses: {uses:,}\\n'","        embed.description = description"],"goodparts":["            description.extend((","            ))","            description.append(f'# uses: {uses:,}')","        embed.description = '\\n'.join(description)"]},{"diff":"\n \n \n \n-    @commands.command(name='invite')\n-    @commands.cooldown(1, 60, commands.BucketType.channel)\n-    async def client_invite(self, ctx):\n-        \"Get the bot's invite link.\"\n-        perms = discord.Permissions(\n-            add_reactions=True,\n-            read_messages=True,\n-            send_messages=True,\n-            embed_links=True,\n-            attach_files=True,\n-            read_message_history=True,\n-            external_emojis=True,\n-            change_nickname=True,\n-            connect=True,\n-            speak=True\n-        )\n+    def get_invite_link(self, perms: Optional[discord.Permissions] = None,\n+                        slash_commands=True):\n+        if perms is None:\n+            perms = discord.Permissions(\n+                add_reactions=True,\n+                read_messages=True,\n+                send_messages=True,\n+                embed_links=True,\n+                attach_files=True,\n+                read_message_history=True,\n+                external_emojis=True,\n+                change_nickname=True,\n+                connect=True,\n+                speak=True\n+            )\n \n         link = discord.utils.oauth_url(self.bot.user.id, perms)\n \n+        if slash_commands:\n+            link = link.replace('scope=bot', 'scope=bot%20applications.commands')\n+\n+        return link\n+\n+\n+    @commands.command(name='invite')\n+    @commands.cooldown(1, 60, commands.BucketType.channel)\n+    async def client_invite(self, ctx):\n+        \"\"\"Get the bot's invite link.\"\"\"\n+        link = self.get_invite_link()\n         embed = discord.Embed(\n-            color=utils.get_bot_color(),\n-            description=f'[OAuth2 Invite Link]({link})'\n+            color=utils.get_bot_color()\n+        ).set_author(\n+            name=f'\u2014> Invitation link <\u2014',\n+            url=link\n         ).set_footer(\n             text=f'Requested by {ctx.author.name}',\n             icon_url=ctx.author.avatar_url\n","add":30,"remove":18,"filename":"\/bot\/commands\/info.py","badparts":["    @commands.command(name='invite')","    @commands.cooldown(1, 60, commands.BucketType.channel)","    async def client_invite(self, ctx):","        \"Get the bot's invite link.\"","        perms = discord.Permissions(","            add_reactions=True,","            read_messages=True,","            send_messages=True,","            embed_links=True,","            attach_files=True,","            read_message_history=True,","            external_emojis=True,","            change_nickname=True,","            connect=True,","            speak=True","        )","            color=utils.get_bot_color(),","            description=f'[OAuth2 Invite Link]({link})'"],"goodparts":["    def get_invite_link(self, perms: Optional[discord.Permissions] = None,","                        slash_commands=True):","        if perms is None:","            perms = discord.Permissions(","                add_reactions=True,","                read_messages=True,","                send_messages=True,","                embed_links=True,","                attach_files=True,","                read_message_history=True,","                external_emojis=True,","                change_nickname=True,","                connect=True,","                speak=True","            )","        if slash_commands:","            link = link.replace('scope=bot', 'scope=bot%20applications.commands')","        return link","    @commands.command(name='invite')","    @commands.cooldown(1, 60, commands.BucketType.channel)","    async def client_invite(self, ctx):","        \"\"\"Get the bot's invite link.\"\"\"","        link = self.get_invite_link()","            color=utils.get_bot_color()","        ).set_author(","            name=f'\u2014> Invitation link <\u2014',","            url=link"]},{"diff":"\n         )\n         embed.add_field(\n             name=f\"{len(roles):,} Role{'s' if len(roles) != 1 else ''}\",\n-            value=', '.join([str(r) for r in roles]),\n+            value=', '.join([r.mention for r in roles]),\n             inline=False\n         )\n         embed.set_footer(\n","add":1,"remove":1,"filename":"\/bot\/commands\/info.py","badparts":["            value=', '.join([str(r) for r in roles]),"],"goodparts":["            value=', '.join([r.mention for r in roles]),"]},{"diff":"\n         try:\n             tz = pytz.timezone(timezone)\n         except pytz.UnknownTimeZoneError:\n-            return await ctx.send('Unknown timezone.')\n+            return await ctx.send('Unknown timezone.', delete_after=6)\n \n         UTC = pytz.utc\n         utcnow = UTC.localize(datetime.datetime.utcnow())\n","add":1,"remove":1,"filename":"\/bot\/commands\/info.py","badparts":["            return await ctx.send('Unknown timezone.')"],"goodparts":["            return await ctx.send('Unknown timezone.', delete_after=6)"]},{"diff":"\n         name='userinfo')\n     @commands.cooldown(3, 20, commands.BucketType.user)\n     async def client_userinfo(self, ctx,\n-                              streamer_friendly: typing.Optional[bool] = True,\n+                              streamer_friendly: Optional[bool] = True,\n                               *, user=None):\n         \"\"\"Get information about a user by name or mention.\n \n","add":1,"remove":1,"filename":"\/bot\/commands\/info.py","badparts":["                              streamer_friendly: typing.Optional[bool] = True,"],"goodparts":["                              streamer_friendly: Optional[bool] = True,"]},{"diff":"\n         if user is None:\n             user = ctx.author\n         else:\n-            user_input = user\n-\n             try:\n                 user = await commands.MemberConverter().convert(ctx, user)\n             except commands.MemberNotFound as e:\n                 if (not self.ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS\n                         and ctx.guild is None):\n-                    return await ctx.send('Cannot search for members in DMs.')\n+                    return await ctx.send(\n+                        'Cannot search for members in DMs.', delete_after=8)\n                 # Else allow error handler to deal with it\n                 raise e\n             else:\n","add":2,"remove":3,"filename":"\/bot\/commands\/info.py","badparts":["            user_input = user","                    return await ctx.send('Cannot search for members in DMs.')"],"goodparts":["                    return await ctx.send(","                        'Cannot search for members in DMs.', delete_after=8)"]},{"diff":"\n                         elif not self.ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS:\n                             # Disallowed showing guild members in DMs\n                             return await ctx.send(\n-                                'Cannot search for members in DMs.')\n+                                'Cannot search for members in DMs.',\n+                                delete_after=8\n+                            )\n \n         # Extract attributes based on whether its a Member or User\n         if isinstance(user, discord.Member):\n","add":3,"remove":1,"filename":"\/bot\/commands\/info.py","badparts":["                                'Cannot search for members in DMs.')"],"goodparts":["                                'Cannot search for members in DMs.',","                                delete_after=8","                            )"]},{"diff":"\n                 user.joined_at.strftime('%Y\/%m\/%d %a %X UTC')\n             )\n             nickname = user.nick\n-            roles = [role.name for role in user.roles]\n+            roles = user.roles\n             if len(roles) > 1:\n                 # Has a role(s); remove @everyone\n                 roles = roles[:0:-1]\n","add":1,"remove":1,"filename":"\/bot\/commands\/info.py","badparts":["            roles = [role.name for role in user.roles]"],"goodparts":["            roles = user.roles"]},{"diff":"\n         if roles is not None:\n             embed.add_field(\n                 name=f\"{len(roles):,} Role{'s' if len(roles) != 1 else ''}\",\n-                value=', '.join(roles),\n+                value=', '.join([r.mention for r in roles]),\n                 inline=False\n             )\n         emb","add":1,"remove":1,"filename":"\/bot\/commands\/info.py","badparts":["                value=', '.join(roles),"],"goodparts":["                value=', '.join([r.mention for r in roles]),"]}],"source":"\nimport datetime import sys import random import time import typing from dateutil.relativedelta import relativedelta import discord from discord.ext import commands import humanize import psutil import pytz from bot import settings from bot import utils class CommandConverter(commands.Converter): async def can_run(self, ctx, command): \"\"\"A variant of command.can_run() that doesn't check if the command is disabled.\"\"\" original=ctx.command ctx.command=command try: if not await ctx.bot.can_run(ctx): return False cog=command.cog if cog is not None: local_check=commands.Cog._get_overridden_method(cog.cog_check) if local_check is not None: ret=await discord.utils.maybe_coroutine(local_check, ctx) if not ret: return False predicates=command.checks if not predicates: return True return await discord.utils.async_all( predicate(ctx) for predicate in predicates) finally: ctx.command=original async def convert(self, ctx, argument): c=ctx.bot.get_command(argument) try: if c is None: raise commands.BadArgument( f'Could not convert \"{argument}\" into a command.') elif not await self.can_run(ctx, c): raise commands.BadArgument(f'The user cannot use \"{argument}\".') except commands.CheckFailure as e: raise commands.BadArgument(str(e)) from e return c def iterable_has(iterable, *args): \"Used for parsing *args in commands.\" return any(s in iterable for s in args) class Informative(commands.Cog): qualified_name='Informative' description='Informative commands.' ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS=False DATETIME_DIFFERENCE_PRECISION={'minutes': False, 'seconds': False} UPTIME_ALLOWED_DOWNTIME=10 COMMANDINFO_BUCKETTYPE_DESCRIPTIONS={ commands.BucketType.default: 'globally', commands.BucketType.user: 'per user', commands.BucketType.guild: 'per guild', commands.BucketType.channel: 'per text channel', commands.BucketType.member: 'per user', commands.BucketType.category: 'per channel category', commands.BucketType.role: 'per role' } def __init__(self, bot): self.bot=bot self.process=psutil.Process() def update_last_connect(self, *, force_update=False): if not self.bot.uptime_is_online: now=datetime.datetime.now().astimezone() diff=now -self.bot.uptime_last_disconnect if force_update or(diff.total_seconds() > self.UPTIME_ALLOWED_DOWNTIME): self.bot.uptime_last_connect=now self.bot.uptime_last_connect_adjusted=now self.bot.uptime_total_downtime=datetime.timedelta() if force_update: print('Uptime: forced uptime reset') else: print( 'Uptime: Downtime of{} seconds exceeded allowed ' 'downtime({} seconds); resetting uptime'.format( diff.total_seconds(), self.UPTIME_ALLOWED_DOWNTIME ) ) else: self.bot.uptime_total_downtime +=diff self.bot.uptime_last_connect_adjusted=( self.bot.uptime_last_connect +self.bot.uptime_total_downtime ) print('Uptime:', 'Recorded downtime of', diff.total_seconds(), 'seconds') self.bot.uptime_is_online=True @commands.Cog.listener() async def on_command_completion(self, ctx): \"\"\"Used for tracking processed commands.\"\"\" self.bot.info_processed_commands[ctx.command.qualified_name] +=1 @commands.Cog.listener() async def on_connect(self): \"\"\"Used for uptime tracking. Triggered when waking up from computer sleep. As there is no way to tell how long the computer went for sleep, this forces the last_connect time to be updated. \"\"\" self.update_last_connect(force_update=True) @commands.Cog.listener() async def on_disconnect(self): \"\"\"Used for uptime tracking.\"\"\" self.bot.uptime_last_disconnect=datetime.datetime.now().astimezone() self.bot.uptime_is_online=False @commands.Cog.listener() async def on_resumed(self): \"\"\"Used for uptime tracking. Triggered when reconnecting from an internet loss. \"\"\" self.update_last_connect() @commands.command( name='about', aliases=['info']) @commands.cooldown(3, 60, commands.BucketType.guild) @commands.max_concurrency(3, wait=True) async def client_aboutbot(self, ctx, *args): \"\"\"An about page for this bot. Optional settings: -S --system: show system-related information about the bot.\"\"\" embed=discord.Embed( title='About', description=('I do random stuff, whatever <@153551102443257856> ' 'adds to me'), color=utils.get_bot_color() ).set_thumbnail( url=self.bot.user.avatar_url ).set_footer( text=f'Requested by{ctx.author.name}', icon_url=ctx.author.avatar_url ) vp=sys.version_info version_python=f'{vp.major}.{vp.minor}.{vp.micro}' start_time=datetime.datetime.fromtimestamp( self.process.create_time()).astimezone().astimezone(pytz.utc) await ctx.trigger_typing() field_statistics=( f\"Bot started at:{start_time.strftime('%Y\/%m\/%d %a %X UTC')}\\n\" ) if self.bot.intents.members: member_count=sum(not u.bot for u in self.bot.users) else: member_count='Unavailable' commands_processed=sum( self.bot.info_processed_commands.values()) +1 field_statistics +=( f' f' f' f' f'Python version:{version_python}\\n' f'D.py version:{discord.__version__}\\n' ) if iterable_has(args, '-S', '--system'): p=self.process with p.oneshot(): mem_usage=p.memory_full_info().uss num_threads=p.num_threads() num_handles=p.num_handles() cpu=p.cpu_percent(interval=0.1) if cpu <=5: cpu=min( random.uniform(20, 60), max(1, cpu \/ 2) * random.uniform(5, 30) ) field_statistics +=( f'> Bootup time:{self.bot.info_bootup_time:.3g} seconds\\n' f'> CPU usage:{cpu:.3g}%\\n' f'> Memory usage:{humanize.naturalsize(mem_usage)}\\n' f'> Threads:{num_threads}\\n' f'> Handles:{num_handles}\\n' ) embed.add_field( name='Statistics', value=field_statistics ) await ctx.send(embed=embed) @commands.command(name='commandinfo') @commands.cooldown(3, 15, commands.BucketType.user) async def client_commandinfo(self, ctx, *, command): \"\"\"Get statistics about a command.\"\"\" def get_group_uses(stats, command): \"Recursively count the uses of a command group.\" uses=0 for sub in command.commands: if isinstance(sub, commands.Group): uses +=get_group_uses(stats, sub) uses +=stats[sub.qualified_name] return uses try: command=await CommandConverter().convert(ctx, command) except commands.BadArgument: return await ctx.send(\"That command doesn't exist.\") embed=discord.Embed( title=command.qualified_name, color=utils.get_bot_color() ).set_footer( text=f'Requested by{ctx.author.name}', icon_url=ctx.author.avatar_url ) stats=self.bot.info_processed_commands is_group=isinstance(command, commands.Group) enabled=('\\N{WHITE HEAVY CHECK MARK}' if command.enabled else '\\N{NO ENTRY}') description='' if command.cog is not None: description +=( f'Categorized under: __{command.cog.qualified_name}__\\n') if len(command.aliases)==1: description +=f\"Alias:{command.aliases[0]}\\n\" elif len(command.aliases) > 1: description +=f\"Aliases:{', '.join(command.aliases)}\\n\" if command.parent is not None: description +=f'Parent command:{command.parent.name}\\n' description +=f\"Is enabled:{enabled}\\n\" if command.hidden: description +='Is hidden: \\N{WHITE HEAVY CHECK MARK}\\n' cooldown=command._buckets._cooldown if cooldown is not None: cooldown_type=self.COMMANDINFO_BUCKETTYPE_DESCRIPTIONS.get( cooldown.type, '') description +=( 'Cooldown settings: ' f'{cooldown.rate}\/{cooldown.per:.2g}s{cooldown_type}\\n' ) else: description +='Cooldown settings: unlimited\\n' uses=stats[command.qualified_name] if is_group: uses +=get_group_uses(stats, command) if command==ctx.command: uses +=1 if is_group: description +=( f' f' ) else: description +=f' embed.description=description await ctx.send(embed=embed) @commands.command(name='invite') @commands.cooldown(1, 60, commands.BucketType.channel) async def client_invite(self, ctx): \"Get the bot's invite link.\" perms=discord.Permissions( add_reactions=True, read_messages=True, send_messages=True, embed_links=True, attach_files=True, read_message_history=True, external_emojis=True, change_nickname=True, connect=True, speak=True ) link=discord.utils.oauth_url(self.bot.user.id, perms) embed=discord.Embed( color=utils.get_bot_color(), description=f'[OAuth2 Invite Link]({link})' ).set_footer( text=f'Requested by{ctx.author.name}', icon_url=ctx.author.avatar_url ) await ctx.send(embed=embed) @commands.command( name='ping') @commands.cooldown(2, 15, commands.BucketType.user) async def client_ping(self, ctx): \"\"\"Get the bot's latency.\"\"\" start=time.perf_counter() message=await ctx.send('pong!') latency=time.perf_counter() -start latency_ms=round(latency * 100000) \/ 1000 await message.edit(content=f'pong!{latency_ms:g}ms') @commands.command( name='serverinfo') @commands.guild_only() @commands.cooldown(1, 15, commands.BucketType.channel) async def client_serverinfo(self, ctx, streamer_friendly: bool=True): \"\"\"Get information about the server you are currently in. streamer_friendly: If yes, hides the server ID and the owner's discriminator. Format referenced from the Ayana bot.\"\"\" guild=ctx.author.guild created=( utils.timedelta_string( utils.datetime_difference( datetime.datetime.utcnow(), guild.created_at ), **self.DATETIME_DIFFERENCE_PRECISION ), guild.created_at.strftime('%Y\/%m\/%d %a %X UTC') ) count_text_ch=len(guild.text_channels) count_voice_ch=len(guild.voice_channels) owner=guild.owner.name if streamer_friendly else str(guild.owner) roles=guild.roles embed=discord.Embed( color=utils.get_user_color(ctx.author), timestamp=datetime.datetime.utcnow() ) embed.set_author(name=guild.name) embed.set_thumbnail(url=guild.icon_url) if not streamer_friendly: embed.add_field( name='ID', value=guild.id ) embed.add_field( name='Region', value=guild.region ) embed.add_field( name='Members', value=guild.member_count ) embed.add_field( name='Channels', value=f'{count_text_ch} text:{count_voice_ch} voice' ) embed.add_field( name='Owner', value=owner ) embed.add_field( name='Time of Server Creation', value=f'{created[0]} ago({created[1]})', inline=False ) embed.add_field( name=f\"{len(roles):,} Role{'s' if len(roles) !=1 else ''}\", value=', '.join([str(r) for r in roles]), inline=False ) embed.set_footer( text=f'Requested by{ctx.author.name}', icon_url=ctx.author.avatar_url ) await ctx.send(embed=embed) @commands.command(name='utctime', aliases=['utc']) @commands.cooldown(3, 15, commands.BucketType.member) async def client_timeutc(self, ctx): \"\"\"Get the current date and time in UTC.\"\"\" await ctx.send(time.asctime(time.gmtime()) +'(UTC)') @commands.command(name='timezone', aliases=['tz']) @commands.cooldown(2, 5, commands.BucketType.member) async def client_timezone(self, ctx, *, timezone): \"\"\"Get the current date and time in a given timezone. This command uses the IANA timezone database.\"\"\" try: tz=pytz.timezone(timezone) except pytz.UnknownTimeZoneError: return await ctx.send('Unknown timezone.') UTC=pytz.utc utcnow=UTC.localize(datetime.datetime.utcnow()) tznow=utcnow.astimezone(tz) await ctx.send(tznow.strftime('%c %Z(%z)')) @commands.command( name='uptime') @commands.cooldown(2, 20, commands.BucketType.user) async def client_uptime(self, ctx): \"\"\"Get the uptime of the bot.\"\"\" diff=utils.datetime_difference( datetime.datetime.now().astimezone(), self.bot.uptime_last_connect_adjusted ) diff_string=utils.timedelta_string(diff) utc=self.bot.uptime_last_connect.astimezone(datetime.timezone.utc) date_string=utc.strftime('%Y\/%m\/%d %a %X UTC') await ctx.send(embed=discord.Embed( title='Uptime', description=f'{diff_string}\\n({date_string})', color=int(settings.get_setting('bot_color'), 16) )) @commands.command( name='userinfo') @commands.cooldown(3, 20, commands.BucketType.user) async def client_userinfo(self, ctx, streamer_friendly: typing.Optional[bool]=True, *, user=None): \"\"\"Get information about a user by name or mention. streamer_friendly: If yes, hides the user's discriminator. user: Can be referenced by name, nickname, name https:\/\/youtu.be\/CppEzOOXJ8E used as reference. Format referenced from the Ayana bot.\"\"\" if user is None: user=ctx.author else: user_input=user try: user=await commands.MemberConverter().convert(ctx, user) except commands.MemberNotFound as e: if(not self.ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS and ctx.guild is None): return await ctx.send('Cannot search for members in DMs.') raise e else: is_me=user.id==self.bot.user.id if isinstance(user, discord.Member): if ctx.guild is None: if is_me: user=self.bot.get_user(user.id) elif not self.ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS: return await ctx.send( 'Cannot search for members in DMs.') if isinstance(user, discord.Member): description=None activity=user.activity guild=user.guild joined=( utils.timedelta_string( utils.datetime_difference( datetime.datetime.utcnow(), user.created_at ), **self.DATETIME_DIFFERENCE_PRECISION ), user.joined_at.strftime('%Y\/%m\/%d %a %X UTC') ) nickname=user.nick roles=[role.name for role in user.roles] if len(roles) > 1: roles=roles[:0:-1] status=None if self.bot.intents.members and self.bot.intents.presences: status=user.status if isinstance(status, discord.Status): status=str(status).title() else: status=None if status=='Dnd': status='Do Not Disturb' else: description='*For more information, ' \\ 'use this command in a server.*' activity=None joined=None nickname=None roles=None status=None author=(f'{user}(Bot)' if user.bot else f'{user.name}' if streamer_friendly else str(user)) created=( utils.timedelta_string( utils.datetime_difference( datetime.datetime.utcnow(), user.created_at ), **self.DATETIME_DIFFERENCE_PRECISION ), user.created_at.strftime('%Y\/%m\/%d %a %X UTC') ) embed=discord.Embed( color=utils.get_user_color(user), description=description, timestamp=datetime.datetime.utcnow() ) embed.set_author(name=author) embed.set_thumbnail(url=user.avatar_url) if not streamer_friendly: embed.add_field( name='ID', value=user.id, inline=False ) embed.add_field( name='Mention', value=user.mention, inline=False ) if nickname is not None: embed.add_field( name='Nickname', value=nickname, inline=False ) if joined is not None: if guild !=ctx.guild: joined_name=f'Time of joining{guild.name}' else: joined_name='Time of Server Join' embed.add_field( name=joined_name, value=f'{joined[0]} ago({joined[1]})', inline=False ) embed.add_field( name='Time of User Creation', value=f'{created[0]} ago({created[1]})', inline=False ) if status is not None: embed.add_field( name='Status', value=status ) if activity is not None: if activity.type is discord.ActivityType.playing: embed.add_field( name='Playing', value=activity.name ) elif activity.type is discord.ActivityType.streaming: embed.add_field( name='Streaming', value=activity.name ) elif activity.type is discord.ActivityType.listening: embed.add_field( name='Listening to', value=activity.name ) elif activity.type is discord.ActivityType.watching: embed.add_field( name='Watching', value=activity.name ) if roles is not None: embed.add_field( name=f\"{len(roles):,} Role{'s' if len(roles) !=1 else ''}\", value=', '.join(roles), inline=False ) embed.set_footer( text=f'Requested by{ctx.author.name}', icon_url=ctx.author.avatar_url ) await ctx.send(embed=embed) def setup(bot): info=Informative(bot) bot.help_command.cog=info bot.add_cog(info) ","sourceWithComments":"import datetime\nimport sys\nimport random\nimport time\nimport typing\n\nfrom dateutil.relativedelta import relativedelta\nimport discord\nfrom discord.ext import commands\nimport humanize\nimport psutil\nimport pytz\n\nfrom bot import settings\nfrom bot import utils\n\n\nclass CommandConverter(commands.Converter):\n    async def can_run(self, ctx, command):\n        \"\"\"A variant of command.can_run() that doesn't check if\n        the command is disabled.\"\"\"\n        original = ctx.command\n        ctx.command = command\n\n        try:\n            if not await ctx.bot.can_run(ctx):\n                return False\n\n            cog = command.cog\n            if cog is not None:\n                local_check = commands.Cog._get_overridden_method(cog.cog_check)\n                if local_check is not None:\n                    ret = await discord.utils.maybe_coroutine(local_check, ctx)\n                    if not ret:\n                        return False\n\n            predicates = command.checks\n            if not predicates:\n                # since we have no checks, then we just return True.\n                return True\n\n            return await discord.utils.async_all(\n                predicate(ctx) for predicate in predicates)\n        finally:\n            ctx.command = original\n\n    async def convert(self, ctx, argument):\n        c = ctx.bot.get_command(argument)\n        try:\n            if c is None:\n                raise commands.BadArgument(\n                    f'Could not convert \"{argument}\" into a command.')\n            elif not await self.can_run(ctx, c):\n                raise commands.BadArgument(f'The user cannot use \"{argument}\".')\n        except commands.CheckFailure as e:\n            raise commands.BadArgument(str(e)) from e\n        return c\n\n\ndef iterable_has(iterable, *args):\n    \"Used for parsing *args in commands.\"\n    return any(s in iterable for s in args)\n\n\nclass Informative(commands.Cog):\n    qualified_name = 'Informative'\n    description = 'Informative commands.'\n\n    ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS = False\n    # If True, members of any guild the bot is in can be looked up in DMs.\n    # Note that this has no effect when the members intent is disabled.\n\n    DATETIME_DIFFERENCE_PRECISION = {'minutes': False, 'seconds': False}\n\n    UPTIME_ALLOWED_DOWNTIME = 10\n\n    COMMANDINFO_BUCKETTYPE_DESCRIPTIONS = {\n        commands.BucketType.default:  'globally',\n        commands.BucketType.user:     'per user',\n        commands.BucketType.guild:    'per guild',\n        commands.BucketType.channel:  'per text channel',\n        commands.BucketType.member:   'per user',\n        commands.BucketType.category: 'per channel category',\n        commands.BucketType.role:     'per role'\n    }\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.process = psutil.Process()\n\n\n\n\n\n    def update_last_connect(self, *, force_update=False):\n        if not self.bot.uptime_is_online:\n            # Calculate downtime\n            now = datetime.datetime.now().astimezone()\n            diff = now - self.bot.uptime_last_disconnect\n\n            # Only update last connect if downtime was long,\n            # else record the downtime\n            if force_update or (diff.total_seconds()\n                                > self.UPTIME_ALLOWED_DOWNTIME):\n                self.bot.uptime_last_connect = now\n                self.bot.uptime_last_connect_adjusted = now\n                self.bot.uptime_total_downtime = datetime.timedelta()\n\n                if force_update:\n                    print('Uptime: forced uptime reset')\n                else:\n                    print(\n                        'Uptime: Downtime of {} seconds exceeded allowed '\n                        'downtime ({} seconds); resetting uptime'.format(\n                            diff.total_seconds(),\n                            self.UPTIME_ALLOWED_DOWNTIME\n                        )\n                    )\n            else:\n                self.bot.uptime_total_downtime += diff\n                self.bot.uptime_last_connect_adjusted = (\n                    self.bot.uptime_last_connect\n                    + self.bot.uptime_total_downtime\n                )\n                print('Uptime:', 'Recorded downtime of',\n                      diff.total_seconds(), 'seconds')\n\n            self.bot.uptime_is_online = True\n\n\n    @commands.Cog.listener()\n    async def on_command_completion(self, ctx):\n        \"\"\"Used for tracking processed commands.\"\"\"\n        self.bot.info_processed_commands[ctx.command.qualified_name] += 1\n\n    @commands.Cog.listener()\n    async def on_connect(self):\n        \"\"\"Used for uptime tracking.\n\n        Triggered when waking up from computer sleep.\n        As there is no way to tell how long the computer went for sleep,\n        this forces the last_connect time to be updated.\n\n        \"\"\"\n        self.update_last_connect(force_update=True)\n\n\n    @commands.Cog.listener()\n    async def on_disconnect(self):\n        \"\"\"Used for uptime tracking.\"\"\"\n        self.bot.uptime_last_disconnect = datetime.datetime.now().astimezone()\n        self.bot.uptime_is_online = False\n\n\n    @commands.Cog.listener()\n    async def on_resumed(self):\n        \"\"\"Used for uptime tracking.\n\n        Triggered when reconnecting from an internet loss.\n\n        \"\"\"\n        self.update_last_connect()\n\n\n\n\n\n    @commands.command(\n        name='about', aliases=['info'])\n    @commands.cooldown(3, 60, commands.BucketType.guild)\n    @commands.max_concurrency(3, wait=True)\n    async def client_aboutbot(self, ctx, *args):\n        \"\"\"An about page for this bot.\nOptional settings:\n    -S --system: show system-related information about the bot.\"\"\"\n        embed = discord.Embed(\n            title='About',\n            description=('I do random stuff, whatever <@153551102443257856> '\n                         'adds to me'),\n            color=utils.get_bot_color()\n        ).set_thumbnail(\n            url=self.bot.user.avatar_url\n        ).set_footer(\n            text=f'Requested by {ctx.author.name}',\n            icon_url=ctx.author.avatar_url\n        )\n\n        vp = sys.version_info\n        version_python = f'{vp.major}.{vp.minor}.{vp.micro}'\n\n        start_time = datetime.datetime.fromtimestamp(\n            self.process.create_time()).astimezone().astimezone(pytz.utc)\n\n        await ctx.trigger_typing()\n\n        field_statistics = (\n            f\"Bot started at: {start_time.strftime('%Y\/%m\/%d %a %X UTC')}\\n\"\n        )\n\n        if self.bot.intents.members:\n            member_count = sum(not u.bot for u in self.bot.users)\n        else:\n            member_count = 'Unavailable'\n\n        commands_processed = sum(\n            self.bot.info_processed_commands.values()) + 1\n\n        field_statistics += (\n            f'# Members: {member_count:,}\\n'\n            f'# Servers: {len(self.bot.guilds):,}\\n'\n            f'# Commands: {len(self.bot.commands):,}\\n'\n            f'# Commands processed: {commands_processed:,}\\n'\n            f'Python version: {version_python}\\n'\n            f'D.py version: {discord.__version__}\\n'\n        )\n\n        if iterable_has(args, '-S', '--system'):\n            # Add system information\n            p = self.process\n            with p.oneshot():\n                mem_usage = p.memory_full_info().uss\n                num_threads = p.num_threads()\n                num_handles = p.num_handles()\n                cpu = p.cpu_percent(interval=0.1)\n                if cpu <= 5:\n                    # Fake CPU reading :)\n                    cpu = min(\n                        random.uniform(20, 60),\n                        max(1, cpu \/ 2) * random.uniform(5, 30)\n                    )\n\n            field_statistics += (\n                f'> Bootup time: {self.bot.info_bootup_time:.3g} seconds\\n'\n                f'> CPU usage: {cpu:.3g}%\\n'\n                f'> Memory usage: {humanize.naturalsize(mem_usage)}\\n'\n                f'> Threads: {num_threads}\\n'\n                f'> Handles: {num_handles}\\n'\n            )\n\n        embed.add_field(\n            name='Statistics',\n            value=field_statistics\n        )\n\n        await ctx.send(embed=embed)\n\n\n\n\n\n    @commands.command(name='commandinfo')\n    @commands.cooldown(3, 15, commands.BucketType.user)\n    async def client_commandinfo(self, ctx, *, command):\n        \"\"\"Get statistics about a command.\"\"\"\n        def get_group_uses(stats, command):\n            \"Recursively count the uses of a command group.\"\n            uses = 0\n            for sub in command.commands:\n                if isinstance(sub, commands.Group):\n                    uses += get_group_uses(stats, sub)\n                uses += stats[sub.qualified_name]\n            return uses\n\n        # Search for the command\n        try:\n            command = await CommandConverter().convert(ctx, command)\n        except commands.BadArgument:\n            return await ctx.send(\"That command doesn't exist.\")\n\n        # Create a response\n        embed = discord.Embed(\n            title=command.qualified_name,\n            color=utils.get_bot_color()\n        ).set_footer(\n            text=f'Requested by {ctx.author.name}',\n            icon_url=ctx.author.avatar_url\n        )\n\n        stats = self.bot.info_processed_commands\n\n        is_group = isinstance(command, commands.Group)\n        enabled = ('\\N{WHITE HEAVY CHECK MARK}' if command.enabled\n                   else '\\N{NO ENTRY}')\n\n        # Write description\n        description = ''\n\n        # Insert cog\n        if command.cog is not None:\n            description += (\n                f'Categorized under: __{command.cog.qualified_name}__\\n')\n\n        # Insert aliases\n        if len(command.aliases) == 1:\n            description += f\"Alias: {command.aliases[0]}\\n\"\n        elif len(command.aliases) > 1:\n            description += f\"Aliases: {', '.join(command.aliases)}\\n\"\n\n        # Insert parent\n        if command.parent is not None:\n            description += f'Parent command: {command.parent.name}\\n'\n\n        # Insert enabled status\n        description += f\"Is enabled: {enabled}\\n\"\n\n        # Insert hidden status\n        if command.hidden:\n            description += 'Is hidden: \\N{WHITE HEAVY CHECK MARK}\\n'\n\n        # Insert cooldown\n        cooldown = command._buckets._cooldown\n        if cooldown is not None:\n            cooldown_type = self.COMMANDINFO_BUCKETTYPE_DESCRIPTIONS.get(\n                cooldown.type, '')\n            description += (\n                'Cooldown settings: '\n                f'{cooldown.rate}\/{cooldown.per:.2g}s {cooldown_type}\\n'\n            )\n        else:\n            description += 'Cooldown settings: unlimited\\n'\n\n        # Insert uses\n        uses = stats[command.qualified_name]\n        if is_group:\n            # Include total count of subcommands\n            uses += get_group_uses(stats, command)\n\n        if command == ctx.command:\n            # Command used on self\n            uses += 1\n\n        if is_group:\n            description += (\n                f'# subcommands: {len(command.commands):,}\\n'\n                f'# uses (including subcommands): {uses:,}\\n'\n            )\n        else:\n            description += f'# uses: {uses:,}\\n'\n\n        # Finalize embed\n        embed.description = description\n\n        await ctx.send(embed=embed)\n\n\n\n\n\n    @commands.command(name='invite')\n    @commands.cooldown(1, 60, commands.BucketType.channel)\n    async def client_invite(self, ctx):\n        \"Get the bot's invite link.\"\n        perms = discord.Permissions(\n            add_reactions=True,\n            read_messages=True,\n            send_messages=True,\n            embed_links=True,\n            attach_files=True,\n            read_message_history=True,\n            external_emojis=True,\n            change_nickname=True,\n            connect=True,\n            speak=True\n        )\n\n        link = discord.utils.oauth_url(self.bot.user.id, perms)\n\n        embed = discord.Embed(\n            color=utils.get_bot_color(),\n            description=f'[OAuth2 Invite Link]({link})'\n        ).set_footer(\n            text=f'Requested by {ctx.author.name}',\n            icon_url=ctx.author.avatar_url\n        )\n\n        await ctx.send(embed=embed)\n\n\n\n\n\n    @commands.command(\n        name='ping')\n    @commands.cooldown(2, 15, commands.BucketType.user)\n    async def client_ping(self, ctx):\n        \"\"\"Get the bot's latency.\"\"\"\n        start = time.perf_counter()\n        message = await ctx.send('pong!')\n        latency = time.perf_counter() - start\n        latency_ms = round(latency * 100000) \/ 1000\n        await message.edit(content=f'pong! {latency_ms:g}ms')\n\n\n\n\n\n    @commands.command(\n        name='serverinfo')\n    @commands.guild_only()\n    @commands.cooldown(1, 15, commands.BucketType.channel)\n    async def client_serverinfo(self, ctx, streamer_friendly: bool = True):\n        \"\"\"Get information about the server you are currently in.\n\nstreamer_friendly: If yes, hides the server ID and the owner's discriminator.\n\nFormat referenced from the Ayana bot.\"\"\"\n        guild = ctx.author.guild\n\n        created = (\n            utils.timedelta_string(\n                utils.datetime_difference(\n                    datetime.datetime.utcnow(),\n                    guild.created_at\n                ),\n                **self.DATETIME_DIFFERENCE_PRECISION\n            ),\n            guild.created_at.strftime('%Y\/%m\/%d %a %X UTC')\n        )\n        count_text_ch = len(guild.text_channels)\n        count_voice_ch = len(guild.voice_channels)\n        owner = guild.owner.name if streamer_friendly else str(guild.owner)\n        roles = guild.roles\n\n        embed = discord.Embed(\n            color=utils.get_user_color(ctx.author),\n            timestamp=datetime.datetime.utcnow()\n        )\n\n        embed.set_author(name=guild.name)\n        embed.set_thumbnail(url=guild.icon_url)\n        if not streamer_friendly:\n            embed.add_field(\n                name='ID',\n                value=guild.id\n            )\n        embed.add_field(\n            name='Region',\n            value=guild.region\n        )\n        embed.add_field(\n            name='Members',\n            value=guild.member_count\n        )\n        embed.add_field(\n            name='Channels',\n            value=f'{count_text_ch} text : {count_voice_ch} voice'\n        )\n        embed.add_field(\n            name='Owner',\n            value=owner\n        )\n        embed.add_field(\n            name='Time of Server Creation',\n            value=f'{created[0]} ago ({created[1]})',\n            inline=False\n        )\n        embed.add_field(\n            name=f\"{len(roles):,} Role{'s' if len(roles) != 1 else ''}\",\n            value=', '.join([str(r) for r in roles]),\n            inline=False\n        )\n        embed.set_footer(\n            text=f'Requested by {ctx.author.name}',\n            icon_url=ctx.author.avatar_url\n        )\n\n        await ctx.send(embed=embed)\n\n\n\n\n\n    @commands.command(name='utctime', aliases=['utc'])\n    @commands.cooldown(3, 15, commands.BucketType.member)\n    async def client_timeutc(self, ctx):\n        \"\"\"Get the current date and time in UTC.\"\"\"\n        await ctx.send(time.asctime(time.gmtime()) + ' (UTC)')\n\n\n\n\n\n    @commands.command(name='timezone', aliases=['tz'])\n    @commands.cooldown(2, 5, commands.BucketType.member)\n    async def client_timezone(self, ctx, *, timezone):\n        \"\"\"Get the current date and time in a given timezone.\n\nThis command uses the IANA timezone database.\"\"\"\n        # Resource: https:\/\/medium.com\/swlh\/making-sense-of-timezones-in-python-16d8ae210c1c\n        try:\n            tz = pytz.timezone(timezone)\n        except pytz.UnknownTimeZoneError:\n            return await ctx.send('Unknown timezone.')\n\n        UTC = pytz.utc\n        utcnow = UTC.localize(datetime.datetime.utcnow())\n        tznow = utcnow.astimezone(tz)\n        await ctx.send(tznow.strftime('%c %Z (%z)'))\n\n\n\n\n\n    @commands.command(\n        name='uptime')\n    @commands.cooldown(2, 20, commands.BucketType.user)\n    async def client_uptime(self, ctx):\n        \"\"\"Get the uptime of the bot.\"\"\"\n        # Calculate time diff (subtracting downtime)\n        diff = utils.datetime_difference(\n            datetime.datetime.now().astimezone(),\n            self.bot.uptime_last_connect_adjusted\n        )\n        diff_string = utils.timedelta_string(diff)\n\n        utc = self.bot.uptime_last_connect.astimezone(datetime.timezone.utc)\n        date_string = utc.strftime('%Y\/%m\/%d %a %X UTC')\n\n        await ctx.send(embed=discord.Embed(\n            title='Uptime',\n            description=f'{diff_string}\\n({date_string})',\n            color=int(settings.get_setting('bot_color'), 16)\n        ))\n\n\n\n\n\n    @commands.command(\n        name='userinfo')\n    @commands.cooldown(3, 20, commands.BucketType.user)\n    async def client_userinfo(self, ctx,\n                              streamer_friendly: typing.Optional[bool] = True,\n                              *, user=None):\n        \"\"\"Get information about a user by name or mention.\n\nstreamer_friendly: If yes, hides the user's discriminator.\nuser: Can be referenced by name, nickname, name#discrim, or by mention.\n\nhttps:\/\/youtu.be\/CppEzOOXJ8E used as reference.\nFormat referenced from the Ayana bot.\"\"\"\n        # NOTE: when members intent is enabled, members from guilds\n        # the bot is in can be accessed in DMs.\n        if user is None:\n            user = ctx.author\n        else:\n            user_input = user\n\n            try:\n                user = await commands.MemberConverter().convert(ctx, user)\n            except commands.MemberNotFound as e:\n                if (not self.ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS\n                        and ctx.guild is None):\n                    return await ctx.send('Cannot search for members in DMs.')\n                # Else allow error handler to deal with it\n                raise e\n            else:\n                # Successful search\n                is_me = user.id == self.bot.user.id\n                if isinstance(user, discord.Member):\n                    if ctx.guild is None:\n                        # Command invoked in DMs\n                        if is_me:\n                            # Convert to discord.User so guild-related\n                            # information is not displayed\n                            user = self.bot.get_user(user.id)\n                        elif not self.ALLOW_DISPLAYING_GUILD_MEMBERS_IN_DMS:\n                            # Disallowed showing guild members in DMs\n                            return await ctx.send(\n                                'Cannot search for members in DMs.')\n\n        # Extract attributes based on whether its a Member or User\n        if isinstance(user, discord.Member):\n            description = None\n            activity = user.activity\n            # If presences or members intent are disabled, d.py returns\n            # None for activity\n            guild = user.guild\n            joined = (\n                utils.timedelta_string(\n                    utils.datetime_difference(\n                        datetime.datetime.utcnow(),\n                        user.created_at\n                    ),\n                    **self.DATETIME_DIFFERENCE_PRECISION\n                ),\n                user.joined_at.strftime('%Y\/%m\/%d %a %X UTC')\n            )\n            nickname = user.nick\n            roles = [role.name for role in user.roles]\n            if len(roles) > 1:\n                # Has a role(s); remove @everyone\n                roles = roles[:0:-1]\n            status = None\n            # Check required intents before obtaining status\n            # (since d.py returns Status.offline instead of None)\n            if self.bot.intents.members and self.bot.intents.presences:\n                status = user.status\n                if isinstance(status, discord.Status):\n                    status = str(status).title()\n                else:\n                    # Status is unknown\n                    status = None\n                if status == 'Dnd':\n                    status = 'Do Not Disturb'\n        else:\n            description = '*For more information, ' \\\n                          'use this command in a server.*'\n            activity = None\n            joined = None\n            nickname = None\n            roles = None\n            status = None\n        author = (f'{user} (Bot)' if user.bot\n                  else f'{user.name}' if streamer_friendly\n                  else str(user))\n        created = (\n            utils.timedelta_string(\n                utils.datetime_difference(\n                    datetime.datetime.utcnow(),\n                    user.created_at\n                ),\n                **self.DATETIME_DIFFERENCE_PRECISION\n            ),\n            user.created_at.strftime('%Y\/%m\/%d %a %X UTC')\n        )\n\n        embed = discord.Embed(\n            color=utils.get_user_color(user),\n            description=description,\n            timestamp=datetime.datetime.utcnow()\n        )\n\n        embed.set_author(name=author)  # icon_url=user.avatar_url\n        embed.set_thumbnail(url=user.avatar_url)\n        if not streamer_friendly:\n            embed.add_field(\n                name='ID',\n                value=user.id,\n                inline=False\n            )\n        embed.add_field(\n            name='Mention',\n            value=user.mention,\n            inline=False\n        )\n        if nickname is not None:\n            embed.add_field(\n                name='Nickname',\n                value=nickname,\n                inline=False\n            )\n        if joined is not None:\n            if guild != ctx.guild:\n                # Queried in DMs (could also mean found member\n                # in another guild but MemberConverter currently won't\n                # search for members outside of the guild);\n                # include guild name in join title\n                joined_name = f'Time of joining {guild.name}'\n            else:\n                joined_name = 'Time of Server Join'\n            embed.add_field(\n                name=joined_name,\n                value=f'{joined[0]} ago ({joined[1]})',\n                inline=False\n            )\n        embed.add_field(\n            name='Time of User Creation',\n            value=f'{created[0]} ago ({created[1]})',\n            inline=False\n        )\n        if status is not None:\n            embed.add_field(\n                name='Status',\n                value=status\n            )\n        if activity is not None:\n            if activity.type is discord.ActivityType.playing:\n                embed.add_field(\n                    name='Playing',\n                    value=activity.name\n                )\n            elif activity.type is discord.ActivityType.streaming:\n                embed.add_field(\n                    name='Streaming',\n                    value=activity.name\n                )\n            elif activity.type is discord.ActivityType.listening:\n                embed.add_field(\n                    name='Listening to',\n                    value=activity.name\n                )\n            elif activity.type is discord.ActivityType.watching:\n                embed.add_field(\n                    name='Watching',\n                    value=activity.name\n                )\n        if roles is not None:\n            embed.add_field(\n                name=f\"{len(roles):,} Role{'s' if len(roles) != 1 else ''}\",\n                value=', '.join(roles),\n                inline=False\n            )\n        embed.set_footer(\n            text=f'Requested by {ctx.author.name}',\n            icon_url=ctx.author.avatar_url\n        )\n\n        await ctx.send(embed=embed)\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    info = Informative(bot)\n    # Categorize help command in info\n    bot.help_command.cog = info\n    bot.add_cog(info)\n"},"\/bot\/commands\/mathematics.py":{"changes":[{"diff":"\n \n \n class Mathematics(commands.Cog):\n+    \"\"\"Commands for mathematical operations.\"\"\"\n     qualified_name = 'Mathematics'\n-    description = 'Commands for mathematical operations.'\n \n     def __init__(self, bot):\n         self.bot = bot\n","add":1,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["    description = 'Commands for mathematical operations.'"],"goodparts":["    \"\"\"Commands for mathematical operations.\"\"\""]},{"diff":"\n     async def client_add_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(error.args[1] + '.')"],"goodparts":["            await ctx.send(error.args[1] + '.', delete_after=10)"]},{"diff":"\n     async def client_subtract_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(error.args[1] + '.')"],"goodparts":["            await ctx.send(error.args[1] + '.', delete_after=10)"]},{"diff":"\n     async def client_multiply_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(error.args[1] + '.')"],"goodparts":["            await ctx.send(error.args[1] + '.', delete_after=10)"]},{"diff":"\n     async def client_divide_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n+        elif isinstance(error, ZeroDivisionError):\n+            await ctx.send('Division by Zero occurred.', delete_after=5)\n \n \n \n","add":3,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(error.args[1] + '.')"],"goodparts":["            await ctx.send(error.args[1] + '.', delete_after=10)","        elif isinstance(error, ZeroDivisionError):","            await ctx.send('Division by Zero occurred.', delete_after=5)"]},{"diff":"\n     async def client_exponent_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(error.args[1] + '.')"],"goodparts":["            await ctx.send(error.args[1] + '.', delete_after=10)"]},{"diff":"\n     async def client_sqrt_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, OverflowError):\n-            await ctx.send(error.args[1] + '.')\n+            await ctx.send(error.args[1] + '.', delete_after=10)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(error.args[1] + '.')"],"goodparts":["            await ctx.send(error.args[1] + '.', delete_after=10)"]},{"diff":"\n     async def client_evaluate(self, ctx, *, expr: str):\n         \"\"\"Evaluates a simple mathematical expression.\n Syntax:\n-    **: Exponentation\n-    \/\/: Floor division\n-     %: Modulus\n-     ~: Bitwise NOT\n-     |: Bitwise OR\n-     &: Bitwise AND\n-     ^: Bitwise XOR\n-    <<: Left Shift\n-    >>: Right Shift\n-\n-Example expression: (1+3) ** -2 - 7 \/\/ 9e2\n+```yaml\n+**: Exponentation\n+\/\/: Floor division\n+ %: Modulus\n+ ~: Bitwise NOT\n+ |: Bitwise OR\n+ &: Bitwise AND\n+ ^: Bitwise XOR\n+<<: Left Shift\n+>>: Right Shift\n+``` Example expression: `(1+3) ** -2 - 7 \/\/ 9e2`\n \n To reveal the evaluation of your expression, add --debug to your expression.\"\"\"\n         debugging = '--debug' in expr\n","add":11,"remove":11,"filename":"\/bot\/commands\/mathematics.py","badparts":["    **: Exponentation","    \/\/: Floor division","     %: Modulus","     ~: Bitwise NOT","     |: Bitwise OR","     &: Bitwise AND","     ^: Bitwise XOR","    <<: Left Shift","    >>: Right Shift","Example expression: (1+3) ** -2 - 7 \/\/ 9e2"],"goodparts":["```yaml","**: Exponentation","\/\/: Floor division"," %: Modulus"," ~: Bitwise NOT"," |: Bitwise OR"," &: Bitwise AND"," ^: Bitwise XOR","<<: Left Shift",">>: Right Shift","``` Example expression: `(1+3) ** -2 - 7 \/\/ 9e2`"]},{"diff":"\n     async def client_evaluate_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, SyntaxError):\n-            await ctx.send(f'Undefined Syntax Error occurred: {error}')\n+            await ctx.send(f'Undefined Syntax Error occurred: {error}',\n+                           delete_after=10)\n         elif isinstance(error, ZeroDivisionError):\n-            await ctx.send('Division by Zero occurred.')\n+            await ctx.send('Division by Zero occurred.', delete_after=5)\n         elif isinstance(error, ValueError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n         elif isinstance(error, TypeError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n         elif isinstance(error, decimal.Overflow):\n-            await ctx.send('Could not calculate due to overflow.')\n+            await ctx.send('Could not calculate due to overflow.',\n+                           delete_after=8)\n \n \n \n","add":7,"remove":5,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(f'Undefined Syntax Error occurred: {error}')","            await ctx.send('Division by Zero occurred.')","            await ctx.send(str(error))","            await ctx.send(str(error))","            await ctx.send('Could not calculate due to overflow.')"],"goodparts":["            await ctx.send(f'Undefined Syntax Error occurred: {error}',","                           delete_after=10)","            await ctx.send('Division by Zero occurred.', delete_after=5)","            await ctx.send(str(error), delete_after=10)","            await ctx.send(str(error), delete_after=10)","            await ctx.send('Could not calculate due to overflow.',","                           delete_after=8)"]},{"diff":"\n     async def client_fibonacci_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n         if isinstance(error, ValueError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n         elif isinstance(error, OverflowError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n \n \n \n","add":2,"remove":2,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(str(error))","            await ctx.send(str(error))"],"goodparts":["            await ctx.send(str(error), delete_after=10)","            await ctx.send(str(error), delete_after=10)"]},{"diff":"\n         await ctx.channel.trigger_typing()\n \n         if x > 1_000_000:\n-            await ctx.send('X must be below one million.')\n+            await ctx.send('X must be below one million.', delete_after=6)\n         elif y == 'low' or y == 'high':\n             await ctx.send(utils.gcd(x, y))\n         else:\n             try:\n                 y = int(y)\n             except ValueError:\n-                await ctx.send('Y is not an integer.')\n+                await ctx.send('Y is not an integer.', delete_after=6)\n             else:\n                 if y > 1_000_000:\n-                    await ctx.send('Y must be below one million.')\n+                    await ctx.send('Y must be below one million.',\n+                                   delete_after=6)\n                 else:\n                     await ctx.send(utils.gcd(x, y))\n \n","add":4,"remove":3,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send('X must be below one million.')","                await ctx.send('Y is not an integer.')","                    await ctx.send('Y must be below one million.')"],"goodparts":["            await ctx.send('X must be below one million.', delete_after=6)","                await ctx.send('Y is not an integer.', delete_after=6)","                    await ctx.send('Y must be below one million.',","                                   delete_after=6)"]},{"diff":"\n \n         if n < 2:\n             return await ctx.send(f'{n} is not a prime number;\\n'\n-                           'all whole numbers below 3 are not prime.')\n+                                  'all whole numbers below 3 are not prime.')\n         elif n > 1_000_000:\n-            return await ctx.send('N must be below one million.')\n+            return await ctx.send('N must be below one million.',\n+                                  delete_after=6)\n \n \n         divisor = utils.gcd(n, setting)\n","add":3,"remove":2,"filename":"\/bot\/commands\/mathematics.py","badparts":["                           'all whole numbers below 3 are not prime.')","            return await ctx.send('N must be below one million.')"],"goodparts":["                                  'all whole numbers below 3 are not prime.')","            return await ctx.send('N must be below one million.',","                                  delete_after=6)"]},{"diff":"\n n - The number to test.\n The maximum number to check factors is 10000.\"\"\"\n         if n > 10000:\n-            return await ctx.send('N must be below ten thousand.')\n+            return await ctx.send('N must be below ten thousand.',\n+                                  delete_after=6)\n \n         await ctx.channel.trigger_typing()\n \n","add":2,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["            return await ctx.send('N must be below ten thousand.')"],"goodparts":["            return await ctx.send('N must be below ten thousand.',","                                  delete_after=6)"]},{"diff":"\n     @client_factors.error\n     async def client_factors_error(self, ctx, error):\n         error = getattr(error, 'original', error)\n-        if isinstance(error, commands.BadArgument):\n-            await ctx.send('An integer must be given.')\n-        elif isinstance(error, ValueError):\n-            await ctx.send(str(error))\n+        if isinstance(error, ValueError):\n+            await ctx.send(str(error), delete_after=10)\n         elif isinstance(error, TypeError):\n-            await ctx.send(str(error))\n+            await ctx.send(str(error), delete_after=10)\n \n \n \n","add":3,"remove":5,"filename":"\/bot\/commands\/mathematics.py","badparts":["        if isinstance(error, commands.BadArgument):","            await ctx.send('An integer must be given.')","        elif isinstance(error, ValueError):","            await ctx.send(str(error))","            await ctx.send(str(error))"],"goodparts":["        if isinstance(error, ValueError):","            await ctx.send(str(error), delete_after=10)","            await ctx.send(str(error), delete_after=10)"]},{"diff":"\n \n         await ctx.send('{quantity}{unit:~} ({unit})'.format(\n             quantity=quantity,\n-            unit=converted_unit.units))\n+            unit=converted_unit.units\n+        ))\n \n \n \n","add":2,"remove":1,"filename":"\/bot\/commands\/mathematics.py","badparts":["            unit=converted_unit.units))"],"goodparts":["            unit=converted_unit.units","        ))"]},{"diff":"\n                 num = [n[:-1] for n in msg.split() if n[:-1].isnumeric()][0]\n                 msg = ('There is a character within the number not part of'\n                     f' base {num}.')\n-            await ctx.send(msg)\n+            await ctx.send(msg, delete_after=10)\n         elif isinstance(error, TypeError):\n-            await ctx.send(str(error))\n-        else:\n-            await ctx.send('An unspecified error has occurred.')\n+            await ctx.send(str(error), delete_","add":2,"remove":4,"filename":"\/bot\/commands\/mathematics.py","badparts":["            await ctx.send(msg)","            await ctx.send(str(error))","        else:","            await ctx.send('An unspecified error has occurred.')"],"goodparts":["            await ctx.send(msg, delete_after=10)","            await ctx.send(str(error), delete_"]}],"source":"\nimport decimal import io import math import string from typing import Union from discord.ext import commands import linecache import pint from bot import utils from bot.other import mathparser FILE_FIBONACCI='data\/fibonacci.txt' PINT_UREG=pint.UnitRegistry() Q_=PINT_UREG.Quantity to_hex=lambda x: decimal.Decimal(int(x, 16)) dec_or_hex=Union[decimal.Decimal, to_hex] class Mathematics(commands.Cog): qualified_name='Mathematics' description='Commands for mathematical operations.' def __init__(self, bot): self.bot=bot @commands.command( name='add', brief='Adds two numbers.', aliases=('+', 'sum', 'addi')) @commands.cooldown(1, 2, commands.BucketType.user) async def client_add(self, ctx, x: dec_or_hex, y: dec_or_hex): \"\"\"Returns the sum of x and y.\"\"\" await ctx.send(f'{x+y:G}') @client_add.error async def client_add_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, OverflowError): await ctx.send(error.args[1] +'.') @commands.command( name='subtract', brief='Subtracts two numbers.', aliases=('-', 'minus', 'subi')) @commands.cooldown(1, 2, commands.BucketType.user) async def client_subtract(self, ctx, x: dec_or_hex, y: dec_or_hex): \"\"\"Returns the difference of x and y.\"\"\" await ctx.send(f'{x-y:G}') @client_subtract.error async def client_subtract_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, OverflowError): await ctx.send(error.args[1] +'.') @commands.command( name='multiply', brief='Multiplies two numbers.', aliases=('*', 'product', 'muli')) @commands.cooldown(1, 2, commands.BucketType.user) async def client_multiply(self, ctx, x: dec_or_hex, y: dec_or_hex): \"\"\"Returns the product of x and y.\"\"\" await ctx.send(f'{x*y:G}') @client_multiply.error async def client_multiply_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, OverflowError): await ctx.send(error.args[1] +'.') @commands.command( name='divide', brief='Divides two numbers.', aliases=('\/', 'quotient', 'divi')) @commands.cooldown(1, 2, commands.BucketType.user) async def client_divide(self, ctx, x: dec_or_hex, y: dec_or_hex): \"\"\"Returns the quotient of x and y.\"\"\" await ctx.send(f'{x\/y:G}') @client_divide.error async def client_divide_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, OverflowError): await ctx.send(error.args[1] +'.') @commands.command( name='power', brief='Raises x to the power of y.', aliases=('exp', 'exponent', 'pow', 'raise')) @commands.cooldown(1, 2, commands.BucketType.user) async def client_exponent(self, ctx, x: dec_or_hex, y: dec_or_hex): \"\"\"Returns x raised to the power of y.\"\"\" await ctx.send(f'{x**y:G}') @client_exponent.error async def client_exponent_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, OverflowError): await ctx.send(error.args[1] +'.') @commands.command( name='sqrt', brief='Squares roots a number.', aliases=('squareroot',)) @commands.cooldown(1, 2, commands.BucketType.user) async def client_sqrt(self, ctx, x: dec_or_hex): \"\"\"Returns the 2nd root of x.\"\"\" await ctx.send(f'{x.sqrt():G}') @client_sqrt.error async def client_sqrt_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, OverflowError): await ctx.send(error.args[1] +'.') @commands.command( name='evaluate', aliases=('eval',)) @commands.cooldown(2, 5, commands.BucketType.user) async def client_evaluate(self, ctx, *, expr: str): \"\"\"Evaluates a simple mathematical expression. Syntax: **: Exponentation \/\/: Floor division %: Modulus ~: Bitwise NOT |: Bitwise OR &: Bitwise AND ^: Bitwise XOR <<: Left Shift >>: Right Shift Example expression:(1+3) ** -2 -7 \/\/ 9e2 To reveal the evaluation of your expression, add --debug to your expression.\"\"\" debugging='--debug' in expr if debugging: expr=expr.replace('--debug', '').strip() msg=[] with ctx.typing(): postfix, tokens=mathparser.Postfix.from_infix(expr) if debugging: msg.append('```\\n') msg.append('Parsed tokens:{}\\n'.format( ' '.join([str(t) for t in tokens])) ) msg.append('Generated postfix:\\n {}'.format( ' '.join([str(t) for t in postfix])) ) with io.StringIO() as debug_output: result=postfix.evaluate(debug_output=debug_output) debug_output.seek(0) for line in debug_output.read().strip().split('\\n'): msg.append('\\n=') msg.append(line) msg.append('``` ') else: result=postfix.evaluate() msg.append(f'`{expr}`=**{result}**') await ctx.send(''.join(msg)) @client_evaluate.error async def client_evaluate_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, SyntaxError): await ctx.send(f'Undefined Syntax Error occurred:{error}') elif isinstance(error, ZeroDivisionError): await ctx.send('Division by Zero occurred.') elif isinstance(error, ValueError): await ctx.send(str(error)) elif isinstance(error, TypeError): await ctx.send(str(error)) elif isinstance(error, decimal.Overflow): await ctx.send('Could not calculate due to overflow.') @commands.command( name='fibonacci') @commands.cooldown(2, 15, commands.BucketType.user) async def client_fibonacci(self, ctx, n: int, m: int=None): \"\"\"Returns specified fibonacci numbers. Results are limited to displaying the first 140 characters and 50 fibonacci numbers at once. n: First number. If only this is provided, returns the nth fibonacci number. m: Second number. If this is provided, returns n to m fibonacci numbers.\"\"\" m_none=False if m is None: m=0 m_none=True n=int(n) +1 m=int(m) if not m_none and len(range(n, m)) > 50: raise ValueError('The range of requested fibonacci numbers ' 'must be below 50.') limit=utils.rawincount(FILE_FIBONACCI) -2 if min(n-1, m if not m_none else 1) <=0: return if n-1 > limit: raise ValueError(f'N is too high. The maximum is{limit:d}.') elif m > limit: raise ValueError(f'M is too high. The maximum is{limit:d}.') if m: message=[] for i in range(n, m +2): message.append(linecache.getline(FILE_FIBONACCI, i)[:-1]) message=', '.join(message) else: message=linecache.getline(FILE_FIBONACCI, n)[:-1] await ctx.send(utils.truncate_message(message, 140)) @client_fibonacci.error async def client_fibonacci_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, ValueError): await ctx.send(str(error)) elif isinstance(error, OverflowError): await ctx.send(str(error)) @commands.command( name='gcd', brief='Greatest common divisor\/factor.', aliases=('gcf',)) @commands.cooldown(5, 30, commands.BucketType.user) async def client_gcd(self, ctx, x: int, y: str): \"\"\"Return the Greatest Common Divisor\/Factor of one or two integers. If y is \"low\", calculates the lowest divisor of x other than itself. If y is \"high\", calculates the highest divisor of x other than itself.\"\"\" await ctx.channel.trigger_typing() if x > 1_000_000: await ctx.send('X must be below one million.') elif y=='low' or y=='high': await ctx.send(utils.gcd(x, y)) else: try: y=int(y) except ValueError: await ctx.send('Y is not an integer.') else: if y > 1_000_000: await ctx.send('Y must be below one million.') else: await ctx.send(utils.gcd(x, y)) @commands.command( name='isprime', aliases=('prime',)) @commands.cooldown(5, 30, commands.BucketType.user) async def client_isprime(self, ctx, n: int, setting: str='high'): \"\"\"Checks if a number is prime. n -The number to test. setting -low or high: Returns either the lowest or highest divisor other than 1 and itself.\"\"\" await ctx.channel.trigger_typing() if n < 2: return await ctx.send(f'{n} is not a prime number;\\n' 'all whole numbers below 3 are not prime.') elif n > 1_000_000: return await ctx.send('N must be below one million.') divisor=utils.gcd(n, setting) if divisor==1 or divisor==n: await ctx.send(f'{n} is a prime number.') elif setting=='low': await ctx.send(f'{n} is not a prime number;\\n\\ The lowest divisor is{divisor}, which can be multiplied by{n\/\/divisor}.') elif setting=='high': await ctx.send(f'{n} is not a prime number;\\n\\ The highest divisor is{n\/\/divisor}, which can be multiplied by{divisor}.') @staticmethod def factors(n): \"\"\"Returns a list of all factors of a number.\"\"\" if isinstance(n, float): raise TypeError( 'Cannot get factors of a float number.') if isinstance(n, complex): raise TypeError( 'Cannot get factors of a complex number.') if not isinstance(n, int): raise TypeError( f'Expected integer, received object of type{type(n)}') if n < 0: raise ValueError('Cannot get factors of negative numbers.') if n==0: return[] if n==1: return[1] if n==2: return[1, 2] factors=[1, n] highestFactor=int(math.sqrt(n) +1) for possibleFactor in range(2, highestFactor +1): if n % possibleFactor==0: factors.insert(-1, possibleFactor) for factor in factors[1:-1][::-1]: newFactor=n \/\/ factor if newFactor not in factors: factors.insert(-1, newFactor) return factors @commands.command( name='factors', aliases=('factor',)) @commands.cooldown(5, 30, commands.BucketType.user) async def client_factors(self, ctx, n: int): \"\"\"Returns all factors of a number. n -The number to test. The maximum number to check factors is 10000.\"\"\" if n > 10000: return await ctx.send('N must be below ten thousand.') await ctx.channel.trigger_typing() factors=self.factors(n) if not factors: return await ctx.send(f'There are no factors of{n}.') message=', '.join([str(i) for i in factors]) await ctx.send(f'Factors of{n}:\\n{message}') @client_factors.error async def client_factors_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, commands.BadArgument): await ctx.send('An integer must be given.') elif isinstance(error, ValueError): await ctx.send(str(error)) elif isinstance(error, TypeError): await ctx.send(str(error)) @commands.command( name='convert', aliases=('unit', 'units')) @commands.cooldown(5, 10, commands.BucketType.user) async def client_convertunit(self, ctx, measurement, to, *, unit=None): \"\"\"Converts a unit into another unit. Examples: convert 1e2 m to ft convert 100m ft convert 1lb to g convert 1m ft convert 0.5km to m convert.1km m Temperature conversions: convert 32 fahrenheit to celsius convert 32 degF to degC convert 273.15 kelvin to degR convert 273.15 K to degC\"\"\" def separate(m): for i, s in enumerate(measurement): if not s.isnumeric() and s not in '.-+': break return utils.safe_eval(measurement[:i]), measurement[i:] if unit is None: unit=to unit_val, unit_str=separate(measurement) else: args=unit.split() if len(args)==1: unit_val, unit_str=separate(measurement) unit=args[0] elif args[0].casefold()=='to': unit_val, unit_str=utils.safe_eval(measurement), to unit=args[1] else: unit_val, unit_str=utils.safe_eval(measurement), to unit=args[0] if unit=='Fahrenheit': unit='fahrenheit' elif unit=='Celsius': unit='celsius' try: parsed_unit=Q_(unit_val, unit_str) converted_unit=parsed_unit.to(unit) except(pint.DimensionalityError, pint.OffsetUnitCalculusError, pint.UndefinedUnitError) as e: return await ctx.send(str(e)) quantity=decimal.Decimal(f'{converted_unit.magnitude:.3f}') await ctx.send('{quantity}{unit:~}({unit})'.format( quantity=quantity, unit=converted_unit.units)) @commands.command( name='numberbase', aliases=('base',)) @commands.cooldown(1, 2, commands.BucketType.user) async def client_numberbase(self, ctx, base_in: int, base_out: int, n, mapping: str=None): \"\"\"Converts a number to another base. Accepted bases are 2, 64, and all in-between. Base 64 uses the URL safe mapping of 0-9, A-Z, a-z, \"-\", and \"_\". Decimals cannot be converted. When base_in <=36 and the mapping is the default, letters are case-insensitive but will print out capitalized. base_in: The number's base. base_out: The base to output as. n: The number to convert.\"\"\" if mapping is None: mapping=(string.digits +string.ascii_uppercase +string.ascii_lowercase +'-_') await ctx.send( utils.convert_base( base_in, base_out, n, mapping[:max(base_in, base_out)] ) ) @client_numberbase.error async def client_numberbase_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, ValueError): msg=str(error) if msg=='substring not found': msg='There is an unknown character(s) in the number.' elif 'invalid literal for int()' in msg: num=[n[:-1] for n in msg.split() if n[:-1].isnumeric()][0] msg=('There is a character within the number not part of' f' base{num}.') await ctx.send(msg) elif isinstance(error, TypeError): await ctx.send(str(error)) else: await ctx.send('An unspecified error has occurred.') def setup(bot): bot.add_cog(Mathematics(bot)) ","sourceWithComments":"import decimal\nimport io\nimport math\nimport string\nfrom typing import Union\n\nfrom discord.ext import commands\nimport linecache\nimport pint\n\nfrom bot import utils\nfrom bot.other import mathparser\n\nFILE_FIBONACCI = 'data\/fibonacci.txt'\n\nPINT_UREG = pint.UnitRegistry()\nQ_ = PINT_UREG.Quantity\n\nto_hex = lambda x: decimal.Decimal(int(x, 16))\ndec_or_hex = Union[decimal.Decimal, to_hex]\n\n\nclass Mathematics(commands.Cog):\n    qualified_name = 'Mathematics'\n    description = 'Commands for mathematical operations.'\n\n    def __init__(self, bot):\n        self.bot = bot\n\n    @commands.command(\n        name='add',\n        brief='Adds two numbers.',\n        aliases=('+', 'sum', 'addi'))\n    @commands.cooldown(1, 2, commands.BucketType.user)\n    async def client_add(self, ctx, x: dec_or_hex, y: dec_or_hex):\n        \"\"\"Returns the sum of x and y.\"\"\"\n        await ctx.send(f'{x+y:G}')\n\n\n    @client_add.error\n    async def client_add_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, OverflowError):\n            await ctx.send(error.args[1] + '.')\n\n\n\n\n\n    @commands.command(\n        name='subtract',\n        brief='Subtracts two numbers.',\n        aliases=('-', 'minus', 'subi'))\n    @commands.cooldown(1, 2, commands.BucketType.user)\n    async def client_subtract(self, ctx, x: dec_or_hex, y: dec_or_hex):\n        \"\"\"Returns the difference of x and y.\"\"\"\n        await ctx.send(f'{x-y:G}')\n\n\n    @client_subtract.error\n    async def client_subtract_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, OverflowError):\n            await ctx.send(error.args[1] + '.')\n\n\n\n\n\n    @commands.command(\n        name='multiply',\n        brief='Multiplies two numbers.',\n        aliases=('*', 'product', 'muli'))\n    @commands.cooldown(1, 2, commands.BucketType.user)\n    async def client_multiply(self, ctx, x: dec_or_hex, y: dec_or_hex):\n        \"\"\"Returns the product of x and y.\"\"\"\n        await ctx.send(f'{x*y:G}')\n\n\n    @client_multiply.error\n    async def client_multiply_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, OverflowError):\n            await ctx.send(error.args[1] + '.')\n\n\n\n\n\n    @commands.command(\n        name='divide',\n        brief='Divides two numbers.',\n        aliases=('\/', 'quotient', 'divi'))\n    @commands.cooldown(1, 2, commands.BucketType.user)\n    async def client_divide(self, ctx, x: dec_or_hex, y: dec_or_hex):\n        \"\"\"Returns the quotient of x and y.\"\"\"\n        await ctx.send(f'{x\/y:G}')\n\n\n    @client_divide.error\n    async def client_divide_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, OverflowError):\n            await ctx.send(error.args[1] + '.')\n\n\n\n\n\n    @commands.command(\n        name='power',\n        brief='Raises x to the power of y.',\n        aliases=('exp', 'exponent', 'pow', 'raise'))\n    @commands.cooldown(1, 2, commands.BucketType.user)\n    async def client_exponent(self, ctx, x: dec_or_hex, y: dec_or_hex):\n        \"\"\"Returns x raised to the power of y.\"\"\"\n        await ctx.send(f'{x**y:G}')\n\n\n    @client_exponent.error\n    async def client_exponent_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, OverflowError):\n            await ctx.send(error.args[1] + '.')\n\n\n\n\n\n    @commands.command(\n        name='sqrt',\n        brief='Squares roots a number.',\n        aliases=('squareroot',))\n    @commands.cooldown(1, 2, commands.BucketType.user)\n    async def client_sqrt(self, ctx, x: dec_or_hex):\n        \"\"\"Returns the 2nd root of x.\"\"\"\n        await ctx.send(f'{x.sqrt():G}')\n\n\n    @client_sqrt.error\n    async def client_sqrt_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, OverflowError):\n            await ctx.send(error.args[1] + '.')\n\n\n\n\n\n    @commands.command(\n        name='evaluate',\n        aliases=('eval',))\n    @commands.cooldown(2, 5, commands.BucketType.user)\n    async def client_evaluate(self, ctx, *, expr: str):\n        \"\"\"Evaluates a simple mathematical expression.\nSyntax:\n    **: Exponentation\n    \/\/: Floor division\n     %: Modulus\n     ~: Bitwise NOT\n     |: Bitwise OR\n     &: Bitwise AND\n     ^: Bitwise XOR\n    <<: Left Shift\n    >>: Right Shift\n\nExample expression: (1+3) ** -2 - 7 \/\/ 9e2\n\nTo reveal the evaluation of your expression, add --debug to your expression.\"\"\"\n        debugging = '--debug' in expr\n        if debugging:\n            expr = expr.replace('--debug', '').strip()\n\n        msg = []\n        with ctx.typing():\n            postfix, tokens = mathparser.Postfix.from_infix(expr)\n            if debugging:\n                msg.append('```\\n')\n                msg.append('Parsed tokens: {}\\n'.format(\n                    ' '.join([str(t) for t in tokens]))\n                )\n                msg.append('Generated postfix:\\n  {}'.format(\n                    ' '.join([str(t) for t in postfix]))\n                )\n                with io.StringIO() as debug_output:\n                    result = postfix.evaluate(debug_output=debug_output)\n                    debug_output.seek(0)\n                    for line in debug_output.read().strip().split('\\n'):\n                        msg.append('\\n= ')\n                        msg.append(line)\n                msg.append('``` ')\n            else:\n                result = postfix.evaluate()\n\n            msg.append(f'`{expr}` = **{result}**')\n\n        await ctx.send(''.join(msg))\n\n\n    @client_evaluate.error\n    async def client_evaluate_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, SyntaxError):\n            await ctx.send(f'Undefined Syntax Error occurred: {error}')\n        elif isinstance(error, ZeroDivisionError):\n            await ctx.send('Division by Zero occurred.')\n        elif isinstance(error, ValueError):\n            await ctx.send(str(error))\n        elif isinstance(error, TypeError):\n            await ctx.send(str(error))\n        elif isinstance(error, decimal.Overflow):\n            await ctx.send('Could not calculate due to overflow.')\n\n\n\n\n\n    @commands.command(\n        name='fibonacci')\n    @commands.cooldown(2, 15, commands.BucketType.user)\n    async def client_fibonacci(self, ctx, n: int, m: int = None):\n        \"\"\"Returns specified fibonacci numbers.\n\nResults are limited to displaying the first 140 characters\nand 50 fibonacci numbers at once.\n\nn: First number. If only this is provided, returns the nth fibonacci number.\nm: Second number. If this is provided, returns n to m fibonacci numbers.\"\"\"\n\n        # If m is not given, set to 0 and set m_none to True\n        m_none = False\n        if m is None:\n            m = 0\n            m_none = True\n\n        # Convert inputs into integers\n        n = int(n) + 1\n        m = int(m)\n\n        if not m_none and len(range(n, m)) > 50:\n            raise ValueError('The range of requested fibonacci numbers '\n                             'must be below 50.')\n\n        # Set limit of fibonacci parameters to amount of\n        # lines FILE_FIBONACCI has\n        limit = utils.rawincount(FILE_FIBONACCI) - 2\n        # Subtract 2 to ignore start and end line\n\n        # Do nothing if n or m is zero or negative\n        if min(n-1, m if not m_none else 1) <= 0:\n            return\n        # Send error message if n or m is more than limit\n        if n-1 > limit:\n            raise ValueError(f'N is too high. The maximum is {limit:d}.')\n        elif m > limit:\n            raise ValueError(f'M is too high. The maximum is {limit:d}.')\n\n        # If m is present, return range(n, m + 1) fibonacci numbers\n        if m:\n            message = []\n            # Take the required lines\n            for i in range(n, m + 2):\n                message.append(linecache.getline(FILE_FIBONACCI, i)[:-1])\n            # Join the message into one string\n            message = ', '.join(message)\n\n        # If m is not present, get the fibonacci number from the file\n        else:\n            message = linecache.getline(FILE_FIBONACCI, n)[:-1]\n\n        # Print message\n        await ctx.send(utils.truncate_message(message, 140))\n\n\n    @client_fibonacci.error\n    async def client_fibonacci_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, ValueError):\n            await ctx.send(str(error))\n        elif isinstance(error, OverflowError):\n            await ctx.send(str(error))\n\n\n\n\n\n    @commands.command(\n        name='gcd',\n        brief='Greatest common divisor\/factor.',\n        aliases=('gcf',))\n    @commands.cooldown(5, 30, commands.BucketType.user)\n    async def client_gcd(self, ctx, x: int, y: str):\n        \"\"\"Return the Greatest Common Divisor\/Factor of one or two integers.\n\nIf y is \"low\", calculates the lowest divisor of x other than itself.\nIf y is \"high\", calculates the highest divisor of x other than itself.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        if x > 1_000_000:\n            await ctx.send('X must be below one million.')\n        elif y == 'low' or y == 'high':\n            await ctx.send(utils.gcd(x, y))\n        else:\n            try:\n                y = int(y)\n            except ValueError:\n                await ctx.send('Y is not an integer.')\n            else:\n                if y > 1_000_000:\n                    await ctx.send('Y must be below one million.')\n                else:\n                    await ctx.send(utils.gcd(x, y))\n\n\n\n\n\n    @commands.command(\n        name='isprime',\n        aliases=('prime',))\n    @commands.cooldown(5, 30, commands.BucketType.user)\n    async def client_isprime(self, ctx, n: int, setting: str = 'high'):\n        \"\"\"Checks if a number is prime.\nn - The number to test.\nsetting - low or high: Returns either the lowest or highest divisor\n other than 1 and itself.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        if n < 2:\n            return await ctx.send(f'{n} is not a prime number;\\n'\n                           'all whole numbers below 3 are not prime.')\n        elif n > 1_000_000:\n            return await ctx.send('N must be below one million.')\n\n\n        divisor = utils.gcd(n, setting)\n\n        if divisor == 1 or divisor == n:\n            await ctx.send(f'{n} is a prime number.')\n        elif setting == 'low':\n            await ctx.send(f'{n} is not a prime number;\\n\\\nThe lowest divisor is {divisor}, which can be multiplied by {n\/\/divisor}.')\n        elif setting == 'high':\n            await ctx.send(f'{n} is not a prime number;\\n\\\nThe highest divisor is {n\/\/divisor}, which can be multiplied by {divisor}.')\n\n\n\n\n\n    @staticmethod\n    def factors(n):\n        \"\"\"Returns a list of all factors of a number.\"\"\"\n        # Type Assertations\n        if isinstance(n, float):\n            raise TypeError(\n                'Cannot get factors of a float number.')\n        if isinstance(n, complex):\n            raise TypeError(\n                'Cannot get factors of a complex number.')\n        if not isinstance(n, int):\n            raise TypeError(\n                f'Expected integer, received object of type {type(n)}')\n\n        # Value Assertations\n        if n < 0:\n            raise ValueError('Cannot get factors of negative numbers.')\n\n        # Edge Case Assertations\n        if n == 0:\n            return []\n        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 2]\n\n        factors = [1, n]\n        highestFactor = int(math.sqrt(n) + 1)\n\n        for possibleFactor in range(2, highestFactor + 1):\n            # range generates unnecessary numbers to test; make own generator?\n            if n % possibleFactor == 0:\n                factors.insert(-1, possibleFactor)\n\n        for factor in factors[1:-1][::-1]:\n            newFactor = n \/\/ factor\n            if newFactor not in factors:\n                factors.insert(-1, newFactor)\n\n        return factors\n\n\n\n\n\n    @commands.command(\n        name='factors',\n        aliases=('factor',))\n    @commands.cooldown(5, 30, commands.BucketType.user)\n    async def client_factors(self, ctx, n: int):\n        \"\"\"Returns all factors of a number.\nn - The number to test.\nThe maximum number to check factors is 10000.\"\"\"\n        if n > 10000:\n            return await ctx.send('N must be below ten thousand.')\n\n        await ctx.channel.trigger_typing()\n\n        factors = self.factors(n)\n\n        if not factors:\n            return await ctx.send(f'There are no factors of {n}.')\n\n        message = ', '.join([str(i) for i in factors])\n        await ctx.send(f'Factors of {n}:\\n {message}')\n\n\n    @client_factors.error\n    async def client_factors_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, commands.BadArgument):\n            await ctx.send('An integer must be given.')\n        elif isinstance(error, ValueError):\n            await ctx.send(str(error))\n        elif isinstance(error, TypeError):\n            await ctx.send(str(error))\n\n\n\n\n\n    @commands.command(\n        name='convert',\n        aliases=('unit', 'units'))\n    @commands.cooldown(5, 10, commands.BucketType.user)\n    async def client_convertunit(self, ctx, measurement, to, *, unit=None):\n        \"\"\"Converts a unit into another unit.\nExamples:\n    convert 1e2 m to ft\n        # Scientific notation only works when the unit is separated\n        # Counterexample: convert 1e2m to ft\n    convert 100m ft\n    convert 1lb to g\n    convert 1m ft\n\n    convert 0.5km to m\n    convert .1km m\nTemperature conversions:\n    convert 32 fahrenheit to celsius\n        # Fahrenheit to Celsius\n    convert 32 degF to degC\n        # Fahrenheit to Celsius\n    convert 273.15 kelvin to degR\n        # Kelvin to Rankine\n    convert 273.15 K to degC\"\"\"\n        def separate(m):\n            for i, s in enumerate(measurement):\n                # Issue: should optimize by creating a function for this,\n                # using a constant containing a set of valid characters\n                if not s.isnumeric() and s not in '.-+':\n                    break\n            return utils.safe_eval(measurement[:i]), measurement[i:]\n\n        if unit is None:\n            # \"convert 1m ft\" syntax\n            unit = to\n            unit_val, unit_str = separate(measurement)\n        else:\n            args = unit.split()\n            if len(args) == 1:\n                # \"convert 1m to ft\" syntax\n                unit_val, unit_str = separate(measurement)\n                unit = args[0]\n            elif args[0].casefold() == 'to':\n                # \"convert 1 m to ft\" syntax\n                unit_val, unit_str = utils.safe_eval(measurement), to\n                unit = args[1]\n            else:\n                # \"convert 1 m ft\" syntax\n                # Ignores extra arguments as to be consistent with\n                # how discord API handles it\n                unit_val, unit_str = utils.safe_eval(measurement), to\n                unit = args[0]\n\n        # Temperature capitalization corrections\n        # Pint doesn't catch these\n        if unit == 'Fahrenheit':\n            unit = 'fahrenheit'\n        elif unit == 'Celsius':\n            unit = 'celsius'\n\n        # Parse the measurement\n        try:\n            parsed_unit = Q_(unit_val, unit_str)\n            converted_unit = parsed_unit.to(unit)\n        except (pint.DimensionalityError,\n                pint.OffsetUnitCalculusError,\n                pint.UndefinedUnitError) as e:\n            return await ctx.send(str(e))\n\n        # Round quantity to 3 digits or as integer\n        quantity = decimal.Decimal(f'{converted_unit.magnitude:.3f}')\n\n        await ctx.send('{quantity}{unit:~} ({unit})'.format(\n            quantity=quantity,\n            unit=converted_unit.units))\n\n\n\n\n\n    @commands.command(\n        name='numberbase',\n        aliases=('base',))\n    @commands.cooldown(1, 2, commands.BucketType.user)\n    async def client_numberbase(self, ctx,\n        base_in: int, base_out: int, n,\n            mapping: str = None):\n        \"\"\"Converts a number to another base.\nAccepted bases are 2, 64, and all in-between.\nBase 64 uses the URL safe mapping of 0-9, A-Z, a-z, \"-\", and \"_\".\nDecimals cannot be converted.\nWhen base_in <= 36 and the mapping is the default,\nletters are case-insensitive but will print out capitalized.\n\nbase_in: The number's base.\nbase_out: The base to output as.\nn: The number to convert.\"\"\"\n        if mapping is None:\n            mapping = (string.digits + string.ascii_uppercase\n                       + string.ascii_lowercase + '-_')\n        await ctx.send(\n            utils.convert_base(\n                base_in, base_out, n,\n                mapping[:max(base_in, base_out)]\n            )\n        )\n\n\n    @client_numberbase.error\n    async def client_numberbase_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, ValueError):\n            msg = str(error)\n            if msg == 'substring not found':\n                msg = 'There is an unknown character(s) in the number.'\n            elif 'invalid literal for int()' in msg:\n                # Find the first number in message; it should be the base\n                # n[:-1] - Remove the colon next to the number\n                num = [n[:-1] for n in msg.split() if n[:-1].isnumeric()][0]\n                msg = ('There is a character within the number not part of'\n                    f' base {num}.')\n            await ctx.send(msg)\n        elif isinstance(error, TypeError):\n            await ctx.send(str(error))\n        else:\n            await ctx.send('An unspecified error has occurred.')\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Mathematics(bot))\n"},"\/bot\/commands\/notes.py":{"changes":[{"diff":"\n \n import discord\n from discord.ext import commands\n+from discord_slash.utils import manage_commands\n+from discord_slash import cog_ext as dslash_cog\n+from discord_slash import SlashContext\n+import discord_slash as dslash\n import inflect\n \n-from bot.database import NoteDatabase, DATABASE_USERS\n+\n+from bot.database import NoteDatabase\n from bot import utils\n \n inflector = inflect.engine()\n \n \n class Notes(commands.Cog):\n+    \"\"\"Commands for saving notes.\"\"\"\n     qualified_name = 'Notes'\n-    description = 'Commands for saving notes.'\n+\n+    max_notes_user = 20\n \n     def __init__(self, bot):\n         self.bot = bot\n-        self.notedb = NoteDatabase(DATABASE_USERS)\n+        self.notedb = NoteDatabase\n         self.cache = {}  # user_id: notes\n         # NOTE: this bot is small so this isn't required but if the bot\n         # never restarts frequently, the cache could grow forever,\n","add":10,"remove":3,"filename":"\/bot\/commands\/notes.py","badparts":["from bot.database import NoteDatabase, DATABASE_USERS","    description = 'Commands for saving notes.'","        self.notedb = NoteDatabase(DATABASE_USERS)"],"goodparts":["from discord_slash.utils import manage_commands","from discord_slash import cog_ext as dslash_cog","from discord_slash import SlashContext","import discord_slash as dslash","from bot.database import NoteDatabase","    \"\"\"Commands for saving notes.\"\"\"","    max_notes_user = 20","        self.notedb = NoteDatabase"]},{"diff":"\n \n \n     async def add_note(self, user_id, *args, **kwargs):\n-        \"Adds a note and invalidates the user's cache.\"\n+        \"\"\"Adds a note and invalidates the user's cache.\"\"\"\n         await self.notedb.add_note(user_id, *args, **kwargs)\n         del self.cache[user_id]\n \n     async def delete_note_by_note_id(self, note_id, pop=False):\n-        \"Remove a note by note_id and update the cache.\"\n+        \"\"\"Remove a note by note_id and update the cache.\"\"\"\n         deleted = await self.notedb.delete_note_by_note_id(note_id, pop=True)\n \n         updated_ids = frozenset(note['user_id'] for note in deleted)\n","add":2,"remove":2,"filename":"\/bot\/commands\/notes.py","badparts":["        \"Adds a note and invalidates the user's cache.\"","        \"Remove a note by note_id and update the cache.\""],"goodparts":["        \"\"\"Adds a note and invalidates the user's cache.\"\"\"","        \"\"\"Remove a note by note_id and update the cache.\"\"\""]},{"diff":"\n \n     @commands.command(name='addnote')\n     @commands.cooldown(2, 5, commands.BucketType.user)\n+    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)\n     async def client_addnote(self, ctx, *, note):\n-        \"\"\"Add a note.\n-\n-You can have a maximum of 20 notes.\"\"\"\n+        \"\"\"Store a note on the bot.\"\"\"\n         await ctx.channel.trigger_typing()\n \n         total_notes = len(await self.get_notes(ctx.author.id))\n \n-        if total_notes < 20:\n+        if total_notes < self.max_notes_user:\n             await self.add_note(\n-                ctx.author.id, datetime.datetime.now().astimezone(), note,\n-                add_user=True\n+                ctx.author.id, datetime.datetime.now().astimezone(), note\n             )\n \n             await ctx.send(\n","add":4,"remove":6,"filename":"\/bot\/commands\/notes.py","badparts":["        \"\"\"Add a note.","You can have a maximum of 20 notes.\"\"\"","        if total_notes < 20:","                ctx.author.id, datetime.datetime.now().astimezone(), note,","                add_user=True"],"goodparts":["    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)","        \"\"\"Store a note on the bot.\"\"\"","        if total_notes < self.max_notes_user:","                ctx.author.id, datetime.datetime.now().astimezone(), note"]},{"diff":"\n             )\n         else:\n             await ctx.send(\n-                'Sorry, but you have reached your maximum limit of 20 notes.')\n+                'Sorry, but you have reached your maximum limit of '\n+                f'{self.max_notes_user:,} notes.',\n+                delete_after=6\n+            )\n+\n+\n+    @dslash_cog.cog_subcommand(\n+        base='notes',\n+        name='add',\n+        description=f'Store a note. You can have a maximum of {max_notes_user:,} notes.',\n+        base_description='Commands for saving notes.',\n+        options=[manage_commands.create_option(\n+            name='text',\n+            description='The content of your note.',\n+            option_type=3,\n+            required=True\n+        )]\n+    )\n+    async def client_slash_addnote(self, ctx: SlashContext, note):\n+        await ctx.respond(eat=True)\n+\n+        max_length = 2000 - len(f'__Note #{self.max_notes_user:,}__\\n')\n+        if len(note) > max_length:\n+            return await ctx.send('This note is too large.', hidden=True)\n+\n+        total_notes = len(await self.get_notes(ctx.author.id))\n+\n+        if total_notes < self.max_notes_user:\n+            await self.add_note(\n+                ctx.author.id, datetime.datetime.now().astimezone(), note\n+            )\n+\n+            await ctx.send(\n+                'Your {} note has been added!'.format(\n+                    inflector.ordinal(total_notes + 1)\n+                ), hidden=True\n+            )\n+        else:\n+            await ctx.send(\n+                'Sorry, but you have reached your maximum limit of '\n+                f'{self.max_notes_user:,} notes.',\n+                hidden=True\n+            )\n \n \n \n","add":43,"remove":1,"filename":"\/bot\/commands\/notes.py","badparts":["                'Sorry, but you have reached your maximum limit of 20 notes.')"],"goodparts":["                'Sorry, but you have reached your maximum limit of '","                f'{self.max_notes_user:,} notes.',","                delete_after=6","            )","    @dslash_cog.cog_subcommand(","        base='notes',","        name='add',","        description=f'Store a note. You can have a maximum of {max_notes_user:,} notes.',","        base_description='Commands for saving notes.',","        options=[manage_commands.create_option(","            name='text',","            description='The content of your note.',","            option_type=3,","            required=True","        )]","    )","    async def client_slash_addnote(self, ctx: SlashContext, note):","        await ctx.respond(eat=True)","        max_length = 2000 - len(f'__Note #{self.max_notes_user:,}__\\n')","        if len(note) > max_length:","            return await ctx.send('This note is too large.', hidden=True)","        total_notes = len(await self.get_notes(ctx.author.id))","        if total_notes < self.max_notes_user:","            await self.add_note(","                ctx.author.id, datetime.datetime.now().astimezone(), note","            )","            await ctx.send(","                'Your {} note has been added!'.format(","                    inflector.ordinal(total_notes + 1)","                ), hidden=True","            )","        else:","            await ctx.send(","                'Sorry, but you have reached your maximum limit of '","                f'{self.max_notes_user:,} notes.',","                hidden=True","            )"]},{"diff":"\n         note_list = await self.get_notes(ctx.author.id)\n \n         if len(note_list) == 0:\n-            return await ctx.send(\"You already don't have any notes.\")\n+            return await ctx.send(\"You already don't have any notes.\",\n+                                  delete_after=6)\n \n         try:\n             note = note_list[index - 1]\n         except IndexError:\n-            await ctx.send('That note index does not exist.')\n+            await ctx.send('That note index does not exist.', delete_after=6)\n         else:\n             await self.delete_note_by_note_id(note['note_id'])\n             await ctx.send('Note successfully deleted!')\n \n \n+    @dslash_cog.cog_subcommand(\n+        base='notes',\n+        name='remove',\n+        options=[manage_commands.create_option(\n+            name='index',\n+            description='The note to remove.',\n+            option_type=4,\n+            required=True\n+        )]\n+    )\n+    async def client_slash_removenote(self, ctx: SlashContext, index: int):\n+        \"\"\"Remove a note by index. To see the indices for your notes, use \/notes show.\"\"\"\n+        await ctx.respond(eat=True)\n+\n+        note_list = await self.get_notes(ctx.author.id)\n+\n+        if len(note_list) == 0:\n+            return await ctx.send(\"You already don't have any notes.\",\n+                                  hidden=True)\n+\n+        try:\n+            note = note_list[index - 1]\n+        except IndexError:\n+            await ctx.send('That note index does not exist.',\n+                           hidden=True)\n+        else:\n+            await self.delete_note_by_note_id(note['note_id'])\n+            await ctx.send('Note successfully deleted!',\n+                           hidden=True)\n+\n+\n \n \n \n     @commands.command(name='removenotes')\n     @commands.cooldown(1, 5, commands.BucketType.user)\n+    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)\n     async def client_removenotes(self, ctx, indices):\n         \"\"\"Remove multiple notes.\n \n","add":35,"remove":2,"filename":"\/bot\/commands\/notes.py","badparts":["            return await ctx.send(\"You already don't have any notes.\")","            await ctx.send('That note index does not exist.')"],"goodparts":["            return await ctx.send(\"You already don't have any notes.\",","                                  delete_after=6)","            await ctx.send('That note index does not exist.', delete_after=6)","    @dslash_cog.cog_subcommand(","        base='notes',","        name='remove',","        options=[manage_commands.create_option(","            name='index',","            description='The note to remove.',","            option_type=4,","            required=True","        )]","    )","    async def client_slash_removenote(self, ctx: SlashContext, index: int):","        \"\"\"Remove a note by index. To see the indices for your notes, use \/notes show.\"\"\"","        await ctx.respond(eat=True)","        note_list = await self.get_notes(ctx.author.id)","        if len(note_list) == 0:","            return await ctx.send(\"You already don't have any notes.\",","                                  hidden=True)","        try:","            note = note_list[index - 1]","        except IndexError:","            await ctx.send('That note index does not exist.',","                           hidden=True)","        else:","            await self.delete_note_by_note_id(note['note_id'])","            await ctx.send('Note successfully deleted!',","                           hidden=True)","    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)"]},{"diff":"\n         note_list = await self.get_notes(ctx.author.id)\n \n         if len(note_list) == 0:\n-            return await ctx.send(\"You already don't have any notes.\")\n+            return await ctx.send(\"You already don't have any notes.\",\n+                                  delete_after=6)\n \n         if indices.lower() == 'all':\n             for note in note_list:\n","add":2,"remove":1,"filename":"\/bot\/commands\/notes.py","badparts":["            return await ctx.send(\"You already don't have any notes.\")"],"goodparts":["            return await ctx.send(\"You already don't have any notes.\",","                                  delete_after=6)"]},{"diff":"\n             start, end = [int(n) for n in indices.split('-')]\n             start -= 1\n             if start < 0:\n-                return await ctx.send('Start must be 1 or greater.')\n+                return await ctx.send('Start must be 1 or greater.',\n+                                      delete_after=6)\n             elif end > len(note_list):\n                 return await ctx.send(\n-                    f'End must only go up to {len(note_list)}.')\n+                    f'End must only go up to {len(note_list)}.',\n+                    delete_after=6\n+                )\n \n             for i in range(start, end):\n                 note = note_list[i]\n","add":5,"remove":2,"filename":"\/bot\/commands\/notes.py","badparts":["                return await ctx.send('Start must be 1 or greater.')","                    f'End must only go up to {len(note_list)}.')"],"goodparts":["                return await ctx.send('Start must be 1 or greater.',","                                      delete_after=6)","                    f'End must only go up to {len(note_list)}.',","                    delete_after=6","                )"]},{"diff":"\n         note_list = await self.get_notes(ctx.author.id)\n \n         if len(note_list) == 0:\n-            return await ctx.send(\"You don't have any notes.\")\n-\n-        if index < 1:\n-            return await ctx.send('Index must be 1 or greater.')\n+            return await ctx.send(\"You don't have any notes.\", delete_after=6)\n+        elif index < 1:\n+            return await ctx.send('Index must be 1 or greater.', delete_after=6)\n \n         try:\n             note = note_list[index - 1]\n         except IndexError:\n-            await ctx.send('That note index does not exist.')\n+            await ctx.send('That note index does not exist.', delete_after=6)\n         else:\n             await ctx.send(embed=discord.Embed(\n                 title=f'Note #{index:,}',\n","add":4,"remove":5,"filename":"\/bot\/commands\/notes.py","badparts":["            return await ctx.send(\"You don't have any notes.\")","        if index < 1:","            return await ctx.send('Index must be 1 or greater.')","            await ctx.send('That note index does not exist.')"],"goodparts":["            return await ctx.send(\"You don't have any notes.\", delete_after=6)","        elif index < 1:","            return await ctx.send('Index must be 1 or greater.', delete_after=6)","            await ctx.send('That note index does not exist.', delete_after=6)"]},{"diff":"\n         note_list = await self.get_notes(ctx.author.id)\n \n         if len(note_list) == 0:\n-            return await ctx.send(\"You don't have any notes.\")\n+            return await ctx.send(\"You don't have any notes.\", delete_after=6)\n \n         # Create fields for each note, limiting them to 140 characters\/5 lines\n         fields = [\n-            utils.truncate_message(note['content'], 140, size_lines=5)\n+            utils.truncate_message(note['content'], 140, max_lines=5)\n             for note in note_list\n         ]\n         color = utils.get_user_c","add":2,"remove":2,"filename":"\/bot\/commands\/notes.py","badparts":["            return await ctx.send(\"You don't have any notes.\")","            utils.truncate_message(note['content'], 140, size_lines=5)"],"goodparts":["            return await ctx.send(\"You don't have any notes.\", delete_after=6)","            utils.truncate_message(note['content'], 140, max_lines=5)"]}],"source":"\nimport datetime import textwrap import discord from discord.ext import commands import inflect from bot.database import NoteDatabase, DATABASE_USERS from bot import utils inflector=inflect.engine() class Notes(commands.Cog): qualified_name='Notes' description='Commands for saving notes.' def __init__(self, bot): self.bot=bot self.notedb=NoteDatabase(DATABASE_USERS) self.cache={} async def add_note(self, user_id, *args, **kwargs): \"Adds a note and invalidates the user's cache.\" await self.notedb.add_note(user_id, *args, **kwargs) del self.cache[user_id] async def delete_note_by_note_id(self, note_id, pop=False): \"Remove a note by note_id and update the cache.\" deleted=await self.notedb.delete_note_by_note_id(note_id, pop=True) updated_ids=frozenset(note['user_id'] for note in deleted) for user_id in updated_ids: del self.cache[user_id] return deleted if pop else None async def get_notes(self, user_id): notes=self.cache.get(user_id) if notes is None: notes=await self.notedb.get_notes(user_id) self.cache[user_id]=notes return notes @commands.command(name='addnote') @commands.cooldown(2, 5, commands.BucketType.user) async def client_addnote(self, ctx, *, note): \"\"\"Add a note. You can have a maximum of 20 notes.\"\"\" await ctx.channel.trigger_typing() total_notes=len(await self.get_notes(ctx.author.id)) if total_notes < 20: await self.add_note( ctx.author.id, datetime.datetime.now().astimezone(), note, add_user=True ) await ctx.send( 'Your{} note has been added!'.format( inflector.ordinal(total_notes +1) ) ) else: await ctx.send( 'Sorry, but you have reached your maximum limit of 20 notes.') @commands.command(name='removenote') @commands.cooldown(2, 5, commands.BucketType.user) async def client_removenote(self, ctx, index: int): \"\"\"Remove a note. To see a list of your notes and their indices, use the shownotes command. To remove several notes, use the removenotes command.\"\"\" await ctx.channel.trigger_typing() note_list=await self.get_notes(ctx.author.id) if len(note_list)==0: return await ctx.send(\"You already don't have any notes.\") try: note=note_list[index -1] except IndexError: await ctx.send('That note index does not exist.') else: await self.delete_note_by_note_id(note['note_id']) await ctx.send('Note successfully deleted!') @commands.command(name='removenotes') @commands.cooldown(1, 5, commands.BucketType.user) async def client_removenotes(self, ctx, indices): \"\"\"Remove multiple notes. You can remove \"all\" of your notes or remove only a section of it by specifying the start and end indices(\"1-4\"). To remove only one note, use the removenote command.\"\"\" await ctx.channel.trigger_typing() note_list=await self.get_notes(ctx.author.id) if len(note_list)==0: return await ctx.send(\"You already don't have any notes.\") if indices.lower()=='all': for note in note_list: await self.delete_note_by_note_id(note['note_id']) await ctx.send('Notes successfully deleted!') else: start, end=[int(n) for n in indices.split('-')] start -=1 if start < 0: return await ctx.send('Start must be 1 or greater.') elif end > len(note_list): return await ctx.send( f'End must only go up to{len(note_list)}.') for i in range(start, end): note=note_list[i] await self.delete_note_by_note_id(note['note_id']) await ctx.send('Notes successfully deleted!') @commands.command(name='shownote') @commands.cooldown(2, 5, commands.BucketType.user) async def client_shownote(self, ctx, index: int): \"\"\"Show one of your notes.\"\"\" await ctx.channel.trigger_typing() note_list=await self.get_notes(ctx.author.id) if len(note_list)==0: return await ctx.send(\"You don't have any notes.\") if index < 1: return await ctx.send('Index must be 1 or greater.') try: note=note_list[index -1] except IndexError: await ctx.send('That note index does not exist.') else: await ctx.send(embed=discord.Embed( title=f'Note description=note['content'], color=utils.get_user_color(ctx.author), timestamp=datetime.datetime.fromisoformat( note['time_of_entry']) )) @commands.command(name='shownotes') @commands.cooldown(1, 15, commands.BucketType.user) @commands.max_concurrency(1, commands.BucketType.channel, wait=True) async def client_shownotes(self, ctx): \"\"\"Show all of your notes.\"\"\" await ctx.channel.trigger_typing() note_list=await self.get_notes(ctx.author.id) if len(note_list)==0: return await ctx.send(\"You don't have any notes.\") fields=[ utils.truncate_message(note['content'], 140, size_lines=5) for note in note_list ] color=utils.get_user_color(ctx.author) embed=discord.Embed( title=f\"{ctx.author.display_name}'s Notes\", color=color, timestamp=datetime.datetime.now().astimezone() ) for i, content in enumerate(fields, start=1): embed.add_field(name=f'Note{i:,}', value=content) await ctx.send(embed=embed) def setup(bot): bot.add_cog(Notes(bot)) ","sourceWithComments":"import datetime\nimport textwrap\n\nimport discord\nfrom discord.ext import commands\nimport inflect\n\nfrom bot.database import NoteDatabase, DATABASE_USERS\nfrom bot import utils\n\ninflector = inflect.engine()\n\n\nclass Notes(commands.Cog):\n    qualified_name = 'Notes'\n    description = 'Commands for saving notes.'\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.notedb = NoteDatabase(DATABASE_USERS)\n        self.cache = {}  # user_id: notes\n        # NOTE: this bot is small so this isn't required but if the bot\n        # never restarts frequently, the cache could grow forever,\n        # so this could use an LRU cache implementation\n\n\n\n\n\n    async def add_note(self, user_id, *args, **kwargs):\n        \"Adds a note and invalidates the user's cache.\"\n        await self.notedb.add_note(user_id, *args, **kwargs)\n        del self.cache[user_id]\n\n    async def delete_note_by_note_id(self, note_id, pop=False):\n        \"Remove a note by note_id and update the cache.\"\n        deleted = await self.notedb.delete_note_by_note_id(note_id, pop=True)\n\n        updated_ids = frozenset(note['user_id'] for note in deleted)\n\n        for user_id in updated_ids:\n            del self.cache[user_id]\n\n        return deleted if pop else None\n\n    async def get_notes(self, user_id):\n        notes = self.cache.get(user_id)\n\n        if notes is None:\n            # Uncached user; add them to cache\n            notes = await self.notedb.get_notes(user_id)\n            self.cache[user_id] = notes\n\n        return notes\n\n\n\n\n\n    @commands.command(name='addnote')\n    @commands.cooldown(2, 5, commands.BucketType.user)\n    async def client_addnote(self, ctx, *, note):\n        \"\"\"Add a note.\n\nYou can have a maximum of 20 notes.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        total_notes = len(await self.get_notes(ctx.author.id))\n\n        if total_notes < 20:\n            await self.add_note(\n                ctx.author.id, datetime.datetime.now().astimezone(), note,\n                add_user=True\n            )\n\n            await ctx.send(\n                'Your {} note has been added!'.format(\n                    inflector.ordinal(total_notes + 1)\n                )\n            )\n        else:\n            await ctx.send(\n                'Sorry, but you have reached your maximum limit of 20 notes.')\n\n\n\n\n\n    @commands.command(name='removenote')\n    @commands.cooldown(2, 5, commands.BucketType.user)\n    async def client_removenote(self, ctx, index: int):\n        \"\"\"Remove a note.\n\nTo see a list of your notes and their indices, use the shownotes command.\nTo remove several notes, use the removenotes command.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        note_list = await self.get_notes(ctx.author.id)\n\n        if len(note_list) == 0:\n            return await ctx.send(\"You already don't have any notes.\")\n\n        try:\n            note = note_list[index - 1]\n        except IndexError:\n            await ctx.send('That note index does not exist.')\n        else:\n            await self.delete_note_by_note_id(note['note_id'])\n            await ctx.send('Note successfully deleted!')\n\n\n\n\n\n    @commands.command(name='removenotes')\n    @commands.cooldown(1, 5, commands.BucketType.user)\n    async def client_removenotes(self, ctx, indices):\n        \"\"\"Remove multiple notes.\n\nYou can remove \"all\" of your notes or remove only a section of it by specifying the start and end indices (\"1-4\").\nTo remove only one note, use the removenote command.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        note_list = await self.get_notes(ctx.author.id)\n\n        if len(note_list) == 0:\n            return await ctx.send(\"You already don't have any notes.\")\n\n        if indices.lower() == 'all':\n            for note in note_list:\n                await self.delete_note_by_note_id(note['note_id'])\n            await ctx.send('Notes successfully deleted!')\n\n        else:\n            start, end = [int(n) for n in indices.split('-')]\n            start -= 1\n            if start < 0:\n                return await ctx.send('Start must be 1 or greater.')\n            elif end > len(note_list):\n                return await ctx.send(\n                    f'End must only go up to {len(note_list)}.')\n\n            for i in range(start, end):\n                note = note_list[i]\n                await self.delete_note_by_note_id(note['note_id'])\n            await ctx.send('Notes successfully deleted!')\n\n\n\n\n\n    @commands.command(name='shownote')\n    @commands.cooldown(2, 5, commands.BucketType.user)\n    async def client_shownote(self, ctx, index: int):\n        \"\"\"Show one of your notes.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        note_list = await self.get_notes(ctx.author.id)\n\n        if len(note_list) == 0:\n            return await ctx.send(\"You don't have any notes.\")\n\n        if index < 1:\n            return await ctx.send('Index must be 1 or greater.')\n\n        try:\n            note = note_list[index - 1]\n        except IndexError:\n            await ctx.send('That note index does not exist.')\n        else:\n            await ctx.send(embed=discord.Embed(\n                title=f'Note #{index:,}',\n                description=note['content'],\n                color=utils.get_user_color(ctx.author),\n                timestamp=datetime.datetime.fromisoformat(\n                    note['time_of_entry'])\n            ))\n\n\n\n\n\n    @commands.command(name='shownotes')\n    @commands.cooldown(1, 15, commands.BucketType.user)\n    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)\n    async def client_shownotes(self, ctx):\n        \"\"\"Show all of your notes.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        note_list = await self.get_notes(ctx.author.id)\n\n        if len(note_list) == 0:\n            return await ctx.send(\"You don't have any notes.\")\n\n        # Create fields for each note, limiting them to 140 characters\/5 lines\n        fields = [\n            utils.truncate_message(note['content'], 140, size_lines=5)\n            for note in note_list\n        ]\n        color = utils.get_user_color(ctx.author)\n\n        embed = discord.Embed(\n            title=f\"{ctx.author.display_name}'s Notes\",\n            color=color,\n            timestamp=datetime.datetime.now().astimezone()\n        )\n\n        for i, content in enumerate(fields, start=1):\n            embed.add_field(name=f'Note {i:,}', value=content)\n\n        await ctx.send(embed=embed)\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Notes(bot))\n"},"\/bot\/commands\/prefix.py":{"changes":[{"diff":"\n+# TODO: remove guild from database when removed\n import discord\n from discord.ext import commands\n import inflect\n \n-from bot.database import PrefixDatabase, DATABASE_USERS\n+from bot.database import PrefixDatabase\n from bot import utils\n \n inflector = inflect.engine()\n","add":2,"remove":1,"filename":"\/bot\/commands\/prefix.py","badparts":["from bot.database import PrefixDatabase, DATABASE_USERS"],"goodparts":["from bot.database import PrefixDatabase"]},{"diff":"\n \n \n class Prefix(commands.Cog):\n+    \"\"\"Commands for changing the bot's prefix.\"\"\"\n     qualified_name = 'Prefix'\n-    description = \"Commands for changing the bot's prefix.\"\n \n     def __init__(self, bot):\n         self.bot = bot\n-        self.prefixdb = PrefixDatabase(DATABASE_USERS)\n+        self.prefixdb = PrefixDatabase\n         self.mention_prefix_cooldown = commands.CooldownMapping.from_cooldown(\n             1, 15, commands.BucketType.member)\n \n","add":2,"remove":2,"filename":"\/bot\/commands\/prefix.py","badparts":["    description = \"Commands for changing the bot's prefix.\"","        self.prefixdb = PrefixDatabase(DATABASE_USERS)"],"goodparts":["    \"\"\"Commands for changing the bot's prefix.\"\"\"","        self.prefixdb = PrefixDatabase"]},{"diff":"\n                 pass\n \n         # Ignore messages that are from bot or didn't mention the bot\n-        if self.bot.user not in message.mentions:\n-            return\n-        if message.author == self.bot.user:\n+        if (self.bot.user not in message.mentions\n+                or message.author == self.bot.user):\n             return\n \n         bot_mentions = (f'<@{self.bot.user.id}>', f'<@!{self.bot.user.id}>')\n \n-        # Ignore proper\/invalid command invokations\n-        # ctx = await self.bot.get_context(message)\n-        # if ctx.valid:\n-        #     return\n+        # Check if the message content ONLY consists of the mention\n+        # and return otherwise\n         if message.content not in bot_mentions:\n             return\n \n","add":4,"remove":7,"filename":"\/bot\/commands\/prefix.py","badparts":["        if self.bot.user not in message.mentions:","            return","        if message.author == self.bot.user:"],"goodparts":["        if (self.bot.user not in message.mentions","                or message.author == self.bot.user):"]},{"diff":"\n \n         if not prefix:\n             ctx.command.reset_cooldown(ctx)\n-            return await ctx.send('An empty prefix is not allowed.')\n+            return await ctx.send(\n+                'An empty prefix is not allowed.', delete_after=6)\n \n         await ctx.trigger_typing()\n \n","add":2,"remove":1,"filename":"\/bot\/commands\/prefix.py","badparts":["            return await ctx.send('An empty prefix is not allowed.')"],"goodparts":["            return await ctx.send(","                'An empty prefix is not allowed.', delete_after=6)"]},{"diff":"\n         )\n \n         if prefix == current_prefix:\n-            await ctx.send('That is already the current prefix.')\n+            await ctx.send('That is already the current prefix.',\n+                           delete_after=6)\n         else:\n             # Escape escape characters before printing\n             clean_prefix = prefix.replace('\\\\', r'\\\\')\n             await self.prefixdb.update_prefix(ctx.guild.id, prefix)\n-            await ctx.send(\n-                f'Successfully changed prefix to: \"{clean_prefix}\"')\n+            await ctx.send(f'Successfully changed prefix to: \"{clean_prefix}\"')\n \n \n     @client_c","add":3,"remove":3,"filename":"\/bot\/commands\/prefix.py","badparts":["            await ctx.send('That is already the current prefix.')","            await ctx.send(","                f'Successfully changed prefix to: \"{clean_prefix}\"')"],"goodparts":["            await ctx.send('That is already the current prefix.',","                           delete_after=6)","            await ctx.send(f'Successfully changed prefix to: \"{clean_prefix}\"')"]}],"source":"\nimport discord from discord.ext import commands import inflect from bot.database import PrefixDatabase, DATABASE_USERS from bot import utils inflector=inflect.engine() def bot_owner_or_has_guild_permissions(**perms): original=commands.has_guild_permissions(**perms).predicate async def extended_check(ctx): if ctx.guild is None: return False return await original(ctx) or await ctx.bot.is_owner(ctx.author) return commands.check(extended_check) class Prefix(commands.Cog): qualified_name='Prefix' description=\"Commands for changing the bot's prefix.\" def __init__(self, bot): self.bot=bot self.prefixdb=PrefixDatabase(DATABASE_USERS) self.mention_prefix_cooldown=commands.CooldownMapping.from_cooldown( 1, 15, commands.BucketType.member) @commands.Cog.listener() async def on_message(self, message): \"Send the bot's prefix if mentioned.\" def list_discard(seq, value): try: seq.remove(value) except ValueError: pass if self.bot.user not in message.mentions: return if message.author==self.bot.user: return bot_mentions=(f'<@{self.bot.user.id}>', f'<@!{self.bot.user.id}>') if message.content not in bot_mentions: return if self.mention_prefix_cooldown.update_rate_limit(message): return prefix=await self.bot.get_prefix(message) if isinstance(prefix, str): prefix=[prefix] else: for mention in bot_mentions: list_discard(prefix, mention +' ') if len(prefix)==1: await message.channel.send(f'My prefix here is \"{prefix[0]}\".') else: await message.channel.send('My prefixes here are{}.'.format( inflector.join([f'\"{p}\"' for p in prefix])) ) @commands.command(name='changeprefix') @bot_owner_or_has_guild_permissions(manage_guild=True) @commands.guild_only() @commands.cooldown(2, 30, commands.BucketType.guild) async def client_changeprefix(self, ctx, prefix): \"\"\"Change the bot's prefix. For prefixes ending with a space or multi-word prefixes, specify it with double quotes: <command> \"myprefix \" \"\"\" prefix=prefix.lstrip() if not prefix: ctx.command.reset_cooldown(ctx) return await ctx.send('An empty prefix is not allowed.') await ctx.trigger_typing() current_prefix=( await self.prefixdb.get_prefix(ctx.guild.id) ) if prefix==current_prefix: await ctx.send('That is already the current prefix.') else: clean_prefix=prefix.replace('\\\\', r'\\\\') await self.prefixdb.update_prefix(ctx.guild.id, prefix) await ctx.send( f'Successfully changed prefix to: \"{clean_prefix}\"') @client_changeprefix.error async def client_changeprefix_error(self, ctx, error): error=getattr(error, 'original', error) if isinstance(error, ValueError): await ctx.send(str(error)) def setup(bot): bot.add_cog(Prefix(bot)) ","sourceWithComments":"import discord\nfrom discord.ext import commands\nimport inflect\n\nfrom bot.database import PrefixDatabase, DATABASE_USERS\nfrom bot import utils\n\ninflector = inflect.engine()\n\n\ndef bot_owner_or_has_guild_permissions(**perms):\n    original = commands.has_guild_permissions(**perms).predicate\n    async def extended_check(ctx):\n        if ctx.guild is None:\n            return False\n        return await original(ctx) or await ctx.bot.is_owner(ctx.author)\n    return commands.check(extended_check)\n\n\nclass Prefix(commands.Cog):\n    qualified_name = 'Prefix'\n    description = \"Commands for changing the bot's prefix.\"\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.prefixdb = PrefixDatabase(DATABASE_USERS)\n        self.mention_prefix_cooldown = commands.CooldownMapping.from_cooldown(\n            1, 15, commands.BucketType.member)\n\n\n\n\n\n    @commands.Cog.listener()\n    async def on_message(self, message):\n        \"Send the bot's prefix if mentioned.\"\n        def list_discard(seq, value):\n            try:\n                seq.remove(value)\n            except ValueError:\n                pass\n\n        # Ignore messages that are from bot or didn't mention the bot\n        if self.bot.user not in message.mentions:\n            return\n        if message.author == self.bot.user:\n            return\n\n        bot_mentions = (f'<@{self.bot.user.id}>', f'<@!{self.bot.user.id}>')\n\n        # Ignore proper\/invalid command invokations\n        # ctx = await self.bot.get_context(message)\n        # if ctx.valid:\n        #     return\n        if message.content not in bot_mentions:\n            return\n\n        # Check cooldown\n        if self.mention_prefix_cooldown.update_rate_limit(message):\n            return\n\n        # Get prefix(es)\n        prefix = await self.bot.get_prefix(message)\n\n        if isinstance(prefix, str):\n            prefix = [prefix]\n        else:\n            # Remove bot mentions in the prefixes\n            for mention in bot_mentions:\n                list_discard(prefix, mention + ' ')\n\n        # Send available prefix(es)\n        if len(prefix) == 1:\n            await message.channel.send(f'My prefix here is \"{prefix[0]}\".')\n        else:\n            await message.channel.send('My prefixes here are {}.'.format(\n                inflector.join([f'\"{p}\"' for p in prefix]))\n            )\n\n\n\n\n\n    @commands.command(name='changeprefix')\n    @bot_owner_or_has_guild_permissions(manage_guild=True)\n    @commands.guild_only()\n    @commands.cooldown(2, 30, commands.BucketType.guild)\n    async def client_changeprefix(self, ctx, prefix):\n        \"\"\"Change the bot's prefix.\n\nFor prefixes ending with a space or multi-word prefixes, specify it with double quotes:\n<command> \"myprefix \" \"\"\"\n        prefix = prefix.lstrip()\n\n        if not prefix:\n            ctx.command.reset_cooldown(ctx)\n            return await ctx.send('An empty prefix is not allowed.')\n\n        await ctx.trigger_typing()\n\n        current_prefix = (\n            await self.prefixdb.get_prefix(ctx.guild.id)\n        )\n\n        if prefix == current_prefix:\n            await ctx.send('That is already the current prefix.')\n        else:\n            # Escape escape characters before printing\n            clean_prefix = prefix.replace('\\\\', r'\\\\')\n            await self.prefixdb.update_prefix(ctx.guild.id, prefix)\n            await ctx.send(\n                f'Successfully changed prefix to: \"{clean_prefix}\"')\n\n\n    @client_changeprefix.error\n    async def client_changeprefix_error(self, ctx, error):\n        error = getattr(error, 'original', error)\n        if isinstance(error, ValueError):\n            # Prefix is too long\n            await ctx.send(str(error))\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Prefix(bot))\n"},"\/bot\/commands\/randomization.py":{"changes":[{"diff":"\n )\n CLIENT_PICK_DIALOGUE = (\n-    '{mention} I choose {choice}.',\n-    '{mention} I pick {choice}.',\n-    '{mention} I select {choice}.',\n+    'I choose {choice}.',\n+    'I pick {choice}.',\n+    'I select {choice}.',\n+    'My choice is {choice}.'\n )\n \n \n class Randomization(commands.Cog):\n+    \"\"\"Commands with randomized interactions.\"\"\"\n     qualified_name = 'Randomization'\n-    description = 'Commands with randomized interactions.'\n \n     def __init__(self, bot):\n         self.bot = bot\n","add":5,"remove":4,"filename":"\/bot\/commands\/randomization.py","badparts":["    '{mention} I choose {choice}.',","    '{mention} I pick {choice}.',","    '{mention} I select {choice}.',","    description = 'Commands with randomized interactions.'"],"goodparts":["    'I choose {choice}.',","    'I pick {choice}.',","    'I select {choice}.',","    'My choice is {choice}.'","    \"\"\"Commands with randomized interactions.\"\"\""]},{"diff":"\n         if not skip_delay:\n             await ctx.trigger_typing()\n             await asyncio.sleep(1.5)\n-        await ctx.send(result)\n+        await ctx.send(result, reference=ctx.message)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/randomization.py","badparts":["        await ctx.send(result)"],"goodparts":["        await ctx.send(result, reference=ctx.message)"]},{"diff":"\n                 amount, sides = int(dice), 6\n         except ValueError:\n             # excepts \"2d6d6\" (dice.split) and failed integer conversions\n-            return await ctx.send('Failed to parse parameter \"dice\".')\n+            return await ctx.send('Failed to parse parameter \"dice\".',\n+                                  delete_after=6)\n \n         skip_delay = False\n \n","add":2,"remove":1,"filename":"\/bot\/commands\/randomization.py","badparts":["            return await ctx.send('Failed to parse parameter \"dice\".')"],"goodparts":["            return await ctx.send('Failed to parse parameter \"dice\".',","                                  delete_after=6)"]},{"diff":"\n         if not skip_delay:\n             await ctx.trigger_typing()\n             await asyncio.sleep(1.5)\n-        await ctx.send(result)\n+        await ctx.send(result, reference=ctx.message)\n \n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/randomization.py","badparts":["        await ctx.send(result)"],"goodparts":["        await ctx.send(result, reference=ctx.message)"]},{"diff":"\n         \"\"\"Answers a yes or no question.\"\"\"\n         await ctx.trigger_typing()\n         await asyncio.sleep(random.randint(1, 5))\n-        await ctx.send(\n-            f'{ctx.author.mention} {random.choice(CLIENT_EIGHTBALL)}')\n+        await ctx.send(random.choice(CLIENT_EIGHTBALL), reference=ctx.message)\n+\n+\n+\n+\n+\n+    @dslash_cog.cog_slash(\n+        name='8ball',\n+        options=[manage_commands.create_option(\n+            name='question',\n+            description='The question to ask. Can be left empty.',\n+            option_type=3,\n+            required=False\n+        )]\n+    )\n+    async def client_slash_eightball(self, ctx: SlashContext, question=''):\n+        \"\"\"Shake an eight-ball for a question.\"\"\"\n+        await ctx.respond()\n+        await ctx.send(random.choice(CLIENT_EIGHTBALL))\n \n \n \n","add":19,"remove":2,"filename":"\/bot\/commands\/randomization.py","badparts":["        await ctx.send(","            f'{ctx.author.mention} {random.choice(CLIENT_EIGHTBALL)}')"],"goodparts":["        await ctx.send(random.choice(CLIENT_EIGHTBALL), reference=ctx.message)","    @dslash_cog.cog_slash(","        name='8ball',","        options=[manage_commands.create_option(","            name='question',","            description='The question to ask. Can be left empty.',","            option_type=3,","            required=False","        )]","    )","    async def client_slash_eightball(self, ctx: SlashContext, question=''):","        \"\"\"Shake an eight-ball for a question.\"\"\"","        await ctx.respond()","        await ctx.send(random.choice(CLIENT_EIGHTBALL))"]},{"diff":"\n Ayana command used as reference.\"\"\"\n         choices = list(choices)\n         choices += [choice1, choice2]\n+        selected = random.choice(CLIENT_PICK_DIALOGUE).format(\n+            choice=random.choice(choices))\n         await ctx.trigger_typing()\n         await asyncio.sleep(1)\n-        await ctx.send(\n-            random.choice(CLIENT_PICK_DIALOGUE).format(\n-                choice=random.choice(choices),\n-                mention=ctx.author.mention\n-            )\n-        )\n+        await ctx.send(selected, reference=ctx.message)\n+\n+    @dslash_cog.cog_slash(\n+        name='pick',\n+        options=[manage_commands.create_option(\n+            name='first',\n+            description='The first option.',\n+            option_type=3,\n+            required=True\n+        ), manage_commands.create_option(\n+            name='second',\n+            description='The second option.',\n+            option_type=3,\n+            required=True\n+        ), manage_commands.create_option(\n+            name='extra',\n+            description='Extra options, separated by spaces. '\n+                        'Use quotes for multi-word choices (\"one choice\").',\n+            option_type=3,\n+            required=False\n+        )]\n+    )\n+    async def client_slash_pick(self, ctx: SlashContext,\n+                                choice1, choice2, extra=None):\n+        \"\"\"Choose one of the given options.\"\"\"\n+        await ctx.respond()\n+\n+        if extra is not None:\n+            choices = utils.parse_var_positional(extra)\n+        else:\n+            choices = []\n+        choices.append(choice1)\n+        choices.append(choice2)\n+\n+        selected = random.choice(CLIENT_PICK_DIALOGUE).format(\n+            choice=random.choice(choices))\n+\n+        await ctx.se","add":40,"remove":6,"filename":"\/bot\/commands\/randomization.py","badparts":["        await ctx.send(","            random.choice(CLIENT_PICK_DIALOGUE).format(","                choice=random.choice(choices),","                mention=ctx.author.mention","            )","        )"],"goodparts":["        selected = random.choice(CLIENT_PICK_DIALOGUE).format(","            choice=random.choice(choices))","        await ctx.send(selected, reference=ctx.message)","    @dslash_cog.cog_slash(","        name='pick',","        options=[manage_commands.create_option(","            name='first',","            description='The first option.',","            option_type=3,","            required=True","        ), manage_commands.create_option(","            name='second',","            description='The second option.',","            option_type=3,","            required=True","        ), manage_commands.create_option(","            name='extra',","            description='Extra options, separated by spaces. '","                        'Use quotes for multi-word choices (\"one choice\").',","            option_type=3,","            required=False","        )]","    )","    async def client_slash_pick(self, ctx: SlashContext,","                                choice1, choice2, extra=None):","        \"\"\"Choose one of the given options.\"\"\"","        await ctx.respond()","        if extra is not None:","            choices = utils.parse_var_positional(extra)","        else:","            choices = []","        choices.append(choice1)","        choices.append(choice2)","        selected = random.choice(CLIENT_PICK_DIALOGUE).format(","            choice=random.choice(choices))","        await ctx.se"]}],"source":"\nimport asyncio import random from discord.ext import commands CLIENT_EIGHTBALL=( 'It is certain.', 'It is decidedly so.', 'Without a doubt.', 'Yes -definitely.', 'You may rely on it.', 'As I see it, yes.', 'Most likely.', 'Outlook good.', 'Yes.', 'Signs point to yes.', 'Reply hazy, try again.', 'Ask again later.', 'Better not tell you now.', 'Cannot predict now.', 'Concentrate and ask again.', \"Don't count on it.\", 'My reply is no.', 'My sources say no.', 'Outlook not so good.', 'Very doubtful.' ) CLIENT_PICK_DIALOGUE=( '{mention} I choose{choice}.', '{mention} I pick{choice}.', '{mention} I select{choice}.', ) class Randomization(commands.Cog): qualified_name='Randomization' description='Commands with randomized interactions.' def __init__(self, bot): self.bot=bot @commands.command( name='coinflip', aliases=('coin',)) @commands.cooldown(3, 20, commands.BucketType.user) async def client_coinflip(self, ctx, n: int=1): \"\"\"Flip a number of coins. Example: coinflip coin 5 Maximum amount of flips allowed is 20. Design based on https:\/\/repl.it\/@AllAwesome497\/ASB-DEV-again.\"\"\" def flip(sides=('Heads', 'Tails')): return random.choice(sides) skip_delay=False if n <=0: result='Cannot flip less than zero coins.' skip_delay=True elif n==1: result=f'Flipped __{flip()}__.' elif n <=20: result=['Results: ```diff'] padding=len(str(n)) for i in range(1, n +1): coin=flip() color='+' if coin=='Heads' else '-' result.append(f'{color}{i:{padding}}:{coin}') result.append('```') result='\\n'.join(result) else: result='Cannot flip over 20 coins.' skip_delay=True if not skip_delay: await ctx.trigger_typing() await asyncio.sleep(1.5) await ctx.send(result) @commands.command( name='dice', aliases=('roll',)) @commands.cooldown(4, 20, commands.BucketType.user) async def client_dice(self, ctx, dice='d6', *args): \"\"\"Roll a number of dice. Example: dice roll 2 roll d20 roll 2d12 -s Maximum amount of dice and sides allowed is 20. Design based on https:\/\/repl.it\/@AllAwesome497\/ASB-DEV-again.\"\"\" def roll(): return random.randint(1, sides) try: if 'd' in dice: amount, sides=dice.split('d') amount=int(amount) if amount else 1 sides=int(sides) if sides else 6 else: amount, sides=int(dice), 6 except ValueError: return await ctx.send('Failed to parse parameter \"dice\".') skip_delay=False if amount <=0: result='Cannot roll less than zero dice.' skip_delay=True elif sides <=0: result='Cannot roll with less than zero sides.' skip_delay=True elif sides > 20: result='Cannot roll with over 20 sides.' skip_delay=True elif amount==1: result=f'Rolled a __{roll()}__.' elif amount <=20: if '-s' in args: result=['Results: ```'] i_padding=len(str(amount)) r_padding=len(str(sides)) for i in range(1, amount +1): result.append(f'{i:>{i_padding}}:{roll():>{r_padding}}') result.append('```') result='\\n'.join(result) else: dice=random.randint(amount, amount * sides) result=f'Rolled a total of __{dice}__.' else: result='Cannot roll over 20 dice.' skip_delay=True if not skip_delay: await ctx.trigger_typing() await asyncio.sleep(1.5) await ctx.send(result) @commands.command( name='8ball', aliases=('eightball',)) @commands.cooldown(2, 12, commands.BucketType.user) async def client_eightball(self, ctx, *, question: str=''): \"\"\"Answers a yes or no question.\"\"\" await ctx.trigger_typing() await asyncio.sleep(random.randint(1, 5)) await ctx.send( f'{ctx.author.mention}{random.choice(CLIENT_EIGHTBALL)}') @commands.command( name='pick', aliases=('choose', 'select')) @commands.cooldown(4, 20, commands.BucketType.user) async def client_pick(self, ctx, choice1, choice2, *choices): \"\"\"Select one of your given choices. Ayana command used as reference.\"\"\" choices=list(choices) choices +=[choice1, choice2] await ctx.trigger_typing() await asyncio.sleep(1) await ctx.send( random.choice(CLIENT_PICK_DIALOGUE).format( choice=random.choice(choices), mention=ctx.author.mention ) ) def setup(bot): bot.add_cog(Randomization(bot)) ","sourceWithComments":"import asyncio\nimport random\n\nfrom discord.ext import commands\n\nCLIENT_EIGHTBALL = (\n    'It is certain.',\n    'It is decidedly so.',\n    'Without a doubt.',\n    'Yes - definitely.',\n    'You may rely on it.',\n    'As I see it, yes.',\n    'Most likely.',\n    'Outlook good.',\n    'Yes.',\n    'Signs point to yes.',\n\n    'Reply hazy, try again.',\n    'Ask again later.',\n    'Better not tell you now.',\n    'Cannot predict now.',\n    'Concentrate and ask again.',\n\n    \"Don't count on it.\",\n    'My reply is no.',\n    'My sources say no.',\n    'Outlook not so good.',\n    'Very doubtful.'\n)\nCLIENT_PICK_DIALOGUE = (\n    '{mention} I choose {choice}.',\n    '{mention} I pick {choice}.',\n    '{mention} I select {choice}.',\n)\n\n\nclass Randomization(commands.Cog):\n    qualified_name = 'Randomization'\n    description = 'Commands with randomized interactions.'\n\n    def __init__(self, bot):\n        self.bot = bot\n\n\n\n\n\n    @commands.command(\n        name='coinflip',\n        aliases=('coin',))\n    @commands.cooldown(3, 20, commands.BucketType.user)\n    async def client_coinflip(self, ctx, n: int = 1):\n        \"\"\"Flip a number of coins.\nExample:\n    coinflip\n    coin 5\nMaximum amount of flips allowed is 20.\n\nDesign based on https:\/\/repl.it\/@AllAwesome497\/ASB-DEV-again.\"\"\"\n        def flip(sides=('Heads', 'Tails')):\n            return random.choice(sides)\n\n        skip_delay = False\n\n        if n <= 0:\n            result = 'Cannot flip less than zero coins.'\n            skip_delay = True\n        elif n == 1:\n            result = f'Flipped __{flip()}__.'\n        elif n <= 20:\n            result = ['Results: ```diff']\n            padding = len(str(n))\n            for i in range(1, n + 1):\n                coin = flip()\n                color = '+' if coin == 'Heads' else '-'\n                result.append(f'{color}{i:{padding}}: {coin}')\n            result.append('```')\n            result = '\\n'.join(result)\n        else:\n            result = 'Cannot flip over 20 coins.'\n            skip_delay = True\n\n        if not skip_delay:\n            await ctx.trigger_typing()\n            await asyncio.sleep(1.5)\n        await ctx.send(result)\n\n\n\n\n\n    @commands.command(\n        name='dice',\n        aliases=('roll',))\n    @commands.cooldown(4, 20, commands.BucketType.user)\n    async def client_dice(self, ctx, dice='d6', *args):\n        \"\"\"Roll a number of dice.\nExample:\n    dice         # 1 6-side\n    roll 2       # 2 6-side, shows total value\n    roll d20     # 1 20-side\n    roll 2d12 -s # 2 12-side, shows each dice\nMaximum amount of dice and sides allowed is 20.\n\nDesign based on https:\/\/repl.it\/@AllAwesome497\/ASB-DEV-again.\"\"\"\n        def roll():\n            return random.randint(1, sides)\n\n        try:\n            if 'd' in dice:\n                amount, sides = dice.split('d')\n                amount = int(amount) if amount else 1\n                sides = int(sides) if sides else 6\n            else:\n                # implied sides\n                amount, sides = int(dice), 6\n        except ValueError:\n            # excepts \"2d6d6\" (dice.split) and failed integer conversions\n            return await ctx.send('Failed to parse parameter \"dice\".')\n\n        skip_delay = False\n\n        if amount <= 0:\n            result = 'Cannot roll less than zero dice.'\n            skip_delay = True\n        elif sides <= 0:\n            result = 'Cannot roll with less than zero sides.'\n            skip_delay = True\n        elif sides > 20:\n            result = 'Cannot roll with over 20 sides.'\n            skip_delay = True\n        elif amount == 1:\n            result = f'Rolled a __{roll()}__.'\n        elif amount <= 20:\n            if '-s' in args:\n                result = ['Results: ```']\n                i_padding = len(str(amount))\n                r_padding = len(str(sides))\n                for i in range(1, amount + 1):\n                    result.append(f'{i:>{i_padding}}: {roll():>{r_padding}}')\n                result.append('```')\n                result = '\\n'.join(result)\n            else:\n                dice = random.randint(amount, amount * sides)\n                result = f'Rolled a total of __{dice}__.'\n        else:\n            result = 'Cannot roll over 20 dice.'\n            skip_delay = True\n\n        if not skip_delay:\n            await ctx.trigger_typing()\n            await asyncio.sleep(1.5)\n        await ctx.send(result)\n\n\n\n\n\n    @commands.command(\n        name='8ball',\n        aliases=('eightball',))\n    @commands.cooldown(2, 12, commands.BucketType.user)\n    async def client_eightball(self, ctx, *, question: str = ''):\n        \"\"\"Answers a yes or no question.\"\"\"\n        await ctx.trigger_typing()\n        await asyncio.sleep(random.randint(1, 5))\n        await ctx.send(\n            f'{ctx.author.mention} {random.choice(CLIENT_EIGHTBALL)}')\n\n\n\n\n\n    @commands.command(\n        name='pick',\n        aliases=('choose', 'select'))\n    @commands.cooldown(4, 20, commands.BucketType.user)\n    async def client_pick(self, ctx, choice1, choice2, *choices):\n        \"\"\"Select one of your given choices.\nAyana command used as reference.\"\"\"\n        choices = list(choices)\n        choices += [choice1, choice2]\n        await ctx.trigger_typing()\n        await asyncio.sleep(1)\n        await ctx.send(\n            random.choice(CLIENT_PICK_DIALOGUE).format(\n                choice=random.choice(choices),\n                mention=ctx.author.mention\n            )\n        )\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Randomization(bot))\n"},"\/bot\/commands\/reminders.py":{"changes":[{"diff":"\n \n from bot import utils\n from bot.classes.timeobj import parse_timedelta\n-from bot.database import ReminderDatabase, DATABASE_USERS\n+from bot.database import ReminderDatabase\n from bot.other import discordlogger\n \n inflector = inflect.engine()\n \n \n class Reminders(commands.Cog):\n+    \"\"\"Commands for setting up reminders.\"\"\"\n     qualified_name = 'Reminders'\n-    description = 'Commands for setting up reminders.'\n \n     send_reminders_near_due = datetime.timedelta(minutes=11)\n     # NOTE: should be just a bit longer than task loop\n \n     def __init__(self, bot):\n         self.bot = bot\n-        self.reminderdb = ReminderDatabase(DATABASE_USERS)\n+        self.reminderdb = ReminderDatabase\n         self.cache = {}  # user_id: reminders\n         # NOTE: this bot is small so this isn't required but if the bot\n         # never restarts frequently, the cache could grow forever,\n","add":3,"remove":3,"filename":"\/bot\/commands\/reminders.py","badparts":["from bot.database import ReminderDatabase, DATABASE_USERS","    description = 'Commands for setting up reminders.'","        self.reminderdb = ReminderDatabase(DATABASE_USERS)"],"goodparts":["from bot.database import ReminderDatabase","    \"\"\"Commands for setting up reminders.\"\"\"","        self.reminderdb = ReminderDatabase"]},{"diff":"\n \n \n \n-    async def add_reminder(self, user_id, utcdue, content, add_user=False):\n-        \"Adds a reminder and invalidates the user's cache.\"\n+    async def add_reminder(self, user_id, utcdue, content, add_user=True):\n+        \"\"\"Adds a reminder and invalidates the user's cache.\"\"\"\n         reminder_id = await self.reminderdb.add_reminder(\n             user_id, utcdue, content, add_user=add_user)\n         self.cache.pop(user_id, None)\n","add":2,"remove":2,"filename":"\/bot\/commands\/reminders.py","badparts":["    async def add_reminder(self, user_id, utcdue, content, add_user=False):","        \"Adds a reminder and invalidates the user's cache.\""],"goodparts":["    async def add_reminder(self, user_id, utcdue, content, add_user=True):","        \"\"\"Adds a reminder and invalidates the user's cache.\"\"\""]},{"diff":"\n                 return await self.send_with_disclaimer(\n                     ctx,\n                     'Could not understand your reminder request. Check this '\n-                    \"command's help page for allowed syntax.\"\n+                    \"command's help page for allowed syntax.\",\n+                    delete_after=6\n                 )\n \n             if td.total_seconds() < 30:\n                 return await self.send_with_disclaimer(\n                     ctx, 'You must set a reminder lasting for at '\n-                    'least 30 seconds!')\n+                    'least 30 seconds.', delete_after=6)\n             elif not content:\n                 return await self.send_with_disclaimer(\n-                    ctx, 'You must have a message with your reminder!')\n+                    ctx, 'You must have a message with your reminder.',\n+                    delete_after=6\n+                )\n \n             # Round seconds down if td does not specify seconds\n             if td.seconds % 60 == 0:\n","add":6,"remove":3,"filename":"\/bot\/commands\/reminders.py","badparts":["                    \"command's help page for allowed syntax.\"","                    'least 30 seconds!')","                    ctx, 'You must have a message with your reminder!')"],"goodparts":["                    \"command's help page for allowed syntax.\",","                    delete_after=6","                    'least 30 seconds.', delete_after=6)","                    ctx, 'You must have a message with your reminder.',","                    delete_after=6","                )"]},{"diff":"\n             utcdue = utcnow + td\n \n             await self.add_reminder(\n-                ctx.author.id, utcdue, content,\n-                add_user=True\n+                ctx.author.id, utcdue, content\n             )\n \n             await self.send_with_disclaimer(\n","add":1,"remove":2,"filename":"\/bot\/commands\/reminders.py","badparts":["                ctx.author.id, utcdue, content,","                add_user=True"],"goodparts":["                ctx.author.id, utcdue, content"]},{"diff":"\n         else:\n             await self.send_with_disclaimer(\n                 ctx, 'Sorry, but you have reached your maximum limit '\n-                'of 5 reminders.'\n+                'of 5 reminders.', delete_after=6\n             )\n \n \n","add":1,"remove":1,"filename":"\/bot\/commands\/reminders.py","badparts":["                'of 5 reminders.'"],"goodparts":["                'of 5 reminders.', delete_after=6"]},{"diff":"\n \n         if len(reminder_list) == 0:\n             return await self.send_with_disclaimer(\n-                ctx, \"You already don't have any reminders.\")\n+                ctx, \"You already don't have any reminders.\", delete_after=6)\n \n         try:\n             reminder = reminder_list[index - 1]\n         except IndexError:\n             await self.send_with_disclaimer(\n-                ctx, 'That reminder index does not exist.')\n+                ctx, 'That reminder index does not exist.', delete_after=6)\n         else:\n             await self.delete_reminder_by_id(reminder['reminder_id'])\n             await self.send_with_disclaimer(\n","add":2,"remove":2,"filename":"\/bot\/commands\/reminders.py","badparts":["                ctx, \"You already don't have any reminders.\")","                ctx, 'That reminder index does not exist.')"],"goodparts":["                ctx, \"You already don't have any reminders.\", delete_after=6)","                ctx, 'That reminder index does not exist.', delete_after=6)"]},{"diff":"\n \n         if len(reminder_list) == 0:\n             return await self.send_with_disclaimer(\n-                ctx, \"You already don't have any reminders.\")\n+                ctx, \"You already don't have any reminders.\", delete_after=6)\n \n         if indices.lower() == 'all':\n             for reminder in reminder_list:\n                 await self.delete_reminder_by_id(reminder['reminder_id'])\n             await self.send_with_disclaimer(\n-                ctx, 'Reminders successfully deleted!')\n+                ctx, 'Reminders successfully deleted!', delete_after=6)\n \n         else:\n             start, end = [int(n) for n in indices.split('-')]\n             start -= 1\n             if start < 0:\n                 return await self.send_with_disclaimer(\n-                    ctx, 'Start must be 1 or greater.')\n+                    ctx, 'Start must be 1 or greater.', delete_after=6)\n             elif end > len(reminder_list):\n                 return await self.send_with_disclaimer(\n-                    ctx, f'End must only go up to {len(reminder_list)}.')\n+                    ctx, f'End must only go up to {len(reminder_list)}.',\n+                    delete_after=6)\n \n             for i in range(start, end):\n                 reminder = reminder_list[i]\n","add":5,"remove":4,"filename":"\/bot\/commands\/reminders.py","badparts":["                ctx, \"You already don't have any reminders.\")","                ctx, 'Reminders successfully deleted!')","                    ctx, 'Start must be 1 or greater.')","                    ctx, f'End must only go up to {len(reminder_list)}.')"],"goodparts":["                ctx, \"You already don't have any reminders.\", delete_after=6)","                ctx, 'Reminders successfully deleted!', delete_after=6)","                    ctx, 'Start must be 1 or greater.', delete_after=6)","                    ctx, f'End must only go up to {len(reminder_list)}.',","                    delete_after=6)"]},{"diff":"\n \n         if len(reminder_list) == 0:\n             return await self.send_with_disclaimer(\n-                ctx, \"You don't have any reminders.\")\n+                ctx, \"You don't have any reminders.\", delete_after=6)\n \n         if index < 1:\n             return await self.send_with_disclaimer(\n-                ctx, 'Index must be 1 or greater.')\n+                ctx, 'Index must be 1 or greater.', delete_after=6)\n \n         try:\n             reminder = reminder_list[index - 1]\n         except IndexError:\n             await self.send_with_disclaimer(\n-                ctx, 'That index does not exist.')\n+                ctx, 'That index does not exist.', delete_after=6)\n         else:\n             utcdue = datetime.datetime.fromisoformat(reminder['due'])\n             embed = discord.Embed(\n","add":3,"remove":3,"filename":"\/bot\/commands\/reminders.py","badparts":["                ctx, \"You don't have any reminders.\")","                ctx, 'Index must be 1 or greater.')","                ctx, 'That index does not exist.')"],"goodparts":["                ctx, \"You don't have any reminders.\", delete_after=6)","                ctx, 'Index must be 1 or greater.', delete_after=6)","                ctx, 'That index does not exist.', delete_after=6)"]},{"diff":"\n \n         if len(reminder_list) == 0:\n             return await self.send_with_disclaimer(\n-                ctx, \"You don't have any reminders.\")\n+                ctx, \"You don't have any reminders.\", delete_after=6)\n \n         # Create fields for each reminder, limiting them\n         # to 140 characters\/5 lines\n         fields = [\n-            utils.truncate_message(reminder['content'], 140, size_lines=5)\n+            utils.truncate_message(reminder['content'], 140, max_lines=5)\n             for reminder in reminder_list\n         ]\n         color = utils.get_use","add":2,"remove":2,"filename":"\/bot\/commands\/reminders.py","badparts":["                ctx, \"You don't have any reminders.\")","            utils.truncate_message(reminder['content'], 140, size_lines=5)"],"goodparts":["                ctx, \"You don't have any reminders.\", delete_after=6)","            utils.truncate_message(reminder['content'], 140, max_lines=5)"]}],"source":"\n\"\"\" Note: This requires members intent to be enabled in order to send reminders.\"\"\" import asyncio import datetime import textwrap import discord from discord.ext import commands, tasks import inflect from bot import utils from bot.classes.timeobj import parse_timedelta from bot.database import ReminderDatabase, DATABASE_USERS from bot.other import discordlogger inflector=inflect.engine() class Reminders(commands.Cog): qualified_name='Reminders' description='Commands for setting up reminders.' send_reminders_near_due=datetime.timedelta(minutes=11) def __init__(self, bot): self.bot=bot self.reminderdb=ReminderDatabase(DATABASE_USERS) self.cache={} if self.bot.intents.members: self.send_reminders_tasks={} self.send_reminders.start() else: self.description +=('\\n**NOTE**: The bot currently ' 'cannot send reminders at this time.') def cog_unload(self): self.send_reminders.cancel() async def add_reminder(self, user_id, utcdue, content, add_user=False): \"Adds a reminder and invalidates the user's cache.\" reminder_id=await self.reminderdb.add_reminder( user_id, utcdue, content, add_user=add_user) self.cache.pop(user_id, None) utcnow=datetime.datetime.utcnow() if utcdue -utcnow < self.send_reminders_near_due: self.check_to_create_reminder( reminder_id, user_id, content, utcdue) async def delete_reminder_by_id(self, reminder_id, pop=False): \"Remove a reminder by reminder_id and update the caches.\" deleted=await self.reminderdb.delete_reminder_by_id( reminder_id, pop=True) updated_ids=frozenset(reminder['user_id'] for reminder in deleted) updated_reminders=[reminder['reminder_id'] for reminder in deleted] for user_id in updated_ids: user=self.cache.pop(user_id, None) if user is not None: discordlogger.get_logger().info( f'Reminders: Invalidated user cache, ID{user_id}') for reminder_id in updated_reminders: task=self.send_reminders_tasks.pop(reminder_id, None) if task is not None: discordlogger.get_logger().info( f'Reminders: Removed reminder task, ID{reminder_id}') if pop: return deleted async def get_reminders(self, user_id): reminders=self.cache.get(user_id) if reminders is None: reminders=await self.reminderdb.get_reminders(user_id) self.cache[user_id]=reminders return reminders async def send_with_disclaimer( self, messageable, content=None, *args, **kwargs): if content is not None and not self.bot.intents.members: content +=('\\nNote: the bot currently cannot send ' 'reminders at this time.') return await messageable.send(content, *args, **kwargs) @commands.command( name='addreminder', aliases=['remindme']) @commands.cooldown(2, 15, commands.BucketType.user) async def client_addreminder(self, ctx, *, time_and_reminder): \"\"\"Add a reminder. Usage: <command> at 10pm <x>(time in UTC) <command> in 10 sec\/min\/h\/days <x> <command> on wednesday <x>(checks the current day in UTC) Reminders will appear in your DMs. Time is rounded down to the minute if seconds are not specified. You can have a maximum of 5 reminders.\"\"\" await ctx.channel.trigger_typing() total_reminders=len(await self.get_reminders(ctx.author.id)) if total_reminders < 5: utcnow=datetime.datetime.utcnow().replace(microsecond=0) try: td, content=parse_timedelta(time_and_reminder, utcnow) except ValueError: return await self.send_with_disclaimer( ctx, 'Could not understand your reminder request. Check this ' \"command's help page for allowed syntax.\" ) if td.total_seconds() < 30: return await self.send_with_disclaimer( ctx, 'You must set a reminder lasting for at ' 'least 30 seconds!') elif not content: return await self.send_with_disclaimer( ctx, 'You must have a message with your reminder!') if td.seconds % 60==0: utcnow=utcnow.replace(second=0) utcdue=utcnow +td await self.add_reminder( ctx.author.id, utcdue, content, add_user=True ) await self.send_with_disclaimer( ctx, 'Your{} reminder has been added!'.format( inflector.ordinal(total_reminders +1) ), embed=discord.Embed( color=utils.get_user_color(ctx.author), timestamp=utcdue ) ) else: await self.send_with_disclaimer( ctx, 'Sorry, but you have reached your maximum limit ' 'of 5 reminders.' ) @commands.command(name='removereminder') @commands.cooldown(2, 5, commands.BucketType.user) async def client_removereminder(self, ctx, index: int): \"\"\"Remove a reminder. To see a list of your reminders and their indices, use the showreminders command. To remove several reminders, use the removereminders command.\"\"\" await ctx.channel.trigger_typing() reminder_list=await self.get_reminders(ctx.author.id) if len(reminder_list)==0: return await self.send_with_disclaimer( ctx, \"You already don't have any reminders.\") try: reminder=reminder_list[index -1] except IndexError: await self.send_with_disclaimer( ctx, 'That reminder index does not exist.') else: await self.delete_reminder_by_id(reminder['reminder_id']) await self.send_with_disclaimer( ctx, 'Reminder successfully deleted!') @commands.command(name='removereminders') @commands.cooldown(1, 5, commands.BucketType.user) async def client_removereminders(self, ctx, indices): \"\"\"Remove multiple reminders. You can remove \"all\" of your reminders or remove only a section of it by specifying the start and end indices(\"1-4\"). To remove only one reminder, use the removereminder command.\"\"\" await ctx.channel.trigger_typing() reminder_list=await self.get_reminders(ctx.author.id) if len(reminder_list)==0: return await self.send_with_disclaimer( ctx, \"You already don't have any reminders.\") if indices.lower()=='all': for reminder in reminder_list: await self.delete_reminder_by_id(reminder['reminder_id']) await self.send_with_disclaimer( ctx, 'Reminders successfully deleted!') else: start, end=[int(n) for n in indices.split('-')] start -=1 if start < 0: return await self.send_with_disclaimer( ctx, 'Start must be 1 or greater.') elif end > len(reminder_list): return await self.send_with_disclaimer( ctx, f'End must only go up to{len(reminder_list)}.') for i in range(start, end): reminder=reminder_list[i] await self.delete_reminder_by_id(reminder['reminder_id']) await self.send_with_disclaimer( ctx, 'Reminders successfully deleted!') @commands.command(name='showreminder') @commands.cooldown(2, 5, commands.BucketType.user) async def client_showreminder(self, ctx, index: int): \"\"\"Show one of your reminders.\"\"\" await ctx.channel.trigger_typing() reminder_list=await self.get_reminders(ctx.author.id) if len(reminder_list)==0: return await self.send_with_disclaimer( ctx, \"You don't have any reminders.\") if index < 1: return await self.send_with_disclaimer( ctx, 'Index must be 1 or greater.') try: reminder=reminder_list[index -1] except IndexError: await self.send_with_disclaimer( ctx, 'That index does not exist.') else: utcdue=datetime.datetime.fromisoformat(reminder['due']) embed=discord.Embed( title=f'Reminder description=reminder['content'], color=utils.get_user_color(ctx.author), timestamp=utcdue ).add_field( name='Due in', value=utils.timedelta_string( utils.datetime_difference( utcdue, datetime.datetime.utcnow() ) ) ).set_footer(text='Due date') await self.send_with_disclaimer(ctx, embed=embed) @commands.command(name='showreminders') @commands.cooldown(1, 15, commands.BucketType.user) @commands.max_concurrency(1, commands.BucketType.channel, wait=True) async def client_showreminders(self, ctx): \"\"\"Show all of your reminders.\"\"\" await ctx.channel.trigger_typing() reminder_list=await self.get_reminders(ctx.author.id) if len(reminder_list)==0: return await self.send_with_disclaimer( ctx, \"You don't have any reminders.\") fields=[ utils.truncate_message(reminder['content'], 140, size_lines=5) for reminder in reminder_list ] color=utils.get_user_color(ctx.author) embed=discord.Embed( title=f\"{ctx.author.display_name}'s Reminders\", color=color, timestamp=datetime.datetime.now().astimezone() ) for i, content in enumerate(fields, start=1): embed.add_field(name=f'Reminder{i:,}', value=content) await self.send_with_disclaimer(ctx, embed=embed) def check_to_create_reminder( self, reminder_id, user_id, content, utcwhen, utcnow=None): \"\"\"Create a reminder task if needed. This does not store the reminder in the database. Returns: bool: Indicates whether the task was created or not. \"\"\" if not self.bot.intents.members: return False if utcnow is None: utcnow=datetime.datetime.utcnow() td=utcwhen -utcnow zero_td=datetime.timedelta() if reminder_id in self.send_reminders_tasks: return False if td < zero_td: self.create_reminder_task( reminder_id, user_id, utcwhen, zero_td, content) return True elif td < self.send_reminders_near_due: self.create_reminder_task( reminder_id, user_id, utcwhen, td, content) return True def create_reminder_task(self, reminder_id, user_id, utcwhen, td, content): \"\"\"Adds a reminder task to the bot loop and logs it.\"\"\" task=self.bot.loop.create_task( self.reminder_coro(reminder_id, user_id, utcwhen, td, content) ) self.send_reminders_tasks[reminder_id]=task discordlogger.get_logger().info( f'Reminders: created reminder task for{user_id}, due in{td}') return task async def reminder_coro(self, reminder_id, user_id, utcwhen, td, content): \"\"\"Schedules a reminder to be sent to the user.\"\"\" async def remove_entry(): await self.delete_reminder_by_id(reminder_id) def remove_task(): self.send_reminders_tasks.pop(reminder_id, None) def log_and_print(message): discordlogger.get_logger().info(message) print(message) seconds=td.total_seconds() await asyncio.sleep(seconds) if await self.reminderdb.get_one( 'Reminders', where=f'reminder_id={reminder_id}') is None: return user=self.bot.get_user(user_id) if user is None: log_and_print( f'Reminders: failed to send reminder, ID{reminder_id}: ' f'could not find user:{user_id}' ) await remove_entry() remove_task() return if seconds==0: title=f'Late reminder for{utcwhen.strftime(\"%c UTC\")}' else: title=f'Reminder for{utcwhen.strftime(\"%c UTC\")}' embed=discord.Embed( title=title, description=content, color=utils.get_user_color(user), timestamp=datetime.datetime.now().astimezone() ) try: await user.send(embed=embed) except discord.HTTPException as e: log_and_print( f'Reminders: failed to send reminder, ID{reminder_id}: ' f'HTTPException occurred:{e}' ) except discord.Forbidden as e: log_and_print( f'Reminders: failed to send reminder, ID{reminder_id}: ' f'was forbidden from sending:{e}' ) else: discordlogger.get_logger().info( f'Reminders: successfully sent reminder, ID{reminder_id}') await remove_entry() finally: remove_task() @tasks.loop(minutes=10) async def send_reminders(self): \"\"\"Periodically queries the database for reminders and spins up reminder tasks as needed. \"\"\" utcnow=datetime.datetime.utcnow() async for entry in self.reminderdb.yield_rows('Reminders'): utcwhen=datetime.datetime.fromisoformat(entry['due']) self.check_to_create_reminder( entry['reminder_id'], entry['user_id'], entry['content'], utcwhen, utcnow ) @send_reminders.before_loop async def before_send_reminders(self): await self.bot.wait_until_ready() def setup(bot): bot.add_cog(Reminders(bot)) ","sourceWithComments":"\"\"\"\nNote: This requires members intent to be enabled in order to send reminders.\"\"\"\nimport asyncio\nimport datetime\nimport textwrap\n\nimport discord\nfrom discord.ext import commands, tasks\nimport inflect\n\nfrom bot import utils\nfrom bot.classes.timeobj import parse_timedelta\nfrom bot.database import ReminderDatabase, DATABASE_USERS\nfrom bot.other import discordlogger\n\ninflector = inflect.engine()\n\n\nclass Reminders(commands.Cog):\n    qualified_name = 'Reminders'\n    description = 'Commands for setting up reminders.'\n\n    send_reminders_near_due = datetime.timedelta(minutes=11)\n    # NOTE: should be just a bit longer than task loop\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.reminderdb = ReminderDatabase(DATABASE_USERS)\n        self.cache = {}  # user_id: reminders\n        # NOTE: this bot is small so this isn't required but if the bot\n        # never restarts frequently, the cache could grow forever,\n        # so this could use an LRU cache implementation\n        if self.bot.intents.members:\n            # Only send reminders when members intent is enabled\n            self.send_reminders_tasks = {}  # reminder_id: Task\n            self.send_reminders.start()\n        else:\n            self.description += ('\\n**NOTE**: The bot currently '\n                                 'cannot send reminders at this time.')\n\n    def cog_unload(self):\n        self.send_reminders.cancel()\n\n\n\n\n\n    async def add_reminder(self, user_id, utcdue, content, add_user=False):\n        \"Adds a reminder and invalidates the user's cache.\"\n        reminder_id = await self.reminderdb.add_reminder(\n            user_id, utcdue, content, add_user=add_user)\n        self.cache.pop(user_id, None)\n\n        utcnow = datetime.datetime.utcnow()\n\n        if utcdue - utcnow < self.send_reminders_near_due:\n            # Reminder executes soon; spin up task\n            self.check_to_create_reminder(\n                reminder_id, user_id, content, utcdue)\n\n    async def delete_reminder_by_id(self, reminder_id, pop=False):\n        \"Remove a reminder by reminder_id and update the caches.\"\n        deleted = await self.reminderdb.delete_reminder_by_id(\n            reminder_id, pop=True)\n\n        updated_ids = frozenset(reminder['user_id'] for reminder in deleted)\n        updated_reminders = [reminder['reminder_id'] for reminder in deleted]\n\n        for user_id in updated_ids:\n            user = self.cache.pop(user_id, None)\n            if user is not None:\n                discordlogger.get_logger().info(\n                    f'Reminders: Invalidated user cache, ID {user_id}')\n        for reminder_id in updated_reminders:\n            task = self.send_reminders_tasks.pop(reminder_id, None)\n            if task is not None:\n                discordlogger.get_logger().info(\n                    f'Reminders: Removed reminder task, ID {reminder_id}')\n\n        if pop:\n            return deleted\n\n    async def get_reminders(self, user_id):\n        reminders = self.cache.get(user_id)\n\n        if reminders is None:\n            # Uncached user; add them to cache\n            reminders = await self.reminderdb.get_reminders(user_id)\n            self.cache[user_id] = reminders\n\n        return reminders\n\n    async def send_with_disclaimer(\n            self, messageable, content=None, *args, **kwargs):\n        if content is not None and not self.bot.intents.members:\n            content += ('\\nNote: the bot currently cannot send '\n                        'reminders at this time.')\n\n        return await messageable.send(content, *args, **kwargs)\n\n\n\n\n\n    @commands.command(\n        name='addreminder',\n        aliases=['remindme'])\n    @commands.cooldown(2, 15, commands.BucketType.user)\n    async def client_addreminder(self, ctx, *, time_and_reminder):\n        \"\"\"Add a reminder.\n\nUsage:\n    <command> at 10pm <x> (time in UTC)\n    <command> in 10 sec\/min\/h\/days <x>\n    <command> on wednesday <x> (checks the current day in UTC)\n\nReminders will appear in your DMs.\nTime is rounded down to the minute if seconds are not specified.\nYou can have a maximum of 5 reminders.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        total_reminders = len(await self.get_reminders(ctx.author.id))\n\n        if total_reminders < 5:\n            # Get current time in UTC without microseconds\n            utcnow = datetime.datetime.utcnow().replace(microsecond=0)\n            try:\n                td, content = parse_timedelta(time_and_reminder, utcnow)\n            except ValueError:\n                return await self.send_with_disclaimer(\n                    ctx,\n                    'Could not understand your reminder request. Check this '\n                    \"command's help page for allowed syntax.\"\n                )\n\n            if td.total_seconds() < 30:\n                return await self.send_with_disclaimer(\n                    ctx, 'You must set a reminder lasting for at '\n                    'least 30 seconds!')\n            elif not content:\n                return await self.send_with_disclaimer(\n                    ctx, 'You must have a message with your reminder!')\n\n            # Round seconds down if td does not specify seconds\n            if td.seconds % 60 == 0:\n                utcnow = utcnow.replace(second=0)\n\n            utcdue = utcnow + td\n\n            await self.add_reminder(\n                ctx.author.id, utcdue, content,\n                add_user=True\n            )\n\n            await self.send_with_disclaimer(\n                ctx, 'Your {} reminder has been added!'.format(\n                    inflector.ordinal(total_reminders + 1)\n                ),\n                embed=discord.Embed(\n                    color=utils.get_user_color(ctx.author),\n                    timestamp=utcdue\n                )\n            )\n        else:\n            await self.send_with_disclaimer(\n                ctx, 'Sorry, but you have reached your maximum limit '\n                'of 5 reminders.'\n            )\n\n\n\n\n    @commands.command(name='removereminder')\n    @commands.cooldown(2, 5, commands.BucketType.user)\n    async def client_removereminder(self, ctx, index: int):\n        \"\"\"Remove a reminder.\n\nTo see a list of your reminders and their indices, use the showreminders command.\nTo remove several reminders, use the removereminders command.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        reminder_list = await self.get_reminders(ctx.author.id)\n\n        if len(reminder_list) == 0:\n            return await self.send_with_disclaimer(\n                ctx, \"You already don't have any reminders.\")\n\n        try:\n            reminder = reminder_list[index - 1]\n        except IndexError:\n            await self.send_with_disclaimer(\n                ctx, 'That reminder index does not exist.')\n        else:\n            await self.delete_reminder_by_id(reminder['reminder_id'])\n            await self.send_with_disclaimer(\n                ctx, 'Reminder successfully deleted!')\n\n\n\n\n\n    @commands.command(name='removereminders')\n    @commands.cooldown(1, 5, commands.BucketType.user)\n    async def client_removereminders(self, ctx, indices):\n        \"\"\"Remove multiple reminders.\n\nYou can remove \"all\" of your reminders or remove only a section of it by specifying the start and end indices (\"1-4\").\nTo remove only one reminder, use the removereminder command.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        reminder_list = await self.get_reminders(ctx.author.id)\n\n        if len(reminder_list) == 0:\n            return await self.send_with_disclaimer(\n                ctx, \"You already don't have any reminders.\")\n\n        if indices.lower() == 'all':\n            for reminder in reminder_list:\n                await self.delete_reminder_by_id(reminder['reminder_id'])\n            await self.send_with_disclaimer(\n                ctx, 'Reminders successfully deleted!')\n\n        else:\n            start, end = [int(n) for n in indices.split('-')]\n            start -= 1\n            if start < 0:\n                return await self.send_with_disclaimer(\n                    ctx, 'Start must be 1 or greater.')\n            elif end > len(reminder_list):\n                return await self.send_with_disclaimer(\n                    ctx, f'End must only go up to {len(reminder_list)}.')\n\n            for i in range(start, end):\n                reminder = reminder_list[i]\n                await self.delete_reminder_by_id(reminder['reminder_id'])\n            await self.send_with_disclaimer(\n                ctx, 'Reminders successfully deleted!')\n\n\n\n\n\n    @commands.command(name='showreminder')\n    @commands.cooldown(2, 5, commands.BucketType.user)\n    async def client_showreminder(self, ctx, index: int):\n        \"\"\"Show one of your reminders.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        reminder_list = await self.get_reminders(ctx.author.id)\n\n        if len(reminder_list) == 0:\n            return await self.send_with_disclaimer(\n                ctx, \"You don't have any reminders.\")\n\n        if index < 1:\n            return await self.send_with_disclaimer(\n                ctx, 'Index must be 1 or greater.')\n\n        try:\n            reminder = reminder_list[index - 1]\n        except IndexError:\n            await self.send_with_disclaimer(\n                ctx, 'That index does not exist.')\n        else:\n            utcdue = datetime.datetime.fromisoformat(reminder['due'])\n            embed = discord.Embed(\n                title=f'Reminder #{index:,}',\n                description=reminder['content'],\n                color=utils.get_user_color(ctx.author),\n                timestamp=utcdue\n            ).add_field(\n                name='Due in',\n                value=utils.timedelta_string(\n                    utils.datetime_difference(\n                        utcdue,\n                        datetime.datetime.utcnow()\n                    )\n                )\n            ).set_footer(text='Due date')\n            await self.send_with_disclaimer(ctx, embed=embed)\n\n\n\n\n\n    @commands.command(name='showreminders')\n    @commands.cooldown(1, 15, commands.BucketType.user)\n    @commands.max_concurrency(1, commands.BucketType.channel, wait=True)\n    async def client_showreminders(self, ctx):\n        \"\"\"Show all of your reminders.\"\"\"\n        await ctx.channel.trigger_typing()\n\n        reminder_list = await self.get_reminders(ctx.author.id)\n\n        if len(reminder_list) == 0:\n            return await self.send_with_disclaimer(\n                ctx, \"You don't have any reminders.\")\n\n        # Create fields for each reminder, limiting them\n        # to 140 characters\/5 lines\n        fields = [\n            utils.truncate_message(reminder['content'], 140, size_lines=5)\n            for reminder in reminder_list\n        ]\n        color = utils.get_user_color(ctx.author)\n\n        embed = discord.Embed(\n            title=f\"{ctx.author.display_name}'s Reminders\",\n            color=color,\n            timestamp=datetime.datetime.now().astimezone()\n        )\n\n        for i, content in enumerate(fields, start=1):\n            embed.add_field(name=f'Reminder {i:,}', value=content)\n\n        await self.send_with_disclaimer(ctx, embed=embed)\n\n\n\n\n\n    def check_to_create_reminder(\n            self, reminder_id, user_id, content, utcwhen, utcnow=None):\n        \"\"\"Create a reminder task if needed.\n\n        This does not store the reminder in the database.\n\n        Returns:\n            bool: Indicates whether the task was created or not.\n\n        \"\"\"\n        if not self.bot.intents.members:\n            # Prevents creating reminder tasks without members intent\n            # as get_user() doesn't work, meaning it's basically\n            # impossible to send DMs\n            return False\n\n        if utcnow is None:\n            utcnow = datetime.datetime.utcnow()\n\n        td = utcwhen - utcnow\n        zero_td = datetime.timedelta()\n\n        if reminder_id in self.send_reminders_tasks:\n            # Task already exists; skip\n            return False\n\n        if td < zero_td:\n            # Overdue; send message immediately\n            self.create_reminder_task(\n                reminder_id, user_id, utcwhen, zero_td, content)\n            return True\n        elif td < self.send_reminders_near_due:\n            # Close to due date; spin up task\n            self.create_reminder_task(\n                reminder_id, user_id, utcwhen, td, content)\n            return True\n\n    def create_reminder_task(self, reminder_id, user_id, utcwhen, td, content):\n        \"\"\"Adds a reminder task to the bot loop and logs it.\"\"\"\n        task = self.bot.loop.create_task(\n            self.reminder_coro(reminder_id, user_id, utcwhen, td, content)\n        )\n        self.send_reminders_tasks[reminder_id] = task\n\n        discordlogger.get_logger().info(\n            f'Reminders: created reminder task for {user_id}, due in {td}')\n\n        return task\n\n    async def reminder_coro(self, reminder_id, user_id, utcwhen, td, content):\n        \"\"\"Schedules a reminder to be sent to the user.\"\"\"\n        async def remove_entry():\n            await self.delete_reminder_by_id(reminder_id)\n\n        def remove_task():\n            self.send_reminders_tasks.pop(reminder_id, None)\n\n        def log_and_print(message):\n            discordlogger.get_logger().info(message)\n            print(message)\n\n        seconds = td.total_seconds()\n\n        await asyncio.sleep(seconds)\n\n        if await self.reminderdb.get_one(\n                'Reminders', where=f'reminder_id={reminder_id}') is None:\n            # Reminder was deleted during wait; don't send\n            return\n\n        user = self.bot.get_user(user_id)\n\n        if user is None:\n            # Could not find user; remove database entry\n            log_and_print(\n                f'Reminders: failed to send reminder, ID {reminder_id}: '\n                f'could not find user: {user_id}'\n            )\n            await remove_entry()\n            remove_task()\n            return\n\n        if seconds == 0:\n            title = f'Late reminder for {utcwhen.strftime(\"%c UTC\")}'\n        else:\n            title = f'Reminder for {utcwhen.strftime(\"%c UTC\")}'\n        embed = discord.Embed(\n            title=title,\n            description=content,\n            color=utils.get_user_color(user),\n            timestamp=datetime.datetime.now().astimezone()\n        )\n\n        try:\n            await user.send(embed=embed)\n        except discord.HTTPException as e:\n            log_and_print(\n                f'Reminders: failed to send reminder, ID {reminder_id}: '\n                f'HTTPException occurred: {e}'\n            )\n        except discord.Forbidden as e:\n            log_and_print(\n                f'Reminders: failed to send reminder, ID {reminder_id}: '\n                f'was forbidden from sending: {e}'\n            )\n        else:\n            # Successful; remove reminder task and database entry\n            discordlogger.get_logger().info(\n                f'Reminders: successfully sent reminder, ID {reminder_id}')\n            await remove_entry()\n        finally:\n            remove_task()\n\n    @tasks.loop(minutes=10)\n    async def send_reminders(self):\n        \"\"\"Periodically queries the database for reminders and\n        spins up reminder tasks as needed.\n        \"\"\"\n        utcnow = datetime.datetime.utcnow()\n\n        async for entry in self.reminderdb.yield_rows('Reminders'):\n            utcwhen = datetime.datetime.fromisoformat(entry['due'])\n\n            self.check_to_create_reminder(\n                entry['reminder_id'], entry['user_id'],\n                entry['content'], utcwhen, utcnow\n            )\n\n    @send_reminders.before_loop\n    async def before_send_reminders(self):\n        await self.bot.wait_until_ready()\n\n\n\n\n\n\n\n\n\n\ndef setup(bot):\n    bot.add_cog(Reminders(bot))\n"},"\/bot\/commands\/undefined.py":{"changes":[{"diff":"\n import asyncio\n import calendar\n-import collections\n-from concurrent.futures import ThreadPoolExecutor\n-import csv\n-import json\n-import math\n import random\n import time\n-import typing\n+from typing import Union\n \n import discord\n from discord.ext import commands\n-import inflect\n \n-from bot import checks\n-from bot import settings\n+from bot.classes.confirmation import AdaptiveConfirmation\n+from bot.database import GuildDatabase\n from bot import utils\n \n-inflector = inflect.engine()\n-\n WORDLIST_PATH = 'data\/wordlist.txt'\n \n # goodday command\n","add":3,"remove":11,"filename":"\/bot\/commands\/undefined.py","badparts":["import collections","from concurrent.futures import ThreadPoolExecutor","import csv","import json","import math","import typing","import inflect","from bot import checks","from bot import settings","inflector = inflect.engine()"],"goodparts":["from typing import Union","from bot.classes.confirmation import AdaptiveConfirmation","from bot.database import GuildDatabase"]},{"diff":"\n \n \n-# phasmophobia commands\n-class Ghost:\n-    __slots__ = ('name', 'evidences', 'url')\n-\n-    def __init__(self, name, evidences, url):\n-        self.name = name\n-        self.evidences = evidences\n-        self.url = url\n-\n-\n-GHOST_EVIDENCE = [\n-    Ghost('Banshee',\n-          ('EMF Level 5', 'Fingerprints', 'Freezing Temperatures'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Banshee'),\n-    Ghost('Demon',\n-          ('Freezing Temperatures', 'Ghost Writing', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Demon'),\n-    Ghost('Jinn',\n-          ('EMF Level 5', 'Ghost Orb', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Jinn'),\n-    Ghost('Mare',\n-          ('Freezing Temperatures', 'Ghost Orb', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Mare'),\n-    Ghost('Oni',\n-          ('EMF Level 5', 'Ghost Writing', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Oni'),\n-    Ghost('Phantom',\n-          ('EMF Level 5', 'Freezing Temperatures', 'Ghost Orb'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Phantom'),\n-    Ghost('Poltergeist',\n-          ('Fingerprints', 'Ghost Orb', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Poltergeist'),\n-    Ghost('Revenant',\n-          ('EMF Level 5', 'Fingerprints', 'Ghost Writing'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Revenant'),\n-    Ghost('Shade',\n-          ('EMF Level 5', 'Ghost Orb', 'Ghost Writing'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Shade'),\n-    Ghost('Spirit',\n-          ('Fingerprints', 'Ghost Writing', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Spirit'),\n-    Ghost('Wraith',\n-          ('Fingerprints', 'Freezing Temperatures', 'Spirit Box'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Wraith'),\n-    Ghost('Yurei',\n-          ('Freezing Temperatures', 'Ghost Orb', 'Ghost Writing'),\n-          'https:\/\/phasmophobia.fandom.com\/wiki\/Yurei')\n-]\n-EVIDENCES = [\n-    'EMF Level 5', 'Freezing Temperatures', 'Fingerprints',\n-    'Ghost Orb', 'Ghost Writing', 'Spirit Box'\n-]\n-\n-\n-def phasmophobia_match_ghost_evidence(evidences):\n-    possible_ghosts = GHOST_EVIDENCE\n-\n-    for e in evidences:\n-        new_ghosts = []\n-\n-        for g in possible_ghosts:\n-            if e.lower() in [gev.lower() for gev in g.evidences]:\n-                new_ghosts.append(g)\n-\n-        possible_ghosts = new_ghosts\n-\n-        if len(possible_ghosts) == 0:\n-            return possible_ghosts\n-\n-    return possible_ghosts\n-\n-\n-# unturned commands\n-class UnturnedItem:\n-    __slots__ = ('id', 'name', 'rarity', 'url', 'dimensions', 'recipe_data')\n-\n-    def __init__(self, id_, name, rarity, url, dimensions, recipe_data):\n-        self.id = id_\n-        self.name = name\n-        self.rarity = rarity\n-        self.url = url\n-        self.dimensions = dimensions\n-        self.recipe_data = recipe_data\n-\n-    def __repr__(self):\n-        return '{}({!r}, {!r})'.format(\n-            self.__class__.__name__,\n-            self.id,\n-            self.name\n-        )\n-\n-\n-class UnturnedDatabase:\n-    UNTURNED_ITEM_IDS_PATH = 'data\/unturned_item_ids.csv'\n-    UNTURNED_ITEM_RECIPES_PATH = 'data\/unturned_recipes.json'\n-\n-    def __init__(self, items):\n-        self.items = items\n-\n-    @classmethod\n-    def _get_items_from_files(cls):\n-        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:\n-            recipes = json.load(f)\n-\n-        items = {}\n-        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:\n-            reader = csv.reader(f)\n-            header = next(reader)\n-            for id_, name, rarity, url in reader:\n-                rec = recipes.get(id_)\n-                dimensions = rec['dimensions'] if rec else None\n-                recipe_data = (\n-                    {'primitive': rec['primitive'],\n-                     'recipes': rec['recipes']}\n-                    if rec else None\n-                )\n-                id_ = int(id_)\n-                items[id_] = UnturnedItem(\n-                    id_, name, rarity, url, dimensions, recipe_data)\n-\n-        return items\n-\n-    @classmethod\n-    async def _get_items_from_files_nonblocking(cls):\n-        executor = ThreadPoolExecutor()\n-        loop = asyncio.get_running_loop()\n-\n-        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:\n-            recipes = json.loads(await loop.run_in_executor(executor, f.read))\n-\n-        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:\n-            raw_lines = await loop.run_in_executor(executor, f.readlines)\n-\n-        items = {}\n-        reader = csv.reader(raw_lines)\n-        next(reader)  # skip header\n-\n-        for ID, name, rarity, url in reader:\n-            rec = recipes.get(ID)\n-            dimensions = rec['dimensions'] if rec else None\n-            recipe_data = (\n-                {'primitive': rec['primitive'],\n-                 'recipes': rec['recipes']}\n-                if rec else None\n-            )\n-\n-            ID = int(ID)\n-            items[ID] = UnturnedItem(ID, name, rarity, url,\n-                                     dimensions, recipe_data)\n-\n-        return items\n-\n-    def reload_items(self):\n-        \"\"\"Regenerate self.items from the data files.\"\"\"\n-        self.items = self._get_items_from_files()\n-\n-    async def reload_items_nonblocking(self):\n-        \"\"\"Regenerate self.items from the data files.\n-        Uses a thread pool to read files.\"\"\"\n-        self.items = await self._get_items_from_files_nonblocking()\n-\n-    def unturned_get_item(self, search):\n-        \"\"\"Search for an item from UNTURNED_ITEM_IDS either by name or ID.\n-\n-        Returns:\n-            List[UnturnedItem]: multiple matches were found.\n-            None: no matches were found.\n-            UnturnedItem: the search term matches one item.\n-\n-        \"\"\"\n-        def get_item_by_name(name):\n-            result = discord.utils.get(self.items.values(), name=name)\n-            if result is None:\n-                raise ValueError(f'Could not find an item with that name.')\n-            return result\n-\n-        # Search by ID\n-        try:\n-            item_id = int(search)\n-        except ValueError:\n-            pass\n-        else:\n-            return self.items.get(item_id)\n-\n-        # Search by name\n-        result = utils.fuzzy_match_word(\n-            search, tuple(entry.name for entry in self.items.values()),\n-            return_possible=True\n-        )\n-\n-        if isinstance(result, str):\n-            return get_item_by_name(result)\n-        elif isinstance(result, collections.abc.Iterable):\n-            return [get_item_by_name(name) for name in result]\n-        elif result is None:\n-            return\n-\n-    @classmethod\n-    def from_files(cls):\n-        return cls(cls._get_items_from_files())\n+# upsidedown text command\n+# sources: https:\/\/www.upsidedowntext.com\/unicode\n+#          https:\/\/text-symbols.com\/upside-down\/\n+UPSIDEDOWN_MAPPING = {\n+    'a': '\u0250', 'b': 'q', 'c': '\u0254', 'd': 'p', 'e': '\u01dd',\n+    'f': '\u025f', 'g': '\u0183', 'h': '\u0265', 'i': '\u1d09', 'j': '\u027e',\n+    'k': '\u029e', 'l': 'l', 'm': '\u026f', 'n': 'u', 'o': 'o',\n+    'p': 'd', 'q': 'b', 'r': '\u0279', 's': 's', 't': '\u0287',\n+    'u': 'n', 'v': '\u028c', 'w': '\u028d', 'x': 'x', 'y': '\u028e',\n+    'z': 'z', 'A': '\u2200', 'B': '\ua4ed', 'C': '\u0186', 'D': '\u15e1',\n+    'E': '\u018e', 'F': '\u2132', 'G': '\u05e4', 'H': 'H', 'I': 'I',\n+    'J': '\u148b', 'K': '\ua4d8', 'L': '\u2142', 'M': 'W', 'N': 'N',\n+    'O': 'O', 'P': '\u0500', 'Q': '\ua779', 'R': '\ua4e4', 'S': 'S',\n+    'T': '\ua4d5', 'U': '\u2229', 'V': '\u0245', 'W': 'M', 'X': 'X',\n+    'Y': '\u2144', 'Z': 'Z', '0': '0', '1': '\u21c2', '2': '\u218a',\n+    '3': '\u0190', '4': '\u07e4', '5': '\u03db', '6': '9', '7': '\ud835\ude13',\n+    '8': '9', '9': '6', '\"': ',,', \"'\": ',', '`': ',',\n+    '(': ')', ')': '(', '[': ']', ']': '[', '{': '}',\n+    '}': '{', '<': '>', '>': '<', '&': '\u214b', '_': '\u203e',\n+    ',': '`', '.': '\u02d9', '!': '\u00a1', '?': '\u00bf'\n+}\n \n \n # dmtest\/test command\n","add":21,"remove":200,"filename":"\/bot\/commands\/undefined.py","badparts":["class Ghost:","    __slots__ = ('name', 'evidences', 'url')","    def __init__(self, name, evidences, url):","        self.name = name","        self.evidences = evidences","        self.url = url","GHOST_EVIDENCE = [","    Ghost('Banshee',","          ('EMF Level 5', 'Fingerprints', 'Freezing Temperatures'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Banshee'),","    Ghost('Demon',","          ('Freezing Temperatures', 'Ghost Writing', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Demon'),","    Ghost('Jinn',","          ('EMF Level 5', 'Ghost Orb', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Jinn'),","    Ghost('Mare',","          ('Freezing Temperatures', 'Ghost Orb', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Mare'),","    Ghost('Oni',","          ('EMF Level 5', 'Ghost Writing', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Oni'),","    Ghost('Phantom',","          ('EMF Level 5', 'Freezing Temperatures', 'Ghost Orb'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Phantom'),","    Ghost('Poltergeist',","          ('Fingerprints', 'Ghost Orb', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Poltergeist'),","    Ghost('Revenant',","          ('EMF Level 5', 'Fingerprints', 'Ghost Writing'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Revenant'),","    Ghost('Shade',","          ('EMF Level 5', 'Ghost Orb', 'Ghost Writing'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Shade'),","    Ghost('Spirit',","          ('Fingerprints', 'Ghost Writing', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Spirit'),","    Ghost('Wraith',","          ('Fingerprints', 'Freezing Temperatures', 'Spirit Box'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Wraith'),","    Ghost('Yurei',","          ('Freezing Temperatures', 'Ghost Orb', 'Ghost Writing'),","          'https:\/\/phasmophobia.fandom.com\/wiki\/Yurei')","]","EVIDENCES = [","    'EMF Level 5', 'Freezing Temperatures', 'Fingerprints',","    'Ghost Orb', 'Ghost Writing', 'Spirit Box'","]","def phasmophobia_match_ghost_evidence(evidences):","    possible_ghosts = GHOST_EVIDENCE","    for e in evidences:","        new_ghosts = []","        for g in possible_ghosts:","            if e.lower() in [gev.lower() for gev in g.evidences]:","                new_ghosts.append(g)","        possible_ghosts = new_ghosts","        if len(possible_ghosts) == 0:","            return possible_ghosts","    return possible_ghosts","class UnturnedItem:","    __slots__ = ('id', 'name', 'rarity', 'url', 'dimensions', 'recipe_data')","    def __init__(self, id_, name, rarity, url, dimensions, recipe_data):","        self.id = id_","        self.name = name","        self.rarity = rarity","        self.url = url","        self.dimensions = dimensions","        self.recipe_data = recipe_data","    def __repr__(self):","        return '{}({!r}, {!r})'.format(","            self.__class__.__name__,","            self.id,","            self.name","        )","class UnturnedDatabase:","    UNTURNED_ITEM_IDS_PATH = 'data\/unturned_item_ids.csv'","    UNTURNED_ITEM_RECIPES_PATH = 'data\/unturned_recipes.json'","    def __init__(self, items):","        self.items = items","    @classmethod","    def _get_items_from_files(cls):","        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:","            recipes = json.load(f)","        items = {}","        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:","            reader = csv.reader(f)","            header = next(reader)","            for id_, name, rarity, url in reader:","                rec = recipes.get(id_)","                dimensions = rec['dimensions'] if rec else None","                recipe_data = (","                    {'primitive': rec['primitive'],","                     'recipes': rec['recipes']}","                    if rec else None","                )","                id_ = int(id_)","                items[id_] = UnturnedItem(","                    id_, name, rarity, url, dimensions, recipe_data)","        return items","    @classmethod","    async def _get_items_from_files_nonblocking(cls):","        executor = ThreadPoolExecutor()","        loop = asyncio.get_running_loop()","        with open(cls.UNTURNED_ITEM_RECIPES_PATH) as f:","            recipes = json.loads(await loop.run_in_executor(executor, f.read))","        with open(cls.UNTURNED_ITEM_IDS_PATH) as f:","            raw_lines = await loop.run_in_executor(executor, f.readlines)","        items = {}","        reader = csv.reader(raw_lines)","        next(reader)  # skip header","        for ID, name, rarity, url in reader:","            rec = recipes.get(ID)","            dimensions = rec['dimensions'] if rec else None","            recipe_data = (","                {'primitive': rec['primitive'],","                 'recipes': rec['recipes']}","                if rec else None","            )","            ID = int(ID)","            items[ID] = UnturnedItem(ID, name, rarity, url,","                                     dimensions, recipe_data)","        return items","    def reload_items(self):","        \"\"\"Regenerate self.items from the data files.\"\"\"","        self.items = self._get_items_from_files()","    async def reload_items_nonblocking(self):","        \"\"\"Regenerate self.items from the data files.","        Uses a thread pool to read files.\"\"\"","        self.items = await self._get_items_from_files_nonblocking()","    def unturned_get_item(self, search):","        \"\"\"Search for an item from UNTURNED_ITEM_IDS either by name or ID.","        Returns:","            List[UnturnedItem]: multiple matches were found.","            None: no matches were found.","            UnturnedItem: the search term matches one item.","        \"\"\"","        def get_item_by_name(name):","            result = discord.utils.get(self.items.values(), name=name)","            if result is None:","                raise ValueError(f'Could not find an item with that name.')","            return result","        try:","            item_id = int(search)","        except ValueError:","            pass","        else:","            return self.items.get(item_id)","        result = utils.fuzzy_match_word(","            search, tuple(entry.name for entry in self.items.values()),","            return_possible=True","        )","        if isinstance(result, str):","            return get_item_by_name(result)","        elif isinstance(result, collections.abc.Iterable):","            return [get_item_by_name(name) for name in result]","        elif result is None:","            return","    @classmethod","    def from_files(cls):","        return cls(cls._get_items_from_files())"],"goodparts":["UPSIDEDOWN_MAPPING = {","    'a': '\u0250', 'b': 'q', 'c': '\u0254', 'd': 'p', 'e': '\u01dd',","    'f': '\u025f', 'g': '\u0183', 'h': '\u0265', 'i': '\u1d09', 'j': '\u027e',","    'k': '\u029e', 'l': 'l', 'm': '\u026f', 'n': 'u', 'o': 'o',","    'p': 'd', 'q': 'b', 'r': '\u0279', 's': 's', 't': '\u0287',","    'u': 'n', 'v': '\u028c', 'w': '\u028d', 'x': 'x', 'y': '\u028e',","    'z': 'z', 'A': '\u2200', 'B': '\ua4ed', 'C': '\u0186', 'D': '\u15e1',","    'E': '\u018e', 'F': '\u2132', 'G': '\u05e4', 'H': 'H', 'I': 'I',","    'J': '\u148b', 'K': '\ua4d8', 'L': '\u2142', 'M': 'W', 'N': 'N',","    'O': 'O', 'P': '\u0500', 'Q': '\ua779', 'R': '\ua4e4', 'S': 'S',","    'T': '\ua4d5', 'U': '\u2229', 'V': '\u0245', 'W': 'M', 'X': 'X',","    'Y': '\u2144', 'Z': 'Z', '0': '0', '1': '\u21c2', '2': '\u218a',","    '3': '\u0190', '4': '\u07e4', '5': '\u03db', '6': '9', '7': '\ud835\ude13',","    '8': '9', '9': '6', '\"': ',,', \"'\": ',', '`': ',',","    '(': ')', ')': '(', '[': ']', ']': '[', '{': '}',","    '}': '{', '<': '>', '>': '<', '&': '\u214b', '_': '\u203e',","    ',': '`', '.': '\u02d9', '!': '\u00a1', '?': '\u00bf'","}"]},{"diff":"\n \n \n class Undefined(commands.Cog):\n+    \"\"\"Uncategorized commands.\"\"\"\n     qualified_name = 'Undefined'\n-    description = 'Uncategorized commands.'\n \n     def __init__(self, bot):\n         self.bot = bot\n-        self.unturneddb = UnturnedDatabase.from_files()\n+        self.guilddb = GuildDatabase\n \n \n \n","add":2,"remove":2,"filename":"\/bot\/commands\/undefined.py","badparts":["    description = 'Uncategorized commands.'","        self.unturneddb = UnturnedDatabase.from_files()"],"goodparts":["    \"\"\"Uncategorized commands.\"\"\"","        self.guilddb = GuildDatabase"]}]},"\/bot\/database\/__init__.py":{"changes":[{"diff":"\n from .database import Database\n-from .dbsetup import DATABASE_IRISH, DATABASE_USERS, get_prefix, setup\n-from .irishdatabase import IrishDatabase\n-from .notedatabase import NoteDatabase\n-from .prefixdatabase import PrefixDatabase\n-from .reminderdatabase import ReminderDatabase\n-from .userdatabase import UserDatabase\n+from .dbsetup import (\n+    DATABASE_IRISH, DATABASE_USERS,\n+    GameDatabase, GuildDatabase, IrishDatabase, NoteDatabase, PrefixDatabase,\n+    ReminderDatabase, UserDatabase, get_prefix, setup\n+)\n+from . import gamedatabase\n+from . import guilddatabase\n+from . import irishdatabase\n+from . import notedatabase\n+from . import prefixdatabase\n+from . import reminderdatabase\n+fro","add":12,"remove":6,"filename":"\/bot\/database\/__init__.py","badparts":["from .dbsetup import DATABASE_IRISH, DATABASE_USERS, get_prefix, setup","from .irishdatabase import IrishDatabase","from .notedatabase import NoteDatabase","from .prefixdatabase import PrefixDatabase","from .reminderdatabase import ReminderDatabase","from .userdatabase import UserDatabase"],"goodparts":["from .dbsetup import (","    DATABASE_IRISH, DATABASE_USERS,","    GameDatabase, GuildDatabase, IrishDatabase, NoteDatabase, PrefixDatabase,","    ReminderDatabase, UserDatabase, get_prefix, setup",")","from . import gamedatabase","from . import guilddatabase","from . import irishdatabase","from . import notedatabase","from . import prefixdatabase","from . import reminderdatabase","fro"]}],"source":"\nfrom.database import Database from.dbsetup import DATABASE_IRISH, DATABASE_USERS, get_prefix, setup from.irishdatabase import IrishDatabase from.notedatabase import NoteDatabase from.prefixdatabase import PrefixDatabase from.reminderdatabase import ReminderDatabase from.userdatabase import UserDatabase ","sourceWithComments":"from .database import Database\nfrom .dbsetup import DATABASE_IRISH, DATABASE_USERS, get_prefix, setup\nfrom .irishdatabase import IrishDatabase\nfrom .notedatabase import NoteDatabase\nfrom .prefixdatabase import PrefixDatabase\nfrom .reminderdatabase import ReminderDatabase\nfrom .userdatabase import UserDatabase\n"},"\/bot\/database\/database.py":{"changes":[{"diff":"\n import aiosqlite\n \n \n-class Singleton(type):\n-    # https:\/\/stackoverflow.com\/q\/6760685\n-    _instances = {}\n-    def __call__(cls, *args, **kwargs):\n-        if cls not in cls._instances:\n-            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n-        return cls._instances[cls]\n-\n-\n-class Database(metaclass=Singleton):\n+class Database:\n     \"\"\"Provide a higher-level interface to a database.\n \n     Methods:\n         add_row(table, row)\n         delete_rows(table, *, where)\n-        get_rows(table, *columns, where=None, as_Row=True)\n+        get_one(table, *, where, as_row=True)\n+        get_rows(table, *, where, as_row=True)\n         update_rows(table, row, *, where)\n+        yield_rows(table, *, where)\n \n         vacuum()\n \n         row_to_dict(Row)\n \n     \"\"\"\n-    # FIXME: using Singleton is probably a dumb way of making sure\n-    # caches of subclasses are preserved across instantiations;\n-    # why not just have dbsetup create all the instances?\n     __slots__ = ['path', 'last_change']\n \n     PRAGMAS = 'PRAGMA foreign_keys = 1'\n \n     def __init__(self, path):\n-        \"\"\"Create a Database with a path to a given sqlite db file.\"\"\"\n         self.path = path\n         self.set_last_change(datetime.datetime.now(), table=None)\n \n","add":4,"remove":15,"filename":"\/bot\/database\/database.py","badparts":["class Singleton(type):","    _instances = {}","    def __call__(cls, *args, **kwargs):","        if cls not in cls._instances:","            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)","        return cls._instances[cls]","class Database(metaclass=Singleton):","        get_rows(table, *columns, where=None, as_Row=True)","        \"\"\"Create a Database with a path to a given sqlite db file.\"\"\""],"goodparts":["class Database:","        get_one(table, *, where, as_row=True)","        get_rows(table, *, where, as_row=True)","        yield_rows(table, *, where)"]},{"diff":"\n         if pop:\n             return rows\n \n-    async def get_one(self, table: str, *, where: str = '1', as_Row=True):\n+    async def get_one(self, table: str, *, where: str = '1', as_row=True):\n         \"\"\"Get one row from a table.\n \n-        If as_Row, rows will be returned as aiosqlite.Row objects.\n+        If as_row, rows will be returned as aiosqlite.Row objects.\n         Otherwise, rows are returned as tuples.\n \n         Returns:\n","add":2,"remove":2,"filename":"\/bot\/database\/database.py","badparts":["    async def get_one(self, table: str, *, where: str = '1', as_Row=True):","        If as_Row, rows will be returned as aiosqlite.Row objects."],"goodparts":["    async def get_one(self, table: str, *, where: str = '1', as_row=True):","        If as_row, rows will be returned as aiosqlite.Row objects."]},{"diff":"\n         \"\"\"\n         async with aiosqlite.connect(self.path) as db:\n             await db.execute(self.PRAGMAS)\n-            if as_Row:\n+            if as_row:\n                 db.row_factory = aiosqlite.Row\n \n             c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n","add":1,"remove":1,"filename":"\/bot\/database\/database.py","badparts":["            if as_Row:"],"goodparts":["            if as_row:"]},{"diff":"\n \n         return row\n \n-    async def get_rows(self, table: str, *, where: str = '1', as_Row=True):\n+    async def get_rows(self, table: str, *, where: str = '1', as_row=True):\n         \"\"\"Get a list of rows from a table.\n \n         Args:\n","add":1,"remove":1,"filename":"\/bot\/database\/database.py","badparts":["    async def get_rows(self, table: str, *, where: str = '1', as_Row=True):"],"goodparts":["    async def get_rows(self, table: str, *, where: str = '1', as_row=True):"]},{"diff":"\n             where (Optional[str]):\n                 An optional parameter specifying a condition.\n                 By default, returns all rows in the table.\n-            as_Row (bool):\n+            as_row (bool):\n                 If True, rows will be returned as aiosqlite.Row objects.\n                 Otherwise, rows are returned as tuples.\n \n","add":1,"remove":1,"filename":"\/bot\/database\/database.py","badparts":["            as_Row (bool):"],"goodparts":["            as_row (bool):"]},{"diff":"\n         \"\"\"\n         async with aiosqlite.connect(self.path) as db:\n             await db.execute(self.PRAGMAS)\n-            if as_Row:\n+            if as_row:\n                 db.row_factory = aiosqlite.Row\n \n             c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n","add":1,"remove":1,"filename":"\/bot\/database\/database.py","badparts":["            if as_Row:"],"goodparts":["            if as_row:"]},{"diff":"\n         return rows\n \n     async def update_rows(self, table: str, row: dict, *, where: str):\n-        \"Update one or more rows in a table.\"\n+        \"\"\"Update one or more rows in a table.\"\"\"\n \n         def create_placeholders(row: dict) -> (str, list):\n             \"\"\"Create the placeholders for setting keys.\n","add":1,"remove":1,"filename":"\/bot\/database\/database.py","badparts":["        \"Update one or more rows in a table.\""],"goodparts":["        \"\"\"Update one or more rows in a table.\"\"\""]},{"diff":"\n \n         self.set_last_change(datetime.datetime.now(), table)\n \n+    async def vacuum(self):\n+        \"\"\"Vacuum the database.\"\"\"\n+        async with aiosqlite.connect(self.path) as db:\n+            await db.execute('VACUUM')\n+\n     async def yield_rows(\n-            self, table: str, *, where: str = '1', as_Row=True):\n+            self, table: str, *, where: str = '1', as_row=True):\n         \"\"\"Yield a list of rows from a table.\n \n         Args:\n","add":6,"remove":1,"filename":"\/bot\/database\/database.py","badparts":["            self, table: str, *, where: str = '1', as_Row=True):"],"goodparts":["    async def vacuum(self):","        \"\"\"Vacuum the database.\"\"\"","        async with aiosqlite.connect(self.path) as db:","            await db.execute('VACUUM')","            self, table: str, *, where: str = '1', as_row=True):"]},{"diff":"\n             where (Optional[str]):\n                 An optional parameter specifying a condition.\n                 By default, yields all rows in the table.\n-            as_Row (bool):\n+            as_row (bool):\n                 If True, rows will be returned as aiosqlite.Row objects.\n                 Otherwise, rows are returned as tuples.\n \n","add":1,"remove":1,"filename":"\/bot\/database\/database.py","badparts":["            as_Row (bool):"],"goodparts":["            as_row (bool):"]},{"diff":"\n         \"\"\"\n         async with aiosqlite.connect(self.path) as db:\n             await db.execute(self.PRAGMAS)\n-            if as_Row:\n+            if as_row:\n                 db.row_factory = aiosqlite.Row\n \n             c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n","add":1,"remove":1,"filename":"\/bot\/database\/database.py","badparts":["            if as_Row:"],"goodparts":["            if as_row:"]},{"diff":"\n             await c.close()\n \n     @staticmethod\n-    def row_to_dict(Row):\n-        \"Convert an aiosqlite.Row into a dictionary.\"\n+    def row_to_dict(row):\n+        \"\"\"Convert an aiosqlite.Row into a dictionary.\"\"\"\n         d = {}\n-        for k, v in zip(Row.keys(), Row):\n+        for k, v in zip(row.keys(), row):\n             d[","add":3,"remove":3,"filename":"\/bot\/database\/database.py","badparts":["    def row_to_dict(Row):","        \"Convert an aiosqlite.Row into a dictionary.\"","        for k, v in zip(Row.keys(), Row):"],"goodparts":["    def row_to_dict(row):","        \"\"\"Convert an aiosqlite.Row into a dictionary.\"\"\"","        for k, v in zip(row.keys(), row):"]}],"source":"\nimport datetime import aiosqlite class Singleton(type): _instances={} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls]=super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class Database(metaclass=Singleton): \"\"\"Provide a higher-level interface to a database. Methods: add_row(table, row) delete_rows(table, *, where) get_rows(table, *columns, where=None, as_Row=True) update_rows(table, row, *, where) vacuum() row_to_dict(Row) \"\"\" __slots__=['path', 'last_change'] PRAGMAS='PRAGMA foreign_keys=1' def __init__(self, path): \"\"\"Create a Database with a path to a given sqlite db file.\"\"\" self.path=path self.set_last_change(datetime.datetime.now(), table=None) def __repr__(self): return '{}({!r})'.format(self.__class__.__name__, self.path) def set_last_change(self, when, table): self.last_change={ 'when': when, 'table': table } async def add_row(self, table: str, row: dict): \"\"\"Add a row to a table. Returns the last row id that was added. \"\"\" def create_keys(row: dict) ->(str, str, list): \"\"\"Return the column placeholders and values for a row. NOTE: Designed to work without using the insertion order invariant of dict since Python 3.6. \"\"\" placeholders=', '.join(['?'] * len(row)) keys, values=[],[] for k, v in row.items(): keys.append(k) values.append(v) keys=', '.join(keys) return keys, placeholders, values keys, placeholders, values=create_keys(row) async with aiosqlite.connect(self.path) as db: await db.execute(self.PRAGMAS) c=await db.cursor() await c.execute( f'INSERT INTO{table}({keys}) VALUES({placeholders})', values ) last_row_id=c.lastrowid await db.commit() self.set_last_change(datetime.datetime.now(), table) return last_row_id async def delete_rows(self, table: str, *, where: str, pop=False): \"\"\"Delete one or more rows from a table. Args: table(str) where(str) pop(bool): If True, gets the rows and returns them before deleting the rows. Returns: None List[aiosqlite.Row]: A list of deleted entries if pop is True. \"\"\" if pop: rows=await self.get_rows(table, where=where) async with aiosqlite.connect(self.path) as db: await db.execute(self.PRAGMAS) await db.execute(f'DELETE FROM{table} WHERE{where}') await db.commit() self.set_last_change(datetime.datetime.now(), table) if pop: return rows async def get_one(self, table: str, *, where: str='1', as_Row=True): \"\"\"Get one row from a table. If as_Row, rows will be returned as aiosqlite.Row objects. Otherwise, rows are returned as tuples. Returns: aiosqlite.Row tuple None: if no row is found. \"\"\" async with aiosqlite.connect(self.path) as db: await db.execute(self.PRAGMAS) if as_Row: db.row_factory=aiosqlite.Row c=await db.execute(f'SELECT * FROM{table} WHERE{where}') row=await c.fetchone() await c.close() return row async def get_rows(self, table: str, *, where: str='1', as_Row=True): \"\"\"Get a list of rows from a table. Args: table(str) where(Optional[str]): An optional parameter specifying a condition. By default, returns all rows in the table. as_Row(bool): If True, rows will be returned as aiosqlite.Row objects. Otherwise, rows are returned as tuples. Returns: List[aiosqlite.Row] List[tuple] \"\"\" async with aiosqlite.connect(self.path) as db: await db.execute(self.PRAGMAS) if as_Row: db.row_factory=aiosqlite.Row c=await db.execute(f'SELECT * FROM{table} WHERE{where}') rows=await c.fetchall() await c.close() return rows async def update_rows(self, table: str, row: dict, *, where: str): \"Update one or more rows in a table.\" def create_placeholders(row: dict) ->(str, list): \"\"\"Create the placeholders for setting keys. NOTE: Designed to work without using the insertion order invariant of dict since Python 3.6. \"\"\" keys, values=[],[] for k, v in row.items(): keys.append(k) values.append(v) keys=', '.join([f'{k}=?' for k in row]) return keys, values keys, values=create_placeholders(row) async with aiosqlite.connect(self.path) as db: await db.execute(self.PRAGMAS) await db.execute( f'UPDATE{table} SET{keys} WHERE{where}', values ) await db.commit() self.set_last_change(datetime.datetime.now(), table) async def yield_rows( self, table: str, *, where: str='1', as_Row=True): \"\"\"Yield a list of rows from a table. Args: table(str) where(Optional[str]): An optional parameter specifying a condition. By default, yields all rows in the table. as_Row(bool): If True, rows will be returned as aiosqlite.Row objects. Otherwise, rows are returned as tuples. Yields: List[aiosqlite.Row] List[tuple] \"\"\" async with aiosqlite.connect(self.path) as db: await db.execute(self.PRAGMAS) if as_Row: db.row_factory=aiosqlite.Row c=await db.execute(f'SELECT * FROM{table} WHERE{where}') async for row in c: yield row await c.close() @staticmethod def row_to_dict(Row): \"Convert an aiosqlite.Row into a dictionary.\" d={} for k, v in zip(Row.keys(), Row): d[k]=v return d ","sourceWithComments":"import datetime\n\nimport aiosqlite\n\n\nclass Singleton(type):\n    # https:\/\/stackoverflow.com\/q\/6760685\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n\nclass Database(metaclass=Singleton):\n    \"\"\"Provide a higher-level interface to a database.\n\n    Methods:\n        add_row(table, row)\n        delete_rows(table, *, where)\n        get_rows(table, *columns, where=None, as_Row=True)\n        update_rows(table, row, *, where)\n\n        vacuum()\n\n        row_to_dict(Row)\n\n    \"\"\"\n    # FIXME: using Singleton is probably a dumb way of making sure\n    # caches of subclasses are preserved across instantiations;\n    # why not just have dbsetup create all the instances?\n    __slots__ = ['path', 'last_change']\n\n    PRAGMAS = 'PRAGMA foreign_keys = 1'\n\n    def __init__(self, path):\n        \"\"\"Create a Database with a path to a given sqlite db file.\"\"\"\n        self.path = path\n        self.set_last_change(datetime.datetime.now(), table=None)\n\n    def __repr__(self):\n        return '{}({!r})'.format(self.__class__.__name__, self.path)\n\n    def set_last_change(self, when, table):\n        self.last_change = {\n            'when': when,\n            'table': table\n        }\n\n    async def add_row(self, table: str, row: dict):\n        \"\"\"Add a row to a table.\n\n        Returns the last row id that was added.\n\n        \"\"\"\n        def create_keys(row: dict) -> (str, str, list):\n            \"\"\"Return the column placeholders and values for a row.\n\n            NOTE: Designed to work without using the insertion order\n            invariant of dict since Python 3.6.\n\n            \"\"\"\n            placeholders = ', '.join(['?'] * len(row))\n            keys, values = [], []\n            for k, v in row.items():\n                keys.append(k)\n                values.append(v)\n            keys = ', '.join(keys)\n            return keys, placeholders, values\n\n        keys, placeholders, values = create_keys(row)\n        async with aiosqlite.connect(self.path) as db:\n            await db.execute(self.PRAGMAS)\n            c = await db.cursor()\n            await c.execute(\n                f'INSERT INTO {table} ({keys}) VALUES ({placeholders})',\n                values\n            )\n            last_row_id = c.lastrowid\n            await db.commit()\n\n        self.set_last_change(datetime.datetime.now(), table)\n\n        return last_row_id\n\n    async def delete_rows(self, table: str, *, where: str, pop=False):\n        \"\"\"Delete one or more rows from a table.\n\n        Args:\n            table (str)\n            where (str)\n            pop (bool):\n                If True, gets the rows and returns them before\n                deleting the rows.\n\n        Returns:\n            None\n            List[aiosqlite.Row]: A list of deleted entries if pop is True.\n\n        \"\"\"\n        if pop:\n            rows = await self.get_rows(table, where=where)\n\n        async with aiosqlite.connect(self.path) as db:\n            await db.execute(self.PRAGMAS)\n            await db.execute(f'DELETE FROM {table} WHERE {where}')\n            await db.commit()\n\n        self.set_last_change(datetime.datetime.now(), table)\n\n        if pop:\n            return rows\n\n    async def get_one(self, table: str, *, where: str = '1', as_Row=True):\n        \"\"\"Get one row from a table.\n\n        If as_Row, rows will be returned as aiosqlite.Row objects.\n        Otherwise, rows are returned as tuples.\n\n        Returns:\n            aiosqlite.Row\n            tuple\n            None: if no row is found.\n\n        \"\"\"\n        async with aiosqlite.connect(self.path) as db:\n            await db.execute(self.PRAGMAS)\n            if as_Row:\n                db.row_factory = aiosqlite.Row\n\n            c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n\n            row = await c.fetchone()\n            await c.close()\n\n        return row\n\n    async def get_rows(self, table: str, *, where: str = '1', as_Row=True):\n        \"\"\"Get a list of rows from a table.\n\n        Args:\n            table (str)\n            where (Optional[str]):\n                An optional parameter specifying a condition.\n                By default, returns all rows in the table.\n            as_Row (bool):\n                If True, rows will be returned as aiosqlite.Row objects.\n                Otherwise, rows are returned as tuples.\n\n        Returns:\n            List[aiosqlite.Row]\n            List[tuple]\n\n        \"\"\"\n        async with aiosqlite.connect(self.path) as db:\n            await db.execute(self.PRAGMAS)\n            if as_Row:\n                db.row_factory = aiosqlite.Row\n\n            c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n\n            rows = await c.fetchall()\n            await c.close()\n        return rows\n\n    async def update_rows(self, table: str, row: dict, *, where: str):\n        \"Update one or more rows in a table.\"\n\n        def create_placeholders(row: dict) -> (str, list):\n            \"\"\"Create the placeholders for setting keys.\n\n            NOTE: Designed to work without using the insertion order\n            invariant of dict since Python 3.6.\n\n            \"\"\"\n            keys, values = [], []\n            for k, v in row.items():\n                keys.append(k)\n                values.append(v)\n            keys = ', '.join([f'{k}=?' for k in row])\n            return keys, values\n\n        keys, values = create_placeholders(row)\n        async with aiosqlite.connect(self.path) as db:\n            await db.execute(self.PRAGMAS)\n            await db.execute(\n                f'UPDATE {table} SET {keys} WHERE {where}',\n                values\n            )\n            await db.commit()\n\n        self.set_last_change(datetime.datetime.now(), table)\n\n    async def yield_rows(\n            self, table: str, *, where: str = '1', as_Row=True):\n        \"\"\"Yield a list of rows from a table.\n\n        Args:\n            table (str)\n            where (Optional[str]):\n                An optional parameter specifying a condition.\n                By default, yields all rows in the table.\n            as_Row (bool):\n                If True, rows will be returned as aiosqlite.Row objects.\n                Otherwise, rows are returned as tuples.\n\n        Yields:\n            List[aiosqlite.Row]\n            List[tuple]\n\n        \"\"\"\n        async with aiosqlite.connect(self.path) as db:\n            await db.execute(self.PRAGMAS)\n            if as_Row:\n                db.row_factory = aiosqlite.Row\n\n            c = await db.execute(f'SELECT * FROM {table} WHERE {where}')\n\n            async for row in c:\n                yield row\n            await c.close()\n\n    @staticmethod\n    def row_to_dict(Row):\n        \"Convert an aiosqlite.Row into a dictionary.\"\n        d = {}\n        for k, v in zip(Row.keys(), Row):\n            d[k] = v\n        return d\n"},"\/bot\/database\/dbsetup.py":{"changes":[{"diff":"\n         commands.Bot(command_prefix=get_prefix())\n \n     \"\"\"\n-    db = prefixdatabase.PrefixDatabase(DATABASE_USERS)\n-\n     async def inner(bot, message):\n         guild = message.guild\n \n-        # If in DMs, get default prefix or use prefix-less invokation\n+        # If in DMs, get default prefix\n         if guild is None:\n             return commands.when_mentioned_or(\n                 settings.get_setting('default_prefix')\n","add":1,"remove":3,"filename":"\/bot\/database\/dbsetup.py","badparts":["    db = prefixdatabase.PrefixDatabase(DATABASE_USERS)"],"goodparts":[]},{"diff":"\n \n         # Else, fetch guild prefix\n         guild_id = guild.id\n-        await db.add_prefix(guild_id, add_guild=True)\n-        prefix = await db.get_prefix(guild_id)\n+        await PrefixDatabase.add_prefix(guild_id, add_guild=True)\n+        prefix = await PrefixDatabase.get_prefix(guild_id)\n \n         if prefix is not None:\n             return commands.when_mentioned_or(prefix)(bot, message)\n","add":2,"remove":2,"filename":"\/bot\/database\/dbsetup.py","badparts":["        await db.add_prefix(guild_id, add_guild=True)","        prefix = await db.get_prefix(guild_id)"],"goodparts":["        await PrefixDatabase.add_prefix(guild_id, add_guild=True)","        prefix = await PrefixDatabase.get_prefix(guild_id)"]},{"diff":"\n \n def setup_database_users(connection):\n     \"Setup the tables for the Users database.\"\n-    userdatabase.setup(connection)\n-    notedatabase.setup(connection)\n-    reminderdatabase.setup(connection)\n-    print('Verified user database')\n-    guilddatabase.setup(connection)\n-    prefixdatabase.setup(connection)\n-    print('Verified guild database')\n+    with utils.update_text('Verifying user database',\n+                           'Verified user database'):\n+        userdatabase.setup(connection)\n+        notedatabase.setup(connection)\n+        reminderdatabase.setup(connection)\n+        gamedatabase.setup(connection)\n+    with utils.update_text('Verifying guild database',\n+                           'Verified guild database'):\n+        guilddatabase.setup(connection)\n+        prefixdatabase.setup(connection)\n \n \n-def setup_database_guild_specific():\n-    irishdatabase.setup(sqlite3.connect(DATABASE_IRISH))\n-    print('Verified guild-specific databases')\n+def setup_database_guild_specific(connection):\n+    with utils.update_text('Verifying guild-specific databases',\n+                           'Verified guild-specific databases'):\n+        irishdatabase.setup(connection)\n \n \n def setup():\n     setup_database_users(sqlite3.connect(DATABASE_USERS))\n-    setup_database_guild_specific()\n+    setup_database_guild_specific(sqlite3","add":15,"remove":11,"filename":"\/bot\/database\/dbsetup.py","badparts":["    userdatabase.setup(connection)","    notedatabase.setup(connection)","    reminderdatabase.setup(connection)","    print('Verified user database')","    guilddatabase.setup(connection)","    prefixdatabase.setup(connection)","    print('Verified guild database')","def setup_database_guild_specific():","    irishdatabase.setup(sqlite3.connect(DATABASE_IRISH))","    print('Verified guild-specific databases')","    setup_database_guild_specific()"],"goodparts":["    with utils.update_text('Verifying user database',","                           'Verified user database'):","        userdatabase.setup(connection)","        notedatabase.setup(connection)","        reminderdatabase.setup(connection)","        gamedatabase.setup(connection)","    with utils.update_text('Verifying guild database',","                           'Verified guild database'):","        guilddatabase.setup(connection)","        prefixdatabase.setup(connection)","def setup_database_guild_specific(connection):","    with utils.update_text('Verifying guild-specific databases',","                           'Verified guild-specific databases'):","        irishdatabase.setup(connection)","    setup_database_guild_specific(sqlite3"]}],"source":"\n\"\"\"Provides functions for setting up the bot's databases.\"\"\" import asyncio import sqlite3 from discord.ext import commands from. import database from. import guilddatabase from. import irishdatabase from. import notedatabase from. import prefixdatabase from. import reminderdatabase from. import userdatabase from bot import settings DATABASE_USERS='.\/data\/userdb.db' DATABASE_IRISH='.\/data\/irishdb.db' def get_prefix(): \"\"\"Return a function for getting the bot prefix. Should be used in bot.command_prefix. This also allows mentioning the bot. Usage: commands.Bot(command_prefix=get_prefix()) \"\"\" db=prefixdatabase.PrefixDatabase(DATABASE_USERS) async def inner(bot, message): guild=message.guild if guild is None: return commands.when_mentioned_or( settings.get_setting('default_prefix') )(bot, message) guild_id=guild.id await db.add_prefix(guild_id, add_guild=True) prefix=await db.get_prefix(guild_id) if prefix is not None: return commands.when_mentioned_or(prefix)(bot, message) return commands.when_mentioned(bot, message) return inner def setup_database_users(connection): \"Setup the tables for the Users database.\" userdatabase.setup(connection) notedatabase.setup(connection) reminderdatabase.setup(connection) print('Verified user database') guilddatabase.setup(connection) prefixdatabase.setup(connection) print('Verified guild database') def setup_database_guild_specific(): irishdatabase.setup(sqlite3.connect(DATABASE_IRISH)) print('Verified guild-specific databases') def setup(): setup_database_users(sqlite3.connect(DATABASE_USERS)) setup_database_guild_specific() ","sourceWithComments":"\"\"\"Provides functions for setting up the bot's databases.\"\"\"\nimport asyncio\nimport sqlite3\n\nfrom discord.ext import commands\n\nfrom . import database\nfrom . import guilddatabase\nfrom . import irishdatabase\nfrom . import notedatabase\nfrom . import prefixdatabase\nfrom . import reminderdatabase\nfrom . import userdatabase\nfrom bot import settings\n\nDATABASE_USERS = '.\/data\/userdb.db'\nDATABASE_IRISH = '.\/data\/irishdb.db'\n\n\ndef get_prefix():\n    \"\"\"Return a function for getting the bot prefix.\n    Should be used in bot.command_prefix.\n\n    This also allows mentioning the bot.\n\n    Usage:\n        commands.Bot(command_prefix=get_prefix())\n\n    \"\"\"\n    db = prefixdatabase.PrefixDatabase(DATABASE_USERS)\n\n    async def inner(bot, message):\n        guild = message.guild\n\n        # If in DMs, get default prefix or use prefix-less invokation\n        if guild is None:\n            return commands.when_mentioned_or(\n                settings.get_setting('default_prefix')\n            )(bot, message)\n\n        # Else, fetch guild prefix\n        guild_id = guild.id\n        await db.add_prefix(guild_id, add_guild=True)\n        prefix = await db.get_prefix(guild_id)\n\n        if prefix is not None:\n            return commands.when_mentioned_or(prefix)(bot, message)\n        return commands.when_mentioned(bot, message)\n\n    return inner\n\n\ndef setup_database_users(connection):\n    \"Setup the tables for the Users database.\"\n    userdatabase.setup(connection)\n    notedatabase.setup(connection)\n    reminderdatabase.setup(connection)\n    print('Verified user database')\n    guilddatabase.setup(connection)\n    prefixdatabase.setup(connection)\n    print('Verified guild database')\n\n\ndef setup_database_guild_specific():\n    irishdatabase.setup(sqlite3.connect(DATABASE_IRISH))\n    print('Verified guild-specific databases')\n\n\ndef setup():\n    setup_database_users(sqlite3.connect(DATABASE_USERS))\n    setup_database_guild_specific()\n"},"\/bot\/database\/guilddatabase.py":{"changes":[{"diff":"\n \n \n class GuildDatabase(db.Database):\n-    \"Provide an interface to a database with a guilds table.\"\n+    \"\"\"Provide an interface to a database with a guilds table.\"\"\"\n \n     async def has_guild(self, guild_id: int):\n-        \"Test if a guild_id exists in the database.\"\n+        \"\"\"Test if a guild_id exists in the database.\"\"\"\n+        guild_id = int(guild_id)\n+\n         return await self.get_guild(guild_id) is not None\n \n     async def add_guild(self, guild_id: int):\n","add":4,"remove":2,"filename":"\/bot\/database\/guilddatabase.py","badparts":["    \"Provide an interface to a database with a guilds table.\"","        \"Test if a guild_id exists in the database.\""],"goodparts":["    \"\"\"Provide an interface to a database with a guilds table.\"\"\"","        \"\"\"Test if a guild_id exists in the database.\"\"\"","        guild_id = int(guild_id)"]},{"diff":"\n         guild_id is not escaped.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         if not await self.has_guild(guild_id):\n             return await self.add_row('Guilds', {'id': guild_id})\n \n-    async def get_guild(self, guild_id: int, *, as_Row=True):\n+    async def get_guild(self, guild_id: int, *, as_row=True):\n         \"\"\"Get a guild record from the database.\n \n         If the guild is not found, returns None.\n","add":3,"remove":1,"filename":"\/bot\/database\/guilddatabase.py","badparts":["    async def get_guild(self, guild_id: int, *, as_Row=True):"],"goodparts":["        guild_id = int(guild_id)","    async def get_guild(self, guild_id: int, *, as_row=True):"]},{"diff":"\n         guild_id is not escaped.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         return await self.get_one(\n-            'Guilds', where=f'id={guild_id}', as_Row=as_Row)\n+            'Guilds', where=f'id={guild_id}', as_row=as_row)\n \n     async def remove_guild(self, guild_id: int):\n         \"\"\"Remove a guild from the database.\n","add":3,"remove":1,"filename":"\/bot\/database\/guilddatabase.py","badparts":["            'Guilds', where=f'id={guild_id}', as_Row=as_Row)"],"goodparts":["        guild_id = int(guild_id)","            'Guilds', where=f'id={guild_id}', as_row=as_row)"]},{"diff":"\n         guild_id is not escaped.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         await self.delete_rows('Guilds', where=f'id={guild_id}')\n \n \n def setup(connection):\n-    \"Set up the guilds table for a sqlite3 connection.\"\n+    \"\"\"Set up the guilds table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n        ","add":3,"remove":1,"filename":"\/bot\/database\/guilddatabase.py","badparts":["    \"Set up the guilds table for a sqlite3 connection.\""],"goodparts":["        guild_id = int(guild_id)","    \"\"\"Set up the guilds table with a sqlite3 connection.\"\"\""]}],"source":"\n\"\"\"A database for storing guild IDs. Table dependencies: None \"\"\" from. import database as db TABLE_GUILDS=\"\"\" CREATE TABLE IF NOT EXISTS Guilds( id INTEGER UNIQUE NOT NULL PRIMARY KEY ); \"\"\" class GuildDatabase(db.Database): \"Provide an interface to a database with a guilds table.\" async def has_guild(self, guild_id: int): \"Test if a guild_id exists in the database.\" return await self.get_guild(guild_id) is not None async def add_guild(self, guild_id: int): \"\"\"Add a guild to the database if the guild does not exist. guild_id is not escaped. \"\"\" if not await self.has_guild(guild_id): return await self.add_row('Guilds',{'id': guild_id}) async def get_guild(self, guild_id: int, *, as_Row=True): \"\"\"Get a guild record from the database. If the guild is not found, returns None. guild_id is not escaped. \"\"\" return await self.get_one( 'Guilds', where=f'id={guild_id}', as_Row=as_Row) async def remove_guild(self, guild_id: int): \"\"\"Remove a guild from the database. guild_id is not escaped. \"\"\" await self.delete_rows('Guilds', where=f'id={guild_id}') def setup(connection): \"Set up the guilds table for a sqlite3 connection.\" with connection as conn: conn.execute(TABLE_GUILDS) ","sourceWithComments":"\"\"\"A database for storing guild IDs.\n\nTable dependencies:\n    None\n\"\"\"\nfrom . import database as db\n\nTABLE_GUILDS = \"\"\"\nCREATE TABLE IF NOT EXISTS Guilds (\n    id INTEGER UNIQUE\n             NOT NULL\n             PRIMARY KEY\n);\n\"\"\"\n\n\nclass GuildDatabase(db.Database):\n    \"Provide an interface to a database with a guilds table.\"\n\n    async def has_guild(self, guild_id: int):\n        \"Test if a guild_id exists in the database.\"\n        return await self.get_guild(guild_id) is not None\n\n    async def add_guild(self, guild_id: int):\n        \"\"\"Add a guild to the database if the guild does not exist.\n\n        guild_id is not escaped.\n\n        \"\"\"\n        if not await self.has_guild(guild_id):\n            return await self.add_row('Guilds', {'id': guild_id})\n\n    async def get_guild(self, guild_id: int, *, as_Row=True):\n        \"\"\"Get a guild record from the database.\n\n        If the guild is not found, returns None.\n\n        guild_id is not escaped.\n\n        \"\"\"\n        return await self.get_one(\n            'Guilds', where=f'id={guild_id}', as_Row=as_Row)\n\n    async def remove_guild(self, guild_id: int):\n        \"\"\"Remove a guild from the database.\n\n        guild_id is not escaped.\n\n        \"\"\"\n        await self.delete_rows('Guilds', where=f'id={guild_id}')\n\n\ndef setup(connection):\n    \"Set up the guilds table for a sqlite3 connection.\"\n    with connection as conn:\n        conn.execute(TABLE_GUILDS)\n"},"\/bot\/database\/irishdatabase.py":{"changes":[{"diff":"\n \n This stores its own users.\n \"\"\"\n-from . import database as db\n from . import userdatabase as user_db\n \n TABLE_USERS = \"\"\"\n","add":0,"remove":1,"filename":"\/bot\/database\/irishdatabase.py","badparts":["from . import database as db"],"goodparts":[]},{"diff":"\n     amount INTEGER NOT NULL DEFAULT 0,\n     FOREIGN KEY(user_id) REFERENCES Users(id)\n+        ON DELETE CASCADE\n )\"\"\"\n \n \n class ChargeDatabase(user_db.UserDatabase):\n     \"\"\"Provide an interface to the Charges table.\"\"\"\n \n-    async def add_charges(self, user_id: int, amount: int, *, add_user=False):\n+    async def add_charges(self, user_id: int, amount: int, *, add_user=True):\n         \"\"\"Add charges for a user.\n \n         Args:\n","add":2,"remove":1,"filename":"\/bot\/database\/irishdatabase.py","badparts":["    async def add_charges(self, user_id: int, amount: int, *, add_user=False):"],"goodparts":["        ON DELETE CASCADE","    async def add_charges(self, user_id: int, amount: int, *, add_user=True):"]},{"diff":"\n                 Otherwise, the user_id foreign key can be violated.\n \n         \"\"\"\n-        if add_user:\n-            await self.add_user(user_id)\n+        user_id = int(user_id)\n \n-        charges = await self.get_charges(user_id)\n+        charges = await self.get_charges(user_id, add_user=add_user)\n \n         return await self.update_rows(\n             'Charges',\n","add":2,"remove":3,"filename":"\/bot\/database\/irishdatabase.py","badparts":["        if add_user:","            await self.add_user(user_id)","        charges = await self.get_charges(user_id)"],"goodparts":["        user_id = int(user_id)","        charges = await self.get_charges(user_id, add_user=add_user)"]},{"diff":"\n \n     async def delete_charges(self, user_id: int):\n         \"\"\"Delete a user's charges entry.\"\"\"\n-        await self.delete_rows('Charges', where=f'note_id={note_id}')\n+        user_id = int(user_id)\n+\n+        await self.delete_rows('Charges', where=f'user_id={user_id}')\n \n     async def subtract_charges(self, user_id: int, amount: int,\n                                *, add_user=False):\n","add":3,"remove":1,"filename":"\/bot\/database\/irishdatabase.py","badparts":["        await self.delete_rows('Charges', where=f'note_id={note_id}')"],"goodparts":["        user_id = int(user_id)","        await self.delete_rows('Charges', where=f'user_id={user_id}')"]},{"diff":"\n                 Otherwise, the user_id foreign key can be violated.\n \n         \"\"\"\n-        if add_user:\n-            await self.add_user(user_id)\n+        user_id = int(user_id)\n \n-        charges = await self.get_charges(user_id)\n+        charges = await self.get_charges(user_id, add_user=add_user)\n \n         return await self.update_rows(\n             'Charges',\n","add":2,"remove":3,"filename":"\/bot\/database\/irishdatabase.py","badparts":["        if add_user:","            await self.add_user(user_id)","        charges = await self.get_charges(user_id)"],"goodparts":["        user_id = int(user_id)","        charges = await self.get_charges(user_id, add_user=add_user)"]},{"diff":"\n         \"\"\"Get the number of charges a user has.\n \n         Args:\n-            user_id (int): The id of the user to get notes from.\n+            user_id (int): The id of the user to get their number of charges.\n             add_user (bool):\n                 If True, automatically adds the user_id to the Users table.\n                 Otherwise, the user_id foreign key can be violated.\n \n         \"\"\"\n+        user_id = int(user_id)\n+\n         if add_user:\n             await self.add_user(user_id)\n \n","add":3,"remove":1,"filename":"\/bot\/database\/irishdatabase.py","badparts":["            user_id (int): The id of the user to get notes from."],"goodparts":["            user_id (int): The id of the user to get their number of charges.","        user_id = int(user_id)"]},{"diff":"\n \n \n def setup(connection):\n-    \"Set up the Users table for a sqlite3 connection.\"\n+    \"\"\"Set up the Irish Squad tables with a sqlite3 connection.\"\"\"\n     with connection as conn:\n         conn.execute(TABLE_USERS)\n        ","add":1,"remove":1,"filename":"\/bot\/database\/irishdatabase.py","badparts":["    \"Set up the Users table for a sqlite3 connection.\""],"goodparts":["    \"\"\"Set up the Irish Squad tables with a sqlite3 connection.\"\"\""]}],"source":"\n\"\"\"A database for the Irish Squad server. This stores its own users. \"\"\" from. import database as db from. import userdatabase as user_db TABLE_USERS=\"\"\" CREATE TABLE IF NOT EXISTS Users( id INTEGER UNIQUE NOT NULL PRIMARY KEY ); \"\"\" TABLE_CHARGES=\"\"\" CREATE TABLE IF NOT EXISTS Charges( user_id INTEGER NOT NULL, amount INTEGER NOT NULL DEFAULT 0, FOREIGN KEY(user_id) REFERENCES Users(id) )\"\"\" class ChargeDatabase(user_db.UserDatabase): \"\"\"Provide an interface to the Charges table.\"\"\" async def add_charges(self, user_id: int, amount: int, *, add_user=False): \"\"\"Add charges for a user. Args: user_id(int) amount(int) add_user(bool): If True, automatically adds the user_id to the Users table. Otherwise, the user_id foreign key can be violated. \"\"\" if add_user: await self.add_user(user_id) charges=await self.get_charges(user_id) return await self.update_rows( 'Charges', {'amount': charges +amount}, where=f'user_id={user_id}' ) async def delete_charges(self, user_id: int): \"\"\"Delete a user's charges entry.\"\"\" await self.delete_rows('Charges', where=f'note_id={note_id}') async def subtract_charges(self, user_id: int, amount: int, *, add_user=False): \"\"\"Subtract charges from a user. Note that this has no restraints; amount can become negative. Args: user_id(int) amount(int) add_user(bool): If True, automatically adds the user_id to the Users table. Otherwise, the user_id foreign key can be violated. \"\"\" if add_user: await self.add_user(user_id) charges=await self.get_charges(user_id) return await self.update_rows( 'Charges', {'amount': charges -amount}, where=f'user_id={user_id}' ) async def get_charges(self, user_id: int, add_user=True): \"\"\"Get the number of charges a user has. Args: user_id(int): The id of the user to get notes from. add_user(bool): If True, automatically adds the user_id to the Users table. Otherwise, the user_id foreign key can be violated. \"\"\" if add_user: await self.add_user(user_id) row=await self.get_one('Charges', where=f'user_id={user_id}') if row is None: if not await self.has_user(user_id): raise ValueError( f'User{user_id!r} does not exist in the database') else: await self.add_row('Charges',{'user_id': user_id}) row=await self.get_one('Charges', where=f'user_id={user_id}') return row['amount'] class IrishDatabase(ChargeDatabase): \"\"\"Provide an interface to the Irish Squad's database.\"\"\" def setup(connection): \"Set up the Users table for a sqlite3 connection.\" with connection as conn: conn.execute(TABLE_USERS) conn.execute(TABLE_CHARGES) ","sourceWithComments":"\"\"\"A database for the Irish Squad server.\n\nThis stores its own users.\n\"\"\"\nfrom . import database as db\nfrom . import userdatabase as user_db\n\nTABLE_USERS = \"\"\"\nCREATE TABLE IF NOT EXISTS Users (\n    id INTEGER UNIQUE\n             NOT NULL\n             PRIMARY KEY\n);\n\"\"\"\nTABLE_CHARGES = \"\"\"\nCREATE TABLE IF NOT EXISTS Charges (\n    user_id INTEGER NOT NULL,\n    amount INTEGER NOT NULL DEFAULT 0,\n    FOREIGN KEY(user_id) REFERENCES Users(id)\n)\"\"\"\n\n\nclass ChargeDatabase(user_db.UserDatabase):\n    \"\"\"Provide an interface to the Charges table.\"\"\"\n\n    async def add_charges(self, user_id: int, amount: int, *, add_user=False):\n        \"\"\"Add charges for a user.\n\n        Args:\n            user_id (int)\n            amount (int)\n            add_user (bool):\n                If True, automatically adds the user_id to the Users table.\n                Otherwise, the user_id foreign key can be violated.\n\n        \"\"\"\n        if add_user:\n            await self.add_user(user_id)\n\n        charges = await self.get_charges(user_id)\n\n        return await self.update_rows(\n            'Charges',\n            {'amount': charges + amount},\n            where=f'user_id={user_id}'\n        )\n\n    async def delete_charges(self, user_id: int):\n        \"\"\"Delete a user's charges entry.\"\"\"\n        await self.delete_rows('Charges', where=f'note_id={note_id}')\n\n    async def subtract_charges(self, user_id: int, amount: int,\n                               *, add_user=False):\n        \"\"\"Subtract charges from a user.\n\n        Note that this has no restraints; amount can become negative.\n\n        Args:\n            user_id (int)\n            amount (int)\n            add_user (bool):\n                If True, automatically adds the user_id to the Users table.\n                Otherwise, the user_id foreign key can be violated.\n\n        \"\"\"\n        if add_user:\n            await self.add_user(user_id)\n\n        charges = await self.get_charges(user_id)\n\n        return await self.update_rows(\n            'Charges',\n            {'amount': charges - amount},\n            where=f'user_id={user_id}'\n        )\n\n    async def get_charges(self, user_id: int, add_user=True):\n        \"\"\"Get the number of charges a user has.\n\n        Args:\n            user_id (int): The id of the user to get notes from.\n            add_user (bool):\n                If True, automatically adds the user_id to the Users table.\n                Otherwise, the user_id foreign key can be violated.\n\n        \"\"\"\n        if add_user:\n            await self.add_user(user_id)\n\n        row = await self.get_one('Charges', where=f'user_id={user_id}')\n        if row is None:\n            if not await self.has_user(user_id):\n                raise ValueError(\n                    f'User {user_id!r} does not exist in the database')\n            else:\n                await self.add_row('Charges', {'user_id': user_id})\n                row = await self.get_one('Charges', where=f'user_id={user_id}')\n        return row['amount']\n\n\nclass IrishDatabase(ChargeDatabase):\n    \"\"\"Provide an interface to the Irish Squad's database.\"\"\"\n\n\ndef setup(connection):\n    \"Set up the Users table for a sqlite3 connection.\"\n    with connection as conn:\n        conn.execute(TABLE_USERS)\n        conn.execute(TABLE_CHARGES)\n"},"\/bot\/database\/notedatabase.py":{"changes":[{"diff":"\n     content TEXT NOT NULL,\n     FOREIGN KEY(user_id) REFERENCES Users(id)\n+        ON DELETE CASCADE\n );\n \"\"\"\n \n \n class NoteDatabase(user_db.UserDatabase):\n-    \"Provide an interface to a UserDatabase with a Notes table.\"\n+    \"\"\"Provide an interface to a UserDatabase with a Notes table.\"\"\"\n \n-    async def add_note(self, user_id: int, time_of_entry,\n-            content: str, *, add_user=False):\n+    async def add_note(self, user_id: int, time_of_entry: datetime.datetime,\n+                       content: str, *, add_user=True):\n         \"\"\"Add a note to the Notes table.\n \n         Args:\n","add":4,"remove":3,"filename":"\/bot\/database\/notedatabase.py","badparts":["    \"Provide an interface to a UserDatabase with a Notes table.\"","    async def add_note(self, user_id: int, time_of_entry,","            content: str, *, add_user=False):"],"goodparts":["        ON DELETE CASCADE","    \"\"\"Provide an interface to a UserDatabase with a Notes table.\"\"\"","    async def add_note(self, user_id: int, time_of_entry: datetime.datetime,","                       content: str, *, add_user=True):"]},{"diff":"\n             List[aiosqlite.Row]: A list of deleted entries if pop is True.\n \n         \"\"\"\n+        note_id = int(note_id)\n         return await self.delete_rows(\n             'Notes', where=f'note_id={note_id}', pop=pop)\n \n     async def delete_note_by_user_id(self, user_id: int, entry_num: int):\n-        \"\"\"Delete a note from the Notes table by user_id and entry_num.\n-\n-        user_id is not escaped.\n+        \"\"\"Delete a note from the Notes table by user_id and entry_num.\"\"\"\n+        user_id = int(user_id)\n \n-        \"\"\"\n-        notes = self.get_notes(user_id)\n+        notes = await self.get_notes(user_id)\n         note_id = notes[entry_num]['note_id']\n         await self.delete_rows('Notes', where=f'note_id={note_id}')\n \n-    async def get_notes(self, user_id: int, *, as_Row=True):\n+    async def get_notes(self, user_id: int, *, as_row=True):\n         \"\"\"Get one or more notes for a user.\n \n-        user_id is not escaped.\n-\n         Args:\n             user_id (int): The id of the user to get notes from.\n+            as_row (bool)\n \n         \"\"\"\n+        user_id = int(user_id)\n         return await self.get_rows(\n-            'Notes', where=f'user_id={user_id}', as_Row=as_Row)\n+            'Notes', where=f'user_id={user_id}', as_row=as_row)\n \n \n def setup(connection):\n-    \"Set up the Notes table for a sqlite3 connection.\"\n+    \"\"\"Set up the Notes table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n     ","add":9,"remove":10,"filename":"\/bot\/database\/notedatabase.py","badparts":["        \"\"\"Delete a note from the Notes table by user_id and entry_num.","        user_id is not escaped.","        \"\"\"","        notes = self.get_notes(user_id)","    async def get_notes(self, user_id: int, *, as_Row=True):","        user_id is not escaped.","            'Notes', where=f'user_id={user_id}', as_Row=as_Row)","    \"Set up the Notes table for a sqlite3 connection.\""],"goodparts":["        note_id = int(note_id)","        \"\"\"Delete a note from the Notes table by user_id and entry_num.\"\"\"","        user_id = int(user_id)","        notes = await self.get_notes(user_id)","    async def get_notes(self, user_id: int, *, as_row=True):","            as_row (bool)","        user_id = int(user_id)","            'Notes', where=f'user_id={user_id}', as_row=as_row)","    \"\"\"Set up the Notes table with a sqlite3 connection.\"\"\""]}],"source":"\n\"\"\"A database for storing user's notes. Table dependencies: Users \"\"\" from. import userdatabase as user_db TABLE_NOTES=\"\"\" CREATE TABLE IF NOT EXISTS Notes( note_id INTEGER PRIMARY KEY NOT NULL, user_id INTEGER NOT NULL, time_of_entry TIMESTAMP, content TEXT NOT NULL, FOREIGN KEY(user_id) REFERENCES Users(id) ); \"\"\" class NoteDatabase(user_db.UserDatabase): \"Provide an interface to a UserDatabase with a Notes table.\" async def add_note(self, user_id: int, time_of_entry, content: str, *, add_user=False): \"\"\"Add a note to the Notes table. Args: user_id(int) time_of_entry(datetime.datetime) content(str) add_user(bool): If True, automatically adds the user_id to the Users table. Otherwise, the user_id foreign key can be violated. \"\"\" if add_user: await self.add_user(user_id) return await self.add_row('Notes',{ 'user_id': user_id, 'time_of_entry': time_of_entry, 'content': content }) async def delete_note_by_note_id(self, note_id: int, pop=False): \"\"\"Delete a note from the Notes table. note_id is not escaped. Args: note_id(int) pop(bool): If True, gets the notes before deleting them. Returns: None List[aiosqlite.Row]: A list of deleted entries if pop is True. \"\"\" return await self.delete_rows( 'Notes', where=f'note_id={note_id}', pop=pop) async def delete_note_by_user_id(self, user_id: int, entry_num: int): \"\"\"Delete a note from the Notes table by user_id and entry_num. user_id is not escaped. \"\"\" notes=self.get_notes(user_id) note_id=notes[entry_num]['note_id'] await self.delete_rows('Notes', where=f'note_id={note_id}') async def get_notes(self, user_id: int, *, as_Row=True): \"\"\"Get one or more notes for a user. user_id is not escaped. Args: user_id(int): The id of the user to get notes from. \"\"\" return await self.get_rows( 'Notes', where=f'user_id={user_id}', as_Row=as_Row) def setup(connection): \"Set up the Notes table for a sqlite3 connection.\" with connection as conn: conn.execute(TABLE_NOTES) ","sourceWithComments":"\"\"\"A database for storing user's notes.\n\nTable dependencies:\n    Users\n\"\"\"\nfrom . import userdatabase as user_db\n\nTABLE_NOTES = \"\"\"\nCREATE TABLE IF NOT EXISTS Notes (\n    note_id INTEGER PRIMARY KEY NOT NULL,\n    user_id INTEGER NOT NULL,\n    time_of_entry TIMESTAMP,\n    content TEXT NOT NULL,\n    FOREIGN KEY(user_id) REFERENCES Users(id)\n);\n\"\"\"\n\n\nclass NoteDatabase(user_db.UserDatabase):\n    \"Provide an interface to a UserDatabase with a Notes table.\"\n\n    async def add_note(self, user_id: int, time_of_entry,\n            content: str, *, add_user=False):\n        \"\"\"Add a note to the Notes table.\n\n        Args:\n            user_id (int)\n            time_of_entry (datetime.datetime)\n            content (str)\n            add_user (bool):\n                If True, automatically adds the user_id to the Users table.\n                Otherwise, the user_id foreign key can be violated.\n\n        \"\"\"\n        if add_user:\n            await self.add_user(user_id)\n\n        return await self.add_row('Notes', {\n            'user_id': user_id,\n            'time_of_entry': time_of_entry,\n            'content': content\n        })\n\n    async def delete_note_by_note_id(self, note_id: int, pop=False):\n        \"\"\"Delete a note from the Notes table.\n\n        note_id is not escaped.\n\n        Args:\n            note_id (int)\n            pop (bool): If True, gets the notes before deleting them.\n\n        Returns:\n            None\n            List[aiosqlite.Row]: A list of deleted entries if pop is True.\n\n        \"\"\"\n        return await self.delete_rows(\n            'Notes', where=f'note_id={note_id}', pop=pop)\n\n    async def delete_note_by_user_id(self, user_id: int, entry_num: int):\n        \"\"\"Delete a note from the Notes table by user_id and entry_num.\n\n        user_id is not escaped.\n\n        \"\"\"\n        notes = self.get_notes(user_id)\n        note_id = notes[entry_num]['note_id']\n        await self.delete_rows('Notes', where=f'note_id={note_id}')\n\n    async def get_notes(self, user_id: int, *, as_Row=True):\n        \"\"\"Get one or more notes for a user.\n\n        user_id is not escaped.\n\n        Args:\n            user_id (int): The id of the user to get notes from.\n\n        \"\"\"\n        return await self.get_rows(\n            'Notes', where=f'user_id={user_id}', as_Row=as_Row)\n\n\ndef setup(connection):\n    \"Set up the Notes table for a sqlite3 connection.\"\n    with connection as conn:\n        conn.execute(TABLE_NOTES)\n"},"\/bot\/database\/prefixdatabase.py":{"changes":[{"diff":"\n     guild_id INTEGER NOT NULL,\n     prefix TEXT NOT NULL,\n     FOREIGN KEY(guild_id) REFERENCES Guilds(id)\n+        ON DELETE CASCADE\n );\n \"\"\"\n \n \n class PrefixDatabase(guild_db.GuildDatabase):\n-    \"Provide an interface to a GuildDatabase with a Prefixes table.\"\n+    \"\"\"Provide an interface to a GuildDatabase with a Prefixes table.\"\"\"\n \n     __slots__ = ['prefix_cache']\n \n","add":2,"remove":1,"filename":"\/bot\/database\/prefixdatabase.py","badparts":["    \"Provide an interface to a GuildDatabase with a Prefixes table.\""],"goodparts":["        ON DELETE CASCADE","    \"\"\"Provide an interface to a GuildDatabase with a Prefixes table.\"\"\""]},{"diff":"\n         self.prefix_cache = {}\n \n     async def has_prefix(self, guild_id: int):\n-        \"Test if a prefix for a guild exists in the database.\"\n+        \"\"\"Test if a prefix for a guild exists in the database.\"\"\"\n+        guild_id = int(guild_id)\n+\n         return await self.get_prefix(guild_id) is not None\n \n     async def add_prefix(\n","add":3,"remove":1,"filename":"\/bot\/database\/prefixdatabase.py","badparts":["        \"Test if a prefix for a guild exists in the database.\""],"goodparts":["        \"\"\"Test if a prefix for a guild exists in the database.\"\"\"","        guild_id = int(guild_id)"]},{"diff":"\n \n         return prefixes\n \n-    async def get_prefix(self, guild_id: int, *, as_Row=True):\n+    async def get_prefix(self, guild_id: int, *, as_row=True):\n         \"\"\"Get the prefix for a guild.\n \n         guild_id is not escaped.\n","add":1,"remove":1,"filename":"\/bot\/database\/prefixdatabase.py","badparts":["    async def get_prefix(self, guild_id: int, *, as_Row=True):"],"goodparts":["    async def get_prefix(self, guild_id: int, *, as_row=True):"]},{"diff":"\n             str\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         prefix = self.prefix_cache.get(guild_id)\n         if prefix is not None:\n             return prefix\n \n         query = await self.get_one(\n-            'Prefixes', where=f'guild_id={guild_id}', as_Row=as_Row)\n+            'Prefixes', where=f'guild_id={guild_id}', as_row=as_row)\n \n         if query is None:\n             return\n","add":3,"remove":1,"filename":"\/bot\/database\/prefixdatabase.py","badparts":["            'Prefixes', where=f'guild_id={guild_id}', as_Row=as_Row)"],"goodparts":["        guild_id = int(guild_id)","            'Prefixes', where=f'guild_id={guild_id}', as_row=as_row)"]},{"diff":"\n         self.prefix_cache[guild_id] = prefix\n \n         return prefix\n-        \n \n-    async def update_prefix(\n-            self, guild_id: int, prefix: str):\n+    async def update_prefix(self, guild_id: int, prefix: str):\n         \"\"\"Update a prefix for a guild.\n \n         The prefix is constrained by PREFIX_SIZE_LIMIT.\n \n         \"\"\"\n+        guild_id = int(guild_id)\n+\n         if len(prefix) > self.PREFIX_SIZE_LIMIT:\n             raise ValueError(\n                 f'Prefix cannot be over {self.PREFIX_SIZE_LIMIT:,} '\n","add":3,"remove":3,"filename":"\/bot\/database\/prefixdatabase.py","badparts":["    async def update_prefix(","            self, guild_id: int, prefix: str):"],"goodparts":["    async def update_prefix(self, guild_id: int, prefix: str):","        guild_id = int(guild_id)"]},{"diff":"\n \n \n def setup(connection):\n-    \"Set up the prefixes table for a sqlite3 connection.\"\n+    \"\"\"Set up the prefixes table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n       ","add":1,"remove":1,"filename":"\/bot\/database\/prefixdatabase.py","badparts":["    \"Set up the prefixes table for a sqlite3 connection.\""],"goodparts":["    \"\"\"Set up the prefixes table with a sqlite3 connection.\"\"\""]}],"source":"\n\"\"\"A database for storing user's prefixes. Table dependencies: Users \"\"\" from. import guilddatabase as guild_db from bot import settings TABLE_PREFIXES=\"\"\" CREATE TABLE IF NOT EXISTS Prefixes( guild_id INTEGER NOT NULL, prefix TEXT NOT NULL, FOREIGN KEY(guild_id) REFERENCES Guilds(id) ); \"\"\" class PrefixDatabase(guild_db.GuildDatabase): \"Provide an interface to a GuildDatabase with a Prefixes table.\" __slots__=['prefix_cache'] PREFIX_SIZE_LIMIT=20 def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.prefix_cache={} async def has_prefix(self, guild_id: int): \"Test if a prefix for a guild exists in the database.\" return await self.get_prefix(guild_id) is not None async def add_prefix( self, guild_id: int, prefix: str=None, *, add_guild=False): \"\"\"Add a prefix for a guild. The prefix is constrained by PREFIX_SIZE_LIMIT. Args: guild_id(int) prefix(Optional[str]): The prefix to set the guild with. If no prefix is provided, uses default_prefix in settings. add_guild(bool): If True, automatically adds the guild_id to the Guilds table. Otherwise, the guild_id foreign key can be violated. \"\"\" if prefix is None: prefix=settings.get_setting('default_prefix') if len(prefix) > self.PREFIX_SIZE_LIMIT: raise ValueError( f'Prefix cannot be over{self.PREFIX_SIZE_LIMIT:,} ' 'characters long.' ) if add_guild: await self.add_guild(guild_id) if not await self.has_prefix(guild_id): result=await self.add_row( 'Prefixes',{'guild_id': guild_id, 'prefix': prefix}) self.prefix_cache[guild_id]=prefix return result async def delete_prefix(self, guild_id: int, pop=False): \"\"\"Delete a prefix from a guild. guild_id is not escaped. Args: guild_id(int) pop(bool): If True, gets the prefixes before deleting them. Returns: None List[aiosqlite.Row]: A list of deleted entries if pop is True. \"\"\" prefixes=await self.delete_rows( 'Prefixes', where=f'guild_id={guild_id}', pop=pop) self.prefix_cache.pop(guild_id, None) return prefixes async def get_prefix(self, guild_id: int, *, as_Row=True): \"\"\"Get the prefix for a guild. guild_id is not escaped. Returns: str \"\"\" prefix=self.prefix_cache.get(guild_id) if prefix is not None: return prefix query=await self.get_one( 'Prefixes', where=f'guild_id={guild_id}', as_Row=as_Row) if query is None: return prefix=query['prefix'] self.prefix_cache[guild_id]=prefix return prefix async def update_prefix( self, guild_id: int, prefix: str): \"\"\"Update a prefix for a guild. The prefix is constrained by PREFIX_SIZE_LIMIT. \"\"\" if len(prefix) > self.PREFIX_SIZE_LIMIT: raise ValueError( f'Prefix cannot be over{self.PREFIX_SIZE_LIMIT:,} ' 'characters long.' ) await self.update_rows( 'Prefixes',{'prefix': prefix}, where=f'guild_id={guild_id}') self.prefix_cache[guild_id]=prefix def setup(connection): \"Set up the prefixes table for a sqlite3 connection.\" with connection as conn: conn.execute(TABLE_PREFIXES) ","sourceWithComments":"\"\"\"A database for storing user's prefixes.\n\nTable dependencies:\n    Users\n\"\"\"\nfrom . import guilddatabase as guild_db\nfrom bot import settings\n\nTABLE_PREFIXES = \"\"\"\nCREATE TABLE IF NOT EXISTS Prefixes (\n    guild_id INTEGER NOT NULL,\n    prefix TEXT NOT NULL,\n    FOREIGN KEY(guild_id) REFERENCES Guilds(id)\n);\n\"\"\"\n\n\nclass PrefixDatabase(guild_db.GuildDatabase):\n    \"Provide an interface to a GuildDatabase with a Prefixes table.\"\n\n    __slots__ = ['prefix_cache']\n\n    PREFIX_SIZE_LIMIT = 20\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.prefix_cache = {}\n\n    async def has_prefix(self, guild_id: int):\n        \"Test if a prefix for a guild exists in the database.\"\n        return await self.get_prefix(guild_id) is not None\n\n    async def add_prefix(\n            self, guild_id: int, prefix: str = None, *, add_guild=False):\n        \"\"\"Add a prefix for a guild.\n\n        The prefix is constrained by PREFIX_SIZE_LIMIT.\n\n        Args:\n            guild_id (int)\n            prefix (Optional[str]): The prefix to set the guild with.\n                If no prefix is provided, uses default_prefix in settings.\n            add_guild (bool):\n                If True, automatically adds the guild_id to the Guilds table.\n                Otherwise, the guild_id foreign key can be violated.\n\n        \"\"\"\n        if prefix is None:\n            prefix = settings.get_setting('default_prefix')\n\n        if len(prefix) > self.PREFIX_SIZE_LIMIT:\n            raise ValueError(\n                f'Prefix cannot be over {self.PREFIX_SIZE_LIMIT:,} '\n                'characters long.'\n            )\n\n        if add_guild:\n            await self.add_guild(guild_id)\n\n        if not await self.has_prefix(guild_id):\n            result = await self.add_row(\n                'Prefixes', {'guild_id': guild_id, 'prefix': prefix})\n\n            self.prefix_cache[guild_id] = prefix\n\n            return result\n\n    async def delete_prefix(self, guild_id: int, pop=False):\n        \"\"\"Delete a prefix from a guild.\n\n        guild_id is not escaped.\n\n        Args:\n            guild_id (int)\n            pop (bool): If True, gets the prefixes before deleting them.\n\n        Returns:\n            None\n            List[aiosqlite.Row]: A list of deleted entries if pop is True.\n\n        \"\"\"\n        prefixes = await self.delete_rows(\n            'Prefixes', where=f'guild_id={guild_id}', pop=pop)\n\n        self.prefix_cache.pop(guild_id, None)\n\n        return prefixes\n\n    async def get_prefix(self, guild_id: int, *, as_Row=True):\n        \"\"\"Get the prefix for a guild.\n\n        guild_id is not escaped.\n\n        Returns:\n            str\n\n        \"\"\"\n        prefix = self.prefix_cache.get(guild_id)\n        if prefix is not None:\n            return prefix\n\n        query = await self.get_one(\n            'Prefixes', where=f'guild_id={guild_id}', as_Row=as_Row)\n\n        if query is None:\n            return\n\n        prefix = query['prefix']\n\n        self.prefix_cache[guild_id] = prefix\n\n        return prefix\n        \n\n    async def update_prefix(\n            self, guild_id: int, prefix: str):\n        \"\"\"Update a prefix for a guild.\n\n        The prefix is constrained by PREFIX_SIZE_LIMIT.\n\n        \"\"\"\n        if len(prefix) > self.PREFIX_SIZE_LIMIT:\n            raise ValueError(\n                f'Prefix cannot be over {self.PREFIX_SIZE_LIMIT:,} '\n                'characters long.'\n            )\n\n        await self.update_rows(\n            'Prefixes', {'prefix': prefix}, where=f'guild_id={guild_id}')\n\n        self.prefix_cache[guild_id] = prefix\n\n\ndef setup(connection):\n    \"Set up the prefixes table for a sqlite3 connection.\"\n    with connection as conn:\n        conn.execute(TABLE_PREFIXES)\n"},"\/bot\/database\/reminderdatabase.py":{"changes":[{"diff":"\n     due TIMESTAMP,\n     content TEXT NOT NULL,\n     FOREIGN KEY(user_id) REFERENCES Users(id)\n+        ON DELETE CASCADE\n );\n \"\"\"\n \n \n class ReminderDatabase(user_db.UserDatabase):\n-    \"Provide an interface to a UserDatabase with a Reminders table.\"\n+    \"\"\"Provide an interface to a UserDatabase with a Reminders table.\"\"\"\n \n     async def add_reminder(self, user_id: int, due,\n-            content: str, *, add_user=False):\n+                           content: str, *, add_user=True):\n         \"\"\"Add a reminder to the Reminders table.\n \n         Args:\n","add":3,"remove":2,"filename":"\/bot\/database\/reminderdatabase.py","badparts":["    \"Provide an interface to a UserDatabase with a Reminders table.\"","            content: str, *, add_user=False):"],"goodparts":["        ON DELETE CASCADE","    \"\"\"Provide an interface to a UserDatabase with a Reminders table.\"\"\"","                           content: str, *, add_user=True):"]},{"diff":"\n         user_id is not escaped.\n \n         \"\"\"\n-        reminders = self.get_reminders(user_id)\n+        user_id = int(user_id)\n+\n+        reminders = await self.get_reminders(user_id)\n         reminder_id = reminders[entry_num]['reminder_id']\n         await self.delete_rows(\n             'Reminders', where=f'reminder_id={reminder_id}')\n \n-    async def get_reminders(self, user_id: int, *, as_Row=True):\n+    async def get_reminders(self, user_id: int, *, as_row=True):\n         \"\"\"Get one or more reminders for a user.\n \n         user_id is not escaped.\n \n         Args:\n             user_id (int): The id of the user to get reminders from.\n+            as_row (bool)\n \n         \"\"\"\n+        user_id = int(user_id)\n+\n         return await self.get_rows(\n-            'Reminders', where=f'user_id={user_id}', as_Row=as_Row)\n+            'Reminders', where=f'user_id={user_id}', as_row=as_row)\n \n \n def setup(connection):\n-    \"Set up the Reminders table for a sqlite3 connection.\"\n+    \"\"\"Set up the Reminders table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n       ","add":9,"remove":4,"filename":"\/bot\/database\/reminderdatabase.py","badparts":["        reminders = self.get_reminders(user_id)","    async def get_reminders(self, user_id: int, *, as_Row=True):","            'Reminders', where=f'user_id={user_id}', as_Row=as_Row)","    \"Set up the Reminders table for a sqlite3 connection.\""],"goodparts":["        user_id = int(user_id)","        reminders = await self.get_reminders(user_id)","    async def get_reminders(self, user_id: int, *, as_row=True):","            as_row (bool)","        user_id = int(user_id)","            'Reminders', where=f'user_id={user_id}', as_row=as_row)","    \"\"\"Set up the Reminders table with a sqlite3 connection.\"\"\""]}],"source":"\n\"\"\"A database for storing user's reminders. Table dependencies: Users \"\"\" from. import userdatabase as user_db TABLE_REMINDERS=\"\"\" CREATE TABLE IF NOT EXISTS Reminders( reminder_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, user_id INTEGER NOT NULL, due TIMESTAMP, content TEXT NOT NULL, FOREIGN KEY(user_id) REFERENCES Users(id) ); \"\"\" class ReminderDatabase(user_db.UserDatabase): \"Provide an interface to a UserDatabase with a Reminders table.\" async def add_reminder(self, user_id: int, due, content: str, *, add_user=False): \"\"\"Add a reminder to the Reminders table. Args: user_id(int) due(datetime.datetime) content(str) add_user(bool): If True, automatically adds the user_id to the Users table. Otherwise, the user_id foreign key can be violated. \"\"\" if add_user: await self.add_user(user_id) return await self.add_row('Reminders',{ 'user_id': user_id, 'due': due, 'content': content }) async def delete_reminder_by_id( self, reminder_id: int, pop=False): \"\"\"Delete a reminder from the Reminders table. reminder_id is not escaped. Args: reminder_id(int) pop(bool): If True, gets the reminders before deleting them. Returns: None List[aiosqlite.Row]: A list of deleted entries if pop is True. \"\"\" return await self.delete_rows( 'Reminders', where=f'reminder_id={reminder_id}', pop=pop) async def delete_reminder_by_user_id( self, user_id: int, entry_num: int): \"\"\"Delete a reminder from the Reminders table by user_id and entry_num. user_id is not escaped. \"\"\" reminders=self.get_reminders(user_id) reminder_id=reminders[entry_num]['reminder_id'] await self.delete_rows( 'Reminders', where=f'reminder_id={reminder_id}') async def get_reminders(self, user_id: int, *, as_Row=True): \"\"\"Get one or more reminders for a user. user_id is not escaped. Args: user_id(int): The id of the user to get reminders from. \"\"\" return await self.get_rows( 'Reminders', where=f'user_id={user_id}', as_Row=as_Row) def setup(connection): \"Set up the Reminders table for a sqlite3 connection.\" with connection as conn: conn.execute(TABLE_REMINDERS) ","sourceWithComments":"\"\"\"A database for storing user's reminders.\n\nTable dependencies:\n    Users\n\"\"\"\nfrom . import userdatabase as user_db\n\nTABLE_REMINDERS = \"\"\"\nCREATE TABLE IF NOT EXISTS Reminders (\n    reminder_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    user_id INTEGER NOT NULL,\n    due TIMESTAMP,\n    content TEXT NOT NULL,\n    FOREIGN KEY(user_id) REFERENCES Users(id)\n);\n\"\"\"\n\n\nclass ReminderDatabase(user_db.UserDatabase):\n    \"Provide an interface to a UserDatabase with a Reminders table.\"\n\n    async def add_reminder(self, user_id: int, due,\n            content: str, *, add_user=False):\n        \"\"\"Add a reminder to the Reminders table.\n\n        Args:\n            user_id (int)\n            due (datetime.datetime)\n            content (str)\n            add_user (bool):\n                If True, automatically adds the user_id to the Users table.\n                Otherwise, the user_id foreign key can be violated.\n\n        \"\"\"\n        if add_user:\n            await self.add_user(user_id)\n\n        return await self.add_row('Reminders', {\n            'user_id': user_id,\n            'due': due,\n            'content': content\n        })\n\n    async def delete_reminder_by_id(\n            self, reminder_id: int, pop=False):\n        \"\"\"Delete a reminder from the Reminders table.\n\n        reminder_id is not escaped.\n\n        Args:\n            reminder_id (int)\n            pop (bool): If True, gets the reminders before deleting them.\n\n        Returns:\n            None\n            List[aiosqlite.Row]: A list of deleted entries if pop is True.\n\n        \"\"\"\n        return await self.delete_rows(\n            'Reminders', where=f'reminder_id={reminder_id}', pop=pop)\n\n    async def delete_reminder_by_user_id(\n            self, user_id: int, entry_num: int):\n        \"\"\"Delete a reminder from the Reminders table by user_id and entry_num.\n\n        user_id is not escaped.\n\n        \"\"\"\n        reminders = self.get_reminders(user_id)\n        reminder_id = reminders[entry_num]['reminder_id']\n        await self.delete_rows(\n            'Reminders', where=f'reminder_id={reminder_id}')\n\n    async def get_reminders(self, user_id: int, *, as_Row=True):\n        \"\"\"Get one or more reminders for a user.\n\n        user_id is not escaped.\n\n        Args:\n            user_id (int): The id of the user to get reminders from.\n\n        \"\"\"\n        return await self.get_rows(\n            'Reminders', where=f'user_id={user_id}', as_Row=as_Row)\n\n\ndef setup(connection):\n    \"Set up the Reminders table for a sqlite3 connection.\"\n    with connection as conn:\n        conn.execute(TABLE_REMINDERS)\n"},"\/bot\/database\/userdatabase.py":{"changes":[{"diff":"\n \n \n class UserDatabase(db.Database):\n-    \"Provide an interface to a database with a Users table.\"\n+    \"\"\"Provide an interface to a database with a Users table.\"\"\"\n \n     async def has_user(self, user_id: int):\n-        \"Test if a user_id exists in the database.\"\n+        \"\"\"Test if a user_id exists in the database.\"\"\"\n+        user_id = int(user_id)\n+\n         return await self.get_user(user_id) is not None\n \n     async def add_user(self, user_id: int):\n-        \"\"\"Add a user to the database if the user does not exist.\n-\n-        user_id is not escaped.\n+        \"\"\"Add a user to the database if the user does not exist.\"\"\"\n+        user_id = int(user_id)\n \n-        \"\"\"\n         if not await self.has_user(user_id):\n             return await self.add_row('Users', {'id': user_id})\n \n-    async def get_user(self, user_id: int, *, as_Row=True):\n+    async def get_user(self, user_id: int, *, as_row=True):\n         \"\"\"Get a user record from the database.\n \n         If the user is not found, returns None.\n \n-        user_id is not escaped.\n-\n         \"\"\"\n+        user_id = int(user_id)\n+\n         return await self.get_one(\n-            'Users', where=f'id={user_id}', as_Row=as_Row)\n+            'Users', where=f'id={user_id}', as_row=as_row)\n \n     async def remove_user(self, user_id: int):\n-        \"\"\"Remove a user from the database.\n-\n-        user_id is not escaped.\n+        \"\"\"Remove a user from the database.\"\"\"\n+        user_id = int(user_id)\n \n-        \"\"\"\n         await self.delete_rows('Users', where=f'id={user_id}')\n \n \n def setup(connection):\n-    \"Set up the Users table for a sqlite3 connection.\"\n+    \"\"\"Set up the Users table with a sqlite3 connection.\"\"\"\n     with connection as conn:\n  ","add":13,"remove":15,"filename":"\/bot\/database\/userdatabase.py","badparts":["    \"Provide an interface to a database with a Users table.\"","        \"Test if a user_id exists in the database.\"","        \"\"\"Add a user to the database if the user does not exist.","        user_id is not escaped.","        \"\"\"","    async def get_user(self, user_id: int, *, as_Row=True):","        user_id is not escaped.","            'Users', where=f'id={user_id}', as_Row=as_Row)","        \"\"\"Remove a user from the database.","        user_id is not escaped.","        \"\"\"","    \"Set up the Users table for a sqlite3 connection.\""],"goodparts":["    \"\"\"Provide an interface to a database with a Users table.\"\"\"","        \"\"\"Test if a user_id exists in the database.\"\"\"","        user_id = int(user_id)","        \"\"\"Add a user to the database if the user does not exist.\"\"\"","        user_id = int(user_id)","    async def get_user(self, user_id: int, *, as_row=True):","        user_id = int(user_id)","            'Users', where=f'id={user_id}', as_row=as_row)","        \"\"\"Remove a user from the database.\"\"\"","        user_id = int(user_id)","    \"\"\"Set up the Users table with a sqlite3 connection.\"\"\""]}],"source":"\n\"\"\"A database for storing user IDs. Table dependencies: None \"\"\" from. import database as db TABLE_USERS=\"\"\" CREATE TABLE IF NOT EXISTS Users( id INTEGER UNIQUE NOT NULL PRIMARY KEY ); \"\"\" class UserDatabase(db.Database): \"Provide an interface to a database with a Users table.\" async def has_user(self, user_id: int): \"Test if a user_id exists in the database.\" return await self.get_user(user_id) is not None async def add_user(self, user_id: int): \"\"\"Add a user to the database if the user does not exist. user_id is not escaped. \"\"\" if not await self.has_user(user_id): return await self.add_row('Users',{'id': user_id}) async def get_user(self, user_id: int, *, as_Row=True): \"\"\"Get a user record from the database. If the user is not found, returns None. user_id is not escaped. \"\"\" return await self.get_one( 'Users', where=f'id={user_id}', as_Row=as_Row) async def remove_user(self, user_id: int): \"\"\"Remove a user from the database. user_id is not escaped. \"\"\" await self.delete_rows('Users', where=f'id={user_id}') def setup(connection): \"Set up the Users table for a sqlite3 connection.\" with connection as conn: conn.execute(TABLE_USERS) ","sourceWithComments":"\"\"\"A database for storing user IDs.\n\nTable dependencies:\n    None\n\"\"\"\nfrom . import database as db\n\nTABLE_USERS = \"\"\"\nCREATE TABLE IF NOT EXISTS Users (\n    id INTEGER UNIQUE\n             NOT NULL\n             PRIMARY KEY\n);\n\"\"\"\n\n\nclass UserDatabase(db.Database):\n    \"Provide an interface to a database with a Users table.\"\n\n    async def has_user(self, user_id: int):\n        \"Test if a user_id exists in the database.\"\n        return await self.get_user(user_id) is not None\n\n    async def add_user(self, user_id: int):\n        \"\"\"Add a user to the database if the user does not exist.\n\n        user_id is not escaped.\n\n        \"\"\"\n        if not await self.has_user(user_id):\n            return await self.add_row('Users', {'id': user_id})\n\n    async def get_user(self, user_id: int, *, as_Row=True):\n        \"\"\"Get a user record from the database.\n\n        If the user is not found, returns None.\n\n        user_id is not escaped.\n\n        \"\"\"\n        return await self.get_one(\n            'Users', where=f'id={user_id}', as_Row=as_Row)\n\n    async def remove_user(self, user_id: int):\n        \"\"\"Remove a user from the database.\n\n        user_id is not escaped.\n\n        \"\"\"\n        await self.delete_rows('Users', where=f'id={user_id}')\n\n\ndef setup(connection):\n    \"Set up the Users table for a sqlite3 connection.\"\n    with connection as conn:\n        conn.execute(TABLE_USERS)\n"},"\/bot\/eventhandlers.py":{"changes":[{"diff":"\n     'on_resumed',\n ]\n \n-COMMAND_ERROR_IGNORE_EXCEPTIONS = (\n-    commands.CommandNotFound, commands.CheckFailure)\n+COMMAND_ERROR_IGNORE_EXCEPTIONS = (commands.CommandNotFound,)\n # Prevents errors from being processed in this set of exceptions\n+COMMAND_ERROR_IGNORE_EXCEPTIONS_AFTER = (commands.CheckFailure,)\n+# Same as above except this prevents raising the error if the exception\n+# was not matched. Helpful for ignoring superclasses of exceptions.\n COMMAND_ERROR_CALLBACK_BLACKLIST = frozenset()\n # Prevents errors from being processed in this set of commands,\n # specified by the callback name of the command ('client_execute', etc.)\n","add":4,"remove":2,"filename":"\/bot\/eventhandlers.py","badparts":["COMMAND_ERROR_IGNORE_EXCEPTIONS = (","    commands.CommandNotFound, commands.CheckFailure)"],"goodparts":["COMMAND_ERROR_IGNORE_EXCEPTIONS = (commands.CommandNotFound,)","COMMAND_ERROR_IGNORE_EXCEPTIONS_AFTER = (commands.CheckFailure,)"]},{"diff":"\n \n \n async def on_command_error(ctx, error):\n+    error_unpacked = getattr(error, 'original', error)\n     if isinstance(error, COMMAND_ERROR_IGNORE_EXCEPTIONS):\n         return\n     elif ctx.command.callback.__name__ in COMMAND_ERROR_CALLBACK_BLACKLIST:\n         # command is to be ignored\n         return\n-    elif (isinstance(error, ERRORS_TO_LIMIT)\n-          or hasattr(error, 'original')\n-          and isinstance(error.original, ERRORS_TO_LIMIT)):\n-        error_unpacked = getattr(error, 'original', error)\n+    elif isinstance(error_unpacked, ERRORS_TO_LIMIT):\n         if command_error_limiter.check_user(ctx, error_unpacked):\n             # user is rate limited on receiving a particular error\n             return\n","add":2,"remove":4,"filename":"\/bot\/eventhandlers.py","badparts":["    elif (isinstance(error, ERRORS_TO_LIMIT)","          or hasattr(error, 'original')","          and isinstance(error.original, ERRORS_TO_LIMIT)):","        error_unpacked = getattr(error, 'original', error)"],"goodparts":["    error_unpacked = getattr(error, 'original', error)","    elif isinstance(error_unpacked, ERRORS_TO_LIMIT):"]},{"diff":"\n         ).set_footer(\n             text=inflector.inflect(\n                 'You are using commands too frequently. '\n-                'You can retry in {0:.2g} plural(\"second\", {0}).'.format(\n-                    error.retry_after)\n+                'You can retry in {0} plural(\"second\", {0}).'.format(\n+                    round(error.retry_after * 10) \/ 10)\n             ),\n-            icon_url=str(ctx.author.avatar_url)\n+            icon_url=ctx.author.avatar_url\n         )\n \n-        await ctx.send(embed=embed)\n-    elif (isinstance(error, commands.CommandInvokeError)\n-          and isinstance(error.original, discord.Forbidden)\n-          and error.original.code == 50007):\n+        await ctx.send(embed=embed, delete_after=min(error.retry_after, 20))\n+    elif (isinstance(error_unpacked, discord.Forbidden)\n+          and error_unpacked.code == 50007):\n         # Cannot send messages to this user\n         await ctx.send('I tried DMing you but you have your DMs '\n-                       'disabled for this server.')\n-    else:\n+                       'disabled for this server.', delete_after=10)\n+    elif not isinstance(error, COMMAND_ERROR_IGNORE_EXCEPTIONS","add":8,"remove":9,"filename":"\/bot\/eventhandlers.py","badparts":["                'You can retry in {0:.2g} plural(\"second\", {0}).'.format(","                    error.retry_after)","            icon_url=str(ctx.author.avatar_url)","        await ctx.send(embed=embed)","    elif (isinstance(error, commands.CommandInvokeError)","          and isinstance(error.original, discord.Forbidden)","          and error.original.code == 50007):","                       'disabled for this server.')","    else:"],"goodparts":["                'You can retry in {0} plural(\"second\", {0}).'.format(","                    round(error.retry_after * 10) \/ 10)","            icon_url=ctx.author.avatar_url","        await ctx.send(embed=embed, delete_after=min(error.retry_after, 20))","    elif (isinstance(error_unpacked, discord.Forbidden)","          and error_unpacked.code == 50007):","                       'disabled for this server.', delete_after=10)","    elif not isinstance(error, COMMAND_ERROR_IGNORE_EXCEPTIONS"]}],"source":"\nimport asyncio import random import time import discord from discord.ext import commands import inflect from bot import checks from bot import settings from bot import utils handlers=[ 'on_command_error', 'on_connect', 'on_disconnect', 'on_ready', 'on_resumed', ] COMMAND_ERROR_IGNORE_EXCEPTIONS=( commands.CommandNotFound, commands.CheckFailure) COMMAND_ERROR_CALLBACK_BLACKLIST=frozenset() inflector=inflect.engine() COOLDOWN_DESCRIPTIONS={ commands.BucketType.default: 'Too many people have used this command ' 'globally. The limit is{times}.', commands.BucketType.user: 'You have used this command too many times. ' 'The personal limit is{times}.', commands.BucketType.guild: 'Too many people have used this command ' '{here}. The limit is{times}.', commands.BucketType.channel: 'Too many people have used this command ' '{here}. The limit is{times}.', commands.BucketType.member: 'You have used this command too many times ' '{here}. The personal limit is{times}.', commands.BucketType.category: 'Too many people have used this command in ' 'this server category. The limit is{times}.', commands.BucketType.role: 'Too many people with the same role have used ' 'this command. The limit is{times}.' } MAX_CONCURRENCY_DESCRIPTIONS={ commands.BucketType.default: 'Too many people are currently using this ' 'command globally. The limit is ' '{times} concurrently.', commands.BucketType.user: 'You are using this command too many times. ' 'The personal limit is{times} concurrently.', commands.BucketType.guild: 'Too many people are currently using this ' 'command{here}. The limit is ' '{times} concurrently.', commands.BucketType.channel: 'Too many people are currently using this ' 'command{here}. The limit is ' '{times} concurrently.', commands.BucketType.member: 'You are using this command too many times ' '{here}. The personal limit is ' '{times} concurrently.', commands.BucketType.category: 'Too many people are currently using this ' 'command in this server category. ' 'The limit is{times} concurrently.', commands.BucketType.role: 'Too many people with the same role are using ' 'this command. The limit is ' '{times} concurrently.' } PERMS_TO_ENGLISH={ 'add_reactions': 'Add Reactions', 'administrator': 'Administrator', 'attach_files': 'Attach Files', 'ban_members': 'Ban Members', 'change_nickname': 'Change Nickname', 'connect': 'Connect', 'deafen_members': 'Deafen Members', 'embed_links': 'Embed Links', 'external_emojis': 'External Emojis', 'kick_members': 'Kick Members', 'manage_channels': 'Manage Channels', 'manage_emojis': 'Manage Emojis', 'manage_guild': 'Manage Guild', 'manage_messages': 'Manage Messages', 'manage_nicknames': 'Manage Nicknames', 'manage_permissions': 'Manage Roles', 'manage_roles': 'Manage Roles', 'manage_webhooks': 'Manage ', 'mention_everyone': 'Mention Everyone', 'move_members': 'Move Members', 'mute_members': 'Mute Members', 'priority_speaker': 'Priority Speaker', 'read_message_history': 'Read Message History', 'read_messages': 'Read Messages', 'send_messages': 'Send Messages', 'send_tts_messages': 'Send TTS Messages', 'speak': 'Speak', 'stream': 'Stream', 'use_external_emojis': 'External Emojis', 'use_voice_activation': 'Voice Activation', 'view_audit_log': 'View Audit Log', 'view_channel': 'Read Messages', 'view_guild_insights': 'View Guild Insights' } class CommandErrorCooldown: \"\"\"Maps cooldowns to specific errors. Args: errors_to_cooldowns(Dictionary[commands.CommandError, Optional[Tuple[int, int, commands.BucketType]]]): A mapping of errors to CooldownMapping arguments. the value can be None to use default parameters. \"\"\" __slots__=('error_mapping',) DEFAULT_COOLDOWN=(1, 10, commands.BucketType.user) def __init__(self, errors_to_cooldowns): from_cooldown=commands.CooldownMapping.from_cooldown self.error_mapping={ err: from_cooldown(*args) if args is not None else from_cooldown(*self.DEFAULT_COOLDOWN) for err, args in errors_to_cooldowns.items() } def check_user(self, ctx, error): mapping=self.error_mapping.get(type(error)) if mapping is None: return False return mapping.update_rate_limit(ctx.message) ERRORS_TO_LIMIT_COOLDOWN_MAPPING={ commands.BotMissingPermissions: None, commands.BotMissingAnyRole: None, commands.BotMissingRole: None, commands.CommandOnCooldown: None, commands.DisabledCommand: None, commands.MaxConcurrencyReached: None, commands.MissingAnyRole: None, commands.MissingPermissions: None, commands.MissingRole: None, commands.NoPrivateMessage: None, commands.NotOwner: None, commands.UserInputError:(5, 30, commands.BucketType.user), checks.UserOnCooldown:(1, 5, commands.BucketType.user), discord.Forbidden:(1, 5, commands.BucketType.user), } ERRORS_TO_LIMIT=tuple(ERRORS_TO_LIMIT_COOLDOWN_MAPPING) command_error_limiter=CommandErrorCooldown(ERRORS_TO_LIMIT_COOLDOWN_MAPPING) def convert_perms_to_english(perms): \"\"\"Run through a list of permissions and convert them into user-friendly representations. \"\"\" new_perms=[] for p in perms: eng=PERMS_TO_ENGLISH.get(p) if eng is not None: new_perms.append(eng) return new_perms def get_denied_message(): return random.choice(settings.get_setting('deniedmessages')) async def on_connect(): print(time.strftime( 'Connection: Connected to Discord, %c', time.localtime())) async def on_disconnect(): print(time.strftime( 'Connection: Lost connection to Discord, %c', time.localtime())) async def on_ready(): s=time.strftime( 'Bot is ready, %c', time.localtime() ) line='-' * len(s) print(s, line, sep='\\n') async def on_resumed(): print(time.strftime( 'Connection: Reconnected to Discord, %c', time.localtime())) async def on_command_error(ctx, error): if isinstance(error, COMMAND_ERROR_IGNORE_EXCEPTIONS): return elif ctx.command.callback.__name__ in COMMAND_ERROR_CALLBACK_BLACKLIST: return elif(isinstance(error, ERRORS_TO_LIMIT) or hasattr(error, 'original') and isinstance(error.original, ERRORS_TO_LIMIT)): error_unpacked=getattr(error, 'original', error) if command_error_limiter.check_user(ctx, error_unpacked): return if ctx.guild is not None: print( 'Command error({}:{}:{}:\"{}\")\\n {}:{}'.format( ctx.guild, ctx.channel, ctx.author, ctx.invoked_with, type(error).__name__, error )) else: print( 'Command error(<DM>:{}:\"{}\")\\n {}:{}'.format( ctx.author, ctx.invoked_with, type(error).__name__, error )) def convert_roles(missing_perms): \"Convert IDs in one or more roles into strings.\" def convert(p): if isinstance(p, int): r=ctx.bot.get_role(p) return str(r) if r is not None else p return p if isinstance(missing_perms, list): return[convert(p) for p in missing_perms] return(convert(missing_perms),) def get_command_signature(): prefix=ctx.prefix name_signature=ctx.invoked_with arguments=ctx.command.signature return f'{prefix}{name_signature}{arguments}' def get_concurrency_description(ctx, error): if not ctx.guild and error.per==commands.BucketType.channel: description=MAX_CONCURRENCY_DESCRIPTIONS.get( commands.BucketType.member, 'This command has currently reached max concurrency.' ) else: description=MAX_CONCURRENCY_DESCRIPTIONS.get( error.per, 'This command has currently reached max concurrency.' ) return description.format( here=get_cooldown_here(ctx, error.per), times=inflector.inflect( '{0} plural(\"time\",{0})'.format( error.number ) ) ) def get_cooldown_description(ctx, error): if( not ctx.guild and error.cooldown.type in( commands.BucketType.channel, commands.BucketType.guild)): description=COOLDOWN_DESCRIPTIONS.get( commands.BucketType.member, 'This command is on cooldown.' ) else: description=COOLDOWN_DESCRIPTIONS.get( error.cooldown.type, 'This command is on cooldown.' ) return description.format( here=get_cooldown_here(ctx, error.cooldown.type), times=inflector.inflect( '{0} plural(\"time\",{0}) ' 'every{1} plural(\"second\",{1})'.format( error.cooldown.rate, utils.num(error.cooldown.per) ) ) ) def get_cooldown_here(ctx, bucket): if ctx.guild: if bucket==commands.BucketType.guild: return 'on this server' return 'in this channel' else: return 'in this DM' def missing_x_to_run(x, missing_perms): count=len(missing_perms) if count==1: return(f'missing the{missing_perms[0]}{x} ' 'to run this command.') return 'missing{:,}{} to run this command:{}'.format( count, inflector.plural(x), inflector.join(missing_perms) ) if isinstance(error, commands.BadBoolArgument): await ctx.send('Expected a boolean answer for parameter ' f'\"{error.param.name}\".\\n' f'Usage: `{get_command_signature()}`') elif isinstance(error, commands.BotMissingPermissions): await ctx.send( 'I am{}'.format( missing_x_to_run( 'permission', convert_perms_to_english(error.missing_perms) ) ) ) elif isinstance(error,( commands.BotMissingRole, commands.BotMissingAnyRole)): await ctx.send('I am{}'.format( missing_x_to_run('role', convert_roles(error.missing_perms)) )) elif isinstance(error, commands.ChannelNotFound): await ctx.send('I cannot find the given channel.') elif isinstance(error, commands.ChannelNotReadable): await ctx.send('I cannot read messages in the channel.') elif isinstance(error, commands.CommandOnCooldown): embed=discord.Embed( color=utils.get_bot_color() ).set_footer( text=inflector.inflect( 'You can retry in{0} plural(\"second\",{0}).'.format( float(f'{error.retry_after:.2g}') ) ), icon_url=str(ctx.author.avatar_url) ) embed.description=get_cooldown_description(ctx, error) await ctx.send(embed=embed) elif isinstance(error, commands.DisabledCommand): await ctx.send('This command is currently disabled.') elif isinstance(error, commands.EmojiNotFound): await ctx.send(f'I cannot find the given emoji \"{error.argument}\"') elif isinstance(error, commands.ExpectedClosingQuoteError): await ctx.send('Expected a closing quotation mark.') elif isinstance(error, commands.InvalidEndOfQuotedStringError): await ctx.send('Expected a space after a closing quotation mark.') elif isinstance(error, commands.MaxConcurrencyReached): embed=discord.Embed( color=utils.get_bot_color() ).set_footer( text=get_concurrency_description(ctx, error), icon_url=str(ctx.author.avatar_url) ) await ctx.send(embed=embed) elif isinstance(error, commands.MessageNotFound): await ctx.send('I cannot find the given message.') elif isinstance(error, commands.MissingRequiredArgument): await ctx.send(f'Missing argument \"{error.param.name}\"\\n' f'Usage: `{get_command_signature()}`') elif isinstance(error, commands.MissingPermissions): await ctx.send( 'You are{}'.format( missing_x_to_run( 'permission', convert_perms_to_english(error.missing_perms) ) ) ) elif isinstance(error,(commands.MissingRole, commands.MissingAnyRole)): await ctx.send('You are{}'.format( missing_x_to_run('role', convert_roles(error.missing_perms)) )) elif isinstance(error, commands.NoPrivateMessage): await ctx.send('You must be in a server to use this command.') elif isinstance(error,( commands.NotOwner, checks.InvalidBotOwner, checks.InvalidBotAdmin)): await ctx.send(get_denied_message()) elif isinstance(error, commands.NSFWChannelRequired): await ctx.send('The given channel must be marked as NSFW.') elif isinstance(error, commands.UnexpectedQuoteError): await ctx.send('Did not expect a quotation mark.') elif isinstance(error,(commands.UserNotFound, commands.MemberNotFound)): await ctx.send('I cannot find the given user.') elif isinstance(error, commands.UserInputError): await ctx.send('Failed to parse your parameters.\\n' f'Usage: `{get_command_signature()}`') elif isinstance(error, checks.UserOnCooldown): embed=discord.Embed( color=utils.get_bot_color() ).set_footer( text=inflector.inflect( 'You are using commands too frequently. ' 'You can retry in{0:.2g} plural(\"second\",{0}).'.format( error.retry_after) ), icon_url=str(ctx.author.avatar_url) ) await ctx.send(embed=embed) elif(isinstance(error, commands.CommandInvokeError) and isinstance(error.original, discord.Forbidden) and error.original.code==50007): await ctx.send('I tried DMing you but you have your DMs ' 'disabled for this server.') else: raise error def setup(bot): for handler in handlers: bot.event(globals()[handler]) ","sourceWithComments":"import asyncio\nimport random\nimport time\n\nimport discord\nfrom discord.ext import commands\nimport inflect\n\nfrom bot import checks\nfrom bot import settings\nfrom bot import utils\n\nhandlers = [\n    'on_command_error',\n    'on_connect',\n    'on_disconnect',\n    'on_ready',\n    'on_resumed',\n]\n\nCOMMAND_ERROR_IGNORE_EXCEPTIONS = (\n    commands.CommandNotFound, commands.CheckFailure)\n# Prevents errors from being processed in this set of exceptions\nCOMMAND_ERROR_CALLBACK_BLACKLIST = frozenset()\n# Prevents errors from being processed in this set of commands,\n# specified by the callback name of the command ('client_execute', etc.)\n\ninflector = inflect.engine()\n\nCOOLDOWN_DESCRIPTIONS = {\n    commands.BucketType.default: 'Too many people have used this command '\n                                 'globally. The limit is {times}.',\n\n    commands.BucketType.user: 'You have used this command too many times. '\n                              'The personal limit is {times}.',\n\n    commands.BucketType.guild: 'Too many people have used this command '\n                               '{here}. The limit is {times}.',\n\n    commands.BucketType.channel: 'Too many people have used this command '\n                                 '{here}. The limit is {times}.',\n\n    commands.BucketType.member: 'You have used this command too many times '\n                                '{here}. The personal limit is {times}.',\n\n    commands.BucketType.category: 'Too many people have used this command in '\n                                  'this server category. The limit is {times}.',\n\n    commands.BucketType.role: 'Too many people with the same role have used '\n                              'this command. The limit is {times}.'\n}\n\nMAX_CONCURRENCY_DESCRIPTIONS = {\n    commands.BucketType.default: 'Too many people are currently using this '\n                                 'command globally. The limit is '\n                                 '{times} concurrently.',\n\n    commands.BucketType.user: 'You are using this command too many times. '\n                              'The personal limit is {times} concurrently.',\n\n    commands.BucketType.guild: 'Too many people are currently using this '\n                               'command {here}. The limit is '\n                               '{times} concurrently.',\n\n    commands.BucketType.channel: 'Too many people are currently using this '\n                                 'command {here}. The limit is '\n                                 '{times} concurrently.',\n\n    commands.BucketType.member: 'You are using this command too many times '\n                                '{here}. The personal limit is '\n                                '{times} concurrently.',\n\n    commands.BucketType.category: 'Too many people are currently using this '\n                                  'command in this server category. '\n                                  'The limit is {times} concurrently.',\n\n    commands.BucketType.role: 'Too many people with the same role are using '\n                              'this command. The limit is '\n                              '{times} concurrently.'\n}\n\nPERMS_TO_ENGLISH = {\n    'add_reactions': 'Add Reactions',\n    'administrator': 'Administrator',\n    'attach_files': 'Attach Files',\n    'ban_members': 'Ban Members',\n    'change_nickname': 'Change Nickname',\n    'connect': 'Connect',\n    'deafen_members': 'Deafen Members',\n    'embed_links': 'Embed Links',\n    'external_emojis': 'External Emojis',\n    'kick_members': 'Kick Members',\n    'manage_channels': 'Manage Channels',\n    'manage_emojis': 'Manage Emojis',\n    'manage_guild': 'Manage Guild',\n    'manage_messages': 'Manage Messages',\n    'manage_nicknames': 'Manage Nicknames',\n    'manage_permissions': 'Manage Roles',\n    'manage_roles': 'Manage Roles',\n    'manage_webhooks': 'Manage ',\n    'mention_everyone': 'Mention Everyone',\n    'move_members': 'Move Members',\n    'mute_members': 'Mute Members',\n    'priority_speaker': 'Priority Speaker',\n    'read_message_history': 'Read Message History',\n    'read_messages': 'Read Messages',\n    'send_messages': 'Send Messages',\n    'send_tts_messages': 'Send TTS Messages',\n    'speak': 'Speak',\n    'stream': 'Stream',\n    'use_external_emojis': 'External Emojis',\n    'use_voice_activation': 'Voice Activation',\n    'view_audit_log': 'View Audit Log',\n    'view_channel': 'Read Messages',\n    'view_guild_insights': 'View Guild Insights'\n}\n\n\nclass CommandErrorCooldown:\n    \"\"\"Maps cooldowns to specific errors.\n\n    Args:\n        errors_to_cooldowns (Dictionary[commands.CommandError, Optional[Tuple[int, int, commands.BucketType]]]):\n            A mapping of errors to CooldownMapping arguments.\n            the value can be None to use default parameters.\n\n    \"\"\"\n\n    __slots__ = ('error_mapping',)\n\n    DEFAULT_COOLDOWN = (1, 10, commands.BucketType.user)\n\n    def __init__(self, errors_to_cooldowns):\n        from_cooldown = commands.CooldownMapping.from_cooldown\n        self.error_mapping = {\n            err: from_cooldown(*args) if args is not None\n                 else from_cooldown(*self.DEFAULT_COOLDOWN)\n            for err, args in errors_to_cooldowns.items()\n        }\n\n    def check_user(self, ctx, error):\n        mapping = self.error_mapping.get(type(error))\n        if mapping is None:\n            return False\n        return mapping.update_rate_limit(ctx.message)\n\n\nERRORS_TO_LIMIT_COOLDOWN_MAPPING = {\n    commands.BotMissingPermissions: None,\n    commands.BotMissingAnyRole: None,\n    commands.BotMissingRole: None,\n    commands.CommandOnCooldown: None,\n    commands.DisabledCommand: None,\n    commands.MaxConcurrencyReached: None,\n    commands.MissingAnyRole: None,\n    commands.MissingPermissions: None,\n    commands.MissingRole: None,\n    commands.NoPrivateMessage: None,\n    commands.NotOwner: None,\n    commands.UserInputError: (5, 30, commands.BucketType.user),\n    checks.UserOnCooldown: (1, 5, commands.BucketType.user),\n    discord.Forbidden: (1, 5, commands.BucketType.user),\n}\nERRORS_TO_LIMIT = tuple(ERRORS_TO_LIMIT_COOLDOWN_MAPPING)\ncommand_error_limiter = CommandErrorCooldown(ERRORS_TO_LIMIT_COOLDOWN_MAPPING)\n\n\ndef convert_perms_to_english(perms):\n    \"\"\"Run through a list of permissions and convert them into\n    user-friendly representations.\n    \"\"\"\n    new_perms = []\n\n    for p in perms:\n        eng = PERMS_TO_ENGLISH.get(p)\n        if eng is not None:\n            new_perms.append(eng)\n\n    return new_perms\n\n\ndef get_denied_message():\n    return random.choice(settings.get_setting('deniedmessages'))\n\n\n# Events\nasync def on_connect():\n    print(time.strftime(\n        'Connection: Connected to Discord, %c',\n        time.localtime()))\n\n\nasync def on_disconnect():\n    print(time.strftime(\n        'Connection: Lost connection to Discord, %c',\n        time.localtime()))\n\n\nasync def on_ready():\n    s = time.strftime(\n        'Bot is ready, %c',\n        time.localtime()\n    )\n    line = '-' * len(s)\n    print(s, line, sep='\\n')\n\n\nasync def on_resumed():\n    print(time.strftime(\n        'Connection: Reconnected to Discord, %c',\n        time.localtime()))\n\n\nasync def on_command_error(ctx, error):\n    if isinstance(error, COMMAND_ERROR_IGNORE_EXCEPTIONS):\n        return\n    elif ctx.command.callback.__name__ in COMMAND_ERROR_CALLBACK_BLACKLIST:\n        # command is to be ignored\n        return\n    elif (isinstance(error, ERRORS_TO_LIMIT)\n          or hasattr(error, 'original')\n          and isinstance(error.original, ERRORS_TO_LIMIT)):\n        error_unpacked = getattr(error, 'original', error)\n        if command_error_limiter.check_user(ctx, error_unpacked):\n            # user is rate limited on receiving a particular error\n            return\n\n    # Print error\n    if ctx.guild is not None:\n        # Command invoked in server\n        print(\n            'Command error ({}:{}:{}:\"{}\")\\n  {}: {}'.format(\n                ctx.guild,\n                ctx.channel,\n                ctx.author,\n                ctx.invoked_with,\n                type(error).__name__,\n                error\n        ))\n    else:\n        # Command invoked in DMs\n        print(\n            'Command error (<DM>:{}:\"{}\")\\n  {}: {}'.format(\n                ctx.author, ctx.invoked_with,\n                type(error).__name__, error\n        ))\n\n    # Error message functions\n    def convert_roles(missing_perms):\n        \"Convert IDs in one or more roles into strings.\"\n        def convert(p):\n            if isinstance(p, int):\n                r = ctx.bot.get_role(p)\n                return str(r) if r is not None else p\n            return p\n\n        if isinstance(missing_perms, list):\n            return [convert(p) for p in missing_perms]\n\n        return (convert(missing_perms),)\n\n    def get_command_signature():\n        prefix = ctx.prefix\n        name_signature = ctx.invoked_with\n        arguments = ctx.command.signature\n\n        return f'{prefix}{name_signature} {arguments}'\n\n    def get_concurrency_description(ctx, error):\n        if not ctx.guild and error.per == commands.BucketType.channel:\n            # Use message for member bucket when in DMs\n            description = MAX_CONCURRENCY_DESCRIPTIONS.get(\n                commands.BucketType.member,\n                'This command has currently reached max concurrency.'\n            )\n        else:\n            description = MAX_CONCURRENCY_DESCRIPTIONS.get(\n                error.per,\n                'This command has currently reached max concurrency.'\n            )\n\n        return description.format(\n            here=get_cooldown_here(ctx, error.per),\n            times=inflector.inflect(\n                '{0} plural(\"time\", {0})'.format(\n                    error.number\n                )\n            )\n        )\n\n    def get_cooldown_description(ctx, error):\n        if (    not ctx.guild\n                and error.cooldown.type in (\n                    commands.BucketType.channel,\n                    commands.BucketType.guild)):\n            # in DMs; use member in place of channel\/guild bucket\n            description = COOLDOWN_DESCRIPTIONS.get(\n                commands.BucketType.member, 'This command is on cooldown.'\n            )\n        else:\n            description = COOLDOWN_DESCRIPTIONS.get(\n                error.cooldown.type, 'This command is on cooldown.'\n            )\n\n        return description.format(\n            here=get_cooldown_here(ctx, error.cooldown.type),\n            times=inflector.inflect(\n                '{0} plural(\"time\", {0}) '\n                'every {1} plural(\"second\", {1})'.format(\n                    error.cooldown.rate,\n                    utils.num(error.cooldown.per)\n                )\n            )\n        )\n\n    def get_cooldown_here(ctx, bucket):\n        if ctx.guild:\n            if bucket == commands.BucketType.guild:\n                return 'on this server'\n            return 'in this channel'\n        else:\n            return 'in this DM'\n\n    def missing_x_to_run(x, missing_perms):\n        count = len(missing_perms)\n        if count == 1:\n            return (f'missing the {missing_perms[0]} {x} '\n                    'to run this command.')\n\n        return 'missing {:,} {} to run this command: {}'.format(\n            count, inflector.plural(x), inflector.join(missing_perms)\n        )\n\n    # Send an error message\n    if isinstance(error, commands.BadBoolArgument):\n        # error.param is instance of inspect.Parameter\n        await ctx.send('Expected a boolean answer for parameter '\n                       f'\"{error.param.name}\".\\n'\n                       f'Usage: `{get_command_signature()}`')\n    elif isinstance(error, commands.BotMissingPermissions):\n        await ctx.send(\n            'I am {}'.format(\n                missing_x_to_run(\n                    'permission',\n                    convert_perms_to_english(error.missing_perms)\n                )\n            )\n        )\n    elif isinstance(error, (\n            commands.BotMissingRole,\n            commands.BotMissingAnyRole)):\n        await ctx.send('I am {}'.format(\n            missing_x_to_run('role', convert_roles(error.missing_perms))\n        ))\n    # elif isinstance(error, commands.CommandNotFound):\n    #     Command \"x\" is not found\n    #     await ctx.send('Unknown command: {}'.format(\n    #         error.args[0].split()[1].strip('\"')\n    #     ))\n    #     pass\n    elif isinstance(error, commands.ChannelNotFound):\n        await ctx.send('I cannot find the given channel.')\n    elif isinstance(error, commands.ChannelNotReadable):\n        await ctx.send('I cannot read messages in the channel.')\n    elif isinstance(error, commands.CommandOnCooldown):\n        embed = discord.Embed(\n            color=utils.get_bot_color()\n        ).set_footer(\n            text=inflector.inflect(\n                'You can retry in {0} plural(\"second\", {0}).'.format(\n                    float(f'{error.retry_after:.2g}')\n                )\n            ),\n            icon_url=str(ctx.author.avatar_url)\n        )\n\n        embed.description = get_cooldown_description(ctx, error)\n\n        await ctx.send(embed=embed)\n    elif isinstance(error, commands.DisabledCommand):\n        await ctx.send('This command is currently disabled.')\n    elif isinstance(error, commands.EmojiNotFound):\n        await ctx.send(f'I cannot find the given emoji \"{error.argument}\"')\n    elif isinstance(error, commands.ExpectedClosingQuoteError):\n        await ctx.send('Expected a closing quotation mark.')\n    elif isinstance(error, commands.InvalidEndOfQuotedStringError):\n        await ctx.send('Expected a space after a closing quotation mark.')\n    elif isinstance(error, commands.MaxConcurrencyReached):\n        embed = discord.Embed(\n            color=utils.get_bot_color()\n        ).set_footer(\n            text=get_concurrency_description(ctx, error),\n            icon_url=str(ctx.author.avatar_url)\n        )\n\n        await ctx.send(embed=embed)\n    elif isinstance(error, commands.MessageNotFound):\n        await ctx.send('I cannot find the given message.')\n    elif isinstance(error, commands.MissingRequiredArgument):\n        # error.param is instance of inspect.Parameter\n        await ctx.send(f'Missing argument \"{error.param.name}\"\\n'\n                       f'Usage: `{get_command_signature()}`')\n    elif isinstance(error, commands.MissingPermissions):\n        await ctx.send(\n            'You are {}'.format(\n                missing_x_to_run(\n                    'permission',\n                    convert_perms_to_english(error.missing_perms)\n                )\n            )\n        )\n    elif isinstance(error, (commands.MissingRole,\n                            commands.MissingAnyRole)):\n        await ctx.send('You are {}'.format(\n            missing_x_to_run('role', convert_roles(error.missing_perms))\n        ))\n    elif isinstance(error, commands.NoPrivateMessage):\n        await ctx.send('You must be in a server to use this command.')\n    elif isinstance(error, (\n            commands.NotOwner, checks.InvalidBotOwner,\n            checks.InvalidBotAdmin)):\n        # await ctx.send('This command is for the bot owner only.')\n        await ctx.send(get_denied_message())\n    elif isinstance(error, commands.NSFWChannelRequired):\n        await ctx.send('The given channel must be marked as NSFW.')\n    elif isinstance(error, commands.UnexpectedQuoteError):\n        await ctx.send('Did not expect a quotation mark.')\n    elif isinstance(error, (commands.UserNotFound,\n                            commands.MemberNotFound)):\n        await ctx.send('I cannot find the given user.')\n    elif isinstance(error, commands.UserInputError):\n        # NOTE: This is a superclass of several other errors\n        await ctx.send('Failed to parse your parameters.\\n'\n                       f'Usage: `{get_command_signature()}`')\n    elif isinstance(error, checks.UserOnCooldown):\n        # User has invoked too many commands\n        embed = discord.Embed(\n            color=utils.get_bot_color()\n        ).set_footer(\n            text=inflector.inflect(\n                'You are using commands too frequently. '\n                'You can retry in {0:.2g} plural(\"second\", {0}).'.format(\n                    error.retry_after)\n            ),\n            icon_url=str(ctx.author.avatar_url)\n        )\n\n        await ctx.send(embed=embed)\n    elif (isinstance(error, commands.CommandInvokeError)\n          and isinstance(error.original, discord.Forbidden)\n          and error.original.code == 50007):\n        # Cannot send messages to this user\n        await ctx.send('I tried DMing you but you have your DMs '\n                       'disabled for this server.')\n    else:\n        raise error\n\n\ndef setup(bot):\n    for handler in handlers:\n        bot.event(globals()[handler])\n"},"\/bot\/settings.py":{"changes":[{"diff":"\n         'message_size': 2000,\n         'message_limit': 1,\n         'owner_ids': [153551102443257856, ],\n-        'print_error_mode': 'raise'  # raise, print, None\n+        'print_error_mode': 'raise',  # raise, print, None\n+        'slash_guild_ids': []\n     }\n \n   ","add":2,"remove":1,"filename":"\/bot\/settings.py","badparts":["        'print_error_mode': 'raise'  # raise, print, None"],"goodparts":["        'print_error_mode': 'raise',  # raise, print, None","        'slash_guild_ids': []"]}],"source":"\n\"\"\"Provides functions to interact with the configuration file. All results are cached into memory on first access. On overwrite_setting(which includes update_settings and write_setting), the cache is cleared. ====================================================================== Function Arguments: Description ====================================================================== clear_cache (): Clears the settings cache. get_setting (key): Get a specific setting. load_settings (): Return the config file as a dictionary. overwrite_settings (settings: dict): Overwrite the config file. setup (): Initialize the config file. update_settings (settings: dict): Update the config file. write_setting (key, value): Write a new value to a given setting. ====================================================================== \"\"\" import json import pathlib SETTINGS_LOCATION='settings.json' _settings_cache=None def clear_cache(): \"\"\"Clears the settings cache.\"\"\" global _settings_cache _settings_cache=None def load_settings(): \"\"\"Return the config file as a dictionary. Missing settings file is handled but not corrupt settings. \"\"\" global _settings_cache if _settings_cache is not None: return _settings_cache if not pathlib.Path(SETTINGS_LOCATION).exists(): setup() with open(SETTINGS_LOCATION) as f: config=json.load(f) _settings_cache=config return config def get_setting(key): \"\"\"Get a specific setting from the config file.\"\"\" config=load_settings() return config[key] def overwrite_settings(settings: dict): \"\"\"Overwrite the current config file with new settings.\"\"\" with open(SETTINGS_LOCATION, mode='w') as f: json.dump( settings, f, indent=4, sort_keys=True ) clear_cache() def update_settings(settings: dict): \"\"\"Update the current config file with new settings.\"\"\" config=load_settings() config.update(obj) overwrite_settings(config) def write_setting(key, value): \"\"\"Write a new value to a given setting in the config file.\"\"\" config=load_settings() config[key]=value overwrite_settings(config) def setup(): \"\"\"Generate\/verify the settings and return a dictionary of it.\"\"\" SETTINGS_DEFAULT={ 'admin_ids':[153551102443257856,], 'bgtask_ListGuildsDelay': 600, 'bgtask_RandomPresenceMinDelay': 180, 'bgtask_RandomPresenceMaxDelay': 600, 'bgtask_RandomPresenceOnStartup': True, 'bgtask_RandomPresenceRandomStatusChance': 30, 'bgtask_RandomPresences':[ {'activity': 'watching', 'title': 'my existential crisis'}, {'activity': 'playing', 'title': 'nothing'}, {'status': 'away', 'activity': 'watching', 'title': 'something'}, {'status': 'dnd', 'activity': 'playing', 'title': 'against a hacker'}, {'activity': 'listening', 'title': 'ASMR'}, {'activity': 'watching', 'title': 'you'}, {'activity': 'watching', 'title': 'YouTube'}, {'activity': 'watching', 'title': 'humanity'}, {'activity': 'playing', 'title': 'foobar2000'}, {'activity': 'watching', 'title': 'Jon Rick'}, {'activity': 'listening', 'title': 'a lecture'}, {'activity': 'listening', 'title': 'Audibill'}, {'activity': 'watching', 'title': 'Mitchell Keeves'}, {'activity': 'listening', 'title': \"spiderdan's pizza\"}, {'activity': 'playing', 'title': 'with a plane'}, {'activity': 'watching', 'title': 'animated toys'}, {'activity': 'playing', 'title': 'poker'}, {'activity': 'watching', 'title': 'Skillzhare'}, {'activity': 'listening', 'title': 'beep bop behop'}, {'activity': 'listening', 'title': 'The Real Folk Blues'}, {'activity': 'playing', 'title': 'as a car'}, {'activity': 'watching', 'title': 'my creator'}, {'activity': 'playing', 'title': 'with a rocket'}, {'activity': 'playing', 'title': 'on a computer'}, {'activity': 'playing', 'title': 'dueturn.py'}, {'activity': 'playing', 'title': 'with an arm'}, {'activity': 'watching', 'title': 'Copper Man'}, {'activity': 'listening', 'title': 'paint drying'}, {'activity': 'playing', 'title': 'cavejohnsonremaster.py'}, {'activity': 'watching', 'title': 'Wick and Warty'}, {\"activity\": \"competing\", \"title\": \"a battle royale\"}, {\"activity\": \"competing\", \"title\": \"YouTube comments section\"}, {\"activity\": \"competing\", \"title\": \"a deathmatch\"}, {\"activity\": \"competing\", \"title\": \"the arcade\"}, {\"activity\": \"competing\", \"title\": \"the FBI's firewall\"}, ], 'bgtask_TimestampDelay': 300, 'bot_color': '0xFF8002', 'default_StreamingURL': 'https:\/\/www.twitch.tv\/thegamecracks', 'default_prefix': ';', 'deniedmessages':[ 'Nope.', \"Not havin' it.\", 'Denied.', 'Negative.', 'Uh, no.', 'Sorry, no.', 'No go.', 'Ineffective.', ], 'message_size': 2000, 'message_limit': 1, 'owner_ids':[153551102443257856,], 'print_error_mode': 'raise' } def generate_settings(filename): print(f'Writing new settings to{filename}') with open(filename, 'w') as f: json.dump( SETTINGS_DEFAULT, f, indent=4, sort_keys=True ) print('Generated new settings') def backup(): fn=SETTINGS_LOCATION +'.backup' print(f'Backing up settings to{fn}') with open(fn, 'w') as backup: with open(SETTINGS_LOCATION) as broken: for line in iter(broken.readline, ''): backup.write(line) print('Backed up settings') try: with open(SETTINGS_LOCATION) as f: settings=json.load(f) except FileNotFoundError: print('Could not find settings file') generate_settings(SETTINGS_LOCATION) except json.decoder.JSONDecodeError as e: print(f'Failed to parse the settings file:{e}') backup() generate_settings(SETTINGS_LOCATION) else: backed_up=False for k, v in SETTINGS_DEFAULT.items(): if k not in settings: print(f'Missing key{k!r} in settings, adding default') if not backed_up: backup() backed_up=True settings[k]=v else: if backed_up: overwrite_settings(settings) else: print('Verified settings integrity') return settings ","sourceWithComments":"\"\"\"Provides functions to interact with the configuration file.\n\nAll results are cached into memory on first access.\n\nOn overwrite_setting (which includes update_settings and write_setting),\nthe cache is cleared.\n\n==================  ====================================================\nFunction            Arguments: Description\n==================  ====================================================\nclear_cache         (): Clears the settings cache.\nget_setting         (key): Get a specific setting.\nload_settings       (): Return the config file as a dictionary.\noverwrite_settings  (settings: dict): Overwrite the config file.\nsetup               (): Initialize the config file.\nupdate_settings     (settings: dict): Update the config file.\nwrite_setting       (key, value): Write a new value to a given setting.\n==================  ====================================================\n\"\"\"\nimport json\nimport pathlib\n\nSETTINGS_LOCATION = 'settings.json'\n\n_settings_cache = None\n\n\ndef clear_cache():\n    \"\"\"Clears the settings cache.\"\"\"\n    global _settings_cache\n    _settings_cache = None\n\n\ndef load_settings():\n    \"\"\"Return the config file as a dictionary.\n\n    Missing settings file is handled but not corrupt settings.\n\n    \"\"\"\n    global _settings_cache\n    if _settings_cache is not None:\n        return _settings_cache\n\n    if not pathlib.Path(SETTINGS_LOCATION).exists():\n        setup()\n    with open(SETTINGS_LOCATION) as f:\n        config = json.load(f)\n        _settings_cache = config\n        return config\n\n\ndef get_setting(key):\n    \"\"\"Get a specific setting from the config file.\"\"\"\n    config = load_settings()\n    return config[key]\n\n\ndef overwrite_settings(settings: dict):\n    \"\"\"Overwrite the current config file with new settings.\"\"\"\n    with open(SETTINGS_LOCATION, mode='w') as f:\n        json.dump(\n            settings, f,\n            indent=4,\n            sort_keys=True\n        )\n    clear_cache()\n\n\ndef update_settings(settings: dict):\n    \"\"\"Update the current config file with new settings.\"\"\"\n    config = load_settings()\n    config.update(obj)\n    overwrite_settings(config)\n\n\ndef write_setting(key, value):\n    \"\"\"Write a new value to a given setting in the config file.\"\"\"\n    config = load_settings()\n    config[key] = value\n    overwrite_settings(config)\n\n\ndef setup():\n    \"\"\"Generate\/verify the settings and return a dictionary of it.\"\"\"\n    SETTINGS_DEFAULT = {\n        'admin_ids': [153551102443257856, ],\n        'bgtask_ListGuildsDelay': 600,\n        'bgtask_RandomPresenceMinDelay': 180,\n        'bgtask_RandomPresenceMaxDelay': 600,\n        'bgtask_RandomPresenceOnStartup': True,\n        'bgtask_RandomPresenceRandomStatusChance': 30,\n        'bgtask_RandomPresences': [\n            {'activity': 'watching',\n             'title': 'my existential crisis'},\n            {'activity': 'playing',\n             'title': 'nothing'},\n            {'status': 'away', 'activity': 'watching',\n             'title': 'something'},\n            {'status': 'dnd', 'activity': 'playing',\n             'title': 'against a hacker'},\n            {'activity': 'listening',\n             'title': 'ASMR'},\n            {'activity': 'watching',\n             'title': 'you'},\n            {'activity': 'watching',\n             'title': 'YouTube'},\n            {'activity': 'watching',\n             'title': 'humanity'},\n            {'activity': 'playing',\n             'title': 'foobar2000'},\n            {'activity': 'watching',\n             'title': 'Jon Rick'},\n            {'activity': 'listening',\n             'title': 'a lecture'},\n            {'activity': 'listening',\n             'title': 'Audibill'},\n            {'activity': 'watching',\n             'title': 'Mitchell Keeves'},\n            {'activity': 'listening',\n             'title': \"spiderdan's pizza\"},\n            {'activity': 'playing',\n             'title': 'with a plane'},\n            {'activity': 'watching',\n             'title': 'animated toys'},\n            {'activity': 'playing',\n             'title': 'poker'},\n            {'activity': 'watching',\n             'title': 'Skillzhare'},\n            {'activity': 'listening',\n             'title': 'beep bop behop'},\n            {'activity': 'listening',\n             'title': 'The Real Folk Blues'},\n            {'activity': 'playing',\n             'title': 'as a car'},\n            {'activity': 'watching',\n             'title': 'my creator'},\n            {'activity': 'playing',\n             'title': 'with a rocket'},\n            {'activity': 'playing',\n             'title': 'on a computer'},\n            {'activity': 'playing',\n             'title': 'dueturn.py'},\n            {'activity': 'playing',\n             'title': 'with an arm'},\n            {'activity': 'watching',\n             'title': 'Copper Man'},\n            {'activity': 'listening',\n             'title': 'paint drying'},\n            {'activity': 'playing',\n             'title': 'cavejohnsonremaster.py'},\n            {'activity': 'watching',\n             'title': 'Wick and Warty'},\n            {\"activity\": \"competing\",\n             \"title\": \"a battle royale\"},\n            {\"activity\": \"competing\",\n             \"title\": \"YouTube comments section\"},\n            {\"activity\": \"competing\",\n             \"title\": \"a deathmatch\"},\n            {\"activity\": \"competing\",\n             \"title\": \"the arcade\"},\n            {\"activity\": \"competing\",\n             \"title\": \"the FBI's firewall\"},\n            # {'activity': 'playing',\n            #  'title': ''},\n            # {'status': 'online', 'activity': 'playing',\n            #  'title': ''},\n        ],\n        'bgtask_TimestampDelay': 300,\n        'bot_color': '0xFF8002',\n        'default_StreamingURL': 'https:\/\/www.twitch.tv\/thegamecracks',\n        'default_prefix': ';',\n        'deniedmessages': [\n            'Nope.',\n            \"Not havin' it.\",\n            'Denied.',\n            'Negative.',\n            'Uh, no.',\n            'Sorry, no.',\n            'No go.',\n            'Ineffective.',\n        ],\n        'message_size': 2000,\n        'message_limit': 1,\n        'owner_ids': [153551102443257856, ],\n        'print_error_mode': 'raise'  # raise, print, None\n    }\n\n    def generate_settings(filename):\n        print(f'Writing new settings to {filename}')\n        with open(filename, 'w') as f:\n            json.dump(\n                SETTINGS_DEFAULT, f,\n                indent=4,\n                sort_keys=True\n            )\n        print('Generated new settings')\n\n    def backup():\n        fn = SETTINGS_LOCATION + '.backup'\n        print(f'Backing up settings to {fn}')\n        with open(fn, 'w') as backup:\n            with open(SETTINGS_LOCATION) as broken:\n                for line in iter(broken.readline, ''):\n                    backup.write(line)\n        print('Backed up settings')\n\n    # Verify integrity of settings file\n    try:\n        # Check that file can be found and parsed\n        with open(SETTINGS_LOCATION) as f:\n            settings = json.load(f)\n    except FileNotFoundError:\n        print('Could not find settings file')\n        generate_settings(SETTINGS_LOCATION)\n    except json.decoder.JSONDecodeError as e:\n        print(f'Failed to parse the settings file: {e}')\n        backup()\n        generate_settings(SETTINGS_LOCATION)\n    else:\n        # Check that every key in SETTINGS_DEFAULT exists in the file\n        # If a key is missing, add it\n        backed_up = False\n        for k, v in SETTINGS_DEFAULT.items():\n            if k not in settings:\n                print(f'Missing key {k!r} in settings, adding default')\n                if not backed_up:\n                    backup()\n                    backed_up = True\n                settings[k] = v\n        else:\n            if backed_up:\n                overwrite_settings(settings)\n            else:\n                print('Verified settings integrity')\n\n            return settings\n"},"\/bot\/utils.py":{"changes":[{"diff":"\n+import contextlib\n import datetime\n import decimal\n import itertools  # rawincount()\n import math\n import pathlib    # exception_message()\n-import string\n import sys        # exception_message()\n import traceback  # exception_message()\n+from typing import List, Iterable, Union, Optional\n \n from dateutil.relativedelta import relativedelta\n import discord\n+from discord.ext.commands.view import StringView\n import inflect\n+import prettify_exceptions\n \n from bot import settings\n from bot.other import discordlogger\n \n inflector = inflect.engine()\n \n+logger = discordlogger.get_logger()\n+\n # Whitelist Digits, Decimal Point, Main Arithmetic,\n # Order of Operations, Function Arithmetic (modulus,),\n # Binary Arithmetic (bitwise NOT, OR, AND, XOR, shifts)\n # Scientific Notation, and Imaginary Part for evaluate command\n-CLIENT_EVALUATE_WHITELIST = set(\n-    string.digits\n+SAFE_EVAL_WHITELIST = frozenset(\n+    '0123456789'\n     + '.'\n     + '*\/+-'\n     + '%'\n","add":8,"remove":3,"filename":"\/bot\/utils.py","badparts":["import string","CLIENT_EVALUATE_WHITELIST = set(","    string.digits"],"goodparts":["import contextlib","from typing import List, Iterable, Union, Optional","from discord.ext.commands.view import StringView","import prettify_exceptions","logger = discordlogger.get_logger()","SAFE_EVAL_WHITELIST = frozenset(","    '0123456789'"," '.'"," '*\/+-'"," '%'"]},{"diff":"\n )\n \n-logger = discordlogger.get_logger()\n-\n \n def convert_base(base_in: int, base_out: int, n,\n-        mapping='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n+                 mapping=('0123456789'\n+                          'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n+                          'abcdefghijklmnopqrstuvwxyz-_')):\n     \"\"\"Converts a number to another base.\n     Accepted bases are 2, 36, and all in-between.\n     Base 36 uses 0-9 and a-z (case-insensitive).\n","add":3,"remove":3,"filename":"\/bot\/utils.py","badparts":["logger = discordlogger.get_logger()","        mapping='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'):"],"goodparts":["                 mapping=('0123456789'","                          'ABCDEFGHIJKLMNOPQRSTUVWXYZ'","                          'abcdefghijklmnopqrstuvwxyz-_')):"]},{"diff":"\n     elif min(base_in, base_out) < 2:\n         raise ValueError('Given base is less than 2.')\n \n-    if base_out == 10 and base_in <= 36 \\\n-           and mapping == '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n-        # int() already represents in base 10, use that for optimization\n-        # unless base_in is larger than int()'s maximum base allowed\n-        # or the mapping is different that what int() uses\n-        # (\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n+    mapping_normal = mapping.startswith('0123456789ABCDEFGHJIKLMNOPQRSTUVWXYZ')\n+\n+    if base_out == 10 and base_in <= 36 and mapping_normal:\n+        # use int() for optimization\n         return int(n, base_in)\n \n-    if base_in <= 36 and mapping:\n+    if base_in <= 36 and mapping_normal:\n         n_int = int(n, base_in)\n     else:\n         n_int = 0\n","add":5,"remove":7,"filename":"\/bot\/utils.py","badparts":["    if base_out == 10 and base_in <= 36 \\","           and mapping == '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ':","    if base_in <= 36 and mapping:"],"goodparts":["    mapping_normal = mapping.startswith('0123456789ABCDEFGHJIKLMNOPQRSTUVWXYZ')","    if base_out == 10 and base_in <= 36 and mapping_normal:","    if base_in <= 36 and mapping_normal:"]},{"diff":"\n     return relativedelta(current, prior)\n \n \n-def fuzzy_match_word(s, choices, return_possible=False):\n-    \"\"\"Matches a string with a given evidence by token (case-insensitive).\n+def fuzzy_match_word(s, choices: Iterable[str], return_possible=False) \\\n+        -> Optional[Union[str, List[str]]]:\n+    \"\"\"Matches a string to given choices by token (case-insensitive).\n \n     Choices can be matched even if the given string has tokens out of order:\n         >>> fuzzy_match_word('orb ghost', ['Ghost Orb', 'Ghost Writing'])\n","add":3,"remove":2,"filename":"\/bot\/utils.py","badparts":["def fuzzy_match_word(s, choices, return_possible=False):","    \"\"\"Matches a string with a given evidence by token (case-insensitive)."],"goodparts":["def fuzzy_match_word(s, choices: Iterable[str], return_possible=False) \\","        -> Optional[Union[str, List[str]]]:","    \"\"\"Matches a string to given choices by token (case-insensitive)."]},{"diff":"\n             a list of those matches will be returned.\n \n     Returns:\n-        None\n+        None: Returned if there are multiple matches and\n+              `return_possible` is False.\n         str\n-        List[str]:\n-            Returned if `return_possible` and there are multiple matches.\n+        List[str]: Returned if there are multiple matches and\n+                   `return_possible` is True.\n \n     \"\"\"\n-    possible = choices\n+    possible = list(choices) if not isinstance(choices, list) else choices\n     possible_lower = [s.lower() for s in possible]\n \n     # See if the phrase already exists\n","add":5,"remove":4,"filename":"\/bot\/utils.py","badparts":["        None","        List[str]:","            Returned if `return_possible` and there are multiple matches.","    possible = choices"],"goodparts":["        None: Returned if there are multiple matches and","              `return_possible` is False.","        List[str]: Returned if there are multiple matches and","                   `return_possible` is True.","    possible = list(choices) if not isinstance(choices, list) else choices"]},{"diff":"\n \n \n def get_bot_color():\n-    \"Return the bot's color from settings.\"\n+    \"\"\"Return the bot's color from settings.\"\"\"\n     return int(settings.get_setting('bot_color'), 16)\n \n \n def get_user_color(\n         user, default_color=None):\n-    \"Return a user's role color if they are in a guild, else default_color.\"\n+    \"\"\"Return a user's role color if they are in a guild, else default_color.\"\"\"\n     return (\n         user.color if isinstance(user, discord.Member)\n         else default_color if default_color is not None\n","add":2,"remove":2,"filename":"\/bot\/utils.py","badparts":["    \"Return the bot's color from settings.\"","    \"Return a user's role color if they are in a guild, else default_color.\""],"goodparts":["    \"\"\"Return the bot's color from settings.\"\"\"","    \"\"\"Return a user's role color if they are in a guild, else default_color.\"\"\""]}],"source":"\nimport datetime import decimal import itertools import math import pathlib import string import sys import traceback from dateutil.relativedelta import relativedelta import discord import inflect from bot import settings from bot.other import discordlogger inflector=inflect.engine() CLIENT_EVALUATE_WHITELIST=set( string.digits +'.' +'*\/+-' +'%' +'~|&^<>' +'()' +'e' +'E' +'j' ) logger=discordlogger.get_logger() def convert_base(base_in: int, base_out: int, n, mapping='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'): \"\"\"Converts a number to another base. Accepted bases are 2, 36, and all in-between. Base 36 uses 0-9 and a-z(case-insensitive). Decimals cannot be converted. Args: base_in(int): The number's base. base_out(int): The base to output as. n(int): The number to convert. mapping(str): The string mapping. \"\"\" if max(base_in, base_out) > len(mapping): raise ValueError(f'Given base is greater than{len(mapping)}.') elif min(base_in, base_out) < 2: raise ValueError('Given base is less than 2.') if base_out==10 and base_in <=36 \\ and mapping=='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ': return int(n, base_in) if base_in <=36 and mapping: n_int=int(n, base_in) else: n_int=0 for place, i_val in enumerate(n[::-1]): n_int +=mapping.index(i_val) * base_in ** place n_max_place=int(math.log(n_int, base_out)) n_out='' for i in range(n_max_place, -1, -1): i_val=n_int \/\/ base_out ** i n_out +=mapping[i_val] n_int -=base_out ** i * i_val return n_out def datetime_difference(current, prior): \"\"\"Return a relativedelta of current -prior.\"\"\" return relativedelta(current, prior) def fuzzy_match_word(s, choices, return_possible=False): \"\"\"Matches a string with a given evidence by token(case-insensitive). Choices can be matched even if the given string has tokens out of order: >>> fuzzy_match_word('orb ghost',['Ghost Orb', 'Ghost Writing']) 'Ghost Orb' `choices` does not get mutated. Args: s(str) choices(Iterable[str]) return_possible(bool): If this is True and there are multiple matches, a list of those matches will be returned. Returns: None str List[str]: Returned if `return_possible` and there are multiple matches. \"\"\" possible=choices possible_lower=[s.lower() for s in possible] try: i=possible_lower.index(s.lower()) return possible[i] except ValueError: pass length=len(s) for word in s.lower().split(): new=[] for p, pl in zip(possible, possible_lower): if word in pl: new.append(p) possible=new count=len(possible) if count==0: return elif count==1: return possible[0] possible_lower=[s.lower() for s in possible] return possible if return_possible and possible else None def timedelta_string( diff, years=True, months=True, weeks=True, days=True, hours=True, minutes=True, seconds=True): \"\"\"Return a string representation of a timedelta. Can show years, months, weeks, day, hours, and minutes. \"\"\" def s(n): return 's' if n !=1 else '' message=[] if diff.years and years: message.append(f\"{diff.years:,} Year{s(diff.years)}\") if diff.months and months: message.append(f\"{diff.months:,} Month{s(diff.months)}\") if diff.weeks and weeks: message.append(f\"{diff.weeks:,} Week{s(diff.weeks)}\") if diff.days and days: message.append(f\"{diff.days:,} Day{s(diff.days)}\") if diff.hours and hours: message.append(f\"{diff.hours:,} Hour{s(diff.hours)}\") if diff.minutes and minutes: message.append(f\"{diff.minutes:,} Minute{s(diff.minutes)}\") if diff.seconds and seconds: message.append(f\"{diff.seconds:,} Second{s(diff.seconds)}\") return inflector.join(message) def dec_addi(x, y): \"\"\"Convert x and y into decimal.Decimal and return their sum.\"\"\" return decimal.Decimal(x) +decimal.Decimal(y) def dec_subi(x, y): \"\"\"Convert x and y into decimal.Decimal and return their difference.\"\"\" return decimal.Decimal(x) -decimal.Decimal(y) def dec_muli(x, y): \"\"\"Convert x and y into decimal.Decimal and return their product.\"\"\" return decimal.Decimal(x) +decimal.Decimal(y) def dec_divi(x, y): \"\"\"Convert x and y into decimal.Decimal and return their quotient.\"\"\" return decimal.Decimal(x) \/ decimal.Decimal(y) def dec_divf(x, y): \"\"\"Convert x and y into decimal.Decimal and return their floor quotient.\"\"\" return decimal.Decimal(x) \/\/ decimal.Decimal(y) def dec_pow(x, y): \"\"\"Raise x to the power of y.\"\"\" return decimal.Decimal(x) ** decimal.Decimal(y) def exception_message( exc_type=None, exc_value=None, exc_traceback=None, header: str='', log_handler=logger) -> str: \"\"\"Create a message out of the last exception handled by try\/except. Args: header(Optional[str]): The header to place above the message. log_handler(Optional): The logger to run the exception() method on. Returns: str: The string containing the exception message. \"\"\" if exc_type is None and exc_value is None and exc_traceback is None: exc_type, exc_value, exc_traceback=sys.exc_info() elif exc_type is None or exc_value is None or exc_traceback is None: raise ValueError('An exception type\/value\/traceback was passed ' 'but is missing the other values') msg='' if header: msg='{:=^{length}}\\n'.format( header, length=len(header) * 2 +len(header) % 2) if log_handler is not None: log_handler.exception(msg) for frame in traceback.extract_tb(exc_traceback): if frame.name=='<module>': break msg +=f'Frame{frame.name!r}\\n' project_path=pathlib.Path().resolve() trace_path=pathlib.Path(frame.filename) try: filename=trace_path.relative_to(project_path) except ValueError: filename=trace_path msg +=f'Within file \"{filename}\"\\n' msg +=f'at line number{frame.lineno}:\\n' msg +=f' {frame.line}\\n' msg +=f'\\n{exc_type.__name__}:{exc_value}' return msg def gcd(a, b='high'): \"\"\"Calculate the Greatest Common Divisor of a and b. Unless b==0, the result will have the same sign as b(so that when b is divided by it, the result comes out positive). If b is low, calculates the low divisor of a other than itself. If b is high, calculates the highest divisor of a other than itself. \"\"\" if b=='low' or b=='high': lookUpTo=math.ceil(math.sqrt(a)) for i in range(2 if b=='low' else lookUpTo, lookUpTo +1 if b=='low' else 1, 1 if b=='low' else -1): if a % i==0: a=i if b=='low' else a \/\/ i break else: while b: a, b=b, a % b return a def get_bot_color(): \"Return the bot's color from settings.\" return int(settings.get_setting('bot_color'), 16) def get_user_color( user, default_color=None): \"Return a user's role color if they are in a guild, else default_color.\" return( user.color if isinstance(user, discord.Member) else default_color if default_color is not None else get_bot_color() ) def num(x): \"\"\"Convert an object into either a int, float, or complex in that order.\"\"\" try: if hasattr(x, 'is_integer') and not x.is_integer(): raise ValueError return int(x) except Exception: try: return float(x) except Exception: n=complex(x) if n.imag==0: return num(n.real) return complex(num(n.real), num(n.imag)) def parse_status(status='online'): status=status.casefold() if status in('online', 'green', 'on', 'active'): return discord.Status.online elif status in('idle', 'yellow', 'away', 'afk'): return discord.Status.idle elif status in('dnd', 'red', 'donotdisturb'): return discord.Status.dnd elif status in('invisible', 'grey', 'gray', 'black', 'offline', 'off'): return discord.Status.invisible else: raise ValueError('Unknown status') def prime(n): \"\"\"Checks if a number is prime.\"\"\" return True if gcd(n)==1 else False def rawincount(filename): \"\"\"Returns the number of lines in a file. Citation needed. \"\"\" with open(filename, 'rb') as f: bufgen=itertools.takewhile(lambda x: x,(f.raw.read(1024*1024) for _ in itertools.repeat(None))) return sum( buf.count(b'\\n') for buf in bufgen) +1 def safe_eval(x): \"\"\"Filters a string before evaluating. Uses CLIENT_EVALUATE_WHITELIST as the filter.\"\"\" return num(eval( ''.join([char for char in x if char in CLIENT_EVALUATE_WHITELIST]) )) def truncate_message( message, size=2000, size_lines=None, placeholder='[...]'): \"\"\"Truncate a message to a given amount of characters or lines. This should be used when whitespace needs to be retained as `textwrap.shorten` will collapse whitespace. Message is stripped of whitespace. \"\"\" message=message.strip() in_code_block=0 lines=message.split('\\n') chars=0 for line_i, line in enumerate(lines): if size_lines is not None and line_i==size_lines: break in_code_block=(in_code_block +line.count('```')) % 2 new_chars=chars +len(line) if new_chars > size: words=line.split(' ') last_word=len(words) -1 line_chars=chars for word_i, word in enumerate(words): new_line_chars=line_chars +len(word) if new_line_chars >( size -len(placeholder) -in_code_block * 3): break if word_i !=last_word: new_line_chars +=1 line_chars=new_line_chars else: raise RuntimeError(f'line{line_i:,} exceeded max size but ' 'failed to determine where to ' 'truncate the line') if word_i==0: break else: line=' '.join(words[:word_i] +[placeholder]) return( '\\n'.join(lines[:line_i] +[line]) +'```' * in_code_block ) else: chars=new_chars else: return message return( '\\n'.join(lines[:line_i]) +f'{placeholder}' +'```' * in_code_block ) def print_error(func): \"\"\"Decorate error handlers to print the error to console before running the handler function.\"\"\" async def wrapper(*args, **kwargs): logger.exception(f'In{func.__name__}, this error was raised:') mode=settings.get_setting('print_error_mode') if mode=='raise': print(f'In{func.__name__}, this error was raised:') await func(*args, **kwargs) raise elif mode=='print': print(f'In{func.__name__}, this error was raised:') print('\\t' +repr(args[2])) await func(*args, **kwargs) return wrapper ","sourceWithComments":"import datetime\nimport decimal\nimport itertools  # rawincount()\nimport math\nimport pathlib    # exception_message()\nimport string\nimport sys        # exception_message()\nimport traceback  # exception_message()\n\nfrom dateutil.relativedelta import relativedelta\nimport discord\nimport inflect\n\nfrom bot import settings\nfrom bot.other import discordlogger\n\ninflector = inflect.engine()\n\n# Whitelist Digits, Decimal Point, Main Arithmetic,\n# Order of Operations, Function Arithmetic (modulus,),\n# Binary Arithmetic (bitwise NOT, OR, AND, XOR, shifts)\n# Scientific Notation, and Imaginary Part for evaluate command\nCLIENT_EVALUATE_WHITELIST = set(\n    string.digits\n    + '.'\n    + '*\/+-'\n    + '%'\n    + '~|&^<>'\n    + '()'\n    + 'e'\n    + 'E'\n    + 'j'\n)\n\nlogger = discordlogger.get_logger()\n\n\ndef convert_base(base_in: int, base_out: int, n,\n        mapping='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n    \"\"\"Converts a number to another base.\n    Accepted bases are 2, 36, and all in-between.\n    Base 36 uses 0-9 and a-z (case-insensitive).\n    Decimals cannot be converted.\n\n    Args:\n        base_in (int): The number's base.\n        base_out (int): The base to output as.\n        n (int): The number to convert.\n        mapping (str): The string mapping.\n\n    \"\"\"\n    if max(base_in, base_out) > len(mapping):\n        raise ValueError(f'Given base is greater than {len(mapping)}.')\n    elif min(base_in, base_out) < 2:\n        raise ValueError('Given base is less than 2.')\n\n    if base_out == 10 and base_in <= 36 \\\n           and mapping == '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        # int() already represents in base 10, use that for optimization\n        # unless base_in is larger than int()'s maximum base allowed\n        # or the mapping is different that what int() uses\n        # (\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        return int(n, base_in)\n\n    if base_in <= 36 and mapping:\n        n_int = int(n, base_in)\n    else:\n        n_int = 0\n        for place, i_val in enumerate(n[::-1]):\n            n_int += mapping.index(i_val) * base_in ** place\n    n_max_place = int(math.log(n_int, base_out))\n    n_out = ''\n\n    # For every digit place\n    for i in range(n_max_place, -1, -1):\n        i_val = n_int \/\/ base_out ** i\n        n_out += mapping[i_val]\n        n_int -= base_out ** i * i_val\n\n    return n_out\n\n\ndef datetime_difference(current, prior):\n    \"\"\"Return a relativedelta of current - prior.\"\"\"\n    return relativedelta(current, prior)\n\n\ndef fuzzy_match_word(s, choices, return_possible=False):\n    \"\"\"Matches a string with a given evidence by token (case-insensitive).\n\n    Choices can be matched even if the given string has tokens out of order:\n        >>> fuzzy_match_word('orb ghost', ['Ghost Orb', 'Ghost Writing'])\n        'Ghost Orb'\n\n    `choices` does not get mutated.\n\n    Args:\n        s (str)\n        choices (Iterable[str])\n        return_possible (bool): If this is True and there are multiple matches,\n            a list of those matches will be returned.\n\n    Returns:\n        None\n        str\n        List[str]:\n            Returned if `return_possible` and there are multiple matches.\n\n    \"\"\"\n    possible = choices\n    possible_lower = [s.lower() for s in possible]\n\n    # See if the phrase already exists\n    try:\n        i = possible_lower.index(s.lower())\n        return possible[i]\n    except ValueError:\n        pass\n\n    length = len(s)\n    for word in s.lower().split():\n        new = []\n\n        for p, pl in zip(possible, possible_lower):\n            if word in pl:\n                new.append(p)\n\n        possible = new\n\n        count = len(possible)\n        if count == 0:\n            return\n        elif count == 1:\n            return possible[0]\n\n        possible_lower = [s.lower() for s in possible]\n\n    return possible if return_possible and possible else None\n\n\ndef timedelta_string(\n        diff,\n        years=True, months=True, weeks=True, days=True,\n        hours=True, minutes=True, seconds=True):\n    \"\"\"Return a string representation of a timedelta.\n\n    Can show years, months, weeks, day, hours, and minutes.\n\n    \"\"\"\n    def s(n):\n        return 's' if n != 1 else ''\n\n    message = []\n    if diff.years and years:\n        message.append(f\"{diff.years:,} Year{s(diff.years)}\")\n    if diff.months and months:\n        message.append(f\"{diff.months:,} Month{s(diff.months)}\")\n    if diff.weeks and weeks:\n        message.append(f\"{diff.weeks:,} Week{s(diff.weeks)}\")\n    if diff.days and days:\n        message.append(f\"{diff.days:,} Day{s(diff.days)}\")\n    if diff.hours and hours:\n        message.append(f\"{diff.hours:,} Hour{s(diff.hours)}\")\n    if diff.minutes and minutes:\n        message.append(f\"{diff.minutes:,} Minute{s(diff.minutes)}\")\n    if diff.seconds and seconds:\n        message.append(f\"{diff.seconds:,} Second{s(diff.seconds)}\")\n    return inflector.join(message)\n\n\ndef dec_addi(x, y):\n    \"\"\"Convert x and y into decimal.Decimal and return their sum.\"\"\"\n    return decimal.Decimal(x) + decimal.Decimal(y)\n\n\ndef dec_subi(x, y):\n    \"\"\"Convert x and y into decimal.Decimal and return their difference.\"\"\"\n    return decimal.Decimal(x) - decimal.Decimal(y)\n\n\ndef dec_muli(x, y):\n    \"\"\"Convert x and y into decimal.Decimal and return their product.\"\"\"\n    return decimal.Decimal(x) + decimal.Decimal(y)\n\n\ndef dec_divi(x, y):\n    \"\"\"Convert x and y into decimal.Decimal and return their quotient.\"\"\"\n    return decimal.Decimal(x) \/ decimal.Decimal(y)\n\n\ndef dec_divf(x, y):\n    \"\"\"Convert x and y into decimal.Decimal and return their floor quotient.\"\"\"\n    return decimal.Decimal(x) \/\/ decimal.Decimal(y)\n\n\ndef dec_pow(x, y):\n    \"\"\"Raise x to the power of y.\"\"\"\n    return decimal.Decimal(x) ** decimal.Decimal(y)\n\n\ndef exception_message(\n        exc_type=None, exc_value=None, exc_traceback=None,\n        header: str = '', log_handler=logger) -> str:\n    \"\"\"Create a message out of the last exception handled by try\/except.\n\n    Args:\n        header (Optional[str]): The header to place above the message.\n        log_handler (Optional): The logger to run the exception() method on.\n\n    Returns:\n        str: The string containing the exception message.\n\n    \"\"\"\n    if exc_type is None and exc_value is None and exc_traceback is None:\n        exc_type, exc_value, exc_traceback = sys.exc_info()\n    elif exc_type is None or exc_value is None or exc_traceback is None:\n        raise ValueError('An exception type\/value\/traceback was passed '\n                         'but is missing the other values')\n\n    # Header message with padded border\n    msg = ''\n    if header:\n        msg = '{:=^{length}}\\n'.format(\n            header, length=len(header) * 2 + len(header) % 2)\n\n    if log_handler is not None:\n        # Log the exception; doesn't require creating a message\n        log_handler.exception(msg)\n\n    # Create the message to return, containing the traceback and exception\n    for frame in traceback.extract_tb(exc_traceback):\n        if frame.name == '<module>':\n            # Bottom of the stack; stop here\n            break\n\n        msg += f'Frame {frame.name!r}\\n'\n        # Show only the path starting from project using instead of\n        # just the full path inside frame.filename\n        project_path = pathlib.Path().resolve()\n        trace_path = pathlib.Path(frame.filename)\n        try:\n            filename = trace_path.relative_to(project_path)\n        except ValueError:\n            # Trace must be outside of project; use that then\n            filename = trace_path\n\n        msg += f'Within file \"{filename}\"\\n'\n        msg += f'at line number {frame.lineno}:\\n'\n        msg += f'   {frame.line}\\n'\n    msg += f'\\n{exc_type.__name__}: {exc_value}'\n\n    return msg\n\n\ndef gcd(a, b='high'):\n    \"\"\"Calculate the Greatest Common Divisor of a and b.\n\n    Unless b == 0, the result will have the same sign as b (so that when\n    b is divided by it, the result comes out positive).\n\n    If b is low, calculates the low divisor of a other than itself.\n    If b is high, calculates the highest divisor of a other than itself.\n\n    \"\"\"\n    if b == 'low' or b == 'high':\n        lookUpTo = math.ceil(math.sqrt(a))\n        for i in range(2 if b == 'low' else lookUpTo,\n                       lookUpTo + 1 if b == 'low' else 1,\n                       1 if b == 'low' else -1):\n            if a % i == 0:\n                a = i if b == 'low' else a \/\/ i\n                break\n    else:\n        while b:\n            a, b = b, a % b\n    return a\n\n\ndef get_bot_color():\n    \"Return the bot's color from settings.\"\n    return int(settings.get_setting('bot_color'), 16)\n\n\ndef get_user_color(\n        user, default_color=None):\n    \"Return a user's role color if they are in a guild, else default_color.\"\n    return (\n        user.color if isinstance(user, discord.Member)\n        else default_color if default_color is not None\n        else get_bot_color()\n    )\n\n\n# This function is not done and is not currently in use.\n##def message_snip(message):\n##    \"\"\"Returns a list of messages split by maximum message size in settings.\n##\n##    If the amount of messages exceeds message_limit, raises an OverflowError.\n##\n##    \"\"\"\n##    message_size\n##    if len(message) > message_size:\n##        max_length = message_size * message_limit\n##        # If too many messages are required, return error message and True\n##        if len(message) > max_length:\n##            raise OverflowError(\n##                f'The message is too long to print \\\n##({len(message)} > {max_length}).')\n##\n##        message_list = []  # The list containing each new message\n##        message_extra = ' '  # Variable to store extra data\n##\n##        # Split the message into blocks of message_size characters\n##        while len(message_extra):\n##            message_extra = message[message_size:]\n##            message_list.append(message[:message_size])\n##            message = message_extra\n##\n##        # Send messages\n##        return message_list\n##\n##    # If message is not over message_size characters\n##    return [message]\n\n\ndef num(x):\n    \"\"\"Convert an object into either a int, float, or complex in that order.\"\"\"\n    try:\n        if hasattr(x, 'is_integer') and not x.is_integer():\n            raise ValueError\n        return int(x)\n    except Exception:\n        try:\n            return float(x)\n        except Exception:\n            n = complex(x)\n            if n.imag == 0:\n                return num(n.real)\n            return complex(num(n.real), num(n.imag))\n\n\ndef parse_status(status='online'):\n    status = status.casefold()\n\n    if status in ('online', 'green', 'on', 'active'):\n        return discord.Status.online\n    elif status in ('idle', 'yellow', 'away', 'afk'):\n        return discord.Status.idle\n    elif status in ('dnd', 'red', 'donotdisturb'):\n        return discord.Status.dnd\n    elif status in ('invisible', 'grey', 'gray', 'black', 'offline', 'off'):\n        return discord.Status.invisible\n    else:\n        raise ValueError('Unknown status')\n\n\ndef prime(n):\n    \"\"\"Checks if a number is prime.\"\"\"\n    return True if gcd(n) == 1 else False\n\n\ndef rawincount(filename):\n    \"\"\"Returns the number of lines in a file.\n\n    Citation needed.\n\n    \"\"\"\n    with open(filename, 'rb') as f:\n        bufgen = itertools.takewhile(lambda x: x, (f.raw.read(1024*1024)\n                                         for _ in itertools.repeat(None)))\n        return sum( buf.count(b'\\n') for buf in bufgen ) + 1\n\n\ndef safe_eval(x):\n    \"\"\"Filters a string before evaluating.\nUses CLIENT_EVALUATE_WHITELIST as the filter.\"\"\"\n    return num(eval(\n        ''.join([char for char in x if char in CLIENT_EVALUATE_WHITELIST])\n    ))\n\n\ndef truncate_message(\n        message, size=2000, size_lines=None, placeholder='[...]'):\n    \"\"\"Truncate a message to a given amount of characters or lines.\n\n    This should be used when whitespace needs to be retained as\n    `textwrap.shorten` will collapse whitespace.\n\n    Message is stripped of whitespace.\n\n    \"\"\"\n    message = message.strip()\n\n    in_code_block = 0\n\n    lines = message.split('\\n')\n    chars = 0\n    for line_i, line in enumerate(lines):\n        if size_lines is not None and line_i == size_lines:\n            # Reached maximum lines\n            break\n\n        in_code_block = (in_code_block + line.count('```')) % 2\n\n        new_chars = chars + len(line)\n        if new_chars > size:\n            # This line exceeds max size; truncate it by word\n            words = line.split(' ')\n            last_word = len(words) - 1  # for compensating space split\n            line_chars = chars\n\n            for word_i, word in enumerate(words):\n                new_line_chars = line_chars + len(word)\n\n                if new_line_chars > (\n                        size - len(placeholder)\n                        - in_code_block * 3):\n                    # This word exceeds the max size; truncate to here\n                    break\n\n                if word_i != last_word:\n                    new_line_chars += 1\n\n                line_chars = new_line_chars\n            else:\n                raise RuntimeError(f'line {line_i:,} exceeded max size but '\n                                   'failed to determine where to '\n                                   'truncate the line')\n\n            if word_i == 0:\n                # Line becomes empty; go back to last line\n                # and add placeholder\n                break\n            else:\n                # Truncate line and return new message\n                line = ' '.join(words[:word_i] + [placeholder])\n                return (\n                    '\\n'.join(lines[:line_i] + [line])\n                    + '```' * in_code_block\n                )\n        else:\n            chars = new_chars\n    else:\n        # Message did not exceed max size or lines; no truncation\n        return message\n    # Message exceeded max lines but not max size; truncate to line\n    return (\n        '\\n'.join(lines[:line_i])\n        + f' {placeholder}'\n        + '```' * in_code_block\n    )\n\n\n# Decorators\ndef print_error(func):\n    \"\"\"Decorate error handlers to print the error to console\n    before running the handler function.\"\"\"\n    async def wrapper(*args, **kwargs):\n        logger.exception(f'In {func.__name__}, this error was raised:')\n        mode = settings.get_setting('print_error_mode')\n        if mode == 'raise':\n            print(f'In {func.__name__}, this error was raised:')\n            await func(*args, **kwargs)\n            raise\n        elif mode == 'print':\n            print(f'In {func.__name__}, this error was raised:')\n            print('\\t' + repr(args[2]))\n            await func(*args, **kwargs)\n    return wrapper\n"}},"msg":"Feature Update 5 (#5)\n\nNew commands:\r\n- Administrative\r\n  - cooldown\r\n    - update: Add or update a command's cooldown.\r\n    - reset: Reset a command's cooldown for either the user or everyone.\r\n    - remove: Remove a command's cooldown.\r\n  - concurrency\r\n    - update: Add or update a command's max concurrency.\r\n    - remove: Remove a command's max concurrency.\r\n  - restart: Create a RESTART file before closing the bot; to be used in conjunction with runloop.bat\r\n- Embedding\r\n  - \/hyperlink: Similar to \"hyperlink quick\" except done using plain text instead of an embed, taking advantage of the interaction's webhook capabilities.\r\n- Games\r\n  - blackjack: Run a zero-stakes game of blackjack. Uses two guilds to host the playing card emojis.\r\n    - stats: View total games, wins, and losses.\r\n    - reset: Reset your stats.\r\n  - phasmophobia: Moved from Undefined cog\r\n  - unturned: Moved from Undefined cog\r\n- Graphing\r\n  - interest: Graph the simple and compound interest for an investment as a stackplot\r\n- Informative\r\n  - \/invite: Similar to the \"invite\" text command.\r\n- Notes\r\n  - \/notes\r\n    - add: Add a note.\r\n    - remove: Remove a note.\r\n    - show: Show one or all notes.\r\n- Randomization\r\n  - \/8ball: Similar to the \"8ball\" text command except without the delay between the invokation and the result.\r\n  - \/pick: Similar to the \"pick\" text command.\r\n- Undefined\r\n  - upsidedown: Flips the user's message upside down. Only works one way.\r\n  - leave: Tell the bot to leave the server. (user requires Manage Server permission)\r\n\r\nAdditions:\r\n- Jishaku cog\r\n- runloop.bat for running the bot and repeating if a file named RESTART exists\r\n- `utils.update_text` for printing a line and then clearing it with another line\r\n  - Used in main.py and dbsetup.py\r\n- Adds bot\/converters.py\r\n  - Moves `CommandConverter` from bot\/commands\/info.py\r\n  - Adds `UnicodeEmojiConverter` to check if an argument is a unicode emoji.\r\n- bot\/database\r\n  - `Database` subclass `GameDatabase` which is currently composed of a `BlackjackDatabase`\r\n  - Includes GuildDatabase in __init__.py since that was forgotten\r\n- bot\/classes\/confirmation.py\r\n  - Base class `EmbedConfirmation`\r\n  - `TextConfirmation` to get a yes\/no response from the user by message\r\n  - `AdaptiveConfirmation` which chooses between confirming via reaction or by message based on the bot's permissions and intents\r\n  - Renames previous `Confirmation` class to `ReactionConfirmation`\r\n- bot\/utils.py\r\n  - Added `iterable_has()` from bot\/commands\/info.py\r\n- Adds \"slash_guild_ids\" to the settings file, containing the list of guilds for slash commands to be registered\r\n\r\nImprovements:\r\n- Commands:\r\n  - \"about\": Sends an approximate member count when members intent is disabled instead of a generic \"Unavailable\" message\r\n  - \"block\": Now edits the first message instead of sending two messages\r\n  - \"commandinfo\"\r\n    - Adds the command's max concurrency to the description\r\n    - Now only shows cooldown if the command has a cooldown\r\n  - \"embed\"\r\n    - Sends an error message when failing to send the embed (usually due to missing parameters given by the user)\r\n    - Error messages now delete themselves after 10 seconds\r\n    - Adjusts description to work with the new plain text rendering in help command\r\n  - \"evaluate\": Fixes help documentation being incorrectly formatted\r\n  - \"invite\": Now requests the slash commands scope\r\n  - \"reversecipher\": Adds cooldown\r\n  - \"serverinfo\": Displays roles using mentions instead of names\r\n  - \"shutdown\"\r\n    - Adds confirmation prompt\r\n\t- Prints to terminal when beginning shutdown\r\n  - \"userinfo\": Displays roles using mentions instead of names\r\n  - Adds concurrency queue to note commands\r\n- Updates discord.py to 1.6.0\r\n- \"divide\" command now responds to division by zero error\r\n- IrishSquad cog\r\n  - Adds bot owner-only vacuum command for cleaning up the database of non-existing members\r\n  - \"charge amount\"\r\n    - Renamed to \"charge number\" with \"amount\" as alias\r\n    - Uses typehint converter instead of manually instantiating the converter\r\n    - Fixes being able to query members outside of the guild\r\n  - \"charge total\" now also shows a leaderboard of the top 10 members\r\n  - Removes `has_guild_permissions_dm_safe` custom check (used for \"charge reset\") since returning False is equivalent to raising a CheckFailure\r\n  - Charges are now printed with commas\r\n  - Adds guild property\r\n- bot\/database\r\n  - Databases are now instantiated once in dbsetup.py instead of enforcing databases to be singletons. This means cogs no longer have to \"initialize\" their database.\r\n  - Adds `vacuum()` method to `Database` class\r\n  - Adds ON DELETE CASCADE to all foreign keys\r\n  - Cast user\/guild_id to int to help prevent SQL injections\r\n  - Renames as_Row argument to as_row\r\n- utils.fuzzy_match_word(): Allows non-list objects to be given for `choices`\r\n- Allows case-insensitive help for cogs\r\n- Graphing\r\n  - Attempts fixing memory leak by closing figures as they won't always close themselves, which resulted in figures piling up in the background\r\n  - Switches to a non-GUI backend (Anti-Grain Geometry), since\r\n    1. Interactive GUI isn't needed\r\n\t2. Tkinter sometimes throws an AsyncDelete exception which crashes the bot, particularly when the process is halted or suspended\r\n  - Sets style mode to \"fast\" to optimize rendering\r\n  - Reduces redundancy in graphing commands by having custom style settings stored in data\/discord.mplstyle\r\n- Overhuals `utils.truncate_message` to support more edge cases, improve parameter names, and make the code slightly easier to read\r\n- Moves the uptime tracking from the Informative cog into its own Uptime cog\r\n- The global cooldown check is now registered using a Checks cog instead of manually adding the check. This makes it possible to inspect\/modify the cooldown mapping, and simplifies disabling the global cooldown just by unloading the cog.\r\n  - UserOnCooldown now inherits from commands.CommandError instead of commands.CheckFailure\r\n- CheckFailures are now ignored in the error handler when there is no programmed response for it\r\n- Adds error response for PrivateMessageOnly, raised by commands.dm_only() check\r\n\r\nTweaks:\r\n- Changes global cooldown from 15\/42s to 15\/60s\r\n- Renames `utils.CLIENT_EVALUATE_WHITELIST` to `utils.SAFE_EVAL_WHITELIST` and makes it a frozenset\r\n- Updates randomization commands to use references instead of mentions\r\n- Updates graphing commands to use the new resolved attribute of MessageReference\r\n- All `add_user` arguments related to databases now default to True\r\n- Most error messages now automatically delete itself\r\n- bot\/utils\r\n  - `convert_base()`: Default mapping is now the url-safe base64 sequence\r\n- Ciphers cog: Tweaks documentation of commands\r\n\r\nFixes:\r\n- Commands:\r\n  - \"block\": NameError occurring when a non-owner uses the command\r\n- Retry after time in cooldown responses not always being rounded to the nearest tenth\r\n- Group doc not being shown in help command (this has been missing for ages!)\r\n- Help command not supporting cogs with no explicit qualified_name declaration\r\n- Error messages not being sent for check failures\r\n- AttributeError when handling MissingRole and related errors\r\n\r\nOther:\r\n- Refactors several instances of string concatenations to joins to improve performance, based on an analysis from https:\/\/stackoverflow.com\/a\/16147471\r\n- Refactors all cog descriptions to be specified using docstrings"}},"https:\/\/github.com\/openstack-archive\/cloudpulse":{"9df1d0344f01aa9bc06b6227772c5872dfbaa065":{"url":"https:\/\/api.github.com\/repos\/openstack-archive\/cloudpulse\/commits\/9df1d0344f01aa9bc06b6227772c5872dfbaa065","html_url":"https:\/\/github.com\/openstack-archive\/cloudpulse\/commit\/9df1d0344f01aa9bc06b6227772c5872dfbaa065","sha":"9df1d0344f01aa9bc06b6227772c5872dfbaa065","keyword":"eval injection fix","diff":"diff --git a\/cloudpulse\/operator\/ansible\/ansible_runner.py b\/cloudpulse\/operator\/ansible\/ansible_runner.py\nindex c246b5a..5fbd073 100644\n--- a\/cloudpulse\/operator\/ansible\/ansible_runner.py\n+++ b\/cloudpulse\/operator\/ansible\/ansible_runner.py\n@@ -17,11 +17,27 @@\n import ansible.constants as CONST\n import ansible.inventory\n import ansible.runner\n+import cloudpulse\n+from cloudpulse.scenario.plugins.security_pulse.util.\\\n+    security_pulse_test_input import security_test_input_reader\n import json\n import os\n \n+\n+def get_temp_path():\n+    base_dir = os.path.dirname(cloudpulse.__file__)\n+    try:\n+        config_file = base_dir + '\/scenario\/plugins\/security_pulse\/config\/' +\\\n+            'securityhealth_test_input.yaml'\n+        input_reader = security_test_input_reader(config_file)\n+        input_data = input_reader.process_security_input_file()\n+        return input_data['global_data']['file_info_dir']\n+    except Exception:\n+        print (\"Exception while getting temp path..\")\n+        return \"\/var\/sec_hc\/\"\n+\n CONST.HOST_KEY_CHECKING = False\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+TMP_LOCATION = get_temp_path()\n \n is_containerized = False\n \n@@ -56,10 +72,11 @@ def execute_cmd(self, command, file_list=[], ips=[], roles=[],\n             out = self.execute(command, container_name=container_name)\n             print (out)\n             # remove the files from containers\n-            self.execute(\"rm -rf \/tmp\/sec_hc\/\", container_name=container_name)\n+            self.execute(\"rm -rf \" + TMP_LOCATION,\n+                         container_name=container_name)\n             if is_containerized:\n                 # remove the files from host\n-                self.execute(\"rm -rf \/tmp\/sec_hc\/\")\n+                self.execute(\"rm -rf \" + TMP_LOCATION)\n             return out\n \n     def set_ansible_inventory(self, inv):\ndiff --git a\/cloudpulse\/operator\/ansible\/openstack_config_reader.py b\/cloudpulse\/operator\/ansible\/openstack_config_reader.py\nindex 4b03f7f..487d5c7 100644\n--- a\/cloudpulse\/operator\/ansible\/openstack_config_reader.py\n+++ b\/cloudpulse\/operator\/ansible\/openstack_config_reader.py\n@@ -68,7 +68,7 @@ def printHostList(self):\n             print (\"NAGIOS RUNNING - %s\" % (str(hostObj.isNagiosRunning())))\n \n     def generate_ansible_config(self, os_obj_list):\n-        f = open('\/tmp\/sec_hc\/ansible_hosts', 'w+')\n+        f = open('\/var\/sec_hc\/ansible_hosts', 'w+')\n         for obj in os_obj_list:\n             # print obj.getName()\n             f.write('[' + obj.getName() + ']\\n')\ndiff --git a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py\nindex 62a9948..8fff62d 100644\n--- a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py\n+++ b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py\n@@ -13,12 +13,12 @@\n # License for the specific language governing permissions and limitations\n # under the License.\n \n+import ast\n import cloudpulse\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n import json\n import os\n-\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+import subprocess\n \n \n class SecurityFileCheck(object):\n@@ -46,18 +46,18 @@ def perform_file_permission_check(self, input_params):\n                      \"remote_file_check.py\",\n                      base_dir + \"\/scenario\/plugins\/security_pulse\/testcase\/\" +\n                      \"remote_filecredentials.py\",\n-                     \"\/tmp\/sec_hc\/dir_list\",\n-                     \"\/tmp\/sec_hc\/os_baseline\"]\n+                     file_info_dir + \"dir_list\",\n+                     file_info_dir + \"os_baseline\"]\n \n             def ConsolidateResults(flist, container_name=None):\n                 result = ans_runner.execute_cmd(\n                     \"python \" +\n-                    TMP_LOCATION +\n+                    file_info_dir +\n                     \"remote_file_check.py \",\n                     file_list=flist, container_name=container_name)\n                 Result = ans_runner.get_parsed_ansible_output(result)\n                 final_status.append(Result[0])\n-                final_result.extend(eval(Result[1]))\n+                final_result.extend(ast.literal_eval(Result[1]))\n                 final_msg.extend(Result[2])\n \n             for p in perform_on:\n@@ -65,7 +65,8 @@ def ConsolidateResults(flist, container_name=None):\n                     ans_runner = ansible_runner([obj])\n                     if obj.getRole() == p:\n                         os_dir = input_params[p + '_dir']\n-                        all_baseline = eval(open(baseline_file).read())\n+                        all_baseline = ast.literal_eval(\n+                            open(baseline_file).read())\n                         baseline = all_baseline[p]\n                         open(\n                             file_info_dir +\n@@ -82,7 +83,10 @@ def ConsolidateResults(flist, container_name=None):\n                                 ConsolidateResults(\n                                     flist,\n                                     container_name=container)\n-                                os.system('rm ' + file_info_dir + 'dir_list ')\n+                                subprocess.call([\n+                                    'rm',\n+                                    file_info_dir +\n+                                    'dir_list'])\n \n                         else:\n                             os_dir_list = []\n@@ -91,32 +95,32 @@ def ConsolidateResults(flist, container_name=None):\n                             self.createDirList(os_dir_list, file_info_dir)\n                             # flist.append(\"\/tmp\/sec_hc\/dir_list\")\n                             ConsolidateResults(flist)\n-            os.system(\n-                'rm -rf ' +\n+            subprocess.call([\n+                'rm', '-rf',\n                 file_info_dir +\n-                'os_baseline ' +\n+                'os_baseline',\n                 file_info_dir +\n-                'output')\n-            os.system(\n-                'rm ' +\n+                'output'])\n+            subprocess.call([\n+                'rm',\n                 file_info_dir +\n-                'dir_list ')\n+                'dir_list'])\n             if 404 in final_status:\n                 return (404, final_result, final_msg)\n             else:\n                 return (200, final_result, final_msg)\n         except Exception as e:\n             print (\"exception in perform_file_permission_check is--\", e)\n-            os.system(\n-                'rm -rf ' +\n+            subprocess.call([\n+                'rm', '-rf',\n                 file_info_dir +\n-                'os_baseline ' +\n+                'os_baseline',\n                 file_info_dir +\n-                'output')\n-            os.system(\n-                'rm ' +\n+                'output'])\n+            subprocess.call([\n+                'rm',\n                 file_info_dir +\n-                'dir_list ')\n+                'dir_list'])\n             print (\n                 \"Exception occured in executing\" +\n                 \" perform_file_permission_check\")\ndiff --git a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/generate_baseline.py b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/generate_baseline.py\nindex 93670f3..98b1ad7 100644\n--- a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/generate_baseline.py\n+++ b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/generate_baseline.py\n@@ -13,6 +13,7 @@\n # License for the specific language governing permissions and limitations\n # under the License.\n \n+import ast\n import cloudpulse\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n from cloudpulse.operator.ansible import openstack_config_reader as os_cfg\n@@ -31,7 +32,7 @@ def base_line(self, os_baseline_cfg):\n             openstack_host_list = oscfg_reader.get_host_list()\n             baseline_data = {}\n             for host in openstack_host_list:\n-                f = open('\/tmp\/sec_hc\/dir_list', 'w+')\n+                f = open('\/var\/sec_hc\/dir_list', 'w+')\n                 for dir_name in host.getDirList():\n                     f.write(dir_name + '\\n')\n                 f.close()\n@@ -41,11 +42,11 @@ def base_line(self, os_baseline_cfg):\n                 base_dir += '\/scenario\/plugins\/security_pulse\/testcase'\n                 flist = [base_dir + '\/remote_baseline.py',\n                          base_dir + '\/remote_filecredentials.py',\n-                         '\/tmp\/sec_hc\/dir_list'\n+                         '\/var\/sec_hc\/dir_list'\n                          ]\n                 results = ans_runner.execute_cmd(\n                     \"python \" +\n-                    '\/tmp\/sec_hc\/' +\n+                    '\/var\/sec_hc\/' +\n                     \"remote_baseline.py \",\n                     file_list=flist)\n                 # for node in results['contacted'].keys():\n@@ -53,10 +54,10 @@ def base_line(self, os_baseline_cfg):\n                 node = host.getIp()\n                 data = results['contacted'][node]['stdout']\n \n-                baseline_data.update({role: eval(data)})\n+                baseline_data.update({role: ast.literal_eval(data)})\n                 print (baseline_data)\n             formated_data = json.dumps(baseline_data, indent=4)\n-            open('\/tmp\/sec_hc\/os_allnode_baseline',\n+            open('\/var\/sec_hc\/os_allnode_baseline',\n                  'w+').write(str(formated_data))\n         except Exception as e:\n             print (e)\ndiff --git a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/ks_admin_token_check.py b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/ks_admin_token_check.py\nindex 95dfe4c..d7c87f8 100644\n--- a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/ks_admin_token_check.py\n+++ b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/ks_admin_token_check.py\n@@ -18,8 +18,7 @@\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n import json\n import os\n-\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+import subprocess\n \n \n class ks_admin_token_check(object):\n@@ -47,9 +46,9 @@ def perform_ks_admin_token_check_test(self, input_params):\n             container_name = input_params['input']['container_name']\n         result = ans_runner.execute_cmd(\n             \"python \" +\n-            TMP_LOCATION +\n+            file_info_dir +\n             \"keystone_admin_token_check.py \",\n             file_list=flist, container_name=container_name)\n         Result = ans_runner.get_parsed_ansible_output(result)\n-        os.system('rm -rf ' + file_info_dir + 'output')\n+        subprocess.call(['rm', '-rf', file_info_dir + 'output'])\n         return Result\ndiff --git a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/mysql_tls_enable_test.py b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/mysql_tls_enable_test.py\nindex 2b06376..acc0f9e 100644\n--- a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/mysql_tls_enable_test.py\n+++ b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/mysql_tls_enable_test.py\n@@ -17,8 +17,7 @@\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n import json\n import os\n-\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+import subprocess\n \n \n class mysql_tls_enablement_test(object):\n@@ -45,11 +44,11 @@ def perform_mysql_tls_enablement_test(self, input_params):\n                 container_name = input_params['input']['container_name']\n             result = ans_runner.execute_cmd(\n                 \"python \" +\n-                TMP_LOCATION +\n+                file_info_dir +\n                 \"remote_mysql_tls_enablement_check.py \",\n                 file_list=flist, container_name=container_name)\n             Result = ans_runner.get_parsed_ansible_output(result)\n-            os.system('rm -rf ' + file_info_dir + 'output')\n+            subprocess.call(['rm', '-rf', file_info_dir + 'output'])\n             return Result\n         except Exception as msg:\n             print (\ndiff --git a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_baseline.py b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_baseline.py\nindex 3c7aa7c..ae9ddb5 100644\n--- a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_baseline.py\n+++ b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_baseline.py\n@@ -52,7 +52,7 @@ def file_traversal(self, dir_list, file_dir):\n \n if __name__ == '__main__':\n     # LOG.info('Executing test')\n-    file_dir = '\/tmp\/sec_hc\/'\n+    file_dir = '\/var\/sec_hc\/'\n     dirs = []\n     with open(file_dir + 'dir_list') as f:\n         dirs = f.read().splitlines()\ndiff --git a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_file_check.py b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_file_check.py\nindex 290d159..eadd9a1 100644\n--- a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_file_check.py\n+++ b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_file_check.py\n@@ -13,6 +13,7 @@\n # License for the specific language governing permissions and limitations\n # under the License.\n \n+import ast\n import os\n import pwd\n import remote_filecredentials as filecredentials\n@@ -51,7 +52,8 @@ def file_check(self, dir_list, file_dir):\n                                     'mode': ins.getMode(),\n                                     'user': ins.getUser(),\n                                     'group': ins.getGroup()}})\n-            keystone_baseline = eval(open(file_dir + 'os_baseline').read())\n+            keystone_baseline = ast.literal_eval(\n+                open(file_dir + 'os_baseline').read())\n             remote_mismatch = list(set(output.keys()).\n                                    difference(keystone_baseline.keys()))\n             baseline_mismatch = list(set(keystone_baseline.keys()).\n@@ -74,29 +76,29 @@ def file_check(self, dir_list, file_dir):\n                             ' in remote')\n                     msg = string.join(l, ', ')\n                     if msg:\n-                        temp = {'Test Case Name': key, 'Status': 'Fail'}\n-                        temp.update({'Message': msg})\n+                        temp = {'test_case_name': key, 'Status': 'Fail'}\n+                        temp.update({'message': msg})\n                         result.append(temp)\n             if baseline_mismatch:\n                 for item in baseline_mismatch:\n                     msg = 'File not found in remote'\n-                    temp = {'Test Case Name': item, 'Status': 'Fail'}\n-                    temp.update({'Message': msg})\n+                    temp = {'test_case_name': item, 'Status': 'Fail'}\n+                    temp.update({'message': msg})\n                     result.append(temp)\n             if remote_mismatch:\n                 for item in remote_mismatch:\n                     msg = 'New file found in remote'\n-                    temp = {'Test Case Name': item, 'Status': 'Fail'}\n-                    temp.update({'Message': msg})\n+                    temp = {'test_case_name': item, 'Status': 'Fail'}\n+                    temp.update({'message': msg})\n                     result.append(temp)\n             if not result:\n                 overall_status = True\n                 final_result.update(\n                     {'OverallStatus': overall_status})\n                 result = {}\n-                result.update({'Test Case Name': 'File permission Check'})\n-                result.update({'Status': 'Pass'})\n-                result.update({'Message': 'No mismatch'})\n+                result.update({'test_case_name': 'File permission Check'})\n+                result.update({'status': 'Pass'})\n+                result.update({'message': 'No mismatch'})\n                 final_result.update({'result': [result]})\n                 print (final_result)\n                 return\n@@ -110,16 +112,16 @@ def file_check(self, dir_list, file_dir):\n             final_result.update(\n                 {'OverallStatus': False})\n             result = {}\n-            result.update({'Test Case Name': 'File permission Check'})\n-            result.update({'Status': 'Fail'})\n+            result.update({'test_case_name': 'File permission Check'})\n+            result.update({'status': 'Fail'})\n             result.update(\n-                {'Message': 'Exception in file comparision' + str(e)})\n+                {'message': 'Exception in file comparision' + str(e)})\n             final_result.update({'result': [result]})\n             print (final_result)\n             return\n \n if __name__ == '__main__':\n-    file_dir = '\/tmp\/sec_hc\/'\n+    file_dir = '\/var\/sec_hc\/'\n     dirs = []\n     with open(file_dir + 'dir_list') as f:\n         dirs = f.read().splitlines()\ndiff --git a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/tls_enable_test.py b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/tls_enable_test.py\nindex f390cc9..55613ad 100644\n--- a\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/tls_enable_test.py\n+++ b\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/tls_enable_test.py\n@@ -17,8 +17,7 @@\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n import json\n import os\n-\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+import subprocess\n \n \n class tls_enablement_test(object):\n@@ -45,9 +44,9 @@ def perform_tls_enablement_test(self, input_params):\n             container_name = input_params['input']['container_name']\n         result = ans_runner.execute_cmd(\n             \"python \" +\n-            TMP_LOCATION +\n+            file_info_dir +\n             \"TLS_Enablement_Check.py \",\n             file_list=flist, container_name=container_name)\n         Result = ans_runner.get_parsed_ansible_output(result)\n-        os.system('rm -rf ' + file_info_dir + 'output')\n+        subprocess.call(['rm', '-rf', file_info_dir + 'output'])\n         return Result\n","message":"","files":{"\/cloudpulse\/operator\/ansible\/ansible_runner.py":{"changes":[{"diff":"\n import ansible.constants as CONST\n import ansible.inventory\n import ansible.runner\n+import cloudpulse\n+from cloudpulse.scenario.plugins.security_pulse.util.\\\n+    security_pulse_test_input import security_test_input_reader\n import json\n import os\n \n+\n+def get_temp_path():\n+    base_dir = os.path.dirname(cloudpulse.__file__)\n+    try:\n+        config_file = base_dir + '\/scenario\/plugins\/security_pulse\/config\/' +\\\n+            'securityhealth_test_input.yaml'\n+        input_reader = security_test_input_reader(config_file)\n+        input_data = input_reader.process_security_input_file()\n+        return input_data['global_data']['file_info_dir']\n+    except Exception:\n+        print (\"Exception while getting temp path..\")\n+        return \"\/var\/sec_hc\/\"\n+\n CONST.HOST_KEY_CHECKING = False\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+TMP_LOCATION = get_temp_path()\n \n is_containerized = False\n \n","add":17,"remove":1,"filename":"\/cloudpulse\/operator\/ansible\/ansible_runner.py","badparts":["TMP_LOCATION = \"\/tmp\/sec_hc\/\""],"goodparts":["import cloudpulse","from cloudpulse.scenario.plugins.security_pulse.util.\\","    security_pulse_test_input import security_test_input_reader","def get_temp_path():","    base_dir = os.path.dirname(cloudpulse.__file__)","    try:","        config_file = base_dir + '\/scenario\/plugins\/security_pulse\/config\/' +\\","            'securityhealth_test_input.yaml'","        input_reader = security_test_input_reader(config_file)","        input_data = input_reader.process_security_input_file()","        return input_data['global_data']['file_info_dir']","    except Exception:","        print (\"Exception while getting temp path..\")","        return \"\/var\/sec_hc\/\"","TMP_LOCATION = get_temp_path()"]},{"diff":"\n             out = self.execute(command, container_name=container_name)\n             print (out)\n             # remove the files from containers\n-            self.execute(\"rm -rf \/tmp\/sec_hc\/\", container_name=container_name)\n+            self.execute(\"rm -rf \" + TMP_LOCATION,\n+                         container_name=container_name)\n             if is_containerized:\n                 # remove the files from host\n-                self.execute(\"rm -rf \/tmp\/sec_hc\/\")\n+                self.execute(\"rm -rf \" + TMP_LOCATION)\n             return out\n \n     def set_ansible_inventory(self, inv):","add":3,"remove":2,"filename":"\/cloudpulse\/operator\/ansible\/ansible_runner.py","badparts":["            self.execute(\"rm -rf \/tmp\/sec_hc\/\", container_name=container_name)","                self.execute(\"rm -rf \/tmp\/sec_hc\/\")"],"goodparts":["            self.execute(\"rm -rf \" + TMP_LOCATION,","                         container_name=container_name)","                self.execute(\"rm -rf \" + TMP_LOCATION)"]}],"source":"\n from __future__ import print_function import ansible.constants as CONST import ansible.inventory import ansible.runner import json import os CONST.HOST_KEY_CHECKING=False TMP_LOCATION=\"\/tmp\/sec_hc\/\" is_containerized=False class ansible_runner(object): def __init__(self, os_node_list=[]): self.openstack_node=os_node_list self.remote_user=None self.inventory=None def execute_cmd(self, command, file_list=[], ips=[], roles=[], container_name=None): inventory=None filetered_os_list=[] if ips: filetered_os_list=self.get_os_node_list(ip_list=ips) elif roles: filetered_os_list=self.get_os_node_list(role_list=roles) else: filetered_os_list=self.openstack_node if filetered_os_list: inventory=self.init_ansible_inventory(filetered_os_list) if inventory: self.inventory=inventory if is_containerized: self.execute(\"mkdir \" +TMP_LOCATION, container_name=container_name) for f in file_list: self.copy(f, TMP_LOCATION, container_name=container_name) out=self.execute(command, container_name=container_name) print(out) self.execute(\"rm -rf \/tmp\/sec_hc\/\", container_name=container_name) if is_containerized: self.execute(\"rm -rf \/tmp\/sec_hc\/\") return out def set_ansible_inventory(self, inv): self.inventory=inv def set_credential(self, user): self.remote_user=user def init_ansible_inventory(self, os_node_list): ip_list=[] for os_node in os_node_list: ip_list.append(os_node.getIp()) self.remote_user=os_node.getUser() inventory=ansible.inventory.Inventory(ip_list) return inventory def get_os_node_list(self, ip_list=[], role_list=[]): filetered_list=[] if not ip_list and not role_list: return self.openstack_node if ip_list and self.openstack_node: for ip in ip_list: for os_node in self.openstack_node: if ip==os_node.getIp(): filetered_list.append(os_node) elif role_list and self.openstack_node: for role in role_list: for os_node in self.self.openstack_node: if role==os_node.getRole(): filetered_list.append(os_node) return filetered_list def copy(self, src, dest, container_name=None): runner=ansible.runner.Runner( module_name='copy', module_args='src=%s dest=%s' %(src, dest), remote_user=self.remote_user, inventory=self.inventory, ) out=runner.run() print(out) if is_containerized: con_runner=self.container_copy(src, dest, container_name) out1=con_runner.run() print(out1) return out def container_copy(self, src, dest, container_name): new_src=TMP_LOCATION +src.split('\/')[-1] dest=dest +src.split('\/')[-1] cmd=\"docker exec -i %s sh -c 'cat > %s' < %s\" \\ %(container_name, dest, new_src) runner=ansible.runner.Runner( module_name='shell', module_args=cmd, remote_user=self.remote_user, inventory=self.inventory, ) print(cmd) return runner def fetch(self, src, dest, flat='yes'): runner=ansible.runner.Runner( module_name='fetch', module_args='src=%s dest=%s flat=%s' %(src, dest, flat), remote_user=self.remote_user, inventory=self.inventory, ) out=runner.run() return out def execute(self, command, container_name=None): if is_containerized and container_name: command='docker exec %s %s' %(container_name, command) runner=ansible.runner.Runner( module_name='shell', module_args=command, remote_user=self.remote_user, inventory=self.inventory, ) out=runner.run() return out def get_results(self): result={} if not os.path.isdir(TMP_LOCATION +'output\/'): return result files=os.walk(TMP_LOCATION +'output\/').next()[1] for f in files: try: result[f]=open(TMP_LOCATION +'output\/' + f +TMP_LOCATION +'output', 'r').read() except IOError: print(\"Error opening the file: \" +TMP_LOCATION + 'output\/' +f +TMP_LOCATION +'output') return result def validate_results(self, results, checks=None): results['status']='PASS' failed_hosts=[] if results['dark']: failed_hosts.append(results['dark'].keys()) results['status']='FAIL' results['status_message']='' for node in results['contacted'].keys(): if 'failed' in results['contacted'][node]: if results['contacted'][node]['failed'] is True: results['status']='FAIL' results['status_message']='' for node in results['contacted'].keys(): rc=results['contacted'][node].get('rc', None) if rc is not None and rc !=0: failed_hosts.append(node) results['status']='FAIL' results['status_message']=results[ 'contacted'][node].get('stderr', None) if checks is None: return results, failed_hosts for check in checks: key=check.keys()[0] value=check.values()[0] for node in results['contacted'].keys(): if key in results['contacted'][node].keys(): if results['contacted'][node][key] !=value: failed_hosts.append(node) results['status']='FAIL' results['status_message']='' return(results, failed_hosts) def get_parsed_ansible_output(self, output_data): if output_data: return self.get_validated_data(output_data) else: msg={ 'message': 'No result from test execution', 'status': 'Fail'} return(404, json.dumps([msg],[])) def get_validated_data(self, results): print(\"Inside get_validated_data\", results) output=[] status=200 if results['dark']: status=404 for node in results['contacted'].keys(): if 'failed' in results['contacted'][node]: if results['contacted'][node]['failed'] is True: status=404 msg={ 'node': node, 'status': 'Fail', 'message': 'Execution failed'} output.append(msg) for node in results['contacted'].keys(): rc=results['contacted'][node].get('rc', None) if rc is not None and rc !=0: status=404 node_info=results['contacted'][node] op=eval(node_info.get('stdout')) if not op.get('OverallStatus'): status=404 try: res=op.get('result',[]) for tc in res: tc.update({'node': node}) output.append(tc) except Exception: print(\"Exception while getting the result\" + \" from the ansible output\") return(status, json.dumps(output),[]) \"\"\" if __name__=='__main__': os_node_info_obj=openstack_node_info_reader(\"\/home\/ubuntu\/ sasi\/cpulse\/cloudpulse\/plugins\/security_pulse\/config\/ openstack_config.yaml\") openstack_node_list=os_node_info_obj.get_host_list() print openstack_node_list flist=[\"\/home\/ubuntu\/sasi\/cpulse\/cloudpulse\/plugins\/ security_pulse\/testcase\/TLS_Enablement_Check.py\"] ans_runner=ansible_runner(openstack_node_list) ans_runner.execute_cmd(\"python \"+TMP_LOCATION+ \"TLS_Enablement_Check.py\",file_list=flist) \"\"\" ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom __future__ import print_function\nimport ansible.constants as CONST\nimport ansible.inventory\nimport ansible.runner\nimport json\nimport os\n\nCONST.HOST_KEY_CHECKING = False\nTMP_LOCATION = \"\/tmp\/sec_hc\/\"\n\nis_containerized = False\n\n\nclass ansible_runner(object):\n\n    def __init__(self, os_node_list=[]):\n        self.openstack_node = os_node_list\n        self.remote_user = None\n        self.inventory = None\n\n    def execute_cmd(self, command, file_list=[], ips=[], roles=[],\n                    container_name=None):\n        inventory = None\n        filetered_os_list = []\n        if ips:\n            filetered_os_list = self.get_os_node_list(ip_list=ips)\n        elif roles:\n            filetered_os_list = self.get_os_node_list(role_list=roles)\n        else:\n            filetered_os_list = self.openstack_node\n        # print filetered_os_list\n        if filetered_os_list:\n            inventory = self.init_ansible_inventory(filetered_os_list)\n        if inventory:\n            self.inventory = inventory\n            if is_containerized:\n                self.execute(\"mkdir \" + TMP_LOCATION,\n                             container_name=container_name)\n            for f in file_list:\n                self.copy(f, TMP_LOCATION, container_name=container_name)\n            out = self.execute(command, container_name=container_name)\n            print (out)\n            # remove the files from containers\n            self.execute(\"rm -rf \/tmp\/sec_hc\/\", container_name=container_name)\n            if is_containerized:\n                # remove the files from host\n                self.execute(\"rm -rf \/tmp\/sec_hc\/\")\n            return out\n\n    def set_ansible_inventory(self, inv):\n        self.inventory = inv\n\n    def set_credential(self, user):\n        self.remote_user = user\n\n    def init_ansible_inventory(self, os_node_list):\n        ip_list = []\n        for os_node in os_node_list:\n            ip_list.append(os_node.getIp())\n            self.remote_user = os_node.getUser()\n        inventory = ansible.inventory.Inventory(ip_list)\n        return inventory\n\n    def get_os_node_list(self, ip_list=[], role_list=[]):\n        filetered_list = []\n        if not ip_list and not role_list:\n            return self.openstack_node\n        if ip_list and self.openstack_node:\n            for ip in ip_list:\n                for os_node in self.openstack_node:\n                    if ip == os_node.getIp():\n                        filetered_list.append(os_node)\n        elif role_list and self.openstack_node:\n            for role in role_list:\n                for os_node in self.self.openstack_node:\n                    if role == os_node.getRole():\n                        filetered_list.append(os_node)\n        return filetered_list\n\n    def copy(self, src, dest, container_name=None):\n        runner = ansible.runner.Runner(\n            module_name='copy',\n            module_args='src=%s dest=%s' % (src, dest),\n            remote_user=self.remote_user,\n            inventory=self.inventory,\n        )\n        out = runner.run()\n        print (out)\n        # copy to container\n        if is_containerized:\n            con_runner = self.container_copy(src, dest, container_name)\n            out1 = con_runner.run()\n            print (out1)\n        return out\n\n    def container_copy(self, src, dest, container_name):\n        new_src = TMP_LOCATION + src.split('\/')[-1]\n        dest = dest + src.split('\/')[-1]\n        cmd = \"docker exec -i %s sh -c 'cat > %s' < %s\" \\\n            % (container_name, dest, new_src)\n        runner = ansible.runner.Runner(\n            module_name='shell',\n            module_args=cmd,\n            remote_user=self.remote_user,\n            # remote_pass=self.remote_pass,\n            inventory=self.inventory,\n        )\n        print (cmd)\n        return runner\n\n    def fetch(self, src, dest, flat='yes'):\n        runner = ansible.runner.Runner(\n            module_name='fetch',\n            module_args='src=%s dest=%s flat=%s' % (src, dest, flat),\n            remote_user=self.remote_user,\n            inventory=self.inventory,\n        )\n        out = runner.run()\n        return out\n\n    # can perform all shell operations Ex: rm \/tmp\/output\n    def execute(self, command, container_name=None):\n        if is_containerized and container_name:\n            command = 'docker exec %s %s' % (container_name, command)\n\n        # print command\n        runner = ansible.runner.Runner(\n            module_name='shell',\n            module_args=command,\n            remote_user=self.remote_user,\n            inventory=self.inventory,\n        )\n        out = runner.run()\n        return out\n\n    def get_results(self):\n        result = {}\n        if not os.path.isdir(TMP_LOCATION + 'output\/'):\n            return result\n        files = os.walk(TMP_LOCATION + 'output\/').next()[1]\n        for f in files:\n            try:\n                result[f] = open(TMP_LOCATION + 'output\/' +\n                                 f + TMP_LOCATION + 'output', 'r').read()\n            except IOError:\n                print (\"Error opening the file : \" + TMP_LOCATION +\n                       'output\/' + f + TMP_LOCATION + 'output')\n        return result\n\n    def validate_results(self, results, checks=None):\n        results['status'] = 'PASS'\n        failed_hosts = []\n\n        if results['dark']:\n            failed_hosts.append(results['dark'].keys())\n            results['status'] = 'FAIL'\n            results['status_message'] = ''\n\n        for node in results['contacted'].keys():\n            if 'failed' in results['contacted'][node]:\n                if results['contacted'][node]['failed'] is True:\n                    results['status'] = 'FAIL'\n                    results['status_message'] = ''\n\n        for node in results['contacted'].keys():\n            rc = results['contacted'][node].get('rc', None)\n            if rc is not None and rc != 0:\n                failed_hosts.append(node)\n                results['status'] = 'FAIL'\n                results['status_message'] = results[\n                    'contacted'][node].get('stderr', None)\n\n        if checks is None:\n            # print \"No additional checks validated\"\n            return results, failed_hosts\n\n        for check in checks:\n            key = check.keys()[0]\n            value = check.values()[0]\n            for node in results['contacted'].keys():\n                if key in results['contacted'][node].keys():\n                    if results['contacted'][node][key] != value:\n                        failed_hosts.append(node)\n                        results['status'] = 'FAIL'\n                        results['status_message'] = ''\n\n        return (results, failed_hosts)\n\n    def get_parsed_ansible_output(self, output_data):\n        if output_data:\n            return self.get_validated_data(output_data)\n        else:\n            msg = {\n                'message': 'No result from test execution',\n                'status': 'Fail'}\n            return (404, json.dumps([msg], []))\n\n    def get_validated_data(self, results):\n        print (\"Inside get_validated_data\", results)\n        # final_result = {}\n        output = []\n        status = 200  # 'PASS'\n        ###################################################\n        # First validation is to make sure connectivity to\n        # all the hosts was ok.\n        ###################################################\n        if results['dark']:\n            status = 404  # 'FAIL'\n\n        ##################################################\n        # Now look for status 'failed'\n        ##################################################\n        for node in results['contacted'].keys():\n            if 'failed' in results['contacted'][node]:\n                if results['contacted'][node]['failed'] is True:\n                    status = 404  # 'FAIL'\n                    msg = {\n                        'node': node,\n                        'status': 'Fail',\n                        'message': 'Execution failed'}\n                    output.append(msg)\n\n        #################################################\n        # Check for the return code 'rc' for each host.\n        #################################################\n        for node in results['contacted'].keys():\n            rc = results['contacted'][node].get('rc', None)\n            if rc is not None and rc != 0:\n                status = 404  # 'FAIL'\n            node_info = results['contacted'][node]\n            op = eval(node_info.get('stdout'))\n            if not op.get('OverallStatus'):\n                status = 404  # 'FAIL'\n            try:\n                res = op.get('result', [])\n                for tc in res:\n                    tc.update({'node': node})\n                    output.append(tc)\n            except Exception:\n                print (\"Exception while getting the result\" +\n                       \" from the ansible output\")\n        return (status, json.dumps(output), [])\n\n\"\"\"\nif __name__ == '__main__':\n    os_node_info_obj = openstack_node_info_reader(\"\/home\/ubuntu\/\n        sasi\/cpulse\/cloudpulse\/plugins\/security_pulse\/config\/\n        openstack_config.yaml\")\n    openstack_node_list = os_node_info_obj.get_host_list()\n    print openstack_node_list\n    flist=[\"\/home\/ubuntu\/sasi\/cpulse\/cloudpulse\/plugins\/\n    security_pulse\/testcase\/TLS_Enablement_Check.py\"]\n    ans_runner = ansible_runner(openstack_node_list)\n    ans_runner.execute_cmd(\"python \"+TMP_LOCATION+\n        \"TLS_Enablement_Check.py\",file_list=flist)\n\"\"\"\n"},"\/cloudpulse\/operator\/ansible\/openstack_config_reader.py":{"changes":[{"diff":"\n             print (\"NAGIOS RUNNING - %s\" % (str(hostObj.isNagiosRunning())))\n \n     def generate_ansible_config(self, os_obj_list):\n-        f = open('\/tmp\/sec_hc\/ansible_hosts', 'w+')\n+        f = open('\/var\/sec_hc\/ansible_hosts', 'w+')\n         for obj in os_obj_list:\n             # print obj.getName()\n             f.write('[' + obj.getName() + ']\\n'","add":1,"remove":1,"filename":"\/cloudpulse\/operator\/ansible\/openstack_config_reader.py","badparts":["        f = open('\/tmp\/sec_hc\/ansible_hosts', 'w+')"],"goodparts":["        f = open('\/var\/sec_hc\/ansible_hosts', 'w+')"]}],"source":"\n from hostObj import HostObject import os import yaml class os_cfg_reader(object): def __init__(self, hostFileName=\"openstack_config.yaml\"): abs_path=os.getcwd() +os.sep +'config\/%s' % hostFileName self.hostYamlObj=None self.openstack_host_list=[] try: fp=open(abs_path) except IOError as e: print(\"Error while opening the file...%s\" % e) return try: self.hostYamlObj=yaml.load(fp) except yaml.error.YAMLError as perr: print(\"Error while parsing...%s\" % perr) return def setOpenstackNodeIp(self): for key in self.hostYamlObj.keys(): name=key ip=self.hostYamlObj[key][\"ip\"] hostname=key username=self.hostYamlObj[key][\"user\"] role=self.hostYamlObj[key][\"role\"] hstObj=HostObject( hostname, ip, username, role, name, False) if \"dirlist\" in self.hostYamlObj[key]: dirList=self.hostYamlObj[key][\"dirlist\"] hstObj.setDirList(dirList) self.openstack_host_list.append(hstObj) def get_host_list(self): return self.openstack_host_list def printHostList(self): for hostObj in self.openstack_host_list: print(\"IP -%s\" %(hostObj.getIp())) print(\"HOST -%s\" %(hostObj.getHost())) print(\"USER -%s\" %(hostObj.getUser())) print(\"NAGIOS RUNNING -%s\" %(str(hostObj.isNagiosRunning()))) def generate_ansible_config(self, os_obj_list): f=open('\/tmp\/sec_hc\/ansible_hosts', 'w+') for obj in os_obj_list: f.write('[' +obj.getName() +']\\n') f.write( obj.getIp() + '\\t\\t' + 'ansible_ssh_user=' + obj.getUser() + '\\t\\tansible_ssh_pass=' + obj.getPassword()) f.write('\\n') f.close() \"\"\" def update_ansible_playbook(self): f=open('testcase-configs\/ansible-playbook.yaml') f1=open('testcase-configs\/ansible-playbook_update.yaml', \"w\") for line in f: if 'hosts' in line: f1.write('-hosts: sasi1\\n') else: f1.write(line) f.close() f1.close() \"\"\" if __name__=='__main__': yhp=os_cfg_reader() yhp.setOpenstackNodeIp() yhp.printHostList() yhp.update_ansible_playbook() ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\nfrom hostObj import HostObject\nimport os\nimport yaml\n\n\nclass os_cfg_reader(object):\n\n    def __init__(self, hostFileName=\"openstack_config.yaml\"):\n        abs_path = os.getcwd() + os.sep + 'config\/%s' % hostFileName\n        self.hostYamlObj = None\n        self.openstack_host_list = []\n        try:\n            fp = open(abs_path)\n        except IOError as e:\n            print (\"Error while opening the file...%s\" % e)\n            return\n\n        try:\n            self.hostYamlObj = yaml.load(fp)\n            # print \"self.hostYamlObj: \", self.hostYamlObj,\n            # dir(self.hostYamlObj)\n        except yaml.error.YAMLError as perr:\n            print (\"Error while parsing...%s\" % perr)\n            return\n\n    def setOpenstackNodeIp(self):\n        # print self.hostYamlObj\n        for key in self.hostYamlObj.keys():\n            name = key\n            ip = self.hostYamlObj[key][\"ip\"]\n            hostname = key\n            username = self.hostYamlObj[key][\"user\"]\n            role = self.hostYamlObj[key][\"role\"]\n            hstObj = HostObject(\n                hostname,\n                ip,\n                username,\n                role,\n                name,\n                False)\n            if \"dirlist\" in self.hostYamlObj[key]:\n                dirList = self.hostYamlObj[key][\"dirlist\"]\n                hstObj.setDirList(dirList)\n            self.openstack_host_list.append(hstObj)\n\n    def get_host_list(self):\n        return self.openstack_host_list\n\n    def printHostList(self):\n        for hostObj in self.openstack_host_list:\n            print (\"IP - %s\" % (hostObj.getIp()))\n            print (\"HOST - %s\" % (hostObj.getHost()))\n            print (\"USER - %s\" % (hostObj.getUser()))\n            print (\"NAGIOS RUNNING - %s\" % (str(hostObj.isNagiosRunning())))\n\n    def generate_ansible_config(self, os_obj_list):\n        f = open('\/tmp\/sec_hc\/ansible_hosts', 'w+')\n        for obj in os_obj_list:\n            # print obj.getName()\n            f.write('[' + obj.getName() + ']\\n')\n            f.write(\n                obj.getIp() +\n                '\\t\\t' +\n                'ansible_ssh_user=' +\n                obj.getUser() +\n                '\\t\\tansible_ssh_pass=' +\n                obj.getPassword())\n            f.write('\\n')\n        f.close()\n\"\"\"\n\n    def update_ansible_playbook(self):\n        f = open('testcase-configs\/ansible-playbook.yaml')\n        f1 = open('testcase-configs\/ansible-playbook_update.yaml', \"w\")\n        for line in f:\n            if 'hosts' in line:\n                f1.write('- hosts: sasi1\\n')\n            else:\n                f1.write(line)\n        f.close()\n        f1.close()\n\"\"\"\nif __name__ == '__main__':\n    yhp = os_cfg_reader()\n    yhp.setOpenstackNodeIp()\n    yhp.printHostList()\n    # yhp.generate_ansible_config(yhp.get_host_list())\n    yhp.update_ansible_playbook()\n"},"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py":{"changes":[{"diff":"\n # License for the specific language governing permissions and limitations\n # under the License.\n \n+import ast\n import cloudpulse\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n import json\n import os\n-\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+import subprocess\n \n \n class SecurityFileCheck(object):\n","add":2,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py","badparts":["TMP_LOCATION = \"\/tmp\/sec_hc\/\""],"goodparts":["import ast","import subprocess"]},{"diff":"\n                      \"remote_file_check.py\",\n                      base_dir + \"\/scenario\/plugins\/security_pulse\/testcase\/\" +\n                      \"remote_filecredentials.py\",\n-                     \"\/tmp\/sec_hc\/dir_list\",\n-                     \"\/tmp\/sec_hc\/os_baseline\"]\n+                     file_info_dir + \"dir_list\",\n+                     file_info_dir + \"os_baseline\"]\n \n             def ConsolidateResults(flist, container_name=None):\n                 result = ans_runner.execute_cmd(\n                     \"python \" +\n-                    TMP_LOCATION +\n+                    file_info_dir +\n                     \"remote_file_check.py \",\n                     file_list=flist, container_name=container_name)\n                 Result = ans_runner.get_parsed_ansible_output(result)\n                 final_status.append(Result[0])\n-                final_result.extend(eval(Result[1]))\n+                final_result.extend(ast.literal_eval(Result[1]))\n                 final_msg.extend(Result[2])\n \n             for p in perform_on:\n","add":4,"remove":4,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py","badparts":["                     \"\/tmp\/sec_hc\/dir_list\",","                     \"\/tmp\/sec_hc\/os_baseline\"]","                    TMP_LOCATION +","                final_result.extend(eval(Result[1]))"],"goodparts":["                     file_info_dir + \"dir_list\",","                     file_info_dir + \"os_baseline\"]","                    file_info_dir +","                final_result.extend(ast.literal_eval(Result[1]))"]},{"diff":"\n                     ans_runner = ansible_runner([obj])\n                     if obj.getRole() == p:\n                         os_dir = input_params[p + '_dir']\n-                        all_baseline = eval(open(baseline_file).read())\n+                        all_baseline = ast.literal_eval(\n+                            open(baseline_file).read())\n                         baseline = all_baseline[p]\n                         open(\n                             file_info_dir +\n","add":2,"remove":1,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py","badparts":["                        all_baseline = eval(open(baseline_file).read())"],"goodparts":["                        all_baseline = ast.literal_eval(","                            open(baseline_file).read())"]},{"diff":"\n                                 ConsolidateResults(\n                                     flist,\n                                     container_name=container)\n-                                os.system('rm ' + file_info_dir + 'dir_list ')\n+                                subprocess.call([\n+                                    'rm',\n+                                    file_info_dir +\n+                                    'dir_list'])\n \n                         else:\n                             os_dir_list = []\n","add":4,"remove":1,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py","badparts":["                                os.system('rm ' + file_info_dir + 'dir_list ')"],"goodparts":["                                subprocess.call([","                                    'rm',","                                    file_info_dir +","                                    'dir_list'])"]},{"diff":"\n                             self.createDirList(os_dir_list, file_info_dir)\n                             # flist.append(\"\/tmp\/sec_hc\/dir_list\")\n                             ConsolidateResults(flist)\n-            os.system(\n-                'rm -rf ' +\n+            subprocess.call([\n+                'rm', '-rf',\n                 file_info_dir +\n-                'os_baseline ' +\n+                'os_baseline',\n                 file_info_dir +\n-                'output')\n-            os.system(\n-                'rm ' +\n+                'output'])\n+            subprocess.call([\n+                'rm',\n                 file_info_dir +\n-                'dir_list ')\n+                'dir_list'])\n             if 404 in final_status:\n                 return (404, final_result, final_msg)\n             else:\n                 return (200, final_result, final_msg)\n         except Exception as e:\n             print (\"exception in perform_file_permission_check is--\", e)\n-            os.system(\n-                'rm -rf ' +\n+            subprocess.call([\n+                'rm', '-rf',\n                 file_info_dir +\n-                'os_baseline ' +\n+                'os_baseline',\n                 file_info_dir +\n-                'output')\n-            os.system(\n-                'rm ' +\n+                'output'])\n+            subprocess.call([\n+                'rm',\n                 file_info_dir +\n-                'dir_list ')\n+                'dir_list'])\n             print (\n                 \"Exception occured in executing\" +\n                 \" perform_file_permission_check","add":14,"remove":14,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/file_check_test.py","badparts":["            os.system(","                'rm -rf ' +","                'os_baseline ' +","                'output')","            os.system(","                'rm ' +","                'dir_list ')","            os.system(","                'rm -rf ' +","                'os_baseline ' +","                'output')","            os.system(","                'rm ' +","                'dir_list ')"],"goodparts":["            subprocess.call([","                'rm', '-rf',","                'os_baseline',","                'output'])","            subprocess.call([","                'rm',","                'dir_list'])","            subprocess.call([","                'rm', '-rf',","                'os_baseline',","                'output'])","            subprocess.call([","                'rm',","                'dir_list'])"]}],"source":"\n import cloudpulse from cloudpulse.operator.ansible.ansible_runner import ansible_runner import json import os TMP_LOCATION=\"\/tmp\/sec_hc\/\" class SecurityFileCheck(object): def perform_file_permission_check(self, input_params): try: print(\"Executing the test \", input_params.get('testcase_name')) final_result=[] final_status=[] final_msg=[] file_info_dir=input_params['global_data']['file_info_dir'] is_containerized=input_params['global_data']['is_containerized'] perform_on=input_params['perform_on'] if perform_on is None or not perform_on: print(\"Perform on should be mentioned either at test level\" + \" or test case level\") msg={'message': 'Perform on should be mentioned either at' + ' test level or test case level'} return(404, json.dumps([msg]),[]) os_hostobj_list=input_params['os_host_list'] base_dir=os.path.dirname(cloudpulse.__file__) baseline_file=input_params['baseline_file'] flist=[base_dir + \"\/scenario\/plugins\/security_pulse\/testcase\/\" + \"remote_file_check.py\", base_dir +\"\/scenario\/plugins\/security_pulse\/testcase\/\" + \"remote_filecredentials.py\", \"\/tmp\/sec_hc\/dir_list\", \"\/tmp\/sec_hc\/os_baseline\"] def ConsolidateResults(flist, container_name=None): result=ans_runner.execute_cmd( \"python \" + TMP_LOCATION + \"remote_file_check.py \", file_list=flist, container_name=container_name) Result=ans_runner.get_parsed_ansible_output(result) final_status.append(Result[0]) final_result.extend(eval(Result[1])) final_msg.extend(Result[2]) for p in perform_on: for obj in os_hostobj_list: ans_runner=ansible_runner([obj]) if obj.getRole()==p: os_dir=input_params[p +'_dir'] all_baseline=eval(open(baseline_file).read()) baseline=all_baseline[p] open( file_info_dir + 'os_baseline', 'w').write( str(baseline)) if is_containerized: for container, os_dir in os_dir.items(): self.createDirList( os_dir, file_info_dir) ConsolidateResults( flist, container_name=container) os.system('rm ' +file_info_dir +'dir_list ') else: os_dir_list=[] [os_dir_list.extend(d) for d in os_dir.values()] self.createDirList(os_dir_list, file_info_dir) ConsolidateResults(flist) os.system( 'rm -rf ' + file_info_dir + 'os_baseline ' + file_info_dir + 'output') os.system( 'rm ' + file_info_dir + 'dir_list ') if 404 in final_status: return(404, final_result, final_msg) else: return(200, final_result, final_msg) except Exception as e: print(\"exception in perform_file_permission_check is--\", e) os.system( 'rm -rf ' + file_info_dir + 'os_baseline ' + file_info_dir + 'output') os.system( 'rm ' + file_info_dir + 'dir_list ') print( \"Exception occured in executing\" + \" perform_file_permission_check\") message={ 'message': 'Test case execution failed due to some exception'} return(404, json.dumps([message]),[]) def createDirList(self, os_dir, file_info_dir): if os_dir is not None: f=open(file_info_dir +'dir_list', 'w+') for dir_name in os_dir: f.write(dir_name +'\\n') f.close() if __name__=='__main__': sec=SecurityFileCheck() sec.perform_file_permission_check() ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport cloudpulse\nfrom cloudpulse.operator.ansible.ansible_runner import ansible_runner\nimport json\nimport os\n\nTMP_LOCATION = \"\/tmp\/sec_hc\/\"\n\n\nclass SecurityFileCheck(object):\n\n    def perform_file_permission_check(self, input_params):\n        try:\n            print (\"Executing the test \", input_params.get('testcase_name'))\n            final_result = []\n            final_status = []\n            final_msg = []\n            file_info_dir = input_params['global_data']['file_info_dir']\n            is_containerized = input_params['global_data']['is_containerized']\n            perform_on = input_params['perform_on']\n            if perform_on is None or not perform_on:\n                print (\"Perform on should be mentioned either at test level\" +\n                       \" or test case level\")\n                msg = {'message': 'Perform on should be mentioned either at' +\n                       ' test level or test case level'}\n                return (404, json.dumps([msg]), [])\n            os_hostobj_list = input_params['os_host_list']\n            base_dir = os.path.dirname(cloudpulse.__file__)\n            baseline_file = input_params['baseline_file']\n            flist = [base_dir +\n                     \"\/scenario\/plugins\/security_pulse\/testcase\/\" +\n                     \"remote_file_check.py\",\n                     base_dir + \"\/scenario\/plugins\/security_pulse\/testcase\/\" +\n                     \"remote_filecredentials.py\",\n                     \"\/tmp\/sec_hc\/dir_list\",\n                     \"\/tmp\/sec_hc\/os_baseline\"]\n\n            def ConsolidateResults(flist, container_name=None):\n                result = ans_runner.execute_cmd(\n                    \"python \" +\n                    TMP_LOCATION +\n                    \"remote_file_check.py \",\n                    file_list=flist, container_name=container_name)\n                Result = ans_runner.get_parsed_ansible_output(result)\n                final_status.append(Result[0])\n                final_result.extend(eval(Result[1]))\n                final_msg.extend(Result[2])\n\n            for p in perform_on:\n                for obj in os_hostobj_list:\n                    ans_runner = ansible_runner([obj])\n                    if obj.getRole() == p:\n                        os_dir = input_params[p + '_dir']\n                        all_baseline = eval(open(baseline_file).read())\n                        baseline = all_baseline[p]\n                        open(\n                            file_info_dir +\n                            'os_baseline',\n                            'w').write(\n                            str(baseline))\n\n                        # if container, make dir list and copy to container\n                        if is_containerized:\n                            for container, os_dir in os_dir.items():\n                                self.createDirList(\n                                    os_dir,\n                                    file_info_dir)\n                                ConsolidateResults(\n                                    flist,\n                                    container_name=container)\n                                os.system('rm ' + file_info_dir + 'dir_list ')\n\n                        else:\n                            os_dir_list = []\n                            [os_dir_list.extend(d) for d in os_dir.values()]\n                            # os_dir = os_dir.values()\n                            self.createDirList(os_dir_list, file_info_dir)\n                            # flist.append(\"\/tmp\/sec_hc\/dir_list\")\n                            ConsolidateResults(flist)\n            os.system(\n                'rm -rf ' +\n                file_info_dir +\n                'os_baseline ' +\n                file_info_dir +\n                'output')\n            os.system(\n                'rm ' +\n                file_info_dir +\n                'dir_list ')\n            if 404 in final_status:\n                return (404, final_result, final_msg)\n            else:\n                return (200, final_result, final_msg)\n        except Exception as e:\n            print (\"exception in perform_file_permission_check is--\", e)\n            os.system(\n                'rm -rf ' +\n                file_info_dir +\n                'os_baseline ' +\n                file_info_dir +\n                'output')\n            os.system(\n                'rm ' +\n                file_info_dir +\n                'dir_list ')\n            print (\n                \"Exception occured in executing\" +\n                \" perform_file_permission_check\")\n            message = {\n                'message': 'Test case execution failed due to some exception'}\n            return (404, json.dumps([message]), [])\n\n    def createDirList(self, os_dir, file_info_dir):\n        if os_dir is not None:\n            f = open(file_info_dir + 'dir_list', 'w+')\n            for dir_name in os_dir:\n                f.write(dir_name + '\\n')\n            f.close()\n\nif __name__ == '__main__':\n    sec = SecurityFileCheck()\n    sec.perform_file_permission_check()\n"},"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/generate_baseline.py":{"changes":[{"diff":"\n             openstack_host_list = oscfg_reader.get_host_list()\n             baseline_data = {}\n             for host in openstack_host_list:\n-                f = open('\/tmp\/sec_hc\/dir_list', 'w+')\n+                f = open('\/var\/sec_hc\/dir_list', 'w+')\n                 for dir_name in host.getDirList():\n                     f.write(dir_name + '\\n')\n                 f.close()\n","add":1,"remove":1,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/generate_baseline.py","badparts":["                f = open('\/tmp\/sec_hc\/dir_list', 'w+')"],"goodparts":["                f = open('\/var\/sec_hc\/dir_list', 'w+')"]},{"diff":"\n                 base_dir += '\/scenario\/plugins\/security_pulse\/testcase'\n                 flist = [base_dir + '\/remote_baseline.py',\n                          base_dir + '\/remote_filecredentials.py',\n-                         '\/tmp\/sec_hc\/dir_list'\n+                         '\/var\/sec_hc\/dir_list'\n                          ]\n                 results = ans_runner.execute_cmd(\n                     \"python \" +\n-                    '\/tmp\/sec_hc\/' +\n+                    '\/var\/sec_hc\/' +\n                     \"remote_baseline.py \",\n                     file_list=flist)\n                 # for node in results['contacted'].keys():\n","add":2,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/generate_baseline.py","badparts":["                         '\/tmp\/sec_hc\/dir_list'","                    '\/tmp\/sec_hc\/' +"],"goodparts":["                         '\/var\/sec_hc\/dir_list'","                    '\/var\/sec_hc\/' +"]},{"diff":"\n                 node = host.getIp()\n                 data = results['contacted'][node]['stdout']\n \n-                baseline_data.update({role: eval(data)})\n+                baseline_data.update({role: ast.literal_eval(data)})\n                 print (baseline_data)\n             formated_data = json.dumps(baseline_data, indent=4)\n-            open('\/tmp\/sec_hc\/os_allnode_baseline',\n+            open('\/var\/sec_hc\/os_allnode_baseline',\n                  'w+').write(str(formated_data))\n         except Exception as e:\n             print ","add":2,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/generate_baseline.py","badparts":["                baseline_data.update({role: eval(data)})","            open('\/tmp\/sec_hc\/os_allnode_baseline',"],"goodparts":["                baseline_data.update({role: ast.literal_eval(data)})","            open('\/var\/sec_hc\/os_allnode_baseline',"]}],"source":"\n import cloudpulse from cloudpulse.operator.ansible.ansible_runner import ansible_runner from cloudpulse.operator.ansible import openstack_config_reader as os_cfg import json import os import sys class BaseLine(object): def base_line(self, os_baseline_cfg): try: oscfg_reader=os_cfg.os_cfg_reader(os_baseline_cfg) oscfg_reader.setOpenstackNodeIp() oscfg_reader.printHostList() openstack_host_list=oscfg_reader.get_host_list() baseline_data={} for host in openstack_host_list: f=open('\/tmp\/sec_hc\/dir_list', 'w+') for dir_name in host.getDirList(): f.write(dir_name +'\\n') f.close() ans_runner=ansible_runner([host]) base_dir=os.path.dirname(cloudpulse.__file__) base_dir +='\/scenario\/plugins\/security_pulse\/testcase' flist=[base_dir +'\/remote_baseline.py', base_dir +'\/remote_filecredentials.py', '\/tmp\/sec_hc\/dir_list' ] results=ans_runner.execute_cmd( \"python \" + '\/tmp\/sec_hc\/' + \"remote_baseline.py \", file_list=flist) role=host.getRole() node=host.getIp() data=results['contacted'][node]['stdout'] baseline_data.update({role: eval(data)}) print(baseline_data) formated_data=json.dumps(baseline_data, indent=4) open('\/tmp\/sec_hc\/os_allnode_baseline', 'w+').write(str(formated_data)) except Exception as e: print(e) if __name__=='__main__': os_cfg_file=sys.argv[1] sec=BaseLine() sec.base_line(os_cfg_file) ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport cloudpulse\nfrom cloudpulse.operator.ansible.ansible_runner import ansible_runner\nfrom cloudpulse.operator.ansible import openstack_config_reader as os_cfg\nimport json\nimport os\nimport sys\n\n\nclass BaseLine(object):\n\n    def base_line(self, os_baseline_cfg):\n        try:\n            oscfg_reader = os_cfg.os_cfg_reader(os_baseline_cfg)\n            oscfg_reader.setOpenstackNodeIp()\n            oscfg_reader.printHostList()\n            openstack_host_list = oscfg_reader.get_host_list()\n            baseline_data = {}\n            for host in openstack_host_list:\n                f = open('\/tmp\/sec_hc\/dir_list', 'w+')\n                for dir_name in host.getDirList():\n                    f.write(dir_name + '\\n')\n                f.close()\n                ans_runner = ansible_runner([host])\n                # execute_cmd\n                base_dir = os.path.dirname(cloudpulse.__file__)\n                base_dir += '\/scenario\/plugins\/security_pulse\/testcase'\n                flist = [base_dir + '\/remote_baseline.py',\n                         base_dir + '\/remote_filecredentials.py',\n                         '\/tmp\/sec_hc\/dir_list'\n                         ]\n                results = ans_runner.execute_cmd(\n                    \"python \" +\n                    '\/tmp\/sec_hc\/' +\n                    \"remote_baseline.py \",\n                    file_list=flist)\n                # for node in results['contacted'].keys():\n                role = host.getRole()\n                node = host.getIp()\n                data = results['contacted'][node]['stdout']\n\n                baseline_data.update({role: eval(data)})\n                print (baseline_data)\n            formated_data = json.dumps(baseline_data, indent=4)\n            open('\/tmp\/sec_hc\/os_allnode_baseline',\n                 'w+').write(str(formated_data))\n        except Exception as e:\n            print (e)\n\nif __name__ == '__main__':\n    os_cfg_file = sys.argv[1]\n    sec = BaseLine()\n    sec.base_line(os_cfg_file)\n"},"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/ks_admin_token_check.py":{"changes":[{"diff":"\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n import json\n import os\n-\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+import subprocess\n \n \n class ks_admin_token_check(object):\n","add":1,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/ks_admin_token_check.py","badparts":["TMP_LOCATION = \"\/tmp\/sec_hc\/\""],"goodparts":["import subprocess"]},{"diff":"\n             container_name = input_params['input']['container_name']\n         result = ans_runner.execute_cmd(\n             \"python \" +\n-            TMP_LOCATION +\n+            file_info_dir +\n             \"keystone_admin_token_check.py \",\n             file_list=flist, container_name=container_name)\n         Result = ans_runner.get_parsed_ansible_output(result)\n-        os.system('rm -rf ' + file_info_dir + 'output')\n+        subprocess.call(['rm', '-rf', file_info_dir + 'output'])\n         return Re","add":2,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/ks_admin_token_check.py","badparts":["            TMP_LOCATION +","        os.system('rm -rf ' + file_info_dir + 'output')"],"goodparts":["            file_info_dir +","        subprocess.call(['rm', '-rf', file_info_dir + 'output'])"]}],"source":"\n from __future__ import print_function import cloudpulse from cloudpulse.operator.ansible.ansible_runner import ansible_runner import json import os TMP_LOCATION=\"\/tmp\/sec_hc\/\" class ks_admin_token_check(object): def perform_ks_admin_token_check_test(self, input_params): print(\"Executing the test \", input_params.get('testcase_name')) file_info_dir=input_params['global_data']['file_info_dir'] is_containerized=input_params['global_data']['is_containerized'] perform_on=input_params['perform_on'] if perform_on is None or not perform_on: print(\"Perform on should be mentioned either at \\ test level or test case level\") msg={ 'message': 'Perform on should be mentioned either ' + 'at test level or test case level'} return(404, json.dumps([msg]),[]) os_hostobj_list=input_params['os_host_list'] base_dir=os.path.dirname(cloudpulse.__file__) flist=[base_dir + \"\/scenario\/plugins\/security_pulse\/testcase\/\" + \"keystone_admin_token_check.py\"] ans_runner=ansible_runner(os_hostobj_list) container_name=None if is_containerized: container_name=input_params['input']['container_name'] result=ans_runner.execute_cmd( \"python \" + TMP_LOCATION + \"keystone_admin_token_check.py \", file_list=flist, container_name=container_name) Result=ans_runner.get_parsed_ansible_output(result) os.system('rm -rf ' +file_info_dir +'output') return Result ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom __future__ import print_function\nimport cloudpulse\nfrom cloudpulse.operator.ansible.ansible_runner import ansible_runner\nimport json\nimport os\n\nTMP_LOCATION = \"\/tmp\/sec_hc\/\"\n\n\nclass ks_admin_token_check(object):\n\n    def perform_ks_admin_token_check_test(self, input_params):\n        print (\"Executing the test \", input_params.get('testcase_name'))\n        file_info_dir = input_params['global_data']['file_info_dir']\n        is_containerized = input_params['global_data']['is_containerized']\n        perform_on = input_params['perform_on']\n        if perform_on is None or not perform_on:\n            print (\"Perform on should be mentioned either at \\\n                    test level or test case level\")\n            msg = {\n                'message': 'Perform on should be mentioned either ' +\n                'at test level or test case level'}\n            return (404, json.dumps([msg]), [])\n        os_hostobj_list = input_params['os_host_list']\n        base_dir = os.path.dirname(cloudpulse.__file__)\n        flist = [base_dir +\n                 \"\/scenario\/plugins\/security_pulse\/testcase\/\" +\n                 \"keystone_admin_token_check.py\"]\n        ans_runner = ansible_runner(os_hostobj_list)\n        container_name = None\n        if is_containerized:\n            container_name = input_params['input']['container_name']\n        result = ans_runner.execute_cmd(\n            \"python \" +\n            TMP_LOCATION +\n            \"keystone_admin_token_check.py \",\n            file_list=flist, container_name=container_name)\n        Result = ans_runner.get_parsed_ansible_output(result)\n        os.system('rm -rf ' + file_info_dir + 'output')\n        return Result\n"},"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/mysql_tls_enable_test.py":{"changes":[{"diff":"\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n import json\n import os\n-\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+import subprocess\n \n \n class mysql_tls_enablement_test(object):\n","add":1,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/mysql_tls_enable_test.py","badparts":["TMP_LOCATION = \"\/tmp\/sec_hc\/\""],"goodparts":["import subprocess"]},{"diff":"\n                 container_name = input_params['input']['container_name']\n             result = ans_runner.execute_cmd(\n                 \"python \" +\n-                TMP_LOCATION +\n+                file_info_dir +\n                 \"remote_mysql_tls_enablement_check.py \",\n                 file_list=flist, container_name=container_name)\n             Result = ans_runner.get_parsed_ansible_output(result)\n-            os.system('rm -rf ' + file_info_dir + 'output')\n+            subprocess.call(['rm', '-rf', file_info_dir + 'output'])\n             return Result\n         except Exception as msg:\n             pr","add":2,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/mysql_tls_enable_test.py","badparts":["                TMP_LOCATION +","            os.system('rm -rf ' + file_info_dir + 'output')"],"goodparts":["                file_info_dir +","            subprocess.call(['rm', '-rf', file_info_dir + 'output'])"]}],"source":"\n import cloudpulse from cloudpulse.operator.ansible.ansible_runner import ansible_runner import json import os TMP_LOCATION=\"\/tmp\/sec_hc\/\" class mysql_tls_enablement_test(object): def perform_mysql_tls_enablement_test(self, input_params): try: file_info_dir=input_params['global_data']['file_info_dir'] is_containerized=input_params['global_data']['is_containerized'] perform_on=input_params['perform_on'] if perform_on is None or not perform_on: print(\"Perform on should be mentioned either at test level \\ or test case level\") message={ 'message': 'Perform on should be mentioned either at \\ test level or test case level'} return(404, json.dumps([message]),[]) os_hostobj_list=input_params['os_host_list'] base_dir=os.path.dirname(cloudpulse.__file__) flist=[base_dir +\"\/scenario\/plugins\/security_pulse\" + \"\/testcase\/remote_mysql_tls_enablement_check.py\"] ans_runner=ansible_runner(os_hostobj_list) container_name=None if is_containerized: container_name=input_params['input']['container_name'] result=ans_runner.execute_cmd( \"python \" + TMP_LOCATION + \"remote_mysql_tls_enablement_check.py \", file_list=flist, container_name=container_name) Result=ans_runner.get_parsed_ansible_output(result) os.system('rm -rf ' +file_info_dir +'output') return Result except Exception as msg: print( \"Exception while executing perform_mysql_tls_enablement_test\") print(msg) message={ 'message': 'Test case execution failed due to some exception'} return(404, json.dumps([message]),[]) ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport cloudpulse\nfrom cloudpulse.operator.ansible.ansible_runner import ansible_runner\nimport json\nimport os\n\nTMP_LOCATION = \"\/tmp\/sec_hc\/\"\n\n\nclass mysql_tls_enablement_test(object):\n\n    def perform_mysql_tls_enablement_test(self, input_params):\n        try:\n            file_info_dir = input_params['global_data']['file_info_dir']\n            is_containerized = input_params['global_data']['is_containerized']\n            perform_on = input_params['perform_on']\n            if perform_on is None or not perform_on:\n                print (\"Perform on should be mentioned either at test level \\\n                    or test case level\")\n                message = {\n                    'message': 'Perform on should be mentioned either at \\\n                    test level or test case level'}\n                return (404, json.dumps([message]), [])\n            os_hostobj_list = input_params['os_host_list']\n            base_dir = os.path.dirname(cloudpulse.__file__)\n            flist = [base_dir + \"\/scenario\/plugins\/security_pulse\" +\n                     \"\/testcase\/remote_mysql_tls_enablement_check.py\"]\n            ans_runner = ansible_runner(os_hostobj_list)\n            container_name = None\n            if is_containerized:\n                container_name = input_params['input']['container_name']\n            result = ans_runner.execute_cmd(\n                \"python \" +\n                TMP_LOCATION +\n                \"remote_mysql_tls_enablement_check.py \",\n                file_list=flist, container_name=container_name)\n            Result = ans_runner.get_parsed_ansible_output(result)\n            os.system('rm -rf ' + file_info_dir + 'output')\n            return Result\n        except Exception as msg:\n            print (\n                \"Exception while executing perform_mysql_tls_enablement_test\")\n            print (msg)\n            message = {\n                'message': 'Test case execution failed due to some exception'}\n            return (404, json.dumps([message]), [])\n"},"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_baseline.py":{"changes":[{"diff":"\n \n if __name__ == '__main__':\n     # LOG.info('Executing test')\n-    file_dir = '\/tmp\/sec_hc\/'\n+    file_dir = '\/var\/sec_hc\/'\n     dirs = []\n     with open(file_dir + 'dir_list') as f:\n         dirs = f.read().splitl","add":1,"remove":1,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_baseline.py","badparts":["    file_dir = '\/tmp\/sec_hc\/'"],"goodparts":["    file_dir = '\/var\/sec_hc\/'"]}],"source":"\n import os import pwd import remote_filecredentials as filecredentials import stat class FileTraversal(object): def file_traversal(self, dir_list, file_dir): try: output={} for dir_name in dir_list: self.rootDir=dir_name for dirName, subdirList, fileList in os.walk(self.rootDir): os.chdir(dirName) for f1 in fileList: st=os.stat(f1) ins=filecredentials.AccessPreveliges( f1, st[stat.ST_SIZE], oct( stat.S_IMODE( st[ stat.ST_MODE])), pwd.getpwuid( st[stat.ST_UID]), pwd.getpwuid( st[stat.ST_GID])) output.update( { ins.getName():{ 'size': ins.getSize(), 'mode': ins.getMode(), 'user': ins.getUser(), 'group': ins.getGroup()}}) print(output) except Exception as e: print(e) if __name__=='__main__': file_dir='\/tmp\/sec_hc\/' dirs=[] with open(file_dir +'dir_list') as f: dirs=f.read().splitlines() sec=FileTraversal() sec.file_traversal(dirs, file_dir) ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport os\nimport pwd\nimport remote_filecredentials as filecredentials\nimport stat\n\n\nclass FileTraversal(object):\n\n    def file_traversal(self, dir_list, file_dir):\n        try:\n\n            output = {}\n            for dir_name in dir_list:\n                self.rootDir = dir_name\n                for dirName, subdirList, fileList in os.walk(self.rootDir):\n                    os.chdir(dirName)\n                    for f1 in fileList:\n                        st = os.stat(f1)\n                        ins = filecredentials.AccessPreveliges(\n                            f1, st[stat.ST_SIZE], oct(\n                                stat.S_IMODE(\n                                    st[\n                                        stat.ST_MODE])), pwd.getpwuid(\n                                st[stat.ST_UID]), pwd.getpwuid(\n                                st[stat.ST_GID]))\n                        output.update(\n                            {\n                                ins.getName(): {\n                                    'size': ins.getSize(),\n                                    'mode': ins.getMode(),\n                                    'user': ins.getUser(),\n                                    'group': ins.getGroup()}})\n            print (output)\n        except Exception as e:\n            print (e)\n\n\nif __name__ == '__main__':\n    # LOG.info('Executing test')\n    file_dir = '\/tmp\/sec_hc\/'\n    dirs = []\n    with open(file_dir + 'dir_list') as f:\n        dirs = f.read().splitlines()\n\n    sec = FileTraversal()\n\n    # LOG.info('Executing test1')\n    sec.file_traversal(dirs, file_dir)\n"},"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_file_check.py":{"changes":[{"diff":"\n                                     'mode': ins.getMode(),\n                                     'user': ins.getUser(),\n                                     'group': ins.getGroup()}})\n-            keystone_baseline = eval(open(file_dir + 'os_baseline').read())\n+            keystone_baseline = ast.literal_eval(\n+                open(file_dir + 'os_baseline').read())\n             remote_mismatch = list(set(output.keys()).\n                                    difference(keystone_baseline.keys()))\n             baseline_mismatch = list(set(keystone_baseline.keys()).\n","add":2,"remove":1,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_file_check.py","badparts":["            keystone_baseline = eval(open(file_dir + 'os_baseline').read())"],"goodparts":["            keystone_baseline = ast.literal_eval(","                open(file_dir + 'os_baseline').read())"]},{"diff":"\n                             ' in remote')\n                     msg = string.join(l, ', ')\n                     if msg:\n-                        temp = {'Test Case Name': key, 'Status': 'Fail'}\n-                        temp.update({'Message': msg})\n+                        temp = {'test_case_name': key, 'Status': 'Fail'}\n+                        temp.update({'message': msg})\n                         result.append(temp)\n             if baseline_mismatch:\n                 for item in baseline_mismatch:\n                     msg = 'File not found in remote'\n-                    temp = {'Test Case Name': item, 'Status': 'Fail'}\n-                    temp.update({'Message': msg})\n+                    temp = {'test_case_name': item, 'Status': 'Fail'}\n+                    temp.update({'message': msg})\n                     result.append(temp)\n             if remote_mismatch:\n                 for item in remote_mismatch:\n                     msg = 'New file found in remote'\n-                    temp = {'Test Case Name': item, 'Status': 'Fail'}\n-                    temp.update({'Message': msg})\n+                    temp = {'test_case_name': item, 'Status': 'Fail'}\n+                    temp.update({'message': msg})\n                     result.append(temp)\n             if not result:\n                 overall_status = True\n                 final_result.update(\n                     {'OverallStatus': overall_status})\n                 result = {}\n-                result.update({'Test Case Name': 'File permission Check'})\n-                result.update({'Status': 'Pass'})\n-                result.update({'Message': 'No mismatch'})\n+                result.update({'test_case_name': 'File permission Check'})\n+                result.update({'status': 'Pass'})\n+                result.update({'message': 'No mismatch'})\n                 final_result.update({'result': [result]})\n                 print (final_result)\n                 return\n","add":9,"remove":9,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_file_check.py","badparts":["                        temp = {'Test Case Name': key, 'Status': 'Fail'}","                        temp.update({'Message': msg})","                    temp = {'Test Case Name': item, 'Status': 'Fail'}","                    temp.update({'Message': msg})","                    temp = {'Test Case Name': item, 'Status': 'Fail'}","                    temp.update({'Message': msg})","                result.update({'Test Case Name': 'File permission Check'})","                result.update({'Status': 'Pass'})","                result.update({'Message': 'No mismatch'})"],"goodparts":["                        temp = {'test_case_name': key, 'Status': 'Fail'}","                        temp.update({'message': msg})","                    temp = {'test_case_name': item, 'Status': 'Fail'}","                    temp.update({'message': msg})","                    temp = {'test_case_name': item, 'Status': 'Fail'}","                    temp.update({'message': msg})","                result.update({'test_case_name': 'File permission Check'})","                result.update({'status': 'Pass'})","                result.update({'message': 'No mismatch'})"]},{"diff":"\n             final_result.update(\n                 {'OverallStatus': False})\n             result = {}\n-            result.update({'Test Case Name': 'File permission Check'})\n-            result.update({'Status': 'Fail'})\n+            result.update({'test_case_name': 'File permission Check'})\n+            result.update({'status': 'Fail'})\n             result.update(\n-                {'Message': 'Exception in file comparision' + str(e)})\n+                {'message': 'Exception in file comparision' + str(e)})\n             final_result.update({'result': [result]})\n             print (final_result)\n             return\n \n if __name__ == '__main__':\n-    file_dir = '\/tmp\/sec_hc\/'\n+    file_dir = '\/var\/sec_hc\/'\n     dirs = []\n     with open(file_dir + 'dir_list') as f:\n         dirs = f.read().split","add":4,"remove":4,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/remote_file_check.py","badparts":["            result.update({'Test Case Name': 'File permission Check'})","            result.update({'Status': 'Fail'})","                {'Message': 'Exception in file comparision' + str(e)})","    file_dir = '\/tmp\/sec_hc\/'"],"goodparts":["            result.update({'test_case_name': 'File permission Check'})","            result.update({'status': 'Fail'})","                {'message': 'Exception in file comparision' + str(e)})","    file_dir = '\/var\/sec_hc\/'"]}],"source":"\n import os import pwd import remote_filecredentials as filecredentials import stat import string class FileCheck(object): def file_check(self, dir_list, file_dir): try: output={} result=[] final_result={} overall_status=True for dir_name in dir_list: self.rootDir=dir_name for dirName, subdirList, fileList in os.walk(self.rootDir): os.chdir(dirName) for f1 in fileList: st=os.stat(f1) ins=filecredentials.AccessPreveliges( f1, st[stat.ST_SIZE], oct( stat.S_IMODE( st[ stat.ST_MODE])), pwd.getpwuid( st[stat.ST_UID]), pwd.getpwuid( st[stat.ST_GID])) output.update( { ins.getName():{ 'size': ins.getSize(), 'mode': ins.getMode(), 'user': ins.getUser(), 'group': ins.getGroup()}}) keystone_baseline=eval(open(file_dir +'os_baseline').read()) remote_mismatch=list(set(output.keys()). difference(keystone_baseline.keys())) baseline_mismatch=list(set(keystone_baseline.keys()). difference(output.keys())) for key in output.keys(): if key in keystone_baseline: new=output.get(key) base=keystone_baseline[key] diffkeys=[k for k in base if base[k] !=new[k]] l=[] for k in diffkeys: l.append( '\"' + k + '\"' + ' is modified from ' + base[k] + ' to ' + new[k] + ' in remote') msg=string.join(l, ', ') if msg: temp={'Test Case Name': key, 'Status': 'Fail'} temp.update({'Message': msg}) result.append(temp) if baseline_mismatch: for item in baseline_mismatch: msg='File not found in remote' temp={'Test Case Name': item, 'Status': 'Fail'} temp.update({'Message': msg}) result.append(temp) if remote_mismatch: for item in remote_mismatch: msg='New file found in remote' temp={'Test Case Name': item, 'Status': 'Fail'} temp.update({'Message': msg}) result.append(temp) if not result: overall_status=True final_result.update( {'OverallStatus': overall_status}) result={} result.update({'Test Case Name': 'File permission Check'}) result.update({'Status': 'Pass'}) result.update({'Message': 'No mismatch'}) final_result.update({'result':[result]}) print(final_result) return else: final_result.update( {'OverallStatus': False}) final_result.update({'result': result}) print(final_result) return except Exception as e: final_result.update( {'OverallStatus': False}) result={} result.update({'Test Case Name': 'File permission Check'}) result.update({'Status': 'Fail'}) result.update( {'Message': 'Exception in file comparision' +str(e)}) final_result.update({'result':[result]}) print(final_result) return if __name__=='__main__': file_dir='\/tmp\/sec_hc\/' dirs=[] with open(file_dir +'dir_list') as f: dirs=f.read().splitlines() sec=FileCheck() sec.file_check(dirs, file_dir) ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport os\nimport pwd\nimport remote_filecredentials as filecredentials\nimport stat\nimport string\n\n\nclass FileCheck(object):\n\n    def file_check(self, dir_list, file_dir):\n        try:\n            output = {}\n            result = []\n            final_result = {}\n            overall_status = True\n            for dir_name in dir_list:\n                self.rootDir = dir_name\n                for dirName, subdirList, fileList in os.walk(self.rootDir):\n                    # flist = []\n                    # for f in fileList:\n                    #    flist.append(os.path.abspath(os.path.join(dirName,f)))\n                    os.chdir(dirName)\n                    for f1 in fileList:  # flist\n                        st = os.stat(f1)\n                        ins = filecredentials.AccessPreveliges(\n                            f1, st[stat.ST_SIZE], oct(\n                                stat.S_IMODE(\n                                    st[\n                                        stat.ST_MODE])), pwd.getpwuid(\n                                st[stat.ST_UID]), pwd.getpwuid(\n                                st[stat.ST_GID]))\n                        output.update(\n                            {\n                                ins.getName(): {\n                                    'size': ins.getSize(),\n                                    'mode': ins.getMode(),\n                                    'user': ins.getUser(),\n                                    'group': ins.getGroup()}})\n            keystone_baseline = eval(open(file_dir + 'os_baseline').read())\n            remote_mismatch = list(set(output.keys()).\n                                   difference(keystone_baseline.keys()))\n            baseline_mismatch = list(set(keystone_baseline.keys()).\n                                     difference(output.keys()))\n            for key in output.keys():\n                if key in keystone_baseline:\n                    new = output.get(key)\n                    base = keystone_baseline[key]\n                    diffkeys = [k for k in base if base[k] != new[k]]\n                    l = []\n                    for k in diffkeys:\n                        l.append(\n                            '\"' +\n                            k +\n                            '\"' +\n                            ' is modified from ' +\n                            base[k] +\n                            ' to ' +\n                            new[k] +\n                            ' in remote')\n                    msg = string.join(l, ', ')\n                    if msg:\n                        temp = {'Test Case Name': key, 'Status': 'Fail'}\n                        temp.update({'Message': msg})\n                        result.append(temp)\n            if baseline_mismatch:\n                for item in baseline_mismatch:\n                    msg = 'File not found in remote'\n                    temp = {'Test Case Name': item, 'Status': 'Fail'}\n                    temp.update({'Message': msg})\n                    result.append(temp)\n            if remote_mismatch:\n                for item in remote_mismatch:\n                    msg = 'New file found in remote'\n                    temp = {'Test Case Name': item, 'Status': 'Fail'}\n                    temp.update({'Message': msg})\n                    result.append(temp)\n            if not result:\n                overall_status = True\n                final_result.update(\n                    {'OverallStatus': overall_status})\n                result = {}\n                result.update({'Test Case Name': 'File permission Check'})\n                result.update({'Status': 'Pass'})\n                result.update({'Message': 'No mismatch'})\n                final_result.update({'result': [result]})\n                print (final_result)\n                return\n            else:\n                final_result.update(\n                    {'OverallStatus': False})\n                final_result.update({'result': result})\n                print (final_result)\n                return\n        except Exception as e:\n            final_result.update(\n                {'OverallStatus': False})\n            result = {}\n            result.update({'Test Case Name': 'File permission Check'})\n            result.update({'Status': 'Fail'})\n            result.update(\n                {'Message': 'Exception in file comparision' + str(e)})\n            final_result.update({'result': [result]})\n            print (final_result)\n            return\n\nif __name__ == '__main__':\n    file_dir = '\/tmp\/sec_hc\/'\n    dirs = []\n    with open(file_dir + 'dir_list') as f:\n        dirs = f.read().splitlines()\n    sec = FileCheck()\n    sec.file_check(dirs, file_dir)\n"},"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/tls_enable_test.py":{"changes":[{"diff":"\n from cloudpulse.operator.ansible.ansible_runner import ansible_runner\n import json\n import os\n-\n-TMP_LOCATION = \"\/tmp\/sec_hc\/\"\n+import subprocess\n \n \n class tls_enablement_test(object):\n","add":1,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/tls_enable_test.py","badparts":["TMP_LOCATION = \"\/tmp\/sec_hc\/\""],"goodparts":["import subprocess"]},{"diff":"\n             container_name = input_params['input']['container_name']\n         result = ans_runner.execute_cmd(\n             \"python \" +\n-            TMP_LOCATION +\n+            file_info_dir +\n             \"TLS_Enablement_Check.py \",\n             file_list=flist, container_name=container_name)\n         Result = ans_runner.get_parsed_ansible_output(result)\n-        os.system('rm -rf ' + file_info_dir + 'output')\n+        subprocess.call(['rm', '-rf', file_info_dir + 'output'])\n         return Result\n","add":2,"remove":2,"filename":"\/cloudpulse\/scenario\/plugins\/security_pulse\/testcase\/tls_enable_test.py","badparts":["            TMP_LOCATION +","        os.system('rm -rf ' + file_info_dir + 'output')"],"goodparts":["            file_info_dir +","        subprocess.call(['rm', '-rf', file_info_dir + 'output'])"]}],"source":"\n import cloudpulse from cloudpulse.operator.ansible.ansible_runner import ansible_runner import json import os TMP_LOCATION=\"\/tmp\/sec_hc\/\" class tls_enablement_test(object): def perform_tls_enablement_test(self, input_params): print(\"Executing the test \", input_params.get('testcase_name')) file_info_dir=input_params['global_data']['file_info_dir'] is_containerized=input_params['global_data']['is_containerized'] perform_on=input_params['perform_on'] if perform_on is None or not perform_on: print(\"Perform on should be mentioned either at test level \" + \"or test case level\") msg={ 'message': 'Perform on should be mentioned either at test ' + 'level or test case level'} return(404, json.dumps([msg]),[]) os_hostobj_list=input_params['os_host_list'] base_dir=os.path.dirname(cloudpulse.__file__) flist=[base_dir +\"\/scenario\/plugins\/security_pulse\" + \"\/testcase\/TLS_Enablement_Check.py\"] ans_runner=ansible_runner(os_hostobj_list) container_name=None if is_containerized: container_name=input_params['input']['container_name'] result=ans_runner.execute_cmd( \"python \" + TMP_LOCATION + \"TLS_Enablement_Check.py \", file_list=flist, container_name=container_name) Result=ans_runner.get_parsed_ansible_output(result) os.system('rm -rf ' +file_info_dir +'output') return Result ","sourceWithComments":"# Copyright 2010-2011 OpenStack Foundation\n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport cloudpulse\nfrom cloudpulse.operator.ansible.ansible_runner import ansible_runner\nimport json\nimport os\n\nTMP_LOCATION = \"\/tmp\/sec_hc\/\"\n\n\nclass tls_enablement_test(object):\n\n    def perform_tls_enablement_test(self, input_params):\n        print (\"Executing the test \", input_params.get('testcase_name'))\n        file_info_dir = input_params['global_data']['file_info_dir']\n        is_containerized = input_params['global_data']['is_containerized']\n        perform_on = input_params['perform_on']\n        if perform_on is None or not perform_on:\n            print (\"Perform on should be mentioned either at test level \" +\n                   \"or test case level\")\n            msg = {\n                'message': 'Perform on should be mentioned either at test ' +\n                'level or test case level'}\n            return (404, json.dumps([msg]), [])\n        os_hostobj_list = input_params['os_host_list']\n        base_dir = os.path.dirname(cloudpulse.__file__)\n        flist = [base_dir + \"\/scenario\/plugins\/security_pulse\" +\n                 \"\/testcase\/TLS_Enablement_Check.py\"]\n        ans_runner = ansible_runner(os_hostobj_list)\n        container_name = None\n        if is_containerized:\n            container_name = input_params['input']['container_name']\n        result = ans_runner.execute_cmd(\n            \"python \" +\n            TMP_LOCATION +\n            \"TLS_Enablement_Check.py \",\n            file_list=flist, container_name=container_name)\n        Result = ans_runner.get_parsed_ansible_output(result)\n        os.system('rm -rf ' + file_info_dir + 'output')\n        return Result\n"}},"msg":"Bandit fix for tmp directory usage and shell injection.\n\tIncludes eval to literal_eval fix\n\nChange-Id: I275c6cf0c0bc9b2620d6278f3069aa16016ece67"}},"https:\/\/github.com\/craigjmidwinter\/total-connect-client":{"3524dfbb8893433f3a2364a26d02fb49122677ad":{"url":"https:\/\/api.github.com\/repos\/craigjmidwinter\/total-connect-client\/commits\/3524dfbb8893433f3a2364a26d02fb49122677ad","html_url":"https:\/\/github.com\/craigjmidwinter\/total-connect-client\/commit\/3524dfbb8893433f3a2364a26d02fb49122677ad","message":"retry all the exceptions that might be raised by SOAP's underlying HTTP transport. some aren't fixable by a retry but it won't hurt to retry them either.\n\nunittests in python 3.7 has a bug when patching builtins.eval, so now we have a method _eval() that just calls eval(), only so that unittest dependency injection works.\n\ntox passes py37.","sha":"3524dfbb8893433f3a2364a26d02fb49122677ad","keyword":"eval injection fix","diff":"diff --git a\/tests\/test_client_request.py b\/tests\/test_client_request.py\nindex 5d96c75..34c163b 100644\n--- a\/tests\/test_client_request.py\n+++ b\/tests\/test_client_request.py\n@@ -22,6 +22,8 @@\n from total_connect_client.client import TotalConnectClient\n from total_connect_client.exceptions import AuthenticationError, TotalConnectError\n \n+PATCH_EVAL = \"total_connect_client.client.TotalConnectClient._eval\"\n+# PATCH_EVAL = \"builtins.eval\"  ### this should work but doesn't\n \n class FakeResponse:\n     \"\"\"Fake response from zeep.\"\"\"\n@@ -65,7 +67,7 @@ def tests_request_init(self):\n \n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n-        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n+        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:\n             client = TotalConnectClient(\"username\", \"password\", usercodes=None)\n             assert mock_request.call_count == 1\n             if client.locations:  # force client to fetch them\n@@ -87,7 +89,7 @@ def tests_request_init_bad_user_or_password(self):\n \n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n-        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n+        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:\n             with pytest.raises(AuthenticationError):\n                 TotalConnectClient(\"username\", \"password\", usercodes=None)\n             assert mock_request.call_count == 1\n@@ -107,7 +109,7 @@ def tests_request_init_failed_to_connect(self):\n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n         ), patch(\"time.sleep\", autospec=True), patch(\n-            \"builtins.eval\", side_effect=eval_responses\n+            PATCH_EVAL, side_effect=eval_responses\n         ) as mock_request, pytest.raises(\n             Exception\n         ) as e:\n@@ -137,7 +139,7 @@ def tests_request_connection_error(self):\n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n         ), patch(\"time.sleep\", autospec=True), patch(\n-            \"builtins.eval\", side_effect=eval_responses\n+            PATCH_EVAL, side_effect=eval_responses\n         ) as mock_request, pytest.raises(\n             Exception\n         ) as e:\n@@ -186,7 +188,7 @@ def tests_request_invalid_session(self):\n \n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n-        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n+        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:\n             client = TotalConnectClient(\"username\", \"password\", usercodes=None)\n             assert mock_request.call_count == 1\n             if client.locations:  # force client to fetch them\n@@ -209,7 +211,7 @@ def tests_request_unknown_result_code(self):\n \n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n-        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n+        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:\n             with pytest.raises(TotalConnectError):\n                 TotalConnectClient(\"username\", \"password\", usercodes=None)\n             assert mock_request.call_count == 1\ndiff --git a\/total_connect_client\/client.py b\/total_connect_client\/client.py\nindex e9f5840..f7cfa20 100644\n--- a\/total_connect_client\/client.py\n+++ b\/total_connect_client\/client.py\n@@ -13,6 +13,7 @@\n import warnings\n \n import zeep\n+import requests.exceptions\n \n from .const import ArmType\n from .exceptions import (\n@@ -178,6 +179,10 @@ def raise_for_resultcode(self, response):\n             raise AuthenticationError(\"user code unavailable\", response)\n         raise BadResultCodeError(f\"unknown result code {rc}\", response)\n \n+    def _eval(self, soap_request):\n+        \"\"\"unittest doesn't like injecting responses for builtins.eval\"\"\"\n+        return eval(soap_request)\n+\n     def request(self, request, attempts=0):\n         \"\"\"Send a SOAP request.\"\"\"\n \n@@ -187,10 +192,20 @@ def request(self, request, attempts=0):\n             )\n         try:\n             LOGGER.debug(f\"sending API request {request}\")\n-            r = eval(\"self.soap_client.service.\" + request)\n+            r = self._eval(\"self.soap_client.service.\" + request)\n             response = zeep.helpers.serialize_object(r)\n             self._raise_for_retry(response)\n             return response\n+        # To retry an exception that could be raised during the request,\n+        # add it to one of the following except blocks, depending on what\n+        # you want to have happen. The first two blocks are the same except\n+        # for what gets logged. The third block causes reauthentication.\n+        except requests.exceptions.RequestException as err:\n+            if attempts > self.MAX_RETRY_ATTEMPTS:\n+                raise\n+            LOGGER.info(f\"retrying {err}, attempt # {attempts}\")\n+            time.sleep(self.retry_delay)\n+            return self.request(request, attempts + 1)\n         except RetryableTotalConnectError as err:\n             if attempts > self.MAX_RETRY_ATTEMPTS:\n                 raise\n","files":{"\/tests\/test_client_request.py":{"changes":[{"diff":"\n \n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n-        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n+        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:\n             client = TotalConnectClient(\"username\", \"password\", usercodes=None)\n             assert mock_request.call_count == 1\n             if client.locations:  # force client to fetch them\n","add":1,"remove":1,"filename":"\/tests\/test_client_request.py","badparts":["        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:"],"goodparts":["        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:"]},{"diff":"\n \n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n-        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n+        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:\n             with pytest.raises(AuthenticationError):\n                 TotalConnectClient(\"username\", \"password\", usercodes=None)\n             assert mock_request.call_count == 1\n","add":1,"remove":1,"filename":"\/tests\/test_client_request.py","badparts":["        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:"],"goodparts":["        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:"]},{"diff":"\n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n         ), patch(\"time.sleep\", autospec=True), patch(\n-            \"builtins.eval\", side_effect=eval_responses\n+            PATCH_EVAL, side_effect=eval_responses\n         ) as mock_request, pytest.raises(\n             Exception\n         ) as e:\n","add":1,"remove":1,"filename":"\/tests\/test_client_request.py","badparts":["            \"builtins.eval\", side_effect=eval_responses"],"goodparts":["            PATCH_EVAL, side_effect=eval_responses"]},{"diff":"\n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n         ), patch(\"time.sleep\", autospec=True), patch(\n-            \"builtins.eval\", side_effect=eval_responses\n+            PATCH_EVAL, side_effect=eval_responses\n         ) as mock_request, pytest.raises(\n             Exception\n         ) as e:\n","add":1,"remove":1,"filename":"\/tests\/test_client_request.py","badparts":["            \"builtins.eval\", side_effect=eval_responses"],"goodparts":["            PATCH_EVAL, side_effect=eval_responses"]},{"diff":"\n \n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n-        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n+        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:\n             client = TotalConnectClient(\"username\", \"password\", usercodes=None)\n             assert mock_request.call_count == 1\n             if client.locations:  # force client to fetch them\n","add":1,"remove":1,"filename":"\/tests\/test_client_request.py","badparts":["        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:"],"goodparts":["        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:"]},{"diff":"\n \n         with patch(\n             \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n-        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n+        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:\n             with pytest.raises(TotalConnectError):\n                 TotalConnectClient(\"username\", \"password\", usercodes=None)\n             assert mock_request.call_count == 1","add":1,"remove":1,"filename":"\/tests\/test_client_request.py","badparts":["        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:"],"goodparts":["        ), patch(PATCH_EVAL, side_effect=eval_responses) as mock_request:"]}],"source":"\n\"\"\"Test total_connect_client request().\"\"\" import unittest from unittest.mock import patch import pytest from const import( LOCATION_INFO_BASIC_NORMAL, RESPONSE_ARMED_AWAY, RESPONSE_AUTHENTICATE, RESPONSE_BAD_USER_OR_PASSWORD, RESPONSE_CONNECTION_ERROR, RESPONSE_DISARMED, RESPONSE_FAILED_TO_CONNECT, RESPONSE_GET_ZONE_DETAILS_SUCCESS, RESPONSE_INVALID_SESSION, RESPONSE_PARTITION_DETAILS, RESPONSE_SESSION_INITIATED, RESPONSE_UNKNOWN, ) from total_connect_client.client import TotalConnectClient from total_connect_client.exceptions import AuthenticationError, TotalConnectError class FakeResponse: \"\"\"Fake response from zeep.\"\"\" def __init__(self, code, data): \"\"\"Initialize.\"\"\" self.ResultCode=code self.ResultData=data class TestTotalConnectClient(unittest.TestCase): \"\"\"Test TotalConnectClient request().\"\"\" def setUp(self): \"\"\"Test setup.\"\"\" self.client=None self.location_id=LOCATION_INFO_BASIC_NORMAL[\"LocationID\"] def tearDown(self): \"\"\"Test cleanup.\"\"\" self.client=None def tests_request_init(self): \"\"\"Test normal init sequence with no problems.\"\"\" eval_responses=[ FakeResponse( RESPONSE_AUTHENTICATE[\"ResultCode\"], \"Authentication Succeess.\" ), FakeResponse(RESPONSE_PARTITION_DETAILS[\"ResultCode\"], \"Partition Success\"), FakeResponse( RESPONSE_GET_ZONE_DETAILS_SUCCESS[\"ResultCode\"], \"Zone Details Success\" ), FakeResponse(RESPONSE_DISARMED[\"ResultCode\"], \"Response Disarmed\"), ] serialize_responses=[ RESPONSE_AUTHENTICATE, RESPONSE_PARTITION_DETAILS, RESPONSE_GET_ZONE_DETAILS_SUCCESS, RESPONSE_DISARMED, ] with patch( \"zeep.helpers.serialize_object\", side_effect=serialize_responses ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request: client=TotalConnectClient(\"username\", \"password\", usercodes=None) assert mock_request.call_count==1 if client.locations: pass assert mock_request.call_count==4 assert client.is_valid_credentials() is True assert client.is_logged_in() is True def tests_request_init_bad_user_or_password(self): \"\"\"Test init sequence with no a bad password.\"\"\" eval_responses=[ FakeResponse( RESPONSE_BAD_USER_OR_PASSWORD[\"ResultCode\"], \"Response Disarmed\" ), ] serialize_responses=[ RESPONSE_BAD_USER_OR_PASSWORD, ] with patch( \"zeep.helpers.serialize_object\", side_effect=serialize_responses ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request: with pytest.raises(AuthenticationError): TotalConnectClient(\"username\", \"password\", usercodes=None) assert mock_request.call_count==1 def tests_request_init_failed_to_connect(self): \"\"\"Test init sequence when fails to connect.\"\"\" eval_responses=[] serialize_responses=[] for x in range(TotalConnectClient.MAX_RETRY_ATTEMPTS): eval_responses.append( FakeResponse( RESPONSE_FAILED_TO_CONNECT[\"ResultCode\"], \"Response Disarmed\" ) ) serialize_responses.append(RESPONSE_FAILED_TO_CONNECT) with patch( \"zeep.helpers.serialize_object\", side_effect=serialize_responses ), patch(\"time.sleep\", autospec=True), patch( \"builtins.eval\", side_effect=eval_responses ) as mock_request, pytest.raises( Exception ) as e: client=TotalConnectClient( \"username\", \"password\", usercodes=None, retry_delay=0 ) assert mock_request.call_count==TotalConnectClient.MAX_RETRY_ATTEMPTS assert client.is_valid_credentials() is False assert client.is_logged_in() is False assert( str(e.value) ==\"total-connect-client could not execute request. Maximum attempts tried.\" ) def tests_request_connection_error(self): \"\"\"Test a connection error.\"\"\" eval_responses=[] serialize_responses=[] for x in range(TotalConnectClient.MAX_RETRY_ATTEMPTS): eval_responses.append( FakeResponse( RESPONSE_CONNECTION_ERROR[\"ResultCode\"], \"Response Disarmed\" ) ) serialize_responses.append(RESPONSE_CONNECTION_ERROR) with patch( \"zeep.helpers.serialize_object\", side_effect=serialize_responses ), patch(\"time.sleep\", autospec=True), patch( \"builtins.eval\", side_effect=eval_responses ) as mock_request, pytest.raises( Exception ) as e: client=TotalConnectClient( \"username\", \"password\", usercodes=None, retry_delay=0 ) assert mock_request.call_count==TotalConnectClient.MAX_RETRY_ATTEMPTS assert client.is_valid_credentials() is False assert client.is_logged_in() is False assert( str(e.value) ==\"total-connect-client could not execute request. Maximum attempts tried.\" ) def tests_request_invalid_session(self): \"\"\"Test an invalid session, which is when the session times out.\"\"\" eval_responses=[ FakeResponse( RESPONSE_AUTHENTICATE[\"ResultCode\"], \"Authentication Succeess.\" ), FakeResponse(RESPONSE_PARTITION_DETAILS[\"ResultCode\"], \"Partition Success\"), FakeResponse( RESPONSE_GET_ZONE_DETAILS_SUCCESS[\"ResultCode\"], \"Zone Details Success\" ), FakeResponse(RESPONSE_DISARMED[\"ResultCode\"], \"Response Disarmed\"), FakeResponse( RESPONSE_INVALID_SESSION[\"ResultCode\"], \"Response Invalid Session\" ), FakeResponse( RESPONSE_SESSION_INITIATED[\"ResultCode\"], \"Session initiated.\" ), FakeResponse(RESPONSE_ARMED_AWAY[\"ResultCode\"], \"Response armed\"), ] serialize_responses=[ RESPONSE_AUTHENTICATE, RESPONSE_PARTITION_DETAILS, RESPONSE_GET_ZONE_DETAILS_SUCCESS, RESPONSE_DISARMED, RESPONSE_SESSION_INITIATED, RESPONSE_ARMED_AWAY, ] with patch( \"zeep.helpers.serialize_object\", side_effect=serialize_responses ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request: client=TotalConnectClient(\"username\", \"password\", usercodes=None) assert mock_request.call_count==1 if client.locations: pass assert mock_request.call_count==4 assert client.is_valid_credentials() is True assert client.is_logged_in() is True client.arm_away(self.location_id) assert mock_request.call_count==5 def tests_request_unknown_result_code(self): \"\"\"Test an unknown result code.\"\"\" eval_responses=[ FakeResponse(RESPONSE_UNKNOWN[\"ResultCode\"], \"unknown code.\"), ] serialize_responses=[ RESPONSE_UNKNOWN, ] with patch( \"zeep.helpers.serialize_object\", side_effect=serialize_responses ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request: with pytest.raises(TotalConnectError): TotalConnectClient(\"username\", \"password\", usercodes=None) assert mock_request.call_count==1 ","sourceWithComments":"\"\"\"Test total_connect_client request().\"\"\"\n\nimport unittest\nfrom unittest.mock import patch\n\nimport pytest\nfrom const import (\n    LOCATION_INFO_BASIC_NORMAL,\n    RESPONSE_ARMED_AWAY,\n    RESPONSE_AUTHENTICATE,\n    RESPONSE_BAD_USER_OR_PASSWORD,\n    RESPONSE_CONNECTION_ERROR,\n    RESPONSE_DISARMED,\n    RESPONSE_FAILED_TO_CONNECT,\n    RESPONSE_GET_ZONE_DETAILS_SUCCESS,\n    RESPONSE_INVALID_SESSION,\n    RESPONSE_PARTITION_DETAILS,\n    RESPONSE_SESSION_INITIATED,\n    RESPONSE_UNKNOWN,\n)\n\nfrom total_connect_client.client import TotalConnectClient\nfrom total_connect_client.exceptions import AuthenticationError, TotalConnectError\n\n\nclass FakeResponse:\n    \"\"\"Fake response from zeep.\"\"\"\n\n    def __init__(self, code, data):\n        \"\"\"Initialize.\"\"\"\n        self.ResultCode = code\n        self.ResultData = data\n\n\nclass TestTotalConnectClient(unittest.TestCase):\n    \"\"\"Test TotalConnectClient request().\"\"\"\n\n    def setUp(self):\n        \"\"\"Test setup.\"\"\"\n        self.client = None\n        self.location_id = LOCATION_INFO_BASIC_NORMAL[\"LocationID\"]\n\n    def tearDown(self):\n        \"\"\"Test cleanup.\"\"\"\n        self.client = None\n\n    def tests_request_init(self):\n        \"\"\"Test normal init sequence with no problems.\"\"\"\n        eval_responses = [\n            FakeResponse(\n                RESPONSE_AUTHENTICATE[\"ResultCode\"], \"Authentication Succeess.\"\n            ),\n            FakeResponse(RESPONSE_PARTITION_DETAILS[\"ResultCode\"], \"Partition Success\"),\n            FakeResponse(\n                RESPONSE_GET_ZONE_DETAILS_SUCCESS[\"ResultCode\"], \"Zone Details Success\"\n            ),\n            FakeResponse(RESPONSE_DISARMED[\"ResultCode\"], \"Response Disarmed\"),\n        ]\n        serialize_responses = [\n            RESPONSE_AUTHENTICATE,\n            RESPONSE_PARTITION_DETAILS,\n            RESPONSE_GET_ZONE_DETAILS_SUCCESS,\n            RESPONSE_DISARMED,\n        ]\n\n        with patch(\n            \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n            client = TotalConnectClient(\"username\", \"password\", usercodes=None)\n            assert mock_request.call_count == 1\n            if client.locations:  # force client to fetch them\n                pass\n            assert mock_request.call_count == 4\n            assert client.is_valid_credentials() is True\n            assert client.is_logged_in() is True\n\n    def tests_request_init_bad_user_or_password(self):\n        \"\"\"Test init sequence with no a bad password.\"\"\"\n        eval_responses = [\n            FakeResponse(\n                RESPONSE_BAD_USER_OR_PASSWORD[\"ResultCode\"], \"Response Disarmed\"\n            ),\n        ]\n        serialize_responses = [\n            RESPONSE_BAD_USER_OR_PASSWORD,\n        ]\n\n        with patch(\n            \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n            with pytest.raises(AuthenticationError):\n                TotalConnectClient(\"username\", \"password\", usercodes=None)\n            assert mock_request.call_count == 1\n\n    def tests_request_init_failed_to_connect(self):\n        \"\"\"Test init sequence when fails to connect.\"\"\"\n        eval_responses = []\n        serialize_responses = []\n        for x in range(TotalConnectClient.MAX_RETRY_ATTEMPTS):\n            eval_responses.append(\n                FakeResponse(\n                    RESPONSE_FAILED_TO_CONNECT[\"ResultCode\"], \"Response Disarmed\"\n                )\n            )\n            serialize_responses.append(RESPONSE_FAILED_TO_CONNECT)\n\n        with patch(\n            \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n        ), patch(\"time.sleep\", autospec=True), patch(\n            \"builtins.eval\", side_effect=eval_responses\n        ) as mock_request, pytest.raises(\n            Exception\n        ) as e:\n            client = TotalConnectClient(\n                \"username\", \"password\", usercodes=None, retry_delay=0\n            )\n            assert mock_request.call_count == TotalConnectClient.MAX_RETRY_ATTEMPTS\n            assert client.is_valid_credentials() is False\n            assert client.is_logged_in() is False\n            assert (\n                str(e.value)\n                == \"total-connect-client could not execute request.  Maximum attempts tried.\"\n            )\n\n    def tests_request_connection_error(self):\n        \"\"\"Test a connection error.\"\"\"\n        eval_responses = []\n        serialize_responses = []\n        for x in range(TotalConnectClient.MAX_RETRY_ATTEMPTS):\n            eval_responses.append(\n                FakeResponse(\n                    RESPONSE_CONNECTION_ERROR[\"ResultCode\"], \"Response Disarmed\"\n                )\n            )\n            serialize_responses.append(RESPONSE_CONNECTION_ERROR)\n\n        with patch(\n            \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n        ), patch(\"time.sleep\", autospec=True), patch(\n            \"builtins.eval\", side_effect=eval_responses\n        ) as mock_request, pytest.raises(\n            Exception\n        ) as e:\n            client = TotalConnectClient(\n                \"username\", \"password\", usercodes=None, retry_delay=0\n            )\n            assert mock_request.call_count == TotalConnectClient.MAX_RETRY_ATTEMPTS\n            assert client.is_valid_credentials() is False\n            assert client.is_logged_in() is False\n            assert (\n                str(e.value)\n                == \"total-connect-client could not execute request.  Maximum attempts tried.\"\n            )\n\n    def tests_request_invalid_session(self):\n        \"\"\"Test an invalid session, which is when the session times out.\"\"\"\n        # First three responses set up 'normal' session\n        # Call to client.arm_away() will first get an invalid session,\n        # which will trigger client.authenticate() before completing the arm_away()\n        eval_responses = [\n            FakeResponse(\n                RESPONSE_AUTHENTICATE[\"ResultCode\"], \"Authentication Succeess.\"\n            ),\n            FakeResponse(RESPONSE_PARTITION_DETAILS[\"ResultCode\"], \"Partition Success\"),\n            FakeResponse(\n                RESPONSE_GET_ZONE_DETAILS_SUCCESS[\"ResultCode\"], \"Zone Details Success\"\n            ),\n            FakeResponse(RESPONSE_DISARMED[\"ResultCode\"], \"Response Disarmed\"),\n            FakeResponse(\n                RESPONSE_INVALID_SESSION[\"ResultCode\"], \"Response Invalid Session\"\n            ),\n            FakeResponse(\n                RESPONSE_SESSION_INITIATED[\"ResultCode\"], \"Session initiated.\"\n            ),\n            FakeResponse(RESPONSE_ARMED_AWAY[\"ResultCode\"], \"Response armed\"),\n        ]\n        # invalid_session responses don't get serialized\n        serialize_responses = [\n            RESPONSE_AUTHENTICATE,\n            RESPONSE_PARTITION_DETAILS,\n            RESPONSE_GET_ZONE_DETAILS_SUCCESS,\n            RESPONSE_DISARMED,\n            RESPONSE_SESSION_INITIATED,\n            RESPONSE_ARMED_AWAY,\n        ]\n\n        with patch(\n            \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n            client = TotalConnectClient(\"username\", \"password\", usercodes=None)\n            assert mock_request.call_count == 1\n            if client.locations:  # force client to fetch them\n                pass\n            assert mock_request.call_count == 4\n            assert client.is_valid_credentials() is True\n            assert client.is_logged_in() is True\n\n            client.arm_away(self.location_id)\n            assert mock_request.call_count == 5\n\n    def tests_request_unknown_result_code(self):\n        \"\"\"Test an unknown result code.\"\"\"\n        eval_responses = [\n            FakeResponse(RESPONSE_UNKNOWN[\"ResultCode\"], \"unknown code.\"),\n        ]\n        serialize_responses = [\n            RESPONSE_UNKNOWN,\n        ]\n\n        with patch(\n            \"zeep.helpers.serialize_object\", side_effect=serialize_responses\n        ), patch(\"builtins.eval\", side_effect=eval_responses) as mock_request:\n            with pytest.raises(TotalConnectError):\n                TotalConnectClient(\"username\", \"password\", usercodes=None)\n            assert mock_request.call_count == 1\n"},"\/total_connect_client\/client.py":{"changes":[{"diff":"\n             )\n         try:\n             LOGGER.debug(f\"sending API request {request}\")\n-            r = eval(\"self.soap_client.service.\" + request)\n+            r = self._eval(\"self.soap_client.service.\" + request)\n             response = zeep.helpers.serialize_object(r)\n             self._raise_for_retry(response)\n             return response\n+        # To retry an exception that could be raised during the request,\n+        # add it to one of the following except blocks, depending on what\n+        # you want to have happen. The first two blocks are the same except\n+        # for what gets logged. The third block causes reauthentication.\n+        except requests.exceptions.RequestException as err:\n+            if attempts > self.MAX_RETRY_ATTEMPTS:\n+                raise\n+            LOGGER.info(f\"retrying {err}, attempt # {attempts}\")\n+            time.sleep(self.retry_delay)\n+            return self.request(request, attempts + 1)\n         except RetryableTotalConnectError as err:\n             if attempts > self.MAX_RETRY_ATTEMPTS:\n                 raise\n","add":11,"remove":1,"filename":"\/total_connect_client\/client.py","badparts":["            r = eval(\"self.soap_client.service.\" + request)"],"goodparts":["            r = self._eval(\"self.soap_client.service.\" + request)","        except requests.exceptions.RequestException as err:","            if attempts > self.MAX_RETRY_ATTEMPTS:","                raise","            LOGGER.info(f\"retrying {err}, attempt # {attempts}\")","            time.sleep(self.retry_delay)","            return self.request(request, attempts + 1)"]}],"source":"\n\"\"\"TotalConnectClient() in this file is the primary class of this package. Instantiate it like this: usercodes={ 'default': '1234'} client=TCC.TotalConnectClient(username, password, usercodes) for location in client.locations: \"\"\" import logging import time import warnings import zeep from.const import ArmType from.exceptions import( AuthenticationError, BadResultCodeError, InvalidSessionError, RetryableTotalConnectError, TotalConnectError, ) from.location import TotalConnectLocation from.user import TotalConnectUser PROJECT_URL=\"https:\/\/github.com\/craigjmidwinter\/total-connect-client\" DEFAULT_USERCODE=\"-1\" LOGGER=logging.getLogger(__name__) class TotalConnectClient: \"\"\"Client for Total Connect.\"\"\" SUCCESS=0 ARM_SUCCESS=4500 DISARM_SUCCESS=4500 SESSION_INITIATED=4500 CONNECTION_ERROR=4101 FAILED_TO_CONNECT=-4104 USER_CODE_INVALID=-4106 USER_CODE_UNAVAILABLE=-4114 COMMAND_FAILED=-4502 INVALID_SESSION=-102 INVALID_SESSIONID=-30002 BAD_USER_OR_PASSWORD=-50004 AUTHENTICATION_FAILED=-100 FEATURE_NOT_SUPPORTED=-120 MAX_RETRY_ATTEMPTS=10 def __init__( self, username, password, usercodes=None, auto_bypass_battery=False, retry_delay=3, ): \"\"\"Initialize.\"\"\" self.times={} self.time_start=time.time() self.soap_client=None self.application_id=\"14588\" self.application_version=\"1.0.34\" self.username=username self.password=password self.usercodes=usercodes or{} self.auto_bypass_low_battery=auto_bypass_battery self.retry_delay=retry_delay self.token=None self._invalid_credentials=False self._module_flags=None self._user=None self._locations={} self._locations_unfetched={} self.authenticate() self.times[\"__init__\"]=time.time() -self.time_start @property def locations(self): \"\"\"Raises an exception if the panel cannot be reached to retrieve metadata or details. This can be retried later and will succeed if\/when the panel becomes reachable. \"\"\" to_fetch=list(self._locations_unfetched.items()) for(locationid, location) in to_fetch: try: location.get_partition_details() location.get_zone_details() location.get_panel_meta_data() del self._locations_unfetched[locationid] except Exception: LOGGER.error(f\"exception during initial fetch of{locationid}\") raise assert not self._locations_unfetched return self._locations def __str__(self): \"\"\"Return a text string that is printable.\"\"\" data=( f\"CLIENT\\n\\n\" f\"Username:{self.username}\\n\" f\"Password:{'[hidden]' if self.password else '[unset]'}\\n\" f\"Usercode:{self.usercodes}\\n\" f\"Auto Bypass Low Battery:{self.auto_bypass_low_battery}\\n\" f\"Invalid Credentials:{self._invalid_credentials}\\n\" f\"Module Flags:\\n\" ) for key, value in self._module_flags.items(): data=data +f\" {key}:{value}\\n\" data=data +str(self._user) locations=f\"LOCATIONS:{len(self.locations)}\\n\\n\" for location in self.locations: locations=locations +str(self.locations[location]) return data +locations def get_times(self): \"\"\"Return a string with times.\"\"\" self.times[\"total running time\"]=time.time() -self.time_start msg=\"total-connect-client time info(seconds):\\n\" for key, value in self.times.items(): msg=msg +f\" {key}:{value}\\n\" return msg def _raise_for_retry(self, response): \"\"\"Used internally to determine which responses should be retried in request(). \"\"\" rc=response[\"ResultCode\"] if rc==self.INVALID_SESSION: raise InvalidSessionError(\"invalid session\", response) if rc==self.INVALID_SESSIONID: raise InvalidSessionError(\"invalid session ID\", response) if rc==self.CONNECTION_ERROR: raise RetryableTotalConnectError(\"connection error\", response) if rc==self.FAILED_TO_CONNECT: raise RetryableTotalConnectError(\"failed to connect with panel\", response) def raise_for_resultcode(self, response): \"\"\"If response.ResultCode indicates success, return and do nothing. If it indicates an authentication error, raise AuthenticationError. \"\"\" rc=response[\"ResultCode\"] if rc in( self.SUCCESS, self.ARM_SUCCESS, self.DISARM_SUCCESS, self.SESSION_INITIATED, ): return self._raise_for_retry(response) if rc==self.COMMAND_FAILED: raise BadResultCodeError(\"command failed\", response) if rc==self.FEATURE_NOT_SUPPORTED: raise BadResultCodeError(\"feature not supported\", response) if rc==self.USER_CODE_INVALID: raise BadResultCodeError(\"user code invalid\", response) if rc==self.BAD_USER_OR_PASSWORD: raise AuthenticationError(\"bad user or password\", response) if rc==self.AUTHENTICATION_FAILED: raise AuthenticationError(\"authentication failed\", response) if rc==self.USER_CODE_UNAVAILABLE: raise AuthenticationError(\"user code unavailable\", response) raise BadResultCodeError(f\"unknown result code{rc}\", response) def request(self, request, attempts=0): \"\"\"Send a SOAP request.\"\"\" if not self.soap_client: self.soap_client=zeep.Client( \"https:\/\/rs.alarmnet.com\/TC21api\/tc2.asmx?WSDL\" ) try: LOGGER.debug(f\"sending API request{request}\") r=eval(\"self.soap_client.service.\" +request) response=zeep.helpers.serialize_object(r) self._raise_for_retry(response) return response except RetryableTotalConnectError as err: if attempts > self.MAX_RETRY_ATTEMPTS: raise LOGGER.info(f\"retrying{err.args[0]}, attempt time.sleep(self.retry_delay) return self.request(request, attempts +1) except InvalidSessionError: if attempts > self.MAX_RETRY_ATTEMPTS: raise LOGGER.info(f\"reauthenticating session, attempt self.token=None self.authenticate() return self.request(request, attempts +1) def authenticate(self): \"\"\"Login to the system. Upon success, self.token is a valid credential for further API calls, and self._user and self.locations are valid. self.locations will not be refreshed if it was non-empty on entry. \"\"\" start_time=time.time() if self._invalid_credentials: raise AuthenticationError( f\"not authenticating: password already failed for user{self.username}\" ) verb=( \"AuthenticateUserLogin\" if self._locations else \"LoginAndGetSessionDetails\" ) response=self.request( verb +\"(self.username, self.password, \" \"self.application_id, self.application_version)\" ) try: self.raise_for_resultcode(response) except AuthenticationError: self._invalid_credentials=True self.token=None raise self.token=response[\"SessionID\"] if not self._locations: self._module_flags=dict( x.split(\"=\") for x in response[\"ModuleFlags\"].split(\",\") ) self._user=TotalConnectUser(response[\"UserInfo\"]) self._locations_unfetched=self._make_locations(response) self._locations=self._locations_unfetched.copy() if not self._locations: raise TotalConnectError(\"no locations found\", response) LOGGER.info(f\"{self.username} authenticated:{len(self._locations)} locations\") self.times[\"authenticate()\"]=time.time() -start_time def validate_usercode(self, device_id, usercode): \"\"\"Return True if the usercode is valid for the device.\"\"\" response=self.request( f\"ValidateUserCode(self.token,{device_id}, '{usercode}')\" ) if response[\"ResultCode\"] in( self.USER_CODE_INVALID, self.USER_CODE_UNAVAILABLE, ): LOGGER.warning(f\"usercode{usercode} invalid for device{device_id}\") return False self.raise_for_resultcode(response) return True def is_logged_in(self): \"\"\"Return true if the client is logged into Total Connect service.\"\"\" return self.token is not None def log_out(self): \"\"\"Upon return, we are logged out. Raises TotalConnectError if we still might be logged in. \"\"\" if self.is_logged_in(): response=self.request(\"Logout(self.token)\") self.raise_for_resultcode(response) LOGGER.info(\"Logout Successful\") self.token=None def is_valid_credentials(self): \"\"\"Return True if the credentials are known to be valid.\"\"\" return self.token is not None def _make_locations(self, response): \"\"\"Return a dict mapping LocationID to TotalConnectLocation.\"\"\" start_time=time.time() new_locations={} for location in(response[\"Locations\"] or{}).get(\"LocationInfoBasic\",{}): location_id=location[\"LocationID\"] new_locations[location_id]=TotalConnectLocation(location, self) new_locations[ location_id ].auto_bypass_low_battery=self.auto_bypass_low_battery usercode=( self.usercodes.get(location_id) or self.usercodes.get(str(location_id)) or self.usercodes.get(\"default\") ) if usercode: new_locations[location_id].usercode=usercode else: LOGGER.warning(f\"no usercode for location{location_id}\") new_locations[location_id].usercode=DEFAULT_USERCODE self.times[\"_make_locations()\"]=time.time() -start_time return new_locations def arm_away(self, location_id): \"\"\"Arm the system(Away).\"\"\" warnings.warn( \"Using deprecated client.arm_away(). \" \"Use location.arm_away().\", DeprecationWarning, ) return self.arm(ArmType.AWAY, location_id) def arm_stay(self, location_id): \"\"\"Arm the system(Stay).\"\"\" warnings.warn( \"Using deprecated client.arm_stay(). \" \"Use location.arm_stay().\", DeprecationWarning, ) return self.arm(ArmType.STAY, location_id) def arm_stay_instant(self, location_id): \"\"\"Arm the system(Stay -Instant).\"\"\" warnings.warn( \"Using deprecated client.arm_stay_instant(). \" \"Use location.arm_stay_instant().\", DeprecationWarning, ) return self.arm(ArmType.STAY_INSTANT, location_id) def arm_away_instant(self, location_id): \"\"\"Arm the system(Away -Instant).\"\"\" warnings.warn( \"Using deprecated client.arm_away_instant(). \" \"Use location.arm_away_instant().\", DeprecationWarning, ) return self.arm(ArmType.AWAY_INSTANT, location_id) def arm_stay_night(self, location_id): \"\"\"Arm the system(Stay -Night).\"\"\" warnings.warn( \"Using deprecated client.arm_stay_night(). \" \"Use location.arm_stay_night().\", DeprecationWarning, ) return self.arm(ArmType.STAY_NIGHT, location_id) def arm(self, arm_type, location_id): \"\"\"Arm the system. Return True if successful.\"\"\" warnings.warn( \"Using deprecated client.arm(). \" \"Use location.arm().\", DeprecationWarning ) return self.locations[location_id].arm(arm_type) def get_custom_arm_settings(self, location_id): \"\"\"Get custom arm settings. Return true if successful.\"\"\" warnings.warn( \"Using deprecated client.get_custom_arm_settings(). \" \"Use location.get_custom_arm_settings().\", DeprecationWarning, ) return self.locations[location_id].get_custom_arm_settings() def get_panel_meta_data(self, location_id): \"\"\"Get all meta data about the alarm panel.\"\"\" warnings.warn( \"Using deprecated client.get_panel_meta_data(). \" \"Use location.get_panel_meta_data().\", DeprecationWarning, ) return self.locations[location_id].get_panel_meta_data() def zone_status(self, location_id, zone_id): \"\"\"Get status of a zone.\"\"\" warnings.warn( \"Using deprecated client.zone_status(). \" \"Use location.zone_status().\", DeprecationWarning, ) return self.locations[location_id].zone_status(zone_id) def disarm(self, location_id): \"\"\"Disarm the system. Return True if successful.\"\"\" warnings.warn( \"Using deprecated client.disarm(). \" \"Use location.disarm().\", DeprecationWarning, ) return self.locations[location_id].disarm() def zone_bypass(self, zone_id, location_id): \"\"\"Bypass a zone. Return true if successful.\"\"\" warnings.warn( \"Using deprecated client.zone_bypass(). \" \"Use location.zone_bypass().\", DeprecationWarning, ) return self.locations[location_id].zone_bypass(zone_id) def get_zone_details(self, location_id): \"\"\"Get Zone details. Return True if successful.\"\"\" warnings.warn( \"Using deprecated client.get_zone_details(). \" \"Use location.get_zone_details().\", DeprecationWarning, ) return self.locations[location_id].get_zone_details() class ArmingHelper: \"\"\" For a partition or location, you can call its arm() or disarm() method directly. Example: partition.arm(ArmType.AWAY) Alternatively, you can use ArmingHelper. Example: ArmingHelper(partition).arm_away() \"\"\" def __init__(self, partition_or_location): self.armable=partition_or_location def arm_away(self): \"\"\"Arm the system(Away).\"\"\" self.armable.arm(ArmType.AWAY) def arm_stay(self): \"\"\"Arm the system(Stay).\"\"\" self.armable.arm(ArmType.STAY) def arm_stay_instant(self): \"\"\"Arm the system(Stay -Instant).\"\"\" self.armable.arm(ArmType.STAY_INSTANT) def arm_away_instant(self): \"\"\"Arm the system(Away -Instant).\"\"\" self.armable.arm(ArmType.AWAY_INSTANT) def arm_stay_night(self): \"\"\"Arm the system(Stay -Night).\"\"\" self.armable.arm(ArmType.STAY_NIGHT) def disarm(self): self.armable.disarm() ","sourceWithComments":"\"\"\"TotalConnectClient() in this file is the primary class of this package.\nInstantiate it like this:\n\nusercodes = { 'default': '1234' }\nclient = TCC.TotalConnectClient(username, password, usercodes)\n\nfor location in client.locations:\n    ### do stuff with this location\n\"\"\"\n\nimport logging\nimport time\nimport warnings\n\nimport zeep\n\nfrom .const import ArmType\nfrom .exceptions import (\n    AuthenticationError,\n    BadResultCodeError,\n    InvalidSessionError,\n    RetryableTotalConnectError,\n    TotalConnectError,\n)\nfrom .location import TotalConnectLocation\nfrom .user import TotalConnectUser\n\nPROJECT_URL = \"https:\/\/github.com\/craigjmidwinter\/total-connect-client\"\n\nDEFAULT_USERCODE = \"-1\"\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass TotalConnectClient:\n    \"\"\"Client for Total Connect.\"\"\"\n\n    SUCCESS = 0\n    ARM_SUCCESS = 4500\n    DISARM_SUCCESS = 4500\n    SESSION_INITIATED = 4500\n    CONNECTION_ERROR = 4101\n    FAILED_TO_CONNECT = -4104\n    USER_CODE_INVALID = -4106\n    USER_CODE_UNAVAILABLE = -4114\n    COMMAND_FAILED = -4502\n    INVALID_SESSION = -102\n    INVALID_SESSIONID = -30002\n    BAD_USER_OR_PASSWORD = -50004\n    AUTHENTICATION_FAILED = -100\n    FEATURE_NOT_SUPPORTED = -120\n\n    MAX_RETRY_ATTEMPTS = 10\n\n    def __init__(\n        self,\n        username,\n        password,\n        usercodes=None,\n        auto_bypass_battery=False,\n        retry_delay=3,  # seconds between retries\n    ):\n        \"\"\"Initialize.\"\"\"\n        self.times = {}\n        self.time_start = time.time()\n        self.soap_client = None\n        self.application_id = \"14588\"\n        self.application_version = \"1.0.34\"\n\n        self.username = username\n        self.password = password\n        self.usercodes = usercodes or {}\n        self.auto_bypass_low_battery = auto_bypass_battery\n        self.retry_delay = retry_delay\n\n        self.token = None\n        self._invalid_credentials = False\n        self._module_flags = None\n        self._user = None\n        self._locations = {}\n        self._locations_unfetched = {}\n\n        self.authenticate()\n\n        self.times[\"__init__\"] = time.time() - self.time_start\n\n    @property\n    def locations(self):\n        \"\"\"Raises an exception if the panel cannot be reached to retrieve\n        metadata or details. This can be retried later and will succeed\n        if\/when the panel becomes reachable.\n        \"\"\"\n        # to_fetch is needed because items() is invalidated by del\n        to_fetch = list(self._locations_unfetched.items())\n        for (locationid, location) in to_fetch:\n            try:\n                location.get_partition_details()\n                location.get_zone_details()\n                location.get_panel_meta_data()\n                # if we get here, it has been fetched successfully\n                del self._locations_unfetched[locationid]\n            except Exception:\n                LOGGER.error(f\"exception during initial fetch of {locationid}\")\n                raise\n        assert not self._locations_unfetched\n        return self._locations\n\n    def __str__(self):\n        \"\"\"Return a text string that is printable.\"\"\"\n        data = (\n            f\"CLIENT\\n\\n\"\n            f\"Username: {self.username}\\n\"\n            f\"Password: {'[hidden]' if self.password else '[unset]'}\\n\"\n            f\"Usercode: {self.usercodes}\\n\"\n            f\"Auto Bypass Low Battery: {self.auto_bypass_low_battery}\\n\"\n            f\"Invalid Credentials: {self._invalid_credentials}\\n\"\n            f\"Module Flags:\\n\"\n        )\n\n        for key, value in self._module_flags.items():\n            data = data + f\"  {key}: {value}\\n\"\n\n        data = data + str(self._user)\n\n        locations = f\"LOCATIONS: {len(self.locations)}\\n\\n\"\n        for location in self.locations:\n            locations = locations + str(self.locations[location])\n\n        return data + locations\n\n    def get_times(self):\n        \"\"\"Return a string with times.\"\"\"\n        self.times[\"total running time\"] = time.time() - self.time_start\n        msg = \"total-connect-client time info (seconds):\\n\"\n        for key, value in self.times.items():\n            msg = msg + f\"  {key}: {value}\\n\"\n\n        return msg\n\n    def _raise_for_retry(self, response):\n        \"\"\"Used internally to determine which responses should be retried in\n        request().\n        \"\"\"\n        rc = response[\"ResultCode\"]\n        if rc == self.INVALID_SESSION:\n            raise InvalidSessionError(\"invalid session\", response)\n        if rc == self.INVALID_SESSIONID:\n            raise InvalidSessionError(\"invalid session ID\", response)\n        if rc == self.CONNECTION_ERROR:\n            raise RetryableTotalConnectError(\"connection error\", response)\n        if rc == self.FAILED_TO_CONNECT:\n            raise RetryableTotalConnectError(\"failed to connect with panel\", response)\n\n    def raise_for_resultcode(self, response):\n        \"\"\"If response.ResultCode indicates success, return and do nothing.\n        If it indicates an authentication error, raise AuthenticationError.\n        \"\"\"\n        rc = response[\"ResultCode\"]\n        if rc in (\n            self.SUCCESS,\n            self.ARM_SUCCESS,\n            self.DISARM_SUCCESS,\n            self.SESSION_INITIATED,\n        ):\n            return\n        self._raise_for_retry(response)\n        if rc == self.COMMAND_FAILED:\n            raise BadResultCodeError(\"command failed\", response)\n        if rc == self.FEATURE_NOT_SUPPORTED:\n            raise BadResultCodeError(\"feature not supported\", response)\n        if rc == self.USER_CODE_INVALID:\n            raise BadResultCodeError(\"user code invalid\", response)\n        if rc == self.BAD_USER_OR_PASSWORD:\n            raise AuthenticationError(\"bad user or password\", response)\n        if rc == self.AUTHENTICATION_FAILED:\n            raise AuthenticationError(\"authentication failed\", response)\n        if rc == self.USER_CODE_UNAVAILABLE:\n            raise AuthenticationError(\"user code unavailable\", response)\n        raise BadResultCodeError(f\"unknown result code {rc}\", response)\n\n    def request(self, request, attempts=0):\n        \"\"\"Send a SOAP request.\"\"\"\n\n        if not self.soap_client:\n            self.soap_client = zeep.Client(\n                \"https:\/\/rs.alarmnet.com\/TC21api\/tc2.asmx?WSDL\"\n            )\n        try:\n            LOGGER.debug(f\"sending API request {request}\")\n            r = eval(\"self.soap_client.service.\" + request)\n            response = zeep.helpers.serialize_object(r)\n            self._raise_for_retry(response)\n            return response\n        except RetryableTotalConnectError as err:\n            if attempts > self.MAX_RETRY_ATTEMPTS:\n                raise\n            LOGGER.info(f\"retrying {err.args[0]}, attempt # {attempts}\")\n            time.sleep(self.retry_delay)\n            return self.request(request, attempts + 1)\n        except InvalidSessionError:\n            if attempts > self.MAX_RETRY_ATTEMPTS:\n                raise\n            LOGGER.info(f\"reauthenticating session, attempt # {attempts}\")\n            self.token = None\n            self.authenticate()\n            return self.request(request, attempts + 1)\n\n    def authenticate(self):\n        \"\"\"Login to the system. Upon success, self.token is a valid credential\n        for further API calls, and self._user and self.locations are valid.\n        self.locations will not be refreshed if it was non-empty on entry.\n        \"\"\"\n        start_time = time.time()\n        if self._invalid_credentials:\n            raise AuthenticationError(\n                f\"not authenticating: password already failed for user {self.username}\"\n            )\n\n        # LoginAndGetSessionDetails is very slow, so only use it when necessary\n        verb = (\n            \"AuthenticateUserLogin\" if self._locations else \"LoginAndGetSessionDetails\"\n        )\n        response = self.request(\n            verb + \"(self.username, self.password, \"\n            \"self.application_id, self.application_version)\"\n        )\n        try:\n            self.raise_for_resultcode(response)\n        except AuthenticationError:\n            self._invalid_credentials = True\n            self.token = None\n            raise\n\n        self.token = response[\"SessionID\"]\n        if not self._locations:\n            self._module_flags = dict(\n                x.split(\"=\") for x in response[\"ModuleFlags\"].split(\",\")\n            )\n            self._user = TotalConnectUser(response[\"UserInfo\"])\n            self._locations_unfetched = self._make_locations(response)\n            self._locations = self._locations_unfetched.copy()\n            if not self._locations:\n                raise TotalConnectError(\"no locations found\", response)\n        LOGGER.info(f\"{self.username} authenticated: {len(self._locations)} locations\")\n        self.times[\"authenticate()\"] = time.time() - start_time\n\n    def validate_usercode(self, device_id, usercode):\n        \"\"\"Return True if the usercode is valid for the device.\"\"\"\n        response = self.request(\n            f\"ValidateUserCode(self.token, {device_id}, '{usercode}')\"\n        )\n\n        if response[\"ResultCode\"] in (\n            self.USER_CODE_INVALID,\n            self.USER_CODE_UNAVAILABLE,\n        ):\n            LOGGER.warning(f\"usercode {usercode} invalid for device {device_id}\")\n            return False\n        self.raise_for_resultcode(response)\n        return True\n\n    def is_logged_in(self):\n        \"\"\"Return true if the client is logged into Total Connect service.\"\"\"\n        return self.token is not None\n\n    def log_out(self):\n        \"\"\"Upon return, we are logged out. Raises TotalConnectError if we\n        still might be logged in.\n        \"\"\"\n        if self.is_logged_in():\n            response = self.request(\"Logout(self.token)\")\n            self.raise_for_resultcode(response)\n            LOGGER.info(\"Logout Successful\")\n            self.token = None\n\n    def is_valid_credentials(self):\n        \"\"\"Return True if the credentials are known to be valid.\"\"\"\n        return self.token is not None\n\n    def _make_locations(self, response):\n        \"\"\"Return a dict mapping LocationID to TotalConnectLocation.\"\"\"\n        start_time = time.time()\n        new_locations = {}\n\n        for location in (response[\"Locations\"] or {}).get(\"LocationInfoBasic\", {}):\n            location_id = location[\"LocationID\"]\n            new_locations[location_id] = TotalConnectLocation(location, self)\n\n            # set auto_bypass\n            new_locations[\n                location_id\n            ].auto_bypass_low_battery = self.auto_bypass_low_battery\n\n            # set the usercode for the location\n            usercode = (\n                self.usercodes.get(location_id)\n                or self.usercodes.get(str(location_id))\n                or self.usercodes.get(\"default\")\n            )\n            if usercode:\n                new_locations[location_id].usercode = usercode\n            else:\n                LOGGER.warning(f\"no usercode for location {location_id}\")\n                new_locations[location_id].usercode = DEFAULT_USERCODE\n\n        self.times[\"_make_locations()\"] = time.time() - start_time\n        return new_locations\n\n    def arm_away(self, location_id):\n        \"\"\"Arm the system (Away).\"\"\"\n        warnings.warn(\n            \"Using deprecated client.arm_away(). \" \"Use location.arm_away().\",\n            DeprecationWarning,\n        )\n        return self.arm(ArmType.AWAY, location_id)\n\n    def arm_stay(self, location_id):\n        \"\"\"Arm the system (Stay).\"\"\"\n        warnings.warn(\n            \"Using deprecated client.arm_stay(). \" \"Use location.arm_stay().\",\n            DeprecationWarning,\n        )\n        return self.arm(ArmType.STAY, location_id)\n\n    def arm_stay_instant(self, location_id):\n        \"\"\"Arm the system (Stay - Instant).\"\"\"\n        warnings.warn(\n            \"Using deprecated client.arm_stay_instant(). \"\n            \"Use location.arm_stay_instant().\",\n            DeprecationWarning,\n        )\n        return self.arm(ArmType.STAY_INSTANT, location_id)\n\n    def arm_away_instant(self, location_id):\n        \"\"\"Arm the system (Away - Instant).\"\"\"\n        warnings.warn(\n            \"Using deprecated client.arm_away_instant(). \"\n            \"Use location.arm_away_instant().\",\n            DeprecationWarning,\n        )\n        return self.arm(ArmType.AWAY_INSTANT, location_id)\n\n    def arm_stay_night(self, location_id):\n        \"\"\"Arm the system (Stay - Night).\"\"\"\n        warnings.warn(\n            \"Using deprecated client.arm_stay_night(). \"\n            \"Use location.arm_stay_night().\",\n            DeprecationWarning,\n        )\n        return self.arm(ArmType.STAY_NIGHT, location_id)\n\n    def arm(self, arm_type, location_id):\n        \"\"\"Arm the system. Return True if successful.\"\"\"\n        warnings.warn(\n            \"Using deprecated client.arm(). \" \"Use location.arm().\", DeprecationWarning\n        )\n        return self.locations[location_id].arm(arm_type)\n\n    def get_custom_arm_settings(self, location_id):\n        \"\"\"Get custom arm settings.  Return true if successful.\"\"\"\n        warnings.warn(\n            \"Using deprecated client.get_custom_arm_settings(). \"\n            \"Use location.get_custom_arm_settings().\",\n            DeprecationWarning,\n        )\n        return self.locations[location_id].get_custom_arm_settings()\n\n    def get_panel_meta_data(self, location_id):\n        \"\"\"Get all meta data about the alarm panel.\"\"\"\n        warnings.warn(\n            \"Using deprecated client.get_panel_meta_data(). \"\n            \"Use location.get_panel_meta_data().\",\n            DeprecationWarning,\n        )\n        return self.locations[location_id].get_panel_meta_data()\n\n    def zone_status(self, location_id, zone_id):\n        \"\"\"Get status of a zone.\"\"\"\n        warnings.warn(\n            \"Using deprecated client.zone_status(). \" \"Use location.zone_status().\",\n            DeprecationWarning,\n        )\n        return self.locations[location_id].zone_status(zone_id)\n\n    def disarm(self, location_id):\n        \"\"\"Disarm the system. Return True if successful.\"\"\"\n        warnings.warn(\n            \"Using deprecated client.disarm(). \" \"Use location.disarm().\",\n            DeprecationWarning,\n        )\n        return self.locations[location_id].disarm()\n\n    def zone_bypass(self, zone_id, location_id):\n        \"\"\"Bypass a zone.  Return true if successful.\"\"\"\n        warnings.warn(\n            \"Using deprecated client.zone_bypass(). \" \"Use location.zone_bypass().\",\n            DeprecationWarning,\n        )\n        return self.locations[location_id].zone_bypass(zone_id)\n\n    def get_zone_details(self, location_id):\n        \"\"\"Get Zone details. Return True if successful.\"\"\"\n        warnings.warn(\n            \"Using deprecated client.get_zone_details(). \"\n            \"Use location.get_zone_details().\",\n            DeprecationWarning,\n        )\n        return self.locations[location_id].get_zone_details()\n\n\nclass ArmingHelper:\n    \"\"\"\n    For a partition or location, you can call its arm() or disarm() method directly.\n       Example: partition.arm(ArmType.AWAY)\n\n    Alternatively, you can use ArmingHelper.\n       Example: ArmingHelper(partition).arm_away()\n    \"\"\"\n\n    def __init__(self, partition_or_location):\n        self.armable = partition_or_location\n\n    def arm_away(self):\n        \"\"\"Arm the system (Away).\"\"\"\n        self.armable.arm(ArmType.AWAY)\n\n    def arm_stay(self):\n        \"\"\"Arm the system (Stay).\"\"\"\n        self.armable.arm(ArmType.STAY)\n\n    def arm_stay_instant(self):\n        \"\"\"Arm the system (Stay - Instant).\"\"\"\n        self.armable.arm(ArmType.STAY_INSTANT)\n\n    def arm_away_instant(self):\n        \"\"\"Arm the system (Away - Instant).\"\"\"\n        self.armable.arm(ArmType.AWAY_INSTANT)\n\n    def arm_stay_night(self):\n        \"\"\"Arm the system (Stay - Night).\"\"\"\n        self.armable.arm(ArmType.STAY_NIGHT)\n\n    def disarm(self):\n        self.armable.disarm()\n"}},"msg":"retry all the exceptions that might be raised by SOAP's underlying HTTP transport. some aren't fixable by a retry but it won't hurt to retry them either.\n\nunittests in python 3.7 has a bug when patching builtins.eval, so now we have a method _eval() that just calls eval(), only so that unittest dependency injection works.\n\ntox passes py37."}},"https:\/\/github.com\/schodet\/nxt-python":{"cad30b1a6e02914c3e69cb6a017a052e334bce78":{"url":"https:\/\/api.github.com\/repos\/schodet\/nxt-python\/commits\/cad30b1a6e02914c3e69cb6a017a052e334bce78","html_url":"https:\/\/github.com\/schodet\/nxt-python\/commit\/cad30b1a6e02914c3e69cb6a017a052e334bce78","message":"don't use eval() for parsing method in config file\n\nThis improves the config file parsing of the method property. It fixes\npossible code injection via eval() as well as makes parsing a bit more\nrobust by filtering out invalid values, such as the obsolete fantom\ndriver values.\n\nFixes #137","sha":"cad30b1a6e02914c3e69cb6a017a052e334bce78","keyword":"eval injection fix","diff":"diff --git a\/nxt\/locator.py b\/nxt\/locator.py\nindex 17d0892..b91cd4b 100644\n--- a\/nxt\/locator.py\n+++ b\/nxt\/locator.py\n@@ -99,7 +99,10 @@ def find_one_brick(host=None, name=None, silent=False, strict=None, debug=False,\n         host\t= conf.get('Brick', 'host')\n         name\t= conf.get('Brick', 'name')\n         strict\t= bool(int(conf.get('Brick', 'strict')))\n-        method\t= eval('Method(%s)' % conf.get('Brick', 'method'))\n+        methods = map(lambda x: x.strip().split('='),\n+                      conf.get('Brick', 'method').split(','))\n+        method = Method(**{k: v == 'True' for k, v in methods\n+                           if k in ('bluetooth', 'usb', 'device')})\n     if not strict: strict = True\n     if not method: method = Method()\n \n","files":{"\/nxt\/locator.py":{"changes":[{"diff":"\n         host\t= conf.get('Brick', 'host')\n         name\t= conf.get('Brick', 'name')\n         strict\t= bool(int(conf.get('Brick', 'strict')))\n-        method\t= eval('Method(%s)' % conf.get('Brick', 'method'))\n+        methods = map(lambda x: x.strip().split('='),\n+                      conf.get('Brick', 'method').split(','))\n+        method = Method(**{k: v == 'True' for k, v in methods\n+                           if k in ('bluetooth', 'usb', 'device')})\n     if not strict: strict = True\n     if not method: method = Method()\n \n","add":4,"remove":1,"filename":"\/nxt\/locator.py","badparts":["        method\t= eval('Method(%s)' % conf.get('Brick', 'method'))"],"goodparts":["        methods = map(lambda x: x.strip().split('='),","                      conf.get('Brick', 'method').split(','))","        method = Method(**{k: v == 'True' for k, v in methods","                           if k in ('bluetooth', 'usb', 'device')})"]}],"source":"\n import traceback, configparser, os class BrickNotFoundError(Exception): pass class NoBackendError(Exception): pass class Method(): \"\"\"Used to indicate which comm backends should be tried by find_bricks\/ find_one_brick. Any or all can be selected.\"\"\" def __init__(self, usb=True, bluetooth=True, device=False): self.usb=usb self.bluetooth=bluetooth self.device=device def find_bricks(host=None, name=None, silent=False, method=Method()): \"\"\"Used by find_one_brick to look for bricks ***ADVANCED USERS ONLY***\"\"\" methods_available=0 if method.usb: try: from. import usbsock methods_available +=1 socks=usbsock.find_bricks(host, name) for s in socks: yield s except ImportError: import sys if not silent: print(\"USB module unavailable, not searching there\", file=sys.stderr) if method.bluetooth: try: from. import bluesock methods_available +=1 try: socks=bluesock.find_bricks(host, name) for s in socks: yield s except(bluesock.bluetooth.BluetoothError, IOError): pass except ImportError: import sys if not silent: print(\"Bluetooth module unavailable, not searching there\", file=sys.stderr) if method.device: try: from. import devsock methods_available +=1 socks=devsock.find_bricks(name=name) for s in socks: yield s except IOError: pass if methods_available==0: raise NoBackendError(\"No selected backends are available! Did you install the comm modules?\") def find_one_brick(host=None, name=None, silent=False, strict=None, debug=False, method=None, confpath=None): \"\"\"Use to find one brick. The host and name args limit the search to a given MAC or brick name. Set silent to True to stop nxt-python from printing anything during the search. This function by default automatically checks to see if the brick found has the correct host\/name (if either are provided) and will not return a brick which doesn't match. This can be disabled(so the function returns any brick which can be connected to and provides a valid reply to get_device_info()) by passing strict=False. This will, however, still tell the comm backends to only look for devices which match the args provided. The confpath arg specifies the location of the configuration file which brick location information will be read from if no brick location directives(host, name, strict, or method) are provided.\"\"\" if debug and silent: silent=False print(\"silent and debug can't both be set; giving debug priority\") conf=read_config(confpath, debug) if not(host or name or strict or method): host\t=conf.get('Brick', 'host') name\t=conf.get('Brick', 'name') strict\t=bool(int(conf.get('Brick', 'strict'))) method\t=eval('Method(%s)' % conf.get('Brick', 'method')) if not strict: strict=True if not method: method=Method() if debug: print(\"Host: %s Name: %s Strict: %s\" %(host, name, str(strict))) print(\"USB:{} BT:{}\".format(method.usb, method.bluetooth)) for s in find_bricks(host, name, silent, method): try: if host and 'host' in dir(s) and s.host !=host: if debug: print(\"Warning: the brick found does not match the host provided(s.host).\") if strict: continue b=s.connect() info=b.get_device_info() if debug: print(\"info: \" +str(info)) strict=False if host and info[1] !=host: if debug: print(\"Warning: the brick found does not match the host provided(get_device_info).\") print(\" host:\" +str(host)) print(\" info[1]:\" +info[1]) if strict: s.close() continue info=list(info) info[0]=str(info[0]) info[0]=info[0][2:(len(info[0])-1)] info[0]=info[0].strip('\\\\x00') if info[0] !=name: if debug: print(\"Warning; the brick found does not match the name provided.\") print(\" host:\" +str(host)) print(\" info[0]:\" +info[0]) print(\" name:\" +str(name)) if strict: s.close() continue return b except: if debug: traceback.print_exc() print(\"Failed to connect to possible brick\") print(\"\"\"No brick was found. Is the brick turned on? For more diagnosing use the debug=True argument or try the 'nxt_test' script located in \/bin or ~\/.local\/bin\"\"\") raise BrickNotFoundError def server_brick(host, port=2727): from. import ipsock sock=ipsock.IpSock(host, port) return sock.connect() def device_brick(filename): from. import devsock sock=devsock.find_bricks(filename=filename) return sock.connect() def read_config(confpath=None, debug=False): conf=configparser.RawConfigParser({'host': None, 'name': None, 'strict': True, 'method': ''}) if not confpath: confpath=os.path.expanduser('~\/.nxt-python') if conf.read([confpath])==[] and debug: print(\"Warning: Config file(should be at %s) was not read. Use nxt.locator.make_config() to create a config file.\" % confpath) if conf.has_section('Brick')==False: conf.add_section('Brick') return conf def make_config(confpath=None): conf=configparser.RawConfigParser() if not confpath: confpath=os.path.expanduser('~\/.nxt-python') print(\"Welcome to the nxt-python config file generator!\") print(\"This function creates an example file which find_one_brick uses to find a brick.\") try: if os.path.exists(confpath): input(\"File already exists at %s. Press Enter to overwrite or Ctrl+C to abort.\" % confpath) except KeyboardInterrupt: print(\"Not writing file.\") return conf.add_section('Brick') conf.set('Brick', 'name', 'MyNXT') conf.set('Brick', 'host', '54:32:59:92:F9:39') conf.set('Brick', 'strict', 0) conf.set('Brick', 'method', 'usb=True, bluetooth=False') conf.write(open(confpath, 'w')) print(\"The file has been written at %s\" % confpath) print(\"The file contains less-than-sane default values to get you started.\") print(\"You must now edit the file with a text editor and change the values to match what you would pass to find_one_brick\") print(\"The fields for name, host, and strict correspond to the similar args accepted by find_one_brick\") print(\"The method field contains the string which would be passed to Method()\") print(\"Any field whose corresponding option does not need to be passed to find_one_brick should be commented out(using a print(\"If you have questions, check the wiki and then ask on the mailing list.\") ","sourceWithComments":"# nxt.locator module -- Locate LEGO Minstorms NXT bricks via USB or Bluetooth\n# Copyright (C) 2006, 2007  Douglas P Lau\n# Copyright (C) 2009  Marcus Wanner\n# Copyright (C) 2013  Dave Churchill, Marcus Wanner\n# Copyright (C) 2015, 2016, 2017, 2018 Multiple Authors\n#\n# This program is free software: you can redistribute it and\/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\nimport traceback, configparser, os\n\nclass BrickNotFoundError(Exception):\n    pass\n\n\nclass NoBackendError(Exception):\n    pass\n\n\nclass Method():\n    \"\"\"Used to indicate which comm backends should be tried by find_bricks\/\nfind_one_brick. Any or all can be selected.\"\"\"\n    def __init__(self, usb=True, bluetooth=True, device=False):\n        #new method options MUST default to False!\n        self.usb = usb\n        self.bluetooth = bluetooth\n        self.device = device\n\n\ndef find_bricks(host=None, name=None, silent=False, method=Method()):\n    \"\"\"Used by find_one_brick to look for bricks ***ADVANCED USERS ONLY***\"\"\"\n    methods_available = 0\n\n    if method.usb:\n        try:\n            from . import usbsock\n            methods_available += 1\n            socks = usbsock.find_bricks(host, name)\n            for s in socks:\n                yield s\n        except ImportError:\n            import sys\n            if not silent: print(\"USB module unavailable, not searching there\", file=sys.stderr)\n\n    if method.bluetooth:\n        try:\n            from . import bluesock\n            methods_available += 1\n            try:\n                socks = bluesock.find_bricks(host, name)\n                for s in socks:\n                    yield s\n            except (bluesock.bluetooth.BluetoothError, IOError): #for cases such as no adapter, bluetooth throws IOError, not BluetoothError\n                pass\n        except ImportError:\n            import sys\n            if not silent: print(\"Bluetooth module unavailable, not searching there\", file=sys.stderr)\n\n    if method.device:\n        try:\n            from . import devsock\n            methods_available += 1\n            socks = devsock.find_bricks(name=name)\n            for s in socks:\n                yield s\n        except IOError:\n            pass\n\n    if methods_available == 0:\n        raise NoBackendError(\"No selected backends are available! Did you install the comm modules?\")\n\n\ndef find_one_brick(host=None, name=None, silent=False, strict=None, debug=False, method=None, confpath=None):\n    \"\"\"Use to find one brick. The host and name args limit the search to\na given MAC or brick name. Set silent to True to stop nxt-python from\nprinting anything during the search. This function by default\nautomatically checks to see if the brick found has the correct host\/name\n(if either are provided) and will not return a brick which doesn't\nmatch. This can be disabled (so the function returns any brick which can\nbe connected to and provides a valid reply to get_device_info()) by\npassing strict=False. This will, however, still tell the comm backends\nto only look for devices which match the args provided. The confpath arg\nspecifies the location of the configuration file which brick location\ninformation will be read from if no brick location directives (host,\nname, strict, or method) are provided.\"\"\"\n    if debug and silent:\n        silent = False\n        print(\"silent and debug can't both be set; giving debug priority\")\n\n    conf = read_config(confpath, debug)\n    if not (host or name or strict or method):\n        host\t= conf.get('Brick', 'host')\n        name\t= conf.get('Brick', 'name')\n        strict\t= bool(int(conf.get('Brick', 'strict')))\n        method\t= eval('Method(%s)' % conf.get('Brick', 'method'))\n    if not strict: strict = True\n    if not method: method = Method()\n\n    if debug:\n        print(\"Host: %s Name: %s Strict: %s\" % (host, name, str(strict)))\n        print(\"USB: {} BT: {}\".format(method.usb, method.bluetooth))\n\n    for s in find_bricks(host, name, silent, method):\n        try:\n            if host and 'host' in dir(s) and s.host != host:\n                if debug:\n                    print(\"Warning: the brick found does not match the host provided (s.host).\")\n                if strict: continue\n            b = s.connect()\n            info = b.get_device_info()\n            if debug:\n                print(\"info: \" + str(info))\n\n            strict = False\n\n            if host and info[1] != host:\n                if debug:\n                    print(\"Warning: the brick found does not match the host provided (get_device_info).\")\n                    print(\"  host:\" + str(host))\n                    print(\"  info[1]:\" + info[1])\n                if strict:\n                    s.close()\n                    continue\n\n            info = list(info)\n            info[0] = str(info[0])\n            info[0] = info[0][2:(len(info[0])-1)]\n            info[0] = info[0].strip('\\\\x00')\n\n            if info[0] != name:\n                if debug:\n                    print(\"Warning; the brick found does not match the name provided.\")\n                    print(\"  host:\" + str(host))\n                    print(\"  info[0]:\" + info[0])\n                    print(\"  name:\" + str(name))\n                if strict:\n                    s.close()\n                    continue\n\n            return b\n        except:\n            if debug:\n                traceback.print_exc()\n                print(\"Failed to connect to possible brick\")\n\n    print(\"\"\"No brick was found.\n    Is the brick turned on?\n    For more diagnosing use the debug=True argument or\n    try the 'nxt_test' script located in \/bin or ~\/.local\/bin\"\"\")\n    raise BrickNotFoundError\n\n\ndef server_brick(host, port = 2727):\n    from . import ipsock\n    sock = ipsock.IpSock(host, port)\n    return sock.connect()\n\n\ndef device_brick(filename):\n    from . import devsock\n    sock = devsock.find_bricks(filename=filename)\n    return sock.connect()\n\n\ndef read_config(confpath=None, debug=False):\n    conf = configparser.RawConfigParser({'host': None, 'name': None, 'strict': True, 'method': ''})\n    if not confpath: confpath = os.path.expanduser('~\/.nxt-python')\n    if conf.read([confpath]) == [] and debug:\n        print(\"Warning: Config file (should be at %s) was not read. Use nxt.locator.make_config() to create a config file.\" % confpath)\n    if conf.has_section('Brick') == False:\n        conf.add_section('Brick')\n    return conf\n\n\ndef make_config(confpath=None):\n    conf = configparser.RawConfigParser()\n    if not confpath: confpath = os.path.expanduser('~\/.nxt-python')\n    print(\"Welcome to the nxt-python config file generator!\")\n    print(\"This function creates an example file which find_one_brick uses to find a brick.\")\n    try:\n        if os.path.exists(confpath): input(\"File already exists at %s. Press Enter to overwrite or Ctrl+C to abort.\" % confpath)\n    except KeyboardInterrupt:\n        print(\"Not writing file.\")\n        return\n    conf.add_section('Brick')\n    conf.set('Brick', 'name', 'MyNXT')\n    conf.set('Brick', 'host', '54:32:59:92:F9:39')\n    conf.set('Brick', 'strict', 0)\n    conf.set('Brick', 'method', 'usb=True, bluetooth=False')\n    conf.write(open(confpath, 'w'))\n    print(\"The file has been written at %s\" % confpath)\n    print(\"The file contains less-than-sane default values to get you started.\")\n    print(\"You must now edit the file with a text editor and change the values to match what you would pass to find_one_brick\")\n    print(\"The fields for name, host, and strict correspond to the similar args accepted by find_one_brick\")\n    print(\"The method field contains the string which would be passed to Method()\")\n    print(\"Any field whose corresponding option does not need to be passed to find_one_brick should be commented out (using a # at the start of the line) or simply removed.\")\n    print(\"If you have questions, check the wiki and then ask on the mailing list.\")\n"}},"msg":"don't use eval() for parsing method in config file\n\nThis improves the config file parsing of the method property. It fixes\npossible code injection via eval() as well as makes parsing a bit more\nrobust by filtering out invalid values, such as the obsolete fantom\ndriver values.\n\nFixes #137"}},"https:\/\/github.com\/inducer\/arraycontext":{"d964b2833d495076366c07a1f73c750a75ac2b7c":{"url":"https:\/\/api.github.com\/repos\/inducer\/arraycontext\/commits\/d964b2833d495076366c07a1f73c750a75ac2b7c","html_url":"https:\/\/github.com\/inducer\/arraycontext\/commit\/d964b2833d495076366c07a1f73c750a75ac2b7c","message":"Improve freeze\/thaw usability (#22)\n\n* Add a longer explainer on freeze and thaw\r\n\r\n* Add ArrayContext.clone\r\n\r\n* with_container_arithmetic: Add _same_cls_check\r\n\r\n* Add test for error-on-mixed-array-contexts\r\n\r\n* Improvements\/fixes to freeze\/thaw explainer\r\n\r\nCo-authored-by: Alex Fikl <alexfikl@gmail.com>\r\n\r\n* Remove trailing whitespace (flake8)\r\n\r\n* Add link to lazy eval functionality under the hood of freeze\/thaw\r\n\r\n* Stop using code injection for actx match checking in with_container_arithmetic\r\n\r\n* Make usage guidelines for freeze\/thaw a separate section\r\n\r\nCo-authored-by: Thomas H. Gibson <gibsonthomas1120@hotmail.com>\r\n\r\n* Tweak phrasing in freeze\/thaw usage guidelines, add anchors\r\n\r\n* Remove an extraneous word in the freeze\/thaw description\r\n\r\nCo-authored-by: Alex Fikl <alexfikl@gmail.com>\r\nCo-authored-by: Thomas H. Gibson <gibsonthomas1120@hotmail.com>","sha":"d964b2833d495076366c07a1f73c750a75ac2b7c","keyword":"eval injection fix","diff":"diff --git a\/arraycontext\/container\/arithmetic.py b\/arraycontext\/container\/arithmetic.py\nindex db989c1c..84cfa20c 100644\n--- a\/arraycontext\/container\/arithmetic.py\n+++ b\/arraycontext\/container\/arithmetic.py\n@@ -133,6 +133,7 @@ def with_container_arithmetic(\n         matmul: bool = False,\n         bitwise: bool = False,\n         shift: bool = False,\n+        _cls_has_array_context_attr: bool = False,\n         eq_comparison: Optional[bool] = None,\n         rel_comparison: Optional[bool] = None) -> Callable[[type], type]:\n     \"\"\"A class decorator that implements built-in operators for array containers\n@@ -160,6 +161,11 @@ def with_container_arithmetic(\n     :arg rel_comparison: If *True*, implement ``<``, ``<=``, ``>``, ``>=``.\n         In that case, if *eq_comparison* is unspecified, it is also set to\n         *True*.\n+    :arg _cls_has_array_context_attr: A flag indicating whether the decorated\n+        class has an ``array_context`` attribute. If so, and if :data:`__debug__`\n+        is *True*, an additional check is performed in binary operators\n+        to ensure that both containers use the same array context.\n+        Consider this argument an unstable interface. It may disappear at any moment.\n \n     Each operator class also includes the \"reverse\" operators if applicable.\n \n@@ -245,7 +251,7 @@ def wrap(cls: Any) -> Any:\n                     \"'_deserialize_init_arrays_code'. If this is a dataclass, \"\n                     \"use the 'dataclass_array_container' decorator first.\")\n \n-        from pytools.codegen import CodeGenerator\n+        from pytools.codegen import CodeGenerator, Indentation\n         gen = CodeGenerator()\n         gen(\"\"\"\n             from numbers import Number\n@@ -317,20 +323,28 @@ def {fname}(arg1):\n                     cls._serialize_init_arrays_code(\"arg1\").items()\n                     })\n \n-            gen(f\"\"\"\n-                def {fname}(arg1, arg2):\n-                    if arg2.__class__ is cls:\n-                        return cls({zip_init_args})\n-                    if {bool(outer_bcast_type_names)}:  # optimized away\n-                        if isinstance(arg2, {tup_str(outer_bcast_type_names)}):\n-                            return cls({bcast_init_args})\n-                    if {numpy_pred(\"arg2\")}:  # optimized away\n-                        result = np.empty_like(arg2, dtype=object)\n-                        for i in np.ndindex(arg2.shape):\n-                            result[i] = {op_str.format(\"arg1\", \"arg2[i]\")}\n-                        return result\n-                    return NotImplemented\n-                cls.__{dunder_name}__ = {fname}\"\"\")\n+            gen(f\"def {fname}(arg1, arg2):\")\n+            with Indentation(gen):\n+                gen(\"if arg2.__class__ is cls:\")\n+                with Indentation(gen):\n+                    if __debug__ and _cls_has_array_context_attr:\n+                        gen(\"\"\"\n+                            if arg1.array_context is not arg2.array_context:\n+                                raise ValueError(\"array contexts of both arguments \"\n+                                    \"must match\")\"\"\")\n+                    gen(f\"return cls({zip_init_args})\")\n+                gen(f\"\"\"\n+                if {bool(outer_bcast_type_names)}:  # optimized away\n+                    if isinstance(arg2, {tup_str(outer_bcast_type_names)}):\n+                        return cls({bcast_init_args})\n+                if {numpy_pred(\"arg2\")}:  # optimized away\n+                    result = np.empty_like(arg2, dtype=object)\n+                    for i in np.ndindex(arg2.shape):\n+                        result[i] = {op_str.format(\"arg1\", \"arg2[i]\")}\n+                    return result\n+                return NotImplemented\n+                \"\"\")\n+            gen(f\"cls.__{dunder_name}__ = {fname}\")\n             gen(\"\")\n \n             # }}}\ndiff --git a\/arraycontext\/context.py b\/arraycontext\/context.py\nindex a4b24029..838f9692 100644\n--- a\/arraycontext\/context.py\n+++ b\/arraycontext\/context.py\n@@ -1,4 +1,78 @@\n \"\"\"\n+.. _freeze-thaw:\n+\n+Freezing and thawing\n+--------------------\n+\n+One of the central concepts introduced by the array context formalism is\n+the notion of :meth:`~arraycontext.ArrayContext.freeze` and\n+:meth:`~arraycontext.ArrayContext.thaw`. Each array handled by the array context\n+is either \"thawed\" or \"frozen\". Unlike the real-world concept of freezing and\n+thawing, these operations leave the original array alone; instead, a semantically\n+separate array in the desired state is returned.\n+\n+*   \"Thawed\" arrays are associated with an array context. They use that context\n+    to carry out operations (arithmetic, function calls).\n+\n+*   \"Frozen\" arrays are static data. They are not associated with an array context,\n+    and no operations can be performed on them.\n+\n+Freezing and thawing may be used to move arrays from one array context to another,\n+as long as both array contexts use identical in-memory data representation.\n+Otherwise, a common format must be agreed upon, for example using\n+:mod:`numpy` through :meth:`~arraycontext.ArrayContext.to_numpy` and\n+:meth:`~arraycontext.ArrayContext.from_numpy`.\n+\n+.. _freeze-thaw-guidelines:\n+\n+Usage guidelines\n+^^^^^^^^^^^^^^^^\n+Here are some rules of thumb to use when dealing with thawing and freezing:\n+\n+-   Any array that is stored for a long time needs to be frozen.\n+    \"Memoized\" data (cf. :func:`pytools.memoize` and friends) is a good example\n+    of long-lived data that should be frozen.\n+\n+-   Within a function, if the user did not supply an array context,\n+    then any data returned to the user should be frozen.\n+\n+-   Note that array contexts need not necessarily be passed as a separate\n+    argument. Passing thawed data as an argument to a function suffices\n+    to supply an array context. The array context can be extracted from\n+    a thawed argument using, e.g., :func:`~arraycontext.get_container_context`\n+    or :func:`~arraycontext.get_container_context_recursively`.\n+\n+What does this mean concretely?\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+Freezing and thawing are abstract names for concrete operations. It may be helpful\n+to understand what these operations mean in the concrete case of various\n+actual array contexts:\n+\n+-   Each :class:`~arraycontext.PyOpenCLArrayContext` is associated with a\n+    :class:`pyopencl.CommandQueue`. In order to operate on array data,\n+    such a command queue is necessary; it is the main means of synchronization\n+    between the host program and the compute device. \"Thawing\" here\n+    means associating an array with a command queue, and \"freezing\" means\n+    ensuring that the array data is fully computed in memory and\n+    decoupling the array from the command queue. It is not valid to \"mix\"\n+    arrays associated with multiple queues within an operation: if it were allowed,\n+    a dependent operation might begin computing before an input is fully\n+    available. (Since bugs of this nature would be very difficult to\n+    find, :class:`pyopencl.array.Array` and\n+    :class:`~meshmode.dof_array.DOFArray` will not allow them.)\n+\n+-   For the lazily-evaluating array context based on :mod:`pytato`,\n+    \"thawing\" corresponds to the creation of a symbolic \"handle\"\n+    (specifically, a :class:`pytato.array.DataWrapper`) representing\n+    the array that can then be used in computation, and \"freezing\"\n+    corresponds to triggering (code generation and) evaluation of\n+    an array expression that has been built up by the user\n+    (using, e.g. :func:`pytato.generate_loopy`).\n+\n+The interface of an array context\n+---------------------------------\n+\n .. currentmodule:: arraycontext\n .. autoclass:: ArrayContext\n \"\"\"\n@@ -256,6 +330,25 @@ def einsum(self, spec, *args, arg_names=None, tagged=()):\n             prg, **{arg_names[i]: arg for i, arg in enumerate(args)}\n         )[\"out\"]\n \n+    @abstractmethod\n+    def clone(self):\n+        \"\"\"If possible, return a version of *self* that is semantically\n+        equivalent (i.e. implements all array operations in the same way)\n+        but is a separate object. May return *self* if that is not possible.\n+\n+        .. note::\n+\n+            The main objective of this semi-documented method is to help\n+            flag errors more clearly when array contexts are mixed that\n+            should not be. For example, at the time of this writing,\n+            :class:`meshmode.meshmode.Discretization` objects have a private\n+            array context that is only to be used for setup-related tasks.\n+            By using :meth:`clone` to make this a separate array context,\n+            and by checking that arithmetic does not mix array contexts,\n+            it becomes easier to detect and flag if unfrozen data attached to a\n+            \"setup-only\" array context \"leaks\" into the application.\n+        \"\"\"\n+\n # }}}\n \n # vim: foldmethod=marker\ndiff --git a\/arraycontext\/impl\/pyopencl.py b\/arraycontext\/impl\/pyopencl.py\nindex 1906509d..c2726ad1 100644\n--- a\/arraycontext\/impl\/pyopencl.py\n+++ b\/arraycontext\/impl\/pyopencl.py\n@@ -388,6 +388,9 @@ def tag_axis(self, iaxis, tags: Union[Sequence[Tag], Tag], array):\n         # Sorry, not capable.\n         return array\n \n+    def clone(self):\n+        return type(self)(self.queue, self.allocator, self._wait_event_queue_length)\n+\n # }}}\n \n # vim: foldmethod=marker\ndiff --git a\/test\/test_arraycontext.py b\/test\/test_arraycontext.py\nindex aeadb70a..30b7103a 100644\n--- a\/test\/test_arraycontext.py\n+++ b\/test\/test_arraycontext.py\n@@ -46,7 +46,8 @@\n @with_container_arithmetic(\n         bcast_obj_array=True,\n         bcast_numpy_array=True,\n-        rel_comparison=True)\n+        rel_comparison=True,\n+        _cls_has_array_context_attr=True)\n class DOFArray:\n     def __init__(self, actx, data):\n         if not (actx is None or isinstance(actx, ArrayContext)):\n@@ -624,6 +625,13 @@ def test_container_freeze_thaw(actx_factory):\n         assert get_container_context_recursively(frozen_ary) is None\n         assert get_container_context_recursively(thawed_ary) is actx\n \n+    actx2 = actx.clone()\n+\n+    ary_dof_2 = thaw(freeze(ary_dof), actx2)\n+\n+    with pytest.raises(ValueError):\n+        ary_dof + ary_dof_2\n+\n     # }}}\n \n \n","files":{"\/arraycontext\/container\/arithmetic.py":{"changes":[{"diff":"\n                     \"'_deserialize_init_arrays_code'. If this is a dataclass, \"\n                     \"use the 'dataclass_array_container' decorator first.\")\n \n-        from pytools.codegen import CodeGenerator\n+        from pytools.codegen import CodeGenerator, Indentation\n         gen = CodeGenerator()\n         gen(\"\"\"\n             from numbers import Number\n","add":1,"remove":1,"filename":"\/arraycontext\/container\/arithmetic.py","badparts":["        from pytools.codegen import CodeGenerator"],"goodparts":["        from pytools.codegen import CodeGenerator, Indentation"]},{"diff":"\n                     cls._serialize_init_arrays_code(\"arg1\").items()\n                     })\n \n-            gen(f\"\"\"\n-                def {fname}(arg1, arg2):\n-                    if arg2.__class__ is cls:\n-                        return cls({zip_init_args})\n-                    if {bool(outer_bcast_type_names)}:  # optimized away\n-                        if isinstance(arg2, {tup_str(outer_bcast_type_names)}):\n-                            return cls({bcast_init_args})\n-                    if {numpy_pred(\"arg2\")}:  # optimized away\n-                        result = np.empty_like(arg2, dtype=object)\n-                        for i in np.ndindex(arg2.shape):\n-                            result[i] = {op_str.format(\"arg1\", \"arg2[i]\")}\n-                        return result\n-                    return NotImplemented\n-                cls.__{dunder_name}__ = {fname}\"\"\")\n+            gen(f\"def {fname}(arg1, arg2):\")\n+            with Indentation(gen):\n+                gen(\"if arg2.__class__ is cls:\")\n+                with Indentation(gen):\n+                    if __debug__ and _cls_has_array_context_attr:\n+                        gen(\"\"\"\n+                            if arg1.array_context is not arg2.array_context:\n+                                raise ValueError(\"array contexts of both arguments \"\n+                                    \"must match\")\"\"\")\n+                    gen(f\"return cls({zip_init_args})\")\n+                gen(f\"\"\"\n+                if {bool(outer_bcast_type_names)}:  # optimized away\n+                    if isinstance(arg2, {tup_str(outer_bcast_type_names)}):\n+                        return cls({bcast_init_args})\n+                if {numpy_pred(\"arg2\")}:  # optimized away\n+                    result = np.empty_like(arg2, dtype=object)\n+                    for i in np.ndindex(arg2.shape):\n+                        result[i] = {op_str.format(\"arg1\", \"arg2[i]\")}\n+                    return result\n+                return NotImplemented\n+                \"\"\")\n+            gen(f\"cls.__{dunder_name}__ = {fname}\")\n             gen(\"\")\n \n             # }}}","add":22,"remove":14,"filename":"\/arraycontext\/container\/arithmetic.py","badparts":["            gen(f\"\"\"","                def {fname}(arg1, arg2):","                    if arg2.__class__ is cls:","                        return cls({zip_init_args})","                    if {bool(outer_bcast_type_names)}:  # optimized away","                        if isinstance(arg2, {tup_str(outer_bcast_type_names)}):","                            return cls({bcast_init_args})","                    if {numpy_pred(\"arg2\")}:  # optimized away","                        result = np.empty_like(arg2, dtype=object)","                        for i in np.ndindex(arg2.shape):","                            result[i] = {op_str.format(\"arg1\", \"arg2[i]\")}","                        return result","                    return NotImplemented","                cls.__{dunder_name}__ = {fname}\"\"\")"],"goodparts":["            gen(f\"def {fname}(arg1, arg2):\")","            with Indentation(gen):","                gen(\"if arg2.__class__ is cls:\")","                with Indentation(gen):","                    if __debug__ and _cls_has_array_context_attr:","                        gen(\"\"\"","                            if arg1.array_context is not arg2.array_context:","                                raise ValueError(\"array contexts of both arguments \"","                                    \"must match\")\"\"\")","                    gen(f\"return cls({zip_init_args})\")","                gen(f\"\"\"","                if {bool(outer_bcast_type_names)}:  # optimized away","                    if isinstance(arg2, {tup_str(outer_bcast_type_names)}):","                        return cls({bcast_init_args})","                if {numpy_pred(\"arg2\")}:  # optimized away","                    result = np.empty_like(arg2, dtype=object)","                    for i in np.ndindex(arg2.shape):","                        result[i] = {op_str.format(\"arg1\", \"arg2[i]\")}","                    return result","                return NotImplemented","                \"\"\")","            gen(f\"cls.__{dunder_name}__ = {fname}\")"]}],"source":"\n \"\"\" .. currentmodule:: arraycontext .. autofunction:: with_container_arithmetic \"\"\" import enum __copyright__=\"\"\" Copyright(C) 2020-1 University of Illinois Board of Trustees \"\"\" __license__=\"\"\" Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files(the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from typing import Any, Callable, Optional, Tuple, TypeVar, Union import numpy as np T=TypeVar(\"T\") class _OpClass(enum.Enum): ARITHMETIC=enum.auto MATMUL=enum.auto BITWISE=enum.auto SHIFT=enum.auto EQ_COMPARISON=enum.auto REL_COMPARISON=enum.auto _UNARY_OP_AND_DUNDER=[ (\"pos\", \"+{}\", _OpClass.ARITHMETIC), (\"neg\", \"-{}\", _OpClass.ARITHMETIC), (\"abs\", \"abs({})\", _OpClass.ARITHMETIC), (\"inv\", \"~{}\", _OpClass.BITWISE), ] _BINARY_OP_AND_DUNDER=[ (\"add\", \"{} +{}\", True, _OpClass.ARITHMETIC), (\"sub\", \"{} -{}\", True, _OpClass.ARITHMETIC), (\"mul\", \"{} *{}\", True, _OpClass.ARITHMETIC), (\"truediv\", \"{} \/{}\", True, _OpClass.ARITHMETIC), (\"floordiv\", \"{} \/\/{}\", True, _OpClass.ARITHMETIC), (\"pow\", \"{} **{}\", True, _OpClass.ARITHMETIC), (\"mod\", \"{} %{}\", True, _OpClass.ARITHMETIC), (\"divmod\", \"divmod({},{})\", True, _OpClass.ARITHMETIC), (\"matmul\", \"{} @{}\", True, _OpClass.MATMUL), (\"and\", \"{} &{}\", True, _OpClass.BITWISE), (\"or\", \"{} |{}\", True, _OpClass.BITWISE), (\"xor\", \"{} ^{}\", True, _OpClass.BITWISE), (\"lshift\", \"{} <<{}\", False, _OpClass.SHIFT), (\"rshift\", \"{} >>{}\", False, _OpClass.SHIFT), (\"eq\", \"{}=={}\", False, _OpClass.EQ_COMPARISON), (\"ne\", \"{} !={}\", False, _OpClass.EQ_COMPARISON), (\"lt\", \"{} <{}\", False, _OpClass.REL_COMPARISON), (\"gt\", \"{} >{}\", False, _OpClass.REL_COMPARISON), (\"le\", \"{} <={}\", False, _OpClass.REL_COMPARISON), (\"ge\", \"{} >={}\", False, _OpClass.REL_COMPARISON), ] def _format_unary_op_str(op_str: str, arg1: Union[Tuple[str,...], str]) -> str: if isinstance(arg1, tuple): arg1_entry, arg1_container=arg1 return(f\"{op_str.format(arg1_entry)} \" f\"for{arg1_entry} in{arg1_container}\") else: return op_str.format(arg1) def _format_binary_op_str(op_str: str, arg1: Union[Tuple[str,...], str], arg2: Union[Tuple[str,...], str]) -> str: if isinstance(arg1, tuple) and isinstance(arg2, tuple): import sys if sys.version_info >=(3, 10): strict_arg=\", strict=__debug__\" else: strict_arg=\"\" arg1_entry, arg1_container=arg1 arg2_entry, arg2_container=arg2 return(f\"{op_str.format(arg1_entry, arg2_entry)} \" f\"for{arg1_entry},{arg2_entry} \" f\"in zip({arg1_container},{arg2_container}{strict_arg})\") elif isinstance(arg1, tuple): arg1_entry, arg1_container=arg1 return(f\"{op_str.format(arg1_entry, arg2)} \" f\"for{arg1_entry} in{arg1_container}\") elif isinstance(arg2, tuple): arg2_entry, arg2_container=arg2 return(f\"{op_str.format(arg1, arg2_entry)} \" f\"for{arg2_entry} in{arg2_container}\") else: return op_str.format(arg1, arg2) def with_container_arithmetic( *, bcast_number: bool=True, bcast_obj_array: Optional[bool]=None, bcast_numpy_array: bool=False, bcast_container_types: Optional[Tuple[type,...]]=None, arithmetic: bool=True, matmul: bool=False, bitwise: bool=False, shift: bool=False, eq_comparison: Optional[bool]=None, rel_comparison: Optional[bool]=None) -> Callable[[type], type]: \"\"\"A class decorator that implements built-in operators for array containers by propagating the operations to the elements of the container. :arg bcast_number: If *True*, numbers broadcast over the container (with the container as the 'outer' structure). :arg bcast_obj_array: If *True*,:mod:`numpy` object arrays broadcast over the container. (with the container as the 'inner' structure) :arg bcast_numpy_array: If *True*, any:class:`numpy.ndarray` will broadcast over the container. (with the container as the 'inner' structure) If this is set to *True*, *bcast_obj_array* must also be *True*. :arg bcast_container_types: A sequence of container types that will broadcast over this container(with this container as the 'outer' structure). :class:`numpy.ndarray` is permitted to be part of this sequence to indicate that, in such broadcasting situations, this container should be the 'outer' structure. In this case, *bcast_obj_array* (and consequently *bcast_numpy_array*) must be *False*. :arg arithmetic: Implement the conventional arithmetic operators, including ``**``,:func:`divmod`, and ``\/\/``. Also includes ``+`` and ``-`` as well as :func:`abs`. :arg bitwise: If *True*, implement bitwise and, or, not, and inversion. :arg shift: If *True*, implement bit shifts. :arg eq_comparison: If *True*, implement ``==`` and ``!=``. :arg rel_comparison: If *True*, implement ``<``, ``<=``, ``>``, ``>=``. In that case, if *eq_comparison* is unspecified, it is also set to *True*. Each operator class also includes the \"reverse\" operators if applicable. .. note:: To generate the code implementing the operators, this function relies on class methods ``_deserialize_init_arrays_code`` and ``_serialize_init_arrays_code``. This interface should be considered undocumented and subject to change, however if you are curious, you may look at its implementation in:class:`meshmode.dof_array.DOFArray`. For a simple structure type, the implementation might look like this:: @classmethod def _serialize_init_arrays_code(cls, instance_name): return{\"u\": f\"{instance_name}.u\", \"v\": f\"{instance_name}.v\"} @classmethod def _deserialize_init_arrays_code(cls, tmpl_instance_name, args): return f\"u={args['u']}, v={args['v']}\" :func:`dataclass_array_container` automatically generates an appropriate implementation of these methods, so:func:`with_container_arithmetic` should nest \"outside\":func:dataclass_array_container`. \"\"\" if bcast_obj_array is None: raise TypeError(\"bcast_obj_array must be specified\") if rel_comparison is None: raise TypeError(\"rel_comparison must be specified\") if rel_comparison and eq_comparison is None: eq_comparison=True if eq_comparison is None: raise TypeError(\"eq_comparison must be specified\") if not bcast_obj_array and bcast_numpy_array: raise TypeError(\"bcast_obj_array must be set if bcast_numpy_array is\") if bcast_numpy_array: def numpy_pred(name: str) -> str: return f\"isinstance({name}, np.ndarray)\" elif bcast_obj_array: def numpy_pred(name: str) -> str: return f\"isinstance({name}, np.ndarray) and{name}.dtype.char=='O'\" else: def numpy_pred(name: str) -> str: return \"False\" if bcast_container_types is None: bcast_container_types=() bcast_container_types_count=len(bcast_container_types) if np.ndarray in bcast_container_types and bcast_obj_array: raise ValueError(\"If numpy.ndarray is part of bcast_container_types, \" \"bcast_obj_array must be False.\") desired_op_classes=set() if arithmetic: desired_op_classes.add(_OpClass.ARITHMETIC) if matmul: desired_op_classes.add(_OpClass.MATMUL) if bitwise: desired_op_classes.add(_OpClass.BITWISE) if shift: desired_op_classes.add(_OpClass.SHIFT) if eq_comparison: desired_op_classes.add(_OpClass.EQ_COMPARISON) if rel_comparison: desired_op_classes.add(_OpClass.REL_COMPARISON) def wrap(cls: Any) -> Any: if(not hasattr(cls, \"_serialize_init_arrays_code\") or not hasattr(cls, \"_deserialize_init_arrays_code\")): raise TypeError(f\"class '{cls.__name__}' must provide serialization \" \"code to generate arithmetic operations by implementing \" \"'_serialize_init_arrays_code' and \" \"'_deserialize_init_arrays_code'. If this is a dataclass, \" \"use the 'dataclass_array_container' decorator first.\") from pytools.codegen import CodeGenerator gen=CodeGenerator() gen(\"\"\" from numbers import Number import numpy as np from arraycontext import ArrayContainer \"\"\") gen(\"\") if bcast_container_types: for i, bct in enumerate(bcast_container_types): gen(f\"from{bct.__module__} import{bct.__qualname__} as _bctype{i}\") gen(\"\") outer_bcast_type_names=tuple([ f\"_bctype{i}\" for i in range(bcast_container_types_count) ]) if bcast_number: outer_bcast_type_names +=(\"Number\",) def same_key(k1: T, k2: T) -> T: assert k1==k2 return k1 def tup_str(t: Tuple[str,...]) -> str: if not t: return \"()\" else: return \"(%s,)\" % \", \".join(t) for dunder_name, op_str, op_cls in _UNARY_OP_AND_DUNDER: if op_cls not in desired_op_classes: continue fname=f\"_{cls.__name__.lower()}_{dunder_name}\" init_args=cls._deserialize_init_arrays_code(\"arg1\",{ key_arg1: _format_unary_op_str(op_str, expr_arg1) for key_arg1, expr_arg1 in cls._serialize_init_arrays_code(\"arg1\").items() }) gen(f\"\"\" def{fname}(arg1): return cls({init_args}) cls.__{dunder_name}__={fname}\"\"\") gen(\"\") for dunder_name, op_str, reversible, op_cls in _BINARY_OP_AND_DUNDER: if op_cls not in desired_op_classes: continue fname=f\"_{cls.__name__.lower()}_{dunder_name}\" zip_init_args=cls._deserialize_init_arrays_code(\"arg1\",{ same_key(key_arg1, key_arg2): _format_binary_op_str(op_str, expr_arg1, expr_arg2) for(key_arg1, expr_arg1),(key_arg2, expr_arg2) in zip( cls._serialize_init_arrays_code(\"arg1\").items(), cls._serialize_init_arrays_code(\"arg2\").items()) }) bcast_init_args=cls._deserialize_init_arrays_code(\"arg1\",{ key_arg1: _format_binary_op_str(op_str, expr_arg1, \"arg2\") for key_arg1, expr_arg1 in cls._serialize_init_arrays_code(\"arg1\").items() }) gen(f\"\"\" def{fname}(arg1, arg2): if arg2.__class__ is cls: return cls({zip_init_args}) if{bool(outer_bcast_type_names)}: if isinstance(arg2,{tup_str(outer_bcast_type_names)}): return cls({bcast_init_args}) if{numpy_pred(\"arg2\")}: result=np.empty_like(arg2, dtype=object) for i in np.ndindex(arg2.shape): result[i]={op_str.format(\"arg1\", \"arg2[i]\")} return result return NotImplemented cls.__{dunder_name}__={fname}\"\"\") gen(\"\") if reversible: fname=f\"_{cls.__name__.lower()}_r{dunder_name}\" bcast_init_args=cls._deserialize_init_arrays_code(\"arg2\",{ key_arg2: _format_binary_op_str( op_str, \"arg1\", expr_arg2) for key_arg2, expr_arg2 in cls._serialize_init_arrays_code(\"arg2\").items() }) gen(f\"\"\" def{fname}(arg2, arg1): if{bool(outer_bcast_type_names)}: if isinstance(arg1,{tup_str(outer_bcast_type_names)}): return cls({bcast_init_args}) if{numpy_pred(\"arg1\")}: result=np.empty_like(arg1, dtype=object) for i in np.ndindex(arg1.shape): result[i]={op_str.format(\"arg1[i]\", \"arg2\")} return result return NotImplemented cls.__r{dunder_name}__={fname}\"\"\") gen(\"\") code=gen.get().rstrip()+\"\\n\" result_dict={\"_MODULE_SOURCE_CODE\": code, \"cls\": cls} exec(compile(code, \"<generated code>\", \"exec\"), result_dict) return cls return wrap ","sourceWithComments":"# mypy: disallow-untyped-defs\n\n\"\"\"\n.. currentmodule:: arraycontext\n.. autofunction:: with_container_arithmetic\n\"\"\"\n\nimport enum\n\n__copyright__ = \"\"\"\nCopyright (C) 2020-1 University of Illinois Board of Trustees\n\"\"\"\n\n__license__ = \"\"\"\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\"\"\n\nfrom typing import Any, Callable, Optional, Tuple, TypeVar, Union\n\nimport numpy as np\n\n\n# {{{ with_container_arithmetic\n\nT = TypeVar(\"T\")\n\n\nclass _OpClass(enum.Enum):\n    ARITHMETIC = enum.auto\n    MATMUL = enum.auto\n    BITWISE = enum.auto\n    SHIFT = enum.auto\n    EQ_COMPARISON = enum.auto\n    REL_COMPARISON = enum.auto\n\n\n_UNARY_OP_AND_DUNDER = [\n        (\"pos\", \"+{}\", _OpClass.ARITHMETIC),\n        (\"neg\", \"-{}\", _OpClass.ARITHMETIC),\n        (\"abs\", \"abs({})\", _OpClass.ARITHMETIC),\n        (\"inv\", \"~{}\", _OpClass.BITWISE),\n        ]\n_BINARY_OP_AND_DUNDER = [\n        (\"add\", \"{} + {}\", True, _OpClass.ARITHMETIC),\n        (\"sub\", \"{} - {}\", True, _OpClass.ARITHMETIC),\n        (\"mul\", \"{} * {}\", True, _OpClass.ARITHMETIC),\n        (\"truediv\", \"{} \/ {}\", True, _OpClass.ARITHMETIC),\n        (\"floordiv\", \"{} \/\/ {}\", True, _OpClass.ARITHMETIC),\n        (\"pow\", \"{} ** {}\", True, _OpClass.ARITHMETIC),\n        (\"mod\", \"{} % {}\", True, _OpClass.ARITHMETIC),\n        (\"divmod\", \"divmod({}, {})\", True, _OpClass.ARITHMETIC),\n\n        (\"matmul\", \"{} @ {}\", True, _OpClass.MATMUL),\n\n        (\"and\", \"{} & {}\", True, _OpClass.BITWISE),\n        (\"or\", \"{} | {}\", True, _OpClass.BITWISE),\n        (\"xor\", \"{} ^ {}\", True, _OpClass.BITWISE),\n\n        (\"lshift\", \"{} << {}\", False, _OpClass.SHIFT),\n        (\"rshift\", \"{} >> {}\", False, _OpClass.SHIFT),\n\n        (\"eq\", \"{} == {}\", False, _OpClass.EQ_COMPARISON),\n        (\"ne\", \"{} != {}\", False, _OpClass.EQ_COMPARISON),\n\n        (\"lt\", \"{} < {}\", False, _OpClass.REL_COMPARISON),\n        (\"gt\", \"{} > {}\", False, _OpClass.REL_COMPARISON),\n        (\"le\", \"{} <= {}\", False, _OpClass.REL_COMPARISON),\n        (\"ge\", \"{} >= {}\", False, _OpClass.REL_COMPARISON),\n        ]\n\n\ndef _format_unary_op_str(op_str: str, arg1: Union[Tuple[str, ...], str]) -> str:\n    if isinstance(arg1, tuple):\n        arg1_entry, arg1_container = arg1\n        return (f\"{op_str.format(arg1_entry)} \"\n                f\"for {arg1_entry} in {arg1_container}\")\n    else:\n        return op_str.format(arg1)\n\n\ndef _format_binary_op_str(op_str: str,\n        arg1: Union[Tuple[str, ...], str],\n        arg2: Union[Tuple[str, ...], str]) -> str:\n    if isinstance(arg1, tuple) and isinstance(arg2, tuple):\n        import sys\n        if sys.version_info >= (3, 10):\n            strict_arg = \", strict=__debug__\"\n        else:\n            strict_arg = \"\"\n\n        arg1_entry, arg1_container = arg1\n        arg2_entry, arg2_container = arg2\n        return (f\"{op_str.format(arg1_entry, arg2_entry)} \"\n                f\"for {arg1_entry}, {arg2_entry} \"\n                f\"in zip({arg1_container}, {arg2_container}{strict_arg})\")\n\n    elif isinstance(arg1, tuple):\n        arg1_entry, arg1_container = arg1\n        return (f\"{op_str.format(arg1_entry, arg2)} \"\n                f\"for {arg1_entry} in {arg1_container}\")\n\n    elif isinstance(arg2, tuple):\n        arg2_entry, arg2_container = arg2\n        return (f\"{op_str.format(arg1, arg2_entry)} \"\n                f\"for {arg2_entry} in {arg2_container}\")\n    else:\n        return op_str.format(arg1, arg2)\n\n\ndef with_container_arithmetic(\n        *,\n        bcast_number: bool = True,\n        bcast_obj_array: Optional[bool] = None,\n        bcast_numpy_array: bool = False,\n        bcast_container_types: Optional[Tuple[type, ...]] = None,\n        arithmetic: bool = True,\n        matmul: bool = False,\n        bitwise: bool = False,\n        shift: bool = False,\n        eq_comparison: Optional[bool] = None,\n        rel_comparison: Optional[bool] = None) -> Callable[[type], type]:\n    \"\"\"A class decorator that implements built-in operators for array containers\n    by propagating the operations to the elements of the container.\n\n    :arg bcast_number: If *True*, numbers broadcast over the container\n        (with the container as the 'outer' structure).\n    :arg bcast_obj_array: If *True*, :mod:`numpy` object arrays broadcast over\n        the container.  (with the container as the 'inner' structure)\n    :arg bcast_numpy_array: If *True*, any :class:`numpy.ndarray` will broadcast\n        over the container.  (with the container as the 'inner' structure)\n        If this is set to *True*, *bcast_obj_array* must also be *True*.\n    :arg bcast_container_types: A sequence of container types that will broadcast\n        over this container (with this container as the 'outer' structure).\n        :class:`numpy.ndarray` is permitted to be part of this sequence to\n        indicate that, in such broadcasting situations, this container should\n        be the 'outer' structure. In this case, *bcast_obj_array*\n        (and consequently *bcast_numpy_array*) must be *False*.\n    :arg arithmetic: Implement the conventional arithmetic operators, including\n        ``**``, :func:`divmod`, and ``\/\/``. Also includes ``+`` and ``-`` as well as\n        :func:`abs`.\n    :arg bitwise: If *True*, implement bitwise and, or, not, and inversion.\n    :arg shift: If *True*, implement bit shifts.\n    :arg eq_comparison: If *True*, implement ``==`` and ``!=``.\n    :arg rel_comparison: If *True*, implement ``<``, ``<=``, ``>``, ``>=``.\n        In that case, if *eq_comparison* is unspecified, it is also set to\n        *True*.\n\n    Each operator class also includes the \"reverse\" operators if applicable.\n\n    .. note::\n\n        To generate the code implementing the operators, this function relies on\n        class methods ``_deserialize_init_arrays_code`` and\n        ``_serialize_init_arrays_code``. This interface should be considered\n        undocumented and subject to change, however if you are curious, you may look\n        at its implementation in :class:`meshmode.dof_array.DOFArray`. For a simple\n        structure type, the implementation might look like this::\n\n            @classmethod\n            def _serialize_init_arrays_code(cls, instance_name):\n                return {\"u\": f\"{instance_name}.u\", \"v\": f\"{instance_name}.v\"}\n\n            @classmethod\n            def _deserialize_init_arrays_code(cls, tmpl_instance_name, args):\n                return f\"u={args['u']}, v={args['v']}\"\n\n    :func:`dataclass_array_container` automatically generates an appropriate\n    implementation of these methods, so :func:`with_container_arithmetic`\n    should nest \"outside\" :func:dataclass_array_container`.\n    \"\"\"\n\n    # {{{ handle inputs\n\n    if bcast_obj_array is None:\n        raise TypeError(\"bcast_obj_array must be specified\")\n\n    if rel_comparison is None:\n        raise TypeError(\"rel_comparison must be specified\")\n\n    if rel_comparison and eq_comparison is None:\n        eq_comparison = True\n\n    if eq_comparison is None:\n        raise TypeError(\"eq_comparison must be specified\")\n\n    if not bcast_obj_array and bcast_numpy_array:\n        raise TypeError(\"bcast_obj_array must be set if bcast_numpy_array is\")\n\n    if bcast_numpy_array:\n        def numpy_pred(name: str) -> str:\n            return f\"isinstance({name}, np.ndarray)\"\n    elif bcast_obj_array:\n        def numpy_pred(name: str) -> str:\n            return f\"isinstance({name}, np.ndarray) and {name}.dtype.char == 'O'\"\n    else:\n        def numpy_pred(name: str) -> str:\n            return \"False\"  # optimized away\n\n    if bcast_container_types is None:\n        bcast_container_types = ()\n    bcast_container_types_count = len(bcast_container_types)\n\n    if np.ndarray in bcast_container_types and bcast_obj_array:\n        raise ValueError(\"If numpy.ndarray is part of bcast_container_types, \"\n                \"bcast_obj_array must be False.\")\n\n    desired_op_classes = set()\n    if arithmetic:\n        desired_op_classes.add(_OpClass.ARITHMETIC)\n    if matmul:\n        desired_op_classes.add(_OpClass.MATMUL)\n    if bitwise:\n        desired_op_classes.add(_OpClass.BITWISE)\n    if shift:\n        desired_op_classes.add(_OpClass.SHIFT)\n    if eq_comparison:\n        desired_op_classes.add(_OpClass.EQ_COMPARISON)\n    if rel_comparison:\n        desired_op_classes.add(_OpClass.REL_COMPARISON)\n\n    # }}}\n\n    def wrap(cls: Any) -> Any:\n        if (not hasattr(cls, \"_serialize_init_arrays_code\")\n                or not hasattr(cls, \"_deserialize_init_arrays_code\")):\n            raise TypeError(f\"class '{cls.__name__}' must provide serialization \"\n                    \"code to generate arithmetic operations by implementing \"\n                    \"'_serialize_init_arrays_code' and \"\n                    \"'_deserialize_init_arrays_code'. If this is a dataclass, \"\n                    \"use the 'dataclass_array_container' decorator first.\")\n\n        from pytools.codegen import CodeGenerator\n        gen = CodeGenerator()\n        gen(\"\"\"\n            from numbers import Number\n            import numpy as np\n            from arraycontext import ArrayContainer\n            \"\"\")\n        gen(\"\")\n\n        if bcast_container_types:\n            for i, bct in enumerate(bcast_container_types):\n                gen(f\"from {bct.__module__} import {bct.__qualname__} as _bctype{i}\")\n            gen(\"\")\n        outer_bcast_type_names = tuple([\n                f\"_bctype{i}\" for i in range(bcast_container_types_count)\n                ])\n        if bcast_number:\n            outer_bcast_type_names += (\"Number\",)\n\n        def same_key(k1: T, k2: T) -> T:\n            assert k1 == k2\n            return k1\n\n        def tup_str(t: Tuple[str, ...]) -> str:\n            if not t:\n                return \"()\"\n            else:\n                return \"(%s,)\" % \", \".join(t)\n\n        # {{{ unary operators\n\n        for dunder_name, op_str, op_cls in _UNARY_OP_AND_DUNDER:\n            if op_cls not in desired_op_classes:\n                continue\n\n            fname = f\"_{cls.__name__.lower()}_{dunder_name}\"\n            init_args = cls._deserialize_init_arrays_code(\"arg1\", {\n                    key_arg1: _format_unary_op_str(op_str, expr_arg1)\n                    for key_arg1, expr_arg1 in\n                    cls._serialize_init_arrays_code(\"arg1\").items()\n                    })\n\n            gen(f\"\"\"\n                def {fname}(arg1):\n                    return cls({init_args})\n                cls.__{dunder_name}__ = {fname}\"\"\")\n            gen(\"\")\n\n        # }}}\n\n        # {{{ binary operators\n\n        for dunder_name, op_str, reversible, op_cls in _BINARY_OP_AND_DUNDER:\n            if op_cls not in desired_op_classes:\n                continue\n\n            # {{{ \"forward\" binary operators\n\n            fname = f\"_{cls.__name__.lower()}_{dunder_name}\"\n            zip_init_args = cls._deserialize_init_arrays_code(\"arg1\", {\n                    same_key(key_arg1, key_arg2):\n                    _format_binary_op_str(op_str, expr_arg1, expr_arg2)\n                    for (key_arg1, expr_arg1), (key_arg2, expr_arg2) in zip(\n                        cls._serialize_init_arrays_code(\"arg1\").items(),\n                        cls._serialize_init_arrays_code(\"arg2\").items())\n                    })\n            bcast_init_args = cls._deserialize_init_arrays_code(\"arg1\", {\n                    key_arg1: _format_binary_op_str(op_str, expr_arg1, \"arg2\")\n                    for key_arg1, expr_arg1 in\n                    cls._serialize_init_arrays_code(\"arg1\").items()\n                    })\n\n            gen(f\"\"\"\n                def {fname}(arg1, arg2):\n                    if arg2.__class__ is cls:\n                        return cls({zip_init_args})\n                    if {bool(outer_bcast_type_names)}:  # optimized away\n                        if isinstance(arg2, {tup_str(outer_bcast_type_names)}):\n                            return cls({bcast_init_args})\n                    if {numpy_pred(\"arg2\")}:  # optimized away\n                        result = np.empty_like(arg2, dtype=object)\n                        for i in np.ndindex(arg2.shape):\n                            result[i] = {op_str.format(\"arg1\", \"arg2[i]\")}\n                        return result\n                    return NotImplemented\n                cls.__{dunder_name}__ = {fname}\"\"\")\n            gen(\"\")\n\n            # }}}\n\n            # {{{ \"reverse\" binary operators\n\n            if reversible:\n                fname = f\"_{cls.__name__.lower()}_r{dunder_name}\"\n                bcast_init_args = cls._deserialize_init_arrays_code(\"arg2\", {\n                        key_arg2: _format_binary_op_str(\n                            op_str, \"arg1\", expr_arg2)\n                        for key_arg2, expr_arg2 in\n                        cls._serialize_init_arrays_code(\"arg2\").items()\n                        })\n                gen(f\"\"\"\n                    def {fname}(arg2, arg1):\n                        # assert other.__cls__ is not cls\n\n                        if {bool(outer_bcast_type_names)}:  # optimized away\n                            if isinstance(arg1, {tup_str(outer_bcast_type_names)}):\n                                return cls({bcast_init_args})\n                        if {numpy_pred(\"arg1\")}:  # optimized away\n                            result = np.empty_like(arg1, dtype=object)\n                            for i in np.ndindex(arg1.shape):\n                                result[i] = {op_str.format(\"arg1[i]\", \"arg2\")}\n                            return result\n                        return NotImplemented\n\n                    cls.__r{dunder_name}__ = {fname}\"\"\")\n                gen(\"\")\n\n            # }}}\n\n        # }}}\n\n        # This will evaluate the module, which is all we need.\n        code = gen.get().rstrip()+\"\\n\"\n        result_dict = {\"_MODULE_SOURCE_CODE\": code, \"cls\": cls}\n        exec(compile(code, \"<generated code>\", \"exec\"), result_dict)\n\n        return cls\n\n    # we're being called as @with_container_arithmetic(...), with parens\n    return wrap\n\n# }}}\n\n\n# vim: foldmethod=marker\n"},"\/test\/test_arraycontext.py":{"changes":[{"diff":"\n @with_container_arithmetic(\n         bcast_obj_array=True,\n         bcast_numpy_array=True,\n-        rel_comparison=True)\n+        rel_comparison=True,\n+        _cls_has_array_context_attr=True)\n class DOFArray:\n     def __init__(self, actx, data):\n         if not (actx is None or isinstance(actx, ArrayContext)):\n","add":2,"remove":1,"filename":"\/test\/test_arraycontext.py","badparts":["        rel_comparison=True)"],"goodparts":["        rel_comparison=True,","        _cls_has_array_context_attr=True)"]}],"source":"\n__copyright__=\"Copyright(C) 2020-21 University of Illinois Board of Trustees\" __license__=\"\"\" Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files(the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \"\"\" from dataclasses import dataclass import numpy as np import pytest from pytools.obj_array import make_obj_array from arraycontext import( ArrayContext, dataclass_array_container, with_container_arithmetic, serialize_container, deserialize_container, freeze, thaw, FirstAxisIsElementsTag) from arraycontext import( pytest_generate_tests_for_pyopencl_array_context as pytest_generate_tests, _acf) import logging logger=logging.getLogger(__name__) @with_container_arithmetic( bcast_obj_array=True, bcast_numpy_array=True, rel_comparison=True) class DOFArray: def __init__(self, actx, data): if not(actx is None or isinstance(actx, ArrayContext)): raise TypeError(\"actx must be of type ArrayContext\") if not isinstance(data, tuple): raise TypeError(\"'data' argument must be a tuple\") self.array_context=actx self.data=data __array_priority__=10 def __len__(self): return len(self.data) def __getitem__(self, i): return self.data[i] @classmethod def _serialize_init_arrays_code(cls, instance_name): return{\"_\": (f\"{instance_name}_i\", f\"{instance_name}\")} @classmethod def _deserialize_init_arrays_code(cls, template_instance_name, args): (_, arg),=args.items() return(f\"{template_instance_name}.array_context, tuple([{arg}])\") @property def real(self): return DOFArray(self.array_context, tuple([subary.real for subary in self])) @property def imag(self): return DOFArray(self.array_context, tuple([subary.imag for subary in self])) @serialize_container.register(DOFArray) def _serialize_dof_container(ary: DOFArray): return enumerate(ary.data) @deserialize_container.register(DOFArray) def _deserialize_dof_container( template, iterable): def _raise_index_inconsistency(i, stream_i): raise ValueError( \"out-of-sequence indices supplied in DOFArray deserialization \" f\"(expected{i}, received{stream_i})\") return type(template)( template.array_context, data=tuple( v if i==stream_i else _raise_index_inconsistency(i, stream_i) for i,(stream_i, v) in enumerate(iterable))) @freeze.register(DOFArray) def _freeze_dofarray(ary, actx=None): assert actx is None return type(ary)( None, tuple(ary.array_context.freeze(subary) for subary in ary.data)) @thaw.register(DOFArray) def _thaw_dofarray(ary, actx): if ary.array_context is not None: raise ValueError(\"cannot thaw DOFArray that already has an array context\") return type(ary)( actx, tuple(actx.thaw(subary) for subary in ary.data)) def assert_close_to_numpy(actx, op, args): assert np.allclose( actx.to_numpy( op(actx.np, *[ actx.from_numpy(arg) if isinstance(arg, np.ndarray) else arg for arg in args])), op(np, *args)) def assert_close_to_numpy_in_containers(actx, op, args): assert_close_to_numpy(actx, op, args) ref_result=op(np, *args) dofarray_args=[ DOFArray(actx,(actx.from_numpy(arg),)) if isinstance(arg, np.ndarray) else arg for arg in args] actx_result=actx.to_numpy(op(actx.np, *dofarray_args)[0]) assert np.allclose(actx_result, ref_result) obj_array_args=[ make_obj_array([arg]) if isinstance(arg, DOFArray) else arg for arg in dofarray_args] obj_array_result=actx.to_numpy(op(actx.np, *obj_array_args)[0][0]) assert np.allclose(obj_array_result, ref_result) @pytest.mark.parametrize((\"sym_name\", \"n_args\"),[ (\"sin\", 1), (\"exp\", 1), (\"arctan2\", 2), (\"minimum\", 2), (\"maximum\", 2), (\"where\", 3), (\"conj\", 1), ]) def test_array_context_np_workalike(actx_factory, sym_name, n_args): actx=actx_factory() ndofs=5000 args=[np.random.randn(ndofs) for i in range(n_args)] assert_close_to_numpy_in_containers( actx, lambda _np, *_args: getattr(_np, sym_name)(*_args), args) @pytest.mark.parametrize((\"sym_name\", \"n_args\"),[ (\"zeros_like\", 1), (\"ones_like\", 1), ]) def test_array_context_np_like(actx_factory, sym_name, n_args): actx=actx_factory() ndofs=5000 args=[np.random.randn(ndofs) for i in range(n_args)] assert_close_to_numpy( actx, lambda _np, *_args: getattr(_np, sym_name)(*_args), args) def test_actx_stack(actx_factory): actx=actx_factory() ndofs=5000 args=[np.random.randn(ndofs) for i in range(10)] assert_close_to_numpy_in_containers( actx, lambda _np, *_args: _np.stack(_args), args) def test_actx_concatenate(actx_factory): actx=actx_factory() ndofs=5000 args=[np.random.randn(ndofs) for i in range(10)] assert_close_to_numpy( actx, lambda _np, *_args: _np.concatenate(_args), args) def test_actx_reshape(actx_factory): actx=actx_factory() for new_shape in[(3, 2),(3, -1),(6,),(-1,)]: assert_close_to_numpy( actx, lambda _np, *_args: _np.reshape(*_args), (np.random.randn(2, 3), new_shape)) def test_dof_array_arithmetic_same_as_numpy(actx_factory): actx=actx_factory() ndofs=50_000 def get_real(ary): return ary.real def get_imag(ary): return ary.real import operator from pytools import generate_nonnegative_integer_tuples_below as gnitb from random import uniform, randrange for op_func, n_args, use_integers in[ (operator.add, 2, False), (operator.sub, 2, False), (operator.mul, 2, False), (operator.truediv, 2, False), (operator.pow, 2, False), (operator.iadd, 2, False), (operator.isub, 2, False), (operator.imul, 2, False), (operator.itruediv, 2, False), (operator.and_, 2, True), (operator.xor, 2, True), (operator.or_, 2, True), (operator.iand, 2, True), (operator.ixor, 2, True), (operator.ior, 2, True), (operator.ge, 2, False), (operator.lt, 2, False), (operator.gt, 2, False), (operator.eq, 2, True), (operator.ne, 2, True), (operator.pos, 1, False), (operator.neg, 1, False), (operator.abs, 1, False), (get_real, 1, False), (get_imag, 1, False), ]: for is_array_flags in gnitb(2, n_args): if sum(is_array_flags)==0: continue if is_array_flags[0]==0 and op_func in[ operator.iadd, operator.isub, operator.imul, operator.itruediv, operator.iand, operator.ixor, operator.ior, ]: continue args=[ (0.5+np.random.rand(ndofs) if not use_integers else np.random.randint(3, 200, ndofs)) if is_array_flag else (uniform(0.5, 2) if not use_integers else randrange(3, 200)) for is_array_flag in is_array_flags] ref_args=[ arg.copy() if isinstance(arg, np.ndarray) else arg for arg in args] ref_result=op_func(*ref_args) actx_args=[ DOFArray(actx,(actx.from_numpy(arg),)) if isinstance(arg, np.ndarray) else arg for arg in args] actx_result=actx.to_numpy(op_func(*actx_args)[0]) assert np.allclose(actx_result, ref_result) if op_func not in[ operator.eq, operator.ne, operator.le, operator.lt, operator.ge, operator.gt, operator.iadd, operator.isub, operator.imul, operator.itruediv, operator.iand, operator.ixor, operator.ior, get_imag, ]: obj_array_args=[ make_obj_array([arg]) if isinstance(arg, DOFArray) else arg for arg in actx_args] obj_array_result=actx.to_numpy( op_func(*obj_array_args)[0][0]) assert np.allclose(obj_array_result, ref_result) def test_dof_array_reductions_same_as_numpy(actx_factory): actx=actx_factory() from numbers import Number for name in[\"sum\", \"min\", \"max\"]: ary=np.random.randn(3000) np_red=getattr(np, name)(ary) actx_red=getattr(actx.np, name)(actx.from_numpy(ary)) assert isinstance(actx_red, Number) assert np.allclose(np_red, actx_red) @pytest.mark.parametrize(\"spec\",[ \"ij->ij\", \"ij->ji\", \"ii->i\", ]) def test_array_context_einsum_array_manipulation(actx_factory, spec): actx=actx_factory() mat=actx.from_numpy(np.random.randn(10, 10)) res=actx.to_numpy(actx.einsum(spec, mat, tagged=(FirstAxisIsElementsTag()))) ans=np.einsum(spec, actx.to_numpy(mat)) assert np.allclose(res, ans) @pytest.mark.parametrize(\"spec\",[ \"ij,ij->ij\", \"ij,ji->ij\", \"ij,kj->ik\", ]) def test_array_context_einsum_array_matmatprods(actx_factory, spec): actx=actx_factory() mat_a=actx.from_numpy(np.random.randn(5, 5)) mat_b=actx.from_numpy(np.random.randn(5, 5)) res=actx.to_numpy(actx.einsum(spec, mat_a, mat_b, tagged=(FirstAxisIsElementsTag()))) ans=np.einsum(spec, actx.to_numpy(mat_a), actx.to_numpy(mat_b)) assert np.allclose(res, ans) @pytest.mark.parametrize(\"spec\",[ \"im,mj,k->ijk\" ]) def test_array_context_einsum_array_tripleprod(actx_factory, spec): actx=actx_factory() mat_a=actx.from_numpy(np.random.randn(7, 5)) mat_b=actx.from_numpy(np.random.randn(5, 7)) vec=actx.from_numpy(np.random.randn(7)) res=actx.to_numpy(actx.einsum(spec, mat_a, mat_b, vec, tagged=(FirstAxisIsElementsTag()))) ans=np.einsum(spec, actx.to_numpy(mat_a), actx.to_numpy(mat_b), actx.to_numpy(vec)) assert np.allclose(res, ans) @with_container_arithmetic(bcast_obj_array=False, rel_comparison=True) @dataclass_array_container @dataclass(frozen=True) class MyContainer: name: str mass: DOFArray momentum: np.ndarray enthalpy: DOFArray @property def array_context(self): return self.mass.array_context @with_container_arithmetic( bcast_obj_array=False, bcast_container_types=(DOFArray, np.ndarray), matmul=True, rel_comparison=True,) @dataclass_array_container @dataclass(frozen=True) class MyContainerDOFBcast: name: str mass: DOFArray momentum: np.ndarray enthalpy: DOFArray @property def array_context(self): return self.mass.array_context def _get_test_containers(actx, ambient_dim=2): x=DOFArray(actx,(actx.from_numpy(np.random.randn(50_000)),)) dataclass_of_dofs=MyContainer( name=\"container\", mass=x, momentum=make_obj_array([x, x]), enthalpy=x) bcast_dataclass_of_dofs=MyContainerDOFBcast( name=\"container\", mass=x, momentum=make_obj_array([x, x]), enthalpy=x) ary_dof=x ary_of_dofs=make_obj_array([x, x, x]) mat_of_dofs=np.empty((3, 3), dtype=object) for i in np.ndindex(mat_of_dofs.shape): mat_of_dofs[i]=x return(ary_dof, ary_of_dofs, mat_of_dofs, dataclass_of_dofs, bcast_dataclass_of_dofs) def test_container_multimap(actx_factory): actx=actx_factory() ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs, bcast_dc_of_dofs=\\ _get_test_containers(actx) def _check_allclose(f, arg1, arg2, atol=1.0e-14): assert np.linalg.norm((f(arg1) -arg2).get()) < atol def func_all_scalar(x, y): return x +y def func_first_scalar(x, subary): return x +subary def func_multiple_scalar(a, subary1, b, subary2): return a * subary1 +b * subary2 from arraycontext import rec_multimap_array_container result=rec_multimap_array_container(func_all_scalar, 1, 2) assert result==3 from functools import partial for ary in[ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs]: result=rec_multimap_array_container(func_first_scalar, 1, ary) rec_multimap_array_container( partial(_check_allclose, lambda x: 1 +x), ary, result) result=rec_multimap_array_container(func_multiple_scalar, 2, ary, 2, ary) rec_multimap_array_container( partial(_check_allclose, lambda x: 4 * x), ary, result) with pytest.raises(AssertionError): rec_multimap_array_container(func_multiple_scalar, 2, ary_dof, 2, dc_of_dofs) def test_container_arithmetic(actx_factory): actx=actx_factory() ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs, bcast_dc_of_dofs=\\ _get_test_containers(actx) def _check_allclose(f, arg1, arg2, atol=1.0e-14): assert np.linalg.norm((f(arg1) -arg2).get()) < atol from functools import partial from arraycontext import rec_multimap_array_container for ary in[ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs]: rec_multimap_array_container( partial(_check_allclose, lambda x: 3 * x), ary, 2 * ary +ary) rec_multimap_array_container( partial(_check_allclose, lambda x: actx.np.sin(x)), ary, actx.np.sin(ary)) with pytest.raises(TypeError): ary_of_dofs +dc_of_dofs with pytest.raises(TypeError): dc_of_dofs +ary_of_dofs with pytest.raises(TypeError): ary_dof +dc_of_dofs with pytest.raises(TypeError): dc_of_dofs +ary_dof bcast_result=ary_dof +bcast_dc_of_dofs bcast_dc_of_dofs +ary_dof assert actx.np.linalg.norm(bcast_result.mass -2*ary_of_dofs) < 1e-8 mock_gradient=MyContainerDOFBcast( name=\"yo\", mass=ary_of_dofs, momentum=mat_of_dofs, enthalpy=ary_of_dofs) grad_matvec_result=mock_gradient @ ary_of_dofs assert isinstance(grad_matvec_result.mass, DOFArray) assert grad_matvec_result.momentum.shape==(3,) assert actx.np.linalg.norm(grad_matvec_result.mass -3*ary_of_dofs**2) < 1e-8 def test_container_freeze_thaw(actx_factory): actx=actx_factory() ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs, bcast_dc_of_dofs=\\ _get_test_containers(actx) from arraycontext import get_container_context from arraycontext import get_container_context_recursively assert get_container_context(ary_of_dofs) is None assert get_container_context(mat_of_dofs) is None assert get_container_context(ary_dof) is actx assert get_container_context(dc_of_dofs) is actx assert get_container_context_recursively(ary_of_dofs) is actx assert get_container_context_recursively(mat_of_dofs) is actx for ary in[ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs]: frozen_ary=freeze(ary) thawed_ary=thaw(frozen_ary, actx) frozen_ary=freeze(thawed_ary) assert get_container_context_recursively(frozen_ary) is None assert get_container_context_recursively(thawed_ary) is actx @pytest.mark.parametrize(\"ord\",[2, np.inf]) def test_container_norm(actx_factory, ord): actx=actx_factory() ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs, bcast_dc_of_dofs=\\ _get_test_containers(actx) from pytools.obj_array import make_obj_array c=MyContainer(name=\"hey\", mass=1, momentum=make_obj_array([2, 3]), enthalpy=5) n1=actx.np.linalg.norm(make_obj_array([c, c]), ord) n2=np.linalg.norm([1, 2, 3, 5]*2, ord) assert abs(n1 -n2) < 1e-12 def test_numpy_conversion(actx_factory): actx=actx_factory() ac=MyContainer( name=\"test_numpy_conversion\", mass=np.random.rand(42), momentum=make_obj_array([np.random.rand(42) for _ in range(3)]), enthalpy=np.random.rand(42), ) from arraycontext import from_numpy, to_numpy ac_actx=from_numpy(ac, actx) ac_roundtrip=to_numpy(ac_actx, actx) assert np.allclose(ac.mass, ac_roundtrip.mass) assert np.allclose(ac.momentum[0], ac_roundtrip.momentum[0]) from dataclasses import replace ac_with_cl=replace(ac, enthalpy=ac_actx.mass) with pytest.raises(TypeError): from_numpy(ac_with_cl, actx) with pytest.raises(TypeError): from_numpy(ac_actx, actx) with pytest.raises(ValueError): to_numpy(ac, actx) @pytest.mark.parametrize(\"norm_ord\",[2, np.inf]) def test_norm_complex(actx_factory, norm_ord): actx=actx_factory() a=np.random.randn(2000) +1j * np.random.randn(2000) norm_a_ref=np.linalg.norm(a, norm_ord) norm_a=actx.np.linalg.norm(actx.from_numpy(a), norm_ord) assert abs(norm_a_ref -norm_a)\/norm_a < 1e-13 if __name__==\"__main__\": import sys if len(sys.argv) > 1: exec(sys.argv[1]) else: from pytest import main main([__file__]) ","sourceWithComments":"__copyright__ = \"Copyright (C) 2020-21 University of Illinois Board of Trustees\"\n\n__license__ = \"\"\"\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\"\"\n\nfrom dataclasses import dataclass\nimport numpy as np\nimport pytest\n\nfrom pytools.obj_array import make_obj_array\n\nfrom arraycontext import (\n        ArrayContext,\n        dataclass_array_container, with_container_arithmetic,\n        serialize_container, deserialize_container,\n        freeze, thaw,\n        FirstAxisIsElementsTag)\nfrom arraycontext import (  # noqa: F401\n        pytest_generate_tests_for_pyopencl_array_context\n        as pytest_generate_tests,\n        _acf)\n\nimport logging\nlogger = logging.getLogger(__name__)\n\n\n# {{{ stand-in DOFArray implementation\n\n@with_container_arithmetic(\n        bcast_obj_array=True,\n        bcast_numpy_array=True,\n        rel_comparison=True)\nclass DOFArray:\n    def __init__(self, actx, data):\n        if not (actx is None or isinstance(actx, ArrayContext)):\n            raise TypeError(\"actx must be of type ArrayContext\")\n\n        if not isinstance(data, tuple):\n            raise TypeError(\"'data' argument must be a tuple\")\n\n        self.array_context = actx\n        self.data = data\n\n    __array_priority__ = 10\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, i):\n        return self.data[i]\n\n    @classmethod\n    def _serialize_init_arrays_code(cls, instance_name):\n        return {\"_\":\n                (f\"{instance_name}_i\", f\"{instance_name}\")}\n\n    @classmethod\n    def _deserialize_init_arrays_code(cls, template_instance_name, args):\n        (_, arg), = args.items()\n        # Why tuple([...])? https:\/\/stackoverflow.com\/a\/48592299\n        return (f\"{template_instance_name}.array_context, tuple([{arg}])\")\n\n    @property\n    def real(self):\n        return DOFArray(self.array_context, tuple([subary.real for subary in self]))\n\n    @property\n    def imag(self):\n        return DOFArray(self.array_context, tuple([subary.imag for subary in self]))\n\n\n@serialize_container.register(DOFArray)\ndef _serialize_dof_container(ary: DOFArray):\n    return enumerate(ary.data)\n\n\n@deserialize_container.register(DOFArray)\ndef _deserialize_dof_container(\n        template, iterable):\n    def _raise_index_inconsistency(i, stream_i):\n        raise ValueError(\n                \"out-of-sequence indices supplied in DOFArray deserialization \"\n                f\"(expected {i}, received {stream_i})\")\n\n    return type(template)(\n            template.array_context,\n            data=tuple(\n                v if i == stream_i else _raise_index_inconsistency(i, stream_i)\n                for i, (stream_i, v) in enumerate(iterable)))\n\n\n@freeze.register(DOFArray)\ndef _freeze_dofarray(ary, actx=None):\n    assert actx is None\n    return type(ary)(\n        None,\n        tuple(ary.array_context.freeze(subary) for subary in ary.data))\n\n\n@thaw.register(DOFArray)\ndef _thaw_dofarray(ary, actx):\n    if ary.array_context is not None:\n        raise ValueError(\"cannot thaw DOFArray that already has an array context\")\n\n    return type(ary)(\n        actx,\n        tuple(actx.thaw(subary) for subary in ary.data))\n\n# }}}\n\n\n# {{{ assert_close_to_numpy*\n\ndef assert_close_to_numpy(actx, op, args):\n    assert np.allclose(\n            actx.to_numpy(\n                op(actx.np, *[\n                    actx.from_numpy(arg) if isinstance(arg, np.ndarray) else arg\n                    for arg in args])),\n            op(np, *args))\n\n\ndef assert_close_to_numpy_in_containers(actx, op, args):\n    assert_close_to_numpy(actx, op, args)\n\n    ref_result = op(np, *args)\n\n    # {{{ test DOFArrays\n\n    dofarray_args = [\n            DOFArray(actx, (actx.from_numpy(arg),))\n            if isinstance(arg, np.ndarray) else arg\n            for arg in args]\n    actx_result = actx.to_numpy(op(actx.np, *dofarray_args)[0])\n\n    assert np.allclose(actx_result, ref_result)\n\n    # }}}\n\n    # {{{ test object arrays of DOFArrays\n\n    obj_array_args = [\n            make_obj_array([arg]) if isinstance(arg, DOFArray) else arg\n            for arg in dofarray_args]\n    obj_array_result = actx.to_numpy(op(actx.np, *obj_array_args)[0][0])\n\n    assert np.allclose(obj_array_result, ref_result)\n\n    # }}}\n\n# }}}\n\n\n# {{{ np.function same as numpy\n\n@pytest.mark.parametrize((\"sym_name\", \"n_args\"), [\n            (\"sin\", 1),\n            (\"exp\", 1),\n            (\"arctan2\", 2),\n            (\"minimum\", 2),\n            (\"maximum\", 2),\n            (\"where\", 3),\n            (\"conj\", 1),\n            ])\ndef test_array_context_np_workalike(actx_factory, sym_name, n_args):\n    actx = actx_factory()\n\n    ndofs = 5000\n    args = [np.random.randn(ndofs) for i in range(n_args)]\n    assert_close_to_numpy_in_containers(\n            actx, lambda _np, *_args: getattr(_np, sym_name)(*_args), args)\n\n\n@pytest.mark.parametrize((\"sym_name\", \"n_args\"), [\n            # (\"empty_like\", 1),    # NOTE: fails np.allclose, obviously\n            (\"zeros_like\", 1),\n            (\"ones_like\", 1),\n            ])\ndef test_array_context_np_like(actx_factory, sym_name, n_args):\n    actx = actx_factory()\n\n    ndofs = 5000\n    args = [np.random.randn(ndofs) for i in range(n_args)]\n    assert_close_to_numpy(\n            actx, lambda _np, *_args: getattr(_np, sym_name)(*_args), args)\n\n# }}}\n\n\n# {{{ array manipulations\n\ndef test_actx_stack(actx_factory):\n    actx = actx_factory()\n\n    ndofs = 5000\n    args = [np.random.randn(ndofs) for i in range(10)]\n\n    assert_close_to_numpy_in_containers(\n            actx, lambda _np, *_args: _np.stack(_args), args)\n\n\ndef test_actx_concatenate(actx_factory):\n    actx = actx_factory()\n\n    ndofs = 5000\n    args = [np.random.randn(ndofs) for i in range(10)]\n\n    assert_close_to_numpy(\n            actx, lambda _np, *_args: _np.concatenate(_args), args)\n\n\ndef test_actx_reshape(actx_factory):\n    actx = actx_factory()\n\n    for new_shape in [(3, 2), (3, -1), (6,), (-1,)]:\n        assert_close_to_numpy(\n                actx, lambda _np, *_args: _np.reshape(*_args),\n                (np.random.randn(2, 3), new_shape))\n\n# }}}\n\n\n# {{{ arithmetic same as numpy\n\ndef test_dof_array_arithmetic_same_as_numpy(actx_factory):\n    actx = actx_factory()\n\n    ndofs = 50_000\n\n    def get_real(ary):\n        return ary.real\n\n    def get_imag(ary):\n        return ary.real\n\n    import operator\n    from pytools import generate_nonnegative_integer_tuples_below as gnitb\n    from random import uniform, randrange\n    for op_func, n_args, use_integers in [\n            (operator.add, 2, False),\n            (operator.sub, 2, False),\n            (operator.mul, 2, False),\n            (operator.truediv, 2, False),\n            (operator.pow, 2, False),\n            # FIXME pyopencl.Array doesn't do mod.\n            #(operator.mod, 2, True),\n            #(operator.mod, 2, False),\n            #(operator.imod, 2, True),\n            #(operator.imod, 2, False),\n            # FIXME: Two outputs\n            #(divmod, 2, False),\n\n            (operator.iadd, 2, False),\n            (operator.isub, 2, False),\n            (operator.imul, 2, False),\n            (operator.itruediv, 2, False),\n\n            (operator.and_, 2, True),\n            (operator.xor, 2, True),\n            (operator.or_, 2, True),\n\n            (operator.iand, 2, True),\n            (operator.ixor, 2, True),\n            (operator.ior, 2, True),\n\n            (operator.ge, 2, False),\n            (operator.lt, 2, False),\n            (operator.gt, 2, False),\n            (operator.eq, 2, True),\n            (operator.ne, 2, True),\n\n            (operator.pos, 1, False),\n            (operator.neg, 1, False),\n            (operator.abs, 1, False),\n\n            (get_real, 1, False),\n            (get_imag, 1, False),\n            ]:\n        for is_array_flags in gnitb(2, n_args):\n            if sum(is_array_flags) == 0:\n                # all scalars, no need to test\n                continue\n\n            if is_array_flags[0] == 0 and op_func in [\n                    operator.iadd, operator.isub,\n                    operator.imul, operator.itruediv,\n                    operator.iand, operator.ixor, operator.ior,\n                    ]:\n                # can't do in place operations with a scalar lhs\n                continue\n\n            args = [\n                    (0.5+np.random.rand(ndofs)\n                        if not use_integers else\n                        np.random.randint(3, 200, ndofs))\n\n                    if is_array_flag else\n                    (uniform(0.5, 2)\n                        if not use_integers\n                        else randrange(3, 200))\n                    for is_array_flag in is_array_flags]\n\n            # {{{ get reference numpy result\n\n            # make a copy for the in place operators\n            ref_args = [\n                    arg.copy() if isinstance(arg, np.ndarray) else arg\n                    for arg in args]\n            ref_result = op_func(*ref_args)\n\n            # }}}\n\n            # {{{ test DOFArrays\n\n            actx_args = [\n                    DOFArray(actx, (actx.from_numpy(arg),))\n                    if isinstance(arg, np.ndarray) else arg\n                    for arg in args]\n\n            actx_result = actx.to_numpy(op_func(*actx_args)[0])\n\n            assert np.allclose(actx_result, ref_result)\n\n            # }}}\n\n            # {{{ test object arrays of DOFArrays\n\n            # It would be very nice if comparisons on object arrays behaved\n            # consistently with everything else. Alas, they do not. Instead:\n            #\n            # 0.5 < obj_array(DOFArray) -> obj_array([True])\n            #\n            # because hey, 0.5 < DOFArray returned something truthy.\n\n            if op_func not in [\n                    operator.eq, operator.ne,\n                    operator.le, operator.lt,\n                    operator.ge, operator.gt,\n\n                    operator.iadd, operator.isub,\n                    operator.imul, operator.itruediv,\n                    operator.iand, operator.ixor, operator.ior,\n\n                    # All Python objects are real-valued, right?\n                    get_imag,\n                    ]:\n                obj_array_args = [\n                        make_obj_array([arg]) if isinstance(arg, DOFArray) else arg\n                        for arg in actx_args]\n\n                obj_array_result = actx.to_numpy(\n                        op_func(*obj_array_args)[0][0])\n\n                assert np.allclose(obj_array_result, ref_result)\n\n            # }}}\n\n# }}}\n\n\n# {{{ reductions same as numpy\n\ndef test_dof_array_reductions_same_as_numpy(actx_factory):\n    actx = actx_factory()\n\n    from numbers import Number\n    for name in [\"sum\", \"min\", \"max\"]:\n        ary = np.random.randn(3000)\n        np_red = getattr(np, name)(ary)\n        actx_red = getattr(actx.np, name)(actx.from_numpy(ary))\n\n        assert isinstance(actx_red, Number)\n        assert np.allclose(np_red, actx_red)\n\n# }}}\n\n\n# {{{ test array context einsum\n\n@pytest.mark.parametrize(\"spec\", [\n    \"ij->ij\",\n    \"ij->ji\",\n    \"ii->i\",\n])\ndef test_array_context_einsum_array_manipulation(actx_factory, spec):\n    actx = actx_factory()\n\n    mat = actx.from_numpy(np.random.randn(10, 10))\n    res = actx.to_numpy(actx.einsum(spec, mat,\n                                    tagged=(FirstAxisIsElementsTag())))\n    ans = np.einsum(spec, actx.to_numpy(mat))\n    assert np.allclose(res, ans)\n\n\n@pytest.mark.parametrize(\"spec\", [\n    \"ij,ij->ij\",\n    \"ij,ji->ij\",\n    \"ij,kj->ik\",\n])\ndef test_array_context_einsum_array_matmatprods(actx_factory, spec):\n    actx = actx_factory()\n\n    mat_a = actx.from_numpy(np.random.randn(5, 5))\n    mat_b = actx.from_numpy(np.random.randn(5, 5))\n    res = actx.to_numpy(actx.einsum(spec, mat_a, mat_b,\n                                    tagged=(FirstAxisIsElementsTag())))\n    ans = np.einsum(spec, actx.to_numpy(mat_a), actx.to_numpy(mat_b))\n    assert np.allclose(res, ans)\n\n\n@pytest.mark.parametrize(\"spec\", [\n    \"im,mj,k->ijk\"\n])\ndef test_array_context_einsum_array_tripleprod(actx_factory, spec):\n    actx = actx_factory()\n\n    mat_a = actx.from_numpy(np.random.randn(7, 5))\n    mat_b = actx.from_numpy(np.random.randn(5, 7))\n    vec = actx.from_numpy(np.random.randn(7))\n    res = actx.to_numpy(actx.einsum(spec, mat_a, mat_b, vec,\n                                    tagged=(FirstAxisIsElementsTag())))\n    ans = np.einsum(spec,\n                    actx.to_numpy(mat_a),\n                    actx.to_numpy(mat_b),\n                    actx.to_numpy(vec))\n    assert np.allclose(res, ans)\n\n# }}}\n\n\n# {{{ test array container\n\n@with_container_arithmetic(bcast_obj_array=False, rel_comparison=True)\n@dataclass_array_container\n@dataclass(frozen=True)\nclass MyContainer:\n    name: str\n    mass: DOFArray\n    momentum: np.ndarray\n    enthalpy: DOFArray\n\n    @property\n    def array_context(self):\n        return self.mass.array_context\n\n\n@with_container_arithmetic(\n        bcast_obj_array=False,\n        bcast_container_types=(DOFArray, np.ndarray),\n        matmul=True,\n        rel_comparison=True,)\n@dataclass_array_container\n@dataclass(frozen=True)\nclass MyContainerDOFBcast:\n    name: str\n    mass: DOFArray\n    momentum: np.ndarray\n    enthalpy: DOFArray\n\n    @property\n    def array_context(self):\n        return self.mass.array_context\n\n\ndef _get_test_containers(actx, ambient_dim=2):\n    x = DOFArray(actx, (actx.from_numpy(np.random.randn(50_000)),))\n\n    # pylint: disable=unexpected-keyword-arg, no-value-for-parameter\n    dataclass_of_dofs = MyContainer(\n            name=\"container\",\n            mass=x,\n            momentum=make_obj_array([x, x]),\n            enthalpy=x)\n\n    # pylint: disable=unexpected-keyword-arg, no-value-for-parameter\n    bcast_dataclass_of_dofs = MyContainerDOFBcast(\n            name=\"container\",\n            mass=x,\n            momentum=make_obj_array([x, x]),\n            enthalpy=x)\n\n    ary_dof = x\n    ary_of_dofs = make_obj_array([x, x, x])\n    mat_of_dofs = np.empty((3, 3), dtype=object)\n    for i in np.ndindex(mat_of_dofs.shape):\n        mat_of_dofs[i] = x\n\n    return (ary_dof, ary_of_dofs, mat_of_dofs, dataclass_of_dofs,\n            bcast_dataclass_of_dofs)\n\n\ndef test_container_multimap(actx_factory):\n    actx = actx_factory()\n    ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs, bcast_dc_of_dofs = \\\n            _get_test_containers(actx)\n\n    # {{{ check\n\n    def _check_allclose(f, arg1, arg2, atol=1.0e-14):\n        assert np.linalg.norm((f(arg1) - arg2).get()) < atol\n\n    def func_all_scalar(x, y):\n        return x + y\n\n    def func_first_scalar(x, subary):\n        return x + subary\n\n    def func_multiple_scalar(a, subary1, b, subary2):\n        return a * subary1 + b * subary2\n\n    from arraycontext import rec_multimap_array_container\n    result = rec_multimap_array_container(func_all_scalar, 1, 2)\n    assert result == 3\n\n    from functools import partial\n    for ary in [ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs]:\n        result = rec_multimap_array_container(func_first_scalar, 1, ary)\n        rec_multimap_array_container(\n                partial(_check_allclose, lambda x: 1 + x),\n                ary, result)\n\n        result = rec_multimap_array_container(func_multiple_scalar, 2, ary, 2, ary)\n        rec_multimap_array_container(\n                partial(_check_allclose, lambda x: 4 * x),\n                ary, result)\n\n    with pytest.raises(AssertionError):\n        rec_multimap_array_container(func_multiple_scalar, 2, ary_dof, 2, dc_of_dofs)\n\n    # }}}\n\n\ndef test_container_arithmetic(actx_factory):\n    actx = actx_factory()\n    ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs, bcast_dc_of_dofs = \\\n            _get_test_containers(actx)\n\n    # {{{ check\n\n    def _check_allclose(f, arg1, arg2, atol=1.0e-14):\n        assert np.linalg.norm((f(arg1) - arg2).get()) < atol\n\n    from functools import partial\n    from arraycontext import rec_multimap_array_container\n    for ary in [ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs]:\n        rec_multimap_array_container(\n                partial(_check_allclose, lambda x: 3 * x),\n                ary, 2 * ary + ary)\n        rec_multimap_array_container(\n                partial(_check_allclose, lambda x: actx.np.sin(x)),\n                ary, actx.np.sin(ary))\n\n    with pytest.raises(TypeError):\n        ary_of_dofs + dc_of_dofs\n\n    with pytest.raises(TypeError):\n        dc_of_dofs + ary_of_dofs\n\n    with pytest.raises(TypeError):\n        ary_dof + dc_of_dofs\n\n    with pytest.raises(TypeError):\n        dc_of_dofs + ary_dof\n\n    bcast_result = ary_dof + bcast_dc_of_dofs\n    bcast_dc_of_dofs + ary_dof\n\n    assert actx.np.linalg.norm(bcast_result.mass - 2*ary_of_dofs) < 1e-8\n\n    mock_gradient = MyContainerDOFBcast(\n            name=\"yo\",\n            mass=ary_of_dofs,\n            momentum=mat_of_dofs,\n            enthalpy=ary_of_dofs)\n\n    grad_matvec_result = mock_gradient @ ary_of_dofs\n    assert isinstance(grad_matvec_result.mass, DOFArray)\n    assert grad_matvec_result.momentum.shape == (3,)\n    assert actx.np.linalg.norm(grad_matvec_result.mass - 3*ary_of_dofs**2) < 1e-8\n\n    # }}}\n\n\ndef test_container_freeze_thaw(actx_factory):\n    actx = actx_factory()\n    ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs, bcast_dc_of_dofs = \\\n            _get_test_containers(actx)\n\n    # {{{ check\n\n    from arraycontext import get_container_context\n    from arraycontext import get_container_context_recursively\n\n    assert get_container_context(ary_of_dofs) is None\n    assert get_container_context(mat_of_dofs) is None\n    assert get_container_context(ary_dof) is actx\n    assert get_container_context(dc_of_dofs) is actx\n\n    assert get_container_context_recursively(ary_of_dofs) is actx\n    assert get_container_context_recursively(mat_of_dofs) is actx\n\n    for ary in [ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs]:\n        frozen_ary = freeze(ary)\n        thawed_ary = thaw(frozen_ary, actx)\n        frozen_ary = freeze(thawed_ary)\n\n        assert get_container_context_recursively(frozen_ary) is None\n        assert get_container_context_recursively(thawed_ary) is actx\n\n    # }}}\n\n\n@pytest.mark.parametrize(\"ord\", [2, np.inf])\ndef test_container_norm(actx_factory, ord):\n    actx = actx_factory()\n\n    ary_dof, ary_of_dofs, mat_of_dofs, dc_of_dofs, bcast_dc_of_dofs = \\\n            _get_test_containers(actx)\n\n    from pytools.obj_array import make_obj_array\n    c = MyContainer(name=\"hey\", mass=1, momentum=make_obj_array([2, 3]), enthalpy=5)\n    n1 = actx.np.linalg.norm(make_obj_array([c, c]), ord)\n    n2 = np.linalg.norm([1, 2, 3, 5]*2, ord)\n\n    assert abs(n1 - n2) < 1e-12\n\n# }}}\n\n\n# {{{ test from_numpy and to_numpy\n\ndef test_numpy_conversion(actx_factory):\n    actx = actx_factory()\n\n    ac = MyContainer(\n            name=\"test_numpy_conversion\",\n            mass=np.random.rand(42),\n            momentum=make_obj_array([np.random.rand(42) for _ in range(3)]),\n            enthalpy=np.random.rand(42),\n            )\n\n    from arraycontext import from_numpy, to_numpy\n    ac_actx = from_numpy(ac, actx)\n    ac_roundtrip = to_numpy(ac_actx, actx)\n\n    assert np.allclose(ac.mass, ac_roundtrip.mass)\n    assert np.allclose(ac.momentum[0], ac_roundtrip.momentum[0])\n\n    from dataclasses import replace\n    ac_with_cl = replace(ac, enthalpy=ac_actx.mass)\n    with pytest.raises(TypeError):\n        from_numpy(ac_with_cl, actx)\n\n    with pytest.raises(TypeError):\n        from_numpy(ac_actx, actx)\n\n    with pytest.raises(ValueError):\n        to_numpy(ac, actx)\n\n# }}}\n\n\n@pytest.mark.parametrize(\"norm_ord\", [2, np.inf])\ndef test_norm_complex(actx_factory, norm_ord):\n    actx = actx_factory()\n    a = np.random.randn(2000) + 1j * np.random.randn(2000)\n\n    norm_a_ref = np.linalg.norm(a, norm_ord)\n    norm_a = actx.np.linalg.norm(actx.from_numpy(a), norm_ord)\n\n    assert abs(norm_a_ref - norm_a)\/norm_a < 1e-13\n\n\nif __name__ == \"__main__\":\n    import sys\n    if len(sys.argv) > 1:\n        exec(sys.argv[1])\n    else:\n        from pytest import main\n        main([__file__])\n\n# vim: fdm=marker\n"}},"msg":"Improve freeze\/thaw usability (#22)\n\n* Add a longer explainer on freeze and thaw\r\n\r\n* Add ArrayContext.clone\r\n\r\n* with_container_arithmetic: Add _same_cls_check\r\n\r\n* Add test for error-on-mixed-array-contexts\r\n\r\n* Improvements\/fixes to freeze\/thaw explainer\r\n\r\nCo-authored-by: Alex Fikl <alexfikl@gmail.com>\r\n\r\n* Remove trailing whitespace (flake8)\r\n\r\n* Add link to lazy eval functionality under the hood of freeze\/thaw\r\n\r\n* Stop using code injection for actx match checking in with_container_arithmetic\r\n\r\n* Make usage guidelines for freeze\/thaw a separate section\r\n\r\nCo-authored-by: Thomas H. Gibson <gibsonthomas1120@hotmail.com>\r\n\r\n* Tweak phrasing in freeze\/thaw usage guidelines, add anchors\r\n\r\n* Remove an extraneous word in the freeze\/thaw description\r\n\r\nCo-authored-by: Alex Fikl <alexfikl@gmail.com>\r\nCo-authored-by: Thomas H. Gibson <gibsonthomas1120@hotmail.com>"}},"https:\/\/github.com\/opensvc\/opensvc":{"ff4b85060f501d2eafe19df2144389ce69e54a0a":{"url":"https:\/\/api.github.com\/repos\/opensvc\/opensvc\/commits\/ff4b85060f501d2eafe19df2144389ce69e54a0a","html_url":"https:\/\/github.com\/opensvc\/opensvc\/commit\/ff4b85060f501d2eafe19df2144389ce69e54a0a","message":"Remove uneeded variable value check in compliance framework\n\nThe agent suppressed the variable values containing `$;\ncharacters to protect against code injection.\n\nActually the code injection risk is limited to modules\ndoing an 'eval' on the variable values ... which is users'\nresponsability.\n\nRemove this suppression logic to allow more values.","sha":"ff4b85060f501d2eafe19df2144389ce69e54a0a","keyword":"eval injection protect","diff":"diff --git a\/lib\/compliance.py b\/lib\/compliance.py\nindex 85f4ac07b7..9d206525ca 100644\n--- a\/lib\/compliance.py\n+++ b\/lib\/compliance.py\n@@ -294,11 +294,6 @@ def format_rule_val(self, val):\n             val = repr(val).strip(\"'\")\n         else:\n             val = str(val)\n-        illegal_chars = \"\"\"`;$\"\"\"\n-        for c in illegal_chars:\n-            if c in val:\n-                print \"illegal char %s in variable value: %s\"%(c,val)\n-                return \"suppressed\"\n         return val\n \n     def setup_env(self):\n","files":{"\/lib\/compliance.py":{"changes":[{"diff":"\n             val = repr(val).strip(\"'\")\n         else:\n             val = str(val)\n-        illegal_chars = \"\"\"`;$\"\"\"\n-        for c in illegal_chars:\n-            if c in val:\n-                print \"illegal char %s in variable value: %s\"%(c,val)\n-                return \"suppressed\"\n         return val\n \n     def setup_env(self):\n","add":0,"remove":5,"filename":"\/lib\/compliance.py","badparts":["        illegal_chars = \"\"\"`;$\"\"\"","        for c in illegal_chars:","            if c in val:","                print \"illegal char %s in variable value: %s\"%(c,val)","                return \"suppressed\""],"goodparts":[]}],"source":"\nfrom stat import * import os import sys import re import datetime import rcExceptions as ex from rcGlobalEnv import rcEnv from rcUtilities import is_exe, justcall, banner from subprocess import * from rcPrintTable import print_table comp_dir=os.path.join(rcEnv.pathvar, 'compliance') regex=re.compile(\"\\x1b\\[([0-9]{1,3}(;[0-9]{1,3})*)?[m|K|G]\", re.UNICODE) class Module(object): pattern='^S*[0-9]+-*%(name)s$' def __init__(self, name): self.name=name self.executable=None dl=os.listdir(comp_dir) match=[] for e in dl: if re.match(self.pattern%dict(name=name), e) is not None: match.append(e) if len(match)==0: raise ex.excInitError('module %s not found in %s'%(name, comp_dir)) if len(match) > 1: raise ex.excError('module %s matches too many entries in %s'%(name, comp_dir)) base=match[0] if base[0]=='S': base==base[1:] for i, c in enumerate(base): if not c.isdigit(): break self.ordering=int(base[0:i]) regex2=re.compile(\"^S*[0-9]+-*\", re.UNICODE) self.name=regex2.sub(\"\", match[0]) locations=[] locations.append(os.path.join(comp_dir, match[0])) locations.append(os.path.join(locations[0], 'main')) locations.append(os.path.join(locations[0], 'scripts', 'main')) for loc in locations: if not os.path.exists(loc): continue statinfo=os.stat(loc) mode=statinfo[ST_MODE] if statinfo.st_uid !=0 or statinfo.st_gid not in(0,2,3,4): raise ex.excError('%s is not owned by root. security hazard.'%(loc)) if not S_ISREG(mode): continue if not is_exe(loc): mode |=S_IXUSR os.chmod(loc, mode) self.executable=loc if self.executable is None: raise ex.excError('executable not found for module %s'%(name)) def __str__(self): a=[] a.append(\"name: %s\"%self.name) a.append(\"ordering: %d\"%self.ordering) a.append(\"executable: %s\"%self.executable) return '\\n'.join(a) def strip_unprintable(self, s): return regex.sub('', s) def log_action(self, out, ret, action): ruleset=','.join(self.ruleset) vars=['run_nodename', 'run_module', 'run_status', 'run_log', 'run_ruleset', 'run_action', 'rset_md5'] vals=[rcEnv.nodename, self.name, str(ret), self.strip_unprintable(out), ruleset, action, self.rset_md5] if self.svcname is not None: vars.append('run_svcname') vals.append(self.svcname) self.collector.call('comp_log_action', vars, vals, sync=False) def action(self, action): print banner(self.name) if action not in['check', 'fix', 'fixable']: print 'action %s not supported' return 1 if self.options.force: return self.do_action(action) if action=='fix': if self.do_action('check')==0: print 'check passed, skip fix' return 0 if self.do_action('fixable') not in(0, 2): print 'not fixable, skip fix' return 1 self.do_action('fix') r=self.do_action('check') elif action=='check': r=self.do_action('check') if r==1: self.do_action('fixable') elif action=='fixable': r=self.do_action('fixable') return r def do_action(self, action): start=datetime.datetime.now() cmd=[self.executable, action] log='' print \"ACTION: %s\"%action print \"START: %s\"%str(start) print \"COMMAND: %s\"%' '.join(cmd) print \"LOG:\" import tempfile import time fo=tempfile.NamedTemporaryFile() fe=tempfile.NamedTemporaryFile() _fo=None _fe=None def poll_out(): fop=_fo.tell() line=_fo.readline() if not line: _fo.seek(fop) return None sys.stdout.write(line) sys.stdout.flush() return line def poll_err(): fep=_fe.tell() line=_fe.readline() if not line: _fe.seek(fep) return None line='ERR: '+line sys.stdout.write(line) sys.stdout.flush() return line def poll_pipes(log): i=0 while True: o=poll_out() e=poll_err() if o is not None: log +=o if e is not None: log +=e if o is None and e is None: break return log try: p=Popen(cmd, stdout=fo, stderr=fe) _fo=open(fo.name, 'r') _fe=open(fe.name, 'r') while True: time.sleep(0.1) log=poll_pipes(log) if p.poll() !=None: log=poll_pipes(log) break except OSError, e: if _fo is not None: _fo.close() if _fe is not None: _fe.close() fo.close() fe.close() if e.errno==2: raise ex.excError(\"%s execution error(File not found or bad interpreter)\"%self.executable) elif e.errno==8: raise ex.excError(\"%s execution error(Exec format error)\"%self.executable) else: raise fo.close() fe.close() _fo.close() _fe.close() end=datetime.datetime.now() print \"RCODE: %d\"%p.returncode print \"DURATION: %s\"%str(end-start) self.log_action(log, p.returncode, action) return p.returncode def check(self): return self.action('check') def fix(self): return self.action('fix') def fixable(self): return self.action('fixable') class Compliance(object): def __init__(self, skip_action=None, options=None, collector=None, svcname=None): self.skip_action=skip_action self.options=options self.collector=collector self.svcname=svcname self.options=options self.module_o={} self.module=[] def compliance_check(self): flag=\"last_comp_check\" if self.svcname is not None: flag='.'.join((flag, self.svcname)) if self.skip_action is not None and \\ self.skip_action(\"compliance\", 'comp_check_interval', flag, period_option='comp_check_period', days_option='comp_check_days'): return self.do_checks() def __iadd__(self, o): self.module_o[o.name]=o o.svcname=self.svcname o.ruleset=self.ruleset o.options=self.options o.collector=self.collector o.rset_md5=self.rset_md5 return self def set_rset_md5(self): self.rset_md5=\"\" if 'OSVC_COMP_RULESET_MD5' in os.environ: self.rset_md5=os.environ['OSVC_COMP_RULESET_MD5'] def init(self): if self.options.moduleset !=\"\" and self.options.module !=\"\": raise ex.excError('--moduleset and --module are exclusive') if self.options.moduleset==\"\" and self.options.module==\"\": self.moduleset=self.get_moduleset() else: self.moduleset=self.options.moduleset.split(',') self.module=self.options.module.split(',') if len(self.moduleset) > 0 and hasattr(self.options, \"attach\") and self.options.attach: self._compliance_attach_moduleset(self.moduleset) self.module=self.merge_moduleset_modules() self.ruleset=self.get_ruleset() self.setup_env() self.set_rset_md5() if not os.path.exists(comp_dir): os.makedirs(comp_dir, 0755) raise ex.excError('modules[%s] are not present in %s'%( ','.join(self.module), comp_dir)) for module in self.module: try: self +=Module(module) except ex.excInitError, e: print >>sys.stderr, e self.ordered_module=self.module_o.keys() self.ordered_module.sort(lambda x, y: cmp(self.module_o[x].ordering, self.module_o[y].ordering)) def __str__(self): print banner('run context') a=[] a.append('modules:') for m in self.ordered_module: a.append(' %0.2d %s'%(self.module_o[m].ordering, m)) a.append(self.str_ruleset()) return '\\n'.join(a) def format_rule_var(self, var): var=var.upper().replace('-', '_').replace(' ', '_').replace('.','_') var='_'.join(('OSVC_COMP', var)) return var def format_rule_val(self, val): if isinstance(val, unicode): val=repr(val).strip(\"'\") else: val=str(val) illegal_chars=\"\"\"`;$\"\"\" for c in illegal_chars: if c in val: print \"illegal char %s in variable value: %s\"%(c,val) return \"suppressed\" return val def setup_env(self): for rule in self.ruleset.values(): for var, val in rule['vars']: os.environ[self.format_rule_var(var)]=self.format_rule_val(val) def get_moduleset(self): if self.svcname is not None: moduleset=self.collector.call('comp_get_svc_moduleset', self.svcname) else: moduleset=self.collector.call('comp_get_moduleset') if moduleset is None: raise ex.excError('could not fetch moduleset') return moduleset def get_ruleset(self): if hasattr(self.options, 'ruleset') and \\ len(self.options.ruleset) > 0: return self.get_ruleset_md5(self.options.ruleset) return self.get_current_ruleset() def get_current_ruleset(self): if self.svcname is not None: ruleset=self.collector.call('comp_get_svc_ruleset', self.svcname) else: ruleset=self.collector.call('comp_get_ruleset') if ruleset is None: raise ex.excError('could not fetch ruleset') return ruleset def get_ruleset_md5(self, rset_md5): ruleset=self.collector.call('comp_get_ruleset_md5', rset_md5) if ruleset is None: raise ex.excError('could not fetch ruleset') return ruleset def str_ruleset(self): a=[] a.append('rules:') for rule in self.ruleset.values(): if len(rule['filter'])==0: a.append(' %s'%rule['name']) else: a.append(' %s(%s)'%(rule['name'],rule['filter'])) for var, val in rule['vars']: val=self.format_rule_val(val) if ' ' in val: val=repr(val) a.append(' %s=%s'%(self.format_rule_var(var), val)) return '\\n'.join(a) def merge_moduleset_modules(self): modules=self.get_moduleset_modules(self.moduleset) return set(self.module +modules) -set(['']) def get_moduleset_modules(self, m): moduleset=self.collector.call('comp_get_moduleset_modules', m) if moduleset is None: raise ex.excError('could not expand moduleset modules') return moduleset def digest_errors(self, err): passed=[m for m in err if err[m]==0] errors=[m for m in err if err[m]==1] na=[m for m in err if err[m]==2] n_passed=len(passed) n_errors=len(errors) n_na=len(na) def _s(n): if n > 1: return 's' else: return '' def modules(l): if len(l)==0: return '' return '\\n%s'%'\\n'.join(map(lambda x: ' '+x, l)) print banner(\"digest\") print \"%d n\/a%s\"%(n_na, modules(na)) print \"%d passed%s\"%(n_passed, modules(passed)) print \"%d error%s%s\"%(n_errors, _s(n_errors), modules(errors)) if len(errors) > 0: return 1 return 0 def compliance_show_moduleset(self): self.moduleset=self.get_moduleset() for ms in self.moduleset: print ms+':' for m in self.get_moduleset_modules(ms): print ' %s'%m def compliance_show_ruleset(self): self.ruleset=self.get_ruleset() self.setup_env() print self.str_ruleset() def do_run(self, action): err={} self.init() start=datetime.datetime.now() for module in self.ordered_module: err[module]=getattr(self.module_o[module], action)() r=self.digest_errors(err) end=datetime.datetime.now() print \"total duration: %s\"%str(end-start) return r def do_checks(self): return self.do_run('check') def compliance_fix(self): return self.do_run('fix') def compliance_fixable(self): return self.do_run('fixable') def compliance_attach_moduleset(self): if not hasattr(self.options, 'moduleset') or \\ len(self.options.moduleset)==0: raise ex.excError('no moduleset specified. use --moduleset') self._compliance_attach_moduleset(self.options.moduleset.split(',')) def _compliance_attach_moduleset(self, modulesets): err=False for moduleset in modulesets: if self.svcname is not None: d=self.collector.call('comp_attach_svc_moduleset', self.svcname, moduleset) else: d=self.collector.call('comp_attach_moduleset', moduleset) if not d['status']: err=True print d['msg'] if err: raise ex.excError() def compliance_detach_moduleset(self): if not hasattr(self.options, 'moduleset') or \\ len(self.options.moduleset)==0: raise ex.excError('no moduleset specified. use --moduleset') err=False for moduleset in self.options.moduleset.split(','): if self.svcname is not None: d=self.collector.call('comp_detach_svc_moduleset', self.svcname, moduleset) else: d=self.collector.call('comp_detach_moduleset', moduleset) if not d['status']: err=True print d['msg'] if err: raise ex.excError() def compliance_attach_ruleset(self): if not hasattr(self.options, 'ruleset') or \\ len(self.options.ruleset)==0: raise ex.excError('no ruleset specified. use --ruleset') err=False for ruleset in self.options.ruleset.split(','): if self.svcname is not None: d=self.collector.call('comp_attach_svc_ruleset', self.svcname, ruleset) else: d=self.collector.call('comp_attach_ruleset', ruleset) if not d['status']: err=True print d['msg'] if err: raise ex.excError() def compliance_detach_ruleset(self): if not hasattr(self.options, 'ruleset') or \\ len(self.options.ruleset)==0: raise ex.excError('no ruleset specified. use --ruleset') err=False for ruleset in self.options.ruleset.split(','): if self.svcname is not None: d=self.collector.call('comp_detach_svc_ruleset', self.svcname, ruleset) else: d=self.collector.call('comp_detach_ruleset', ruleset) if not d['status']: err=True print d['msg'] if err: raise ex.excError() def compliance_show_status(self): args=['comp_show_status'] if self.svcname is None: args.append('') else: args.append(self.svcname) if hasattr(self.options, 'module') and \\ len(self.options.module) > 0: args.append(self.options.module) l=self.collector.call(*args) if l is None: return print_table(l, width=50) def compliance_list_ruleset(self): if not hasattr(self.options, 'ruleset') or \\ len(self.options.ruleset)==0: l=self.collector.call('comp_list_ruleset') else: l=self.collector.call('comp_list_ruleset', self.options.ruleset) if l is None: return print '\\n'.join(l) def compliance_list_moduleset(self): if not hasattr(self.options, 'moduleset') or \\ len(self.options.moduleset)==0: l=self.collector.call('comp_list_moduleset') else: l=self.collector.call('comp_list_moduleset', self.options.moduleset) if l is None: return print '\\n'.join(l) def compliance_list_module(self): import glob regex2=re.compile(\"^S*[0-9]+-*\", re.UNICODE) for path in glob.glob(os.path.join(comp_dir, '*')): name=regex2.sub(\"\", os.path.basename(path)) try: m=Module(name) print m.name except: continue ","sourceWithComments":"from stat import *\nimport os\nimport sys\nimport re\nimport datetime\nimport rcExceptions as ex\nfrom rcGlobalEnv import rcEnv\nfrom rcUtilities import is_exe, justcall, banner\nfrom subprocess import *\nfrom rcPrintTable import print_table\n\ncomp_dir = os.path.join(rcEnv.pathvar, 'compliance')\n\n# ex: \\x1b[37;44m\\x1b[1mContact List\\x1b[0m\\n\nregex = re.compile(\"\\x1b\\[([0-9]{1,3}(;[0-9]{1,3})*)?[m|K|G]\", re.UNICODE)\n\nclass Module(object):\n    pattern = '^S*[0-9]+-*%(name)s$'\n\n    def __init__(self, name):\n        self.name = name\n        self.executable = None\n\n        dl = os.listdir(comp_dir)\n        match = []\n        for e in dl:\n            if re.match(self.pattern%dict(name=name), e) is not None:\n                match.append(e)\n        if len(match) == 0:\n            raise ex.excInitError('module %s not found in %s'%(name, comp_dir))\n        if len(match) > 1:\n            raise ex.excError('module %s matches too many entries in %s'%(name,\n                              comp_dir))\n        base = match[0]\n        if base[0] == 'S':\n            base == base[1:]\n        for i, c in enumerate(base):\n            if not c.isdigit():\n               break\n        self.ordering = int(base[0:i])\n        regex2 = re.compile(\"^S*[0-9]+-*\", re.UNICODE)\n        self.name = regex2.sub(\"\", match[0])\n\n        locations = []\n        locations.append(os.path.join(comp_dir, match[0]))\n        locations.append(os.path.join(locations[0], 'main'))\n        locations.append(os.path.join(locations[0], 'scripts', 'main'))\n\n        for loc in locations:\n            if not os.path.exists(loc):\n                continue\n            statinfo = os.stat(loc)\n            mode = statinfo[ST_MODE]\n            if statinfo.st_uid != 0 or statinfo.st_gid not in (0,2,3,4):\n                raise ex.excError('%s is not owned by root. security hazard.'%(loc))\n            if not S_ISREG(mode):\n                continue\n            if not is_exe(loc):\n                mode |= S_IXUSR\n                os.chmod(loc, mode)\n            self.executable = loc\n        if self.executable is None:\n            raise ex.excError('executable not found for module %s'%(name))\n\n    def __str__(self):\n        a = []\n        a.append(\"name: %s\"%self.name)\n        a.append(\"ordering: %d\"%self.ordering)\n        a.append(\"executable: %s\"%self.executable)\n        return '\\n'.join(a)\n\n\n    def strip_unprintable(self, s):\n        return regex.sub('', s)\n\n    def log_action(self, out, ret, action):\n        ruleset = ','.join(self.ruleset)\n        vars = ['run_nodename', 'run_module', 'run_status', 'run_log',\n                'run_ruleset', 'run_action', 'rset_md5']\n        vals = [rcEnv.nodename,\n                self.name,\n                str(ret),\n                self.strip_unprintable(out),\n                ruleset,\n                action,\n                self.rset_md5]\n        if self.svcname is not None:\n            vars.append('run_svcname')\n            vals.append(self.svcname)\n        self.collector.call('comp_log_action', vars, vals, sync=False)\n\n    def action(self, action):\n        print banner(self.name)\n\n        if action not in ['check', 'fix', 'fixable']:\n            print 'action %s not supported'\n            return 1\n\n        if self.options.force:\n            # short-circuit all pre and post action\n            return self.do_action(action)\n\n        if action == 'fix':\n            if self.do_action('check') == 0:\n                print 'check passed, skip fix'\n                return 0\n            if self.do_action('fixable') not in (0, 2):\n                print 'not fixable, skip fix'\n                return 1\n            self.do_action('fix')\n            r = self.do_action('check')\n        elif action == 'check':\n            r = self.do_action('check')\n            if r == 1:\n                self.do_action('fixable')\n        elif action == 'fixable':\n            r = self.do_action('fixable')\n        return r\n\n    def do_action(self, action):\n        start = datetime.datetime.now()\n        cmd = [self.executable, action]\n        log = ''\n        print \"ACTION:   %s\"%action\n        print \"START:    %s\"%str(start)\n        print \"COMMAND:  %s\"%' '.join(cmd)\n        print \"LOG:\"\n\n        import tempfile\n        import time\n        fo = tempfile.NamedTemporaryFile()\n        fe = tempfile.NamedTemporaryFile()\n        _fo = None\n        _fe = None\n\n        def poll_out():\n            fop = _fo.tell()\n            line = _fo.readline()\n            if not line:\n                _fo.seek(fop)\n                return None\n            sys.stdout.write(line)\n            sys.stdout.flush()\n            return line\n\n        def poll_err():\n            fep = _fe.tell()\n            line = _fe.readline()\n            if not line:\n                _fe.seek(fep)\n                return None\n            line = 'ERR: '+line\n            sys.stdout.write(line)\n            sys.stdout.flush()\n            return line\n\n        def poll_pipes(log):\n            i = 0\n            while True:\n                o = poll_out()\n                e = poll_err()\n                if o is not None:\n                    log += o\n                if e is not None:\n                    log += e\n                if o is None and e is None:\n                    break\n            return log\n\n        try:\n            p = Popen(cmd, stdout=fo, stderr=fe)\n            _fo = open(fo.name, 'r')\n            _fe = open(fe.name, 'r')\n            while True:\n                time.sleep(0.1)\n                log = poll_pipes(log)\n                if p.poll() != None:\n                    log = poll_pipes(log)\n                    break\n        except OSError, e:\n            if _fo is not None:\n                _fo.close()\n            if _fe is not None:\n                _fe.close()\n            fo.close()\n            fe.close()\n            if e.errno == 2:\n                raise ex.excError(\"%s execution error (File not found or bad interpreter)\"%self.executable)\n            elif e.errno == 8:\n                raise ex.excError(\"%s execution error (Exec format error)\"%self.executable)\n            else:\n                raise\n        fo.close()\n        fe.close()\n        _fo.close()\n        _fe.close()\n        end = datetime.datetime.now()\n        print \"RCODE:    %d\"%p.returncode\n        print \"DURATION: %s\"%str(end-start)\n        self.log_action(log, p.returncode, action)\n        return p.returncode\n\n    def check(self):\n        return self.action('check')\n\n    def fix(self):\n        return self.action('fix')\n\n    def fixable(self):\n        return self.action('fixable')\n\nclass Compliance(object):\n    def __init__(self, skip_action=None, options=None, collector=None, svcname=None):\n        self.skip_action = skip_action\n        self.options = options\n        self.collector = collector\n        self.svcname = svcname\n        self.options = options\n        self.module_o = {}\n        self.module = []\n\n    def compliance_check(self):\n        flag = \"last_comp_check\"\n        if self.svcname is not None:\n            flag = '.'.join((flag, self.svcname))\n        if self.skip_action is not None and \\\n           self.skip_action(\"compliance\", 'comp_check_interval', flag,\n                            period_option='comp_check_period',\n                            days_option='comp_check_days'):\n            return\n        self.do_checks()\n\n    def __iadd__(self, o):\n        self.module_o[o.name] = o\n        o.svcname = self.svcname\n        o.ruleset = self.ruleset\n        o.options = self.options\n        o.collector = self.collector\n        o.rset_md5 = self.rset_md5\n        return self\n\n    def set_rset_md5(self):\n        self.rset_md5 = \"\"\n        if 'OSVC_COMP_RULESET_MD5' in os.environ:\n            self.rset_md5 = os.environ['OSVC_COMP_RULESET_MD5']\n\n    def init(self):\n        if self.options.moduleset != \"\" and self.options.module != \"\":\n            raise ex.excError('--moduleset and --module are exclusive')\n\n        if self.options.moduleset == \"\" and self.options.module == \"\":\n            self.moduleset = self.get_moduleset()\n        else:\n            self.moduleset = self.options.moduleset.split(',')\n            self.module = self.options.module.split(',')\n        if len(self.moduleset) > 0 and hasattr(self.options, \"attach\") and self.options.attach:\n            self._compliance_attach_moduleset(self.moduleset)\n        self.module = self.merge_moduleset_modules()\n        self.ruleset = self.get_ruleset()\n        self.setup_env()\n        self.set_rset_md5()\n\n        if not os.path.exists(comp_dir):\n            os.makedirs(comp_dir, 0755)\n            raise ex.excError('modules [%s] are not present in %s'%(\n                               ','.join(self.module), comp_dir))\n\n        for module in self.module:\n            try:\n                self += Module(module)\n            except ex.excInitError, e:\n                print >>sys.stderr, e\n\n        self.ordered_module = self.module_o.keys()\n        self.ordered_module.sort(lambda x, y: cmp(self.module_o[x].ordering,\n                                                  self.module_o[y].ordering))\n\n    def __str__(self):\n        print banner('run context')\n        a = []\n        a.append('modules:')\n        for m in self.ordered_module:\n            a.append(' %0.2d %s'%(self.module_o[m].ordering, m))\n        a.append(self.str_ruleset())\n        return '\\n'.join(a)\n\n    def format_rule_var(self, var):\n        var = var.upper().replace('-', '_').replace(' ', '_').replace('.','_')\n        var = '_'.join(('OSVC_COMP', var))\n        return var\n\n    def format_rule_val(self, val):\n        if isinstance(val, unicode):\n            val = repr(val).strip(\"'\")\n        else:\n            val = str(val)\n        illegal_chars = \"\"\"`;$\"\"\"\n        for c in illegal_chars:\n            if c in val:\n                print \"illegal char %s in variable value: %s\"%(c,val)\n                return \"suppressed\"\n        return val\n\n    def setup_env(self):\n        for rule in self.ruleset.values():\n            for var, val in rule['vars']:\n                os.environ[self.format_rule_var(var)] = self.format_rule_val(val)\n\n    def get_moduleset(self):\n        if self.svcname is not None:\n            moduleset = self.collector.call('comp_get_svc_moduleset', self.svcname)\n        else:\n            moduleset = self.collector.call('comp_get_moduleset')\n        if moduleset is None:\n            raise ex.excError('could not fetch moduleset')\n        return moduleset\n\n    def get_ruleset(self):\n        if hasattr(self.options, 'ruleset') and \\\n           len(self.options.ruleset) > 0:\n            return self.get_ruleset_md5(self.options.ruleset)\n        return self.get_current_ruleset()\n\n    def get_current_ruleset(self):\n        if self.svcname is not None:\n            ruleset = self.collector.call('comp_get_svc_ruleset', self.svcname)\n        else:\n            ruleset = self.collector.call('comp_get_ruleset')\n        if ruleset is None:\n            raise ex.excError('could not fetch ruleset')\n        return ruleset\n\n    def get_ruleset_md5(self, rset_md5):\n        ruleset = self.collector.call('comp_get_ruleset_md5', rset_md5)\n        if ruleset is None:\n            raise ex.excError('could not fetch ruleset')\n        return ruleset\n\n    def str_ruleset(self):\n        a = []\n        a.append('rules:')\n        for rule in self.ruleset.values():\n            if len(rule['filter']) == 0:\n                a.append(' %s'%rule['name'])\n            else:\n                a.append(' %s (%s)'%(rule['name'],rule['filter']))\n            for var, val in rule['vars']:\n                val = self.format_rule_val(val)\n                if ' ' in val:\n                    val = repr(val)\n                a.append('  %s=%s'%(self.format_rule_var(var), val))\n        return '\\n'.join(a)\n\n    def merge_moduleset_modules(self):\n        modules = self.get_moduleset_modules(self.moduleset)\n        return set(self.module + modules) - set([''])\n\n    def get_moduleset_modules(self, m):\n        moduleset = self.collector.call('comp_get_moduleset_modules', m)\n        if moduleset is None:\n            raise ex.excError('could not expand moduleset modules')\n        return moduleset\n\n    def digest_errors(self, err):\n        passed = [m for m in err if err[m] == 0]\n        errors = [m for m in err if err[m] == 1]\n        na = [m for m in err if err[m] == 2]\n\n        n_passed = len(passed)\n        n_errors = len(errors)\n        n_na = len(na)\n\n        def _s(n):\n            if n > 1:\n                return 's'\n            else:\n                return ''\n\n        def modules(l):\n            if len(l) == 0:\n                return ''\n            return '\\n%s'%'\\n'.join(map(lambda x: ' '+x, l))\n\n        print banner(\"digest\")\n        print \"%d n\/a%s\"%(n_na, modules(na))\n        print \"%d passed%s\"%(n_passed, modules(passed))\n        print \"%d error%s%s\"%(n_errors, _s(n_errors), modules(errors))\n\n        if len(errors) > 0:\n            return 1\n        return 0\n\n    def compliance_show_moduleset(self):\n        self.moduleset = self.get_moduleset()\n        for ms in self.moduleset:\n            print ms+':'\n            for m in self.get_moduleset_modules(ms):\n                print ' %s'%m\n\n    def compliance_show_ruleset(self):\n        self.ruleset = self.get_ruleset()\n        self.setup_env()\n        print self.str_ruleset()\n\n    def do_run(self, action):\n        err = {}\n        self.init()\n        start = datetime.datetime.now()\n        for module in self.ordered_module:\n            err[module] = getattr(self.module_o[module], action)()\n        r = self.digest_errors(err)\n        end = datetime.datetime.now()\n        print \"total duration: %s\"%str(end-start)\n        return r\n\n    def do_checks(self):\n        return self.do_run('check')\n\n    def compliance_fix(self):\n        return self.do_run('fix')\n\n    def compliance_fixable(self):\n        return self.do_run('fixable')\n\n    def compliance_attach_moduleset(self):\n        if not hasattr(self.options, 'moduleset') or \\\n           len(self.options.moduleset) == 0:\n            raise ex.excError('no moduleset specified. use --moduleset')\n        self._compliance_attach_moduleset(self.options.moduleset.split(','))\n\n    def _compliance_attach_moduleset(self, modulesets):\n        err = False\n        for moduleset in modulesets:\n            if self.svcname is not None:\n                d = self.collector.call('comp_attach_svc_moduleset', self.svcname, moduleset)\n            else:\n                d = self.collector.call('comp_attach_moduleset', moduleset)\n            if not d['status']:\n                err = True\n            print d['msg']\n        if err:\n            raise ex.excError()\n\n    def compliance_detach_moduleset(self):\n        if not hasattr(self.options, 'moduleset') or \\\n           len(self.options.moduleset) == 0:\n            raise ex.excError('no moduleset specified. use --moduleset')\n        err = False\n        for moduleset in self.options.moduleset.split(','):\n            if self.svcname is not None:\n                d = self.collector.call('comp_detach_svc_moduleset', self.svcname, moduleset)\n            else:\n                d = self.collector.call('comp_detach_moduleset', moduleset)\n            if not d['status']:\n                err = True\n            print d['msg']\n        if err:\n            raise ex.excError()\n\n    def compliance_attach_ruleset(self):\n        if not hasattr(self.options, 'ruleset') or \\\n           len(self.options.ruleset) == 0:\n            raise ex.excError('no ruleset specified. use --ruleset')\n        err = False\n        for ruleset in self.options.ruleset.split(','):\n            if self.svcname is not None:\n                d = self.collector.call('comp_attach_svc_ruleset', self.svcname, ruleset)\n            else:\n                d = self.collector.call('comp_attach_ruleset', ruleset)\n            if not d['status']:\n                err = True\n            print d['msg']\n        if err:\n            raise ex.excError()\n\n    def compliance_detach_ruleset(self):\n        if not hasattr(self.options, 'ruleset') or \\\n           len(self.options.ruleset) == 0:\n            raise ex.excError('no ruleset specified. use --ruleset')\n        err = False\n        for ruleset in self.options.ruleset.split(','):\n            if self.svcname is not None:\n                d = self.collector.call('comp_detach_svc_ruleset', self.svcname, ruleset)\n            else:\n                d = self.collector.call('comp_detach_ruleset', ruleset)\n            if not d['status']:\n                err = True\n            print d['msg']\n        if err:\n            raise ex.excError()\n\n    def compliance_show_status(self):\n        args = ['comp_show_status']\n        if self.svcname is None:\n           args.append('')\n        else:\n           args.append(self.svcname)\n        if hasattr(self.options, 'module') and \\\n           len(self.options.module) > 0:\n            args.append(self.options.module)\n        l = self.collector.call(*args)\n        if l is None:\n            return\n        print_table(l, width=50)\n\n    def compliance_list_ruleset(self):\n        if not hasattr(self.options, 'ruleset') or \\\n           len(self.options.ruleset) == 0:\n            l = self.collector.call('comp_list_ruleset')\n        else:\n            l = self.collector.call('comp_list_ruleset', self.options.ruleset)\n        if l is None:\n            return\n        print '\\n'.join(l)\n\n    def compliance_list_moduleset(self):\n        if not hasattr(self.options, 'moduleset') or \\\n           len(self.options.moduleset) == 0:\n            l = self.collector.call('comp_list_moduleset')\n        else:\n            l = self.collector.call('comp_list_moduleset', self.options.moduleset)\n        if l is None:\n            return\n        print '\\n'.join(l)\n\n    def compliance_list_module(self):\n        import glob\n        regex2 = re.compile(\"^S*[0-9]+-*\", re.UNICODE)\n        for path in glob.glob(os.path.join(comp_dir, '*')):\n            name = regex2.sub(\"\", os.path.basename(path))\n            try:\n                m = Module(name)\n                print m.name\n            except:\n                continue\n\n\n"}},"msg":"Remove uneeded variable value check in compliance framework\n\nThe agent suppressed the variable values containing `$;\ncharacters to protect against code injection.\n\nActually the code injection risk is limited to modules\ndoing an 'eval' on the variable values ... which is users'\nresponsability.\n\nRemove this suppression logic to allow more values."}},"https:\/\/github.com\/mijowild\/fieldcycling":{"482b92c89853b9908c6bbe8f9d08bbfd991c98f6":{"url":"https:\/\/api.github.com\/repos\/mijowild\/fieldcycling\/commits\/482b92c89853b9908c6bbe8f9d08bbfd991c98f6","html_url":"https:\/\/github.com\/mijowild\/fieldcycling\/commit\/482b92c89853b9908c6bbe8f9d08bbfd991c98f6","message":"implemented matlab code for correct implementation of tau. Not tested yet.\n\nAlso uses pyparsing instead of eval, because eval can be used for injection and should be avoided in python.","sha":"482b92c89853b9908c6bbe8f9d08bbfd991c98f6","keyword":"eval injection correct","diff":"diff --git a\/bokeh_dropdown_fieldcycling.py b\/bokeh_dropdown_fieldcycling.py\nindex 9b4625c..861b667 100644\n--- a\/bokeh_dropdown_fieldcycling.py\n+++ b\/bokeh_dropdown_fieldcycling.py\n@@ -66,9 +66,7 @@ def modify_doc(doc):\n \r\n     p2 = figure(plot_width=300, plot_height=300)\r\n     p2.circle_cross('tau', 'phi', source=source_df, color=\"navy\")\r\n-    \r\n-    slider = Slider(start=1, end=nr_experiments, value=1, step=1)\r\n-    \r\n+        \r\n     menu = [(\"Experiment nr {:4d}\".format(ie), \"{:4d}\".format(ie)) for ie in range(1, nr_experiments+1)]\r\n     dropdown = Dropdown(label=\"choose experiment number\", menu=menu)    \r\n \r\ndiff --git a\/bokeh_throttle_fieldcycling.py b\/bokeh_throttle_fieldcycling.py\nindex 9f615c3..5365a28 100644\n--- a\/bokeh_throttle_fieldcycling.py\n+++ b\/bokeh_throttle_fieldcycling.py\n@@ -21,6 +21,7 @@\n from bokeh.models import ColumnDataSource, Slider\r\n from bokeh.server.server import Server\r\n import stelardatafile as sdf\r\n+from utils import get_x_axis\r\n \r\n #specify and import data file\r\n path=os.path.join(os.path.curdir,'data')\r\n@@ -53,6 +54,8 @@ def modify_doc(doc):\n     #calculate the tau for the corresponding fid in each block\r\n     tau=np.logspace(-3,np.log10(5*parameters['T1MX']),nblk) #FIXME we need to read the tau from bini and bend (complicated)\r\n     #calculate magnitization amplitudes from fid series, integrate from startpoint to endpoint\r\n+    # TODO: Test the following line:\r\n+    # tau = get_x_axis(parameters)\r\n     startpoint=int(0.05*bs)-1\r\n     endpoint=int(0.1*bs)\r\n     phi=np.zeros(nblk)\r\ndiff --git a\/num_string_eval.py b\/num_string_eval.py\nnew file mode 100644\nindex 0000000..6c620ed\n--- \/dev\/null\n+++ b\/num_string_eval.py\n@@ -0,0 +1,117 @@\n+from __future__ import division\n+from pyparsing import (Literal, CaselessLiteral, Word, Combine, Group, Optional,\n+                       ZeroOrMore, Forward, nums, alphas, oneOf)\n+import math\n+import operator\n+\n+__author__ = 'Paul McGuire'\n+__version__ = '$Revision: 0.0 $'\n+__date__ = '$Date: 2009-03-20 $'\n+__source__ = '''http:\/\/pyparsing.wikispaces.com\/file\/view\/fourFn.py\n+http:\/\/pyparsing.wikispaces.com\/message\/view\/home\/15549426\n+'''\n+__note__ = '''\n+All I've done is rewrap Paul McGuire's fourFn.py as a class, so I can use it\n+more easily in other places.\n+'''\n+\n+\n+class NumericStringParser(object):\n+    '''\n+    Most of this code comes from the fourFn.py pyparsing example\n+\n+    '''\n+\n+    def pushFirst(self, strg, loc, toks):\n+        self.exprStack.append(toks[0])\n+\n+    def pushUMinus(self, strg, loc, toks):\n+        if toks and toks[0] == '-':\n+            self.exprStack.append('unary -')\n+\n+    def __init__(self):\n+        \"\"\"\n+        expop   :: '^'\n+        multop  :: '*' | '\/'\n+        addop   :: '+' | '-'\n+        integer :: ['+' | '-'] '0'..'9'+\n+        atom    :: PI | E | real | fn '(' expr ')' | '(' expr ')'\n+        factor  :: atom [ expop factor ]*\n+        term    :: factor [ multop factor ]*\n+        expr    :: term [ addop term ]*\n+        \"\"\"\n+        point = Literal(\".\")\n+        e = CaselessLiteral(\"E\")\n+        fnumber = Combine(Word(\"+-\" + nums, nums) +\n+                          Optional(point + Optional(Word(nums))) +\n+                          Optional(e + Word(\"+-\" + nums, nums)))\n+        ident = Word(alphas, alphas + nums + \"_$\")\n+        plus = Literal(\"+\")\n+        minus = Literal(\"-\")\n+        mult = Literal(\"*\")\n+        div = Literal(\"\/\")\n+        lpar = Literal(\"(\").suppress()\n+        rpar = Literal(\")\").suppress()\n+        addop = plus | minus\n+        multop = mult | div\n+        expop = Literal(\"^\")\n+        pi = CaselessLiteral(\"PI\")\n+        expr = Forward()\n+        atom = ((Optional(oneOf(\"- +\")) +\n+                 (ident + lpar + expr + rpar | pi | e | fnumber).setParseAction(self.pushFirst))\n+                | Optional(oneOf(\"- +\")) + Group(lpar + expr + rpar)\n+                ).setParseAction(self.pushUMinus)\n+        # by defining exponentiation as \"atom [ ^ factor ]...\" instead of\n+        # \"atom [ ^ atom ]...\", we get right-to-left exponents, instead of left-to-right\n+        # that is, 2^3^2 = 2^(3^2), not (2^3)^2.\n+        factor = Forward()\n+        factor << atom + \\\n+            ZeroOrMore((expop + factor).setParseAction(self.pushFirst))\n+        term = factor + \\\n+            ZeroOrMore((multop + factor).setParseAction(self.pushFirst))\n+        expr << term + \\\n+            ZeroOrMore((addop + term).setParseAction(self.pushFirst))\n+        # addop_term = ( addop + term ).setParseAction( self.pushFirst )\n+        # general_term = term + ZeroOrMore( addop_term ) | OneOrMore( addop_term)\n+        # expr <<  general_term\n+        self.bnf = expr\n+        # map operator symbols to corresponding arithmetic operations\n+        epsilon = 1e-12\n+        self.opn = {\"+\": operator.add,\n+                    \"-\": operator.sub,\n+                    \"*\": operator.mul,\n+                    \"\/\": operator.truediv,\n+                    \"^\": operator.pow}\n+        self.fn = {\"sin\": math.sin,\n+                   \"cos\": math.cos,\n+                   \"tan\": math.tan,\n+                   \"exp\": math.exp,\n+                   \"abs\": abs,\n+                   \"trunc\": lambda a: int(a),\n+                   \"round\": round,\n+                   \"sgn\": lambda a: abs(a) > epsilon and cmp(a, 0) or 0}\n+\n+    def evaluateStack(self, s):\n+        op = s.pop()\n+        if op == 'unary -':\n+            return -self.evaluateStack(s)\n+        if op in \"+-*\/^\":\n+            op2 = self.evaluateStack(s)\n+            op1 = self.evaluateStack(s)\n+            return self.opn[op](op1, op2)\n+        elif op == \"PI\":\n+            return math.pi  # 3.1415926535\n+        elif op == \"E\":\n+            return math.e  # 2.718281828\n+        elif op in self.fn:\n+            return self.fn[op](self.evaluateStack(s))\n+        elif op[0].isalpha():\n+            return 0\n+        else:\n+            return float(op)\n+\n+    def eval(self, num_string, parseAll=True):\n+        self.exprStack = []\n+        results = self.bnf.parseString(num_string, parseAll)\n+        val = self.evaluateStack(self.exprStack[:])\n+        return val\ndiff --git a\/understand_data.ipynb b\/understand_data.ipynb\nindex 90eaa18..e0049df 100644\n--- a\/understand_data.ipynb\n+++ b\/understand_data.ipynb\n@@ -26,7 +26,7 @@\n      \"name\": \"stdout\",\n      \"output_type\": \"stream\",\n      \"text\": [\n-      \"escape\\n\",\n+      \"probably end of file reached\\n\",\n       \"145 experiments read\\n\"\n      ]\n     }\n@@ -38,7 +38,7 @@\n   },\n   {\n    \"cell_type\": \"code\",\n-   \"execution_count\": 4,\n+   \"execution_count\": 56,\n    \"metadata\": {\n     \"collapsed\": true\n    },\n@@ -864,6 +864,59 @@\n     \"for ax in axes:\\n\",\n     \"    ax.grid('on')\"\n    ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"# understanding tau:\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"eval is evil in python... Can be used for injection. see http:\/\/stackoverflow.com\/questions\/2371436\/evaluating-a-mathematical-expression-in-a-string\\n\",\n+    \"Complicated alternative:\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 60,\n+   \"metadata\": {\n+    \"collapsed\": false\n+   },\n+   \"outputs\": [],\n+   \"source\": [\n+    \"import numpy.matlib\\n\",\n+    \"from num_string_eval import NumericStringParser\\n\",\n+    \"nsp = NumericStringParser()\\n\",\n+    \"\\n\",\n+    \"T1MX = parameters['T1MX'] # T1MX is used in the 'eval' expressions below\\n\",\n+    \"# TODO: not tested yet for all cases\\n\",\n+    \"if parameters['BGRD'] == 'LIST':\\n\",\n+    \"    temp = parameters['BLST']\\n\",\n+    \"    temp.replace(';', ':')\\n\",\n+    \"    sep_indices = [pos for pos, char in enumerate(ele) if char == ':'] # find indices of ':'\\n\",\n+    \"    Tini = nsp.eval(temp[:sep_indices[0]].replace('T1MX', str(T1MX)))\\n\",\n+    \"    Tend = nsp.eval(temp[sep_indices[0]+1:sep_indices[1]].replace('T1MX', str(T1MX)))\\n\",\n+    \"    npts = nsp.eval(temp[sep_indices[2]+1:].replace('T1MX', str(T1MX))) # number of points selected: can be ~= NBLK    \\n\",\n+    \"    if temp[sep[1]+1:sep[2]] == 'LIN':\\n\",\n+    \"        listx = linspace(Tini,Tend,npts);\\n\",\n+    \"    elif temp[sep[1]+1:sep[2]] == 'LOG':\\n\",\n+    \"        listx = np.logspace(np.log10(Tini),np.log10(Tend),npts);\\n\",\n+    \"    nrep = np.ceil(nblk\/npts) # find if the time vector needs to be longer\\n\",\n+    \"    x = numpy.matlib.repmat(listx,1,nrep) # re-create the time vector\\n\",\n+    \"    x = x[:nblk] # select the portion corresponding to the number of blocs (needed if npts~=nblk)\\n\",\n+    \"elif parameters['BGRD'] == 'LIN':\\n\",\n+    \"    Tini = nsp.eval(parameters['BINI'].replace('T1MX', str(T1MX)))\\n\",\n+    \"    Tend = nsp.eval(parameters['BEND'].replace('T1MX', str(T1MX)))\\n\",\n+    \"    x = np.linspace(Tini, Tend, nblk) # re-create the time vector\\n\",\n+    \"elif parameters['BGRD'] == 'LOG':\\n\",\n+    \"    Tini = nsp.eval(parameters['BINI'].replace('T1MX', str(T1MX)))\\n\",\n+    \"    Tend = nsp.eval(parameters['BEND'].replace('T1MX', str(T1MX)))\\n\",\n+    \"    x = np.logspace(np.log10(Tini),np.log10(Tend),nblk) # re-create the time vector\"\n+   ]\n   }\n  ],\n  \"metadata\": {\ndiff --git a\/utils.py b\/utils.py\nnew file mode 100644\nindex 0000000..2fde241\n--- \/dev\/null\n+++ b\/utils.py\n@@ -0,0 +1,30 @@\n+import numpy.matlib\n+from num_string_eval import NumericStringParser\n+\n+def get_x_axis(parameters):\n+    nsp = NumericStringParser()\n+    T1MX = parameters['T1MX'] # T1MX is used in the 'eval' expressions below\n+    # TODO: not tested yet for all cases\n+    if parameters['BGRD'] == 'LIST':\n+        temp = parameters['BLST']\n+        temp.replace(';', ':')\n+        sep_indices = [pos for pos, char in enumerate(ele) if char == ':'] # find indices of ':'\n+        Tini = nsp.eval(temp[:sep_indices[0]].replace('T1MX', str(T1MX)))\n+        Tend = nsp.eval(temp[sep_indices[0]+1:sep_indices[1]].replace('T1MX', str(T1MX)))\n+        npts = nsp.eval(temp[sep_indices[2]+1:].replace('T1MX', str(T1MX))) # number of points selected: can be ~= NBLK    \n+        if temp[sep[1]+1:sep[2]] == 'LIN':\n+            listx = linspace(Tini,Tend,npts);\n+        elif temp[sep[1]+1:sep[2]] == 'LOG':\n+            listx = np.logspace(np.log10(Tini),np.log10(Tend),npts);\n+        nrep = np.ceil(nblk\/npts) # find if the time vector needs to be longer\n+        x = numpy.matlib.repmat(listx,1,nrep) # re-create the time vector\n+        x = x[:nblk] # select the portion corresponding to the number of blocs (needed if npts~=nblk)\n+    elif parameters['BGRD'] == 'LIN':\n+        Tini = nsp.eval(parameters['BINI'].replace('T1MX', str(T1MX)))\n+        Tend = nsp.eval(parameters['BEND'].replace('T1MX', str(T1MX)))\n+        x = np.linspace(Tini, Tend, nblk) # re-create the time vector\n+    elif parameters['BGRD'] == 'LOG':\n+        Tini = nsp.eval(parameters['BINI'].replace('T1MX', str(T1MX)))\n+        Tend = nsp.eval(parameters['BEND'].replace('T1MX', str(T1MX)))\n+        x = np.logspace(np.log10(Tini),np.log10(Tend),nblk) # re-create the time vector\n+    return x\n\\ No newline at end of file\n","files":{"\/bokeh_dropdown_fieldcycling.py":{"changes":[{"diff":"\n \r\n     p2 = figure(plot_width=300, plot_height=300)\r\n     p2.circle_cross('tau', 'phi', source=source_df, color=\"navy\")\r\n-    \r\n-    slider = Slider(start=1, end=nr_experiments, value=1, step=1)\r\n-    \r\n+        \r\n     menu = [(\"Experiment nr {:4d}\".format(ie), \"{:4d}\".format(ie)) for ie in range(1, nr_experiments+1)]\r\n     dropdown = Dropdown(label=\"choose experiment number\", menu=menu)    \r\n \r","add":1,"remove":3,"filename":"\/bokeh_dropdown_fieldcycling.py","badparts":["    \r","    slider = Slider(start=1, end=nr_experiments, value=1, step=1)\r","    \r"],"goodparts":["        \r"]}],"source":"\n import os\r import sys\r import pandas as pd\r import numpy as np\r import matplotlib.pyplot as plt\r import re\r from bokeh.charts import Scatter, output_file, show\r from bokeh.sampledata.autompg import autompg as df\r from bokeh.models.widgets import Panel, Tabs\r from bokeh.io import output_file, show\r from bokeh.plotting import figure\r from bokeh.layouts import widgetbox\r from bokeh.models.widgets import Dropdown\r from tornado.ioloop import IOLoop\r from bokeh.application.handlers import FunctionHandler\r from bokeh.application import Application\r from bokeh.layouts import column\r from bokeh.models import ColumnDataSource, Slider\r from bokeh.server.server import Server\r import stelardatafile as sdf\r \r path=os.path.join(os.path.curdir,'data')\r polymer=sdf.StelarDataFile('297K.sdf',path)\r polymer.sdfimport()\r nr_experiments=polymer.get_number_of_experiments()\r \r io_loop=IOLoop.current()\r ie=1\r \r def modify_doc(doc):\r parameters=polymer.getparameter(ie)\r bs=int(parameters['BS'])\r try:\r nblk=int(parameters['NBLK'])\r except:\r nblk=1;\r ns=int(parameters['NS'])\r try:\r dw=parameters['DW']*1e-6 except:\r dw=1\r temperature=parameters['TEMP']\r fid=pd.DataFrame(polymer.getdata(ie),index=np.linspace(dw,dw*bs*nblk,bs* nblk), columns=['real', 'im'])\/ns\r fid['magnitude']=( fid['real']**2 +fid['im']**2)**0.5 tau=np.logspace(-3,np.log10(5*parameters['T1MX']),nblk) startpoint=int(0.05*bs)-1\r endpoint=int(0.1*bs)\r phi=np.zeros(nblk)\r for blk in range(nblk):\r start=startpoint +blk * bs\r end=endpoint +blk * bs\r phi[blk]=fid['magnitude'].iloc[start:end].sum() \/(endpoint-startpoint)\r df=pd.DataFrame(data=np.c_[tau, phi], columns=['tau', 'phi'])\r \r source_fid=ColumnDataSource(data=ColumnDataSource.from_df(fid))\r source_df=ColumnDataSource(data=ColumnDataSource.from_df(df))\r \r \r p1=figure(plot_width=300, plot_height=300)\r p1.line('index', 'im', source=source_fid, color='blue')\r p1.line('index', 'real', source=source_fid, color='green')\r p1.line('index', 'magnitude', source=source_fid, color='red')\r \r \r p2=figure(plot_width=300, plot_height=300)\r p2.circle_cross('tau', 'phi', source=source_df, color=\"navy\")\r \r slider=Slider(start=1, end=nr_experiments, value=1, step=1)\r \r menu=[(\"Experiment nr{:4d}\".format(ie), \"{:4d}\".format(ie)) for ie in range(1, nr_experiments+1)]\r dropdown=Dropdown(label=\"choose experiment number\", menu=menu) \r \r def callback(attr, old, new):\r ie=int(new)\r parameters=polymer.getparameter(ie)\r bs=int(parameters['BS'])\r try:\r nblk=int(parameters['NBLK'])\r except:\r nblk=1;\r ns=int(parameters['NS'])\r try:\r dw=parameters['DW']*1e-6 except:\r dw=1\r temperature=parameters['TEMP']\r fid=pd.DataFrame(polymer.getdata(ie),index=np.linspace(dw,dw*bs*nblk,bs* nblk), columns=['real', 'im'])\/ns\r fid['magnitude']=( fid['real']**2 +fid['im']**2)**0.5 tau=np.logspace(-3,np.log10(5*parameters['T1MX']),nblk) startpoint=int(0.05*bs)-1\r endpoint=int(0.1*bs)\r phi=np.zeros(nblk) \r for blk in range(nblk):\r start=startpoint +blk * bs\r end=endpoint +blk * bs\r phi[blk]=fid['magnitude'].iloc[start:end].sum() \/(endpoint-startpoint)\r df=pd.DataFrame(data=np.c_[tau, phi], columns=['tau', 'phi'])\r \r source_fid.data=ColumnDataSource.from_df(fid)\r source_df.data=ColumnDataSource.from_df(df)\r \r dropdown.on_change('value', callback)\r doc.add_root(column(dropdown, p1, p2))\r \r bokeh_app=Application(FunctionHandler(modify_doc))\r \r server=Server({'\/': bokeh_app}, io_loop=io_loop)\r server.start()\r \r if __name__=='__main__':\r print('Opening Bokeh application on http:\/\/localhost:5006\/')\r \r io_loop.add_callback(server.show, \"\/\")\r io_loop.start() ","sourceWithComments":"#!\/usr\/bin\/python\r\n# -*- coding: UTF-8 -*-\r\nimport os\r\nimport sys\r\nimport pandas as pd\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport re\r\nfrom bokeh.charts import Scatter, output_file, show\r\nfrom bokeh.sampledata.autompg import autompg as df\r\nfrom bokeh.models.widgets import Panel, Tabs\r\nfrom bokeh.io import output_file, show\r\nfrom bokeh.plotting import figure\r\nfrom bokeh.layouts import widgetbox\r\nfrom bokeh.models.widgets import Dropdown\r\nfrom tornado.ioloop import IOLoop\r\nfrom bokeh.application.handlers import FunctionHandler\r\nfrom bokeh.application import Application\r\nfrom bokeh.layouts import column\r\nfrom bokeh.models import ColumnDataSource, Slider\r\nfrom bokeh.server.server import Server\r\nimport stelardatafile as sdf\r\n\r\npath=os.path.join(os.path.curdir,'data')\r\npolymer=sdf.StelarDataFile('297K.sdf',path)\r\npolymer.sdfimport()\r\nnr_experiments = polymer.get_number_of_experiments()\r\n\r\nio_loop = IOLoop.current()\r\nie = 1\r\n\r\ndef modify_doc(doc):\r\n    parameters=polymer.getparameter(ie)\r\n    bs=int(parameters['BS'])\r\n    try:\r\n        nblk=int(parameters['NBLK'])\r\n    except:\r\n        nblk=1;\r\n    ns=int(parameters['NS'])\r\n    try:\r\n        dw=parameters['DW']*1e-6 #dwell time is in [mu s]\r\n    except:\r\n        dw=1\r\n    temperature=parameters['TEMP']\r\n    fid=pd.DataFrame(polymer.getdata(ie),index=np.linspace(dw,dw*bs*nblk,bs*                 nblk), columns=['real', 'im'])\/ns\r\n    fid['magnitude']=( fid['real']**2 + fid['im']**2 )**0.5 # last two lines may represent a seperate method\r\n    tau=np.logspace(-3,np.log10(5*parameters['T1MX']),nblk) #as a dummy\r\n    startpoint=int(0.05*bs)-1\r\n    endpoint=int(0.1*bs)\r\n    phi=np.zeros(nblk)\r\n    for blk in range(nblk):\r\n        start=startpoint + blk * bs\r\n        end=endpoint + blk * bs\r\n        phi[blk]=fid['magnitude'].iloc[start:end].sum() \/ (endpoint-startpoint)\r\n    df = pd.DataFrame(data=np.c_[tau, phi], columns=['tau', 'phi'])\r\n\r\n    source_fid = ColumnDataSource(data=ColumnDataSource.from_df(fid))\r\n    source_df = ColumnDataSource(data=ColumnDataSource.from_df(df))\r\n\r\n    \r\n    p1 = figure(plot_width=300, plot_height=300)\r\n    p1.line('index', 'im', source=source_fid, color='blue')\r\n    p1.line('index', 'real', source=source_fid, color='green')\r\n    p1.line('index', 'magnitude', source=source_fid, color='red')\r\n\r\n\r\n    p2 = figure(plot_width=300, plot_height=300)\r\n    p2.circle_cross('tau', 'phi', source=source_df, color=\"navy\")\r\n    \r\n    slider = Slider(start=1, end=nr_experiments, value=1, step=1)\r\n    \r\n    menu = [(\"Experiment nr {:4d}\".format(ie), \"{:4d}\".format(ie)) for ie in range(1, nr_experiments+1)]\r\n    dropdown = Dropdown(label=\"choose experiment number\", menu=menu)    \r\n\r\n    def callback(attr, old, new):\r\n        ie = int(new)\r\n        parameters=polymer.getparameter(ie)\r\n        bs=int(parameters['BS'])\r\n        try:\r\n            nblk=int(parameters['NBLK'])\r\n        except:\r\n            nblk=1;\r\n        ns=int(parameters['NS'])\r\n        try:\r\n            dw=parameters['DW']*1e-6 #dwell time is in [mu s]\r\n        except:\r\n            dw=1\r\n        temperature=parameters['TEMP']\r\n        fid=pd.DataFrame(polymer.getdata(ie),index=np.linspace(dw,dw*bs*nblk,bs*                 nblk), columns=['real', 'im'])\/ns\r\n        fid['magnitude']=( fid['real']**2 + fid['im']**2 )**0.5 # last two lines may represent a seperate method\r\n        tau=np.logspace(-3,np.log10(5*parameters['T1MX']),nblk) #as a dummy\r\n        startpoint=int(0.05*bs)-1\r\n        endpoint=int(0.1*bs)\r\n        phi=np.zeros(nblk)  \r\n        for blk in range(nblk):\r\n            start=startpoint + blk * bs\r\n            end=endpoint + blk * bs\r\n            phi[blk]=fid['magnitude'].iloc[start:end].sum() \/ (endpoint-startpoint)\r\n        df = pd.DataFrame(data=np.c_[tau, phi], columns=['tau', 'phi'])\r\n\r\n        source_fid.data = ColumnDataSource.from_df(fid)\r\n        source_df.data = ColumnDataSource.from_df(df)\r\n\r\n    dropdown.on_change('value', callback)\r\n    doc.add_root(column(dropdown, p1, p2))\r\n\r\nbokeh_app = Application(FunctionHandler(modify_doc))\r\n\r\nserver = Server({'\/': bokeh_app}, io_loop=io_loop)\r\nserver.start()\r\n\r\nif __name__ == '__main__':\r\n    print('Opening Bokeh application on http:\/\/localhost:5006\/')\r\n\r\n    io_loop.add_callback(server.show, \"\/\")\r\nio_loop.start()"}},"msg":"implemented matlab code for correct implementation of tau. Not tested yet.\n\nAlso uses pyparsing instead of eval, because eval can be used for injection and should be avoided in python."}},"https:\/\/github.com\/montemac\/algebraic_value_editing":{"edf608c0fdb7477da51664f97ee7a30caad52ca7":{"url":"https:\/\/api.github.com\/repos\/montemac\/algebraic_value_editing\/commits\/edf608c0fdb7477da51664f97ee7a30caad52ca7","html_url":"https:\/\/github.com\/montemac\/algebraic_value_editing\/commit\/edf608c0fdb7477da51664f97ee7a30caad52ca7","message":"Changed torch requirement to 1.13.1 to address eval injection vulnerability","sha":"edf608c0fdb7477da51664f97ee7a30caad52ca7","keyword":"eval injection change","diff":"diff --git a\/setup.py b\/setup.py\nindex 081e53a..7a08ecf 100644\n--- a\/setup.py\n+++ b\/setup.py\n@@ -15,7 +15,7 @@\n             \"transformer-lens @\"\n             \" git+https:\/\/github.com\/neelnanda-io\/TransformerLens.git@1f65f4bf35d91677deea2331561ae6a9d2e92d38\"\n         ),\n-        \"torch==1.13.0\",\n+        \"torch==1.13.1\",\n         \"numpy>=1.22.1\",\n         \"pandas>=1.4.4\",\n         \"jaxtyping>=0.2.14\",\n","files":{"\/setup.py":{"changes":[{"diff":"\n             \"transformer-lens @\"\n             \" git+https:\/\/github.com\/neelnanda-io\/TransformerLens.git@1f65f4bf35d91677deea2331561ae6a9d2e92d38\"\n         ),\n-        \"torch==1.13.0\",\n+        \"torch==1.13.1\",\n         \"numpy>=1.22.1\",\n         \"pandas>=1.4.4\",\n         \"jaxtyping>=0.2.14\",\n","add":1,"remove":1,"filename":"\/setup.py","badparts":["        \"torch==1.13.0\","],"goodparts":["        \"torch==1.13.1\","]}],"source":"\nfrom setuptools import setup, find_packages setup( name=\"algebraic_value_editing\", description=( \"Tools for testing the algebraic value-editing conjecture(AVEC) on\" \" language models\" ), long_description=open(\"README.md\", encoding=\"utf-8\").read(), long_description_content_type=\"text\/markdown\", version=\"0.2.0\", packages=find_packages(), install_requires=[ ( \"transformer-lens @\" \" git+https:\/\/github.com\/neelnanda-io\/TransformerLens.git@1f65f4bf35d91677deea2331561ae6a9d2e92d38\" ), \"torch==1.13.0\", \"numpy>=1.22.1\", \"pandas>=1.4.4\", \"jaxtyping>=0.2.14\", \"prettytable>=3.6.0\", \"funcy>=2.0\", \"wandb==0.13.5\", ], ) ","sourceWithComments":"from setuptools import setup, find_packages\n\nsetup(\n    name=\"algebraic_value_editing\",\n    description=(\n        \"Tools for testing the algebraic value-editing conjecture (AVEC) on\"\n        \" language models\"\n    ),\n    long_description=open(\"README.md\", encoding=\"utf-8\").read(),\n    long_description_content_type=\"text\/markdown\",\n    version=\"0.2.0\",\n    packages=find_packages(),\n    install_requires=[\n        (\n            \"transformer-lens @\"\n            \" git+https:\/\/github.com\/neelnanda-io\/TransformerLens.git@1f65f4bf35d91677deea2331561ae6a9d2e92d38\"\n        ),\n        \"torch==1.13.0\",\n        \"numpy>=1.22.1\",\n        \"pandas>=1.4.4\",\n        \"jaxtyping>=0.2.14\",\n        \"prettytable>=3.6.0\",\n        \"funcy>=2.0\",\n        \"wandb==0.13.5\",  # transformer_lens 0.0.0 requires <0.14.0, >=0.13.5\n    ],\n)\n"}},"msg":"Changed torch requirement to 1.13.1 to address eval injection vulnerability"}},"https:\/\/github.com\/jottyVlad\/mdb-vk-bot":{"4a2f6bec73efe91a95d2f3d1706b7aa33b6c8590":{"url":"https:\/\/api.github.com\/repos\/jottyVlad\/mdb-vk-bot\/commits\/4a2f6bec73efe91a95d2f3d1706b7aa33b6c8590","html_url":"https:\/\/github.com\/jottyVlad\/mdb-vk-bot\/commit\/4a2f6bec73efe91a95d2f3d1706b7aa33b6c8590","message":"Refactor code, added utils functions, changed structure of models, FIXED SQL-INJECTION POSSIBILITY, REPLACED EVAL","sha":"4a2f6bec73efe91a95d2f3d1706b7aa33b6c8590","keyword":"eval injection change","diff":"diff --git a\/config.py b\/config.py\nindex 94507bb..6ac9631 100644\n--- a\/config.py\n+++ b\/config.py\n@@ -14,3 +14,4 @@\n NEW_START = bool(int(os.getenv(\"NEW_START\", 0)))\n ADMINS_IN_CONV = list(map(int, os.getenv(\"ADMINS_IN_CONV\").split(',')))\n \n+BOT_GROUP_ID = 196816306\ndiff --git a\/global_settings.py b\/global_settings.py\nindex a211713..c858aea 100644\n--- a\/global_settings.py\n+++ b\/global_settings.py\n@@ -2,14 +2,10 @@\n \n from vkbottle import User as vkBottleUser, Bot\n \n-from config import ACCESS_TOKEN, USER_ACCESS_TOKEN\n+from config import ACCESS_TOKEN, USER_ACCESS_TOKEN, BOT_GROUP_ID\n from utils.main import get_access_for_all\n \n-BOT = Bot(ACCESS_TOKEN, loop=asyncio.get_event_loop(), group_id=196816306)\n+BOT = Bot(ACCESS_TOKEN, loop=asyncio.get_event_loop(), group_id=BOT_GROUP_ID)\n USER = vkBottleUser(USER_ACCESS_TOKEN)\n \n-#TODO: \u0441\u043e\u0437\u0434\u0430\u0442\u044c utils.py \u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u0441\u0442\u0438\u0442\u044c \u0442\u0443\u0434\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n-\n access_for_all = asyncio.get_event_loop().run_until_complete(get_access_for_all())\n-\n-\ndiff --git a\/middlewares\/ExpMiddleware.py b\/middlewares\/ExpMiddleware.py\nindex f092629..61616d7 100644\n--- a\/middlewares\/ExpMiddleware.py\n+++ b\/middlewares\/ExpMiddleware.py\n@@ -3,7 +3,7 @@\n \n from config import NEW_START\n from global_settings import BOT\n-from utils.main import check_or_create\n+from utils.db_methods import check_or_create\n from models import Car, User\n \n \ndiff --git a\/models.py b\/models.py\nindex b0dc3d8..7caf1fc 100644\n--- a\/models.py\n+++ b\/models.py\n@@ -5,7 +5,7 @@\n class User(Model):\r\n     id = fields.IntField(pk=True)\r\n     user_id = fields.IntField()\r\n-    peer_id = fields.IntField() #NOTE: \u0440\u0430\u0437\u043d\u044b\u0439 peer_id?\r\n+    chat = fields.ForeignKeyField('models.Conversation', related_name=\"chat\")\r\n     coins = fields.IntField(default=100)\r\n     energy = fields.IntField(default=4)\r\n     warns = fields.IntField(default=0)\r\ndiff --git a\/routes\/actions.py b\/routes\/actions.py\nindex af949eb..faa00ca 100644\n--- a\/routes\/actions.py\n+++ b\/routes\/actions.py\n@@ -1,11 +1,8 @@\n-import random\n import sys\n from typing import Optional\n \n from vkbottle.bot import Blueprint\n \n-from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT\n-from global_settings import *\n from models import Conversation, User\n from rules import *\n \n@@ -15,13 +12,7 @@\n \n @bp.on.chat_invite()\n async def invite_message(action: Message, _: Optional[User] = None):\n-    await BOT.api.request(\n-        \"messages.send\",\n-        {\n-            \"message\": '\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u044f \u043e\u0442\u0432\u0435\u0447\u0430\u043b \u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \"\u0414\u043e\u0441\u0442\u0443\u043f \u043a\u043e \u0432\u0441\u0435\u0439 \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u043a\u0435\". '\n-                       '\u0414\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a\u043e \u0432\u0441\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \u043f\u0440\u0430\u0432\u0430 \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\"',\n-            \"random_id\": random.randint(MIN_RANDOM_ID_INT, MAX_RANDOM_ID_INT),\n-            \"peer_id\": action.peer_id,\n-        },\n-    )\n+    await action('\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u044f \u043e\u0442\u0432\u0435\u0447\u0430\u043b \u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \"\u0414\u043e\u0441\u0442\u0443\u043f \u043a\u043e \u0432\u0441\u0435\u0439 \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u043a\u0435\". '\n+                 '\u0414\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a\u043e \u0432\u0441\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \u043f\u0440\u0430\u0432\u0430 \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\"')\n+\n     await Conversation(peer_id=action.peer_id).save()\ndiff --git a\/routes\/admin_realize.py b\/routes\/admin_realize.py\nindex 150d84c..48a633d 100644\n--- a\/routes\/admin_realize.py\n+++ b\/routes\/admin_realize.py\n@@ -6,7 +6,8 @@\n from global_settings import *\n from models import User\n from rules import *\n-from utils.main import is_mention, check_or_create\n+from utils.errors import WrongWarnsCountException\n+from utils.main import get_user_from_mention, give_warns\n \n sys.path.append(\"..\")\n bp = Blueprint(name=\"Working with admin functions\")\n@@ -16,7 +17,8 @@\n async def bot_ban_message(message: Message, _: Optional[User] = None):\n     if message.reply_message:\n         await message(\n-            f\"\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u0415 \u0411\u0410\u041d \u041f\u041e\u041b\u042c\u0417\u041e\u0412\u0410\u0422\u0415\u041b\u042f \u0421 ID {message.reply_message.from_id}! \u041d\u0410\u041f\u0418\u0428\u0418\u0422\u0415 '\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c' (\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418 \u0411\u0423\u041a\u0412\u0410\u041c\u0418) \u0414\u041b\u042f \u0422\u041e\u0413\u041e, \u0427\u0422\u041e\u0411\u042b \u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c, \u0418\u041b\u0418 '\u0412\u042b\u0419\u0422\u0418' (\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418), \u0427\u0422\u041e\u0411\u042b \u0412\u042b\u0419\u0422\u0418 \u0418\u0417 \u042d\u0422\u041e\u0413\u041e \u041c\u0415\u041d\u042e!\"\n+            f\"\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u0415 \u0411\u0410\u041d \u041f\u041e\u041b\u042c\u0417\u041e\u0412\u0410\u0422\u0415\u041b\u042f \u0421 ID {message.reply_message.from_id}! \u041d\u0410\u041f\u0418\u0428\u0418\u0422\u0415 '\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c' (\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418 \"\n+            f\"\u0411\u0423\u041a\u0412\u0410\u041c\u0418) \u0414\u041b\u042f \u0422\u041e\u0413\u041e, \u0427\u0422\u041e\u0411\u042b \u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c, \u0418\u041b\u0418 '\u0412\u042b\u0419\u0422\u0418' (\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418), \u0427\u0422\u041e\u0411\u042b \u0412\u042b\u0419\u0422\u0418 \u0418\u0417 \u042d\u0422\u041e\u0413\u041e \u041c\u0415\u041d\u042e! \"\n         )\n         await BOT.branch.add(\n             message.peer_id,\n@@ -52,115 +54,38 @@ async def bot_ban_branch(message: Message, user_id, admin_id):\n \n @bp.on.chat_message(OnlyAdminAccess(), text=\"\/\u043f\u0440\u0435\u0434 <mention> <count>\", lower=True)\n async def warn_with_mention_message(message: Message, _: Optional[User] = None, mention: str = None, count: str = None):\n-    # Checking for mention\n-    if (is_mention(mention))[0]:\n-        mention = (is_mention(mention))[1]\n-    else:\n-        await message(\"\u042f \u043d\u0435 \u0432\u0438\u0436\u0443 \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f! \u0423\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e!\")\n-        return\n-\n-    # Checking for number-count of warnings\n-    if (not count.isdigit()) and not (count.startswith(\"-\") and count[1:].isdigit()):\n-        await message(\"\u0422\u0435\u043a\u0441\u0442 \u0432\u043c\u0435\u0441\u0442\u043e \u0446\u0438\u0444\u0440\u044b?.. \u041c-\u0434\u0430...\")\n-    else:\n+    mention = get_user_from_mention(mention)\n+    if not mention:\n+        await message(\"\u0423\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e\")\n+        return None\n+\n+    try:\n         count = int(count)\n-        # Checking for count of giving warnings\n-        if count > 4:\n-            await message(\n-                \"\u0414\u0430 \u043a\u0443\u0434\u0430 \u0442\u044b \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u043b\u0441\u044f, \u0431\u043e\u043b\u044c\u0448\u0435 4 \u0432\u0430\u0440\u043d\u043e\u0432 \u043a\u0438\u0434\u0430\u0442\u044c \u0447\u0443\u0432\u0430\u043a\u0443, \u0442\u0443\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 4 \u0432\u0430\u0440\u043d\u0430 \u0435\u0441\u0442\u044c\"\n-            )\n-        else:\n-            user_mention = await User.get_or_none(\n-                user_id=mention, peer_id=message.peer_id\n-            )\n-            if user_mention is None and count < 0:\n-                await check_or_create(mention, message.peer_id)\n-                await message(\n-                    \"\u041d\u0443 \u043d\u0435\u0442 \u0443 \u044d\u0442\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u0435\u0434\u043e\u0432. \u041d\u0443 \u043d\u0435 \u043c\u043e\u0433\u0443 \u044f \u0437\u0430\u0431\u0440\u0430\u0442\u044c \u0442\u043e, \u0447\u0435\u0433\u043e \u041d\u0415\u0422\u0423!!\"\n-                )\n-            elif user_mention is None and count > 0:\n-                await check_or_create(message.from_id, message.peer_id, count)\n-                await message(\n-                    f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0441 ID {mention}, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e: {count}\"\n-                )\n-            elif user_mention is not None:\n-                await check_or_create(message.from_id, message.peer_id)\n-                current_warns = user_mention.warns\n-                if current_warns + count < 0:\n-                    await message(\n-                        f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u041d\u0415 \u0432\u044b\u0434\u0430\u043d\u043e, \u0442.\u043a. \u043f\u0440\u0438 \u0437\u0430\u0431\u0438\u0440\u0430\u043d\u0438\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u043a\u043e\u043b-\u0432\u0430 \u0432\u0430\u0440\u043d\u043e\u0432 \u0443 \u043d\u0435\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u043c\u0435\u043d\u044c\u0448\u0435 0 \"\n-                        f\"\u0432\u0430\u0440\u043d\u043e\u0432, \u0447\u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432: {current_warns} \"\n-                    )\n-                else:\n-                    await User.get(\n-                        user_id=mention, peer_id=message.peer_id\n-                    ).update(warns=current_warns + count)\n-                    if current_warns + count >= 4:\n-                        await message(\n-                            f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e 4, \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0431\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f! \"\n-                            f\"\u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432: {current_warns + count} \"\n-                        )\n-                    else:\n-                        await message(\n-                            f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e: {current_warns + count}\"\n-                        )\n+\n+        user = await User.get_or_none(user_id=mention, peer_id=message.peer_id)\n+        await give_warns(message, user, count)\n+\n+    except ValueError:\n+        await message(\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0447\u0438\u0441\u043b\u043e\u043c, \u0447\u0442\u043e \u043b\u043e\u0433\u0438\u0447\u043d\u043e, \u043d\u043e, \u0432\u0438\u0434\u0438\u043c\u043e, \u043d\u0435\u0442. LoL\")\n+\n+    except WrongWarnsCountException:\n+        await message(\"\u041d\u0435\u0432\u0435\u0440\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u044b\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0445 \u0432\u0430\u0440\u043d\u043e\u0432\")\n \n \n @bp.on.chat_message(OnlyAdminAccess(), text=\"\/\u043f\u0440\u0435\u0434 <count>\", lower=True)\n async def warn_with_reply_message(message: Message, _: Optional[User] = None, count: str = None):\n-    if message.reply_message:\n-        # Checking for number-count of warnings\n-        if (not count.isdigit()) and not (\n-                count.startswith(\"-\") and count[1:].isdigit()\n-        ):\n-            await message(\"\u0422\u0435\u043a\u0441\u0442 \u0432\u043c\u0435\u0441\u0442\u043e \u0446\u0438\u0444\u0440\u044b?.. \u041c-\u0434\u0430...\")\n-        else:\n-            count = int(count)\n-            # Checking for count of giving warnings\n-            if count > 4:\n-                await message(\n-                    \"\u0414\u0430 \u043a\u0443\u0434\u0430 \u0442\u044b \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u043b\u0441\u044f, \u0431\u043e\u043b\u044c\u0448\u0435 4 \u0432\u0430\u0440\u043d\u043e\u0432 \u043a\u0438\u0434\u0430\u0442\u044c \u0447\u0443\u0432\u0430\u043a\u0443, \u0442\u0443\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 4 \u0432\u0430\u0440\u043d\u0430 \u0435\u0441\u0442\u044c\"\n-                )\n-            else:\n-                user_reply = await User.get_or_none(\n-                    user_id=message.reply_message.from_id, peer_id=message.peer_id\n-                )\n-                if user_reply is None and count < 0:\n-                    await check_or_create(message.reply_message.from_id, message.peer_id)\n-                    await message(\n-                        \"\u041d\u0443 \u043d\u0435\u0442 \u0443 \u044d\u0442\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u0435\u0434\u043e\u0432. \u041d\u0443 \u043d\u0435 \u043c\u043e\u0433\u0443 \u044f \u0437\u0430\u0431\u0440\u0430\u0442\u044c \u0442\u043e, \u0447\u0435\u0433\u043e \u041d\u0415\u0422\u0423!!\"\n-                    )\n-                elif user_reply is None and count > 0:\n-                    await check_or_create(\n-                        message.reply_message.from_id, message.peer_id, count\n-                    )\n-                    await message(\n-                        f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0441 ID {message.reply_message.from_id}, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e: {count}\"\n-                    )\n-                elif user_reply is not None:\n-                    await check_or_create(\n-                        message.reply_message.from_id, message.peer_id\n-                    )\n-                    current_warns = user_reply.warns\n-                    if current_warns + count < 0:\n-                        await message(\n-                            f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u041d\u0415 \u0432\u044b\u0434\u0430\u043d\u043e, \u0442.\u043a. \u043f\u0440\u0438 \u0437\u0430\u0431\u0438\u0440\u0430\u043d\u0438\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u043a\u043e\u043b-\u0432\u0430 \u0432\u0430\u0440\u043d\u043e\u0432 \u0443 \u043d\u0435\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u043c\u0435\u043d\u044c\u0448\u0435 0 \"\n-                            f\"\u0432\u0430\u0440\u043d\u043e\u0432, \u0447\u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432: {current_warns} \"\n-                        )\n-                    else:\n-                        await User.get(\n-                            user_id=message.reply_message.from_id,\n-                            peer_id=message.peer_id,\n-                        ).update(warns=current_warns + count)\n-                        if current_warns + count >= 4:\n-                            await message(\n-                                f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e 4, \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0431\u0430\u043d \"\n-                                f\"\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432: {current_warns + count} \"\n-                            )\n-                        else:\n-                            await message(\n-                                f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e: {current_warns + count}\"\n-                            )\n-\n-    else:\n-        await message(\"\u0425\u043e\u0442\u044c \u0431\u044b \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0442\u043e\u0433\u043e, \u043a\u043e\u0433\u043e \u0432\u0430\u0440\u043d\u0438\u0442\u044c \u043d\u0430\u0434\u043e, \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u043b \u0431\u044b\")\n+    if not message.reply_message:\n+        await message(\"\u041e\u0442\u0432\u0435\u0447\u0435\u043d\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e\")\n+        return None\n+\n+    try:\n+        count = int(count)\n+\n+        user = await User.get_or_none(user_id=message.reply_message.from_id, peer_id=message.peer_id)\n+        await give_warns(message, user, count)\n+\n+    except ValueError:\n+        await message(\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0447\u0438\u0441\u043b\u043e\u043c, \u0447\u0442\u043e \u043b\u043e\u0433\u0438\u0447\u043d\u043e, \u043d\u043e, \u0432\u0438\u0434\u0438\u043c\u043e, \u043d\u0435\u0442. LoL\")\n+\n+    except WrongWarnsCountException:\n+        await message(\"\u041d\u0435\u0432\u0435\u0440\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u044b\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0445 \u0432\u0430\u0440\u043d\u043e\u0432\")\ndiff --git a\/routes\/economic_realize.py b\/routes\/economic_realize.py\nindex 33f5d63..897de55 100644\n--- a\/routes\/economic_realize.py\n+++ b\/routes\/economic_realize.py\n@@ -7,6 +7,7 @@\n from vkbottle.bot import Blueprint\n \n from global_settings import *\n+from models import Work, User, Car\n from rules import *\n \n sys.path.append(\"..\")\n@@ -18,12 +19,8 @@ async def payouts():\n     conn = Tortoise.get_connection(\"default\")\n     time_unix = int(datetime.datetime.now().timestamp() - 86400)\n \n-    #TODO: \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u0430 SQL-\u0438\u043d\u044a\u0435\u043a\u0446\u0438\u044f. \u041f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u0442\u044c, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f values\n-    #users = await conn.execute_query_dict(\n-    #    \"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= ?\", [time_unix]\n-    #)\n     users = await conn.execute_query_dict(\n-        f\"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= {time_unix}\"\n+        \"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= ?\", [time_unix]\n     )\n     for user in users:\n         work = await Work.get(id=user[\"work_id_id\"])\n@@ -53,7 +50,7 @@ async def give_job(message: Message, _: Optional[User] = None, j_id: str = None)\n     if j_id.isdigit():\n         j_id = int(j_id)\n         work = await Work.get(id=j_id)\n-        #TODO: \u0437\u0430\u0442\u0435\u0441\u0442\u0438\u0442\u044c\n+        # TODO: \u0437\u0430\u0442\u0435\u0441\u0442\u0438\u0442\u044c\n         await User.get(user_id=message.from_id, peer_id=message.peer_id).update(\n             work_id=work, job_lp=int(datetime.datetime.now().timestamp())\n         )\n@@ -92,7 +89,7 @@ async def buy_car(message: Message, user: Optional[User] = None, c_id: str = Non\n             await User.get(user_id=message.from_id, peer_id=message.peer_id).update(\n                 coins=user.coins - car.cost, car=car\n             )\n-            #TODO: \u0440\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u044b\u043d\u0435\u0441\u0442\u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n+            # TODO: \u0440\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u044b\u043d\u0435\u0441\u0442\u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n             await message(f\"\u041c\u0430\u0448\u0438\u043d\u0430 {car} \u043a\u0443\u043f\u043b\u0435\u043d\u0430!\")\n         elif user.coins < car.cost:\n             await message(\"\u0423 \u0442\u0435\u0431\u044f \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0434\u0435\u043d\u0435\u0433!\")\n@@ -108,7 +105,7 @@ async def buy_car(message: Message, user: Optional[User] = None, c_id: str = Non\n async def sell_car(message: Message, user: Optional[User] = None):\n     if user.car_id is not None:\n         car_cost = (await Car.get(id=user.car_id)).cost\n-        #TODO: \u0447\u0438\u0441\u043b\u043e 0.1 \u0432 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443\n+        # TODO: \u0447\u0438\u0441\u043b\u043e 0.1 \u0432 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443\n         car_cost = car_cost - (car_cost * 0.1)\n         await User.get(user_id=message.from_id, peer_id=message.peer_id).update(\n             coins=user.coins + car_cost, car_id=None\ndiff --git a\/routes\/global_admin_realize.py b\/routes\/global_admin_realize.py\nindex 4d7525d..7fec073 100644\n--- a\/routes\/global_admin_realize.py\n+++ b\/routes\/global_admin_realize.py\n@@ -2,14 +2,17 @@\n import sys\n from typing import Optional\n \n-from tortoise import Tortoise\n+import ujson\n from vkbottle.bot import Blueprint\n \n-from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT\n from global_settings import *\n-from models import Conversation, User, Work\n+from models import Conversation, User\n from rules import *\n+from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT, DatabaseActions, BOT_CREATOR_ID, AccessingLevels\n+from utils.db_methods import add_or_remove_model, give_or_take_access\n+from utils.errors import DatabaseDeleteException, DatabaseAddException, ParseMentionException\n from utils.main import is_mention\n+import numexpr as ne\n \n sys.path.append(\"..\")\n bp = Blueprint(name=\"Working with global admin functions\")\n@@ -33,228 +36,94 @@ async def send_messages(message: Message, _: Optional[User] = None, text: str =\n \n @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c_\u0441\u0435\u0431\u044f\")\n async def get_myself(message: Message, _: Optional[User] = None):\n-    conn = Tortoise.get_connection(\"default\")\n-    # TODO: \u043f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u0442\u044c dct, \u043c\u0430\u0433\u0438\u0447\u0435\u0441\u043a\u0438 \u0446\u0438\u0444\u0440\u044b \u0432 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443\n-    # dct = await conn.execute_query_dict(\n-    #    \"SELECT * FROM `users` WHERE `user_id` = 500101793\"\n-    # )\n-    dct = await User.get(user_id=500101793)\n-    await message(dct)\n+    user = str(await User.get(user_id=BOT_CREATOR_ID))\n+    await message(user)\n \n \n-# TODO: \u043d\u0443\u0436\u043d\u043e \u043b\u0438?\n+# NOTE: \u043d\u0443\u0436\u043d\u043e \u043b\u0438?\n @bp.on.message_handler(OnlyBotModerAccess(), text=\"\/mention <mention>\", lower=True)\n async def mention_test(message: Message, _: Optional[User] = None, mention: str = None):\n-    print(mention.split(\"|\")[0][1:])\n+    # print(mention.split(\"|\")[0][1:])\n     await message(\"[id{0}|Maxim]\".format(message.from_id))\n \n \n @bp.on.message_handler(OnlyBotModerAccess(), text=\"~ <text>\", lower=True)\n async def print_or_count(message: Message, _: Optional[User] = None, text: str = None):\n     try:\n-        text = text.replace(\" \", \"\")\n-        copied_text = text\n-\n-        # TODO: \u0432 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443 \u0432 config.py\n-        allowed_words = []\n-        allowed_words.extend([str(a) for a in range(10)])\n-        allowed_words.extend(\n-            [\n-                \"sin\",\n-                \"sqrt\",\n-                \"+\",\n-                \"-\",\n-                \"j\",\n-                \"*\",\n-                \"\/\",\n-                \"(\",\n-                \")\",\n-                \"cos\",\n-                \"tan\",\n-                \"e\",\n-                \"pi\",\n-                \"ceil\",\n-                \"copysign\",\n-                \"fabs\",\n-                \"factorial\",\n-                \"floor\",\n-                \"fmod\",\n-                \"frexp\",\n-                \"ldexp\",\n-                \"fsum\",\n-                \"isfinite\",\n-                \"isinf\",\n-                \"isnan\",\n-                \"modf\",\n-                \"trunc\",\n-                \"exp\",\n-                \"expm1\",\n-                \"log\",\n-                \"log1p\",\n-                \"log10\",\n-                \"log2\",\n-                \"pow\",\n-                \"acos\",\n-                \"asin\",\n-                \"atan\",\n-                \"atan2\",\n-                \"hypot\",\n-                \"degrees\",\n-                \"radians\",\n-                \"cosh\",\n-                \"sinh\",\n-                \"tanh\",\n-                \"**\",\n-                \"acosh\",\n-                \"asinh\",\n-                \"atanh\",\n-                \"gamma\",\n-                \"lgamma\",\n-            ]\n-        )\n-        awset = set(allowed_words)\n-\n-        for i in awset:\n-            if i in copied_text:\n-                copied_text = copied_text.replace(i, \"\")\n-\n-        if copied_text == \"\":\n-            all_good = True\n-        else:\n-            all_good = False\n-\n-        if all_good:\n-            # TODO: \u0442\u0435\u0441\u0442\u044b \u0434\u043b\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u0435\u0432\u0430\u043b\u0430 \u043d\u0430 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u044c !!!\n-            summ = eval(text)\n-            await message(summ)\n-        else:\n-            await message(text)\n+        summ = ne.evaluate(text).item()\n+        await message(summ)\n \n     except ZeroDivisionError:\n-        await message(\"+-inf\")\n+        await message(\"\u0414\u0435\u043b\u0438\u0442\u044c \u043d\u0430 0 \u043d\u0435\u043b\u044c\u0437\u044f!\")\n     except Exception:\n         await message(text)\n \n \n-# TODO: \u0432\u044b\u0434\u0435\u043b\u0438\u0442\u044c \u0445\u0435\u0440\u043e\u0442\u0443 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c \"\u0440\u043e\u043b\u044c\"\n @bp.on.message_handler(OnlyBotAdminAccess(), text=\"\/\u0441\u043d\u044f\u0442\u044c_\u043c\u043e\u0434\u0435\u0440 <mention>\", lower=True)\n async def delete_bot_moder(message: Message, mention: str, _: Optional[User] = None):\n-    if (is_mention(mention))[0]:\n-        mention = (is_mention(mention))[1]\n-\n-    else:\n+    try:\n+        result = await give_or_take_access(AccessingLevels.MODERATOR, DatabaseActions.REMOVE, mention)\n+    except ParseMentionException:\n         await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043d\u044f\u0442\u044c \u043c\u043e\u0434\u0435\u0440\u043a\u0443!\")\n-        return\n-\n-    global_role_default = await GlobalRole.get(name=\"Default\")\n-    await GlobalUser.get(user_id=mention).update(\n-        global_role=global_role_default\n-    )\n-    await message(\"\u041c\u043e\u0434\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0441\u043d\u044f\u0442\u0430!\")\n+    else:\n+        await message(result)\n \n \n @bp.on.message_handler(OnlyBotAdminAccess(), text=\"\/\u0434\u0430\u0442\u044c_\u043c\u043e\u0434\u0435\u0440 <mention>\", lower=True)\n async def give_bot_moder(message: Message, mention: str, _: Optional[User] = None):\n-    if (is_mention(mention))[0]:\n-        mention = (is_mention(mention))[1]\n-\n+    try:\n+        result = await give_or_take_access(AccessingLevels.MODERATOR, DatabaseActions.ADD, mention)\n+    except ParseMentionException:\n+        await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u0430\u0442\u044c \u043c\u043e\u0434\u0435\u0440\u043a\u0443!\")\n     else:\n-        await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u0430\u0442\u044c \u043f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430!\")\n-        return\n-\n-    global_role_moder = await GlobalRole.get(name=\"Moderator\")\n-    await GlobalUser.get(user_id=mention).update(\n-        global_role=global_role_moder\n-    )\n-    await message(\"\u041f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0432\u044b\u0434\u0430\u043d\u044b!\")\n+        await message(result)\n \n \n @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0434\u0430\u0442\u044c_\u0430\u0434\u043c\u0438\u043d <mention>\", lower=True)\n async def give_bot_admin(message: Message, _: Optional[User] = None, mention: str = None):\n-    if (is_mention(mention))[0]:\n-        mention = (is_mention(mention))[1]\n-\n+    try:\n+        result = await give_or_take_access(AccessingLevels.ADMINISTRATOR, DatabaseActions.ADD, mention)\n+    except ParseMentionException:\n+        await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u0430\u0442\u044c \u0430\u0434\u043c\u0438\u043d\u043a\u0443\")\n     else:\n-        await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u0430\u0442\u044c \u043f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430!\")\n-        return\n-\n-    global_role_moder = await GlobalRole.get(name=\"Administrator\")\n-    await GlobalUser.get(user_id=mention).update(\n-        global_role=global_role_moder\n-    )\n-    await message(\"\u041f\u0440\u0430\u0432\u0430 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0432\u044b\u0434\u0430\u043d\u044b!\")\n+        await message(result)\n \n \n @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0441\u043d\u044f\u0442\u044c_\u0430\u0434\u043c\u0438\u043d <mention>\", lower=True)\n async def delete_bot_admin(message: Message, _: Optional[User] = None, mention: str = None):\n-    if (is_mention(mention))[0]:\n-        mention = (is_mention(mention))[1]\n-\n-    else:\n+    try:\n+        result = await give_or_take_access(AccessingLevels.ADMINISTRATOR, DatabaseActions.REMOVE, mention)\n+    except ParseMentionException:\n         await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043d\u044f\u0442\u044c \u0430\u0434\u043c\u0438\u043d\u043a\u0443!\")\n-        return\n-\n-    global_role_default = await GlobalRole.get(name=\"Default\")\n-    await GlobalUser.get(user_id=mention).update(\n-        global_role=global_role_default\n-    )\n-    await message(\"\u0410\u0434\u043c\u0438\u043d\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0441\u043d\u044f\u0442\u0430!\")\n+    else:\n+        await message(result)\n \n \n-# TODO: \u0412\u044b\u0434\u0435\u043b\u0438\u0442\u044c \u0432 \u043c\u0435\u0442\u043e\u0434 \u0434\u0432\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u044f\n @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0431\u0434 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c <model_name> <value>\")\n async def add_to_db(message: Message, _: Optional[User] = None, model_name: str = None, value: str = None):\n-    # TODO: \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u043a \u0441\u043b\u043e\u0432\u0430\u0440\u044e\n-    value = eval(value)\n-    if model_name == \"GlobalRole\":\n-        returnable = await GlobalRole(name=value[\"name\"]).save()\n-    elif model_name == \"GlobalUser\":\n-        returnable = await GlobalUser(\n-            user_id=value[\"user_id\"], global_role=value[\"global_role\"]\n-        ).save()\n-    elif model_name == \"User\":\n-        returnable = await User(**value).save()\n-    elif model_name == \"Conversation\":\n-        returnable = await Conversation(**value).save()\n-    elif model_name == \"Work\":\n-        returnable = await Work(**value).save()\n-    elif model_name == \"Car\":\n-        returnable = await Car(**value).save()\n-\n-    await message(str(returnable))\n+    try:\n+        result = await add_or_remove_model(model_name, value, DatabaseActions.ADD)\n+    except DatabaseAddException:\n+        await message(\"\u041d\u0435\u0442 \u0442\u0430\u043a\u043e\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u044b!\")\n+    else:\n+        await message(result)\n \n \n-@bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0431\u0434 \u0443\u0434\u0430\u043b\u0438\u0442\u044c <model> <value>\")\n-async def delete_from_db(message: Message, _: Optional[User] = None, model: str = None, value: str = None):\n+@bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0431\u0434 \u0443\u0434\u0430\u043b\u0438\u0442\u044c <model_name> <value>\")\n+async def delete_from_db(message: Message, _: Optional[User] = None, model_name: str = None, value: str = None):\n     try:\n-        # TODO: \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u043a \u0441\u043b\u043e\u0432\u0430\u0440\u044e\n-        value = eval(value)\n-        if model == \"GlobalRole\":\n-            await GlobalRole.get(name=value[\"name\"]).delete()\n-        elif model == \"GlobalUser\":\n-            await GlobalUser.get(\n-                user_id=value[\"user_id\"], global_role=value[\"global_role\"]\n-            ).delete()\n-        elif model == \"User\":\n-            await User.get(**value).delete()\n-        elif model == \"Conversation\":\n-            await Conversation.get(**value).delete()\n-        elif model == \"Work\":\n-            await Work.get(**value).delete()\n-        elif model == \"Car\":\n-            await Car.get(**value).delete()\n-\n-        await message(\"\u0423\u0434\u0430\u043b\u0435\u043d\u043e!\")\n-    except Exception as _:\n+        result = await add_or_remove_model(model_name, value, DatabaseActions.REMOVE)\n+    except DatabaseDeleteException:\n         await message(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f!\")\n+    else:\n+        await message(result)\n \n \n-# TODO: \u0438\u0441\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u043c\u0435\u0442\u043e\u0434\n @bp.on.message_handler(OnlyBotModerAccess(), text=\"\/\u0434\u043e\u0441\u0442\u0443\u043f\", lower=True)\n async def access_message(message: Message, _: Optional[User] = None):\n-    global access_for_all  # ?\n+    access_for_all: bool = await get_access_for_all()\n     access_for_all = not access_for_all\n-    with open(\"settings.json\", \"w\") as write_file:\n+    with open(\"..\/settings.json\", \"w\") as write_file:\n         ujson.dump({\"access\": access_for_all}, write_file)\n \n     if access_for_all:\ndiff --git a\/routes\/users_realize.py b\/routes\/users_realize.py\nindex d20833d..f061e24 100644\n--- a\/routes\/users_realize.py\n+++ b\/routes\/users_realize.py\n@@ -1,15 +1,16 @@\n import os\n-import random\n import sys\n from typing import Optional\n \n import aiohttp\n+import ujson\n from vkbottle.bot import Blueprint\n \n from global_settings import *\n from models import User\n from rules import *\n-from utils.main import check_or_create, make_profile_photo\n+from utils.db_methods import check_or_create\n+from utils.main import make_profile_photo, send_with_bomb, create_poll, is_replied_self\n \n sys.path.append(\"..\")\n bp = Blueprint(name=\"Working with users functions\")\n@@ -22,34 +23,12 @@ async def hi_message(ans: Message, _: Optional[User] = None):\n \n @bp.on.message_handler(AccessForAllRule(), text=\"\u043c\u0430\u043a\u0441\u0438\u043c\", lower=True)\n async def maxim_message(ans: Message, _: Optional[User] = None):\n-    #TODO: \u0432\u0437\u044f\u0442\u044c 2e9 \u0438\u0437 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\n-    #TODO: \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 - \u0432 \u043e\u0442\u0435\u0434\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n-    await USER.api.request(\n-        \"messages.send\",\n-        {\n-            \"message\": \"\u041c\u0430\u043a\u0441\u0438\u043c \u0430\u0434\u043c\u0438\u043d \u0442\u0443\u0442 \u0434\u0430 \u0430\u0433\u0430 \u0431\u043e\u0442\u0430 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0431\u0435\u0441\u0435\u0434\u0435 \u043f\u043e\u0432\u0435\u043b\u0438\u0432\u0430\u0442\u0435\u043b\u044c \u0430\u0433\u0430 \u0434\u0430 \u043c-\u0434\u0430...\",\n-            \"group_id\": BOT.group_id,\n-            \"peer_id\": ans.peer_id,\n-            \"expire_ttl\": \"20\",\n-            \"random_id\": random.randint(-2e9, 2e9),\n-        },\n-    )\n+    await send_with_bomb(\"\u041c\u0430\u043a\u0441\u0438\u043c \u0430\u0434\u043c\u0438\u043d \u0442\u0443\u0442 \u0434\u0430 \u0430\u0433\u0430 \u0431\u043e\u0442\u0430 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0431\u0435\u0441\u0435\u0434\u0435 \u043f\u043e\u0432\u0435\u043b\u0438\u0432\u0430\u0442\u0435\u043b\u044c \u0430\u0433\u0430 \u0434\u0430 \u043c-\u0434\u0430...\", ans.peer_id)\n \n \n @bp.on.message_handler(AccessForAllRule(), text=\"\u043c\u0434\u0430\", lower=True)\n async def mda_message(ans: Message, _: Optional[User] = None):\n-    #TODO: \u0432\u0437\u044f\u0442\u044c 2e9 \u0438\u0437 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\n-    #TODO: \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 - \u0432 \u043e\u0442\u0435\u0434\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n-    await USER.api.request(\n-        \"messages.send\",\n-        {\n-            \"message\": \"\u0414\u0430 \u043c\u0434\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e \u044d\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043c\u0434\u0430 \u0447\u0442\u043e \u043f\u0440\u044f\u043c\u043e \u043c-\u0434\u0430...\",\n-            \"group_id\": BOT.group_id,\n-            \"peer_id\": ans.peer_id,\n-            \"expire_ttl\": \"20\",\n-            \"random_id\": random.randint(-2e9, 2e9),\n-        },\n-    )\n+    await send_with_bomb(\"\u0414\u0430 \u043c\u0434\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e \u044d\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043c\u0434\u0430 \u0447\u0442\u043e \u043f\u0440\u044f\u043c\u043e \u043c-\u0434\u0430...\", ans.peer_id)\n \n \n @bp.on.message_handler(AccessForAllRule(), text=[\"\/\u043f\u0440\u043e\u0444\u0438\u043b\u044c\", \"\/profile\"], lower=True)\n@@ -78,94 +57,28 @@ async def profile_message(message: Message, profile: Optional[User] = None):\n     await message(attachment=f\"photo{photo_object[0].owner_id}_{photo_object[0].id}\")\n \n \n-#TODO: \u0440\u0430\u0441\u043f\u0438\u043b\u0438\u0442\u044c \u0432\u0441\u0451 \u043d\u0430 \u043c\u0435\u0442\u043e\u0434\u044b\n-@bp.on.chat_message(AccessForAllRule(), text=\"\/\u0432\u0441\u0435\u043f\u0440\u0435\u0434\u044b\", lower=True)\n-async def watch_all_warns(message: Message, user: Optional[User] = None):\n-    if not message.reply_message:\n-        if user.warns == 0:\n-\n-            await message(\n-                f\"\u0423 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.from_id} \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u044f!\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e!\"\n-            )\n-        else:\n-            await message(\n-                f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439 \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.from_id}: {user.warns}\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \"\n-                f\"\u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \"\n-            )\n-\n-    if (\n-            message.from_id not in ADMINS_IN_CONV\n-            and message.reply_message.from_id != message.from_id\n-    ):\n-        await message(\n-            \"\u0422\u0435\u0431\u0435 \u0434\u043e\u0441\u0442\u0443\u043f \u0441\u044e\u0434\u0430 \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d, \u043f\u043e\u043d\u0438\u043c\u0430\u0435\u0448\u044c? \u041d\u0430\u0434\u0435\u044e\u0441\u044c, \u0434\u0430. **\u0422\u0438\u0445\u043e* \u041e\u043f\u044f\u0442\u044c \u044d\u0442\u0438 \u0434\u0430\u0443\u043d\u044b \u043c\u0435\u043d\u044f \u043d\u0435 \u043f\u043e \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u044e\u0437\u0430\u044e\u0442* \"\n-            \":(\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \"\n-        )\n-    else:\n-        await check_or_create(message.reply_message.from_id, message.peer_id)\n-        user_from_message = await User.get_or_none(\n-            user_id=message.reply_message.from_id, peer_id=message.peer_id\n-        )\n-        if user_from_message is not None and user_from_message.warns != 0:\n-            await message(\n-                f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439 \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.reply_message.from_id}: \"\n-                f\"{user_from_message.warns}\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e!\"\n-            )\n-        else:\n-            if user_from_message is None:\n-                await User(\n-                    user_id=message.reply_message.from_id, peer_id=message.peer_id\n-                ).save()\n-            await message(\n-                f\"\u0423 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.reply_message.from_id} \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u044f!\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \"\n-                f\"\u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \"\n-            )\n-\n-\n-#TODO: \u0432\u0437\u044f\u0442\u044c \u0438\u0437 \u043c\u0435\u0442\u043e\u0434\u0430\n @bp.on.message_handler(AccessForAllRule(), text=[\"\/\u043f\u043e\u043c\u043e\u0449\u044c\", \"\/help\"], lower=True)\n async def help_message(message: Message, _: Optional[User] = None):\n-    await USER.api.request(\n-        \"messages.send\",\n-        {\n-            \"message\": \"\u041f\u0440\u0438\u0432\u0435\u0442 - \u0438 \u0442\u0435\u0431\u0435 \u043f\u0440\u0438\u0432\u0435\u0442!\\n\u041c\u0430\u043a\u0441\u0438\u043c - \u043e\u043d \u0442\u0443\u0442 \u0430\u0434\u043c\u0438\u043d\\n\/\u043f\u0440\u0435\u0434 - (\u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u0432!) \u0432\u044b\u0434\u0430\u0442\u044c \"\n-                       \"\u043f\u0440\u0435\u0434. \u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u044e\u0437\u0435\u0440\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u043d\u0430\u0434\u043e \u0434\u0430\u0442\u044c \u043f\u0440\u0435\u0434\\n\/\u0432\u0441\u0435\u043f\u0440\u0435\u0434\u044b - \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0432\u0441\u0435 \"\n-                       \"\u043f\u0440\u0435\u0434\u044b. \u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\u043c \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440 \u043f\u0440\u0435\u0434\u043e\u0432 \u0432\u0441\u0435\u0445 \u044e\u0437\u0435\u0440\u043e\u0432, \u043e\u0431\u044b\u0447\u043d\u044b\u043c \u044e\u0437\u0435\u0440\u0430\u043c - \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0432\u043e\u0438\u0445. \"\n-                       \"\u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u043f\u0440\u0435\u0434\u044b \u0447\u044c\u0435\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c\\n\/voteban \u0441 \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u043d\u043d\u044b\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435\u043c - \"\n-                       \"\u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\\n\/\u0438\u043d\u0444\u043e\u0434\u043e\u0441\u0442\u0443\u043f - \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u043b\u0438 \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \"\n-                       \"\u0432 \u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442\\n\/\u043f\u0440\u043e\u0444\u0438\u043b\u044c - \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0441\u0432\u043e\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c\\n\/\u043a\u043e\u043d\u0442\u0430\u043a\u0442\u044b - \u0441\u0441\u044b\u043b\u043a\u0438 \u043d\u0430 \u0441\u0432\u044f\u0437\u044c \u0441 \"\n-                       \"\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c\",\n-            \"group_id\": BOT.group_id,\n-            \"peer_id\": message.peer_id,\n-            \"expire_ttl\": \"120\",\n-            \"random_id\": random.randint(int(-2e9), int(2e9)),\n-        },\n-    )\n+    await send_with_bomb(\"\u041f\u0440\u0438\u0432\u0435\u0442 - \u0438 \u0442\u0435\u0431\u0435 \u043f\u0440\u0438\u0432\u0435\u0442!\\n\u041c\u0430\u043a\u0441\u0438\u043c - \u043e\u043d \u0442\u0443\u0442 \u0430\u0434\u043c\u0438\u043d\\n\/\u043f\u0440\u0435\u0434 - (\u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u0432!) \u0432\u044b\u0434\u0430\u0442\u044c \"\n+                         \"\u043f\u0440\u0435\u0434. \u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u044e\u0437\u0435\u0440\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u043d\u0430\u0434\u043e \u0434\u0430\u0442\u044c \u043f\u0440\u0435\u0434\\n\/\u0432\u0441\u0435\u043f\u0440\u0435\u0434\u044b - \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0432\u0441\u0435 \"\n+                         \"\u043f\u0440\u0435\u0434\u044b. \u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\u043c \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440 \u043f\u0440\u0435\u0434\u043e\u0432 \u0432\u0441\u0435\u0445 \u044e\u0437\u0435\u0440\u043e\u0432, \u043e\u0431\u044b\u0447\u043d\u044b\u043c \u044e\u0437\u0435\u0440\u0430\u043c - \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0432\u043e\u0438\u0445. \"\n+                         \"\u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u043f\u0440\u0435\u0434\u044b \u0447\u044c\u0435\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c\\n\/voteban \u0441 \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u043d\u043d\u044b\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435\u043c - \"\n+                         \"\u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\\n\/\u0438\u043d\u0444\u043e\u0434\u043e\u0441\u0442\u0443\u043f - \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u043b\u0438 \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \"\n+                         \"\u0432 \u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442\\n\/\u043f\u0440\u043e\u0444\u0438\u043b\u044c - \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0441\u0432\u043e\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c\\n\/\u043a\u043e\u043d\u0442\u0430\u043a\u0442\u044b - \u0441\u0441\u044b\u043b\u043a\u0438 \u043d\u0430 \u0441\u0432\u044f\u0437\u044c \u0441 \"\n+                         \"\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c\", message.peer_id, expire_ttl=\"120\")\n \n \n @bp.on.message_handler(AccessForAllRule(), text=\"\/voteban\", lower=True)\n async def voteban_message(message: Message, _: Optional[User] = None):\n     if message.reply_message:\n         await check_or_create(message.reply_message.from_id, message.peer_id)\n-        if (\n-                message.reply_message.from_id == message.from_id\n-                or message.reply_message.from_id in ADMINS_IN_CONV\n-                or message.reply_message.from_id == -BOT.group_id\n-        ):\n+        if is_replied_self(message):\n             await message(\"\u041f\u0440\u043e\u0441\u0442\u043e \u043f\u043e\u043f\u0440\u043e\u0441\u0438 \u0431\u0430\u043d\u0430 \u0441\u0435\u0431\u0435, \u0430\")\n \n         else:\n-            #TODO: \u0442\u043e\u0436\u0435 \u0438\u0437 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430\n-            poll = await USER.api.request(\n-                \"polls.create\",\n-                {\n-                    \"question\": f\"\u0413\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.reply_message.from_id}\",\n-                    \"is_anonymous\": 1,\n-                    \"is_multiply\": 0,\n-                    \"add_answers\": '[\"\u0417\u0430\",\"\u041f\u0440\u043e\u0442\u0438\u0432\"]',\n-                    \"disable_unvote\": 0,\n-                },\n-            )\n+            poll = await create_poll(f\"\u0413\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.reply_message.from_id}\",\n+                                     True, False, [\"\u0417\u0430\", \"\u041f\u0440\u043e\u0442\u0438\u0432\"], False)\n+\n             await message(attachment=f\"poll{poll['owner_id']}_{poll['id']}\")\n \n     else:\ndiff --git a\/utils\/consts.py b\/utils\/consts.py\nindex 52c7d2a..8bbc061 100644\n--- a\/utils\/consts.py\n+++ b\/utils\/consts.py\n@@ -1,5 +1,18 @@\n+from enum import Enum\n+\n MAX_RANDOM_ID_INT = int(2e9)\n MIN_RANDOM_ID_INT = int(-2e9)\n START_WRITE_POSITION_X = 30\n START_WRITE_POSITION_Y = 50\n BLACK_COLOR = (0, 0, 0)\n+BOT_CREATOR_ID = 500101793\n+\n+\n+class DatabaseActions(Enum):\n+    ADD = 0\n+    REMOVE = 1\n+\n+\n+class AccessingLevels(Enum):\n+    MODERATOR = \"\u041c\u043e\u0434\u0435\u0440\u043a\u0430\"\n+    ADMINISTRATOR = \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043a\u0430\"\ndiff --git a\/utils\/db_methods.py b\/utils\/db_methods.py\nnew file mode 100644\nindex 0000000..edd2845\n--- \/dev\/null\n+++ b\/utils\/db_methods.py\n@@ -0,0 +1,103 @@\n+import typing\n+\n+import ujson\n+\n+from models import User, GlobalUser, GlobalRole, Conversation, Work, Car\n+from utils.consts import DatabaseActions, AccessingLevels\n+from utils.errors import DatabaseDeleteException, DatabaseAddException, ParseMentionException\n+from utils.main import get_user_from_mention\n+\n+\n+async def check_or_create(\n+        user_id: int, peer_id: int, warns: int = 0\n+) -> typing.Tuple[User, GlobalUser]:\n+    \"\"\"\n+    check for user in current chat\n+    and global user in database\n+    \"\"\"\n+    profile = await User.get_or_none(user_id=user_id, peer_id=peer_id)\n+    if profile is None:\n+        await User(user_id=user_id, peer_id=peer_id, warns=warns).save()\n+        profile = await User.get(user_id=user_id, peer_id=peer_id)\n+\n+    global_profile = await GlobalUser.get_or_none(user_id=user_id)\n+    if global_profile is None:\n+        default_role = await GlobalRole.get(name=\"Default\")\n+        await GlobalUser(user_id=user_id, global_role=default_role).save()\n+        global_profile = GlobalUser.get(user_id=user_id)\n+\n+    return profile, global_profile\n+\n+\n+async def add_or_remove_model(model_name: str, value: str, action: DatabaseActions) -> str:\n+    value = await ujson.loads(value.replace(\"'\", '\"'))\n+    returnable = \"\"\n+    if action == DatabaseActions.ADD:\n+        if model_name == \"GlobalRole\":\n+            returnable = await GlobalRole(name=value[\"name\"]).save()\n+        elif model_name == \"GlobalUser\":\n+            returnable = await GlobalUser(\n+                user_id=value[\"user_id\"], global_role=value[\"global_role\"]\n+            ).save()\n+        elif model_name == \"User\":\n+            returnable = await User(**value).save()\n+        elif model_name == \"Conversation\":\n+            returnable = await Conversation(**value).save()\n+        elif model_name == \"Work\":\n+            returnable = await Work(**value).save()\n+        elif model_name == \"Car\":\n+            returnable = await Car(**value).save()\n+        else:\n+            raise DatabaseAddException(\"Addition error: no such model_name\")\n+\n+    elif action == DatabaseActions.REMOVE:\n+        try:\n+            if model_name == \"GlobalRole\":\n+                await GlobalRole.get(name=value[\"name\"]).delete()\n+            elif model_name == \"GlobalUser\":\n+                await GlobalUser.get(\n+                    user_id=value[\"user_id\"], global_role=value[\"global_role\"]\n+                ).delete()\n+            elif model_name == \"User\":\n+                await User.get(**value).delete()\n+            elif model_name == \"Conversation\":\n+                await Conversation.get(**value).delete()\n+            elif model_name == \"Work\":\n+                await Work.get(**value).delete()\n+            elif model_name == \"Car\":\n+                await Car.get(**value).delete()\n+\n+            returnable = \"\u0423\u0434\u0430\u043b\u0435\u043d\u043e!\"\n+        except Exception as _:\n+            raise DatabaseDeleteException(\"Deletion error\")\n+\n+    return str(returnable)\n+\n+\n+async def give_or_take_access(level_access: AccessingLevels, action: DatabaseActions, mention: str) -> str:\n+    mention = get_user_from_mention(mention)\n+    if not mention:\n+        raise ParseMentionException(\"\u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0432 \u0441\u0442\u0440\u043e\u043a\u0435\")\n+\n+    if action == DatabaseActions.REMOVE:\n+        global_role_default = await GlobalRole.get(name=\"Default\")\n+        await GlobalUser.get(user_id=mention).update(\n+            global_role=global_role_default\n+        )\n+        return f\"{level_access.name} \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0441\u043d\u044f\u0442\u0430!\"\n+\n+    elif action == DatabaseActions.ADD:\n+        if level_access == AccessingLevels.MODERATOR:\n+            global_role_moder = await GlobalRole.get(name=\"Moderator\")\n+            await GlobalUser.get(user_id=mention).update(\n+                global_role=global_role_moder\n+            )\n+        elif level_access == AccessingLevels.ADMINISTRATOR:\n+            global_role_moder = await GlobalRole.get(name=\"Administrator\")\n+            await GlobalUser.get(user_id=mention).update(\n+                global_role=global_role_moder\n+            )\n+\n+        return f\"{level_access.name} \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0432\u044b\u0434\u0430\u043d\u0430!\"\n+\n+\ndiff --git a\/utils\/errors.py b\/utils\/errors.py\nnew file mode 100644\nindex 0000000..0df0615\n--- \/dev\/null\n+++ b\/utils\/errors.py\n@@ -0,0 +1,14 @@\n+class DatabaseDeleteException(Exception):\n+    pass\n+\n+\n+class DatabaseAddException(Exception):\n+    pass\n+\n+\n+class ParseMentionException(Exception):\n+    pass\n+\n+\n+class WrongWarnsCountException(Exception):\n+    pass\n\\ No newline at end of file\ndiff --git a\/utils\/main.py b\/utils\/main.py\nindex 2692024..87252cd 100644\n--- a\/utils\/main.py\n+++ b\/utils\/main.py\n@@ -1,10 +1,17 @@\n+import random\n import typing\n \n import ujson\n from PIL import Image, ImageDraw, ImageFont\n+from vkbottle.types.message import Message\n \n+from config import ADMINS_IN_CONV\n+from global_settings import USER, BOT\n from models import User, GlobalUser, GlobalRole, Work, Car\n-from utils.consts import START_WRITE_POSITION_X, START_WRITE_POSITION_Y, BLACK_COLOR\n+from utils.consts import START_WRITE_POSITION_X, START_WRITE_POSITION_Y, BLACK_COLOR, MIN_RANDOM_ID_INT, \\\n+    MAX_RANDOM_ID_INT\n+from utils.db_methods import check_or_create\n+from utils.errors import WrongWarnsCountException\n \n \n def is_mention(mention: str) -> typing.Union[typing.Tuple[bool, int], typing.Tuple[bool, str]]:\n@@ -22,27 +29,6 @@ def is_mention(mention: str) -> typing.Union[typing.Tuple[bool, int], typing.Tup\n         return False, \"\"\n \n \n-async def check_or_create(\n-        user_id: int, peer_id: int, warns: int = 0\n-) -> typing.Tuple[User, GlobalUser]:\n-    \"\"\"\n-    check for user in current chat\n-    and global user in database\n-    \"\"\"\n-    profile = await User.get_or_none(user_id=user_id, peer_id=peer_id)\n-    if profile is None:\n-        await User(user_id=user_id, peer_id=peer_id, warns=warns).save()\n-        profile = await User.get(user_id=user_id, peer_id=peer_id)\n-\n-    global_profile = await GlobalUser.get_or_none(user_id=user_id)\n-    if global_profile is None:\n-        default_role = await GlobalRole.get(name=\"Default\")\n-        await GlobalUser(user_id=user_id, global_role=default_role).save()\n-        global_profile = GlobalUser.get(user_id=user_id)\n-\n-    return profile, global_profile\n-\n-\n async def get_access_for_all() -> bool:\n     with open(\"settings.json\", \"r\") as read_file:\n         data = ujson.load(read_file)\n@@ -84,3 +70,77 @@ async def make_profile_photo(user: User):\n     y += 35\n     draw.text((x, y), f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439: {user.warns}\", BLACK_COLOR, font=font)\n     img.save(f\"{user.user_id}.jpeg\")\n+\n+\n+def get_user_from_mention(mention: str) -> typing.Union[str, int]:\n+    if (is_mention(mention))[0]:\n+        mention = (is_mention(mention))[1]\n+\n+    else:\n+        return \"\"\n+\n+    return mention\n+\n+\n+async def send_with_bomb(text: str, peer_id: int, **kwargs):\n+    await USER.api.request(\n+        \"messages.send\",\n+        {\n+            \"message\": text,\n+            \"group_id\": BOT.group_id,\n+            \"peer_id\": peer_id,\n+            \"expire_ttl\": kwargs['ttl'] | \"20\",\n+            \"random_id\": random.randint(MIN_RANDOM_ID_INT, MAX_RANDOM_ID_INT),\n+        },\n+    )\n+\n+\n+async def create_poll(question: str, is_anonymous: bool,\n+                      is_multiply: bool, answers: typing.List[str], disable_unvote: bool) -> dict:\n+    poll = await USER.api.request(\n+        \"polls.create\",\n+        {\n+            \"question\": question,\n+            \"is_anonymous\": int(is_anonymous),\n+            \"is_multiply\": int(is_multiply),\n+            \"add_answers\": f'{answers}',\n+            \"disable_unvote\": int(disable_unvote),\n+        },\n+    )\n+\n+    return poll\n+\n+\n+def is_replied_self(message: Message) -> bool:\n+    if (\n+            message.reply_message.from_id == message.from_id\n+            or message.reply_message.from_id in ADMINS_IN_CONV\n+            or message.reply_message.from_id == -BOT.group_id\n+    ):\n+        return True\n+\n+    return False\n+\n+\n+async def give_warns(message: Message, user: typing.Optional[User], count: int) -> User:\n+    if user is None:\n+        if 4 >= count >= 0:\n+            await check_or_create(message.from_id, message.peer_id, count)\n+            user = await User.get(user_id=message.from_id, peer_id=message.peer_id)\n+            return user\n+\n+        else:\n+            raise WrongWarnsCountException(\"Wrong count of giving warns\")\n+\n+    else:\n+        if 4 >= user.warns + count >= 0:\n+            await User.get(\n+                user_id=user.user_id, peer_id=message.peer_id\n+            ).update(warns=user.warns + count)\n+\n+            user = await User.get(user_id=user.user_id, peer_id=message.peer_id)\n+\n+            return user\n+\n+        else:\n+            raise WrongWarnsCountException(\"Wrong count of giving warns\")\n","files":{"\/global_settings.py":{"changes":[{"diff":"\n \n from vkbottle import User as vkBottleUser, Bot\n \n-from config import ACCESS_TOKEN, USER_ACCESS_TOKEN\n+from config import ACCESS_TOKEN, USER_ACCESS_TOKEN, BOT_GROUP_ID\n from utils.main import get_access_for_all\n \n-BOT = Bot(ACCESS_TOKEN, loop=asyncio.get_event_loop(), group_id=196816306)\n+BOT = Bot(ACCESS_TOKEN, loop=asyncio.get_event_loop(), group_id=BOT_GROUP_ID)\n USER = vkBottleUser(USER_ACCESS_TOKEN)\n \n-#TODO: \u0441\u043e\u0437\u0434\u0430\u0442\u044c utils.py \u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u0441\u0442\u0438\u0442\u044c \u0442\u0443\u0434\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n-\n access_for_all = asyncio.get_event_loop().run_until_complete(get_access_for_all())\n-\n","add":2,"remove":5,"filename":"\/global_settings.py","badparts":["from config import ACCESS_TOKEN, USER_ACCESS_TOKEN","BOT = Bot(ACCESS_TOKEN, loop=asyncio.get_event_loop(), group_id=196816306)"],"goodparts":["from config import ACCESS_TOKEN, USER_ACCESS_TOKEN, BOT_GROUP_ID","BOT = Bot(ACCESS_TOKEN, loop=asyncio.get_event_loop(), group_id=BOT_GROUP_ID)"]}],"source":"\nimport asyncio from vkbottle import User as vkBottleUser, Bot from config import ACCESS_TOKEN, USER_ACCESS_TOKEN from utils.main import get_access_for_all BOT=Bot(ACCESS_TOKEN, loop=asyncio.get_event_loop(), group_id=196816306) USER=vkBottleUser(USER_ACCESS_TOKEN) access_for_all=asyncio.get_event_loop().run_until_complete(get_access_for_all()) ","sourceWithComments":"import asyncio\n\nfrom vkbottle import User as vkBottleUser, Bot\n\nfrom config import ACCESS_TOKEN, USER_ACCESS_TOKEN\nfrom utils.main import get_access_for_all\n\nBOT = Bot(ACCESS_TOKEN, loop=asyncio.get_event_loop(), group_id=196816306)\nUSER = vkBottleUser(USER_ACCESS_TOKEN)\n\n#TODO: \u0441\u043e\u0437\u0434\u0430\u0442\u044c utils.py \u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u0441\u0442\u0438\u0442\u044c \u0442\u0443\u0434\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n\naccess_for_all = asyncio.get_event_loop().run_until_complete(get_access_for_all())\n\n\n"},"\/middlewares\/ExpMiddleware.py":{"changes":[{"diff":"\n \n from config import NEW_START\n from global_settings import BOT\n-from utils.main import check_or_create\n+from utils.db_methods import check_or_create\n from models import Car, User\n ","add":1,"remove":1,"filename":"\/middlewares\/ExpMiddleware.py","badparts":["from utils.main import check_or_create"],"goodparts":["from utils.db_methods import check_or_create"]}],"source":"\nfrom vkbottle import Message from vkbottle.ext import Middleware from config import NEW_START from global_settings import BOT from utils.main import check_or_create from models import Car, User @BOT.middleware.middleware_handler() class ExpMiddleware(Middleware): async def pre(self, message: Message, *args): if not NEW_START: user=(await check_or_create(message.from_id, message.peer_id))[0] if not message.text.startswith(\"\/\"): if user.car_id is not None: multiplier=(await Car.get(id=user.car_id)).multiplier else: multiplier=1 msg=[a for a in message.text] msg=[a for a in msg if a !=\" \"] exps=2 * len(msg) * multiplier await User.get( user_id=message.from_id, peer_id=message.peer_id ).update(exp=exps +user.exp) user=(await check_or_create(message.from_id, message.peer_id))[0] return user return None ","sourceWithComments":"from vkbottle import Message\nfrom vkbottle.ext import Middleware\n\nfrom config import NEW_START\nfrom global_settings import BOT\nfrom utils.main import check_or_create\nfrom models import Car, User\n\n\n@BOT.middleware.middleware_handler()\nclass ExpMiddleware(Middleware):\n    async def pre(self, message: Message, *args):\n        if not NEW_START:\n            user = (await check_or_create(message.from_id, message.peer_id))[0]\n            if not message.text.startswith(\"\/\"):\n                if user.car_id is not None:\n                    multiplier = (await Car.get(id=user.car_id)).multiplier\n                else:\n                    multiplier = 1\n\n                # TODO: \u0440\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u0435\u043a\u0441\u0442\u0430 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u043c \u043c\u0435\u0442\u043e\u0434\u0435\n                msg = [a for a in message.text]\n                msg = [a for a in msg if a != \" \"]\n                exps = 2 * len(msg) * multiplier\n                await User.get(\n                    user_id=message.from_id, peer_id=message.peer_id\n                ).update(exp=exps + user.exp)\n\n            user = (await check_or_create(message.from_id, message.peer_id))[0]\n            return user\n\n        return None\n"},"\/models.py":{"changes":[{"diff":"\n class User(Model):\r\n     id = fields.IntField(pk=True)\r\n     user_id = fields.IntField()\r\n-    peer_id = fields.IntField() #NOTE: \u0440\u0430\u0437\u043d\u044b\u0439 peer_id?\r\n+    chat = fields.ForeignKeyField('models.Conversation', related_name=\"chat\")\r\n     coins = fields.IntField(default=100)\r\n     energy = fields.IntField(default=4)\r\n     warns = fields.IntField(default=","add":1,"remove":1,"filename":"\/models.py","badparts":["    peer_id = fields.IntField() #NOTE: \u0440\u0430\u0437\u043d\u044b\u0439 peer_id?\r"],"goodparts":["    chat = fields.ForeignKeyField('models.Conversation', related_name=\"chat\")\r"]}],"source":"\nfrom tortoise.models import Model\r from tortoise import fields\r \r \r class User(Model):\r id=fields.IntField(pk=True)\r user_id=fields.IntField()\r peer_id=fields.IntField() coins=fields.IntField(default=100)\r energy=fields.IntField(default=4)\r warns=fields.IntField(default=0)\r exp=fields.IntField(default=0)\r work_id=fields.ForeignKeyField(\"models.Work\", related_name=\"work_id\", null=True)\r job_lp=fields.BigIntField(null=True)\r car=fields.ForeignKeyField(\"models.Car\", related_name=\"car\", null=True)\r \r class Meta:\r table=\"users\"\r \r def __str__(self):\r return str(self.user_id)\r \r \r class GlobalUser(Model):\r id=fields.IntField(pk=True)\r user_id=fields.IntField()\r global_role=fields.ForeignKeyField(\"models.GlobalRole\")\r \r class Meta:\r table=\"global_users\"\r \r def __str__(self):\r return str(self.user_id)\r \r \r class Conversation(Model):\r id=fields.IntField(pk=True)\r peer_id=fields.IntField()\r \r class Meta:\r table=\"conversations\"\r \r def __str__(self):\r return str(self.peer_id)\r \r \r class GlobalRole(Model):\r id=fields.IntField(pk=True)\r name=fields.CharField(max_length=256)\r \r class Meta:\r table=\"global_roles\"\r \r def __str__(self):\r return str(self.name)\r \r \r class Work(Model):\r id=fields.IntField(pk=True)\r name=fields.CharField(max_length=256)\r salary=fields.IntField()\r \r class Meta:\r table=\"works\"\r \r def __str__(self):\r return str(self.name)\r \r \r class Car(Model):\r id=fields.IntField(pk=True)\r name=fields.CharField(max_length=256)\r multiplier=fields.IntField()\r cost=fields.IntField()\r exp_need=fields.IntField()\r \r class Meta:\r table=\"cars\"\r \r def __str__(self):\r return str(self.name)\r ","sourceWithComments":"from tortoise.models import Model\r\nfrom tortoise import fields\r\n\r\n\r\nclass User(Model):\r\n    id = fields.IntField(pk=True)\r\n    user_id = fields.IntField()\r\n    peer_id = fields.IntField() #NOTE: \u0440\u0430\u0437\u043d\u044b\u0439 peer_id?\r\n    coins = fields.IntField(default=100)\r\n    energy = fields.IntField(default=4)\r\n    warns = fields.IntField(default=0)\r\n    exp = fields.IntField(default=0)\r\n    work_id = fields.ForeignKeyField(\"models.Work\", related_name=\"work_id\", null=True)\r\n    job_lp = fields.BigIntField(null=True)\r\n    car = fields.ForeignKeyField(\"models.Car\", related_name=\"car\", null=True)\r\n\r\n    class Meta:\r\n        table = \"users\"\r\n\r\n    def __str__(self):\r\n        return str(self.user_id)\r\n\r\n\r\nclass GlobalUser(Model):\r\n    id = fields.IntField(pk=True)\r\n    user_id = fields.IntField()\r\n    global_role = fields.ForeignKeyField(\"models.GlobalRole\")\r\n\r\n    class Meta:\r\n        table = \"global_users\"\r\n\r\n    def __str__(self):\r\n        return str(self.user_id)\r\n\r\n\r\nclass Conversation(Model):\r\n    id = fields.IntField(pk=True)\r\n    peer_id = fields.IntField()\r\n\r\n    class Meta:\r\n        table = \"conversations\"\r\n\r\n    def __str__(self):\r\n        return str(self.peer_id)\r\n\r\n\r\nclass GlobalRole(Model):\r\n    id = fields.IntField(pk=True)\r\n    name = fields.CharField(max_length=256)\r\n\r\n    class Meta:\r\n        table = \"global_roles\"\r\n\r\n    def __str__(self):\r\n        return str(self.name)\r\n\r\n\r\nclass Work(Model):\r\n    id = fields.IntField(pk=True)\r\n    name = fields.CharField(max_length=256)\r\n    salary = fields.IntField()\r\n\r\n    class Meta:\r\n        table = \"works\"\r\n\r\n    def __str__(self):\r\n        return str(self.name)\r\n\r\n\r\nclass Car(Model):\r\n    id = fields.IntField(pk=True)\r\n    name = fields.CharField(max_length=256)\r\n    multiplier = fields.IntField()\r\n    cost = fields.IntField()\r\n    exp_need = fields.IntField()\r\n\r\n    class Meta:\r\n        table = \"cars\"\r\n\r\n    def __str__(self):\r\n        return str(self.name)\r\n"},"\/routes\/actions.py":{"changes":[{"diff":"\n-import random\n import sys\n from typing import Optional\n \n from vkbottle.bot import Blueprint\n \n-from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT\n-from global_settings import *\n from models import Conversation, User\n from rules import *\n \n","add":0,"remove":3,"filename":"\/routes\/actions.py","badparts":["import random","from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT","from global_settings import *"],"goodparts":[]},{"diff":"\n @bp.on.chat_invite()\n async def invite_message(action: Message, _: Optional[User] = None):\n-    await BOT.api.request(\n-        \"messages.send\",\n-        {\n-            \"message\": '\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u044f \u043e\u0442\u0432\u0435\u0447\u0430\u043b \u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \"\u0414\u043e\u0441\u0442\u0443\u043f \u043a\u043e \u0432\u0441\u0435\u0439 \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u043a\u0435\". '\n-                       '\u0414\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a\u043e \u0432\u0441\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \u043f\u0440\u0430\u0432\u0430 \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\"',\n-            \"random_id\": random.randint(MIN_RANDOM_ID_INT, MAX_RANDOM_ID_INT),\n-            \"peer_id\": action.peer_id,\n-        },\n-    )\n+    await action('\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u044f \u043e\u0442\u0432\u0435\u0447\u0430\u043b \u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \"\u0414\u043e\u0441\u0442\u0443\u043f \u043a\u043e \u0432\u0441\u0435\u0439 \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u043a\u0435\". '\n+                 '\u0414\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a\u043e \u0432\u0441\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \u043f\u0440\u0430\u0432\u0430 \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\"')\n+\n     await Conversation(peer_id=action.peer_id).sa","add":3,"remove":9,"filename":"\/routes\/actions.py","badparts":["    await BOT.api.request(","        \"messages.send\",","        {","            \"message\": '\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u044f \u043e\u0442\u0432\u0435\u0447\u0430\u043b \u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \"\u0414\u043e\u0441\u0442\u0443\u043f \u043a\u043e \u0432\u0441\u0435\u0439 \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u043a\u0435\". '","                       '\u0414\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a\u043e \u0432\u0441\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \u043f\u0440\u0430\u0432\u0430 \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\"',","            \"random_id\": random.randint(MIN_RANDOM_ID_INT, MAX_RANDOM_ID_INT),","            \"peer_id\": action.peer_id,","        },","    )"],"goodparts":["    await action('\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u044f \u043e\u0442\u0432\u0435\u0447\u0430\u043b \u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \"\u0414\u043e\u0441\u0442\u0443\u043f \u043a\u043e \u0432\u0441\u0435\u0439 \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u043a\u0435\". '","                 '\u0414\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a\u043e \u0432\u0441\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \u043f\u0440\u0430\u0432\u0430 \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\"')"]}],"source":"\nimport random import sys from typing import Optional from vkbottle.bot import Blueprint from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT from global_settings import * from models import Conversation, User from rules import * sys.path.append(\"..\") bp=Blueprint(name=\"Working with actions functions\") @bp.on.chat_invite() async def invite_message(action: Message, _: Optional[User]=None): await BOT.api.request( \"messages.send\", { \"message\": '\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u044f \u043e\u0442\u0432\u0435\u0447\u0430\u043b \u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \"\u0414\u043e\u0441\u0442\u0443\u043f \u043a\u043e \u0432\u0441\u0435\u0439 \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u043a\u0435\". ' '\u0414\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a\u043e \u0432\u0441\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \u043f\u0440\u0430\u0432\u0430 \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\"', \"random_id\": random.randint(MIN_RANDOM_ID_INT, MAX_RANDOM_ID_INT), \"peer_id\": action.peer_id, }, ) await Conversation(peer_id=action.peer_id).save() ","sourceWithComments":"import random\nimport sys\nfrom typing import Optional\n\nfrom vkbottle.bot import Blueprint\n\nfrom utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT\nfrom global_settings import *\nfrom models import Conversation, User\nfrom rules import *\n\nsys.path.append(\"..\")\nbp = Blueprint(name=\"Working with actions functions\")\n\n\n@bp.on.chat_invite()\nasync def invite_message(action: Message, _: Optional[User] = None):\n    await BOT.api.request(\n        \"messages.send\",\n        {\n            \"message\": '\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u044f \u043e\u0442\u0432\u0435\u0447\u0430\u043b \u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \"\u0414\u043e\u0441\u0442\u0443\u043f \u043a\u043e \u0432\u0441\u0435\u0439 \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u043a\u0435\". '\n                       '\u0414\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a\u043e \u0432\u0441\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c \u0432\u044b\u0434\u0430\u0439\u0442\u0435 \u043c\u043d\u0435 \u043f\u0440\u0430\u0432\u0430 \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\"',\n            \"random_id\": random.randint(MIN_RANDOM_ID_INT, MAX_RANDOM_ID_INT),\n            \"peer_id\": action.peer_id,\n        },\n    )\n    await Conversation(peer_id=action.peer_id).save()\n"},"\/routes\/admin_realize.py":{"changes":[{"diff":"\n from global_settings import *\n from models import User\n from rules import *\n-from utils.main import is_mention, check_or_create\n+from utils.errors import WrongWarnsCountException\n+from utils.main import get_user_from_mention, give_warns\n \n sys.path.append(\"..\")\n bp = Blueprint(name=\"Working with admin functions\")\n","add":2,"remove":1,"filename":"\/routes\/admin_realize.py","badparts":["from utils.main import is_mention, check_or_create"],"goodparts":["from utils.errors import WrongWarnsCountException","from utils.main import get_user_from_mention, give_warns"]}],"source":"\nimport sys from typing import Optional from vkbottle.bot import Blueprint from global_settings import * from models import User from rules import * from utils.main import is_mention, check_or_create sys.path.append(\"..\") bp=Blueprint(name=\"Working with admin functions\") @bp.on.message_handler(OnlyAdminAccess(), AccessForBotAdmin(), text=\"\u0431\u0430\u043d\", lower=True) async def bot_ban_message(message: Message, _: Optional[User]=None): if message.reply_message: await message( f\"\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u0415 \u0411\u0410\u041d \u041f\u041e\u041b\u042c\u0417\u041e\u0412\u0410\u0422\u0415\u041b\u042f \u0421 ID{message.reply_message.from_id}! \u041d\u0410\u041f\u0418\u0428\u0418\u0422\u0415 '\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c'(\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418 \u0411\u0423\u041a\u0412\u0410\u041c\u0418) \u0414\u041b\u042f \u0422\u041e\u0413\u041e, \u0427\u0422\u041e\u0411\u042b \u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c, \u0418\u041b\u0418 '\u0412\u042b\u0419\u0422\u0418'(\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418), \u0427\u0422\u041e\u0411\u042b \u0412\u042b\u0419\u0422\u0418 \u0418\u0417 \u042d\u0422\u041e\u0413\u041e \u041c\u0415\u041d\u042e!\" ) await BOT.branch.add( message.peer_id, \"bot_ban_branch\", user_id=message.reply_message.from_id, admin_id=message.from_id, ) @bp.branch.simple_branch(\"bot_ban_branch\") async def bot_ban_branch(message: Message, user_id, admin_id): returning=False if message.text==\"\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c\" and message.from_id==admin_id: await BOT.api.request( \"messages.removeChatUser\",{\"chat_id\": message.chat_id, \"user_id\": user_id} ) await message( f\"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c c ID{user_id} \u0431\u044b\u043b \u0437\u0430\u0431\u0430\u043d\u0435\u043d \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u043c \u0441 ID{admin_id}\" ) returning=True await BOT.branch.exit(message.peer_id) elif message.text==\"\u0412\u042b\u0419\u0422\u0418\" and message.from_id==admin_id: await message(\"\u0411\u044b\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d \u0432\u044b\u0445\u043e\u0434 \u0441 \u043c\u0435\u043d\u044e \u0431\u0430\u043d\u0430\") returning=True await BOT.branch.exit(message.peer_id) if message.from_id==admin_id and not returning: await message( f\"\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u0415 \u0411\u0410\u041d \u041f\u041e\u041b\u042c\u0417\u041e\u0412\u0410\u0422\u0415\u041b\u042f \u0421 ID{user_id}! \u041d\u0410\u041f\u0418\u0428\u0418\u0422\u0415 '\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c'(\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418 \u0411\u0423\u041a\u0412\u0410\u041c\u0418) \u0414\u041b\u042f \u0422\u041e\u0413\u041e, \u0427\u0422\u041e\u0411\u042b \" f\"\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c, \u0418\u041b\u0418 '\u0412\u042b\u0419\u0422\u0418'(\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418), \u0427\u0422\u041e\u0411\u042b \u0412\u042b\u0419\u0422\u0418 \u0418\u0417 \u042d\u0422\u041e\u0413\u041e \u041c\u0415\u041d\u042e! \" ) @bp.on.chat_message(OnlyAdminAccess(), text=\"\/\u043f\u0440\u0435\u0434 <mention> <count>\", lower=True) async def warn_with_mention_message(message: Message, _: Optional[User]=None, mention: str=None, count: str=None): if(is_mention(mention))[0]: mention=(is_mention(mention))[1] else: await message(\"\u042f \u043d\u0435 \u0432\u0438\u0436\u0443 \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f! \u0423\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e!\") return if(not count.isdigit()) and not(count.startswith(\"-\") and count[1:].isdigit()): await message(\"\u0422\u0435\u043a\u0441\u0442 \u0432\u043c\u0435\u0441\u0442\u043e \u0446\u0438\u0444\u0440\u044b?.. \u041c-\u0434\u0430...\") else: count=int(count) if count > 4: await message( \"\u0414\u0430 \u043a\u0443\u0434\u0430 \u0442\u044b \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u043b\u0441\u044f, \u0431\u043e\u043b\u044c\u0448\u0435 4 \u0432\u0430\u0440\u043d\u043e\u0432 \u043a\u0438\u0434\u0430\u0442\u044c \u0447\u0443\u0432\u0430\u043a\u0443, \u0442\u0443\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 4 \u0432\u0430\u0440\u043d\u0430 \u0435\u0441\u0442\u044c\" ) else: user_mention=await User.get_or_none( user_id=mention, peer_id=message.peer_id ) if user_mention is None and count < 0: await check_or_create(mention, message.peer_id) await message( \"\u041d\u0443 \u043d\u0435\u0442 \u0443 \u044d\u0442\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u0435\u0434\u043e\u0432. \u041d\u0443 \u043d\u0435 \u043c\u043e\u0433\u0443 \u044f \u0437\u0430\u0431\u0440\u0430\u0442\u044c \u0442\u043e, \u0447\u0435\u0433\u043e \u041d\u0415\u0422\u0423!!\" ) elif user_mention is None and count > 0: await check_or_create(message.from_id, message.peer_id, count) await message( f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0441 ID{mention}, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e:{count}\" ) elif user_mention is not None: await check_or_create(message.from_id, message.peer_id) current_warns=user_mention.warns if current_warns +count < 0: await message( f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u041d\u0415 \u0432\u044b\u0434\u0430\u043d\u043e, \u0442.\u043a. \u043f\u0440\u0438 \u0437\u0430\u0431\u0438\u0440\u0430\u043d\u0438\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u043a\u043e\u043b-\u0432\u0430 \u0432\u0430\u0440\u043d\u043e\u0432 \u0443 \u043d\u0435\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u043c\u0435\u043d\u044c\u0448\u0435 0 \" f\"\u0432\u0430\u0440\u043d\u043e\u0432, \u0447\u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432:{current_warns} \" ) else: await User.get( user_id=mention, peer_id=message.peer_id ).update(warns=current_warns +count) if current_warns +count >=4: await message( f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e 4, \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0431\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f! \" f\"\u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432:{current_warns +count} \" ) else: await message( f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e:{current_warns +count}\" ) @bp.on.chat_message(OnlyAdminAccess(), text=\"\/\u043f\u0440\u0435\u0434 <count>\", lower=True) async def warn_with_reply_message(message: Message, _: Optional[User]=None, count: str=None): if message.reply_message: if(not count.isdigit()) and not( count.startswith(\"-\") and count[1:].isdigit() ): await message(\"\u0422\u0435\u043a\u0441\u0442 \u0432\u043c\u0435\u0441\u0442\u043e \u0446\u0438\u0444\u0440\u044b?.. \u041c-\u0434\u0430...\") else: count=int(count) if count > 4: await message( \"\u0414\u0430 \u043a\u0443\u0434\u0430 \u0442\u044b \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u043b\u0441\u044f, \u0431\u043e\u043b\u044c\u0448\u0435 4 \u0432\u0430\u0440\u043d\u043e\u0432 \u043a\u0438\u0434\u0430\u0442\u044c \u0447\u0443\u0432\u0430\u043a\u0443, \u0442\u0443\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 4 \u0432\u0430\u0440\u043d\u0430 \u0435\u0441\u0442\u044c\" ) else: user_reply=await User.get_or_none( user_id=message.reply_message.from_id, peer_id=message.peer_id ) if user_reply is None and count < 0: await check_or_create(message.reply_message.from_id, message.peer_id) await message( \"\u041d\u0443 \u043d\u0435\u0442 \u0443 \u044d\u0442\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u0435\u0434\u043e\u0432. \u041d\u0443 \u043d\u0435 \u043c\u043e\u0433\u0443 \u044f \u0437\u0430\u0431\u0440\u0430\u0442\u044c \u0442\u043e, \u0447\u0435\u0433\u043e \u041d\u0415\u0422\u0423!!\" ) elif user_reply is None and count > 0: await check_or_create( message.reply_message.from_id, message.peer_id, count ) await message( f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0441 ID{message.reply_message.from_id}, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e:{count}\" ) elif user_reply is not None: await check_or_create( message.reply_message.from_id, message.peer_id ) current_warns=user_reply.warns if current_warns +count < 0: await message( f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u041d\u0415 \u0432\u044b\u0434\u0430\u043d\u043e, \u0442.\u043a. \u043f\u0440\u0438 \u0437\u0430\u0431\u0438\u0440\u0430\u043d\u0438\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u043a\u043e\u043b-\u0432\u0430 \u0432\u0430\u0440\u043d\u043e\u0432 \u0443 \u043d\u0435\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u043c\u0435\u043d\u044c\u0448\u0435 0 \" f\"\u0432\u0430\u0440\u043d\u043e\u0432, \u0447\u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432:{current_warns} \" ) else: await User.get( user_id=message.reply_message.from_id, peer_id=message.peer_id, ).update(warns=current_warns +count) if current_warns +count >=4: await message( f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e 4, \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0431\u0430\u043d \" f\"\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432:{current_warns +count} \" ) else: await message( f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e:{current_warns +count}\" ) else: await message(\"\u0425\u043e\u0442\u044c \u0431\u044b \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0442\u043e\u0433\u043e, \u043a\u043e\u0433\u043e \u0432\u0430\u0440\u043d\u0438\u0442\u044c \u043d\u0430\u0434\u043e, \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u043b \u0431\u044b\") ","sourceWithComments":"import sys\nfrom typing import Optional\n\nfrom vkbottle.bot import Blueprint\n\nfrom global_settings import *\nfrom models import User\nfrom rules import *\nfrom utils.main import is_mention, check_or_create\n\nsys.path.append(\"..\")\nbp = Blueprint(name=\"Working with admin functions\")\n\n\n@bp.on.message_handler(OnlyAdminAccess(), AccessForBotAdmin(), text=\"\u0431\u0430\u043d\", lower=True)\nasync def bot_ban_message(message: Message, _: Optional[User] = None):\n    if message.reply_message:\n        await message(\n            f\"\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u0415 \u0411\u0410\u041d \u041f\u041e\u041b\u042c\u0417\u041e\u0412\u0410\u0422\u0415\u041b\u042f \u0421 ID {message.reply_message.from_id}! \u041d\u0410\u041f\u0418\u0428\u0418\u0422\u0415 '\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c' (\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418 \u0411\u0423\u041a\u0412\u0410\u041c\u0418) \u0414\u041b\u042f \u0422\u041e\u0413\u041e, \u0427\u0422\u041e\u0411\u042b \u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c, \u0418\u041b\u0418 '\u0412\u042b\u0419\u0422\u0418' (\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418), \u0427\u0422\u041e\u0411\u042b \u0412\u042b\u0419\u0422\u0418 \u0418\u0417 \u042d\u0422\u041e\u0413\u041e \u041c\u0415\u041d\u042e!\"\n        )\n        await BOT.branch.add(\n            message.peer_id,\n            \"bot_ban_branch\",\n            user_id=message.reply_message.from_id,\n            admin_id=message.from_id,\n        )\n\n\n@bp.branch.simple_branch(\"bot_ban_branch\")\nasync def bot_ban_branch(message: Message, user_id, admin_id):\n    returning = False\n    if message.text == \"\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c\" and message.from_id == admin_id:\n        await BOT.api.request(\n            \"messages.removeChatUser\", {\"chat_id\": message.chat_id, \"user_id\": user_id}\n        )\n        await message(\n            f\"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c c ID {user_id} \u0431\u044b\u043b \u0437\u0430\u0431\u0430\u043d\u0435\u043d \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u043c \u0441 ID {admin_id}\"\n        )\n        returning = True\n        await BOT.branch.exit(message.peer_id)\n    elif message.text == \"\u0412\u042b\u0419\u0422\u0418\" and message.from_id == admin_id:\n        await message(\"\u0411\u044b\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d \u0432\u044b\u0445\u043e\u0434 \u0441 \u043c\u0435\u043d\u044e \u0431\u0430\u043d\u0430\")\n        returning = True\n        await BOT.branch.exit(message.peer_id)\n\n    if message.from_id == admin_id and not returning:\n        await message(\n            f\"\u041f\u041e\u0414\u0422\u0412\u0415\u0420\u0414\u0418\u0422\u0415 \u0411\u0410\u041d \u041f\u041e\u041b\u042c\u0417\u041e\u0412\u0410\u0422\u0415\u041b\u042f \u0421 ID {user_id}! \u041d\u0410\u041f\u0418\u0428\u0418\u0422\u0415 '\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c' (\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418 \u0411\u0423\u041a\u0412\u0410\u041c\u0418) \u0414\u041b\u042f \u0422\u041e\u0413\u041e, \u0427\u0422\u041e\u0411\u042b \"\n            f\"\u0417\u0410\u0411\u0410\u041d\u0418\u0422\u042c, \u0418\u041b\u0418 '\u0412\u042b\u0419\u0422\u0418' (\u0417\u0410\u0413\u041b\u0410\u0412\u041d\u042b\u041c\u0418), \u0427\u0422\u041e\u0411\u042b \u0412\u042b\u0419\u0422\u0418 \u0418\u0417 \u042d\u0422\u041e\u0413\u041e \u041c\u0415\u041d\u042e! \"\n        )\n\n\n@bp.on.chat_message(OnlyAdminAccess(), text=\"\/\u043f\u0440\u0435\u0434 <mention> <count>\", lower=True)\nasync def warn_with_mention_message(message: Message, _: Optional[User] = None, mention: str = None, count: str = None):\n    # Checking for mention\n    if (is_mention(mention))[0]:\n        mention = (is_mention(mention))[1]\n    else:\n        await message(\"\u042f \u043d\u0435 \u0432\u0438\u0436\u0443 \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f! \u0423\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e!\")\n        return\n\n    # Checking for number-count of warnings\n    if (not count.isdigit()) and not (count.startswith(\"-\") and count[1:].isdigit()):\n        await message(\"\u0422\u0435\u043a\u0441\u0442 \u0432\u043c\u0435\u0441\u0442\u043e \u0446\u0438\u0444\u0440\u044b?.. \u041c-\u0434\u0430...\")\n    else:\n        count = int(count)\n        # Checking for count of giving warnings\n        if count > 4:\n            await message(\n                \"\u0414\u0430 \u043a\u0443\u0434\u0430 \u0442\u044b \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u043b\u0441\u044f, \u0431\u043e\u043b\u044c\u0448\u0435 4 \u0432\u0430\u0440\u043d\u043e\u0432 \u043a\u0438\u0434\u0430\u0442\u044c \u0447\u0443\u0432\u0430\u043a\u0443, \u0442\u0443\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 4 \u0432\u0430\u0440\u043d\u0430 \u0435\u0441\u0442\u044c\"\n            )\n        else:\n            user_mention = await User.get_or_none(\n                user_id=mention, peer_id=message.peer_id\n            )\n            if user_mention is None and count < 0:\n                await check_or_create(mention, message.peer_id)\n                await message(\n                    \"\u041d\u0443 \u043d\u0435\u0442 \u0443 \u044d\u0442\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u0435\u0434\u043e\u0432. \u041d\u0443 \u043d\u0435 \u043c\u043e\u0433\u0443 \u044f \u0437\u0430\u0431\u0440\u0430\u0442\u044c \u0442\u043e, \u0447\u0435\u0433\u043e \u041d\u0415\u0422\u0423!!\"\n                )\n            elif user_mention is None and count > 0:\n                await check_or_create(message.from_id, message.peer_id, count)\n                await message(\n                    f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0441 ID {mention}, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e: {count}\"\n                )\n            elif user_mention is not None:\n                await check_or_create(message.from_id, message.peer_id)\n                current_warns = user_mention.warns\n                if current_warns + count < 0:\n                    await message(\n                        f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u041d\u0415 \u0432\u044b\u0434\u0430\u043d\u043e, \u0442.\u043a. \u043f\u0440\u0438 \u0437\u0430\u0431\u0438\u0440\u0430\u043d\u0438\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u043a\u043e\u043b-\u0432\u0430 \u0432\u0430\u0440\u043d\u043e\u0432 \u0443 \u043d\u0435\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u043c\u0435\u043d\u044c\u0448\u0435 0 \"\n                        f\"\u0432\u0430\u0440\u043d\u043e\u0432, \u0447\u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432: {current_warns} \"\n                    )\n                else:\n                    await User.get(\n                        user_id=mention, peer_id=message.peer_id\n                    ).update(warns=current_warns + count)\n                    if current_warns + count >= 4:\n                        await message(\n                            f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e 4, \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0431\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f! \"\n                            f\"\u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432: {current_warns + count} \"\n                        )\n                    else:\n                        await message(\n                            f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e: {current_warns + count}\"\n                        )\n\n\n@bp.on.chat_message(OnlyAdminAccess(), text=\"\/\u043f\u0440\u0435\u0434 <count>\", lower=True)\nasync def warn_with_reply_message(message: Message, _: Optional[User] = None, count: str = None):\n    if message.reply_message:\n        # Checking for number-count of warnings\n        if (not count.isdigit()) and not (\n                count.startswith(\"-\") and count[1:].isdigit()\n        ):\n            await message(\"\u0422\u0435\u043a\u0441\u0442 \u0432\u043c\u0435\u0441\u0442\u043e \u0446\u0438\u0444\u0440\u044b?.. \u041c-\u0434\u0430...\")\n        else:\n            count = int(count)\n            # Checking for count of giving warnings\n            if count > 4:\n                await message(\n                    \"\u0414\u0430 \u043a\u0443\u0434\u0430 \u0442\u044b \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u043b\u0441\u044f, \u0431\u043e\u043b\u044c\u0448\u0435 4 \u0432\u0430\u0440\u043d\u043e\u0432 \u043a\u0438\u0434\u0430\u0442\u044c \u0447\u0443\u0432\u0430\u043a\u0443, \u0442\u0443\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 4 \u0432\u0430\u0440\u043d\u0430 \u0435\u0441\u0442\u044c\"\n                )\n            else:\n                user_reply = await User.get_or_none(\n                    user_id=message.reply_message.from_id, peer_id=message.peer_id\n                )\n                if user_reply is None and count < 0:\n                    await check_or_create(message.reply_message.from_id, message.peer_id)\n                    await message(\n                        \"\u041d\u0443 \u043d\u0435\u0442 \u0443 \u044d\u0442\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u0435\u0434\u043e\u0432. \u041d\u0443 \u043d\u0435 \u043c\u043e\u0433\u0443 \u044f \u0437\u0430\u0431\u0440\u0430\u0442\u044c \u0442\u043e, \u0447\u0435\u0433\u043e \u041d\u0415\u0422\u0423!!\"\n                    )\n                elif user_reply is None and count > 0:\n                    await check_or_create(\n                        message.reply_message.from_id, message.peer_id, count\n                    )\n                    await message(\n                        f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0441 ID {message.reply_message.from_id}, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e: {count}\"\n                    )\n                elif user_reply is not None:\n                    await check_or_create(\n                        message.reply_message.from_id, message.peer_id\n                    )\n                    current_warns = user_reply.warns\n                    if current_warns + count < 0:\n                        await message(\n                            f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u041d\u0415 \u0432\u044b\u0434\u0430\u043d\u043e, \u0442.\u043a. \u043f\u0440\u0438 \u0437\u0430\u0431\u0438\u0440\u0430\u043d\u0438\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u043a\u043e\u043b-\u0432\u0430 \u0432\u0430\u0440\u043d\u043e\u0432 \u0443 \u043d\u0435\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u043c\u0435\u043d\u044c\u0448\u0435 0 \"\n                            f\"\u0432\u0430\u0440\u043d\u043e\u0432, \u0447\u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432: {current_warns} \"\n                        )\n                    else:\n                        await User.get(\n                            user_id=message.reply_message.from_id,\n                            peer_id=message.peer_id,\n                        ).update(warns=current_warns + count)\n                        if current_warns + count >= 4:\n                            await message(\n                                f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e 4, \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0431\u0430\u043d \"\n                                f\"\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f! \u041e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043e\u0432: {current_warns + count} \"\n                            )\n                        else:\n                            await message(\n                                f\"\u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0434\u0430\u043d\u043e, \u043e\u0431\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e: {current_warns + count}\"\n                            )\n\n    else:\n        await message(\"\u0425\u043e\u0442\u044c \u0431\u044b \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0442\u043e\u0433\u043e, \u043a\u043e\u0433\u043e \u0432\u0430\u0440\u043d\u0438\u0442\u044c \u043d\u0430\u0434\u043e, \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u043b \u0431\u044b\")\n"},"\/routes\/economic_realize.py":{"changes":[{"diff":"\n     conn = Tortoise.get_connection(\"default\")\n     time_unix = int(datetime.datetime.now().timestamp() - 86400)\n \n-    #TODO: \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u0430 SQL-\u0438\u043d\u044a\u0435\u043a\u0446\u0438\u044f. \u041f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u0442\u044c, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f values\n-    #users = await conn.execute_query_dict(\n-    #    \"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= ?\", [time_unix]\n-    #)\n     users = await conn.execute_query_dict(\n-        f\"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= {time_unix}\"\n+        \"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= ?\", [time_unix]\n     )\n     for user in users:\n         work = await Work.get(id=user[\"work_id_id\"])\n","add":1,"remove":5,"filename":"\/routes\/economic_realize.py","badparts":["        f\"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= {time_unix}\""],"goodparts":["        \"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= ?\", [time_unix]"]}],"source":"\nimport datetime import sys from threading import Thread from typing import Optional from tortoise import Tortoise from vkbottle.bot import Blueprint from global_settings import * from rules import * sys.path.append(\"..\") bp=Blueprint(name=\"Working with economic system\") async def payouts(): conn=Tortoise.get_connection(\"default\") time_unix=int(datetime.datetime.now().timestamp() -86400) users=await conn.execute_query_dict( f\"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <={time_unix}\" ) for user in users: work=await Work.get(id=user[\"work_id_id\"]) await User.get(user_id=user[\"user_id\"], peer_id=user[\"peer_id\"]).update( coins=user[\"coins\"] +work.salary, job_lp=int(datetime.datetime.now().timestamp()), ) class PayoutsThread(Thread): def __init__(self): Thread.__init__(self) def run(self): loop=asyncio.new_event_loop() asyncio.set_event_loop(loop) while True: try: loop.run_until_complete(payouts()) loop.run_until_complete(asyncio.sleep(15)) except Exception as _: continue @bp.on.message_handler(AccessForAllRule(), text=\"\/\u0434\u0430\u0442\u044c_\u0440\u0430\u0431\u043e\u0442\u0443 <j_id>\") async def give_job(message: Message, _: Optional[User]=None, j_id: str=None): if j_id.isdigit(): j_id=int(j_id) work=await Work.get(id=j_id) await User.get(user_id=message.from_id, peer_id=message.peer_id).update( work_id=work, job_lp=int(datetime.datetime.now().timestamp()) ) await message(\"\u0420\u0430\u0431\u043e\u0442\u0430 \u0432\u044b\u0434\u0430\u043d\u0430!\") else: await message(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e!\") @bp.on.message_handler(text=\"\/\u0441\u043f\u0438\u0441\u043e\u043a_\u0440\u0430\u0431\u043e\u0442\") async def job_list(message: Message, _: Optional[User]=None): jobs=await Work.all() await message( \"\\n\".join( [f\"ID:{job.id}; \u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435:{job.name}; \u0417\u041f:{job.salary}\" for job in jobs] ) ) @bp.on.message_handler(text=\"\/\u0441\u043f\u0438\u0441\u043e\u043a_\u043c\u0430\u0448\u0438\u043d\") async def job_list(message: Message, _: Optional[User]=None): cars=await Car.all() await message( \"\\n\".join( [f\"ID:{car.id}; \u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435:{car.name}; \u041c\u043d\u043e\u0436\u0438\u0442\u0435\u043b\u044c:{car.multiplier}\" for car in cars] ) ) @bp.on.message_handler(AccessForAllRule(), text=\"\/\u043a\u0443\u043f\u0438\u0442\u044c_\u043c\u0430\u0448\u0438\u043d\u0443 <c_id>\") async def buy_car(message: Message, user: Optional[User]=None, c_id: str=None): if c_id.isdigit(): c_id=int(c_id) car=await Car.get(id=c_id) if user.coins >=car.cost and user.exp >=car.exp_need and user.car_id is None: await User.get(user_id=message.from_id, peer_id=message.peer_id).update( coins=user.coins -car.cost, car=car ) await message(f\"\u041c\u0430\u0448\u0438\u043d\u0430{car} \u043a\u0443\u043f\u043b\u0435\u043d\u0430!\") elif user.coins < car.cost: await message(\"\u0423 \u0442\u0435\u0431\u044f \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0434\u0435\u043d\u0435\u0433!\") elif user.exp < car.exp_need: await message(\"\u0423 \u0442\u0435\u0431\u044f \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043e\u043f\u044b\u0442\u0430!\") else: await message(\"\u0423 \u0442\u0435\u0431\u044f \u0443\u0436\u0435 \u0435\u0441\u0442\u044c \u043c\u0430\u0448\u0438\u043d\u0430!\") else: await message(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0438\u0444\u0440\u0443-ID \u043c\u0430\u0448\u0438\u043d\u044b!\") @bp.on.message_handler(AccessForAllRule(), text=\"\/\u043f\u0440\u043e\u0434\u0430\u0442\u044c_\u043c\u0430\u0448\u0438\u043d\u0443\") async def sell_car(message: Message, user: Optional[User]=None): if user.car_id is not None: car_cost=(await Car.get(id=user.car_id)).cost car_cost=car_cost -(car_cost * 0.1) await User.get(user_id=message.from_id, peer_id=message.peer_id).update( coins=user.coins +car_cost, car_id=None ) await message(\"\u041c\u0430\u0448\u0438\u043d\u0430 \u043f\u0440\u043e\u0434\u0430\u043d\u0430!\") else: await message(\"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u043c\u0430\u0448\u0438\u043d\u044b!\") ","sourceWithComments":"import datetime\nimport sys\nfrom threading import Thread\nfrom typing import Optional\n\nfrom tortoise import Tortoise\nfrom vkbottle.bot import Blueprint\n\nfrom global_settings import *\nfrom rules import *\n\nsys.path.append(\"..\")\n\nbp = Blueprint(name=\"Working with economic system\")\n\n\nasync def payouts():\n    conn = Tortoise.get_connection(\"default\")\n    time_unix = int(datetime.datetime.now().timestamp() - 86400)\n\n    #TODO: \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u0430 SQL-\u0438\u043d\u044a\u0435\u043a\u0446\u0438\u044f. \u041f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u0442\u044c, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f values\n    #users = await conn.execute_query_dict(\n    #    \"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= ?\", [time_unix]\n    #)\n    users = await conn.execute_query_dict(\n        f\"SELECT * FROM `users` WHERE `work_id_id` IS NOT NULL AND `job_lp` IS NOT NULL AND `job_lp` <= {time_unix}\"\n    )\n    for user in users:\n        work = await Work.get(id=user[\"work_id_id\"])\n        await User.get(user_id=user[\"user_id\"], peer_id=user[\"peer_id\"]).update(\n            coins=user[\"coins\"] + work.salary,\n            job_lp=int(datetime.datetime.now().timestamp()),\n        )\n\n\nclass PayoutsThread(Thread):\n    def __init__(self):\n        Thread.__init__(self)\n\n    def run(self):\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        while True:\n            try:\n                loop.run_until_complete(payouts())\n                loop.run_until_complete(asyncio.sleep(15))\n            except Exception as _:\n                continue\n\n\n@bp.on.message_handler(AccessForAllRule(), text=\"\/\u0434\u0430\u0442\u044c_\u0440\u0430\u0431\u043e\u0442\u0443 <j_id>\")\nasync def give_job(message: Message, _: Optional[User] = None, j_id: str = None):\n    if j_id.isdigit():\n        j_id = int(j_id)\n        work = await Work.get(id=j_id)\n        #TODO: \u0437\u0430\u0442\u0435\u0441\u0442\u0438\u0442\u044c\n        await User.get(user_id=message.from_id, peer_id=message.peer_id).update(\n            work_id=work, job_lp=int(datetime.datetime.now().timestamp())\n        )\n        await message(\"\u0420\u0430\u0431\u043e\u0442\u0430 \u0432\u044b\u0434\u0430\u043d\u0430!\")\n    else:\n        await message(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e!\")\n\n\n@bp.on.message_handler(text=\"\/\u0441\u043f\u0438\u0441\u043e\u043a_\u0440\u0430\u0431\u043e\u0442\")\nasync def job_list(message: Message, _: Optional[User] = None):\n    jobs = await Work.all()\n    await message(\n        \"\\n\".join(\n            [f\"ID: {job.id}; \u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435: {job.name}; \u0417\u041f: {job.salary}\" for job in jobs]\n        )\n    )\n\n\n@bp.on.message_handler(text=\"\/\u0441\u043f\u0438\u0441\u043e\u043a_\u043c\u0430\u0448\u0438\u043d\")\nasync def job_list(message: Message, _: Optional[User] = None):\n    cars = await Car.all()\n    await message(\n        \"\\n\".join(\n            [f\"ID: {car.id}; \u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435: {car.name}; \u041c\u043d\u043e\u0436\u0438\u0442\u0435\u043b\u044c: {car.multiplier}\" for car in cars]\n        )\n    )\n\n\n@bp.on.message_handler(AccessForAllRule(), text=\"\/\u043a\u0443\u043f\u0438\u0442\u044c_\u043c\u0430\u0448\u0438\u043d\u0443 <c_id>\")\nasync def buy_car(message: Message, user: Optional[User] = None, c_id: str = None):\n    if c_id.isdigit():\n        c_id = int(c_id)\n        car = await Car.get(id=c_id)\n\n        if user.coins >= car.cost and user.exp >= car.exp_need and user.car_id is None:\n            await User.get(user_id=message.from_id, peer_id=message.peer_id).update(\n                coins=user.coins - car.cost, car=car\n            )\n            #TODO: \u0440\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u044b\u043d\u0435\u0441\u0442\u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n            await message(f\"\u041c\u0430\u0448\u0438\u043d\u0430 {car} \u043a\u0443\u043f\u043b\u0435\u043d\u0430!\")\n        elif user.coins < car.cost:\n            await message(\"\u0423 \u0442\u0435\u0431\u044f \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0434\u0435\u043d\u0435\u0433!\")\n        elif user.exp < car.exp_need:\n            await message(\"\u0423 \u0442\u0435\u0431\u044f \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043e\u043f\u044b\u0442\u0430!\")\n        else:\n            await message(\"\u0423 \u0442\u0435\u0431\u044f \u0443\u0436\u0435 \u0435\u0441\u0442\u044c \u043c\u0430\u0448\u0438\u043d\u0430!\")\n    else:\n        await message(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0438\u0444\u0440\u0443-ID \u043c\u0430\u0448\u0438\u043d\u044b!\")\n\n\n@bp.on.message_handler(AccessForAllRule(), text=\"\/\u043f\u0440\u043e\u0434\u0430\u0442\u044c_\u043c\u0430\u0448\u0438\u043d\u0443\")\nasync def sell_car(message: Message, user: Optional[User] = None):\n    if user.car_id is not None:\n        car_cost = (await Car.get(id=user.car_id)).cost\n        #TODO: \u0447\u0438\u0441\u043b\u043e 0.1 \u0432 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443\n        car_cost = car_cost - (car_cost * 0.1)\n        await User.get(user_id=message.from_id, peer_id=message.peer_id).update(\n            coins=user.coins + car_cost, car_id=None\n        )\n        await message(\"\u041c\u0430\u0448\u0438\u043d\u0430 \u043f\u0440\u043e\u0434\u0430\u043d\u0430!\")\n    else:\n        await message(\"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u043c\u0430\u0448\u0438\u043d\u044b!\")\n"},"\/routes\/global_admin_realize.py":{"changes":[{"diff":"\n import sys\n from typing import Optional\n \n-from tortoise import Tortoise\n+import ujson\n from vkbottle.bot import Blueprint\n \n-from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT\n from global_settings import *\n-from models import Conversation, User, Work\n+from models import Conversation, User\n from rules import *\n+from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT, DatabaseActions, BOT_CREATOR_ID, AccessingLevels\n+from utils.db_methods import add_or_remove_model, give_or_take_access\n+from utils.errors import DatabaseDeleteException, DatabaseAddException, ParseMentionException\n from utils.main import is_mention\n+import numexpr as ne\n \n sys.path.append(\"..\")\n bp = Blueprint(name=\"Working with global admin functions\")\n","add":6,"remove":3,"filename":"\/routes\/global_admin_realize.py","badparts":["from tortoise import Tortoise","from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT","from models import Conversation, User, Work"],"goodparts":["import ujson","from models import Conversation, User","from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT, DatabaseActions, BOT_CREATOR_ID, AccessingLevels","from utils.db_methods import add_or_remove_model, give_or_take_access","from utils.errors import DatabaseDeleteException, DatabaseAddException, ParseMentionException","import numexpr as ne"]}],"source":"\nimport random import sys from typing import Optional from tortoise import Tortoise from vkbottle.bot import Blueprint from utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT from global_settings import * from models import Conversation, User, Work from rules import * from utils.main import is_mention sys.path.append(\"..\") bp=Blueprint(name=\"Working with global admin functions\") @bp.on.message_handler(OnlyBotAdminAccess(), text=\"\/\u0440\u0430\u0437\u043e\u0441\u043b\u0430\u0442\u044c <text>\", lower=True) async def send_messages(message: Message, _: Optional[User]=None, text: str=None): await BOT.api.request( \"messages.markAsRead\", {\"peer_id\": message.peer_id, \"mark_conversation_as_read\": \"1\"}, ) convs=await Conversation.all().values_list(\"peer_id\", flat=True) if convs: for conv in convs: await BOT.api.messages.send( peer_id=conv, random_id=random.randint(MIN_RANDOM_ID_INT, MAX_RANDOM_ID_INT), message=text ) await message(\"\u0412\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u043e.\") @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c_\u0441\u0435\u0431\u044f\") async def get_myself(message: Message, _: Optional[User]=None): conn=Tortoise.get_connection(\"default\") dct=await User.get(user_id=500101793) await message(dct) @bp.on.message_handler(OnlyBotModerAccess(), text=\"\/mention <mention>\", lower=True) async def mention_test(message: Message, _: Optional[User]=None, mention: str=None): print(mention.split(\"|\")[0][1:]) await message(\"[id{0}|Maxim]\".format(message.from_id)) @bp.on.message_handler(OnlyBotModerAccess(), text=\"~ <text>\", lower=True) async def print_or_count(message: Message, _: Optional[User]=None, text: str=None): try: text=text.replace(\" \", \"\") copied_text=text allowed_words=[] allowed_words.extend([str(a) for a in range(10)]) allowed_words.extend( [ \"sin\", \"sqrt\", \"+\", \"-\", \"j\", \"*\", \"\/\", \"(\", \")\", \"cos\", \"tan\", \"e\", \"pi\", \"ceil\", \"copysign\", \"fabs\", \"factorial\", \"floor\", \"fmod\", \"frexp\", \"ldexp\", \"fsum\", \"isfinite\", \"isinf\", \"isnan\", \"modf\", \"trunc\", \"exp\", \"expm1\", \"log\", \"log1p\", \"log10\", \"log2\", \"pow\", \"acos\", \"asin\", \"atan\", \"atan2\", \"hypot\", \"degrees\", \"radians\", \"cosh\", \"sinh\", \"tanh\", \"**\", \"acosh\", \"asinh\", \"atanh\", \"gamma\", \"lgamma\", ] ) awset=set(allowed_words) for i in awset: if i in copied_text: copied_text=copied_text.replace(i, \"\") if copied_text==\"\": all_good=True else: all_good=False if all_good: summ=eval(text) await message(summ) else: await message(text) except ZeroDivisionError: await message(\"+-inf\") except Exception: await message(text) @bp.on.message_handler(OnlyBotAdminAccess(), text=\"\/\u0441\u043d\u044f\u0442\u044c_\u043c\u043e\u0434\u0435\u0440 <mention>\", lower=True) async def delete_bot_moder(message: Message, mention: str, _: Optional[User]=None): if(is_mention(mention))[0]: mention=(is_mention(mention))[1] else: await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043d\u044f\u0442\u044c \u043c\u043e\u0434\u0435\u0440\u043a\u0443!\") return global_role_default=await GlobalRole.get(name=\"Default\") await GlobalUser.get(user_id=mention).update( global_role=global_role_default ) await message(\"\u041c\u043e\u0434\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0441\u043d\u044f\u0442\u0430!\") @bp.on.message_handler(OnlyBotAdminAccess(), text=\"\/\u0434\u0430\u0442\u044c_\u043c\u043e\u0434\u0435\u0440 <mention>\", lower=True) async def give_bot_moder(message: Message, mention: str, _: Optional[User]=None): if(is_mention(mention))[0]: mention=(is_mention(mention))[1] else: await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u0430\u0442\u044c \u043f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430!\") return global_role_moder=await GlobalRole.get(name=\"Moderator\") await GlobalUser.get(user_id=mention).update( global_role=global_role_moder ) await message(\"\u041f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0432\u044b\u0434\u0430\u043d\u044b!\") @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0434\u0430\u0442\u044c_\u0430\u0434\u043c\u0438\u043d <mention>\", lower=True) async def give_bot_admin(message: Message, _: Optional[User]=None, mention: str=None): if(is_mention(mention))[0]: mention=(is_mention(mention))[1] else: await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u0430\u0442\u044c \u043f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430!\") return global_role_moder=await GlobalRole.get(name=\"Administrator\") await GlobalUser.get(user_id=mention).update( global_role=global_role_moder ) await message(\"\u041f\u0440\u0430\u0432\u0430 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0432\u044b\u0434\u0430\u043d\u044b!\") @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0441\u043d\u044f\u0442\u044c_\u0430\u0434\u043c\u0438\u043d <mention>\", lower=True) async def delete_bot_admin(message: Message, _: Optional[User]=None, mention: str=None): if(is_mention(mention))[0]: mention=(is_mention(mention))[1] else: await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043d\u044f\u0442\u044c \u0430\u0434\u043c\u0438\u043d\u043a\u0443!\") return global_role_default=await GlobalRole.get(name=\"Default\") await GlobalUser.get(user_id=mention).update( global_role=global_role_default ) await message(\"\u0410\u0434\u043c\u0438\u043d\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0441\u043d\u044f\u0442\u0430!\") @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0431\u0434 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c <model_name> <value>\") async def add_to_db(message: Message, _: Optional[User]=None, model_name: str=None, value: str=None): value=eval(value) if model_name==\"GlobalRole\": returnable=await GlobalRole(name=value[\"name\"]).save() elif model_name==\"GlobalUser\": returnable=await GlobalUser( user_id=value[\"user_id\"], global_role=value[\"global_role\"] ).save() elif model_name==\"User\": returnable=await User(**value).save() elif model_name==\"Conversation\": returnable=await Conversation(**value).save() elif model_name==\"Work\": returnable=await Work(**value).save() elif model_name==\"Car\": returnable=await Car(**value).save() await message(str(returnable)) @bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0431\u0434 \u0443\u0434\u0430\u043b\u0438\u0442\u044c <model> <value>\") async def delete_from_db(message: Message, _: Optional[User]=None, model: str=None, value: str=None): try: value=eval(value) if model==\"GlobalRole\": await GlobalRole.get(name=value[\"name\"]).delete() elif model==\"GlobalUser\": await GlobalUser.get( user_id=value[\"user_id\"], global_role=value[\"global_role\"] ).delete() elif model==\"User\": await User.get(**value).delete() elif model==\"Conversation\": await Conversation.get(**value).delete() elif model==\"Work\": await Work.get(**value).delete() elif model==\"Car\": await Car.get(**value).delete() await message(\"\u0423\u0434\u0430\u043b\u0435\u043d\u043e!\") except Exception as _: await message(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f!\") @bp.on.message_handler(OnlyBotModerAccess(), text=\"\/\u0434\u043e\u0441\u0442\u0443\u043f\", lower=True) async def access_message(message: Message, _: Optional[User]=None): global access_for_all access_for_all=not access_for_all with open(\"settings.json\", \"w\") as write_file: ujson.dump({\"access\": access_for_all}, write_file) if access_for_all: await message(\"\u0414\u043e\u0441\u0442\u0443\u043f \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043b\u044f \u0432\u0441\u0435\u0445\") else: await message(\"\u0414\u043e\u0441\u0442\u0443\u043f \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u0432\") ","sourceWithComments":"import random\nimport sys\nfrom typing import Optional\n\nfrom tortoise import Tortoise\nfrom vkbottle.bot import Blueprint\n\nfrom utils.consts import MAX_RANDOM_ID_INT, MIN_RANDOM_ID_INT\nfrom global_settings import *\nfrom models import Conversation, User, Work\nfrom rules import *\nfrom utils.main import is_mention\n\nsys.path.append(\"..\")\nbp = Blueprint(name=\"Working with global admin functions\")\n\n\n@bp.on.message_handler(OnlyBotAdminAccess(), text=\"\/\u0440\u0430\u0437\u043e\u0441\u043b\u0430\u0442\u044c <text>\", lower=True)\nasync def send_messages(message: Message, _: Optional[User] = None, text: str = None):\n    await BOT.api.request(\n        \"messages.markAsRead\",\n        {\"peer_id\": message.peer_id, \"mark_conversation_as_read\": \"1\"},\n    )\n    convs = await Conversation.all().values_list(\"peer_id\", flat=True)\n    if convs:\n        for conv in convs:\n            await BOT.api.messages.send(\n                peer_id=conv, random_id=random.randint(MIN_RANDOM_ID_INT, MAX_RANDOM_ID_INT), message=text\n            )\n\n    await message(\"\u0412\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u043e.\")\n\n\n@bp.on.message_handler(OnlyMaximSend(), text=\"\/\u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c_\u0441\u0435\u0431\u044f\")\nasync def get_myself(message: Message, _: Optional[User] = None):\n    conn = Tortoise.get_connection(\"default\")\n    # TODO: \u043f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u0442\u044c dct, \u043c\u0430\u0433\u0438\u0447\u0435\u0441\u043a\u0438 \u0446\u0438\u0444\u0440\u044b \u0432 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443\n    # dct = await conn.execute_query_dict(\n    #    \"SELECT * FROM `users` WHERE `user_id` = 500101793\"\n    # )\n    dct = await User.get(user_id=500101793)\n    await message(dct)\n\n\n# TODO: \u043d\u0443\u0436\u043d\u043e \u043b\u0438?\n@bp.on.message_handler(OnlyBotModerAccess(), text=\"\/mention <mention>\", lower=True)\nasync def mention_test(message: Message, _: Optional[User] = None, mention: str = None):\n    print(mention.split(\"|\")[0][1:])\n    await message(\"[id{0}|Maxim]\".format(message.from_id))\n\n\n@bp.on.message_handler(OnlyBotModerAccess(), text=\"~ <text>\", lower=True)\nasync def print_or_count(message: Message, _: Optional[User] = None, text: str = None):\n    try:\n        text = text.replace(\" \", \"\")\n        copied_text = text\n\n        # TODO: \u0432 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443 \u0432 config.py\n        allowed_words = []\n        allowed_words.extend([str(a) for a in range(10)])\n        allowed_words.extend(\n            [\n                \"sin\",\n                \"sqrt\",\n                \"+\",\n                \"-\",\n                \"j\",\n                \"*\",\n                \"\/\",\n                \"(\",\n                \")\",\n                \"cos\",\n                \"tan\",\n                \"e\",\n                \"pi\",\n                \"ceil\",\n                \"copysign\",\n                \"fabs\",\n                \"factorial\",\n                \"floor\",\n                \"fmod\",\n                \"frexp\",\n                \"ldexp\",\n                \"fsum\",\n                \"isfinite\",\n                \"isinf\",\n                \"isnan\",\n                \"modf\",\n                \"trunc\",\n                \"exp\",\n                \"expm1\",\n                \"log\",\n                \"log1p\",\n                \"log10\",\n                \"log2\",\n                \"pow\",\n                \"acos\",\n                \"asin\",\n                \"atan\",\n                \"atan2\",\n                \"hypot\",\n                \"degrees\",\n                \"radians\",\n                \"cosh\",\n                \"sinh\",\n                \"tanh\",\n                \"**\",\n                \"acosh\",\n                \"asinh\",\n                \"atanh\",\n                \"gamma\",\n                \"lgamma\",\n            ]\n        )\n        awset = set(allowed_words)\n\n        for i in awset:\n            if i in copied_text:\n                copied_text = copied_text.replace(i, \"\")\n\n        if copied_text == \"\":\n            all_good = True\n        else:\n            all_good = False\n\n        if all_good:\n            # TODO: \u0442\u0435\u0441\u0442\u044b \u0434\u043b\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u0435\u0432\u0430\u043b\u0430 \u043d\u0430 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u044c !!!\n            summ = eval(text)\n            await message(summ)\n        else:\n            await message(text)\n\n    except ZeroDivisionError:\n        await message(\"+-inf\")\n    except Exception:\n        await message(text)\n\n\n# TODO: \u0432\u044b\u0434\u0435\u043b\u0438\u0442\u044c \u0445\u0435\u0440\u043e\u0442\u0443 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c \"\u0440\u043e\u043b\u044c\"\n@bp.on.message_handler(OnlyBotAdminAccess(), text=\"\/\u0441\u043d\u044f\u0442\u044c_\u043c\u043e\u0434\u0435\u0440 <mention>\", lower=True)\nasync def delete_bot_moder(message: Message, mention: str, _: Optional[User] = None):\n    if (is_mention(mention))[0]:\n        mention = (is_mention(mention))[1]\n\n    else:\n        await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043d\u044f\u0442\u044c \u043c\u043e\u0434\u0435\u0440\u043a\u0443!\")\n        return\n\n    global_role_default = await GlobalRole.get(name=\"Default\")\n    await GlobalUser.get(user_id=mention).update(\n        global_role=global_role_default\n    )\n    await message(\"\u041c\u043e\u0434\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0441\u043d\u044f\u0442\u0430!\")\n\n\n@bp.on.message_handler(OnlyBotAdminAccess(), text=\"\/\u0434\u0430\u0442\u044c_\u043c\u043e\u0434\u0435\u0440 <mention>\", lower=True)\nasync def give_bot_moder(message: Message, mention: str, _: Optional[User] = None):\n    if (is_mention(mention))[0]:\n        mention = (is_mention(mention))[1]\n\n    else:\n        await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u0430\u0442\u044c \u043f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430!\")\n        return\n\n    global_role_moder = await GlobalRole.get(name=\"Moderator\")\n    await GlobalUser.get(user_id=mention).update(\n        global_role=global_role_moder\n    )\n    await message(\"\u041f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0432\u044b\u0434\u0430\u043d\u044b!\")\n\n\n@bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0434\u0430\u0442\u044c_\u0430\u0434\u043c\u0438\u043d <mention>\", lower=True)\nasync def give_bot_admin(message: Message, _: Optional[User] = None, mention: str = None):\n    if (is_mention(mention))[0]:\n        mention = (is_mention(mention))[1]\n\n    else:\n        await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u0430\u0442\u044c \u043f\u0440\u0430\u0432\u0430 \u043c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440\u0430!\")\n        return\n\n    global_role_moder = await GlobalRole.get(name=\"Administrator\")\n    await GlobalUser.get(user_id=mention).update(\n        global_role=global_role_moder\n    )\n    await message(\"\u041f\u0440\u0430\u0432\u0430 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0432\u044b\u0434\u0430\u043d\u044b!\")\n\n\n@bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0441\u043d\u044f\u0442\u044c_\u0430\u0434\u043c\u0438\u043d <mention>\", lower=True)\nasync def delete_bot_admin(message: Message, _: Optional[User] = None, mention: str = None):\n    if (is_mention(mention))[0]:\n        mention = (is_mention(mention))[1]\n\n    else:\n        await message(\"\u041c\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0443\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043d\u044f\u0442\u044c \u0430\u0434\u043c\u0438\u043d\u043a\u0443!\")\n        return\n\n    global_role_default = await GlobalRole.get(name=\"Default\")\n    await GlobalUser.get(user_id=mention).update(\n        global_role=global_role_default\n    )\n    await message(\"\u0410\u0434\u043c\u0438\u043d\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0441\u043d\u044f\u0442\u0430!\")\n\n\n# TODO: \u0412\u044b\u0434\u0435\u043b\u0438\u0442\u044c \u0432 \u043c\u0435\u0442\u043e\u0434 \u0434\u0432\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u044f\n@bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0431\u0434 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c <model_name> <value>\")\nasync def add_to_db(message: Message, _: Optional[User] = None, model_name: str = None, value: str = None):\n    # TODO: \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u043a \u0441\u043b\u043e\u0432\u0430\u0440\u044e\n    value = eval(value)\n    if model_name == \"GlobalRole\":\n        returnable = await GlobalRole(name=value[\"name\"]).save()\n    elif model_name == \"GlobalUser\":\n        returnable = await GlobalUser(\n            user_id=value[\"user_id\"], global_role=value[\"global_role\"]\n        ).save()\n    elif model_name == \"User\":\n        returnable = await User(**value).save()\n    elif model_name == \"Conversation\":\n        returnable = await Conversation(**value).save()\n    elif model_name == \"Work\":\n        returnable = await Work(**value).save()\n    elif model_name == \"Car\":\n        returnable = await Car(**value).save()\n\n    await message(str(returnable))\n\n\n@bp.on.message_handler(OnlyMaximSend(), text=\"\/\u0431\u0434 \u0443\u0434\u0430\u043b\u0438\u0442\u044c <model> <value>\")\nasync def delete_from_db(message: Message, _: Optional[User] = None, model: str = None, value: str = None):\n    try:\n        # TODO: \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u043a \u0441\u043b\u043e\u0432\u0430\u0440\u044e\n        value = eval(value)\n        if model == \"GlobalRole\":\n            await GlobalRole.get(name=value[\"name\"]).delete()\n        elif model == \"GlobalUser\":\n            await GlobalUser.get(\n                user_id=value[\"user_id\"], global_role=value[\"global_role\"]\n            ).delete()\n        elif model == \"User\":\n            await User.get(**value).delete()\n        elif model == \"Conversation\":\n            await Conversation.get(**value).delete()\n        elif model == \"Work\":\n            await Work.get(**value).delete()\n        elif model == \"Car\":\n            await Car.get(**value).delete()\n\n        await message(\"\u0423\u0434\u0430\u043b\u0435\u043d\u043e!\")\n    except Exception as _:\n        await message(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f!\")\n\n\n# TODO: \u0438\u0441\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u043c\u0435\u0442\u043e\u0434\n@bp.on.message_handler(OnlyBotModerAccess(), text=\"\/\u0434\u043e\u0441\u0442\u0443\u043f\", lower=True)\nasync def access_message(message: Message, _: Optional[User] = None):\n    global access_for_all  # ?\n    access_for_all = not access_for_all\n    with open(\"settings.json\", \"w\") as write_file:\n        ujson.dump({\"access\": access_for_all}, write_file)\n\n    if access_for_all:\n        await message(\"\u0414\u043e\u0441\u0442\u0443\u043f \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0434\u043b\u044f \u0432\u0441\u0435\u0445\")\n    else:\n        await message(\"\u0414\u043e\u0441\u0442\u0443\u043f \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u0432\")\n"},"\/routes\/users_realize.py":{"changes":[{"diff":"\n import os\n-import random\n import sys\n from typing import Optional\n \n import aiohttp\n+import ujson\n from vkbottle.bot import Blueprint\n \n from global_settings import *\n from models import User\n from rules import *\n-from utils.main import check_or_create, make_profile_photo\n+from utils.db_methods import check_or_create\n+from utils.main import make_profile_photo, send_with_bomb, create_poll, is_replied_self\n \n sys.path.append(\"..\")\n bp = Blueprint(name=\"Working with users functions\")\n","add":3,"remove":2,"filename":"\/routes\/users_realize.py","badparts":["import random","from utils.main import check_or_create, make_profile_photo"],"goodparts":["import ujson","from utils.db_methods import check_or_create","from utils.main import make_profile_photo, send_with_bomb, create_poll, is_replied_self"]},{"diff":"\n \n @bp.on.message_handler(AccessForAllRule(), text=\"\u043c\u0430\u043a\u0441\u0438\u043c\", lower=True)\n async def maxim_message(ans: Message, _: Optional[User] = None):\n-    #TODO: \u0432\u0437\u044f\u0442\u044c 2e9 \u0438\u0437 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\n-    #TODO: \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 - \u0432 \u043e\u0442\u0435\u0434\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n-    await USER.api.request(\n-        \"messages.send\",\n-        {\n-            \"message\": \"\u041c\u0430\u043a\u0441\u0438\u043c \u0430\u0434\u043c\u0438\u043d \u0442\u0443\u0442 \u0434\u0430 \u0430\u0433\u0430 \u0431\u043e\u0442\u0430 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0431\u0435\u0441\u0435\u0434\u0435 \u043f\u043e\u0432\u0435\u043b\u0438\u0432\u0430\u0442\u0435\u043b\u044c \u0430\u0433\u0430 \u0434\u0430 \u043c-\u0434\u0430...\",\n-            \"group_id\": BOT.group_id,\n-            \"peer_id\": ans.peer_id,\n-            \"expire_ttl\": \"20\",\n-            \"random_id\": random.randint(-2e9, 2e9),\n-        },\n-    )\n+    await send_with_bomb(\"\u041c\u0430\u043a\u0441\u0438\u043c \u0430\u0434\u043c\u0438\u043d \u0442\u0443\u0442 \u0434\u0430 \u0430\u0433\u0430 \u0431\u043e\u0442\u0430 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0431\u0435\u0441\u0435\u0434\u0435 \u043f\u043e\u0432\u0435\u043b\u0438\u0432\u0430\u0442\u0435\u043b\u044c \u0430\u0433\u0430 \u0434\u0430 \u043c-\u0434\u0430...\", ans.peer_id)\n \n \n @bp.on.message_handler(AccessForAllRule(), text=\"\u043c\u0434\u0430\", lower=True)\n async def mda_message(ans: Message, _: Optional[User] = None):\n-    #TODO: \u0432\u0437\u044f\u0442\u044c 2e9 \u0438\u0437 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\n-    #TODO: \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 - \u0432 \u043e\u0442\u0435\u0434\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n-    await USER.api.request(\n-        \"messages.send\",\n-        {\n-            \"message\": \"\u0414\u0430 \u043c\u0434\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e \u044d\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043c\u0434\u0430 \u0447\u0442\u043e \u043f\u0440\u044f\u043c\u043e \u043c-\u0434\u0430...\",\n-            \"group_id\": BOT.group_id,\n-            \"peer_id\": ans.peer_id,\n-            \"expire_ttl\": \"20\",\n-            \"random_id\": random.randint(-2e9, 2e9),\n-        },\n-    )\n+    await send_with_bomb(\"\u0414\u0430 \u043c\u0434\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e \u044d\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043c\u0434\u0430 \u0447\u0442\u043e \u043f\u0440\u044f\u043c\u043e \u043c-\u0434\u0430...\", ans.peer_id)\n \n \n @bp.on.message_handler(AccessForAllRule(), text=[\"\/\u043f\u0440\u043e\u0444\u0438\u043b\u044c\", \"\/profile\"], lower=True)\n","add":2,"remove":24,"filename":"\/routes\/users_realize.py","badparts":["    await USER.api.request(","        \"messages.send\",","        {","            \"message\": \"\u041c\u0430\u043a\u0441\u0438\u043c \u0430\u0434\u043c\u0438\u043d \u0442\u0443\u0442 \u0434\u0430 \u0430\u0433\u0430 \u0431\u043e\u0442\u0430 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0431\u0435\u0441\u0435\u0434\u0435 \u043f\u043e\u0432\u0435\u043b\u0438\u0432\u0430\u0442\u0435\u043b\u044c \u0430\u0433\u0430 \u0434\u0430 \u043c-\u0434\u0430...\",","            \"group_id\": BOT.group_id,","            \"peer_id\": ans.peer_id,","            \"expire_ttl\": \"20\",","            \"random_id\": random.randint(-2e9, 2e9),","        },","    )","    await USER.api.request(","        \"messages.send\",","        {","            \"message\": \"\u0414\u0430 \u043c\u0434\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e \u044d\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043c\u0434\u0430 \u0447\u0442\u043e \u043f\u0440\u044f\u043c\u043e \u043c-\u0434\u0430...\",","            \"group_id\": BOT.group_id,","            \"peer_id\": ans.peer_id,","            \"expire_ttl\": \"20\",","            \"random_id\": random.randint(-2e9, 2e9),","        },","    )"],"goodparts":["    await send_with_bomb(\"\u041c\u0430\u043a\u0441\u0438\u043c \u0430\u0434\u043c\u0438\u043d \u0442\u0443\u0442 \u0434\u0430 \u0430\u0433\u0430 \u0431\u043e\u0442\u0430 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0431\u0435\u0441\u0435\u0434\u0435 \u043f\u043e\u0432\u0435\u043b\u0438\u0432\u0430\u0442\u0435\u043b\u044c \u0430\u0433\u0430 \u0434\u0430 \u043c-\u0434\u0430...\", ans.peer_id)","    await send_with_bomb(\"\u0414\u0430 \u043c\u0434\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e \u044d\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043c\u0434\u0430 \u0447\u0442\u043e \u043f\u0440\u044f\u043c\u043e \u043c-\u0434\u0430...\", ans.peer_id)"]}],"source":"\nimport os import random import sys from typing import Optional import aiohttp from vkbottle.bot import Blueprint from global_settings import * from models import User from rules import * from utils.main import check_or_create, make_profile_photo sys.path.append(\"..\") bp=Blueprint(name=\"Working with users functions\") @bp.on.message_handler(AccessForAllRule(), text=\"\u043f\u0440\u0438\u0432\u0435\u0442\", lower=True) async def hi_message(ans: Message, _: Optional[User]=None): await ans(\"\u041f\u0440\u0438\u0432\u0435\u0442, \u0447\u0443\u0432\u0430\u0447\u0435\u043b\u043b\u0430\") @bp.on.message_handler(AccessForAllRule(), text=\"\u043c\u0430\u043a\u0441\u0438\u043c\", lower=True) async def maxim_message(ans: Message, _: Optional[User]=None): await USER.api.request( \"messages.send\", { \"message\": \"\u041c\u0430\u043a\u0441\u0438\u043c \u0430\u0434\u043c\u0438\u043d \u0442\u0443\u0442 \u0434\u0430 \u0430\u0433\u0430 \u0431\u043e\u0442\u0430 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0431\u0435\u0441\u0435\u0434\u0435 \u043f\u043e\u0432\u0435\u043b\u0438\u0432\u0430\u0442\u0435\u043b\u044c \u0430\u0433\u0430 \u0434\u0430 \u043c-\u0434\u0430...\", \"group_id\": BOT.group_id, \"peer_id\": ans.peer_id, \"expire_ttl\": \"20\", \"random_id\": random.randint(-2e9, 2e9), }, ) @bp.on.message_handler(AccessForAllRule(), text=\"\u043c\u0434\u0430\", lower=True) async def mda_message(ans: Message, _: Optional[User]=None): await USER.api.request( \"messages.send\", { \"message\": \"\u0414\u0430 \u043c\u0434\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e \u044d\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043c\u0434\u0430 \u0447\u0442\u043e \u043f\u0440\u044f\u043c\u043e \u043c-\u0434\u0430...\", \"group_id\": BOT.group_id, \"peer_id\": ans.peer_id, \"expire_ttl\": \"20\", \"random_id\": random.randint(-2e9, 2e9), }, ) @bp.on.message_handler(AccessForAllRule(), text=[\"\/\u043f\u0440\u043e\u0444\u0438\u043b\u044c\", \"\/profile\"], lower=True) async def profile_message(message: Message, profile: Optional[User]=None): if message.reply_message \\ and((message.from_id !=message.reply_message) and(message.from_id not in ADMINS_IN_CONV)): await message(\"\u0414\u043e\u0441\u0442\u0443\u043f \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d!\") return upload_srv=(await BOT.api.photos.get_messages_upload_server()).upload_url await make_profile_photo(profile) files={'photo': open(f\"{profile.user_id}.jpeg\", \"rb\")} async with aiohttp.ClientSession() as session: async with session.post(upload_srv, data=files) as resp: data=await resp.read() ready_json=ujson.loads(data) photo_object=await BOT.api.photos.save_messages_photo( server=ready_json[\"server\"], photo=ready_json[\"photo\"], hash=ready_json[\"hash\"]) os.remove(f\"{profile.user_id}.jpeg\") await message(attachment=f\"photo{photo_object[0].owner_id}_{photo_object[0].id}\") @bp.on.chat_message(AccessForAllRule(), text=\"\/\u0432\u0441\u0435\u043f\u0440\u0435\u0434\u044b\", lower=True) async def watch_all_warns(message: Message, user: Optional[User]=None): if not message.reply_message: if user.warns==0: await message( f\"\u0423 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID{message.from_id} \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u044f!\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e!\" ) else: await message( f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439 \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID{message.from_id}:{user.warns}\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \" f\"\u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \" ) if( message.from_id not in ADMINS_IN_CONV and message.reply_message.from_id !=message.from_id ): await message( \"\u0422\u0435\u0431\u0435 \u0434\u043e\u0441\u0442\u0443\u043f \u0441\u044e\u0434\u0430 \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d, \u043f\u043e\u043d\u0438\u043c\u0430\u0435\u0448\u044c? \u041d\u0430\u0434\u0435\u044e\u0441\u044c, \u0434\u0430. **\u0422\u0438\u0445\u043e* \u041e\u043f\u044f\u0442\u044c \u044d\u0442\u0438 \u0434\u0430\u0443\u043d\u044b \u043c\u0435\u043d\u044f \u043d\u0435 \u043f\u043e \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u044e\u0437\u0430\u044e\u0442* \" \":(\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \" ) else: await check_or_create(message.reply_message.from_id, message.peer_id) user_from_message=await User.get_or_none( user_id=message.reply_message.from_id, peer_id=message.peer_id ) if user_from_message is not None and user_from_message.warns !=0: await message( f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439 \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID{message.reply_message.from_id}: \" f\"{user_from_message.warns}\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e!\" ) else: if user_from_message is None: await User( user_id=message.reply_message.from_id, peer_id=message.peer_id ).save() await message( f\"\u0423 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID{message.reply_message.from_id} \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u044f!\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \" f\"\u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \" ) @bp.on.message_handler(AccessForAllRule(), text=[\"\/\u043f\u043e\u043c\u043e\u0449\u044c\", \"\/help\"], lower=True) async def help_message(message: Message, _: Optional[User]=None): await USER.api.request( \"messages.send\", { \"message\": \"\u041f\u0440\u0438\u0432\u0435\u0442 -\u0438 \u0442\u0435\u0431\u0435 \u043f\u0440\u0438\u0432\u0435\u0442!\\n\u041c\u0430\u043a\u0441\u0438\u043c -\u043e\u043d \u0442\u0443\u0442 \u0430\u0434\u043c\u0438\u043d\\n\/\u043f\u0440\u0435\u0434 -(\u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u0432!) \u0432\u044b\u0434\u0430\u0442\u044c \" \"\u043f\u0440\u0435\u0434. \u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u044e\u0437\u0435\u0440\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u043d\u0430\u0434\u043e \u0434\u0430\u0442\u044c \u043f\u0440\u0435\u0434\\n\/\u0432\u0441\u0435\u043f\u0440\u0435\u0434\u044b -\u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0432\u0441\u0435 \" \"\u043f\u0440\u0435\u0434\u044b. \u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\u043c \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440 \u043f\u0440\u0435\u0434\u043e\u0432 \u0432\u0441\u0435\u0445 \u044e\u0437\u0435\u0440\u043e\u0432, \u043e\u0431\u044b\u0447\u043d\u044b\u043c \u044e\u0437\u0435\u0440\u0430\u043c -\u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0432\u043e\u0438\u0445. \" \"\u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u043f\u0440\u0435\u0434\u044b \u0447\u044c\u0435\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c\\n\/voteban \u0441 \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u043d\u043d\u044b\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435\u043c -\" \"\u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\\n\/\u0438\u043d\u0444\u043e\u0434\u043e\u0441\u0442\u0443\u043f -\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u043b\u0438 \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \" \"\u0432 \u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442\\n\/\u043f\u0440\u043e\u0444\u0438\u043b\u044c -\u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0441\u0432\u043e\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c\\n\/\u043a\u043e\u043d\u0442\u0430\u043a\u0442\u044b -\u0441\u0441\u044b\u043b\u043a\u0438 \u043d\u0430 \u0441\u0432\u044f\u0437\u044c \u0441 \" \"\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c\", \"group_id\": BOT.group_id, \"peer_id\": message.peer_id, \"expire_ttl\": \"120\", \"random_id\": random.randint(int(-2e9), int(2e9)), }, ) @bp.on.message_handler(AccessForAllRule(), text=\"\/voteban\", lower=True) async def voteban_message(message: Message, _: Optional[User]=None): if message.reply_message: await check_or_create(message.reply_message.from_id, message.peer_id) if( message.reply_message.from_id==message.from_id or message.reply_message.from_id in ADMINS_IN_CONV or message.reply_message.from_id==-BOT.group_id ): await message(\"\u041f\u0440\u043e\u0441\u0442\u043e \u043f\u043e\u043f\u0440\u043e\u0441\u0438 \u0431\u0430\u043d\u0430 \u0441\u0435\u0431\u0435, \u0430\") else: poll=await USER.api.request( \"polls.create\", { \"question\": f\"\u0413\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID{message.reply_message.from_id}\", \"is_anonymous\": 1, \"is_multiply\": 0, \"add_answers\": '[\"\u0417\u0430\",\"\u041f\u0440\u043e\u0442\u0438\u0432\"]', \"disable_unvote\": 0, }, ) await message(attachment=f\"poll{poll['owner_id']}_{poll['id']}\") else: await message( \"\u041f\u0435\u0440\u0435\u0448\u043b\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043d\u0430\u0447\u0430\u0442\u044c \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d!\" ) @bp.on.message_handler(text=\"\/\u0438\u043d\u0444\u043e\u0434\u043e\u0441\u0442\u0443\u043f\", lower=True) async def check_access_message(message: Message, _: Optional[User]=None): access=\"\u0440\u0430\u0437\u0440\u0435\u0448\u0451\u043d\" if access_for_all else \"\u0437\u0430\u043f\u0440\u0435\u0449\u0451\u043d\" await message(f\"\u0414\u043e\u0441\u0442\u0443\u043f \u043a \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439{access}\") @bp.on.message_handler(AccessForAllRule(), text=\"\/\u043a\u043e\u043d\u0442\u0430\u043a\u0442\u044b\", lower=True) async def get_contacts(message: Message, _: Optional[User]=None): name=(await BOT.api.users.get(message.from_id))[0].first_name await message( \"[id{0}|{1}], \u0441\u043f\u0438\u0441\u043e\u043a \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043e\u0432 \u0441 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c:\\nVK: vk.com\/jottyfounder\\nMail: \" \"vladislavbusiness@jottymdbbot.xyz\\n\u041f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u043e \u0431\u043e\u0442\u0443 \u043f\u0438\u0441\u0430\u0442\u044c \u043d\u0430 \u043f\u043e\u0447\u0442\u0443.\".format( message.from_id, name ) ) ","sourceWithComments":"import os\nimport random\nimport sys\nfrom typing import Optional\n\nimport aiohttp\nfrom vkbottle.bot import Blueprint\n\nfrom global_settings import *\nfrom models import User\nfrom rules import *\nfrom utils.main import check_or_create, make_profile_photo\n\nsys.path.append(\"..\")\nbp = Blueprint(name=\"Working with users functions\")\n\n\n@bp.on.message_handler(AccessForAllRule(), text=\"\u043f\u0440\u0438\u0432\u0435\u0442\", lower=True)\nasync def hi_message(ans: Message, _: Optional[User] = None):\n    await ans(\"\u041f\u0440\u0438\u0432\u0435\u0442, \u0447\u0443\u0432\u0430\u0447\u0435\u043b\u043b\u0430\")\n\n\n@bp.on.message_handler(AccessForAllRule(), text=\"\u043c\u0430\u043a\u0441\u0438\u043c\", lower=True)\nasync def maxim_message(ans: Message, _: Optional[User] = None):\n    #TODO: \u0432\u0437\u044f\u0442\u044c 2e9 \u0438\u0437 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\n    #TODO: \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 - \u0432 \u043e\u0442\u0435\u0434\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n    await USER.api.request(\n        \"messages.send\",\n        {\n            \"message\": \"\u041c\u0430\u043a\u0441\u0438\u043c \u0430\u0434\u043c\u0438\u043d \u0442\u0443\u0442 \u0434\u0430 \u0430\u0433\u0430 \u0431\u043e\u0442\u0430 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0431\u0435\u0441\u0435\u0434\u0435 \u043f\u043e\u0432\u0435\u043b\u0438\u0432\u0430\u0442\u0435\u043b\u044c \u0430\u0433\u0430 \u0434\u0430 \u043c-\u0434\u0430...\",\n            \"group_id\": BOT.group_id,\n            \"peer_id\": ans.peer_id,\n            \"expire_ttl\": \"20\",\n            \"random_id\": random.randint(-2e9, 2e9),\n        },\n    )\n\n\n@bp.on.message_handler(AccessForAllRule(), text=\"\u043c\u0434\u0430\", lower=True)\nasync def mda_message(ans: Message, _: Optional[User] = None):\n    #TODO: \u0432\u0437\u044f\u0442\u044c 2e9 \u0438\u0437 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\n    #TODO: \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 - \u0432 \u043e\u0442\u0435\u0434\u043b\u044c\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434\n    await USER.api.request(\n        \"messages.send\",\n        {\n            \"message\": \"\u0414\u0430 \u043c\u0434\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e \u044d\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043c\u0434\u0430 \u0447\u0442\u043e \u043f\u0440\u044f\u043c\u043e \u043c-\u0434\u0430...\",\n            \"group_id\": BOT.group_id,\n            \"peer_id\": ans.peer_id,\n            \"expire_ttl\": \"20\",\n            \"random_id\": random.randint(-2e9, 2e9),\n        },\n    )\n\n\n@bp.on.message_handler(AccessForAllRule(), text=[\"\/\u043f\u0440\u043e\u0444\u0438\u043b\u044c\", \"\/profile\"], lower=True)\nasync def profile_message(message: Message, profile: Optional[User] = None):\n    if message.reply_message \\\n            and ((message.from_id != message.reply_message)\n                 and (message.from_id not in ADMINS_IN_CONV)):\n        await message(\"\u0414\u043e\u0441\u0442\u0443\u043f \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d!\")\n        return\n\n    upload_srv = (await BOT.api.photos.get_messages_upload_server()).upload_url\n\n    await make_profile_photo(profile)\n    files = {'photo': open(f\"{profile.user_id}.jpeg\", \"rb\")}\n    async with aiohttp.ClientSession() as session:\n        async with session.post(upload_srv, data=files) as resp:\n            data = await resp.read()\n            ready_json = ujson.loads(data)\n\n    photo_object = await BOT.api.photos.save_messages_photo(\n        server=ready_json[\"server\"],\n        photo=ready_json[\"photo\"],\n        hash=ready_json[\"hash\"])\n\n    os.remove(f\"{profile.user_id}.jpeg\")\n    await message(attachment=f\"photo{photo_object[0].owner_id}_{photo_object[0].id}\")\n\n\n#TODO: \u0440\u0430\u0441\u043f\u0438\u043b\u0438\u0442\u044c \u0432\u0441\u0451 \u043d\u0430 \u043c\u0435\u0442\u043e\u0434\u044b\n@bp.on.chat_message(AccessForAllRule(), text=\"\/\u0432\u0441\u0435\u043f\u0440\u0435\u0434\u044b\", lower=True)\nasync def watch_all_warns(message: Message, user: Optional[User] = None):\n    if not message.reply_message:\n        if user.warns == 0:\n\n            await message(\n                f\"\u0423 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.from_id} \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u044f!\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e!\"\n            )\n        else:\n            await message(\n                f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439 \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.from_id}: {user.warns}\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \"\n                f\"\u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \"\n            )\n\n    if (\n            message.from_id not in ADMINS_IN_CONV\n            and message.reply_message.from_id != message.from_id\n    ):\n        await message(\n            \"\u0422\u0435\u0431\u0435 \u0434\u043e\u0441\u0442\u0443\u043f \u0441\u044e\u0434\u0430 \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d, \u043f\u043e\u043d\u0438\u043c\u0430\u0435\u0448\u044c? \u041d\u0430\u0434\u0435\u044e\u0441\u044c, \u0434\u0430. **\u0422\u0438\u0445\u043e* \u041e\u043f\u044f\u0442\u044c \u044d\u0442\u0438 \u0434\u0430\u0443\u043d\u044b \u043c\u0435\u043d\u044f \u043d\u0435 \u043f\u043e \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u044e\u0437\u0430\u044e\u0442* \"\n            \":(\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \"\n        )\n    else:\n        await check_or_create(message.reply_message.from_id, message.peer_id)\n        user_from_message = await User.get_or_none(\n            user_id=message.reply_message.from_id, peer_id=message.peer_id\n        )\n        if user_from_message is not None and user_from_message.warns != 0:\n            await message(\n                f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439 \u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.reply_message.from_id}: \"\n                f\"{user_from_message.warns}\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e!\"\n            )\n        else:\n            if user_from_message is None:\n                await User(\n                    user_id=message.reply_message.from_id, peer_id=message.peer_id\n                ).save()\n            await message(\n                f\"\u0423 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.reply_message.from_id} \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u044f!\\n\u041a\u043e\u043c\u0430\u043d\u0434\u0430 \"\n                f\"\u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044e! \"\n            )\n\n\n#TODO: \u0432\u0437\u044f\u0442\u044c \u0438\u0437 \u043c\u0435\u0442\u043e\u0434\u0430\n@bp.on.message_handler(AccessForAllRule(), text=[\"\/\u043f\u043e\u043c\u043e\u0449\u044c\", \"\/help\"], lower=True)\nasync def help_message(message: Message, _: Optional[User] = None):\n    await USER.api.request(\n        \"messages.send\",\n        {\n            \"message\": \"\u041f\u0440\u0438\u0432\u0435\u0442 - \u0438 \u0442\u0435\u0431\u0435 \u043f\u0440\u0438\u0432\u0435\u0442!\\n\u041c\u0430\u043a\u0441\u0438\u043c - \u043e\u043d \u0442\u0443\u0442 \u0430\u0434\u043c\u0438\u043d\\n\/\u043f\u0440\u0435\u0434 - (\u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u0432!) \u0432\u044b\u0434\u0430\u0442\u044c \"\n                       \"\u043f\u0440\u0435\u0434. \u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u044e\u0437\u0435\u0440\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u043d\u0430\u0434\u043e \u0434\u0430\u0442\u044c \u043f\u0440\u0435\u0434\\n\/\u0432\u0441\u0435\u043f\u0440\u0435\u0434\u044b - \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0432\u0441\u0435 \"\n                       \"\u043f\u0440\u0435\u0434\u044b. \u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430\u043c \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440 \u043f\u0440\u0435\u0434\u043e\u0432 \u0432\u0441\u0435\u0445 \u044e\u0437\u0435\u0440\u043e\u0432, \u043e\u0431\u044b\u0447\u043d\u044b\u043c \u044e\u0437\u0435\u0440\u0430\u043c - \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0432\u043e\u0438\u0445. \"\n                       \"\u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u043f\u0440\u0435\u0434\u044b \u0447\u044c\u0435\u0433\u043e \u044e\u0437\u0435\u0440\u0430 \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c\\n\/voteban \u0441 \u043f\u0435\u0440\u0435\u0441\u043b\u0430\u043d\u043d\u044b\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435\u043c - \"\n                       \"\u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\\n\/\u0438\u043d\u0444\u043e\u0434\u043e\u0441\u0442\u0443\u043f - \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d \u043b\u0438 \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \"\n                       \"\u0432 \u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442\\n\/\u043f\u0440\u043e\u0444\u0438\u043b\u044c - \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0441\u0432\u043e\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c\\n\/\u043a\u043e\u043d\u0442\u0430\u043a\u0442\u044b - \u0441\u0441\u044b\u043b\u043a\u0438 \u043d\u0430 \u0441\u0432\u044f\u0437\u044c \u0441 \"\n                       \"\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c\",\n            \"group_id\": BOT.group_id,\n            \"peer_id\": message.peer_id,\n            \"expire_ttl\": \"120\",\n            \"random_id\": random.randint(int(-2e9), int(2e9)),\n        },\n    )\n\n\n@bp.on.message_handler(AccessForAllRule(), text=\"\/voteban\", lower=True)\nasync def voteban_message(message: Message, _: Optional[User] = None):\n    if message.reply_message:\n        await check_or_create(message.reply_message.from_id, message.peer_id)\n        if (\n                message.reply_message.from_id == message.from_id\n                or message.reply_message.from_id in ADMINS_IN_CONV\n                or message.reply_message.from_id == -BOT.group_id\n        ):\n            await message(\"\u041f\u0440\u043e\u0441\u0442\u043e \u043f\u043e\u043f\u0440\u043e\u0441\u0438 \u0431\u0430\u043d\u0430 \u0441\u0435\u0431\u0435, \u0430\")\n\n        else:\n            #TODO: \u0442\u043e\u0436\u0435 \u0438\u0437 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430\n            poll = await USER.api.request(\n                \"polls.create\",\n                {\n                    \"question\": f\"\u0413\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 ID {message.reply_message.from_id}\",\n                    \"is_anonymous\": 1,\n                    \"is_multiply\": 0,\n                    \"add_answers\": '[\"\u0417\u0430\",\"\u041f\u0440\u043e\u0442\u0438\u0432\"]',\n                    \"disable_unvote\": 0,\n                },\n            )\n            await message(attachment=f\"poll{poll['owner_id']}_{poll['id']}\")\n\n    else:\n        await message(\n            \"\u041f\u0435\u0440\u0435\u0448\u043b\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043d\u0430\u0447\u0430\u0442\u044c \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430 \u0431\u0430\u043d!\"\n        )\n\n\n@bp.on.message_handler(text=\"\/\u0438\u043d\u0444\u043e\u0434\u043e\u0441\u0442\u0443\u043f\", lower=True)\nasync def check_access_message(message: Message, _: Optional[User] = None):\n    access = \"\u0440\u0430\u0437\u0440\u0435\u0448\u0451\u043d\" if access_for_all else \"\u0437\u0430\u043f\u0440\u0435\u0449\u0451\u043d\"\n    await message(f\"\u0414\u043e\u0441\u0442\u0443\u043f \u043a \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 {access}\")\n\n\n@bp.on.message_handler(AccessForAllRule(), text=\"\/\u043a\u043e\u043d\u0442\u0430\u043a\u0442\u044b\", lower=True)\nasync def get_contacts(message: Message, _: Optional[User] = None):\n    name = (await BOT.api.users.get(message.from_id))[0].first_name\n    await message(\n        \"[id{0}|{1}], \u0441\u043f\u0438\u0441\u043e\u043a \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043e\u0432 \u0441 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c:\\nVK: vk.com\/jottyfounder\\nMail: \"\n        \"vladislavbusiness@jottymdbbot.xyz\\n\u041f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u043f\u043e \u0431\u043e\u0442\u0443 \u043f\u0438\u0441\u0430\u0442\u044c \u043d\u0430 \u043f\u043e\u0447\u0442\u0443.\".format(\n            message.from_id, name\n        )\n    )\n"},"\/utils\/main.py":{"changes":[{"diff":"\n+import random\n import typing\n \n import ujson\n from PIL import Image, ImageDraw, ImageFont\n+from vkbottle.types.message import Message\n \n+from config import ADMINS_IN_CONV\n+from global_settings import USER, BOT\n from models import User, GlobalUser, GlobalRole, Work, Car\n-from utils.consts import START_WRITE_POSITION_X, START_WRITE_POSITION_Y, BLACK_COLOR\n+from utils.consts import START_WRITE_POSITION_X, START_WRITE_POSITION_Y, BLACK_COLOR, MIN_RANDOM_ID_INT, \\\n+    MAX_RANDOM_ID_INT\n+from utils.db_methods import check_or_create\n+from utils.errors import WrongWarnsCountException\n \n \n def is_mention(mention: str) -> typing.Union[typing.Tuple[bool, int], typing.Tuple[bool, str]]:\n","add":8,"remove":1,"filename":"\/utils\/main.py","badparts":["from utils.consts import START_WRITE_POSITION_X, START_WRITE_POSITION_Y, BLACK_COLOR"],"goodparts":["import random","from vkbottle.types.message import Message","from config import ADMINS_IN_CONV","from global_settings import USER, BOT","from utils.consts import START_WRITE_POSITION_X, START_WRITE_POSITION_Y, BLACK_COLOR, MIN_RANDOM_ID_INT, \\","    MAX_RANDOM_ID_INT","from utils.db_methods import check_or_create","from utils.errors import WrongWarnsCountException"]},{"diff":"\n         return False, \"\"\n \n \n-async def check_or_create(\n-        user_id: int, peer_id: int, warns: int = 0\n-) -> typing.Tuple[User, GlobalUser]:\n-    \"\"\"\n-    check for user in current chat\n-    and global user in database\n-    \"\"\"\n-    profile = await User.get_or_none(user_id=user_id, peer_id=peer_id)\n-    if profile is None:\n-        await User(user_id=user_id, peer_id=peer_id, warns=warns).save()\n-        profile = await User.get(user_id=user_id, peer_id=peer_id)\n-\n-    global_profile = await GlobalUser.get_or_none(user_id=user_id)\n-    if global_profile is None:\n-        default_role = await GlobalRole.get(name=\"Default\")\n-        await GlobalUser(user_id=user_id, global_role=default_role).save()\n-        global_profile = GlobalUser.get(user_id=user_id)\n-\n-    return profile, global_profile\n-\n-\n async def get_access_for_all() -> bool:\n     with open(\"settings.json\", \"r\") as read_file:\n         data = ujson.load(read_file)\n","add":0,"remove":21,"filename":"\/utils\/main.py","badparts":["async def check_or_create(","        user_id: int, peer_id: int, warns: int = 0",") -> typing.Tuple[User, GlobalUser]:","    \"\"\"","    check for user in current chat","    and global user in database","    \"\"\"","    profile = await User.get_or_none(user_id=user_id, peer_id=peer_id)","    if profile is None:","        await User(user_id=user_id, peer_id=peer_id, warns=warns).save()","        profile = await User.get(user_id=user_id, peer_id=peer_id)","    global_profile = await GlobalUser.get_or_none(user_id=user_id)","    if global_profile is None:","        default_role = await GlobalRole.get(name=\"Default\")","        await GlobalUser(user_id=user_id, global_role=default_role).save()","        global_profile = GlobalUser.get(user_id=user_id)","    return profile, global_profile"],"goodparts":[]}],"source":"\nimport typing import ujson from PIL import Image, ImageDraw, ImageFont from models import User, GlobalUser, GlobalRole, Work, Car from utils.consts import START_WRITE_POSITION_X, START_WRITE_POSITION_Y, BLACK_COLOR def is_mention(mention: str) -> typing.Union[typing.Tuple[bool, int], typing.Tuple[bool, str]]: if all(char in mention for char in \"[|]\") and any( word in mention for word in(\"id\", \"club\") ): if \"club\" in mention: mention=mention[5:] else: mention=mention[3:] mention=int(mention.split(\"|\")[0]) return True, mention else: return False, \"\" async def check_or_create( user_id: int, peer_id: int, warns: int=0 ) -> typing.Tuple[User, GlobalUser]: \"\"\" check for user in current chat and global user in database \"\"\" profile=await User.get_or_none(user_id=user_id, peer_id=peer_id) if profile is None: await User(user_id=user_id, peer_id=peer_id, warns=warns).save() profile=await User.get(user_id=user_id, peer_id=peer_id) global_profile=await GlobalUser.get_or_none(user_id=user_id) if global_profile is None: default_role=await GlobalRole.get(name=\"Default\") await GlobalUser(user_id=user_id, global_role=default_role).save() global_profile=GlobalUser.get(user_id=user_id) return profile, global_profile async def get_access_for_all() -> bool: with open(\"settings.json\", \"r\") as read_file: data=ujson.load(read_file) access_for_all=data[\"access\"] return access_for_all async def make_profile_photo(user: User): x, y=START_WRITE_POSITION_X, START_WRITE_POSITION_Y global_user=await GlobalUser.get_or_none(user_id=user.user_id) global_role=await GlobalRole.get(global_userss=global_user.id) img=Image.open('profile_photo.jpg') draw=ImageDraw.Draw(img) font=ImageFont.truetype('Tahoma.ttf', 30) draw.text((x, y), f\"\u0412\u0430\u0448 ID:{user.user_id}\", BLACK_COLOR, font=font) y +=35 draw.text((x, y), f\"\u0412\u0430\u0448\u0430 \u0440\u043e\u043b\u044c:{global_role}\", BLACK_COLOR, font=font) y +=35 draw.text((x, y), f\"\u0414\u0435\u043d\u044c\u0433\u0438:{user.coins}\", BLACK_COLOR, font=font) y +=35 draw.text((x, y), f\"\u042d\u043d\u0435\u0440\u0433\u0438\u044f:{user.energy}\", BLACK_COLOR, font=font) y +=35 draw.text((x, y), f\"EXP:{user.exp}\", BLACK_COLOR, font=font) y +=35 job=\"\u0431\u0435\u0437\u0440\u0430\u0431\u043e\u0442\u043d\u044b\u0439\" if user.work_id_id is not None: job=(await Work.get(id=user.work_id_id)).name car=\"\u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442\" if user.car_id is not None: car=(await Car.get(id=user.car_id)).name draw.text((x, y), f\"\u0420\u0430\u0431\u043e\u0442\u0430:{job}\", BLACK_COLOR, font=font) y +=35 draw.text((x, y), f\"\u041c\u0430\u0448\u0438\u043d\u0430:{car}\", BLACK_COLOR, font=font) y +=35 draw.text((x, y), f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439:{user.warns}\", BLACK_COLOR, font=font) img.save(f\"{user.user_id}.jpeg\") ","sourceWithComments":"import typing\n\nimport ujson\nfrom PIL import Image, ImageDraw, ImageFont\n\nfrom models import User, GlobalUser, GlobalRole, Work, Car\nfrom utils.consts import START_WRITE_POSITION_X, START_WRITE_POSITION_Y, BLACK_COLOR\n\n\ndef is_mention(mention: str) -> typing.Union[typing.Tuple[bool, int], typing.Tuple[bool, str]]:\n    if all(char in mention for char in \"[|]\") and any(\n            word in mention for word in (\"id\", \"club\")\n    ):\n        if \"club\" in mention:\n            mention = mention[5:]\n        else:\n            mention = mention[3:]\n        mention = int(mention.split(\"|\")[0])\n        return True, mention\n\n    else:\n        return False, \"\"\n\n\nasync def check_or_create(\n        user_id: int, peer_id: int, warns: int = 0\n) -> typing.Tuple[User, GlobalUser]:\n    \"\"\"\n    check for user in current chat\n    and global user in database\n    \"\"\"\n    profile = await User.get_or_none(user_id=user_id, peer_id=peer_id)\n    if profile is None:\n        await User(user_id=user_id, peer_id=peer_id, warns=warns).save()\n        profile = await User.get(user_id=user_id, peer_id=peer_id)\n\n    global_profile = await GlobalUser.get_or_none(user_id=user_id)\n    if global_profile is None:\n        default_role = await GlobalRole.get(name=\"Default\")\n        await GlobalUser(user_id=user_id, global_role=default_role).save()\n        global_profile = GlobalUser.get(user_id=user_id)\n\n    return profile, global_profile\n\n\nasync def get_access_for_all() -> bool:\n    with open(\"settings.json\", \"r\") as read_file:\n        data = ujson.load(read_file)\n        access_for_all = data[\"access\"]\n\n    return access_for_all\n\n\nasync def make_profile_photo(user: User):\n    x, y = START_WRITE_POSITION_X, START_WRITE_POSITION_Y\n\n    global_user = await GlobalUser.get_or_none(user_id=user.user_id)\n    global_role = await GlobalRole.get(global_userss=global_user.id)\n\n    img = Image.open('profile_photo.jpg')\n    draw = ImageDraw.Draw(img)\n    font = ImageFont.truetype('Tahoma.ttf', 30)\n    draw.text((x, y), f\"\u0412\u0430\u0448 ID: {user.user_id}\", BLACK_COLOR, font=font)\n    y += 35\n    draw.text((x, y), f\"\u0412\u0430\u0448\u0430 \u0440\u043e\u043b\u044c: {global_role}\", BLACK_COLOR, font=font)\n    y += 35\n    draw.text((x, y), f\"\u0414\u0435\u043d\u044c\u0433\u0438: {user.coins}\", BLACK_COLOR, font=font)\n    y += 35\n    draw.text((x, y), f\"\u042d\u043d\u0435\u0440\u0433\u0438\u044f: {user.energy}\", BLACK_COLOR, font=font)\n    y += 35\n    draw.text((x, y), f\"EXP: {user.exp}\", BLACK_COLOR, font=font)\n    y += 35\n    job = \"\u0431\u0435\u0437\u0440\u0430\u0431\u043e\u0442\u043d\u044b\u0439\"\n    if user.work_id_id is not None:\n        job = (await Work.get(id=user.work_id_id)).name\n\n    car = \"\u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442\"\n    if user.car_id is not None:\n        car = (await Car.get(id=user.car_id)).name\n\n    draw.text((x, y), f\"\u0420\u0430\u0431\u043e\u0442\u0430: {job}\", BLACK_COLOR, font=font)\n    y += 35\n    draw.text((x, y), f\"\u041c\u0430\u0448\u0438\u043d\u0430: {car}\", BLACK_COLOR, font=font)\n    y += 35\n    draw.text((x, y), f\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0439: {user.warns}\", BLACK_COLOR, font=font)\n    img.save(f\"{user.user_id}.jpeg\")\n"}},"msg":"Refactor code, added utils functions, changed structure of models, FIXED SQL-INJECTION POSSIBILITY, REPLACED EVAL"}},"https:\/\/github.com\/GoosefleetEO\/aa-memberaudit":{"f2dfbcb035885dd4f5bcc4ea6ef93aeb699bbbdf":{"url":"https:\/\/api.github.com\/repos\/GoosefleetEO\/aa-memberaudit\/commits\/f2dfbcb035885dd4f5bcc4ea6ef93aeb699bbbdf","html_url":"https:\/\/github.com\/GoosefleetEO\/aa-memberaudit\/commit\/f2dfbcb035885dd4f5bcc4ea6ef93aeb699bbbdf","message":"Changed eve_xml_to_html function in core.xml_converter to use Bleach to clean the XML\n\nAdded bleach as a required package in setup.py.\nAdded properties for allowed tags, attributes, and protocols.\nChanged eve_xml_to_html() to use Bleach and removed the no longer necessary call to evexml.remove_loc_tag().\nChanged _convert_font_tag() to remove empty elements and fixed a CSS injection.\nChanged _convert_a_tag() to remove empty elements and replace the element with its children on invalid href protocol.\nAdded tests to cover the changes and validate the vulnerability mitigation.","sha":"f2dfbcb035885dd4f5bcc4ea6ef93aeb699bbbdf","keyword":"eval injection change","diff":"diff --git a\/memberaudit\/core\/xml_converter.py b\/memberaudit\/core\/xml_converter.py\nindex aa6d3c7..1684beb 100644\n--- a\/memberaudit\/core\/xml_converter.py\n+++ b\/memberaudit\/core\/xml_converter.py\n@@ -1,5 +1,6 @@\n import unicodedata\n \n+import bleach\n import bs4\n \n from eveuniverse.core import evexml\n@@ -13,6 +14,27 @@\n \n DEFAULT_FONT_SIZE = 13\n \n+EVEXML_ALLOWED_TAGS = [\n+    \"a\",\n+    \"b\",\n+    \"br\",\n+    \"font\",\n+    \"i\",\n+    \"u\",\n+]\n+\n+EVEXML_ALLOWED_ATTRIBUTES = {\n+    \"a\": [\"href\"],\n+    \"font\": [\"size\"],\n+}\n+\n+EVEXML_ALLOWED_PROTOCOLS = {\n+    \"http\",\n+    \"https\",\n+    \"showinfo\",\n+    \"killreport\",\n+}\n+\n \n def eve_xml_to_html(xml_doc: str, add_default_style: bool = False) -> str:\n     \"\"\"Converts Eve Online XML to HTML.\n@@ -22,7 +44,13 @@ def eve_xml_to_html(xml_doc: str, add_default_style: bool = False) -> str:\n     - add_default_style: When set true will add the default style to all unstyled fragments\n     \"\"\"\n     xml_doc = unicodedata.normalize(\"NFKC\", xml_doc)\n-    xml_doc = evexml.remove_loc_tag(xml_doc)\n+    xml_doc = bleach.clean(\n+        xml_doc,\n+        protocols=EVEXML_ALLOWED_PROTOCOLS,\n+        tags=EVEXML_ALLOWED_TAGS,\n+        attributes=EVEXML_ALLOWED_ATTRIBUTES,\n+        strip=True,\n+    )\n     soup = bs4.BeautifulSoup(xml_doc, \"html.parser\")\n     _convert_font_tag(soup)\n     _convert_a_tag(soup)\n@@ -34,13 +62,21 @@ def eve_xml_to_html(xml_doc: str, add_default_style: bool = False) -> str:\n def _convert_font_tag(soup):\n     \"\"\"Convert the font tags into HTML style.\"\"\"\n     for element in soup.find_all(\"font\"):\n+        if not element.contents:\n+            # Element is empty, just remove it from tree as it won't render visibly.\n+            element.decompose()\n+            continue\n         element.name = \"span\"\n         styles = []\n         if \"size\" in element.attrs:\n-            styles.append(f\"font-size: {element['size']}px\")\n+            # Cast to int and use the absolute value, otherwise use default font size.\n+            # Prevents a limited CSS injection via this attribute.\n+            try:\n+                size = abs(int(element[\"size\"]))\n+            except ValueError:\n+                size = DEFAULT_FONT_SIZE\n+            styles.append(f\"font-size: {size}px\")\n             del element[\"size\"]\n-        if \"color\" in element.attrs:\n-            del element[\"color\"]\n         if styles:\n             element[\"style\"] = \"; \".join(styles)\n \n@@ -48,6 +84,15 @@ def _convert_font_tag(soup):\n def _convert_a_tag(soup: bs4.BeautifulSoup):\n     \"\"\"Convert links into HTML.\"\"\"\n     for element in soup.find_all(\"a\"):\n+        if not element.contents:\n+            # Element is empty, just remove it from tree as it won't render visibly.\n+            element.decompose()\n+            continue\n+        # Verify if the href attr exists as it can be removed by Bleach for unsupported protocols.\n+        # Otherwise, we replace this element with its children.\n+        if not element.get(\"href\"):\n+            element.replace_with_children()\n+            continue\n         new_href = evexml.eve_link_to_url(element[\"href\"])\n         if new_href:\n             element[\"href\"] = new_href\ndiff --git a\/memberaudit\/tests\/core\/test_core_xml_converter.py b\/memberaudit\/tests\/core\/test_core_xml_converter.py\nindex a3e9a90..de7c38c 100644\n--- a\/memberaudit\/tests\/core\/test_core_xml_converter.py\n+++ b\/memberaudit\/tests\/core\/test_core_xml_converter.py\n@@ -1,6 +1,6 @@\n from app_utils.testing import NoSocketsTestCase\n \n-from ...core.xml_converter import eve_xml_to_html\n+from ...core.xml_converter import DEFAULT_FONT_SIZE, eve_xml_to_html\n from ..testdata.load_entities import load_entities\n from ..testdata.load_eveuniverse import load_eveuniverse\n from ..testdata.load_locations import load_locations\n@@ -91,10 +91,51 @@ def test_should_disable_unknown_links(self):\n         self.assertHTMLEqual(eve_xml_to_html(input), expected)\n \n     def test_should_set_default_font(self):\n-        input = 'First<br><span style=\"font-size: 20px\">Second<\/span>Third'\n+        input = 'First<br><font size=\"20\">Second<\/font>Third'\n         expected = (\n             '<span style=\"font-size: 13px\">First<\/span>'\n             '<br><span style=\"font-size: 20px\">Second<\/span>'\n             '<span style=\"font-size: 13px\">Third<\/span>'\n         )\n         self.assertHTMLEqual(eve_xml_to_html(input, add_default_style=True), expected)\n+\n+    def test_should_remove_comment(self):\n+        input = \"<u>First<!--<script>badcall();<\/script>--><\/u>\"\n+        expected = \"<u>First<\/u>\"\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_remove_normal_script(self):\n+        input = \"<b>This is a <script>bad_attempt()<\/script> at injection<\/b>\"\n+        expected = \"<b>This is a bad_attempt() at injection<\/b>\"\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    # \\ufe64 and \\ufe65 are two examples of characters that normalize under NFKC to < >\n+    def test_should_remove_confusable_script(self):\n+        input = \"<i>Yet another \\ufe64script\\ufe65attempted()\\ufe64\/script\\ufe65 injection<\/i>\"\n+        expected = \"<i>Yet another attempted() injection<\/i>\"\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_move_valid_children_out(self):\n+        input = \"<u>Test <div><i>it<\/i> <h1>out<\/h1><\/div> okay?<\/u>\"\n+        expected = \"<u>Test <i>it<\/i> out okay?<\/u>\"\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_use_default_font_size(self):\n+        input = '<font size=\"invalid\">Test<\/font>'\n+        expected = f'<span style=\"font-size: {DEFAULT_FONT_SIZE}px\">Test<\/span>'\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_use_absolute_font_size(self):\n+        input = '<font size=\"-13\">Test<\/font>'\n+        expected = '<span style=\"font-size: 13px\">Test<\/span>'\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_handle_valid_or_invalid_protocols(self):\n+        input = '<a href=\"unsupported:\/\/123456\">I should just be text<\/a><br><a href=\"https:\/\/example.org\/\">I should be a link<\/a>'\n+        expected = 'I should just be text<br><a href=\"https:\/\/example.org\/\" target=\"_blank\">I should be a link<\/a>'\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_remove_empty_elements(self):\n+        input = '<font size=\"13\"><font size=\"10\"><\/font><a href=\"https:\/\/iforgottext.com\/\"><\/a>some text<\/font>'\n+        expected = '<span style=\"font-size: 13px\">some text<\/span>'\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\ndiff --git a\/setup.py b\/setup.py\nindex 22db80b..56e9d24 100644\n--- a\/setup.py\n+++ b\/setup.py\n@@ -45,5 +45,6 @@\n         \"allianceauth-app-utils>=1.13\",\n         \"humanize\",\n         \"dj-datatables-view\",\n+        \"bleach\",\n     ],\n )\n","files":{"\/memberaudit\/core\/xml_converter.py":{"changes":[{"diff":"\n     - add_default_style: When set true will add the default style to all unstyled fragments\n     \"\"\"\n     xml_doc = unicodedata.normalize(\"NFKC\", xml_doc)\n-    xml_doc = evexml.remove_loc_tag(xml_doc)\n+    xml_doc = bleach.clean(\n+        xml_doc,\n+        protocols=EVEXML_ALLOWED_PROTOCOLS,\n+        tags=EVEXML_ALLOWED_TAGS,\n+        attributes=EVEXML_ALLOWED_ATTRIBUTES,\n+        strip=True,\n+    )\n     soup = bs4.BeautifulSoup(xml_doc, \"html.parser\")\n     _convert_font_tag(soup)\n     _convert_a_tag(soup)\n","add":7,"remove":1,"filename":"\/memberaudit\/core\/xml_converter.py","badparts":[" add_default_style: When set true will add the default style to all unstyled fragments","    xml_doc = evexml.remove_loc_tag(xml_doc)"],"goodparts":["    xml_doc = bleach.clean(","        xml_doc,","        protocols=EVEXML_ALLOWED_PROTOCOLS,","        tags=EVEXML_ALLOWED_TAGS,","        attributes=EVEXML_ALLOWED_ATTRIBUTES,","        strip=True,","    )"]},{"diff":"\n def _convert_font_tag(soup):\n     \"\"\"Convert the font tags into HTML style.\"\"\"\n     for element in soup.find_all(\"font\"):\n+        if not element.contents:\n+            # Element is empty, just remove it from tree as it won't render visibly.\n+            element.decompose()\n+            continue\n         element.name = \"span\"\n         styles = []\n         if \"size\" in element.attrs:\n-            styles.append(f\"font-size: {element['size']}px\")\n+            # Cast to int and use the absolute value, otherwise use default font size.\n+            # Prevents a limited CSS injection via this attribute.\n+            try:\n+                size = abs(int(element[\"size\"]))\n+            except ValueError:\n+                size = DEFAULT_FONT_SIZE\n+            styles.append(f\"font-size: {size}px\")\n             del element[\"size\"]\n-        if \"color\" in element.attrs:\n-            del element[\"color\"]\n         if styles:\n             element[\"style\"] = \"; \".join(styles)\n \n","add":11,"remove":3,"filename":"\/memberaudit\/core\/xml_converter.py","badparts":["            styles.append(f\"font-size: {element['size']}px\")","        if \"color\" in element.attrs:","            del element[\"color\"]"],"goodparts":["        if not element.contents:","            element.decompose()","            continue","            try:","                size = abs(int(element[\"size\"]))","            except ValueError:","                size = DEFAULT_FONT_SIZE","            styles.append(f\"font-size: {size}px\")"]}],"source":"\nimport unicodedata import bs4 from eveuniverse.core import evexml from allianceauth.services.hooks import get_extension_logger from app_utils.logging import LoggerAddTag from.. import __title__ logger=LoggerAddTag(get_extension_logger(__name__), __title__) DEFAULT_FONT_SIZE=13 def eve_xml_to_html(xml_doc: str, add_default_style: bool=False) -> str: \"\"\"Converts Eve Online XML to HTML. Args: -xml_doc: XML document -add_default_style: When set true will add the default style to all unstyled fragments \"\"\" xml_doc=unicodedata.normalize(\"NFKC\", xml_doc) xml_doc=evexml.remove_loc_tag(xml_doc) soup=bs4.BeautifulSoup(xml_doc, \"html.parser\") _convert_font_tag(soup) _convert_a_tag(soup) if add_default_style: _add_default_style(soup) return str(soup) def _convert_font_tag(soup): \"\"\"Convert the font tags into HTML style.\"\"\" for element in soup.find_all(\"font\"): element.name=\"span\" styles=[] if \"size\" in element.attrs: styles.append(f\"font-size:{element['size']}px\") del element[\"size\"] if \"color\" in element.attrs: del element[\"color\"] if styles: element[\"style\"]=\"; \".join(styles) def _convert_a_tag(soup: bs4.BeautifulSoup): \"\"\"Convert links into HTML.\"\"\" for element in soup.find_all(\"a\"): new_href=evexml.eve_link_to_url(element[\"href\"]) if new_href: element[\"href\"]=new_href element[\"target\"]=\"_blank\" else: element[\"href\"]=\" def _add_default_style(soup: bs4.BeautifulSoup): \"\"\"Add default style to all unstyled fragments.\"\"\" for el in soup.children: if isinstance(el, bs4.NavigableString): new_tag=soup.new_tag(\"span\") new_tag[\"style\"]=f\"font-size:{DEFAULT_FONT_SIZE}px\" el.wrap(new_tag) ","sourceWithComments":"import unicodedata\n\nimport bs4\n\nfrom eveuniverse.core import evexml\n\nfrom allianceauth.services.hooks import get_extension_logger\nfrom app_utils.logging import LoggerAddTag\n\nfrom .. import __title__\n\nlogger = LoggerAddTag(get_extension_logger(__name__), __title__)\n\nDEFAULT_FONT_SIZE = 13\n\n\ndef eve_xml_to_html(xml_doc: str, add_default_style: bool = False) -> str:\n    \"\"\"Converts Eve Online XML to HTML.\n\n    Args:\n    - xml_doc: XML document\n    - add_default_style: When set true will add the default style to all unstyled fragments\n    \"\"\"\n    xml_doc = unicodedata.normalize(\"NFKC\", xml_doc)\n    xml_doc = evexml.remove_loc_tag(xml_doc)\n    soup = bs4.BeautifulSoup(xml_doc, \"html.parser\")\n    _convert_font_tag(soup)\n    _convert_a_tag(soup)\n    if add_default_style:\n        _add_default_style(soup)\n    return str(soup)\n\n\ndef _convert_font_tag(soup):\n    \"\"\"Convert the font tags into HTML style.\"\"\"\n    for element in soup.find_all(\"font\"):\n        element.name = \"span\"\n        styles = []\n        if \"size\" in element.attrs:\n            styles.append(f\"font-size: {element['size']}px\")\n            del element[\"size\"]\n        if \"color\" in element.attrs:\n            del element[\"color\"]\n        if styles:\n            element[\"style\"] = \"; \".join(styles)\n\n\ndef _convert_a_tag(soup: bs4.BeautifulSoup):\n    \"\"\"Convert links into HTML.\"\"\"\n    for element in soup.find_all(\"a\"):\n        new_href = evexml.eve_link_to_url(element[\"href\"])\n        if new_href:\n            element[\"href\"] = new_href\n            element[\"target\"] = \"_blank\"\n        else:\n            element[\"href\"] = \"#\"\n\n\ndef _add_default_style(soup: bs4.BeautifulSoup):\n    \"\"\"Add default style to all unstyled fragments.\"\"\"\n    for el in soup.children:\n        if isinstance(el, bs4.NavigableString):\n            new_tag = soup.new_tag(\"span\")\n            new_tag[\"style\"] = f\"font-size: {DEFAULT_FONT_SIZE}px\"\n            el.wrap(new_tag)\n"},"\/memberaudit\/tests\/core\/test_core_xml_converter.py":{"changes":[{"diff":"\n from app_utils.testing import NoSocketsTestCase\n \n-from ...core.xml_converter import eve_xml_to_html\n+from ...core.xml_converter import DEFAULT_FONT_SIZE, eve_xml_to_html\n from ..testdata.load_entities import load_entities\n from ..testdata.load_eveuniverse import load_eveuniverse\n from ..testdata.load_locations import load_locations\n","add":1,"remove":1,"filename":"\/memberaudit\/tests\/core\/test_core_xml_converter.py","badparts":["from ...core.xml_converter import eve_xml_to_html"],"goodparts":["from ...core.xml_converter import DEFAULT_FONT_SIZE, eve_xml_to_html"]},{"diff":"\n         self.assertHTMLEqual(eve_xml_to_html(input), expected)\n \n     def test_should_set_default_font(self):\n-        input = 'First<br><span style=\"font-size: 20px\">Second<\/span>Third'\n+        input = 'First<br><font size=\"20\">Second<\/font>Third'\n         expected = (\n             '<span style=\"font-size: 13px\">First<\/span>'\n             '<br><span style=\"font-size: 20px\">Second<\/span>'\n             '<span style=\"font-size: 13px\">Third<\/span>'\n         )\n         self.assertHTMLEqual(eve_xml_to_html(input, add_default_style=True), expected)\n+\n+    def test_should_remove_comment(self):\n+        input = \"<u>First<!--<script>badcall();<\/script>--><\/u>\"\n+        expected = \"<u>First<\/u>\"\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_remove_normal_script(self):\n+        input = \"<b>This is a <script>bad_attempt()<\/script> at injection<\/b>\"\n+        expected = \"<b>This is a bad_attempt() at injection<\/b>\"\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    # \\ufe64 and \\ufe65 are two examples of characters that normalize under NFKC to < >\n+    def test_should_remove_confusable_script(self):\n+        input = \"<i>Yet another \\ufe64script\\ufe65attempted()\\ufe64\/script\\ufe65 injection<\/i>\"\n+        expected = \"<i>Yet another attempted() injection<\/i>\"\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_move_valid_children_out(self):\n+        input = \"<u>Test <div><i>it<\/i> <h1>out<\/h1><\/div> okay?<\/u>\"\n+        expected = \"<u>Test <i>it<\/i> out okay?<\/u>\"\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_use_default_font_size(self):\n+        input = '<font size=\"invalid\">Test<\/font>'\n+        expected = f'<span style=\"font-size: {DEFAULT_FONT_SIZE}px\">Test<\/span>'\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_use_absolute_font_size(self):\n+        input = '<font size=\"-13\">Test<\/font>'\n+        expected = '<span style=\"font-size: 13px\">Test<\/span>'\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_handle_valid_or_invalid_protocols(self):\n+        input = '<a href=\"unsupported:\/\/123456\">I should just be text<\/a><br><a href=\"https:\/\/example.org\/\">I should be a link<\/a>'\n+        expected = 'I should just be text<br><a href=\"https:\/\/example.org\/\" target=\"_blank\">I should be a link<\/a>'\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n+\n+    def test_should_remove_empty_elements(self):\n+        input = '<font size=\"13\"><font size=\"10\"><\/font><a href=\"https:\/\/iforgottext.com\/\"><\/a>some text<\/font>'\n+        expected = '<span style=\"font-size: 13px\">some text<\/span>'\n+        self.assertHTMLEqual(eve_xml_to_html(input), expected","add":42,"remove":1,"filename":"\/memberaudit\/tests\/core\/test_core_xml_converter.py","badparts":["        input = 'First<br><span style=\"font-size: 20px\">Second<\/span>Third'"],"goodparts":["        input = 'First<br><font size=\"20\">Second<\/font>Third'","    def test_should_remove_comment(self):","        input = \"<u>First<!--<script>badcall();<\/script>--><\/u>\"","        expected = \"<u>First<\/u>\"","        self.assertHTMLEqual(eve_xml_to_html(input), expected)","    def test_should_remove_normal_script(self):","        input = \"<b>This is a <script>bad_attempt()<\/script> at injection<\/b>\"","        expected = \"<b>This is a bad_attempt() at injection<\/b>\"","        self.assertHTMLEqual(eve_xml_to_html(input), expected)","    def test_should_remove_confusable_script(self):","        input = \"<i>Yet another \\ufe64script\\ufe65attempted()\\ufe64\/script\\ufe65 injection<\/i>\"","        expected = \"<i>Yet another attempted() injection<\/i>\"","        self.assertHTMLEqual(eve_xml_to_html(input), expected)","    def test_should_move_valid_children_out(self):","        input = \"<u>Test <div><i>it<\/i> <h1>out<\/h1><\/div> okay?<\/u>\"","        expected = \"<u>Test <i>it<\/i> out okay?<\/u>\"","        self.assertHTMLEqual(eve_xml_to_html(input), expected)","    def test_should_use_default_font_size(self):","        input = '<font size=\"invalid\">Test<\/font>'","        expected = f'<span style=\"font-size: {DEFAULT_FONT_SIZE}px\">Test<\/span>'","        self.assertHTMLEqual(eve_xml_to_html(input), expected)","    def test_should_use_absolute_font_size(self):","        input = '<font size=\"-13\">Test<\/font>'","        expected = '<span style=\"font-size: 13px\">Test<\/span>'","        self.assertHTMLEqual(eve_xml_to_html(input), expected)","    def test_should_handle_valid_or_invalid_protocols(self):","        input = '<a href=\"unsupported:\/\/123456\">I should just be text<\/a><br><a href=\"https:\/\/example.org\/\">I should be a link<\/a>'","        expected = 'I should just be text<br><a href=\"https:\/\/example.org\/\" target=\"_blank\">I should be a link<\/a>'","        self.assertHTMLEqual(eve_xml_to_html(input), expected)","    def test_should_remove_empty_elements(self):","        input = '<font size=\"13\"><font size=\"10\"><\/font><a href=\"https:\/\/iforgottext.com\/\"><\/a>some text<\/font>'","        expected = '<span style=\"font-size: 13px\">some text<\/span>'","        self.assertHTMLEqual(eve_xml_to_html(input), expected"]}],"source":"\nfrom app_utils.testing import NoSocketsTestCase from...core.xml_converter import eve_xml_to_html from..testdata.load_entities import load_entities from..testdata.load_eveuniverse import load_eveuniverse from..testdata.load_locations import load_locations MODULE_PATH=\"memberaudit.core.xml_converter\" class TestXMLConversion(NoSocketsTestCase): @classmethod def setUpClass(cls) -> None: super().setUpClass() load_eveuniverse() load_entities() load_locations() def test_should_convert_font_tag(self): input='<font size=\"13\" color=\" expected='<span style=\"font-size: 13px\">Character<\/span>' self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_should_remove_loc_tag(self): input=\"<loc>Character<\/loc>\" expected=\"Character\" self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_add_target_to_normal_links(self): input=( '<a href=\"http:\/\/www.google.com\" target=\"_blank\">https:\/\/www.google.com<\/a>' ) self.assertHTMLEqual(eve_xml_to_html(input), input) def test_should_convert_character_link(self): input='<a href=\"showinfo:1376\/\/1001\">Bruce Wayne<\/a>' expected='<a href=\"https:\/\/evewho.com\/character\/1001\" target=\"_blank\">Bruce Wayne<\/a>' self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_should_convert_corporation_link(self): input='<a href=\"showinfo:2\/\/2001\">Wayne Technologies<\/a>' expected=( '<a href=\"https:\/\/evemaps.dotlan.net\/corp\/Wayne_Technologies\" ' 'target=\"_blank\">Wayne Technologies<\/a>' ) self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_should_convert_alliance_link(self): input='<a href=\"showinfo:16159\/\/3001\">Wayne Enterprises<\/a>' expected=( '<a href=\"https:\/\/evemaps.dotlan.net\/alliance\/Wayne_Enterprises\" ' 'target=\"_blank\">Wayne Enterprises<\/a>' ) self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_should_convert_solar_system_link(self): input='<a href=\"showinfo:5\/\/30004984\">Abune<\/a>' expected='<a href=\"https:\/\/evemaps.dotlan.net\/system\/Abune\" target=\"_blank\">Abune<\/a>' self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_should_convert_station_link(self): input=( '<a href=\"showinfo:52678\/\/60003760\">' \"Jita IV -Moon 4 -Caldari Navy Assembly Plant<\/a>\" ) expected=( '<a href=\"https:\/\/evemaps.dotlan.net\/station\/Jita_IV_-_Moon_4_-_Caldari_Navy_Assembly_Plant\" ' 'target=\"_blank\">Jita IV -Moon 4 -Caldari Navy Assembly Plant<\/a>' ) self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_should_convert_kill_link(self): input=( '<a href=\"killReport:84900666:9e6fe9e5392ff0cfc6ab956677dbe1deb69c4b04\">' \"Kill: Yuna Kobayashi(Badger)<\/a>\" ) expected=( '<a href=\"https:\/\/zkillboard.com\/kill\/84900666\/\" ' 'target=\"_blank\">Kill: Yuna Kobayashi(Badger)<\/a>' ) self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_should_disable_unknown_links(self): input='<a href=\"unknown\">Abune<\/a>' expected='<a href=\" self.assertHTMLEqual(eve_xml_to_html(input), expected) def test_should_set_default_font(self): input='First<br><span style=\"font-size: 20px\">Second<\/span>Third' expected=( '<span style=\"font-size: 13px\">First<\/span>' '<br><span style=\"font-size: 20px\">Second<\/span>' '<span style=\"font-size: 13px\">Third<\/span>' ) self.assertHTMLEqual(eve_xml_to_html(input, add_default_style=True), expected) ","sourceWithComments":"from app_utils.testing import NoSocketsTestCase\n\nfrom ...core.xml_converter import eve_xml_to_html\nfrom ..testdata.load_entities import load_entities\nfrom ..testdata.load_eveuniverse import load_eveuniverse\nfrom ..testdata.load_locations import load_locations\n\nMODULE_PATH = \"memberaudit.core.xml_converter\"\n\n\nclass TestXMLConversion(NoSocketsTestCase):\n    @classmethod\n    def setUpClass(cls) -> None:\n        super().setUpClass()\n        load_eveuniverse()\n        load_entities()\n        load_locations()\n\n    def test_should_convert_font_tag(self):\n        input = '<font size=\"13\" color=\"#b3ffffff\">Character<\/font>'\n        expected = '<span style=\"font-size: 13px\">Character<\/span>'\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_should_remove_loc_tag(self):\n        input = \"<loc>Character<\/loc>\"\n        expected = \"Character\"\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_add_target_to_normal_links(self):\n        input = (\n            '<a href=\"http:\/\/www.google.com\" target=\"_blank\">https:\/\/www.google.com<\/a>'\n        )\n        self.assertHTMLEqual(eve_xml_to_html(input), input)\n\n    def test_should_convert_character_link(self):\n        input = '<a href=\"showinfo:1376\/\/1001\">Bruce Wayne<\/a>'\n        expected = '<a href=\"https:\/\/evewho.com\/character\/1001\" target=\"_blank\">Bruce Wayne<\/a>'\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_should_convert_corporation_link(self):\n        input = '<a href=\"showinfo:2\/\/2001\">Wayne Technologies<\/a>'\n        expected = (\n            '<a href=\"https:\/\/evemaps.dotlan.net\/corp\/Wayne_Technologies\" '\n            'target=\"_blank\">Wayne Technologies<\/a>'\n        )\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_should_convert_alliance_link(self):\n        input = '<a href=\"showinfo:16159\/\/3001\">Wayne Enterprises<\/a>'\n        expected = (\n            '<a href=\"https:\/\/evemaps.dotlan.net\/alliance\/Wayne_Enterprises\" '\n            'target=\"_blank\">Wayne Enterprises<\/a>'\n        )\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_should_convert_solar_system_link(self):\n        input = '<a href=\"showinfo:5\/\/30004984\">Abune<\/a>'\n        expected = '<a href=\"https:\/\/evemaps.dotlan.net\/system\/Abune\" target=\"_blank\">Abune<\/a>'\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_should_convert_station_link(self):\n        input = (\n            '<a href=\"showinfo:52678\/\/60003760\">'\n            \"Jita IV - Moon 4 - Caldari Navy Assembly Plant<\/a>\"\n        )\n        expected = (\n            '<a href=\"https:\/\/evemaps.dotlan.net\/station\/Jita_IV_-_Moon_4_-_Caldari_Navy_Assembly_Plant\" '\n            'target=\"_blank\">Jita IV - Moon 4 - Caldari Navy Assembly Plant<\/a>'\n        )\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_should_convert_kill_link(self):\n        input = (\n            '<a href=\"killReport:84900666:9e6fe9e5392ff0cfc6ab956677dbe1deb69c4b04\">'\n            \"Kill: Yuna Kobayashi (Badger)<\/a>\"\n        )\n        expected = (\n            '<a href=\"https:\/\/zkillboard.com\/kill\/84900666\/\" '\n            'target=\"_blank\">Kill: Yuna Kobayashi (Badger)<\/a>'\n        )\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    # def test_should_disable_unknown_types(self):\n    #     input = '<a href=\"showinfo:601\/\/30004984\">Abune<\/a>'\n    #     expected = '<a href=\"#\">Abune<\/a>'\n    #     self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_should_disable_unknown_links(self):\n        input = '<a href=\"unknown\">Abune<\/a>'\n        expected = '<a href=\"#\">Abune<\/a>'\n        self.assertHTMLEqual(eve_xml_to_html(input), expected)\n\n    def test_should_set_default_font(self):\n        input = 'First<br><span style=\"font-size: 20px\">Second<\/span>Third'\n        expected = (\n            '<span style=\"font-size: 13px\">First<\/span>'\n            '<br><span style=\"font-size: 20px\">Second<\/span>'\n            '<span style=\"font-size: 13px\">Third<\/span>'\n        )\n        self.assertHTMLEqual(eve_xml_to_html(input, add_default_style=True), expected)\n"}},"msg":"Changed eve_xml_to_html function in core.xml_converter to use Bleach to clean the XML\n\nAdded bleach as a required package in setup.py.\nAdded properties for allowed tags, attributes, and protocols.\nChanged eve_xml_to_html() to use Bleach and removed the no longer necessary call to evexml.remove_loc_tag().\nChanged _convert_font_tag() to remove empty elements and fixed a CSS injection.\nChanged _convert_a_tag() to remove empty elements and replace the element with its children on invalid href protocol.\nAdded tests to cover the changes and validate the vulnerability mitigation."}},"https:\/\/github.com\/ozgurlukicin\/ozgurlukicin":{"64de0713011209c6678cc238b0202ff36b8571e8":{"url":"https:\/\/api.github.com\/repos\/ozgurlukicin\/ozgurlukicin\/commits\/64de0713011209c6678cc238b0202ff36b8571e8","html_url":"https:\/\/github.com\/ozgurlukicin\/ozgurlukicin\/commit\/64de0713011209c6678cc238b0202ff36b8571e8","message":"request.POST -> form.cleaned_data\n\n<Eren> django's response objects filters the strings?\n<Eren> for xss and sql injection attacs?\n<Eren> i use request object directly in my code\n<Thialfihar> cgrace: don't even need eval.\n<Eren>  user = User.objects.create_user(request.POST['username'], request.POST['email'], request.POST['password'])\n<Thialfihar> You use form.is_valid() to check whether it's all good and after that use the dictionary \nform.clean_data\n<Thialfihar> user = User(form.clean_data['username'], form.clean_data['email'], form.clean_data['password'])\n<Thialfihar> The form object will give you the right data and you don't have to worry about the raw stuff in \nrequest.POST.","sha":"64de0713011209c6678cc238b0202ff36b8571e8","keyword":"eval injection check","diff":"diff --git a\/st\/views.py b\/st\/views.py\nindex bd4f15d3..5f737dea 100644\n--- a\/st\/views.py\n+++ b\/st\/views.py\n@@ -103,12 +103,13 @@ def user_register(request):\n     if request.method == 'POST':\n         form = RegisterForm(request.POST)\n         if form.is_valid():\n-            user = User.objects.create_user(request.POST['username'], request.POST['email'], request.POST['password'])\n-            user.first_name = request.POST['firstname']\n-            user.last_name = request.POST['lastname']\n+            user = User.objects.create_user(form.cleaned_data['username'], form.cleaned_data['email'], form.cleaned_data['password'])\n+            user.first_name = form.cleaned_data['firstname']\n+            user.last_name = form.cleaned_data['lastname']\n+            user.is_active = False\n             user.save()\n             profile = UserProfile(user=user)\n-            profile.homepage = request.POST['homepage']\n+            profile.homepage = form.cleaned_data['homepage']\n             profile.save()\n             return render_response(request, 'register_done.html', {'form': form})\n         else:\n","files":{"\/st\/views.py":{"changes":[{"diff":"\n     if request.method == 'POST':\n         form = RegisterForm(request.POST)\n         if form.is_valid():\n-            user = User.objects.create_user(request.POST['username'], request.POST['email'], request.POST['password'])\n-            user.first_name = request.POST['firstname']\n-            user.last_name = request.POST['lastname']\n+            user = User.objects.create_user(form.cleaned_data['username'], form.cleaned_data['email'], form.cleaned_data['password'])\n+            user.first_name = form.cleaned_data['firstname']\n+            user.last_name = form.cleaned_data['lastname']\n+            user.is_active = False\n             user.save()\n             profile = UserProfile(user=user)\n-            profile.homepage = request.POST['homepage']\n+            profile.homepage = form.cleaned_data['homepage']\n             profile.save()\n             return render_response(request, 'register_done.html', {'form': form})\n         else:\n","add":5,"remove":4,"filename":"\/st\/views.py","badparts":["            user = User.objects.create_user(request.POST['username'], request.POST['email'], request.POST['password'])","            user.first_name = request.POST['firstname']","            user.last_name = request.POST['lastname']","            profile.homepage = request.POST['homepage']"],"goodparts":["            user = User.objects.create_user(form.cleaned_data['username'], form.cleaned_data['email'], form.cleaned_data['password'])","            user.first_name = form.cleaned_data['firstname']","            user.last_name = form.cleaned_data['lastname']","            user.is_active = False","            profile.homepage = form.cleaned_data['homepage']"]}],"source":"\n from django.contrib.auth.decorators import login_required from django.contrib.auth.models import User from oi.st.models import FS, Game, News, Package, ScreenShot, Tag, UserProfile from oi.flatpages.models import FlatPage from oi.st.wrappers import render_response from oi.st.models import RegisterForm def home(request): news=News.objects.all().order_by('-date')[:4] return render_response(request, 'home.html', locals()) def fs_main(request): fs_all=FS.objects.all() return render_response(request, 'fs_main.html', locals()) def fs_detail(request, sef_title): fs=FS.objects.get(sef_title=sef_title) tags=fs.tags.all() return render_response(request, 'fs_detail.html', locals()) def fs_printable(request, sef_title): fs=FS.objects.get(sef_title=sef_title) return render_response(request, 'fs_printable.html', locals()) def game_main(request): game_all=Game.objects.all() return render_response(request, 'game_main.html', locals()) def game_detail(request, sef_title): game=Game.objects.get(sef_title=sef_title) tags=game.tags.all() return render_response(request, 'game_detail.html', locals()) def game_printable(request, sef_title): game=Game.objects.get(sef_title=sef_title) return render_response(request, 'game_printable.html', locals()) def news_main(request): news=News.objects.all().order_by('-date')[:4] return render_response(request, 'news_main.html', locals()) def news_detail(request, sef_title): news=News.objects.get(sef_title=sef_title) tags=news.tags.all() return render_response(request, 'news_detail.html', locals()) def news_printable(request, sef_title): news=News.objects.get(sef_title=sef_title) return render_response(request, 'news_printable.html', locals()) def pkg_main(request): packages=Package.objects.all() packages_by_rating=Package.objects.all().order_by('-point')[:10] for pkg in packages_by_rating: pkg.point=int(round((pkg.point+1)\/2)) return render_response(request, 'package_main.html', locals()) def pkg_detail(request, name): package=Package.objects.get(name=name) tags=package.tags.all() licenses=package.license.all() sss=package.ss.all() return render_response(request, 'package_detail.html', locals()) def pkg_printable(request, name): package=Package.objects.get(name=name) return render_response(request, 'package_printable.html', locals()) def tag_main(request): tags=Tag.objects.all() return render_response(request, 'tag_main.html', locals()) def tag_detail(request, tag): news=News.objects.filter(tags__name__contains=tag) packages=Package.objects.filter(tags__name__contains=tag) games=Game.objects.filter(tags__name__contains=tag) fs=FS.objects.filter(tags__name__contains=tag) flatpages=FlatPage.objects.filter(tags__name__contains=tag) return render_response(request, 'tag_detail.html', locals()) @login_required def user_dashboard(request): return render_response(request, 'dashboard.html', locals()) def user_profile(request, name): infoname=name try: info=User.objects.get(username=name) except: info=None return render_response(request, 'profile.html', locals()) def user_register(request): if request.method=='POST': form=RegisterForm(request.POST) if form.is_valid(): user=User.objects.create_user(request.POST['username'], request.POST['email'], request.POST['password']) user.first_name=request.POST['firstname'] user.last_name=request.POST['lastname'] user.save() profile=UserProfile(user=user) profile.homepage=request.POST['homepage'] profile.save() return render_response(request, 'register_done.html',{'form': form}) else: return render_response(request, 'register.html',{'form': form}) else: form=RegisterForm() return render_response(request, 'register.html',{'form': form}) ","sourceWithComments":"#!\/usr\/bin\/python\n# -*- coding: utf-8 -*-\n#\n# Copyright 2007 TUBITAK\/UEKAE\n# Licensed under the GNU General Public License, version 2.\n# See the file http:\/\/www.gnu.org\/copyleft\/gpl.txt.\n\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.models import User\n\nfrom oi.st.models import FS, Game, News, Package, ScreenShot, Tag, UserProfile\nfrom oi.flatpages.models import FlatPage\nfrom oi.st.wrappers import render_response\nfrom oi.st.models import RegisterForm\n\ndef home(request):\n    news = News.objects.all().order_by('-date')[:4]\n    return render_response(request, 'home.html', locals())\n\ndef fs_main(request):\n    fs_all = FS.objects.all()\n    return render_response(request, 'fs_main.html', locals())\n\ndef fs_detail(request, sef_title):\n    fs = FS.objects.get(sef_title=sef_title)\n    tags = fs.tags.all()\n    return render_response(request, 'fs_detail.html', locals())\n\ndef fs_printable(request, sef_title):\n    fs = FS.objects.get(sef_title=sef_title)\n    return render_response(request, 'fs_printable.html', locals())\n\ndef game_main(request):\n    game_all = Game.objects.all()\n    return render_response(request, 'game_main.html', locals())\n\ndef game_detail(request, sef_title):\n    game = Game.objects.get(sef_title=sef_title)\n    tags = game.tags.all()\n    return render_response(request, 'game_detail.html', locals())\n\ndef game_printable(request, sef_title):\n    game = Game.objects.get(sef_title=sef_title)\n    return render_response(request, 'game_printable.html', locals())\n\ndef news_main(request):\n    news = News.objects.all().order_by('-date')[:4]\n    return render_response(request, 'news_main.html', locals())\n\ndef news_detail(request, sef_title):\n    news = News.objects.get(sef_title=sef_title)\n    tags = news.tags.all()\n    return render_response(request, 'news_detail.html', locals())\n\ndef news_printable(request, sef_title):\n    news = News.objects.get(sef_title=sef_title)\n    return render_response(request, 'news_printable.html', locals())\n\ndef pkg_main(request):\n    packages = Package.objects.all()\n    packages_by_rating = Package.objects.all().order_by('-point')[:10]\n    for pkg in packages_by_rating:\n        pkg.point = int(round((pkg.point+1)\/2))\n    return render_response(request, 'package_main.html', locals())\n\ndef pkg_detail(request, name):\n    package = Package.objects.get(name=name)\n    tags = package.tags.all()\n    licenses = package.license.all()\n    sss = package.ss.all()\n    return render_response(request, 'package_detail.html', locals())\n\ndef pkg_printable(request, name):\n    package = Package.objects.get(name=name)\n    return render_response(request, 'package_printable.html', locals())\n\ndef tag_main(request):\n    tags = Tag.objects.all()\n    return render_response(request, 'tag_main.html', locals())\n\ndef tag_detail(request, tag):\n    news = News.objects.filter(tags__name__contains=tag)\n    packages = Package.objects.filter(tags__name__contains=tag)\n    games = Game.objects.filter(tags__name__contains=tag)\n    fs = FS.objects.filter(tags__name__contains=tag)\n    flatpages = FlatPage.objects.filter(tags__name__contains=tag)\n    return render_response(request, 'tag_detail.html', locals())\n\n@login_required\ndef user_dashboard(request):\n    return render_response(request, 'dashboard.html', locals())\n\ndef user_profile(request, name):\n    infoname = name\n    try:\n        info = User.objects.get(username=name)\n    except:\n        info = None\n\n    return render_response(request, 'profile.html', locals())\n\ndef user_register(request):\n    if request.method == 'POST':\n        form = RegisterForm(request.POST)\n        if form.is_valid():\n            user = User.objects.create_user(request.POST['username'], request.POST['email'], request.POST['password'])\n            user.first_name = request.POST['firstname']\n            user.last_name = request.POST['lastname']\n            user.save()\n            profile = UserProfile(user=user)\n            profile.homepage = request.POST['homepage']\n            profile.save()\n            return render_response(request, 'register_done.html', {'form': form})\n        else:\n            return render_response(request, 'register.html', {'form': form})\n    else:\n        form = RegisterForm()\n        return render_response(request, 'register.html', {'form': form})\n"}},"msg":"request.POST -> form.cleaned_data\n\n<Eren> django's response objects filters the strings?\n<Eren> for xss and sql injection attacs?\n<Eren> i use request object directly in my code\n<Thialfihar> cgrace: don't even need eval.\n<Eren>  user = User.objects.create_user(request.POST['username'], request.POST['email'], request.POST['password'])\n<Thialfihar> You use form.is_valid() to check whether it's all good and after that use the dictionary \nform.clean_data\n<Thialfihar> user = User(form.clean_data['username'], form.clean_data['email'], form.clean_data['password'])\n<Thialfihar> The form object will give you the right data and you don't have to worry about the raw stuff in \nrequest.POST."}}}