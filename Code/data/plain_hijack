{"https:\/\/github.com\/OpenTreeOfLife\/opentree":{"ef45f9100c5339c47c278f23ef7485c9c8e81d2f":{"url":"https:\/\/api.github.com\/repos\/OpenTreeOfLife\/opentree\/commits\/ef45f9100c5339c47c278f23ef7485c9c8e81d2f","html_url":"https:\/\/github.com\/OpenTreeOfLife\/opentree\/commit\/ef45f9100c5339c47c278f23ef7485c9c8e81d2f","sha":"ef45f9100c5339c47c278f23ef7485c9c8e81d2f","keyword":"session hijacking insecure","diff":"diff --git a\/curator\/models\/db.py b\/curator\/models\/db.py\nindex b6657e608..0da6323be 100644\n--- a\/curator\/models\/db.py\n+++ b\/curator\/models\/db.py\n@@ -25,9 +25,11 @@\n ## File is released under public domain and you can use without limitations\n #########################################################################\n \n-## if SSL\/HTTPS is properly configured and you want all HTTP requests to\n-## be redirected to HTTPS, uncomment the line below:\n-# request.requires_https()\n+# If SSL\/HTTPS is properly configured and you want all HTTP requests to\n+# be redirected to HTTPS, uncomment the line below:\n+## request.requires_https()\n+# NO, this is too all-inclusive and complicates our registered apps on GitHub.\n+# (Its OAuth should work with either secure or insecure\/test setups.)\n \n if not request.env.web2py_runtime_gae:\n     ## if NOT running on Google App Engine use SQLite or other DB\n@@ -59,8 +61,12 @@\n ## (more options discussed in gluon\/tools.py)\n #########################################################################\n \n+SECURE_SESSIONS_WITH_HTTPS = conf.getboolean(\"security\", \"secure_sessions_with_HTTPS\")\n+# This is set to 'true' during deployment if our wildcard cert file is found. We\n+# assume this means all prerequisites for HTTPS\/SSL are complete.\n+\n from gluon.tools import Auth, Crud, Service, PluginManager, prettydate\n-auth = Auth(db)\n+auth = Auth(db, secure=SECURE_SESSIONS_WITH_HTTPS)\n crud, service, plugins = Crud(db), Service(), PluginManager()\n \n \ndiff --git a\/curator\/private\/config.example b\/curator\/private\/config.example\nindex 8997b2016..17167462a 100644\n--- a\/curator\/private\/config.example\n+++ b\/curator\/private\/config.example\n@@ -5,6 +5,9 @@\n # build the final config for each web2py app. Changes here might keep it\n # from being built properly.\n \n+[security]\n+secure_sessions_with_HTTPS = false\n+\n [maintenance]\n # During system migration and other scheduled maintenance, we should allow\n # viewing of existing studies but block study creation and editing.\ndiff --git a\/deploy\/setup\/install-web2py-apps.sh b\/deploy\/setup\/install-web2py-apps.sh\nindex 57b96b7ca..12d7f1b5a 100755\n--- a\/deploy\/setup\/install-web2py-apps.sh\n+++ b\/deploy\/setup\/install-web2py-apps.sh\n@@ -78,6 +78,14 @@ configdir=repo\/opentree\/webapp\/private\n configtemplate=$configdir\/config.example\n configfile=$configdir\/config\n \n+# Use the existence of a wildcard cert to trigger the use of HTTPS from within web2py.\n+if [ -r \/etc\/ssl\/certs\/opentree\/STAR_opentreeoflife_org.crt ]; then\n+   SSL_CERTS_FOUND=true\n+else\n+   SSL_CERTS_FOUND=false\n+fi\n+echo \"Triggering use of HTTPS from within web2py? [$SSL_CERTS_FOUND]\"\n+\n # Replace tokens in example config file to make the active config (assume this always changes)\n cp -p $configtemplate $configfile\n sed \"s+github_client_id = .*+github_client_id = $TREEVIEW_GITHUB_CLIENT_ID+;\n@@ -87,6 +95,7 @@ sed \"s+github_client_id = .*+github_client_id = $TREEVIEW_GITHUB_CLIENT_ID+;\n      s+taxomachine = .*+taxomachine = $TAXOMACHINE_BASE_URL+\n      s+oti = .*+oti = $OTI_BASE_URL+\n      s+opentree_api = .*+opentree_api = $OPENTREE_API_BASE_URL+\n+     s+secure_sessions_with_HTTPS = .*+secure_sessions_with_HTTPS = $SSL_CERTS_FOUND+\n     \" < $configfile > tmp.tmp\n mv tmp.tmp $configfile\n \n@@ -103,6 +112,7 @@ sed \"s+github_client_id = .*+github_client_id = $CURATION_GITHUB_CLIENT_ID+;\n      s+taxomachine = .*+taxomachine = $TAXOMACHINE_BASE_URL+\n      s+oti = .*+oti = $OTI_BASE_URL+\n      s+opentree_api = .*+opentree_api = $OPENTREE_API_BASE_URL+\n+     s+secure_sessions_with_HTTPS = .*+secure_sessions_with_HTTPS = $SSL_CERTS_FOUND+\n     \" < $configfile > tmp.tmp\n mv tmp.tmp $configfile\n \ndiff --git a\/webapp\/models\/db.py b\/webapp\/models\/db.py\nindex efcd37414..ce2ffd2e6 100644\n--- a\/webapp\/models\/db.py\n+++ b\/webapp\/models\/db.py\n@@ -23,9 +23,11 @@\n ## File is released under public domain and you can use without limitations\n #########################################################################\n \n-## if SSL\/HTTPS is properly configured and you want all HTTP requests to\n-## be redirected to HTTPS, uncomment the line below:\n-# request.requires_https()\n+# If SSL\/HTTPS is properly configured and you want all HTTP requests to\n+# be redirected to HTTPS, uncomment the line below:\n+## request.requires_https()\n+# NO, this is too all-inclusive and complicates our registered apps on GitHub.\n+# (Its OAuth should work with either secure or insecure\/test setups.)\n \n if not request.env.web2py_runtime_gae:\n     ## if NOT running on Google App Engine use SQLite or other DB\n@@ -57,8 +59,12 @@\n ## (more options discussed in gluon\/tools.py)\n #########################################################################\n \n+SECURE_SESSIONS_WITH_HTTPS = conf.getboolean(\"security\", \"secure_sessions_with_HTTPS\")\n+# This is set to 'true' during deployment if our wildcard cert file is found. We\n+# assume this means all prerequisites for HTTPS\/SSL are complete.\n+\n from gluon.tools import Auth, Crud, Service, PluginManager, prettydate\n-auth = Auth(db)\n+auth = Auth(db, secure=SECURE_SESSIONS_WITH_HTTPS)\n crud, service, plugins = Crud(db), Service(), PluginManager()\n \n ## configure email\ndiff --git a\/webapp\/private\/config.example b\/webapp\/private\/config.example\nindex 3f2c3a445..6a049976b 100644\n--- a\/webapp\/private\/config.example\n+++ b\/webapp\/private\/config.example\n@@ -4,6 +4,8 @@\n # this file! The 'config.example' files are used by our deployment scripts to\n # build the final config for each web2py app. Changes here might keep it\n # from being built properly.\n+[security]\n+secure_sessions_with_HTTPS = false\n \n # paths for the study\/status page (DEPRECATED)\n [paths]\n","message":"","files":{"\/curator\/models\/db.py":{"changes":[{"diff":" ## (more options discussed in gluon\/tools.py)\n #########################################################################\n \n+SECURE_SESSIONS_WITH_HTTPS = conf.getboolean(\"security\", \"secure_sessions_with_HTTPS\")\n+# This is set to 'true' during deployment if our wildcard cert file is found. We\n+# assume this means all prerequisites for HTTPS\/SSL are complete.\n+\n from gluon.tools import Auth, Crud, Service, PluginManager, prettydate\n-auth = Auth(db)\n+auth = Auth(db, secure=SECURE_SESSIONS_WITH_HTTPS)\n crud, service, plugins = Crud(db), Service(), PluginManager()\n \n ","add":5,"remove":1,"filename":"\/curator\/models\/db.py","badparts":["auth = Auth(db)"],"goodparts":["SECURE_SESSIONS_WITH_HTTPS = conf.getboolean(\"security\", \"secure_sessions_with_HTTPS\")","auth = Auth(db, secure=SECURE_SESSIONS_WITH_HTTPS)"]}],"source":"\n\nfrom pprint import pprint import sys import os from ConfigParser import SafeConfigParser import urllib2 import json conf=SafeConfigParser({}) try: if os.path.isfile(\"applications\/%s\/private\/localconfig\" % request.application): conf.read(\"applications\/%s\/private\/localconfig\" % request.application) else: conf.read(\"applications\/%s\/private\/config\" % request.application) except: pass if os.path.isfile(\"applications\/%s\/private\/GITHUB_CLIENT_SECRET\" % request.application): GITHUB_CLIENT_SECRET=open(\"applications\/%s\/private\/GITHUB_CLIENT_SECRET\" % request.application).read().strip() conf.set(\"apis\", \"github_client_secret\", GITHUB_CLIENT_SECRET) if not request.env.web2py_runtime_gae: db=DAL('sqlite:\/\/storage.sqlite',pool_size=1,check_reserved=['all']) else: db=DAL('google:datastore') session.connect(request, response, db=db) response.generic_patterns=['*'] if request.is_local else[] from gluon.tools import Auth, Crud, Service, PluginManager, prettydate auth=Auth(db) crud, service, plugins=Crud(db), Service(), PluginManager() SupportingFiles=db.define_table('supporting_files', Field('doc', 'upload', autodelete=True), Field('file_size', 'float'), Field('study_id', 'string'),) auth_table=db.define_table( auth.settings.table_user_name, Field('name', length=256, default=\"\"), Field('email', length=128, default=\"\"), Field('github_login', length=128, default=\"\"), Field('github_url', length=256, default=\"\"), Field('avatar_url', length=256, default=\"\"), Field('github_auth_token', length=128, default=\"\", writable=False, readable=False), Field('first_name', length=128, default=\"\"), Field('last_name', length=128, default=\"\"), Field('username', length=128, default=\"\",), Field('password', 'password', length=256, readable=False, label='Password'), Field('registration_key', length=128, default=\"\", writable=False, readable=False), ) auth_table.github_login.requires=IS_NOT_IN_DB(db, auth_table.github_login) auth.define_tables() try: CLIENT_ID=conf.get(\"apis\", \"github_client_id\") CLIENT_SECRET=conf.get(\"apis\", \"github_client_secret\") REDIRECT_URI=conf.get(\"apis\", \"github_redirect_uri\") except: CLIENT_ID=\"CLIENT_ID_NOT_FOUND\" CLIENT_SECRET=\"CLIENT_SECRET_NOT_FOUND\" REDIRECT_URI=\"REDIRECT_URI_NOT_FOUND\" AUTH_URL=\"http:\/\/...\" TOKEN_URL=\"http:\/\/...\" from gluon import current from gluon.contrib.login_methods.oauth20_account import OAuthAccount class GitHubAccount(OAuthAccount): '''OAuth impl for GitHub''' AUTH_URL=\"https:\/\/github.com\/login\/oauth\/authorize\" TOKEN_URL=\"https:\/\/github.com\/login\/oauth\/access_token\" def __init__(self): OAuthAccount.__init__(self, g=globals(), client_id=CLIENT_ID, client_secret=CLIENT_SECRET, auth_url=self.AUTH_URL, token_url=self.TOKEN_URL, redirect_uri=REDIRECT_URI, state=os.urandom(16).encode('hex'), scope='public_repo') self.session=globals()['session'] def get_user(self): '''Returns the user using the GitHub User API.''' access_token=self.accessToken() if not access_token: return None user_request=urllib2.Request(\"https:\/\/api.github.com\/user\", headers={\"Authorization\":(\"token %s\" % access_token)}) data=urllib2.urlopen(user_request).read() user_json={} try: user_json=json.loads(data) except Exception, e: raise Exception(\"Cannot parse oauth server response %s %s\" %(data, e)) return None auth_user_fields=dict(name=user_json.get('name', user_json['login']), email=user_json.get('email', 'EMAIL_NOT_PROVIDED'), github_login=user_json['login'], registration_id=user_json['login'], github_url=user_json['html_url'], avatar_url=user_json['avatar_url'], github_auth_token=access_token, first_name=user_json['login'], last_name=(\"(%s)\" % user_json.get('name', user_json['login'])), username=user_json['login'], registration_key=user_json['login'], ) return dict(auth_user_fields) auth.settings.login_form=GitHubAccount() auth.settings.update_fields=['name', 'email', 'github_login', 'github_url', 'avatar_url', 'github_auth_token', 'first_name', 'last_name', 'username', 'registration_key'] auth.settings.actions_disabled=['register', 'change_password','request_reset_password','profile'] mail=auth.settings.mailer mail.settings.server='logging' or 'smtp.gmail.com:587' mail.settings.sender='you@gmail.com' mail.settings.login='username:password' auth.settings.registration_requires_verification=False auth.settings.registration_requires_approval=False auth.settings.reset_password_requires_verification=True ","sourceWithComments":"# -*- coding: utf-8 -*-\nfrom pprint import pprint\nimport sys\nimport os\nfrom ConfigParser import SafeConfigParser\nimport urllib2\nimport json\n\nconf = SafeConfigParser({})\ntry:\n    if os.path.isfile(\"applications\/%s\/private\/localconfig\" % request.application):\n        conf.read(\"applications\/%s\/private\/localconfig\" % request.application)\n    else:\n        conf.read(\"applications\/%s\/private\/config\" % request.application)\nexcept:\n    pass  #@TEMP probably should log this event...\n\n# add our GitHub client secret from a separate file (kept out of source repo)\nif os.path.isfile(\"applications\/%s\/private\/GITHUB_CLIENT_SECRET\" % request.application):\n    GITHUB_CLIENT_SECRET = open(\"applications\/%s\/private\/GITHUB_CLIENT_SECRET\" % request.application).read().strip()\n    conf.set(\"apis\", \"github_client_secret\", GITHUB_CLIENT_SECRET)\n\n#########################################################################\n## This scaffolding model makes your app work on Google App Engine too\n## File is released under public domain and you can use without limitations\n#########################################################################\n\n## if SSL\/HTTPS is properly configured and you want all HTTP requests to\n## be redirected to HTTPS, uncomment the line below:\n# request.requires_https()\n\nif not request.env.web2py_runtime_gae:\n    ## if NOT running on Google App Engine use SQLite or other DB\n    db = DAL('sqlite:\/\/storage.sqlite',pool_size=1,check_reserved=['all'])\nelse:\n    ## connect to Google BigTable (optional 'google:datastore:\/\/namespace')\n    db = DAL('google:datastore')\n    ## store sessions and tickets there\n    session.connect(request, response, db=db)\n    ## or store session in Memcache, Redis, etc.\n    ## from gluon.contrib.memdb import MEMDB\n    ## from google.appengine.api.memcache import Client\n    ## session.connect(request, response, db = MEMDB(Client()))\n\n## by default give a view\/generic.extension to all actions from localhost\n## none otherwise. a pattern can be 'controller\/function.extension'\nresponse.generic_patterns = ['*'] if request.is_local else []\n## (optional) optimize handling of static files\n# response.optimize_css = 'concat,minify,inline'\n# response.optimize_js = 'concat,minify,inline'\n\n#########################################################################\n## Here is sample code if you need for\n## - email capabilities\n## - authentication (registration, login, logout, ... )\n## - authorization (role based authorization)\n## - services (xml, csv, json, xmlrpc, jsonrpc, amf, rss)\n## - old style crud actions\n## (more options discussed in gluon\/tools.py)\n#########################################################################\n\nfrom gluon.tools import Auth, Crud, Service, PluginManager, prettydate\nauth = Auth(db)\ncrud, service, plugins = Crud(db), Service(), PluginManager()\n\n\n#\n# Simple storage for study supporting files. These are stored temporary,\n# pending deposition in Dryad or another permanent repository.\n#\n# I'm adapting a recipe for using web2py with the jQuery-File-Upload plugin:\n# http:\/\/in10min.blogspot.com\/2013\/04\/web2py-implement-multiple-files-upload.html\n#\n\nSupportingFiles = db.define_table('supporting_files',\n Field('doc', 'upload', autodelete=True),\n #Field('thumb', 'upload', autodelete=True),\n #Field('sizeFile', 'float'),\n #Field('sessionId', 'string'),)\n Field('file_size', 'float'),\n Field('study_id', 'string'),)\n\n#from smarthumb import SMARTHUMB\n#box = (200, 200)\n#SupportingFiles.thumb.compute = lambda row: SMARTHUMB(row.doc, box)\n\n\n#\n# OAuth2 for Github (API v3), based on the FB sample provided in gluon\/contrib\/login_methods\/oauth20_account.py\n# \n\n# You need to override the get_user method to match your auth provider needs.\n# define the auth_table before call to auth.define_tables()\nauth_table = db.define_table(\n   auth.settings.table_user_name,\n   Field('name', length=256, default=\"\"),          # \"Charles Darwin\"\n   Field('email', length=128, default=\"\"),         # \"chuck@beagle.net\"\n   Field('github_login', length=128, default=\"\"),  # \"chuckd\"  [Github calls this 'login']\n   Field('github_url', length=256, default=\"\"),    # \"https:\/\/github.com\/chuckd\"  [Github calls this 'html_url']\n   Field('avatar_url', length=256, default=\"\"),    # \"http:\/\/0.gravatar.com\/avatar\/805...9689b.png\"\n   #Field('password', 'password', length=256, readable=False, label='Password'),\n   Field('github_auth_token', length=128, default= \"\", writable=False, readable=False),\n\n   ## Some fields are expected by web2py, so repeat some values above..?\n   Field('first_name', length=128, default=\"\"),\n   Field('last_name', length=128, default=\"\"),\n   Field('username', length=128, default=\"\", ),  # unique=True not allowed in sqlite3\n   Field('password', 'password', length=256, readable=False, label='Password'),\n   Field('registration_key', length=128, default= \"\", writable=False, readable=False),\n   )\n   # is there another 'auth_token' field here already?\n\nauth_table.github_login.requires = IS_NOT_IN_DB(db, auth_table.github_login)\nauth.define_tables()\n# OR auth.define_tables(username=False, signature=False)\n# see https:\/\/code.google.com\/p\/web2py\/issues\/detail?id=1260\n\n# Looking for your app's client ID and secret in {app}\/private\/config\ntry:\n    CLIENT_ID = conf.get(\"apis\", \"github_client_id\")\n    CLIENT_SECRET = conf.get(\"apis\", \"github_client_secret\")\n    REDIRECT_URI = conf.get(\"apis\", \"github_redirect_uri\")\nexcept: \n    CLIENT_ID = \"CLIENT_ID_NOT_FOUND\"\n    CLIENT_SECRET = \"CLIENT_SECRET_NOT_FOUND\"\n    REDIRECT_URI = \"REDIRECT_URI_NOT_FOUND\"\n\nAUTH_URL=\"http:\/\/...\"\nTOKEN_URL=\"http:\/\/...\"\n\nfrom gluon import current\nfrom gluon.contrib.login_methods.oauth20_account import OAuthAccount\nclass GitHubAccount(OAuthAccount):\n    '''OAuth impl for GitHub'''\n    # http:\/\/developer.github.com\/v3\/oauth\/\n    AUTH_URL=\"https:\/\/github.com\/login\/oauth\/authorize\"\n    TOKEN_URL=\"https:\/\/github.com\/login\/oauth\/access_token\"\n\n    def __init__(self):\n        OAuthAccount.__init__(self, \n                              g=globals(),\n                              client_id=CLIENT_ID,\n                              client_secret=CLIENT_SECRET,\n                              auth_url=self.AUTH_URL,\n                              token_url=self.TOKEN_URL,\n                              redirect_uri=REDIRECT_URI,\n                              state=os.urandom(16).encode('hex'),\n                                  # random string to detect cross-site request forgery\n                              scope='public_repo')  # add ',repo' if including private repos\n\n        # adding session here, since older OAuthAccount doesn't seem to have it.. :-\/\n        self.session = globals()['session']\n\n    def get_user(self):\n        '''Returns the user using the GitHub User API.'''\n        ##sys.stderr.write('get_user STARTING...\\n')\n        access_token = self.accessToken()\n        if not access_token:\n            ##sys.stderr.write('get_user NO TOKEN FOUND\\n')\n            return None\n         \n        ##sys.stderr.write('get_user FOUND access_token:\\n')\n        ##pprint(access_token)\n\n        ##sys.stderr.write('> get_user, finishing with this CURRENT.session.token:\\n')\n        ##pprint(current.session.token)\n        ##sys.stderr.write('> get_user, trying SELF.session.token:\\n')\n        ##pprint(self.session.token)\n        ##sys.stderr.write('> what about just session.token?\\n')\n        ##pprint(session.token)\n\n        # fetch full user info from GitHub, to add\/update user data\n        user_request = urllib2.Request(\"https:\/\/api.github.com\/user\", headers={\"Authorization\" : (\"token %s\" % access_token)})\n        data = urllib2.urlopen(user_request).read()\n        user_json = {}\n        try:\n            user_json = json.loads(data)\n        except Exception, e:\n            raise Exception(\"Cannot parse oauth server response %s %s\" % (data, e))\n            return None\n\n        ##pprint('----------- user_json ----------')\n        ##pprint(user_json)\n        ##pprint('----------- auth_user_fields ----------')\n\n        # remap to our chosen auth_user fields\n        auth_user_fields = dict(name = user_json.get('name', user_json['login']),\n                                email = user_json.get('email', 'EMAIL_NOT_PROVIDED'),\n                                github_login = user_json['login'],\n                                registration_id = user_json['login'],\n                                #   required? see https:\/\/groups.google.com\/forum\/#!topic\/web2py\/yd4_yExPwXg\/discussion\n                                github_url = user_json['html_url'],\n                                avatar_url = user_json['avatar_url'],\n                                github_auth_token = access_token,\n                                #   adding more (apparently) standard web2py fields, to make this work..\n                                first_name = user_json['login'],\n                                last_name = (\"(%s)\" % user_json.get('name', user_json['login'])),\n                                username = user_json['login'],\n                                #password = 'TOP-SECRET',\n                                registration_key = user_json['login'],  \n                                )\n\n        ##pprint(auth_user_fields)\n        ##pprint('--------------------------------')\n\n        return dict(auth_user_fields)\n\n\n# use the class above to build a new login form\nauth.settings.login_form=GitHubAccount()\n\n# specify which auth_user fields can be modified on SECOND and subsequent logins\nauth.settings.update_fields = ['name', \n                               'email', \n                               'github_login', \n                               #'registration_id', \n                               'github_url', \n                               'avatar_url', \n                               'github_auth_token', \n                               'first_name', \n                               'last_name', \n                               'username', \n                               #'password', \n                               'registration_key']\n\n# there's no point in offer other user-management actions (we just shadow users in GitHub)\nauth.settings.actions_disabled=['register', 'change_password','request_reset_password','profile']\n\n## configure email\nmail = auth.settings.mailer\nmail.settings.server = 'logging' or 'smtp.gmail.com:587'\nmail.settings.sender = 'you@gmail.com'\nmail.settings.login = 'username:password'\n\n## configure auth policy\nauth.settings.registration_requires_verification = False\nauth.settings.registration_requires_approval = False\nauth.settings.reset_password_requires_verification = True\n\n#########################################################################\n## Define your tables below (or better in another model file) for example\n##\n## >>> db.define_table('mytable',Field('myfield','string'))\n##\n## Fields can be 'string','text','password','integer','double','boolean'\n##       'date','time','datetime','blob','upload', 'reference TABLENAME'\n## There is an implicit 'id integer autoincrement' field\n## Consult manual for more options, validators, etc.\n##\n## More API examples for controllers:\n##\n## >>> db.mytable.insert(myfield='value')\n## >>> rows=db(db.mytable.myfield=='value').select(db.mytable.ALL)\n## >>> for row in rows: print row.id, row.myfield\n#########################################################################\n\n## after defining tables, uncomment below to enable auditing\n# auth.enable_record_versioning(db)\n"}},"msg":"Require HTTPS (session protection) if supported.\n\nDeployment tools will enable (force) HTTS protection for session cookies\nif they detect the wildcard cert that enables HTTPS support in Apache.\nIn this case, all requests with an active session (even anonymous) will\ngo through HTTPS, with smart exceptions for OAuth redirect_uri in HTTP.\nThis lets us support insecure dev setups at the cost of possible\nsession hijacking (caveat user). Addresses #419 and #307."}},"https:\/\/github.com\/yjxtogo\/horizon":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/yjxtogo\/horizon\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/yjxtogo\/horizon\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/chenyingnan\/horizon":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/chenyingnan\/horizon\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/chenyingnan\/horizon\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/AMfalme\/Horizon_Openstack":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/AMfalme\/Horizon_Openstack\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/AMfalme\/Horizon_Openstack\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/openstack-archive\/deb-horizon":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/openstack-archive\/deb-horizon\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/openstack-archive\/deb-horizon\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/daespinel\/horizon":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/daespinel\/horizon\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/daespinel\/horizon\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/ONSdigital\/eq-survey-runner":{"01bb713a7c51a7d742c2dd24f3536a851cbdceb9":{"url":"https:\/\/api.github.com\/repos\/ONSdigital\/eq-survey-runner\/commits\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","html_url":"https:\/\/github.com\/ONSdigital\/eq-survey-runner\/commit\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","sha":"01bb713a7c51a7d742c2dd24f3536a851cbdceb9","keyword":"session fixation attack","diff":"diff --git a\/app\/authentication\/authenticator.py b\/app\/authentication\/authenticator.py\nindex 810ee7ba12..e9bdb98b24 100644\n--- a\/app\/authentication\/authenticator.py\n+++ b\/app\/authentication\/authenticator.py\n@@ -1,4 +1,5 @@\n import logging\n+from flask import session\n \n from app.authentication.invalid_token_exception import InvalidTokenException\n from app.authentication.jwt_decoder import JWTDecryptor\n@@ -36,6 +37,11 @@ def jwt_login(self, request):\n         :param request: The flask request\n         :return: the decrypted and unencoded token\n         \"\"\"\n+        # clear the session entry in the database\n+        session_manager.clear()\n+        # also clear the secure cookie data\n+        session.clear()\n+\n         if request.args.get(EQ_URL_QUERY_STRING_JWT_FIELD_NAME) is None:\n             raise NoTokenException(\"Please provide a token\")\n         token = self._jwt_decrypt(request)\ndiff --git a\/app\/authentication\/session_management.py b\/app\/authentication\/session_management.py\nindex 63c97a65b3..fad668ee0f 100644\n--- a\/app\/authentication\/session_management.py\n+++ b\/app\/authentication\/session_management.py\n@@ -25,7 +25,7 @@ def has_user_id(self):\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n@@ -59,14 +59,6 @@ def has_user_ik(self):\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n@@ -109,7 +101,7 @@ def has_user_id(self):\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n@@ -163,10 +155,9 @@ def has_user_id(self):\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\ndiff --git a\/tests\/app\/authentication\/test_session_management.py b\/tests\/app\/authentication\/test_session_management.py\nindex 9b586f8b07..84f3bed5f2 100644\n--- a\/tests\/app\/authentication\/test_session_management.py\n+++ b\/tests\/app\/authentication\/test_session_management.py\n@@ -27,7 +27,7 @@ def test_remove_token(self):\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","message":"","files":{"\/app\/authentication\/session_management.py":{"changes":[{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]},{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]}],"source":"\nfrom flask import session from app import settings from app.data_model.database import db_session, EQSession import logging from uuid import uuid4 USER_ID=\"user_id\" USER_IK=\"user_ik\" EQ_SESSION_ID=\"eq-session-id\" logger=logging.getLogger(__name__) class SessionManagement(object): def store_user_id(self, user_id): \"\"\" Store a user's id for retrieval later :param user_id: the user id \"\"\" pass def has_user_id(self): \"\"\" Checks if a user has a stored id :return: boolean value \"\"\" pass def remove_user_id(self): \"\"\" Removes a user id from the session \"\"\" pass def get_user_id(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" pass def store_user_ik(self, user_ik): ''' Store a user's ik in the cookie for retrieval later :param user_ik: the user ik ''' logger.debug(\"SessionManager store_user_ik() -session %s\", session) if USER_IK not in session: session[USER_IK]=user_ik session.permanent=True def has_user_ik(self): \"\"\" Checks if a user has a stored ik :return: boolean value \"\"\" logger.debug(\"SessionManager has_user_ik() -session %s\", session) if USER_IK in session: return session[USER_IK] is not None else: return False def remove_user_ik(self): \"\"\" Removes a user id from the session \"\"\" logger.debug(\"SessionManager remove_user_ik() -session %s\", session) if USER_IK in session: del session[USER_IK] def get_user_ik(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" logger.debug(\"SessionManager get_user_ik() -session %s\", session) if self.has_user_ik(): return session[USER_IK] else: return None class DatabaseSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"DatabaseSessionManager store_user_id() -session %s\", session) if EQ_SESSION_ID not in session: eq_session_id=self.create_session_id() logger.debug(\"Created new eq session id %s\", eq_session_id) session[EQ_SESSION_ID]=eq_session_id session.permanent=True eq_session=EQSession(eq_session_id, user_id) logger.debug(\"Constructed EQ Session object %s\", eq_session) else: eq_session_id=session[EQ_SESSION_ID] logger.debug(\"Found eq_session_id %s in session\", eq_session_id) eq_session=self._get_object(eq_session_id) logger.debug(\"Loaded object eq session %s\", eq_session) logger.debug(\"About to commit to database\") db_session.add(eq_session) db_session.commit() logger.debug(\"Committed\") def has_user_id(self): logger.debug(\"DatabaseSessionManager has_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] count=self.run_count(eq_session_id) logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count) return count > 0 def remove_user_id(self): logger.debug(\"DatabaseSessionManager remove_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) logger.debug(\"About to delete entry from eq_session table %s\", eq_session) db_session.delete(eq_session) db_session.commit() else: logger.warning(\"No eq session id exists\") def get_user_id(self): logger.debug(\"DatabaseSessionManager get_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) return eq_session.user_id else: return None def create_session_id(self): while True: new_session_id=str(uuid4()) if self.check_unique(new_session_id): break return new_session_id def check_unique(self, new_session_id): return self.run_count(new_session_id)==0 def _get_object(self, eq_session_id): logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id) return EQSession.query.filter(EQSession.eq_session_id==eq_session_id).first() def run_count(self, eq_session_id): logger.debug(\"Running count query for eq session id %s\", eq_session_id) count=EQSession.query.filter(EQSession.eq_session_id==eq_session_id).count() return count class FlaskSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"FlaskSessionManager store_user_id() -session %s\", session) if USER_ID not in session: session[USER_ID]=user_id session.permanent=True def has_user_id(self): logger.debug(\"FlaskSessionManager has_user_id() -session %s\", session) if USER_ID in session: return session[USER_ID] is not None else: return False def remove_user_id(self): logger.debug(\"FlaskSessionManager remove_user_id() -session %s\", session) if USER_ID in session: del session[USER_ID] def get_user_id(self): logger.debug(\"FlaskSessionManager get_user_id() -session %s\", session) if self.has_user_id(): return session[USER_ID] else: return None if settings.EQ_SERVER_SIDE_STORAGE: session_manager=DatabaseSessionManager() else: session_manager=FlaskSessionManager() ","sourceWithComments":"from flask import session\nfrom app import settings\nfrom app.data_model.database import db_session, EQSession\nimport logging\nfrom uuid import uuid4\n\nUSER_ID = \"user_id\"\nUSER_IK = \"user_ik\"\nEQ_SESSION_ID = \"eq-session-id\"\nlogger = logging.getLogger(__name__)\n\n\nclass SessionManagement(object):\n    def store_user_id(self, user_id):\n        \"\"\"\n        Store a user's id for retrieval later\n        :param user_id: the user id\n        \"\"\"\n        pass\n\n    def has_user_id(self):\n        \"\"\"\n        Checks if a user has a stored id\n        :return: boolean value\n        \"\"\"\n        pass\n\n    def remove_user_id(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        pass\n\n    def get_user_id(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        pass\n\n    def store_user_ik(self, user_ik):\n        '''\n        Store a user's ik in the cookie for retrieval later\n        :param user_ik: the user ik\n        '''\n        logger.debug(\"SessionManager store_user_ik() - session %s\", session)\n        if USER_IK not in session:\n            session[USER_IK] = user_ik\n            session.permanent = True\n\n    def has_user_ik(self):\n        \"\"\"\n        Checks if a user has a stored ik\n        :return: boolean value\n        \"\"\"\n        logger.debug(\"SessionManager has_user_ik() - session %s\", session)\n        if USER_IK in session:\n            return session[USER_IK] is not None\n        else:\n            return False\n\n    def remove_user_ik(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n        if USER_IK in session:\n            del session[USER_IK]\n\n    def get_user_ik(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        logger.debug(\"SessionManager get_user_ik() - session %s\", session)\n        if self.has_user_ik():\n            return session[USER_IK]\n        else:\n            return None\n\n\nclass DatabaseSessionManager(SessionManagement):\n\n    def store_user_id(self, user_id):\n        logger.debug(\"DatabaseSessionManager store_user_id() - session %s\", session)\n        if EQ_SESSION_ID not in session:\n            eq_session_id = self.create_session_id()\n            logger.debug(\"Created new eq session id %s\", eq_session_id)\n            session[EQ_SESSION_ID] = eq_session_id\n            session.permanent = True\n            eq_session = EQSession(eq_session_id, user_id)\n            logger.debug(\"Constructed EQ Session object %s\", eq_session)\n        else:\n            eq_session_id = session[EQ_SESSION_ID]\n            logger.debug(\"Found eq_session_id %s in session\", eq_session_id)\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"Loaded object eq session %s\", eq_session)\n        logger.debug(\"About to commit to database\")\n        db_session.add(eq_session)\n        db_session.commit()\n        logger.debug(\"Committed\")\n\n    def has_user_id(self):\n        logger.debug(\"DatabaseSessionManager has_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n\n            count = self.run_count(eq_session_id)\n            logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n            return count > 0\n\n    def remove_user_id(self):\n        logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"About to delete entry from eq_session table %s\", eq_session)\n            db_session.delete(eq_session)\n            db_session.commit()\n        else:\n            logger.warning(\"No eq session id exists\")\n\n    def get_user_id(self):\n        logger.debug(\"DatabaseSessionManager get_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            return eq_session.user_id\n        else:\n            return None\n\n    def create_session_id(self):\n        while True:\n            new_session_id = str(uuid4())\n            if self.check_unique(new_session_id):\n                break\n        return new_session_id\n\n    def check_unique(self, new_session_id):\n        return self.run_count(new_session_id) == 0\n\n    def _get_object(self, eq_session_id):\n        logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id)\n        return EQSession.query.filter(EQSession.eq_session_id == eq_session_id).first()\n\n    def run_count(self, eq_session_id):\n        logger.debug(\"Running count query for eq session id %s\", eq_session_id)\n        count = EQSession.query.filter(EQSession.eq_session_id == eq_session_id).count()\n        return count\n\n\nclass FlaskSessionManager(SessionManagement):\n    def store_user_id(self, user_id):\n        logger.debug(\"FlaskSessionManager store_user_id() - session %s\", session)\n        if USER_ID not in session:\n            session[USER_ID] = user_id\n            session.permanent = True\n\n    def has_user_id(self):\n        logger.debug(\"FlaskSessionManager has_user_id() - session %s\", session)\n        if USER_ID in session:\n            return session[USER_ID] is not None\n        else:\n            return False\n\n    def remove_user_id(self):\n        logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n        if USER_ID in session:\n            del session[USER_ID]\n\n    def get_user_id(self):\n        logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\n        if self.has_user_id():\n            return session[USER_ID]\n        else:\n            return None\n\nif settings.EQ_SERVER_SIDE_STORAGE:\n    session_manager = DatabaseSessionManager()\nelse:\n    session_manager = FlaskSessionManager()\n"},"\/tests\/app\/authentication\/test_session_management.py":{"changes":[{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]},{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]}],"source":"\nfrom app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager from flask import Flask import unittest from datetime import timedelta from app import settings class BaseSessionManagerTest(unittest.TestCase): def setUp(self): application=Flask(__name__) application.config['TESTING']=True application.secret_key='you will not guess' application.permanent_session_lifetime=timedelta(seconds=1) self.application=application self.session_manager=FlaskSessionManager() def test_has_token_empty(self): with self.application.test_request_context(): self.assertFalse(self.session_manager.has_user_id()) def test_has_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) def test_remove_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) self.session_manager.remove_user_id() self.assertFalse(self.session_manager.has_user_id()) class TestDatabaseSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL=\"sqlite:\/\/\" self.session_manager=DatabaseSessionManager() class TestFlaskSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() self.session_manager=FlaskSessionManager() if __name__=='__main__': unittest.main() ","sourceWithComments":"from app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager\nfrom flask import Flask\nimport unittest\nfrom datetime import timedelta\nfrom app import settings\n\n\nclass BaseSessionManagerTest(unittest.TestCase):\n    def setUp(self):\n        application = Flask(__name__)\n        application.config['TESTING'] = True\n        application.secret_key = 'you will not guess'\n        application.permanent_session_lifetime = timedelta(seconds=1)\n        self.application = application\n        self.session_manager = FlaskSessionManager()\n\n    def test_has_token_empty(self):\n        with self.application.test_request_context():\n            self.assertFalse(self.session_manager.has_user_id())\n\n    def test_has_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n\n    def test_remove_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n            self.session_manager.remove_user_id()\n            self.assertFalse(self.session_manager.has_user_id())\n\n\nclass TestDatabaseSessionManager(BaseSessionManagerTest):\n    def setUp(self):\n        super().setUp()\n        # Use an in memory database\n        settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL = \"sqlite:\/\/\"\n        self.session_manager = DatabaseSessionManager()\n\n\nclass TestFlaskSessionManager(BaseSessionManagerTest):\n\n    def setUp(self):\n        super().setUp()\n        self.session_manager = FlaskSessionManager()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}},"msg":"Protect against session fixation attacks"}},"https:\/\/github.com\/ONSdigital\/eq-questionnaire-runner":{"01bb713a7c51a7d742c2dd24f3536a851cbdceb9":{"url":"https:\/\/api.github.com\/repos\/ONSdigital\/eq-questionnaire-runner\/commits\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","html_url":"https:\/\/github.com\/ONSdigital\/eq-questionnaire-runner\/commit\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","sha":"01bb713a7c51a7d742c2dd24f3536a851cbdceb9","keyword":"session fixation attack","diff":"diff --git a\/app\/authentication\/authenticator.py b\/app\/authentication\/authenticator.py\nindex 810ee7ba12..e9bdb98b24 100644\n--- a\/app\/authentication\/authenticator.py\n+++ b\/app\/authentication\/authenticator.py\n@@ -1,4 +1,5 @@\n import logging\n+from flask import session\n \n from app.authentication.invalid_token_exception import InvalidTokenException\n from app.authentication.jwt_decoder import JWTDecryptor\n@@ -36,6 +37,11 @@ def jwt_login(self, request):\n         :param request: The flask request\n         :return: the decrypted and unencoded token\n         \"\"\"\n+        # clear the session entry in the database\n+        session_manager.clear()\n+        # also clear the secure cookie data\n+        session.clear()\n+\n         if request.args.get(EQ_URL_QUERY_STRING_JWT_FIELD_NAME) is None:\n             raise NoTokenException(\"Please provide a token\")\n         token = self._jwt_decrypt(request)\ndiff --git a\/app\/authentication\/session_management.py b\/app\/authentication\/session_management.py\nindex 63c97a65b3..fad668ee0f 100644\n--- a\/app\/authentication\/session_management.py\n+++ b\/app\/authentication\/session_management.py\n@@ -25,7 +25,7 @@ def has_user_id(self):\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n@@ -59,14 +59,6 @@ def has_user_ik(self):\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n@@ -109,7 +101,7 @@ def has_user_id(self):\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n@@ -163,10 +155,9 @@ def has_user_id(self):\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\ndiff --git a\/tests\/app\/authentication\/test_session_management.py b\/tests\/app\/authentication\/test_session_management.py\nindex 9b586f8b07..84f3bed5f2 100644\n--- a\/tests\/app\/authentication\/test_session_management.py\n+++ b\/tests\/app\/authentication\/test_session_management.py\n@@ -27,7 +27,7 @@ def test_remove_token(self):\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","message":"","files":{"\/app\/authentication\/session_management.py":{"changes":[{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]},{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]}],"source":"\nfrom flask import session from app import settings from app.data_model.database import db_session, EQSession import logging from uuid import uuid4 USER_ID=\"user_id\" USER_IK=\"user_ik\" EQ_SESSION_ID=\"eq-session-id\" logger=logging.getLogger(__name__) class SessionManagement(object): def store_user_id(self, user_id): \"\"\" Store a user's id for retrieval later :param user_id: the user id \"\"\" pass def has_user_id(self): \"\"\" Checks if a user has a stored id :return: boolean value \"\"\" pass def remove_user_id(self): \"\"\" Removes a user id from the session \"\"\" pass def get_user_id(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" pass def store_user_ik(self, user_ik): ''' Store a user's ik in the cookie for retrieval later :param user_ik: the user ik ''' logger.debug(\"SessionManager store_user_ik() -session %s\", session) if USER_IK not in session: session[USER_IK]=user_ik session.permanent=True def has_user_ik(self): \"\"\" Checks if a user has a stored ik :return: boolean value \"\"\" logger.debug(\"SessionManager has_user_ik() -session %s\", session) if USER_IK in session: return session[USER_IK] is not None else: return False def remove_user_ik(self): \"\"\" Removes a user id from the session \"\"\" logger.debug(\"SessionManager remove_user_ik() -session %s\", session) if USER_IK in session: del session[USER_IK] def get_user_ik(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" logger.debug(\"SessionManager get_user_ik() -session %s\", session) if self.has_user_ik(): return session[USER_IK] else: return None class DatabaseSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"DatabaseSessionManager store_user_id() -session %s\", session) if EQ_SESSION_ID not in session: eq_session_id=self.create_session_id() logger.debug(\"Created new eq session id %s\", eq_session_id) session[EQ_SESSION_ID]=eq_session_id session.permanent=True eq_session=EQSession(eq_session_id, user_id) logger.debug(\"Constructed EQ Session object %s\", eq_session) else: eq_session_id=session[EQ_SESSION_ID] logger.debug(\"Found eq_session_id %s in session\", eq_session_id) eq_session=self._get_object(eq_session_id) logger.debug(\"Loaded object eq session %s\", eq_session) logger.debug(\"About to commit to database\") db_session.add(eq_session) db_session.commit() logger.debug(\"Committed\") def has_user_id(self): logger.debug(\"DatabaseSessionManager has_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] count=self.run_count(eq_session_id) logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count) return count > 0 def remove_user_id(self): logger.debug(\"DatabaseSessionManager remove_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) logger.debug(\"About to delete entry from eq_session table %s\", eq_session) db_session.delete(eq_session) db_session.commit() else: logger.warning(\"No eq session id exists\") def get_user_id(self): logger.debug(\"DatabaseSessionManager get_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) return eq_session.user_id else: return None def create_session_id(self): while True: new_session_id=str(uuid4()) if self.check_unique(new_session_id): break return new_session_id def check_unique(self, new_session_id): return self.run_count(new_session_id)==0 def _get_object(self, eq_session_id): logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id) return EQSession.query.filter(EQSession.eq_session_id==eq_session_id).first() def run_count(self, eq_session_id): logger.debug(\"Running count query for eq session id %s\", eq_session_id) count=EQSession.query.filter(EQSession.eq_session_id==eq_session_id).count() return count class FlaskSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"FlaskSessionManager store_user_id() -session %s\", session) if USER_ID not in session: session[USER_ID]=user_id session.permanent=True def has_user_id(self): logger.debug(\"FlaskSessionManager has_user_id() -session %s\", session) if USER_ID in session: return session[USER_ID] is not None else: return False def remove_user_id(self): logger.debug(\"FlaskSessionManager remove_user_id() -session %s\", session) if USER_ID in session: del session[USER_ID] def get_user_id(self): logger.debug(\"FlaskSessionManager get_user_id() -session %s\", session) if self.has_user_id(): return session[USER_ID] else: return None if settings.EQ_SERVER_SIDE_STORAGE: session_manager=DatabaseSessionManager() else: session_manager=FlaskSessionManager() ","sourceWithComments":"from flask import session\nfrom app import settings\nfrom app.data_model.database import db_session, EQSession\nimport logging\nfrom uuid import uuid4\n\nUSER_ID = \"user_id\"\nUSER_IK = \"user_ik\"\nEQ_SESSION_ID = \"eq-session-id\"\nlogger = logging.getLogger(__name__)\n\n\nclass SessionManagement(object):\n    def store_user_id(self, user_id):\n        \"\"\"\n        Store a user's id for retrieval later\n        :param user_id: the user id\n        \"\"\"\n        pass\n\n    def has_user_id(self):\n        \"\"\"\n        Checks if a user has a stored id\n        :return: boolean value\n        \"\"\"\n        pass\n\n    def remove_user_id(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        pass\n\n    def get_user_id(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        pass\n\n    def store_user_ik(self, user_ik):\n        '''\n        Store a user's ik in the cookie for retrieval later\n        :param user_ik: the user ik\n        '''\n        logger.debug(\"SessionManager store_user_ik() - session %s\", session)\n        if USER_IK not in session:\n            session[USER_IK] = user_ik\n            session.permanent = True\n\n    def has_user_ik(self):\n        \"\"\"\n        Checks if a user has a stored ik\n        :return: boolean value\n        \"\"\"\n        logger.debug(\"SessionManager has_user_ik() - session %s\", session)\n        if USER_IK in session:\n            return session[USER_IK] is not None\n        else:\n            return False\n\n    def remove_user_ik(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n        if USER_IK in session:\n            del session[USER_IK]\n\n    def get_user_ik(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        logger.debug(\"SessionManager get_user_ik() - session %s\", session)\n        if self.has_user_ik():\n            return session[USER_IK]\n        else:\n            return None\n\n\nclass DatabaseSessionManager(SessionManagement):\n\n    def store_user_id(self, user_id):\n        logger.debug(\"DatabaseSessionManager store_user_id() - session %s\", session)\n        if EQ_SESSION_ID not in session:\n            eq_session_id = self.create_session_id()\n            logger.debug(\"Created new eq session id %s\", eq_session_id)\n            session[EQ_SESSION_ID] = eq_session_id\n            session.permanent = True\n            eq_session = EQSession(eq_session_id, user_id)\n            logger.debug(\"Constructed EQ Session object %s\", eq_session)\n        else:\n            eq_session_id = session[EQ_SESSION_ID]\n            logger.debug(\"Found eq_session_id %s in session\", eq_session_id)\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"Loaded object eq session %s\", eq_session)\n        logger.debug(\"About to commit to database\")\n        db_session.add(eq_session)\n        db_session.commit()\n        logger.debug(\"Committed\")\n\n    def has_user_id(self):\n        logger.debug(\"DatabaseSessionManager has_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n\n            count = self.run_count(eq_session_id)\n            logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n            return count > 0\n\n    def remove_user_id(self):\n        logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"About to delete entry from eq_session table %s\", eq_session)\n            db_session.delete(eq_session)\n            db_session.commit()\n        else:\n            logger.warning(\"No eq session id exists\")\n\n    def get_user_id(self):\n        logger.debug(\"DatabaseSessionManager get_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            return eq_session.user_id\n        else:\n            return None\n\n    def create_session_id(self):\n        while True:\n            new_session_id = str(uuid4())\n            if self.check_unique(new_session_id):\n                break\n        return new_session_id\n\n    def check_unique(self, new_session_id):\n        return self.run_count(new_session_id) == 0\n\n    def _get_object(self, eq_session_id):\n        logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id)\n        return EQSession.query.filter(EQSession.eq_session_id == eq_session_id).first()\n\n    def run_count(self, eq_session_id):\n        logger.debug(\"Running count query for eq session id %s\", eq_session_id)\n        count = EQSession.query.filter(EQSession.eq_session_id == eq_session_id).count()\n        return count\n\n\nclass FlaskSessionManager(SessionManagement):\n    def store_user_id(self, user_id):\n        logger.debug(\"FlaskSessionManager store_user_id() - session %s\", session)\n        if USER_ID not in session:\n            session[USER_ID] = user_id\n            session.permanent = True\n\n    def has_user_id(self):\n        logger.debug(\"FlaskSessionManager has_user_id() - session %s\", session)\n        if USER_ID in session:\n            return session[USER_ID] is not None\n        else:\n            return False\n\n    def remove_user_id(self):\n        logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n        if USER_ID in session:\n            del session[USER_ID]\n\n    def get_user_id(self):\n        logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\n        if self.has_user_id():\n            return session[USER_ID]\n        else:\n            return None\n\nif settings.EQ_SERVER_SIDE_STORAGE:\n    session_manager = DatabaseSessionManager()\nelse:\n    session_manager = FlaskSessionManager()\n"},"\/tests\/app\/authentication\/test_session_management.py":{"changes":[{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]},{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]}],"source":"\nfrom app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager from flask import Flask import unittest from datetime import timedelta from app import settings class BaseSessionManagerTest(unittest.TestCase): def setUp(self): application=Flask(__name__) application.config['TESTING']=True application.secret_key='you will not guess' application.permanent_session_lifetime=timedelta(seconds=1) self.application=application self.session_manager=FlaskSessionManager() def test_has_token_empty(self): with self.application.test_request_context(): self.assertFalse(self.session_manager.has_user_id()) def test_has_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) def test_remove_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) self.session_manager.remove_user_id() self.assertFalse(self.session_manager.has_user_id()) class TestDatabaseSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL=\"sqlite:\/\/\" self.session_manager=DatabaseSessionManager() class TestFlaskSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() self.session_manager=FlaskSessionManager() if __name__=='__main__': unittest.main() ","sourceWithComments":"from app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager\nfrom flask import Flask\nimport unittest\nfrom datetime import timedelta\nfrom app import settings\n\n\nclass BaseSessionManagerTest(unittest.TestCase):\n    def setUp(self):\n        application = Flask(__name__)\n        application.config['TESTING'] = True\n        application.secret_key = 'you will not guess'\n        application.permanent_session_lifetime = timedelta(seconds=1)\n        self.application = application\n        self.session_manager = FlaskSessionManager()\n\n    def test_has_token_empty(self):\n        with self.application.test_request_context():\n            self.assertFalse(self.session_manager.has_user_id())\n\n    def test_has_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n\n    def test_remove_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n            self.session_manager.remove_user_id()\n            self.assertFalse(self.session_manager.has_user_id())\n\n\nclass TestDatabaseSessionManager(BaseSessionManagerTest):\n    def setUp(self):\n        super().setUp()\n        # Use an in memory database\n        settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL = \"sqlite:\/\/\"\n        self.session_manager = DatabaseSessionManager()\n\n\nclass TestFlaskSessionManager(BaseSessionManagerTest):\n\n    def setUp(self):\n        super().setUp()\n        self.session_manager = FlaskSessionManager()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}},"msg":"Protect against session fixation attacks"}},"https:\/\/github.com\/ONSdigital\/census-survey-runner":{"01bb713a7c51a7d742c2dd24f3536a851cbdceb9":{"url":"https:\/\/api.github.com\/repos\/ONSdigital\/census-survey-runner\/commits\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","html_url":"https:\/\/github.com\/ONSdigital\/census-survey-runner\/commit\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","sha":"01bb713a7c51a7d742c2dd24f3536a851cbdceb9","keyword":"session fixation attack","diff":"diff --git a\/app\/authentication\/authenticator.py b\/app\/authentication\/authenticator.py\nindex 810ee7ba..e9bdb98b 100644\n--- a\/app\/authentication\/authenticator.py\n+++ b\/app\/authentication\/authenticator.py\n@@ -1,4 +1,5 @@\n import logging\n+from flask import session\n \n from app.authentication.invalid_token_exception import InvalidTokenException\n from app.authentication.jwt_decoder import JWTDecryptor\n@@ -36,6 +37,11 @@ def jwt_login(self, request):\n         :param request: The flask request\n         :return: the decrypted and unencoded token\n         \"\"\"\n+        # clear the session entry in the database\n+        session_manager.clear()\n+        # also clear the secure cookie data\n+        session.clear()\n+\n         if request.args.get(EQ_URL_QUERY_STRING_JWT_FIELD_NAME) is None:\n             raise NoTokenException(\"Please provide a token\")\n         token = self._jwt_decrypt(request)\ndiff --git a\/app\/authentication\/session_management.py b\/app\/authentication\/session_management.py\nindex 63c97a65..fad668ee 100644\n--- a\/app\/authentication\/session_management.py\n+++ b\/app\/authentication\/session_management.py\n@@ -25,7 +25,7 @@ def has_user_id(self):\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n@@ -59,14 +59,6 @@ def has_user_ik(self):\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n@@ -109,7 +101,7 @@ def has_user_id(self):\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n@@ -163,10 +155,9 @@ def has_user_id(self):\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\ndiff --git a\/tests\/app\/authentication\/test_session_management.py b\/tests\/app\/authentication\/test_session_management.py\nindex 9b586f8b..84f3bed5 100644\n--- a\/tests\/app\/authentication\/test_session_management.py\n+++ b\/tests\/app\/authentication\/test_session_management.py\n@@ -27,7 +27,7 @@ def test_remove_token(self):\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","message":"","files":{"\/app\/authentication\/session_management.py":{"changes":[{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]},{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]}],"source":"\nfrom flask import session from app import settings from app.data_model.database import db_session, EQSession import logging from uuid import uuid4 USER_ID=\"user_id\" USER_IK=\"user_ik\" EQ_SESSION_ID=\"eq-session-id\" logger=logging.getLogger(__name__) class SessionManagement(object): def store_user_id(self, user_id): \"\"\" Store a user's id for retrieval later :param user_id: the user id \"\"\" pass def has_user_id(self): \"\"\" Checks if a user has a stored id :return: boolean value \"\"\" pass def remove_user_id(self): \"\"\" Removes a user id from the session \"\"\" pass def get_user_id(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" pass def store_user_ik(self, user_ik): ''' Store a user's ik in the cookie for retrieval later :param user_ik: the user ik ''' logger.debug(\"SessionManager store_user_ik() -session %s\", session) if USER_IK not in session: session[USER_IK]=user_ik session.permanent=True def has_user_ik(self): \"\"\" Checks if a user has a stored ik :return: boolean value \"\"\" logger.debug(\"SessionManager has_user_ik() -session %s\", session) if USER_IK in session: return session[USER_IK] is not None else: return False def remove_user_ik(self): \"\"\" Removes a user id from the session \"\"\" logger.debug(\"SessionManager remove_user_ik() -session %s\", session) if USER_IK in session: del session[USER_IK] def get_user_ik(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" logger.debug(\"SessionManager get_user_ik() -session %s\", session) if self.has_user_ik(): return session[USER_IK] else: return None class DatabaseSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"DatabaseSessionManager store_user_id() -session %s\", session) if EQ_SESSION_ID not in session: eq_session_id=self.create_session_id() logger.debug(\"Created new eq session id %s\", eq_session_id) session[EQ_SESSION_ID]=eq_session_id session.permanent=True eq_session=EQSession(eq_session_id, user_id) logger.debug(\"Constructed EQ Session object %s\", eq_session) else: eq_session_id=session[EQ_SESSION_ID] logger.debug(\"Found eq_session_id %s in session\", eq_session_id) eq_session=self._get_object(eq_session_id) logger.debug(\"Loaded object eq session %s\", eq_session) logger.debug(\"About to commit to database\") db_session.add(eq_session) db_session.commit() logger.debug(\"Committed\") def has_user_id(self): logger.debug(\"DatabaseSessionManager has_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] count=self.run_count(eq_session_id) logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count) return count > 0 def remove_user_id(self): logger.debug(\"DatabaseSessionManager remove_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) logger.debug(\"About to delete entry from eq_session table %s\", eq_session) db_session.delete(eq_session) db_session.commit() else: logger.warning(\"No eq session id exists\") def get_user_id(self): logger.debug(\"DatabaseSessionManager get_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) return eq_session.user_id else: return None def create_session_id(self): while True: new_session_id=str(uuid4()) if self.check_unique(new_session_id): break return new_session_id def check_unique(self, new_session_id): return self.run_count(new_session_id)==0 def _get_object(self, eq_session_id): logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id) return EQSession.query.filter(EQSession.eq_session_id==eq_session_id).first() def run_count(self, eq_session_id): logger.debug(\"Running count query for eq session id %s\", eq_session_id) count=EQSession.query.filter(EQSession.eq_session_id==eq_session_id).count() return count class FlaskSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"FlaskSessionManager store_user_id() -session %s\", session) if USER_ID not in session: session[USER_ID]=user_id session.permanent=True def has_user_id(self): logger.debug(\"FlaskSessionManager has_user_id() -session %s\", session) if USER_ID in session: return session[USER_ID] is not None else: return False def remove_user_id(self): logger.debug(\"FlaskSessionManager remove_user_id() -session %s\", session) if USER_ID in session: del session[USER_ID] def get_user_id(self): logger.debug(\"FlaskSessionManager get_user_id() -session %s\", session) if self.has_user_id(): return session[USER_ID] else: return None if settings.EQ_SERVER_SIDE_STORAGE: session_manager=DatabaseSessionManager() else: session_manager=FlaskSessionManager() ","sourceWithComments":"from flask import session\nfrom app import settings\nfrom app.data_model.database import db_session, EQSession\nimport logging\nfrom uuid import uuid4\n\nUSER_ID = \"user_id\"\nUSER_IK = \"user_ik\"\nEQ_SESSION_ID = \"eq-session-id\"\nlogger = logging.getLogger(__name__)\n\n\nclass SessionManagement(object):\n    def store_user_id(self, user_id):\n        \"\"\"\n        Store a user's id for retrieval later\n        :param user_id: the user id\n        \"\"\"\n        pass\n\n    def has_user_id(self):\n        \"\"\"\n        Checks if a user has a stored id\n        :return: boolean value\n        \"\"\"\n        pass\n\n    def remove_user_id(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        pass\n\n    def get_user_id(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        pass\n\n    def store_user_ik(self, user_ik):\n        '''\n        Store a user's ik in the cookie for retrieval later\n        :param user_ik: the user ik\n        '''\n        logger.debug(\"SessionManager store_user_ik() - session %s\", session)\n        if USER_IK not in session:\n            session[USER_IK] = user_ik\n            session.permanent = True\n\n    def has_user_ik(self):\n        \"\"\"\n        Checks if a user has a stored ik\n        :return: boolean value\n        \"\"\"\n        logger.debug(\"SessionManager has_user_ik() - session %s\", session)\n        if USER_IK in session:\n            return session[USER_IK] is not None\n        else:\n            return False\n\n    def remove_user_ik(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n        if USER_IK in session:\n            del session[USER_IK]\n\n    def get_user_ik(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        logger.debug(\"SessionManager get_user_ik() - session %s\", session)\n        if self.has_user_ik():\n            return session[USER_IK]\n        else:\n            return None\n\n\nclass DatabaseSessionManager(SessionManagement):\n\n    def store_user_id(self, user_id):\n        logger.debug(\"DatabaseSessionManager store_user_id() - session %s\", session)\n        if EQ_SESSION_ID not in session:\n            eq_session_id = self.create_session_id()\n            logger.debug(\"Created new eq session id %s\", eq_session_id)\n            session[EQ_SESSION_ID] = eq_session_id\n            session.permanent = True\n            eq_session = EQSession(eq_session_id, user_id)\n            logger.debug(\"Constructed EQ Session object %s\", eq_session)\n        else:\n            eq_session_id = session[EQ_SESSION_ID]\n            logger.debug(\"Found eq_session_id %s in session\", eq_session_id)\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"Loaded object eq session %s\", eq_session)\n        logger.debug(\"About to commit to database\")\n        db_session.add(eq_session)\n        db_session.commit()\n        logger.debug(\"Committed\")\n\n    def has_user_id(self):\n        logger.debug(\"DatabaseSessionManager has_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n\n            count = self.run_count(eq_session_id)\n            logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n            return count > 0\n\n    def remove_user_id(self):\n        logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"About to delete entry from eq_session table %s\", eq_session)\n            db_session.delete(eq_session)\n            db_session.commit()\n        else:\n            logger.warning(\"No eq session id exists\")\n\n    def get_user_id(self):\n        logger.debug(\"DatabaseSessionManager get_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            return eq_session.user_id\n        else:\n            return None\n\n    def create_session_id(self):\n        while True:\n            new_session_id = str(uuid4())\n            if self.check_unique(new_session_id):\n                break\n        return new_session_id\n\n    def check_unique(self, new_session_id):\n        return self.run_count(new_session_id) == 0\n\n    def _get_object(self, eq_session_id):\n        logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id)\n        return EQSession.query.filter(EQSession.eq_session_id == eq_session_id).first()\n\n    def run_count(self, eq_session_id):\n        logger.debug(\"Running count query for eq session id %s\", eq_session_id)\n        count = EQSession.query.filter(EQSession.eq_session_id == eq_session_id).count()\n        return count\n\n\nclass FlaskSessionManager(SessionManagement):\n    def store_user_id(self, user_id):\n        logger.debug(\"FlaskSessionManager store_user_id() - session %s\", session)\n        if USER_ID not in session:\n            session[USER_ID] = user_id\n            session.permanent = True\n\n    def has_user_id(self):\n        logger.debug(\"FlaskSessionManager has_user_id() - session %s\", session)\n        if USER_ID in session:\n            return session[USER_ID] is not None\n        else:\n            return False\n\n    def remove_user_id(self):\n        logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n        if USER_ID in session:\n            del session[USER_ID]\n\n    def get_user_id(self):\n        logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\n        if self.has_user_id():\n            return session[USER_ID]\n        else:\n            return None\n\nif settings.EQ_SERVER_SIDE_STORAGE:\n    session_manager = DatabaseSessionManager()\nelse:\n    session_manager = FlaskSessionManager()\n"},"\/tests\/app\/authentication\/test_session_management.py":{"changes":[{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]},{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]}],"source":"\nfrom app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager from flask import Flask import unittest from datetime import timedelta from app import settings class BaseSessionManagerTest(unittest.TestCase): def setUp(self): application=Flask(__name__) application.config['TESTING']=True application.secret_key='you will not guess' application.permanent_session_lifetime=timedelta(seconds=1) self.application=application self.session_manager=FlaskSessionManager() def test_has_token_empty(self): with self.application.test_request_context(): self.assertFalse(self.session_manager.has_user_id()) def test_has_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) def test_remove_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) self.session_manager.remove_user_id() self.assertFalse(self.session_manager.has_user_id()) class TestDatabaseSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL=\"sqlite:\/\/\" self.session_manager=DatabaseSessionManager() class TestFlaskSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() self.session_manager=FlaskSessionManager() if __name__=='__main__': unittest.main() ","sourceWithComments":"from app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager\nfrom flask import Flask\nimport unittest\nfrom datetime import timedelta\nfrom app import settings\n\n\nclass BaseSessionManagerTest(unittest.TestCase):\n    def setUp(self):\n        application = Flask(__name__)\n        application.config['TESTING'] = True\n        application.secret_key = 'you will not guess'\n        application.permanent_session_lifetime = timedelta(seconds=1)\n        self.application = application\n        self.session_manager = FlaskSessionManager()\n\n    def test_has_token_empty(self):\n        with self.application.test_request_context():\n            self.assertFalse(self.session_manager.has_user_id())\n\n    def test_has_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n\n    def test_remove_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n            self.session_manager.remove_user_id()\n            self.assertFalse(self.session_manager.has_user_id())\n\n\nclass TestDatabaseSessionManager(BaseSessionManagerTest):\n    def setUp(self):\n        super().setUp()\n        # Use an in memory database\n        settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL = \"sqlite:\/\/\"\n        self.session_manager = DatabaseSessionManager()\n\n\nclass TestFlaskSessionManager(BaseSessionManagerTest):\n\n    def setUp(self):\n        super().setUp()\n        self.session_manager = FlaskSessionManager()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}},"msg":"Protect against session fixation attacks"}},"https:\/\/github.com\/joelbcastillo\/openrecords_v2_0":{"95cea5e2342f6807df783a8547e75a81bffe060d":{"url":"https:\/\/api.github.com\/repos\/joelbcastillo\/openrecords_v2_0\/commits\/95cea5e2342f6807df783a8547e75a81bffe060d","html_url":"https:\/\/github.com\/joelbcastillo\/openrecords_v2_0\/commit\/95cea5e2342f6807df783a8547e75a81bffe060d","message":"prevent session fixation attacks","sha":"95cea5e2342f6807df783a8547e75a81bffe060d","keyword":"session fixation prevent","diff":"diff --git a\/app\/auth\/views.py b\/app\/auth\/views.py\nindex ff4436a4..e68ad498 100644\n--- a\/app\/auth\/views.py\n+++ b\/app\/auth\/views.py\n@@ -73,6 +73,7 @@ def ldap_login():\n \n             if authenticated:\n                 login_user(user)\n+                session.regenerate()  # KVSession.regenerate()\n                 session['user_id'] = current_user.get_id()\n \n                 return_to_url = request.form.get('return_to_url')\ndiff --git a\/config.py b\/config.py\nindex 5660f7d2..6b1aee8e 100644\n--- a\/config.py\n+++ b\/config.py\n@@ -17,7 +17,7 @@ class Config:\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","files":{"\/config.py":{"changes":[{"diff":"\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","add":1,"remove":1,"filename":"\/config.py","badparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True"],"goodparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'"]},{"diff":"\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","add":1,"remove":1,"filename":"\/config.py","badparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True"],"goodparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'"]}],"source":"\nimport os from datetime import timedelta from dotenv import load_dotenv basedir=os.path.abspath(os.path.dirname(__file__)) dotenv_path=os.path.join(basedir, '.env') load_dotenv(dotenv_path) class Config: NYC_GOV_BASE='www1.nyc.gov' WTF_CSRF_ENABLED=True SECRET_KEY=os.environ.get('SECRET_KEY') or 'hard to guess string' LOGFILE_DIRECTORY=(os.environ.get('LOGFILE_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/')) APP_TIMEZONE=os.environ.get('APP_TIMEZONE') or 'US\/Eastern' SESSION_COOKIE_SECURE=os.environ.get('SESSION_COOKIE_SECURE') or True BASE_URL=os.environ.get('BASE_URL') VIEW_REQUEST_ENDPOINT=os.environ.get('VIEW_REQUEST_ENDPOINT') AGENCY_DATA=(os.environ.get('AGENCY_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'agencies.csv')) REASON_DATA=(os.environ.get('REASONS_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'reasons.csv')) STAFF_DATA=(os.environ.get('STAFF_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'staff.csv')) DUE_SOON_DAYS_THRESHOLD=os.environ.get('DUE_SOON_DAYS_THRESHOLD') or 2 USE_SFTP=os.environ.get('USE_SFTP')==\"True\" SFTP_HOSTNAME=os.environ.get('SFTP_HOSTNAME') SFTP_PORT=os.environ.get('SFTP_PORT') SFTP_USERNAME=os.environ.get('SFTP_USERNAME') SFTP_RSA_KEY_FILE=os.environ.get('SFTP_RSA_KEY_FILE') SFTP_UPLOAD_DIRECTORY=os.environ.get('SFTP_UPLOAD_DIRECTORY') PERMANENT_SESSION_LIFETIME=timedelta(minutes=int(os.environ.get('PERMANENT_SESSION_LIFETIME', 30))) SAML_PATH=(os.environ.get('SAML_PATH') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'saml')) IDP=os.environ.get('IDP') USE_SAML=os.environ.get('USE_SAML')==\"True\" USE_LDAP=os.environ.get('USE_LDAP')==\"True\" LDAP_SERVER=os.environ.get('LDAP_SERVER') or None LDAP_PORT=os.environ.get('LDAP_PORT') or None LDAP_USE_TLS=os.environ.get('LDAP_USE_TLS')==\"True\" LDAP_KEY_PATH=os.environ.get('LDAP_KEY_PATH') or None LDAP_SA_BIND_DN=os.environ.get('LDAP_SA_BIND_DN') or None LDAP_SA_PASSWORD=os.environ.get('LDAP_SA_PASSWORD') or None LDAP_BASE_DN=os.environ.get('LDAP_BASE_DN') or None SQLALCHEMY_COMMIT_ON_TEARDOWN=True REDIS_HOST=os.environ.get('REDIS_HOST') or 'localhost' REDIS_PORT=os.environ.get('REDIS_PORT') or '6379' CELERY_REDIS_DB=0 SESSION_REDIS_DB=1 UPLOAD_REDIS_DB=2 EMAIL_REDIS_DB=3 CELERY_BROKER_URL='redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format( redis_host=REDIS_HOST, redis_port=REDIS_PORT, celery_redis_db=CELERY_REDIS_DB ) CELERY_RESULT_BACKEND='redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format( redis_host=REDIS_HOST, redis_port=REDIS_PORT, celery_redis_db=CELERY_REDIS_DB ) MAIL_SERVER=os.environ.get('MAIL_SERVER') MAIL_PORT=os.environ.get('MAIL_PORT') MAIL_USE_TLS=os.environ.get('MAIL_USE_TLS', \"True\")==\"True\" MAIL_USERNAME=os.environ.get('MAIL_USERNAME') MAIL_PASSWORD=os.environ.get('MAIL_PASSWORD') MAIL_SUBJECT_PREFIX=os.environ.get('SUBJECT_PREFIX') MAIL_SENDER=os.environ.get('MAIL_SENDER') EMAIL_TEMPLATE_DIR='email_templates\/' SQLALCHEMY_TRACK_MODIFICATIONS=False UPLOAD_QUARANTINE_DIRECTORY=(os.environ.get('UPLOAD_QUARANTINE_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/incoming\/')) UPLOAD_SERVING_DIRECTORY=(os.environ.get('UPLOAD_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/outgoing\/')) UPLOAD_DIRECTORY=(os.environ.get('UPLOAD_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/') if not USE_SFTP else SFTP_UPLOAD_DIRECTORY) VIRUS_SCAN_ENABLED=os.environ.get('VIRUS_SCAN_ENABLED')==\"True\" MAGIC_FILE=(os.environ.get('MAGIC_FILE') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'magic')) RECAPTCHA_SITE_KEY=os.environ.get('RECAPTCHA_SITE_KEY') RECAPTCHA_SECRET_KEY=os.environ.get('RECAPTCHA_SECRET_KEY') ELASTICSEARCH_HOST=os.environ.get('ELASTICSEARCH_HOST') or \"localhost:9200\" ELASTICSEARCH_ENABLED=os.environ.get('ELASTICSEARCH_ENABLED')==\"True\" ELASTICSEARCH_INDEX=os.environ.get('ELASTICSEARCH_INDEX') or \"requests\" ELASTICSEARCH_USE_SSL=os.environ.get('ELASTICSEARCH_USE_SSL')==\"True\" ELASTICSEARCH_USERNAME=os.environ.get('ELASTICSEARCH_USERNAME') ELASTICSEARCH_PASSWORD=os.environ.get('ELASTICSEARCH_PASSWORD') ELASTICSEARCH_HTTP_AUTH=((ELASTICSEARCH_USERNAME, ELASTICSEARCH_PASSWORD) if ELASTICSEARCH_USERNAME and ELASTICSEARCH_PASSWORD else None) @staticmethod def init_app(app): pass class DevelopmentConfig(Config): DEBUG=True VIRUS_SCAN_ENABLED=os.environ.get('VIRUS_SCAN_ENABLED')==\"True\" MAIL_SERVER=os.environ.get('MAIL_SERVER') or 'localhost' MAIL_PORT=os.environ.get('MAIL_PORT') or 2500 MAIL_USE_TLS=False MAIL_SUBJECT_PREFIX='[OpenRecords Development]' MAIL_SENDER='OpenRecords -Dev Admin <donotreply@records.nyc.gov>' SQLALCHEMY_DATABASE_URI=(os.environ.get('DATABASE_URL') or 'postgresql:\/\/localhost:5432\/openrecords_v2_0_dev') ELASTICSEARCH_INDEX=os.environ.get('ELASTICSEARCH_INDEX') or \"requests_dev\" MAGIC_FILE=os.environ.get('MAGIC_FILE') class TestingConfig(Config): TESTING=True VIRUS_SCAN_ENABLED=True USE_SFTP=False UPLOAD_DIRECTORY=os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/') MAIL_SUBJECT_PREFIX='[OpenRecords Testing]' MAIL_SENDER='OpenRecords -Testing Admin <donotreply@records.nyc.gov>' SQLALCHEMY_DATABASE_URI=(os.environ.get('TEST_DATABASE_URL') or 'postgresql:\/\/localhost:5432\/openrecords_v2_0_test') class ProductionConfig(Config): VIRUS_SCAN_ENABLED=True ELASTICSEARCH_ENABLED=True config={ 'development': DevelopmentConfig, 'testing': TestingConfig, 'production': ProductionConfig, 'default': DevelopmentConfig } ","sourceWithComments":"import os\nfrom datetime import timedelta\n\nfrom dotenv import load_dotenv\n\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\ndotenv_path = os.path.join(basedir, '.env')\nload_dotenv(dotenv_path)\n\n\nclass Config:\n    NYC_GOV_BASE = 'www1.nyc.gov'\n    WTF_CSRF_ENABLED = True\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'\n    LOGFILE_DIRECTORY = (os.environ.get('LOGFILE_DIRECTORY') or\n                         os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n\n    APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n\n    # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n    BASE_URL = os.environ.get('BASE_URL')\n    VIEW_REQUEST_ENDPOINT = os.environ.get('VIEW_REQUEST_ENDPOINT')\n\n    AGENCY_DATA = (os.environ.get('AGENCY_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'agencies.csv'))\n    REASON_DATA = (os.environ.get('REASONS_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'reasons.csv'))\n    STAFF_DATA = (os.environ.get('STAFF_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'staff.csv'))\n\n    DUE_SOON_DAYS_THRESHOLD = os.environ.get('DUE_SOON_DAYS_THRESHOLD') or 2\n\n    # SFTP\n    USE_SFTP = os.environ.get('USE_SFTP') == \"True\"\n    SFTP_HOSTNAME = os.environ.get('SFTP_HOSTNAME')\n    SFTP_PORT = os.environ.get('SFTP_PORT')\n    SFTP_USERNAME = os.environ.get('SFTP_USERNAME')\n    SFTP_RSA_KEY_FILE = os.environ.get('SFTP_RSA_KEY_FILE')\n    SFTP_UPLOAD_DIRECTORY = os.environ.get('SFTP_UPLOAD_DIRECTORY')\n\n    # Authentication Settings\n    PERMANENT_SESSION_LIFETIME = timedelta(minutes=int(os.environ.get('PERMANENT_SESSION_LIFETIME', 30)))\n    SAML_PATH = (os.environ.get('SAML_PATH') or\n                os.path.join(os.path.abspath(os.path.dirname(__file__)), 'saml'))\n    IDP = os.environ.get('IDP')\n    USE_SAML = os.environ.get('USE_SAML') == \"True\"\n    USE_LDAP = os.environ.get('USE_LDAP') == \"True\"\n    LDAP_SERVER = os.environ.get('LDAP_SERVER') or None\n    LDAP_PORT = os.environ.get('LDAP_PORT') or None\n    LDAP_USE_TLS = os.environ.get('LDAP_USE_TLS') == \"True\"\n    LDAP_KEY_PATH = os.environ.get('LDAP_KEY_PATH') or None\n    LDAP_SA_BIND_DN = os.environ.get('LDAP_SA_BIND_DN') or None\n    LDAP_SA_PASSWORD = os.environ.get('LDAP_SA_PASSWORD') or None\n    LDAP_BASE_DN = os.environ.get('LDAP_BASE_DN') or None\n\n    # Database Settings\n    SQLALCHEMY_COMMIT_ON_TEARDOWN = True\n\n    # Redis Settings\n    REDIS_HOST = os.environ.get('REDIS_HOST') or 'localhost'\n    REDIS_PORT = os.environ.get('REDIS_PORT') or '6379'\n    CELERY_REDIS_DB = 0\n    SESSION_REDIS_DB = 1\n    UPLOAD_REDIS_DB = 2\n    EMAIL_REDIS_DB = 3\n\n    # Celery Settings\n    CELERY_BROKER_URL = 'redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format(\n        redis_host=REDIS_HOST,\n        redis_port=REDIS_PORT,\n        celery_redis_db=CELERY_REDIS_DB\n    )\n    CELERY_RESULT_BACKEND = 'redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format(\n        redis_host=REDIS_HOST,\n        redis_port=REDIS_PORT,\n        celery_redis_db=CELERY_REDIS_DB\n    )\n\n    # Flask-Mail Settings\n    MAIL_SERVER = os.environ.get('MAIL_SERVER')\n    MAIL_PORT = os.environ.get('MAIL_PORT')\n    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', \"True\") == \"True\"\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    MAIL_SUBJECT_PREFIX = os.environ.get('SUBJECT_PREFIX')\n    MAIL_SENDER = os.environ.get('MAIL_SENDER')\n\n    # TODO: should be a constant\n    EMAIL_TEMPLATE_DIR = 'email_templates\/'\n\n    # Flask-SQLAlchemy\n    SQLALCHEMY_TRACK_MODIFICATIONS = False  # remove once this becomes the default\n\n    # Upload Settings\n    # TODO: change naming since quarantine is used as a serving directory as well\n    UPLOAD_QUARANTINE_DIRECTORY = (os.environ.get('UPLOAD_QUARANTINE_DIRECTORY') or\n                                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/incoming\/'))\n    UPLOAD_SERVING_DIRECTORY = (os.environ.get('UPLOAD_DIRECTORY') or\n                                os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/outgoing\/'))\n    UPLOAD_DIRECTORY = (os.environ.get('UPLOAD_DIRECTORY') or\n                        os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/')\n                        if not USE_SFTP else SFTP_UPLOAD_DIRECTORY)\n    VIRUS_SCAN_ENABLED = os.environ.get('VIRUS_SCAN_ENABLED') == \"True\"\n    MAGIC_FILE = (os.environ.get('MAGIC_FILE') or\n                  os.path.join(os.path.abspath(os.path.dirname(__file__)), 'magic'))\n\n    # ReCaptcha\n    RECAPTCHA_SITE_KEY = os.environ.get('RECAPTCHA_SITE_KEY')\n    RECAPTCHA_SECRET_KEY = os.environ.get('RECAPTCHA_SECRET_KEY')\n\n    # ElasticSearch settings\n    ELASTICSEARCH_HOST = os.environ.get('ELASTICSEARCH_HOST') or \"localhost:9200\"\n    ELASTICSEARCH_ENABLED = os.environ.get('ELASTICSEARCH_ENABLED') == \"True\"\n    ELASTICSEARCH_INDEX = os.environ.get('ELASTICSEARCH_INDEX') or \"requests\"\n    ELASTICSEARCH_USE_SSL = os.environ.get('ELASTICSEARCH_USE_SSL') == \"True\"\n    ELASTICSEARCH_USERNAME = os.environ.get('ELASTICSEARCH_USERNAME')\n    ELASTICSEARCH_PASSWORD = os.environ.get('ELASTICSEARCH_PASSWORD')\n    ELASTICSEARCH_HTTP_AUTH = ((ELASTICSEARCH_USERNAME,\n                                ELASTICSEARCH_PASSWORD)\n                               if ELASTICSEARCH_USERNAME and ELASTICSEARCH_PASSWORD\n                               else None)\n    # https:\/\/www.elastic.co\/blog\/index-vs-type\n\n    @staticmethod\n    def init_app(app):\n        pass\n\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n    VIRUS_SCAN_ENABLED = os.environ.get('VIRUS_SCAN_ENABLED') == \"True\"\n    MAIL_SERVER = os.environ.get('MAIL_SERVER') or 'localhost'\n    MAIL_PORT = os.environ.get('MAIL_PORT') or 2500\n    MAIL_USE_TLS = False\n    MAIL_SUBJECT_PREFIX = '[OpenRecords Development]'\n    MAIL_SENDER = 'OpenRecords - Dev Admin <donotreply@records.nyc.gov>'\n    SQLALCHEMY_DATABASE_URI = (os.environ.get('DATABASE_URL') or\n                               'postgresql:\/\/localhost:5432\/openrecords_v2_0_dev')\n    # Using Vagrant? Try: 'postgresql:\/\/vagrant@\/openrecords_v2_0_dev'\n    ELASTICSEARCH_INDEX = os.environ.get('ELASTICSEARCH_INDEX') or \"requests_dev\"\n    MAGIC_FILE = os.environ.get('MAGIC_FILE')\n\n\nclass TestingConfig(Config):\n    TESTING = True\n    VIRUS_SCAN_ENABLED = True\n    USE_SFTP = False\n    UPLOAD_DIRECTORY = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/')\n    MAIL_SUBJECT_PREFIX = '[OpenRecords Testing]'\n    MAIL_SENDER = 'OpenRecords - Testing Admin <donotreply@records.nyc.gov>'\n    SQLALCHEMY_DATABASE_URI = (os.environ.get('TEST_DATABASE_URL') or\n                               'postgresql:\/\/localhost:5432\/openrecords_v2_0_test')\n\n\nclass ProductionConfig(Config):\n    # TODO: complete me\n    VIRUS_SCAN_ENABLED = True\n    ELASTICSEARCH_ENABLED = True\n\n\nconfig = {\n    'development': DevelopmentConfig,\n    'testing': TestingConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n"}},"msg":"prevent session fixation attacks"}},"https:\/\/github.com\/CityOfNewYork\/NYCOpenRecords":{"95cea5e2342f6807df783a8547e75a81bffe060d":{"url":"https:\/\/api.github.com\/repos\/CityOfNewYork\/NYCOpenRecords\/commits\/95cea5e2342f6807df783a8547e75a81bffe060d","html_url":"https:\/\/github.com\/CityOfNewYork\/NYCOpenRecords\/commit\/95cea5e2342f6807df783a8547e75a81bffe060d","message":"prevent session fixation attacks","sha":"95cea5e2342f6807df783a8547e75a81bffe060d","keyword":"session fixation prevent","diff":"diff --git a\/app\/auth\/views.py b\/app\/auth\/views.py\nindex ff4436a42..e68ad4988 100644\n--- a\/app\/auth\/views.py\n+++ b\/app\/auth\/views.py\n@@ -73,6 +73,7 @@ def ldap_login():\n \n             if authenticated:\n                 login_user(user)\n+                session.regenerate()  # KVSession.regenerate()\n                 session['user_id'] = current_user.get_id()\n \n                 return_to_url = request.form.get('return_to_url')\ndiff --git a\/config.py b\/config.py\nindex 5660f7d2c..6b1aee8ee 100644\n--- a\/config.py\n+++ b\/config.py\n@@ -17,7 +17,7 @@ class Config:\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","files":{"\/config.py":{"changes":[{"diff":"\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","add":1,"remove":1,"filename":"\/config.py","badparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True"],"goodparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'"]},{"diff":"\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","add":1,"remove":1,"filename":"\/config.py","badparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True"],"goodparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'"]}],"source":"\nimport os from datetime import timedelta from dotenv import load_dotenv basedir=os.path.abspath(os.path.dirname(__file__)) dotenv_path=os.path.join(basedir, '.env') load_dotenv(dotenv_path) class Config: NYC_GOV_BASE='www1.nyc.gov' WTF_CSRF_ENABLED=True SECRET_KEY=os.environ.get('SECRET_KEY') or 'hard to guess string' LOGFILE_DIRECTORY=(os.environ.get('LOGFILE_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/')) APP_TIMEZONE=os.environ.get('APP_TIMEZONE') or 'US\/Eastern' SESSION_COOKIE_SECURE=os.environ.get('SESSION_COOKIE_SECURE') or True BASE_URL=os.environ.get('BASE_URL') VIEW_REQUEST_ENDPOINT=os.environ.get('VIEW_REQUEST_ENDPOINT') AGENCY_DATA=(os.environ.get('AGENCY_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'agencies.csv')) REASON_DATA=(os.environ.get('REASONS_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'reasons.csv')) STAFF_DATA=(os.environ.get('STAFF_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'staff.csv')) DUE_SOON_DAYS_THRESHOLD=os.environ.get('DUE_SOON_DAYS_THRESHOLD') or 2 USE_SFTP=os.environ.get('USE_SFTP')==\"True\" SFTP_HOSTNAME=os.environ.get('SFTP_HOSTNAME') SFTP_PORT=os.environ.get('SFTP_PORT') SFTP_USERNAME=os.environ.get('SFTP_USERNAME') SFTP_RSA_KEY_FILE=os.environ.get('SFTP_RSA_KEY_FILE') SFTP_UPLOAD_DIRECTORY=os.environ.get('SFTP_UPLOAD_DIRECTORY') PERMANENT_SESSION_LIFETIME=timedelta(minutes=int(os.environ.get('PERMANENT_SESSION_LIFETIME', 30))) SAML_PATH=(os.environ.get('SAML_PATH') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'saml')) IDP=os.environ.get('IDP') USE_SAML=os.environ.get('USE_SAML')==\"True\" USE_LDAP=os.environ.get('USE_LDAP')==\"True\" LDAP_SERVER=os.environ.get('LDAP_SERVER') or None LDAP_PORT=os.environ.get('LDAP_PORT') or None LDAP_USE_TLS=os.environ.get('LDAP_USE_TLS')==\"True\" LDAP_KEY_PATH=os.environ.get('LDAP_KEY_PATH') or None LDAP_SA_BIND_DN=os.environ.get('LDAP_SA_BIND_DN') or None LDAP_SA_PASSWORD=os.environ.get('LDAP_SA_PASSWORD') or None LDAP_BASE_DN=os.environ.get('LDAP_BASE_DN') or None SQLALCHEMY_COMMIT_ON_TEARDOWN=True REDIS_HOST=os.environ.get('REDIS_HOST') or 'localhost' REDIS_PORT=os.environ.get('REDIS_PORT') or '6379' CELERY_REDIS_DB=0 SESSION_REDIS_DB=1 UPLOAD_REDIS_DB=2 EMAIL_REDIS_DB=3 CELERY_BROKER_URL='redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format( redis_host=REDIS_HOST, redis_port=REDIS_PORT, celery_redis_db=CELERY_REDIS_DB ) CELERY_RESULT_BACKEND='redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format( redis_host=REDIS_HOST, redis_port=REDIS_PORT, celery_redis_db=CELERY_REDIS_DB ) MAIL_SERVER=os.environ.get('MAIL_SERVER') MAIL_PORT=os.environ.get('MAIL_PORT') MAIL_USE_TLS=os.environ.get('MAIL_USE_TLS', \"True\")==\"True\" MAIL_USERNAME=os.environ.get('MAIL_USERNAME') MAIL_PASSWORD=os.environ.get('MAIL_PASSWORD') MAIL_SUBJECT_PREFIX=os.environ.get('SUBJECT_PREFIX') MAIL_SENDER=os.environ.get('MAIL_SENDER') EMAIL_TEMPLATE_DIR='email_templates\/' SQLALCHEMY_TRACK_MODIFICATIONS=False UPLOAD_QUARANTINE_DIRECTORY=(os.environ.get('UPLOAD_QUARANTINE_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/incoming\/')) UPLOAD_SERVING_DIRECTORY=(os.environ.get('UPLOAD_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/outgoing\/')) UPLOAD_DIRECTORY=(os.environ.get('UPLOAD_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/') if not USE_SFTP else SFTP_UPLOAD_DIRECTORY) VIRUS_SCAN_ENABLED=os.environ.get('VIRUS_SCAN_ENABLED')==\"True\" MAGIC_FILE=(os.environ.get('MAGIC_FILE') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'magic')) RECAPTCHA_SITE_KEY=os.environ.get('RECAPTCHA_SITE_KEY') RECAPTCHA_SECRET_KEY=os.environ.get('RECAPTCHA_SECRET_KEY') ELASTICSEARCH_HOST=os.environ.get('ELASTICSEARCH_HOST') or \"localhost:9200\" ELASTICSEARCH_ENABLED=os.environ.get('ELASTICSEARCH_ENABLED')==\"True\" ELASTICSEARCH_INDEX=os.environ.get('ELASTICSEARCH_INDEX') or \"requests\" ELASTICSEARCH_USE_SSL=os.environ.get('ELASTICSEARCH_USE_SSL')==\"True\" ELASTICSEARCH_USERNAME=os.environ.get('ELASTICSEARCH_USERNAME') ELASTICSEARCH_PASSWORD=os.environ.get('ELASTICSEARCH_PASSWORD') ELASTICSEARCH_HTTP_AUTH=((ELASTICSEARCH_USERNAME, ELASTICSEARCH_PASSWORD) if ELASTICSEARCH_USERNAME and ELASTICSEARCH_PASSWORD else None) @staticmethod def init_app(app): pass class DevelopmentConfig(Config): DEBUG=True VIRUS_SCAN_ENABLED=os.environ.get('VIRUS_SCAN_ENABLED')==\"True\" MAIL_SERVER=os.environ.get('MAIL_SERVER') or 'localhost' MAIL_PORT=os.environ.get('MAIL_PORT') or 2500 MAIL_USE_TLS=False MAIL_SUBJECT_PREFIX='[OpenRecords Development]' MAIL_SENDER='OpenRecords -Dev Admin <donotreply@records.nyc.gov>' SQLALCHEMY_DATABASE_URI=(os.environ.get('DATABASE_URL') or 'postgresql:\/\/localhost:5432\/openrecords_v2_0_dev') ELASTICSEARCH_INDEX=os.environ.get('ELASTICSEARCH_INDEX') or \"requests_dev\" MAGIC_FILE=os.environ.get('MAGIC_FILE') class TestingConfig(Config): TESTING=True VIRUS_SCAN_ENABLED=True USE_SFTP=False UPLOAD_DIRECTORY=os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/') MAIL_SUBJECT_PREFIX='[OpenRecords Testing]' MAIL_SENDER='OpenRecords -Testing Admin <donotreply@records.nyc.gov>' SQLALCHEMY_DATABASE_URI=(os.environ.get('TEST_DATABASE_URL') or 'postgresql:\/\/localhost:5432\/openrecords_v2_0_test') class ProductionConfig(Config): VIRUS_SCAN_ENABLED=True ELASTICSEARCH_ENABLED=True config={ 'development': DevelopmentConfig, 'testing': TestingConfig, 'production': ProductionConfig, 'default': DevelopmentConfig } ","sourceWithComments":"import os\nfrom datetime import timedelta\n\nfrom dotenv import load_dotenv\n\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\ndotenv_path = os.path.join(basedir, '.env')\nload_dotenv(dotenv_path)\n\n\nclass Config:\n    NYC_GOV_BASE = 'www1.nyc.gov'\n    WTF_CSRF_ENABLED = True\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'\n    LOGFILE_DIRECTORY = (os.environ.get('LOGFILE_DIRECTORY') or\n                         os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n\n    APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n\n    # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n    BASE_URL = os.environ.get('BASE_URL')\n    VIEW_REQUEST_ENDPOINT = os.environ.get('VIEW_REQUEST_ENDPOINT')\n\n    AGENCY_DATA = (os.environ.get('AGENCY_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'agencies.csv'))\n    REASON_DATA = (os.environ.get('REASONS_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'reasons.csv'))\n    STAFF_DATA = (os.environ.get('STAFF_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'staff.csv'))\n\n    DUE_SOON_DAYS_THRESHOLD = os.environ.get('DUE_SOON_DAYS_THRESHOLD') or 2\n\n    # SFTP\n    USE_SFTP = os.environ.get('USE_SFTP') == \"True\"\n    SFTP_HOSTNAME = os.environ.get('SFTP_HOSTNAME')\n    SFTP_PORT = os.environ.get('SFTP_PORT')\n    SFTP_USERNAME = os.environ.get('SFTP_USERNAME')\n    SFTP_RSA_KEY_FILE = os.environ.get('SFTP_RSA_KEY_FILE')\n    SFTP_UPLOAD_DIRECTORY = os.environ.get('SFTP_UPLOAD_DIRECTORY')\n\n    # Authentication Settings\n    PERMANENT_SESSION_LIFETIME = timedelta(minutes=int(os.environ.get('PERMANENT_SESSION_LIFETIME', 30)))\n    SAML_PATH = (os.environ.get('SAML_PATH') or\n                os.path.join(os.path.abspath(os.path.dirname(__file__)), 'saml'))\n    IDP = os.environ.get('IDP')\n    USE_SAML = os.environ.get('USE_SAML') == \"True\"\n    USE_LDAP = os.environ.get('USE_LDAP') == \"True\"\n    LDAP_SERVER = os.environ.get('LDAP_SERVER') or None\n    LDAP_PORT = os.environ.get('LDAP_PORT') or None\n    LDAP_USE_TLS = os.environ.get('LDAP_USE_TLS') == \"True\"\n    LDAP_KEY_PATH = os.environ.get('LDAP_KEY_PATH') or None\n    LDAP_SA_BIND_DN = os.environ.get('LDAP_SA_BIND_DN') or None\n    LDAP_SA_PASSWORD = os.environ.get('LDAP_SA_PASSWORD') or None\n    LDAP_BASE_DN = os.environ.get('LDAP_BASE_DN') or None\n\n    # Database Settings\n    SQLALCHEMY_COMMIT_ON_TEARDOWN = True\n\n    # Redis Settings\n    REDIS_HOST = os.environ.get('REDIS_HOST') or 'localhost'\n    REDIS_PORT = os.environ.get('REDIS_PORT') or '6379'\n    CELERY_REDIS_DB = 0\n    SESSION_REDIS_DB = 1\n    UPLOAD_REDIS_DB = 2\n    EMAIL_REDIS_DB = 3\n\n    # Celery Settings\n    CELERY_BROKER_URL = 'redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format(\n        redis_host=REDIS_HOST,\n        redis_port=REDIS_PORT,\n        celery_redis_db=CELERY_REDIS_DB\n    )\n    CELERY_RESULT_BACKEND = 'redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format(\n        redis_host=REDIS_HOST,\n        redis_port=REDIS_PORT,\n        celery_redis_db=CELERY_REDIS_DB\n    )\n\n    # Flask-Mail Settings\n    MAIL_SERVER = os.environ.get('MAIL_SERVER')\n    MAIL_PORT = os.environ.get('MAIL_PORT')\n    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', \"True\") == \"True\"\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    MAIL_SUBJECT_PREFIX = os.environ.get('SUBJECT_PREFIX')\n    MAIL_SENDER = os.environ.get('MAIL_SENDER')\n\n    # TODO: should be a constant\n    EMAIL_TEMPLATE_DIR = 'email_templates\/'\n\n    # Flask-SQLAlchemy\n    SQLALCHEMY_TRACK_MODIFICATIONS = False  # remove once this becomes the default\n\n    # Upload Settings\n    # TODO: change naming since quarantine is used as a serving directory as well\n    UPLOAD_QUARANTINE_DIRECTORY = (os.environ.get('UPLOAD_QUARANTINE_DIRECTORY') or\n                                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/incoming\/'))\n    UPLOAD_SERVING_DIRECTORY = (os.environ.get('UPLOAD_DIRECTORY') or\n                                os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/outgoing\/'))\n    UPLOAD_DIRECTORY = (os.environ.get('UPLOAD_DIRECTORY') or\n                        os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/')\n                        if not USE_SFTP else SFTP_UPLOAD_DIRECTORY)\n    VIRUS_SCAN_ENABLED = os.environ.get('VIRUS_SCAN_ENABLED') == \"True\"\n    MAGIC_FILE = (os.environ.get('MAGIC_FILE') or\n                  os.path.join(os.path.abspath(os.path.dirname(__file__)), 'magic'))\n\n    # ReCaptcha\n    RECAPTCHA_SITE_KEY = os.environ.get('RECAPTCHA_SITE_KEY')\n    RECAPTCHA_SECRET_KEY = os.environ.get('RECAPTCHA_SECRET_KEY')\n\n    # ElasticSearch settings\n    ELASTICSEARCH_HOST = os.environ.get('ELASTICSEARCH_HOST') or \"localhost:9200\"\n    ELASTICSEARCH_ENABLED = os.environ.get('ELASTICSEARCH_ENABLED') == \"True\"\n    ELASTICSEARCH_INDEX = os.environ.get('ELASTICSEARCH_INDEX') or \"requests\"\n    ELASTICSEARCH_USE_SSL = os.environ.get('ELASTICSEARCH_USE_SSL') == \"True\"\n    ELASTICSEARCH_USERNAME = os.environ.get('ELASTICSEARCH_USERNAME')\n    ELASTICSEARCH_PASSWORD = os.environ.get('ELASTICSEARCH_PASSWORD')\n    ELASTICSEARCH_HTTP_AUTH = ((ELASTICSEARCH_USERNAME,\n                                ELASTICSEARCH_PASSWORD)\n                               if ELASTICSEARCH_USERNAME and ELASTICSEARCH_PASSWORD\n                               else None)\n    # https:\/\/www.elastic.co\/blog\/index-vs-type\n\n    @staticmethod\n    def init_app(app):\n        pass\n\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n    VIRUS_SCAN_ENABLED = os.environ.get('VIRUS_SCAN_ENABLED') == \"True\"\n    MAIL_SERVER = os.environ.get('MAIL_SERVER') or 'localhost'\n    MAIL_PORT = os.environ.get('MAIL_PORT') or 2500\n    MAIL_USE_TLS = False\n    MAIL_SUBJECT_PREFIX = '[OpenRecords Development]'\n    MAIL_SENDER = 'OpenRecords - Dev Admin <donotreply@records.nyc.gov>'\n    SQLALCHEMY_DATABASE_URI = (os.environ.get('DATABASE_URL') or\n                               'postgresql:\/\/localhost:5432\/openrecords_v2_0_dev')\n    # Using Vagrant? Try: 'postgresql:\/\/vagrant@\/openrecords_v2_0_dev'\n    ELASTICSEARCH_INDEX = os.environ.get('ELASTICSEARCH_INDEX') or \"requests_dev\"\n    MAGIC_FILE = os.environ.get('MAGIC_FILE')\n\n\nclass TestingConfig(Config):\n    TESTING = True\n    VIRUS_SCAN_ENABLED = True\n    USE_SFTP = False\n    UPLOAD_DIRECTORY = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/')\n    MAIL_SUBJECT_PREFIX = '[OpenRecords Testing]'\n    MAIL_SENDER = 'OpenRecords - Testing Admin <donotreply@records.nyc.gov>'\n    SQLALCHEMY_DATABASE_URI = (os.environ.get('TEST_DATABASE_URL') or\n                               'postgresql:\/\/localhost:5432\/openrecords_v2_0_test')\n\n\nclass ProductionConfig(Config):\n    # TODO: complete me\n    VIRUS_SCAN_ENABLED = True\n    ELASTICSEARCH_ENABLED = True\n\n\nconfig = {\n    'development': DevelopmentConfig,\n    'testing': TestingConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n"}},"msg":"prevent session fixation attacks"}},"https:\/\/github.com\/pypi\/warehouse":{"6c7ebab691bcec56724e8b3d82583514f06be79d":{"url":"https:\/\/api.github.com\/repos\/pypi\/warehouse\/commits\/6c7ebab691bcec56724e8b3d82583514f06be79d","html_url":"https:\/\/github.com\/pypi\/warehouse\/commit\/6c7ebab691bcec56724e8b3d82583514f06be79d","sha":"6c7ebab691bcec56724e8b3d82583514f06be79d","keyword":"session fixation protect","diff":"diff --git a\/tests\/accounts\/test_views.py b\/tests\/accounts\/test_views.py\nindex 1721d767cd5..457e1e9236c 100644\n--- a\/tests\/accounts\/test_views.py\n+++ b\/tests\/accounts\/test_views.py\n@@ -95,17 +95,29 @@ def test_post_invalid_returns_form(self, pyramid_request):\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n@@ -128,6 +140,11 @@ def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n             ),\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n+        if with_user:\n+            assert new_session == {}\n+        else:\n+            assert new_session == {\"a\": \"b\", \"foo\": \"bar\"}\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert remember.calls == [pretend.call(pyramid_request, 1)]\n         assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n@@ -143,10 +160,14 @@ def test_post_forgets_user(self, monkeypatch, pyramid_request):\n         monkeypatch.setattr(views, \"forget\", forget)\n \n         pyramid_request.method = \"POST\"\n+        pyramid_request.session = pretend.stub(\n+            invalidate=pretend.call_recorder(lambda: None),\n+        )\n \n         result = views.logout(pyramid_request)\n \n         assert isinstance(result, HTTPSeeOther)\n         assert result.headers[\"Location\"] == \"\/\"\n         assert forget.calls == [pretend.call(pyramid_request)]\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\ndiff --git a\/warehouse\/accounts\/views.py b\/warehouse\/accounts\/views.py\nindex ab3c6fa89af..e4911adf3ce 100644\n--- a\/warehouse\/accounts\/views.py\n+++ b\/warehouse\/accounts\/views.py\n@@ -66,6 +66,33 @@ def login(request, _form_class=LoginForm):\n     )\n \n     if request.method == \"POST\" and form.validate():\n+        # We have a session factory associated with this request, so in order\n+        # to protect against session fixation attacks we're going to make sure\n+        # that we create a new session (which for sessions with an identifier\n+        # will cause it to get a new session identifier).\n+\n+        # We need to protect against session fixation attacks, so make sure\n+        # that we create a new session (which will cause it to get a new\n+        # session identifier).\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        if (request.unauthenticated_userid is not None\n+                and request.unauthenticated_userid != form.user.id):\n+            # There is already a userid associated with this request and it is\n+            # a different userid than the one we're trying to remember now. In\n+            # this case we want to drop the existing session completely because\n+            # we don't want to leak any data between authenticated userids.\n+            request.session.invalidate()\n+        else:\n+            # We either do not have an associated userid with this request\n+            # already, or the userid is the same one we're trying to remember\n+            # now. In either case we want to keep all of the data but we want\n+            # to make sure that we create a new session since we're crossing\n+            # a privilege boundary.\n+            data = dict(request.session.items())\n+            request.session.invalidate()\n+            request.session.update(data)\n+\n         # Remember the userid using the authentication policy.\n         headers = remember(request, form.user.id)\n         request.response.headerlist.extend(headers)\n@@ -102,6 +129,18 @@ def logout(request):\n         headers = forget(request)\n         request.response.headerlist.extend(headers)\n \n+        # When crossing an authentication boundry we want to create a new\n+        # session identifier. We don't want to keep any information in the\n+        # session when going from authenticated to unauthenticated because\n+        # user's generally expect that logging out is a desctructive action\n+        # that erases all of their private data. However if we don't clear the\n+        # session then another user can use the computer after them, log in to\n+        # their account, and then gain access to anything sensitive stored in\n+        # the session for the original user.\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        request.session.invalidate()\n+\n         # Now that we're logged out we'll want to redirect the user to either\n         # where they were originally, or to the default view.\n         # TODO: Implement ?next= support.\n","message":"","files":{"\/tests\/accounts\/test_views.py":{"changes":[{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]},{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]}],"source":"\n import pretend import pytest from pyramid.httpexceptions import( HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther, ) from warehouse.accounts import views from..common.db.accounts import UserFactory class TestUserProfile: def test_no_user(self, db_request): with pytest.raises(HTTPNotFound): views.profile(db_request, \"non-existent-user\") def test_user_redirects_username(self, db_request): user=UserFactory.create(session=db_request.db) if user.username.upper() !=user.username: username=user.username.upper() else: username=user.username.lower() db_request.current_route_url=pretend.call_recorder( lambda username: \"\/user\/the-redirect\/\" ) result=views.profile(db_request, username) assert isinstance(result, HTTPMovedPermanently) assert result.headers[\"Location\"]==\"\/user\/the-redirect\/\" assert db_request.current_route_url.calls==[ pretend.call(username=user.username), ] def test_returns_user(self, db_request): user=UserFactory.create(session=db_request.db) assert views.profile(db_request, user.username)=={\"user\": user} class TestLogin: def test_get_returns_form(self, pyramid_request): pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub() form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] def test_post_invalid_returns_form(self, pyramid_request): pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub(validate=pretend.call_recorder(lambda: False)) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] def test_post_validate_redirects(self, monkeypatch, pyramid_request): remember=pretend.call_recorder( lambda request, user_id:[(\"foo\", \"bar\")] ) monkeypatch.setattr(views, \"remember\", remember) pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() pyramid_request.session=pretend.stub( new_csrf_token=pretend.call_recorder(lambda: None) ) form_obj=pretend.stub( validate=pretend.call_recorder(lambda: True), user=pretend.stub(id=1), ) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] assert remember.calls==[pretend.call(pyramid_request, 1)] assert pyramid_request.session.new_csrf_token.calls==[pretend.call()] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist class TestLogout: def test_get_returns_empty(self, pyramid_request): assert views.logout(pyramid_request)=={} def test_post_forgets_user(self, monkeypatch, pyramid_request): forget=pretend.call_recorder(lambda request:[(\"foo\", \"bar\")]) monkeypatch.setattr(views, \"forget\", forget) pyramid_request.method=\"POST\" result=views.logout(pyramid_request) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert forget.calls==[pretend.call(pyramid_request)] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist ","sourceWithComments":"# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pretend\nimport pytest\n\nfrom pyramid.httpexceptions import (\n    HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther,\n)\n\nfrom warehouse.accounts import views\n\nfrom ..common.db.accounts import UserFactory\n\n\nclass TestUserProfile:\n\n    def test_no_user(self, db_request):\n        with pytest.raises(HTTPNotFound):\n            views.profile(db_request, \"non-existent-user\")\n\n    def test_user_redirects_username(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n\n        if user.username.upper() != user.username:\n            username = user.username.upper()\n        else:\n            username = user.username.lower()\n\n        db_request.current_route_url = pretend.call_recorder(\n            lambda username: \"\/user\/the-redirect\/\"\n        )\n\n        result = views.profile(db_request, username)\n\n        assert isinstance(result, HTTPMovedPermanently)\n        assert result.headers[\"Location\"] == \"\/user\/the-redirect\/\"\n        assert db_request.current_route_url.calls == [\n            pretend.call(username=user.username),\n        ]\n\n    def test_returns_user(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n        assert views.profile(db_request, user.username) == {\"user\": user}\n\n\nclass TestLogin:\n\n    def test_get_returns_form(self, pyramid_request):\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub()\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n\n    def test_post_invalid_returns_form(self, pyramid_request):\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub(validate=pretend.call_recorder(lambda: False))\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n\n    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n        remember = pretend.call_recorder(\n            lambda request, user_id: [(\"foo\", \"bar\")]\n        )\n        monkeypatch.setattr(views, \"remember\", remember)\n\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        pyramid_request.session = pretend.stub(\n            new_csrf_token=pretend.call_recorder(lambda: None)\n        )\n\n        form_obj = pretend.stub(\n            validate=pretend.call_recorder(lambda: True),\n            user=pretend.stub(id=1),\n        )\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n        assert remember.calls == [pretend.call(pyramid_request, 1)]\n        assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n\n\nclass TestLogout:\n\n    def test_get_returns_empty(self, pyramid_request):\n        assert views.logout(pyramid_request) == {}\n\n    def test_post_forgets_user(self, monkeypatch, pyramid_request):\n        forget = pretend.call_recorder(lambda request: [(\"foo\", \"bar\")])\n        monkeypatch.setattr(views, \"forget\", forget)\n\n        pyramid_request.method = \"POST\"\n\n        result = views.logout(pyramid_request)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert forget.calls == [pretend.call(pyramid_request)]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n"}},"msg":"Protect against session fixation and session data leakage"}},"https:\/\/github.com\/quicklers\/pypa1":{"6c7ebab691bcec56724e8b3d82583514f06be79d":{"url":"https:\/\/api.github.com\/repos\/quicklers\/pypa1\/commits\/6c7ebab691bcec56724e8b3d82583514f06be79d","html_url":"https:\/\/github.com\/quicklers\/pypa1\/commit\/6c7ebab691bcec56724e8b3d82583514f06be79d","sha":"6c7ebab691bcec56724e8b3d82583514f06be79d","keyword":"session fixation protect","diff":"diff --git a\/tests\/accounts\/test_views.py b\/tests\/accounts\/test_views.py\nindex 1721d767c..457e1e923 100644\n--- a\/tests\/accounts\/test_views.py\n+++ b\/tests\/accounts\/test_views.py\n@@ -95,17 +95,29 @@ def test_post_invalid_returns_form(self, pyramid_request):\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n@@ -128,6 +140,11 @@ def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n             ),\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n+        if with_user:\n+            assert new_session == {}\n+        else:\n+            assert new_session == {\"a\": \"b\", \"foo\": \"bar\"}\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert remember.calls == [pretend.call(pyramid_request, 1)]\n         assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n@@ -143,10 +160,14 @@ def test_post_forgets_user(self, monkeypatch, pyramid_request):\n         monkeypatch.setattr(views, \"forget\", forget)\n \n         pyramid_request.method = \"POST\"\n+        pyramid_request.session = pretend.stub(\n+            invalidate=pretend.call_recorder(lambda: None),\n+        )\n \n         result = views.logout(pyramid_request)\n \n         assert isinstance(result, HTTPSeeOther)\n         assert result.headers[\"Location\"] == \"\/\"\n         assert forget.calls == [pretend.call(pyramid_request)]\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\ndiff --git a\/warehouse\/accounts\/views.py b\/warehouse\/accounts\/views.py\nindex ab3c6fa89..e4911adf3 100644\n--- a\/warehouse\/accounts\/views.py\n+++ b\/warehouse\/accounts\/views.py\n@@ -66,6 +66,33 @@ def login(request, _form_class=LoginForm):\n     )\n \n     if request.method == \"POST\" and form.validate():\n+        # We have a session factory associated with this request, so in order\n+        # to protect against session fixation attacks we're going to make sure\n+        # that we create a new session (which for sessions with an identifier\n+        # will cause it to get a new session identifier).\n+\n+        # We need to protect against session fixation attacks, so make sure\n+        # that we create a new session (which will cause it to get a new\n+        # session identifier).\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        if (request.unauthenticated_userid is not None\n+                and request.unauthenticated_userid != form.user.id):\n+            # There is already a userid associated with this request and it is\n+            # a different userid than the one we're trying to remember now. In\n+            # this case we want to drop the existing session completely because\n+            # we don't want to leak any data between authenticated userids.\n+            request.session.invalidate()\n+        else:\n+            # We either do not have an associated userid with this request\n+            # already, or the userid is the same one we're trying to remember\n+            # now. In either case we want to keep all of the data but we want\n+            # to make sure that we create a new session since we're crossing\n+            # a privilege boundary.\n+            data = dict(request.session.items())\n+            request.session.invalidate()\n+            request.session.update(data)\n+\n         # Remember the userid using the authentication policy.\n         headers = remember(request, form.user.id)\n         request.response.headerlist.extend(headers)\n@@ -102,6 +129,18 @@ def logout(request):\n         headers = forget(request)\n         request.response.headerlist.extend(headers)\n \n+        # When crossing an authentication boundry we want to create a new\n+        # session identifier. We don't want to keep any information in the\n+        # session when going from authenticated to unauthenticated because\n+        # user's generally expect that logging out is a desctructive action\n+        # that erases all of their private data. However if we don't clear the\n+        # session then another user can use the computer after them, log in to\n+        # their account, and then gain access to anything sensitive stored in\n+        # the session for the original user.\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        request.session.invalidate()\n+\n         # Now that we're logged out we'll want to redirect the user to either\n         # where they were originally, or to the default view.\n         # TODO: Implement ?next= support.\n","message":"","files":{"\/tests\/accounts\/test_views.py":{"changes":[{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]},{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]}],"source":"\n import pretend import pytest from pyramid.httpexceptions import( HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther, ) from warehouse.accounts import views from..common.db.accounts import UserFactory class TestUserProfile: def test_no_user(self, db_request): with pytest.raises(HTTPNotFound): views.profile(db_request, \"non-existent-user\") def test_user_redirects_username(self, db_request): user=UserFactory.create(session=db_request.db) if user.username.upper() !=user.username: username=user.username.upper() else: username=user.username.lower() db_request.current_route_url=pretend.call_recorder( lambda username: \"\/user\/the-redirect\/\" ) result=views.profile(db_request, username) assert isinstance(result, HTTPMovedPermanently) assert result.headers[\"Location\"]==\"\/user\/the-redirect\/\" assert db_request.current_route_url.calls==[ pretend.call(username=user.username), ] def test_returns_user(self, db_request): user=UserFactory.create(session=db_request.db) assert views.profile(db_request, user.username)=={\"user\": user} class TestLogin: def test_get_returns_form(self, pyramid_request): pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub() form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] def test_post_invalid_returns_form(self, pyramid_request): pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub(validate=pretend.call_recorder(lambda: False)) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] def test_post_validate_redirects(self, monkeypatch, pyramid_request): remember=pretend.call_recorder( lambda request, user_id:[(\"foo\", \"bar\")] ) monkeypatch.setattr(views, \"remember\", remember) pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() pyramid_request.session=pretend.stub( new_csrf_token=pretend.call_recorder(lambda: None) ) form_obj=pretend.stub( validate=pretend.call_recorder(lambda: True), user=pretend.stub(id=1), ) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] assert remember.calls==[pretend.call(pyramid_request, 1)] assert pyramid_request.session.new_csrf_token.calls==[pretend.call()] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist class TestLogout: def test_get_returns_empty(self, pyramid_request): assert views.logout(pyramid_request)=={} def test_post_forgets_user(self, monkeypatch, pyramid_request): forget=pretend.call_recorder(lambda request:[(\"foo\", \"bar\")]) monkeypatch.setattr(views, \"forget\", forget) pyramid_request.method=\"POST\" result=views.logout(pyramid_request) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert forget.calls==[pretend.call(pyramid_request)] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist ","sourceWithComments":"# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pretend\nimport pytest\n\nfrom pyramid.httpexceptions import (\n    HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther,\n)\n\nfrom warehouse.accounts import views\n\nfrom ..common.db.accounts import UserFactory\n\n\nclass TestUserProfile:\n\n    def test_no_user(self, db_request):\n        with pytest.raises(HTTPNotFound):\n            views.profile(db_request, \"non-existent-user\")\n\n    def test_user_redirects_username(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n\n        if user.username.upper() != user.username:\n            username = user.username.upper()\n        else:\n            username = user.username.lower()\n\n        db_request.current_route_url = pretend.call_recorder(\n            lambda username: \"\/user\/the-redirect\/\"\n        )\n\n        result = views.profile(db_request, username)\n\n        assert isinstance(result, HTTPMovedPermanently)\n        assert result.headers[\"Location\"] == \"\/user\/the-redirect\/\"\n        assert db_request.current_route_url.calls == [\n            pretend.call(username=user.username),\n        ]\n\n    def test_returns_user(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n        assert views.profile(db_request, user.username) == {\"user\": user}\n\n\nclass TestLogin:\n\n    def test_get_returns_form(self, pyramid_request):\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub()\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n\n    def test_post_invalid_returns_form(self, pyramid_request):\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub(validate=pretend.call_recorder(lambda: False))\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n\n    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n        remember = pretend.call_recorder(\n            lambda request, user_id: [(\"foo\", \"bar\")]\n        )\n        monkeypatch.setattr(views, \"remember\", remember)\n\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        pyramid_request.session = pretend.stub(\n            new_csrf_token=pretend.call_recorder(lambda: None)\n        )\n\n        form_obj = pretend.stub(\n            validate=pretend.call_recorder(lambda: True),\n            user=pretend.stub(id=1),\n        )\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n        assert remember.calls == [pretend.call(pyramid_request, 1)]\n        assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n\n\nclass TestLogout:\n\n    def test_get_returns_empty(self, pyramid_request):\n        assert views.logout(pyramid_request) == {}\n\n    def test_post_forgets_user(self, monkeypatch, pyramid_request):\n        forget = pretend.call_recorder(lambda request: [(\"foo\", \"bar\")])\n        monkeypatch.setattr(views, \"forget\", forget)\n\n        pyramid_request.method = \"POST\"\n\n        result = views.logout(pyramid_request)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert forget.calls == [pretend.call(pyramid_request)]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n"}},"msg":"Protect against session fixation and session data leakage"}},"https:\/\/github.com\/startnayit\/warehouse":{"6c7ebab691bcec56724e8b3d82583514f06be79d":{"url":"https:\/\/api.github.com\/repos\/startnayit\/warehouse\/commits\/6c7ebab691bcec56724e8b3d82583514f06be79d","html_url":"https:\/\/github.com\/startnayit\/warehouse\/commit\/6c7ebab691bcec56724e8b3d82583514f06be79d","sha":"6c7ebab691bcec56724e8b3d82583514f06be79d","keyword":"session fixation protect","diff":"diff --git a\/tests\/accounts\/test_views.py b\/tests\/accounts\/test_views.py\nindex 1721d767..457e1e92 100644\n--- a\/tests\/accounts\/test_views.py\n+++ b\/tests\/accounts\/test_views.py\n@@ -95,17 +95,29 @@ def test_post_invalid_returns_form(self, pyramid_request):\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n@@ -128,6 +140,11 @@ def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n             ),\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n+        if with_user:\n+            assert new_session == {}\n+        else:\n+            assert new_session == {\"a\": \"b\", \"foo\": \"bar\"}\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert remember.calls == [pretend.call(pyramid_request, 1)]\n         assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n@@ -143,10 +160,14 @@ def test_post_forgets_user(self, monkeypatch, pyramid_request):\n         monkeypatch.setattr(views, \"forget\", forget)\n \n         pyramid_request.method = \"POST\"\n+        pyramid_request.session = pretend.stub(\n+            invalidate=pretend.call_recorder(lambda: None),\n+        )\n \n         result = views.logout(pyramid_request)\n \n         assert isinstance(result, HTTPSeeOther)\n         assert result.headers[\"Location\"] == \"\/\"\n         assert forget.calls == [pretend.call(pyramid_request)]\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\ndiff --git a\/warehouse\/accounts\/views.py b\/warehouse\/accounts\/views.py\nindex ab3c6fa8..e4911adf 100644\n--- a\/warehouse\/accounts\/views.py\n+++ b\/warehouse\/accounts\/views.py\n@@ -66,6 +66,33 @@ def login(request, _form_class=LoginForm):\n     )\n \n     if request.method == \"POST\" and form.validate():\n+        # We have a session factory associated with this request, so in order\n+        # to protect against session fixation attacks we're going to make sure\n+        # that we create a new session (which for sessions with an identifier\n+        # will cause it to get a new session identifier).\n+\n+        # We need to protect against session fixation attacks, so make sure\n+        # that we create a new session (which will cause it to get a new\n+        # session identifier).\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        if (request.unauthenticated_userid is not None\n+                and request.unauthenticated_userid != form.user.id):\n+            # There is already a userid associated with this request and it is\n+            # a different userid than the one we're trying to remember now. In\n+            # this case we want to drop the existing session completely because\n+            # we don't want to leak any data between authenticated userids.\n+            request.session.invalidate()\n+        else:\n+            # We either do not have an associated userid with this request\n+            # already, or the userid is the same one we're trying to remember\n+            # now. In either case we want to keep all of the data but we want\n+            # to make sure that we create a new session since we're crossing\n+            # a privilege boundary.\n+            data = dict(request.session.items())\n+            request.session.invalidate()\n+            request.session.update(data)\n+\n         # Remember the userid using the authentication policy.\n         headers = remember(request, form.user.id)\n         request.response.headerlist.extend(headers)\n@@ -102,6 +129,18 @@ def logout(request):\n         headers = forget(request)\n         request.response.headerlist.extend(headers)\n \n+        # When crossing an authentication boundry we want to create a new\n+        # session identifier. We don't want to keep any information in the\n+        # session when going from authenticated to unauthenticated because\n+        # user's generally expect that logging out is a desctructive action\n+        # that erases all of their private data. However if we don't clear the\n+        # session then another user can use the computer after them, log in to\n+        # their account, and then gain access to anything sensitive stored in\n+        # the session for the original user.\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        request.session.invalidate()\n+\n         # Now that we're logged out we'll want to redirect the user to either\n         # where they were originally, or to the default view.\n         # TODO: Implement ?next= support.\n","message":"","files":{"\/tests\/accounts\/test_views.py":{"changes":[{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]},{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]}],"source":"\n import pretend import pytest from pyramid.httpexceptions import( HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther, ) from warehouse.accounts import views from..common.db.accounts import UserFactory class TestUserProfile: def test_no_user(self, db_request): with pytest.raises(HTTPNotFound): views.profile(db_request, \"non-existent-user\") def test_user_redirects_username(self, db_request): user=UserFactory.create(session=db_request.db) if user.username.upper() !=user.username: username=user.username.upper() else: username=user.username.lower() db_request.current_route_url=pretend.call_recorder( lambda username: \"\/user\/the-redirect\/\" ) result=views.profile(db_request, username) assert isinstance(result, HTTPMovedPermanently) assert result.headers[\"Location\"]==\"\/user\/the-redirect\/\" assert db_request.current_route_url.calls==[ pretend.call(username=user.username), ] def test_returns_user(self, db_request): user=UserFactory.create(session=db_request.db) assert views.profile(db_request, user.username)=={\"user\": user} class TestLogin: def test_get_returns_form(self, pyramid_request): pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub() form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] def test_post_invalid_returns_form(self, pyramid_request): pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub(validate=pretend.call_recorder(lambda: False)) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] def test_post_validate_redirects(self, monkeypatch, pyramid_request): remember=pretend.call_recorder( lambda request, user_id:[(\"foo\", \"bar\")] ) monkeypatch.setattr(views, \"remember\", remember) pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() pyramid_request.session=pretend.stub( new_csrf_token=pretend.call_recorder(lambda: None) ) form_obj=pretend.stub( validate=pretend.call_recorder(lambda: True), user=pretend.stub(id=1), ) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] assert remember.calls==[pretend.call(pyramid_request, 1)] assert pyramid_request.session.new_csrf_token.calls==[pretend.call()] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist class TestLogout: def test_get_returns_empty(self, pyramid_request): assert views.logout(pyramid_request)=={} def test_post_forgets_user(self, monkeypatch, pyramid_request): forget=pretend.call_recorder(lambda request:[(\"foo\", \"bar\")]) monkeypatch.setattr(views, \"forget\", forget) pyramid_request.method=\"POST\" result=views.logout(pyramid_request) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert forget.calls==[pretend.call(pyramid_request)] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist ","sourceWithComments":"# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pretend\nimport pytest\n\nfrom pyramid.httpexceptions import (\n    HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther,\n)\n\nfrom warehouse.accounts import views\n\nfrom ..common.db.accounts import UserFactory\n\n\nclass TestUserProfile:\n\n    def test_no_user(self, db_request):\n        with pytest.raises(HTTPNotFound):\n            views.profile(db_request, \"non-existent-user\")\n\n    def test_user_redirects_username(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n\n        if user.username.upper() != user.username:\n            username = user.username.upper()\n        else:\n            username = user.username.lower()\n\n        db_request.current_route_url = pretend.call_recorder(\n            lambda username: \"\/user\/the-redirect\/\"\n        )\n\n        result = views.profile(db_request, username)\n\n        assert isinstance(result, HTTPMovedPermanently)\n        assert result.headers[\"Location\"] == \"\/user\/the-redirect\/\"\n        assert db_request.current_route_url.calls == [\n            pretend.call(username=user.username),\n        ]\n\n    def test_returns_user(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n        assert views.profile(db_request, user.username) == {\"user\": user}\n\n\nclass TestLogin:\n\n    def test_get_returns_form(self, pyramid_request):\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub()\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n\n    def test_post_invalid_returns_form(self, pyramid_request):\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub(validate=pretend.call_recorder(lambda: False))\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n\n    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n        remember = pretend.call_recorder(\n            lambda request, user_id: [(\"foo\", \"bar\")]\n        )\n        monkeypatch.setattr(views, \"remember\", remember)\n\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        pyramid_request.session = pretend.stub(\n            new_csrf_token=pretend.call_recorder(lambda: None)\n        )\n\n        form_obj = pretend.stub(\n            validate=pretend.call_recorder(lambda: True),\n            user=pretend.stub(id=1),\n        )\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n        assert remember.calls == [pretend.call(pyramid_request, 1)]\n        assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n\n\nclass TestLogout:\n\n    def test_get_returns_empty(self, pyramid_request):\n        assert views.logout(pyramid_request) == {}\n\n    def test_post_forgets_user(self, monkeypatch, pyramid_request):\n        forget = pretend.call_recorder(lambda request: [(\"foo\", \"bar\")])\n        monkeypatch.setattr(views, \"forget\", forget)\n\n        pyramid_request.method = \"POST\"\n\n        result = views.logout(pyramid_request)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert forget.calls == [pretend.call(pyramid_request)]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n"}},"msg":"Protect against session fixation and session data leakage"}},"https:\/\/github.com\/cbnusw\/cbnu_indico":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/cbnusw\/cbnu_indico\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/cbnusw\/cbnu_indico\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b0475..62bf31c26d 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/belokop\/indico":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/belokop\/indico\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/belokop\/indico\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b047..62bf31c26 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/indico\/indico":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/indico\/indico\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/indico\/indico\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b0475f..62bf31c26d1 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/eliasdesousa\/indico":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/eliasdesousa\/indico\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/eliasdesousa\/indico\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b047..62bf31c26 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/manikm\/indico2":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/manikm\/indico2\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/manikm\/indico2\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b047..62bf31c26 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/sean-\/flask-skeleton":{"f0e102a1e7d69dcb8a2eb8093c40324503aeb8a0":{"url":"https:\/\/api.github.com\/repos\/sean-\/flask-skeleton\/commits\/f0e102a1e7d69dcb8a2eb8093c40324503aeb8a0","html_url":"https:\/\/github.com\/sean-\/flask-skeleton\/commit\/f0e102a1e7d69dcb8a2eb8093c40324503aeb8a0","message":"aaa.login now generates a new session ID to prevent possible fixation attacks.\n\nSigned-off-by: Sean Chittenden <sean@chittenden.org>","sha":"f0e102a1e7d69dcb8a2eb8093c40324503aeb8a0","keyword":"session fixation prevent","diff":"diff --git a\/skeleton\/modules\/aaa\/views.py b\/skeleton\/modules\/aaa\/views.py\nindex 2ab56db..7dc772a 100644\n--- a\/skeleton\/modules\/aaa\/views.py\n+++ b\/skeleton\/modules\/aaa\/views.py\n@@ -43,6 +43,14 @@ def login():\n         else:\n             flask.abort(500)\n \n+        # Generate a new session ID upon login. If someone steals my session\n+        # id, I want to explicitly prevent its use as a way of inject\n+        # unauthenticated session information in to an authenticated\n+        # session. In the future once pgmemcache has been hooked up to the\n+        # database, the old session id will be expired from memcache\n+        # automatically.\n+        new_sess_id = gen_session_id()\n+\n         ses = db.session\n         result = ses.execute(\n             # SELECT result, \"column\", message FROM aaa.login(email := 'user@example.com', password := '\\xbd\\x18\\xee\\x85\\x9f\\x19Bl\\x1e\\x9dE\\\\xdc\\x10\\xe2NH\\x1b\\x94\\xe5n\\x01C\\x98\\xe5AQ\\x05\\xb2\\xa7,\\x1co', ip_address := '11.22.33.44', session_id := 'user session id from flask', renewal_interval := '60 minutes'::INTERVAL) AS (result BOOL, \"column\" TEXT, message TEXT);\n@@ -51,7 +59,7 @@ def login():\n                     bindparam('email', form.email.data),\n                     bindparam('pw', shapass, type_=LargeBinary),\n                     bindparam('ip', remote_addr),\n-                    bindparam('sid', session['i']),\n+                    bindparam('sid', new_sess_id),\n                     bindparam('idle',idle)]))\n \n         # Explicitly commit regardless of the remaining logic. The database\n@@ -62,6 +70,7 @@ def login():\n         ses.commit()\n         row = result.first()\n         if row[0] == True:\n+            session['i'] = new_sess_id\n             session['li'] = True\n             flash('Successfully logged in as %s' % (form.email.data))\n             return redirect(url_for('home.index'))\n","files":{"\/skeleton\/modules\/aaa\/views.py":{"changes":[{"diff":"\n                     bindparam('email', form.email.data),\n                     bindparam('pw', shapass, type_=LargeBinary),\n                     bindparam('ip', remote_addr),\n-                    bindparam('sid', session['i']),\n+                    bindparam('sid', new_sess_id),\n                     bindparam('idle',idle)]))\n \n         # Explicitly commit regardless of the remaining logic. The database\n","add":1,"remove":1,"filename":"\/skeleton\/modules\/aaa\/views.py","badparts":["                    bindparam('sid', session['i']),"],"goodparts":["                    bindparam('sid', new_sess_id),"]},{"diff":"\n                     bindparam('email', form.email.data),\n                     bindparam('pw', shapass, type_=LargeBinary),\n                     bindparam('ip', remote_addr),\n-                    bindparam('sid', session['i']),\n+                    bindparam('sid', new_sess_id),\n                     bindparam('idle',idle)]))\n \n         # Explicitly commit regardless of the remaining logic. The database\n","add":1,"remove":1,"filename":"\/skeleton\/modules\/aaa\/views.py","badparts":["                    bindparam('sid', session['i']),"],"goodparts":["                    bindparam('sid', new_sess_id),"]}],"source":"\n\nimport base64, hashlib, M2Crypto from flask import current_app, flash, redirect, render_template, request, session, url_for from sqlalchemy.sql.expression import bindparam, text from sqlalchemy.types import LargeBinary from skeleton import db from aaa.forms import LoginForm, RegisterForm from aaa import module def gen_session_id(): \"\"\" Generates a session ID \"\"\" return base64.b32encode(M2Crypto.m2.rand_bytes(current_app.config['SESSION_BYTES'])) @module.route('\/login', methods=('GET','POST')) def login(): form=LoginForm() if not session.has_key('i'): session['i']=gen_session_id() if form.validate_on_submit(): remote_addr=request.environ['REMOTE_ADDR'] h=hashlib.new('sha256') h.update(current_app.config['PASSWORD_HASH']) h.update(form.password.data) shapass=h.digest() idle='1 second' if form.idle_ttl.data=='tmp': idle='20 minutes' elif form.idle_ttl.data=='day': idle='1 day' elif form.idle_ttl.data=='week': idle='1 week' else: flask.abort(500) ses=db.session result=ses.execute( text(\"SELECT ret, col, msg FROM aaa.login(:email,:pw,:ip,:sid,:idle) AS(ret BOOL, col TEXT, msg TEXT)\", bindparams=[ bindparam('email', form.email.data), bindparam('pw', shapass, type_=LargeBinary), bindparam('ip', remote_addr), bindparam('sid', session['i']), bindparam('idle',idle)])) ses.commit() row=result.first() if row[0]==True: session['li']=True flash('Successfully logged in as %s' %(form.email.data)) return redirect(url_for('home.index')) else: session.pop('li', None) try: field=form.__getattribute__(row[1]) if field.name=='vague': form.errors['EPERM']='There is no intro(2) error code for web errors' pass else: field.errors.append(row[2]) except AttributeError as e: pass return render_template('aaa\/login.html', form=form) @module.route('\/logout') def logout(): for k in session.keys(): session.pop(k) flash('You were logged out') return render_template('aaa\/logout.html') @module.route('\/register', methods=('GET','POST')) def register(): form=RegisterForm() if not session.has_key('i'): session['i']=gen_session_id() if form.validate_on_submit(): remote_addr=request.environ['REMOTE_ADDR'] h=hashlib.new('sha256') h.update(current_app.config['PASSWORD_HASH']) h.update(form.password.data) shapass=h.digest() ses=db.session result=ses.execute( text(\"SELECT ret, col, msg FROM aaa.register(:email,:pw,:ip) AS(ret BOOL, col TEXT, msg TEXT)\", bindparams=[ bindparam('email', form.email.data), bindparam('pw', shapass, type_=LargeBinary), bindparam('ip', remote_addr)])) row=result.first() if row[0]==True: ses.commit() flash('Thanks for registering! Please check your %s email account to confirm your email address.' %(form.email.data)) return redirect(url_for('aaa.login')) else: try: field=form.__getattribute__(row[1]) field.errors.append(row[2]) except AttributeError as e: pass return render_template('aaa\/register.html', form=form) ","sourceWithComments":"# -*- coding: utf-8 -*-\nimport base64, hashlib, M2Crypto\n\nfrom flask import current_app, flash, redirect, render_template, request, session, url_for\nfrom sqlalchemy.sql.expression import bindparam, text\nfrom sqlalchemy.types import LargeBinary\n\nfrom skeleton import db\nfrom aaa.forms import LoginForm, RegisterForm\nfrom aaa import module\n\ndef gen_session_id():\n    \"\"\" Generates a session ID \"\"\"\n    # Be kind to future support people and developers by using a base32\n    # encoded session id. Why is this cool? Read RFC3548 \u00a75 and rejoice\n    # at the lack of ambiguity regarding \"one\", \"ell\", \"zero\" and\n    # \"ohh\". You can thank me later.\n    return base64.b32encode(M2Crypto.m2.rand_bytes(current_app.config['SESSION_BYTES']))\n\n@module.route('\/login', methods=('GET','POST'))\ndef login():\n    form = LoginForm()\n    if not session.has_key('i'):\n        session['i'] = gen_session_id()\n\n    if form.validate_on_submit():\n        remote_addr = request.environ['REMOTE_ADDR']\n\n        # Hash the password once here:\n        h = hashlib.new('sha256')\n        h.update(current_app.config['PASSWORD_HASH'])\n        h.update(form.password.data)\n        shapass = h.digest()\n\n        # Change out the values of the session ttl\n        idle = '1 second'\n        if form.idle_ttl.data == 'tmp':\n            idle = '20 minutes'\n        elif form.idle_ttl.data == 'day':\n            idle = '1 day'\n        elif form.idle_ttl.data == 'week':\n            idle = '1 week'\n        else:\n            flask.abort(500)\n\n        ses = db.session\n        result = ses.execute(\n            # SELECT result, \"column\", message FROM aaa.login(email := 'user@example.com', password := '\\xbd\\x18\\xee\\x85\\x9f\\x19Bl\\x1e\\x9dE\\\\xdc\\x10\\xe2NH\\x1b\\x94\\xe5n\\x01C\\x98\\xe5AQ\\x05\\xb2\\xa7,\\x1co', ip_address := '11.22.33.44', session_id := 'user session id from flask', renewal_interval := '60 minutes'::INTERVAL) AS (result BOOL, \"column\" TEXT, message TEXT);\n            text(\"SELECT ret, col, msg FROM aaa.login(:email, :pw, :ip, :sid, :idle) AS (ret BOOL, col TEXT, msg TEXT)\",\n                 bindparams=[\n                    bindparam('email', form.email.data),\n                    bindparam('pw', shapass, type_=LargeBinary),\n                    bindparam('ip', remote_addr),\n                    bindparam('sid', session['i']),\n                    bindparam('idle',idle)]))\n\n        # Explicitly commit regardless of the remaining logic. The database\n        # did the right thing behind the closed doors of aaa.login() and we\n        # need to make sure that the logging to shadow.aaa_login_attempts is\n        # COMMIT'ed so that customer support can help the poor, frustrated\n        # (stupid?) users.\n        ses.commit()\n        row = result.first()\n        if row[0] == True:\n            session['li'] = True\n            flash('Successfully logged in as %s' % (form.email.data))\n            return redirect(url_for('home.index'))\n        else:\n            session.pop('li', None)\n            # Return a useful error message from the database\n            try:\n                # If the database says be vague, we'll be vague in our error\n                # messages. When the database commands it we obey, got it?\n                field = form.__getattribute__(row[1])\n                if field.name == 'vague':\n                    # Set bogus data so that 'form.errors == True'. If brute\n                    # force weren't such an issue, we'd just append a field\n                    # error like below. If you want to get the specifics of\n                    # why the database rejected a user, temporarily change\n                    # the above 'vague' to something that the database\n                    # doesn't return, such as 'EDRAT' or something equally\n                    # POSIXly funny.\n                    form.errors['EPERM'] = 'There is no intro(2) error code for web errors'\n                    pass\n                else:\n                    field.errors.append(row[2])\n            except AttributeError as e:\n                pass\n    return render_template('aaa\/login.html', form=form)\n\n\n@module.route('\/logout')\ndef logout():\n    # Nuke every key in the session\n    for k in session.keys():\n        session.pop(k)\n    flash('You were logged out')\n    return render_template('aaa\/logout.html')\n\n\n@module.route('\/register', methods=('GET','POST'))\ndef register():\n    form = RegisterForm()\n    if not session.has_key('i'):\n        session['i'] = gen_session_id()\n\n    if form.validate_on_submit():\n        # Form validates, execute the registration pl function\n\n        remote_addr = request.environ['REMOTE_ADDR']\n\n        # Hash the password once here:\n        h = hashlib.new('sha256')\n        h.update(current_app.config['PASSWORD_HASH'])\n        h.update(form.password.data)\n        shapass = h.digest()\n\n        ses = db.session\n        result = ses.execute(\n            text(\"SELECT ret, col, msg FROM aaa.register(:email, :pw, :ip) AS (ret BOOL, col TEXT, msg TEXT)\",\n                 bindparams=[\n                    bindparam('email', form.email.data),\n                    bindparam('pw', shapass, type_=LargeBinary),\n                    bindparam('ip', remote_addr)]))\n        row = result.first()\n        if row[0] == True:\n            ses.commit()\n            flash('Thanks for registering! Please check your %s email account to confirm your email address.' % (form.email.data))\n            return redirect(url_for('aaa.login'))\n        else:\n            # Return a useful error message from the database\n            try:\n                field = form.__getattribute__(row[1])\n                field.errors.append(row[2])\n            except AttributeError as e:\n                pass\n    return render_template('aaa\/register.html', form=form)\n"}},"msg":"aaa.login now generates a new session ID to prevent possible fixation attacks.\n\nSigned-off-by: Sean Chittenden <sean@chittenden.org>"}},"https:\/\/github.com\/wwoods\/lamegame_cherrypy_authority":{"6f3c2d3d9a272483aaee21a17c043a2d7eb5f106":{"url":"https:\/\/api.github.com\/repos\/wwoods\/lamegame_cherrypy_authority\/commits\/6f3c2d3d9a272483aaee21a17c043a2d7eb5f106","html_url":"https:\/\/github.com\/wwoods\/lamegame_cherrypy_authority\/commit\/6f3c2d3d9a272483aaee21a17c043a2d7eb5f106","message":"Reconfigured sessions a bit - by default, persist the session.  Create a new session id if the session specified in the client's cookie is expired.  Touch the new session to make it persistent.  When a login information is transmitted, change the session id to prevent some types of session fixation.","sha":"6f3c2d3d9a272483aaee21a17c043a2d7eb5f106","keyword":"session fixation prevent","diff":"diff --git a\/lg_authority\/authinterface.py b\/lg_authority\/authinterface.py\nindex 77e3396..4effa6a 100644\n--- a\/lg_authority\/authinterface.py\n+++ b\/lg_authority\/authinterface.py\n@@ -267,10 +267,16 @@ def login(self, username, admin=False):\n         record = self.user_get_record(username)\n         d = record.todict()\n         d['__name__'] = username\n-        cherrypy.session['auth'] = d\n-        cherrypy.session['authtime'] = datetime.datetime.utcnow()\n+        changeset = {\n+            'auth': d\n+            ,'authtime': datetime.datetime.utcnow()\n+            }\n         if admin:\n-            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()\n+            changeset['authtime_admin'] = datetime.datetime.utcnow()\n+\n+        #Guard against session fixation - see regen_id docstring\n+        cherrypy.session.regen_id()\n+        cherrypy.session.update(changeset)\n \n         self.serve_user_from_dict(d)\n         return record\ndiff --git a\/lg_authority\/common_config.py b\/lg_authority\/common_config.py\nindex 7157297..9c3ae02 100644\n--- a\/lg_authority\/common_config.py\n+++ b\/lg_authority\/common_config.py\n@@ -144,7 +144,7 @@ class ConfigDict(dict):\n         }\n     #Your public and private keys for recaptcha, or None to disable recaptcha\n     ,\n-    'site_debug': False\n+    'site_debug': True\n     #Print debug messages for lg_authority?  True\/False\n     ,\n     'override_sessions': True\ndiff --git a\/lg_authority\/slates\/__init__.py b\/lg_authority\/slates\/__init__.py\nindex 481658e..77eec76 100644\n--- a\/lg_authority\/slates\/__init__.py\n+++ b\/lg_authority\/slates\/__init__.py\n@@ -11,7 +11,7 @@\n import cherrypy\n from ..common import *\n from .slates import Slate\n-from .session import init_session\n+from .session import init_session, send_session_cookie\n \n #Seed global config with Slate variable\n config.Slate = Slate\ndiff --git a\/lg_authority\/slates\/session.py b\/lg_authority\/slates\/session.py\nindex da55783..781f9fb 100644\n--- a\/lg_authority\/slates\/session.py\n+++ b\/lg_authority\/slates\/session.py\n@@ -42,8 +42,16 @@ def __init__(self, id=None, **kwargs):\n             if ttl < self.timeout \/\/ 2 or ttl < self.timeout - 60*60:\n                 self.touch()\n                 self._update_cookie = True\n-\n-        #The response cookie is set in init_session(), at the bottom of this\n+        else:\n+            #This is a brand new session.  We should probably\n+            #touch it to prevent it from expiring.  We could just send a \n+            #new session ID on each request, like the default CherryPy \n+            #behavior, but for an application with AJAX login this \n+            #can cause very weird issues.\n+            self.touch()\n+            self._update_cookie = True\n+\n+        #The response cookie is set in send_session_cookie(), at the bottom of this\n         #file.\n \n     def is_response_cookie_needed(self):\n@@ -67,6 +75,21 @@ def expire(self):\n         cherrypy.serving.response.cookie[self.session_cookie] = 'expired'\n         cherrypy.serving.response.cookie[self.session_cookie]['expires'] = httputil.HTTPDate(e)\n \n+    def regen_id(self):\n+        \"\"\"Copies all of the data for this cookie, but regenerates\n+        it under a new identifier.  Some sources recommend changing \n+        session id on login, and that is what this does.  Essentially\n+        prevents an attacker from creating a blank, persistent session,\n+        getting a user to log in through whatever means, and then \n+        using the previously blank session as a logged in session of\n+        the victim.\n+        \"\"\"\n+        data = self.todict()\n+        Slate.expire(self)\n+        self._test_id()\n+        self.update(data)\n+        self._update_cookie = True\n+\n     def _test_id(self):\n         \"\"\"Test if we are expired.  If we are, assign a new id\"\"\"\n         #Force the session timeout to always update with the site's preferences.\n@@ -148,14 +171,29 @@ def init_session(\n     # the requested session data.\n     cherrypy.serving.session = sess = Session(id, **kwargs)\n     \n+def send_session_cookie(\n+    session_path=None\n+    , session_path_header=None\n+    , session_domain=None\n+    , session_secure=False\n+    , session_httponly=True\n+    , session_persistent=True\n+    , **kwargs\n+    ):\n+    \"\"\"Send the session cookie after the body in case the request\n+    regenerated the session id and it needs to be retransmitted.\n+    \"\"\"\n+    sess = cherrypy.serving.session\n     if sess.is_response_cookie_needed():\n+        session_cookie = kwargs.get('session_cookie', Session.session_cookie)\n+        cookie_timeout = kwargs.get('session_timeout', Session.timeout)\n         if not session_persistent:\n             # See http:\/\/support.microsoft.com\/kb\/223799\/EN-US\/\n             # and http:\/\/support.mozilla.com\/en-US\/kb\/Cookies\n             cookie_timeout = None\n         set_response_cookie(\n           path=session_path, path_header=session_path_header\n-          , name=name\n+          , name=session_cookie\n           , timeout=cookie_timeout\n           , domain=session_domain\n           , secure=session_secure\ndiff --git a\/lg_authority\/tools.py b\/lg_authority\/tools.py\nindex 7b76713..3edc279 100644\n--- a\/lg_authority\/tools.py\n+++ b\/lg_authority\/tools.py\n@@ -100,6 +100,7 @@ def _setup(self):\n                                      #priority, since we read the session.\n         if conf['override_sessions']:\n             hooks.attach('before_request_body', slates.init_session, priority=p-10, **conf)\n+            hooks.attach('before_finalize', slates.send_session_cookie, priority=p, **conf)\n         hooks.attach('before_request_body', self.check_auth, priority=p, **conf)\n \n     def _setup_initialize(self, conf):\n","files":{"\/lg_authority\/authinterface.py":{"changes":[{"diff":"\n         record = self.user_get_record(username)\n         d = record.todict()\n         d['__name__'] = username\n-        cherrypy.session['auth'] = d\n-        cherrypy.session['authtime'] = datetime.datetime.utcnow()\n+        changeset = {\n+            'auth': d\n+            ,'authtime': datetime.datetime.utcnow()\n+            }\n         if admin:\n-            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()\n+            changeset['authtime_admin'] = datetime.datetime.utcnow()\n+\n+        #Guard against session fixation - see regen_id docstring\n+        cherrypy.session.regen_id()\n+        cherrypy.session.update(changeset)\n \n         self.serve_user_from_dict(d)\n         return record","add":9,"remove":3,"filename":"\/lg_authority\/authinterface.py","badparts":["        cherrypy.session['auth'] = d","        cherrypy.session['authtime'] = datetime.datetime.utcnow()","            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()"],"goodparts":["        changeset = {","            'auth': d","            ,'authtime': datetime.datetime.utcnow()","            }","            changeset['authtime_admin'] = datetime.datetime.utcnow()","        cherrypy.session.regen_id()","        cherrypy.session.update(changeset)"]},{"diff":"\n         record = self.user_get_record(username)\n         d = record.todict()\n         d['__name__'] = username\n-        cherrypy.session['auth'] = d\n-        cherrypy.session['authtime'] = datetime.datetime.utcnow()\n+        changeset = {\n+            'auth': d\n+            ,'authtime': datetime.datetime.utcnow()\n+            }\n         if admin:\n-            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()\n+            changeset['authtime_admin'] = datetime.datetime.utcnow()\n+\n+        #Guard against session fixation - see regen_id docstring\n+        cherrypy.session.regen_id()\n+        cherrypy.session.update(changeset)\n \n         self.serve_user_from_dict(d)\n         return record","add":9,"remove":3,"filename":"\/lg_authority\/authinterface.py","badparts":["        cherrypy.session['auth'] = d","        cherrypy.session['authtime'] = datetime.datetime.utcnow()","            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()"],"goodparts":["        changeset = {","            'auth': d","            ,'authtime': datetime.datetime.utcnow()","            }","            changeset['authtime_admin'] = datetime.datetime.utcnow()","        cherrypy.session.regen_id()","        cherrypy.session.update(changeset)"]}],"source":"\nimport datetime from.common import * from. import passwords from.slates import Slate class UserObject: \"\"\"An object representing the current logged in user. Served as cherrypy.user. \"\"\" id=None id__doc=\"The username of the current user\" groups=[] groups__doc=\"List of groups to which the user belongs\" slate=None slate__doc=\"The user's slate for the current request\" def __init__(self, session_dict): self.id=session_dict['__name__'] self.groups=session_dict['groups'] self.slate=Slate( cherrypy.serving.lg_authority['user_slate_section'] ,self.id ) self.__slate__=config.auth.user_get_record(self.id) def __getitem__(self, key): return self.__slate__[key] def __setitem__(self, key, value): self.__slate__[key]=value def __delitem___(self, key): del self.__slate__[key] def get(self, key, default=None): return self.__slate__.get(key, default) def pop(self, key, default=None): \"\"\"Return D[key] and remove key from D, or default.\"\"\" return self.__slate__.pop(key, default) def update(self, d): \"\"\"D.update(E) -> None. Update D from E: for k in E: D[k]=E[k].\"\"\" self.__slate__.update(d) def setdefault(self, key, default=None): \"\"\"D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D.\"\"\" return self.__slate__.setdefault(key, default) def keys(self): return self.__slate__.keys() def values(self): return self.__slate__.values() def items(self): return self.__slate__.items() class AuthInterface(object): \"\"\"The interface for auth-specific functions with the storage backend. \"\"\" def user_name_invalid(self, username): \"\"\"Return a human-readable error if username is invalid or has invalid characters. \"\"\" if '\"' in username or \"'\" in username: return \"Name may not have quotes\" if '<' in username or '>' in username: return \"Name may not have > or <\" if ' ' in username: return \"Name may not have spaces\" if '@' in username: return \"Name may not contain the @ symbol\" if '\/' in username: return \"Name may not contain the \/ symbol\" return False def user_create(self, username, data, timeout=missing): \"\"\"Inserts a user or raises an *Error\"\"\" kwargs={ 'timeout': None} if timeout is not missing: kwargs={ 'timeout': timeout, 'force_timeout': True} user=Slate('user', 'user-' +username) if not user.is_expired(): raise AuthError('User already exists') user.update(data) def user_create_holder(self, username, data): \"\"\"Inserts a placeholder for the given username. Raises an AuthError if the username specified is already an existing user or placeholder user. \"\"\" kwargs={ 'timeout': None} if config['site_registration_timeout'] !=None: kwargs['timeout']=config['site_registration_timeout'] * 60 * 24 sname=Slate('user', 'user-' +username) if not sname.is_expired(): raise AuthError('Username already taken') pname=Slate('user', 'userhold-' +username, **kwargs) if not pname.is_expired(): raise AuthError('Username already taken') oname=Slate('user', 'userold-' +username) if not oname.is_expired(): raise AuthError('Username already taken') pname.update(data) def user_exists(self, username): userrec=Slate('user', 'user-' +username) userhold=Slate('user', 'userhold-' +username) userold=Slate('user', 'userold-' +username) if not userrec.is_expired(): return True if not userhold.is_expired(): return True if not userold.is_expired(): return True return False def user_get_holder(self, username): pname='userhold-' +username return Slate('user', pname) def user_promote_holder(self, holder): \"\"\"Promotes the passed holder slate to a full user\"\"\" uname='user-' +holder.id[len('userhold-'):] uargs={} for k,v in holder.items(): uargs[k]=v user=Slate('user', uname) if not user.is_expired(): raise AuthError('User already activated') user.update(uargs) holder.expire() def user_get_inactive(self, username): pname='userold-' +username return Slate('user', pname) def user_activate(self, username): pname='userold-' +username inact=Slate('user', pname) if inact.is_expired(): raise AuthError('Cannot activate non-inactive user') items=inact.todict() nname='user-' +username s=Slate('user', nname) s.update(items) inact.expire() def user_deactivate(self, username): oname='user-' +username act=Slate('user', oname) if act.is_expired(): raise AuthError('Cannot deactive non-active user') items=act.todict() nname='userold-' +username s=Slate('user', nname) s.update(items) act.expire() def user_get_record(self, username): \"\"\"Returns the record for the given username(or None). \"\"\" slate=Slate('user', 'user-' +username) return slate def get_user_from_email(self, email): \"\"\"Returns the username for the given email, or None. \"\"\" result=config.Slate.find_with('user', 'emails', email) if len(result)==1 and result[0].id.startswith('user-'): return result[0].id[len('user-'):] elif len(result)==1: raise AuthError('This e-mail is in use by an inactive user') elif len(result)==0: return None else: raise AuthError(\"More than one user has this e-mail!\") def get_user_from_openid(self, openid_url): \"\"\"Returns the username for the given openid_url, or None. \"\"\" result=config.Slate.find_with('user', 'auth_openid', openid_url) if len(result)==0: return None elif len(result)==1: if result[0].id.startswith('user-'): return result[0].id[len('user-'):] raise AuthError('This OpenID is in use by an inactive user') else: raise AuthError('This OpenID is in use') def get_user_password(self, username): \"\"\"Returns a dict consisting of a \"date\" element that is the UTC time when the password was set, and a \"pass\" element that is the tuple\/list(type, hashed_pass) for the given username. Returns None if the user specified does not have a password to authenticate through or does not exist. \"\"\" user=Slate('user', 'user-' +username) if user.is_expired(): return None return user.get('auth_password', None) def set_user_password(self, username, new_pass): \"\"\"Updates the given user's password. new_pass is a tuple (algorithm, hashed) that is the user's new password. \"\"\" user=Slate('user', 'user-' +username) if user.is_expired(): raise ValueError('User not found') user['auth_password']={ 'date': datetime.datetime.utcnow(), 'pass': new_pass} cherrypy.session.pop('authtime_admin') def _get_group_name(self, groupid): \"\"\"Retrieves the name for the given groupid. This is subclassed as _get_group_name because get_group_name automatically handles user-, any, and auth groups \"\"\" group=Slate('user', 'group-' +groupid) if not group.is_expired(): return group['name'] return 'Unnamed({0})'.format(groupid) def group_create(self, groupid, data, timeout=missing): \"\"\"Insert the specified group, or raise an *Error\"\"\" kwargs={ 'timeout': None} if timeout is not missing: kwargs={ 'timeout': timeout, 'force_timeout': True} sname=Slate('user', 'group-' +groupid, **kwargs) if not sname.is_expired(): raise AuthError('Group already exists') sname.update(data) def login(self, username, admin=False): \"\"\"Logs in the specified username. Returns the user record.\"\"\" record=self.user_get_record(username) d=record.todict() d['__name__']=username cherrypy.session['auth']=d cherrypy.session['authtime']=datetime.datetime.utcnow() if admin: cherrypy.session['authtime_admin']=datetime.datetime.utcnow() self.serve_user_from_dict(d) return record def login_time_elapsed(self): \"\"\"Gets the t=datetime.datetime.utcnow() -cherrypy.session['authtime'] return t.days * 24 * 60 * 60 +t.seconds def login_is_admin(self): \"\"\"Returns True if the current login is allowed to make administrative changes to the account, or False otherwise. \"\"\" authtime_admin=cherrypy.session.get('authtime_admin') if authtime_admin is None: return False t=datetime.datetime.utcnow() -authtime_admin if t.days * 24 * 60 * 60 +t.seconds < config['site_admin_login_window']: return True return False def serve_user_from_dict(self, d): \"\"\"Sets cherrypy.serving.user based on the passed auth dict. d may be None. \"\"\" if d is not None: cherrypy.serving.user=UserObject(d) else: cherrypy.serving.user=None def logout(self): \"\"\"Log out the current logged in user.\"\"\" if hasattr(cherrypy.session, 'expire'): cherrypy.session.expire() else: cherrypy.lib.sessions.expire() def old_password(self, username): renew=config['site_password_renewal'] if renew is None: return passw=self.get_user_password(username) if passw is None: return False if(datetime.datetime.utcnow() -passw['date']).days >=renew: return True return False def test_password(self, username, password): \"Returns username for OK, None for failed auth\" if '@' in username: username=self.get_user_from_email(username) if username is None: return None expected=self.get_user_password(username) if expected is None: return None if passwords.verify(password, expected['pass']): return username return None def get_group_name(self, groupid): \"\"\"Returns the common name for the given groupid. groupid may be the special identifiers 'any', 'auth', or 'user-' as well. \"\"\" if groupid=='any': return 'Everyone' elif groupid=='auth': return 'Logged In Users' elif groupid.startswith('user-'): return 'User -' +groupid[5:] return self._get_group_name(groupid) ","sourceWithComments":"import datetime\n\nfrom .common import *\nfrom . import passwords\nfrom .slates import Slate\n\nclass UserObject:\n    \"\"\"An object representing the current logged in user.\n    Served as cherrypy.user.\n    \"\"\"\n\n    id = None\n    id__doc = \"The username of the current user\"\n\n    groups = []\n    groups__doc = \"List of groups to which the user belongs\"\n\n    slate = None\n    slate__doc = \"The user's slate for the current request\"\n\n    def __init__(self, session_dict):\n        self.id = session_dict['__name__']\n        self.groups = session_dict['groups']\n        self.slate = Slate(\n            cherrypy.serving.lg_authority['user_slate_section']\n            ,self.id\n            )\n\n        #If they're logged in, they'd better be active.\n        self.__slate__ = config.auth.user_get_record(self.id)\n\n    def __getitem__(self, key):\n        return self.__slate__[key]\n\n    def __setitem__(self, key, value):\n        self.__slate__[key] = value\n\n    def __delitem___(self, key):\n        del self.__slate__[key]\n\n    def get(self, key, default=None):\n        return self.__slate__.get(key, default)\n\n    def pop(self, key, default=None):\n        \"\"\"Return D[key] and remove key from D, or default.\"\"\"\n        return self.__slate__.pop(key, default)\n\n    def update(self, d):\n        \"\"\"D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k].\"\"\"\n        self.__slate__.update(d)\n\n    def setdefault(self, key, default=None):\n        \"\"\"D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D.\"\"\"\n        return self.__slate__.setdefault(key, default)\n\n    #We don't want to expose clear()..\n\n    def keys(self):\n        return self.__slate__.keys()\n\n    def values(self):\n        return self.__slate__.values()\n\n    def items(self):\n        return self.__slate__.items()\n\nclass AuthInterface(object):\n    \"\"\"The interface for auth-specific functions with the storage backend.\n    \"\"\"\n\n    def user_name_invalid(self, username):\n        \"\"\"Return a human-readable error if username is invalid or\n        has invalid characters.\n        \"\"\"\n        if '\"' in username or \"'\" in username:\n            return \"Name may not have quotes\"\n        if '<' in username or '>' in username:\n            return \"Name may not have > or <\"\n        if ' ' in username:\n            return \"Name may not have spaces\"\n        if '@' in username:\n            return \"Name may not contain the @ symbol\"\n        if '\/' in username:\n            return \"Name may not contain the \/ symbol\"\n        return False\n\n    def user_create(self, username, data, timeout=missing):\n        \"\"\"Inserts a user or raises an *Error\"\"\"\n        kwargs = { 'timeout': None }\n        if timeout is not missing:\n            kwargs = { 'timeout': timeout, 'force_timeout': True }\n\n        user = Slate('user', 'user-' + username)\n        if not user.is_expired():\n            raise AuthError('User already exists')\n\n        user.update(data)\n       \n    def user_create_holder(self, username, data):\n        \"\"\"Inserts a placeholder for the given username.  Raises an AuthError\n        if the username specified is already an existing user or placeholder\n        user.\n        \"\"\"\n        kwargs = { 'timeout': None }\n        if config['site_registration_timeout'] != None:\n            kwargs['timeout'] = config['site_registration_timeout'] * 60 * 24\n            \n        sname = Slate('user', 'user-' + username)\n        if not sname.is_expired():\n            raise AuthError('Username already taken')\n            \n        pname = Slate('user', 'userhold-' + username, **kwargs)\n        if not pname.is_expired():\n            raise AuthError('Username already taken')\n\n        oname = Slate('user', 'userold-' + username)\n        if not oname.is_expired():\n            raise AuthError('Username already taken')\n            \n        #Make the holder\n        pname.update(data)\n\n    def user_exists(self, username):\n        userrec = Slate('user', 'user-' + username)\n        userhold = Slate('user', 'userhold-' + username)\n        userold = Slate('user', 'userold-' + username)\n\n        if not userrec.is_expired():\n            return True\n        if not userhold.is_expired():\n            return True\n        if not userold.is_expired():\n            return True\n        return False\n\n    def user_get_holder(self, username):\n        pname = 'userhold-' + username\n        return Slate('user', pname)\n\n    def user_promote_holder(self, holder):\n        \"\"\"Promotes the passed holder slate to a full user\"\"\"\n        uname = 'user-' + holder.id[len('userhold-'):]\n        uargs = {}\n        for k,v in holder.items():\n            uargs[k] = v\n\n        user = Slate('user', uname)\n        if not user.is_expired():\n            raise AuthError('User already activated')\n\n        user.update(uargs)\n        holder.expire()\n\n    def user_get_inactive(self, username):\n        pname = 'userold-' + username\n        return Slate('user', pname)\n\n    def user_activate(self, username):\n        pname = 'userold-' + username\n        inact = Slate('user', pname)\n        if inact.is_expired():\n            raise AuthError('Cannot activate non-inactive user')\n\n        items = inact.todict()\n        nname = 'user-' + username\n        s = Slate('user', nname)\n        s.update(items)\n\n        #Do this last to keep the user's data in case of unexpected error.\n        inact.expire()\n\n    def user_deactivate(self, username):\n        oname = 'user-' + username\n        act = Slate('user', oname)\n        if act.is_expired():\n            raise AuthError('Cannot deactive non-active user')\n\n        items = act.todict()\n        nname = 'userold-' + username\n        s = Slate('user', nname)\n        s.update(items)\n\n        #Do this last to keep user's data in case of unexpected error\n        act.expire()\n\n    def user_get_record(self, username):\n        \"\"\"Returns the record for the given username (or None).\n        \"\"\"\n        slate = Slate('user', 'user-' + username)\n        return slate\n\n    def get_user_from_email(self, email):\n        \"\"\"Returns the username for the given email, or None.\n        \"\"\"\n        result = config.Slate.find_with('user', 'emails', email)\n        if len(result) == 1 and result[0].id.startswith('user-'):\n            return result[0].id[len('user-'):]\n        elif len(result) == 1: #Inactive user\n            raise AuthError('This e-mail is in use by an inactive user')\n        elif len(result) == 0:\n            return None\n        else:\n            raise AuthError(\"More than one user has this e-mail!\")\n\n    def get_user_from_openid(self, openid_url):\n        \"\"\"Returns the username for the given openid_url, or None.\n        \"\"\"\n        result = config.Slate.find_with('user', 'auth_openid', openid_url)\n        if len(result) == 0:\n            return None\n        elif len(result) == 1:\n            if result[0].id.startswith('user-'):\n                return result[0].id[len('user-'):]\n            #Probably a disabled account or holder\n            raise AuthError('This OpenID is in use by an inactive user')\n        else:\n            raise AuthError('This OpenID is in use')\n\n    def get_user_password(self, username):\n        \"\"\"Returns a dict consisting of a \"date\" element that is the UTC time\n        when the password was set, and a \"pass\" element that is the\n        tuple\/list (type, hashed_pass) for the given username.\n        Returns None if the user specified does not have a password to\n        authenticate through or does not exist.\n        \"\"\"\n        user = Slate('user', 'user-' + username)\n        if user.is_expired():\n            return None\n        return user.get('auth_password', None)\n\n    def set_user_password(self, username, new_pass):\n        \"\"\"Updates the given user's password.  new_pass is a tuple\n        (algorithm, hashed) that is the user's new password.\n        \"\"\"\n        user = Slate('user', 'user-' + username)\n        if user.is_expired():\n            raise ValueError('User not found')\n        user['auth_password'] = { 'date': datetime.datetime.utcnow(), 'pass': new_pass }\n\n        #Clear any admin login flag\n        cherrypy.session.pop('authtime_admin')\n\n    def _get_group_name(self, groupid):\n        \"\"\"Retrieves the name for the given groupid.  This is subclassed as\n        _get_group_name because get_group_name automatically handles user-,\n        any, and auth groups\n        \"\"\"\n        group = Slate('user', 'group-' + groupid)\n        if not group.is_expired():\n            return group['name']\n        return 'Unnamed ({0})'.format(groupid)\n\n    def group_create(self, groupid, data, timeout=missing):\n        \"\"\"Insert the specified group, or raise an *Error\"\"\"\n        kwargs = { 'timeout': None }\n        if timeout is not missing:\n            kwargs = { 'timeout': timeout, 'force_timeout': True }\n\n        sname = Slate('user', 'group-' + groupid, **kwargs)\n        if not sname.is_expired():\n            raise AuthError('Group already exists')\n\n        sname.update(data)\n\n    def login(self, username, admin=False):\n        \"\"\"Logs in the specified username.  Returns the user record.\"\"\"\n        record = self.user_get_record(username)\n        d = record.todict()\n        d['__name__'] = username\n        cherrypy.session['auth'] = d\n        cherrypy.session['authtime'] = datetime.datetime.utcnow()\n        if admin:\n            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()\n\n        self.serve_user_from_dict(d)\n        return record\n\n    def login_time_elapsed(self):\n        \"\"\"Gets the # of seconds elapsed since the last login.\"\"\"\n        t = datetime.datetime.utcnow() - cherrypy.session['authtime']\n        return t.days * 24 * 60 * 60 + t.seconds\n\n    def login_is_admin(self):\n        \"\"\"Returns True if the current login is allowed to make administrative\n        changes to the account, or False otherwise.\n        \"\"\"\n        authtime_admin = cherrypy.session.get('authtime_admin')\n        if authtime_admin is None:\n            return False\n        t = datetime.datetime.utcnow() - authtime_admin\n        if t.days * 24 * 60 * 60 + t.seconds < config['site_admin_login_window']:\n            return True\n        return False\n\n    def serve_user_from_dict(self, d):\n        \"\"\"Sets cherrypy.serving.user based on the passed auth dict.\n        d may be None.\n        \"\"\"\n        if d is not None:\n            cherrypy.serving.user = UserObject(d)\n        else:\n            cherrypy.serving.user = None\n\n    def logout(self):\n        \"\"\"Log out the current logged in user.\"\"\"\n        if hasattr(cherrypy.session, 'expire'):\n            cherrypy.session.expire()\n        else:\n            cherrypy.lib.sessions.expire()\n\n    def old_password(self, username):\n        renew = config['site_password_renewal']\n        if renew is None:\n            return\n        passw = self.get_user_password(username)\n        if passw is None:\n            #No password, they don't need to renew probably!\n            return False\n        if (datetime.datetime.utcnow() - passw['date']).days >= renew:\n            return True\n        return False\n\n    def test_password(self, username, password):\n        \"Returns username for OK, None for failed auth\"\n        if '@' in username:\n            #Map e-mail to user\n            username = self.get_user_from_email(username)\n            if username is None:\n                return None\n        expected = self.get_user_password(username)\n        if expected is None:\n            return None\n\n        if passwords.verify(password, expected['pass']):\n            return username\n        return None\n\n    def get_group_name(self, groupid):\n        \"\"\"Returns the common name for the given groupid.\n        groupid may be the special identifiers 'any', 'auth', or 'user-'\n        as well.\n        \"\"\"\n\n        if groupid == 'any':\n            return 'Everyone'\n        elif groupid == 'auth':\n            return 'Logged In Users'\n        elif groupid.startswith('user-'):\n            return 'User - ' + groupid[5:]\n        return self._get_group_name(groupid)\n\n"},"\/lg_authority\/common_config.py":{"changes":[{"diff":"\n         }\n     #Your public and private keys for recaptcha, or None to disable recaptcha\n     ,\n-    'site_debug': False\n+    'site_debug': True\n     #Print debug messages for lg_authority?  True\/False\n     ,\n     'override_sessions': Tru","add":1,"remove":1,"filename":"\/lg_authority\/common_config.py","badparts":["    'site_debug': False"],"goodparts":["    'site_debug': True"]},{"diff":"\n         }\n     #Your public and private keys for recaptcha, or None to disable recaptcha\n     ,\n-    'site_debug': False\n+    'site_debug': True\n     #Print debug messages for lg_authority?  True\/False\n     ,\n     'override_sessions': Tru","add":1,"remove":1,"filename":"\/lg_authority\/common_config.py","badparts":["    'site_debug': False"],"goodparts":["    'site_debug': True"]}],"source":"\n\"\"\"A few functions needed for the defaults, followed by a large dict of all of the available configuration options for lg_authority. \"\"\" import re import datetime import cherrypy def get_site_name(): \"\"\"Returns the site domain for the current cherrypy request.\"\"\" name_match=get_site_name.namere.match(cherrypy.request.base) return name_match.group(1) get_site_name.namere=re.compile('^[^:]+:\/\/([^\/:]*)') def email_reg_default_subject(username): return \"\"\"{site} -Registration\"\"\".format(site=get_site_name()) def email_reg_default_body(username): return \"\"\"You have requested registration as{user} at{site}.\"\"\".format( user=username ,site=get_site_name() ) class ConfigDict(dict): \"\"\"Holds all configuration items. Its own class so that it may hold flags as well. \"\"\" config=ConfigDict() config.update({ 'site_auth_root': '\/auth\/' , 'site_key': 'abc123o2qh3otin;oiH , 'site_password_renewal': 365 , 'site_admin_login_window': 120 , 'site_storage': 'ram' , 'site_storage_conf':{ } , 'site_storage_sections_user':{ 'index_lists': [ 'auth_openid', 'groups', 'emails'] } , 'site_storage_sections_session':{ 'cache':[ 'auth', 'authtime', 'authtime_admin'] } , 'site_storage_clean_freq': 60 , 'site_email':{ 'smtpserver': '127.0.0.1' ,'smtpport': 25 ,'smtpssl': False ,'smtpuser': None ,'smtppass': None ,'default': 'Site <test@example.com>' } , 'site_template': None , 'site_user_list':{ 'admin':{ 'auth_password':{ 'date': datetime.datetime.utcnow(), 'pass':[ 'sha256',['bff74028f285748241375d1c9c7f9b6e85fd3900edf8e601a78f7f84d848b42e', 'admin']]} ,'auth_openid':[] ,'groups':[ 'admin'] } } , 'site_group_list':{ 'admin':{ 'name': 'Administrators'} } , 'site_registration': 'email' , 'site_registration_conf':{ 'subject': email_reg_default_subject ,'body': email_reg_default_body } , 'site_registration_timeout': 2 , 'site_registration_recaptcha':{ 'public': None ,'private': None } , 'site_debug': False , 'override_sessions': True , 'session_timeout': 60 , 'session_cookie': 'session_id' , 'user_slate_section': 'userslate' , 'groups':[ 'any'] , 'user_home_page': '..' , 'logout_page': '..' , 'deny_page_anon': '\/auth\/login' , 'deny_page_auth': None }) ","sourceWithComments":"\"\"\"A few functions needed for the defaults, followed by a large dict\nof all of the available configuration options for lg_authority.\n\"\"\"\n\nimport re\nimport datetime\nimport cherrypy\n\ndef get_site_name():\n    \"\"\"Returns the site domain for the current cherrypy request.\"\"\"\n    name_match = get_site_name.namere.match(cherrypy.request.base)\n    return name_match.group(1)\nget_site_name.namere = re.compile('^[^:]+:\/\/([^\/:]*)')\n\ndef email_reg_default_subject(username):\n    return \"\"\"{site} - Registration\"\"\".format(site=get_site_name())\n\ndef email_reg_default_body(username):\n    return \"\"\"You have requested registration as {user} at {site}.\"\"\".format(\n        user=username\n        ,site=get_site_name()\n        )\n\n#config.Slate is set by slates\n\nclass ConfigDict(dict):\n    \"\"\"Holds all configuration items.  Its own class so that\n    it may hold flags as well.\n    \"\"\"\n\nconfig = ConfigDict()\n#Set defaults, show params.  These are overwritten first \n#by any config in the tools.lg_authority or lg_authority aliased section, then\n#by CherryPy config.\n#Any key prefixed with site_ is meant to be site-wide, and will be written\n#to this dict on the first request (NO MATTER WHERE THE REQUEST IS TO).\nconfig.update({\n    'site_auth_root': '\/auth\/'\n    #The absolute path to the site's auth root, with ending slash.\n    ,\n    'site_key': 'abc123o2qh3otin;oiH#*@(TY(#*Th:T*:(@#HTntb982#HN(:@#*TBH:@#(*THioihI#HOIH%oihio3@H%IOH#@%I)(!*@Y%+(+!@H%~`un23gkh'\n    #Site encryption key for passwords.  Should be more than 60 chars.\n    ,\n    'site_password_renewal': 365\n    #Days until users receive warnings that their passwords are old when they\n    #log in.  Use None for no warning.  Only users with passwords (not openid\n    #users) will be prompted.\n    ,\n    'site_admin_login_window': 120\n    #Seconds after reauthentication that the administrative window closes.\n    #Used for things like changing the user's password or adding a new \n    #e-mail address.\n    ,\n    'site_storage': 'ram'\n    #The storage backend for the auth framework.  Essentially, we use \n    #a namespaced key-value store with expiration times on the namespaces for\n    #our general framework storage.\n    ,\n    'site_storage_conf': {\n        }\n    #Configuration options for the specified site storage.\n    ,\n    'site_storage_sections_user': {\n        'index_lists':  [ 'auth_openid', 'groups', 'emails' ]\n        }\n    #Configuration items for various sections of slates.\n    #Just replace \"_user\" with \"_{section name}\" to set up config.\n    #Most sections do not need any options, but if you want anything\n    #indexed, or admin-editable, then this is where you specify it.\n    ,\n    'site_storage_sections_session': {\n        'cache': [ 'auth', 'authtime', 'authtime_admin' ]\n        }\n    #Session vars to be cached at first read.\n    ,\n    'site_storage_clean_freq': 60\n    #Minutes between cleaning up expired site storage.\n    ,\n    'site_email': {\n        'smtpserver': '127.0.0.1'\n        ,'smtpport': 25\n        ,'smtpssl': False\n        ,'smtpuser': None\n        ,'smtppass': None\n        ,'default': 'Site <test@example.com>'\n        }\n    #Not *strictly* required (set to None for no email), but enables\n    #functionality like e-mail registration and forgot password resets via\n    #email.\n    ,\n    'site_template': None#default_template\n    #The template used to render the authroot forms.  If this is a function,\n    #it will be called with the internal HTML for that particular form as\n    #an argument.  If this is a two-member array, then the form content\n    #is placed firmly in the middle.\n    ,\n    'site_user_list': {\n        'admin': {\n            'auth_password': { 'date': datetime.datetime.utcnow(), 'pass': [ 'sha256', ['bff74028f285748241375d1c9c7f9b6e85fd3900edf8e601a78f7f84d848b42e', 'admin'] ] }\n            ,'auth_openid': []\n            ,'groups': [ 'admin' ]\n            }\n        }\n    #User records to create if they do not already exist\n    ,\n    'site_group_list': {\n        'admin': { 'name': 'Administrators' }\n        }\n    #Group records to create if they do not already exist.  \n    #any, auth, and user- groups are automatic.\n    ,\n    'site_registration': 'email'\n    #The required USER-SIDE registration mechanism.  All registration mechanisms use\n    #recaptcha if it is installed.\n    #Accepted values are:\n    #open - Anyone passing recaptcha may make a valid account, no confirmation\n    #    is necessary.\n    #email - Email based registration (optionally w\/ recaptcha).  \n    #    See site_email_ settings.\n    #admin - A user will define their account (optionally with recaptcha), but \n    #    an admin must sign off on it.\n    #None - Users will be redirected to the login page if their openID\n    #    fails, and the New Account link will be replaced with text asking\n    #    users who feel they should have permission to contact the \n    #    administrator.\n    ,\n    'site_registration_conf': {\n        'subject': email_reg_default_subject\n        ,'body': email_reg_default_body\n        #,'from': 'Site Registration <test@example.com>' Optional; if not\n        #specified, will use the site_email's 'default' parameter\n        }\n    #Config items for the specific \n    ,\n    'site_registration_timeout': 2\n    #The number of days between which a registration request is placed and \n    #expires.  For open or None, this is irrelevant.  For email, it refers to\n    #the time window that the user has to receive the activation email and\n    #activate their account.  For admin, this value IS NOT USED.\n    ,\n    'site_registration_recaptcha': {\n        'public': None\n        ,'private': None\n        }\n    #Your public and private keys for recaptcha, or None to disable recaptcha\n    ,\n    'site_debug': False\n    #Print debug messages for lg_authority?  True\/False\n    ,\n    'override_sessions': True\n    #Use Slates instead of sessions.  This defaults to True, but you might\n    #want to set it to false if you typically set properties in \n    #cherrypy.session WITHOUT setting them directly (e.g. \n    #a = MyClass();\n    #cherrypy.session['var'] = a\n    #a.data = 6 #THIS WILL NOT BE SAVED WITH SITE_OVERRIDE_SESSIONS AS TRUE\n    #\n    #If you use an app that does this, feel free to set its specific \n    #configuration to override_sessions: False\n    ,\n    'session_timeout': 60\n    #Minutes until a session expires; applicable only if override_sessions is\n    #True.\n    ,\n    'session_cookie': 'session_id'\n    #The cookie value used to read the session id.  Applicable only if \n    #override_sessions is True.\n    ,\n    'user_slate_section': 'userslate'\n    #The prefix for named slates for each user (only applicable when using\n    #lamegame_cherrypy_slates).  Can be overridden at different paths to \n    #\"isolate\" user storage.  Don't use any of the existing ones.\n    ,\n    'groups': [ 'any' ]\n    #Static groups allowed to access the resource.  If the FIRST ELEMENT\n    #of the array is 'all:', then the user must be in EVERY group specified\n    #to gain access.  Otherwise, if the user matches a single group, they\n    #will be allowed access.  This convention is ugly, but prevents errors\n    #when a site might wish to use both AND and OR group configurations\n    #in the same environment.\n    #\n    #Special groups:\n    #'any' means everyone, even unauthenticated users\n    #'auth' means all authenticated users\n    #'user-' + username means specifically (and only) username\n    ,\n    'user_home_page': '..'\n    #The page to redirect to (if relative, then from AuthRoot\/OneLevel\/)\n    #on successful authentication when a redirect action was not requested.\n    #May be a function that returns a URL; that function may use cherrypy.user\n    #to determine the user's identity.\n    ,\n    'logout_page': '..'\n    #Page to redirect to on logout.  Use None to show a standard auth\n    #page confirming the logout.\n    ,\n    'deny_page_anon': '\/auth\/login'\n    #Page that unauthorized users are sent to when trying to access a\n    #resource they cannot retrieve AND are not authenticated.  \n    #Use None for a standard \"Access Denied\" page.\n    #\n    #If the path starts with '\/auth\/', then site_auth_root will be substituted.\n    #\n    #deny_page_anon may be pointed to a login page.\n    ,\n    'deny_page_auth': None\n    #Page that unauthorized users are sent to when trying to access a\n    #resource they cannot retrieve AND are already authenticated.\n    #Use None for a standard \"Access Denied\" page.\n    })\n\n"},"\/lg_authority\/slates\/__init__.py":{"changes":[{"diff":"\n import cherrypy\n from ..common import *\n from .slates import Slate\n-from .session import init_session\n+from .session import init_session, send_session_cookie\n \n #Seed global config with Slate variable\n config.Slate = Sla","add":1,"remove":1,"filename":"\/lg_authority\/slates\/__init__.py","badparts":["from .session import init_session"],"goodparts":["from .session import init_session, send_session_cookie"]},{"diff":"\n import cherrypy\n from ..common import *\n from .slates import Slate\n-from .session import init_session\n+from .session import init_session, send_session_cookie\n \n #Seed global config with Slate variable\n config.Slate = Sla","add":1,"remove":1,"filename":"\/lg_authority\/slates\/__init__.py","badparts":["from .session import init_session"],"goodparts":["from .session import init_session, send_session_cookie"]}],"source":"\n\"\"\"LameGame Productions' cherrypy slates tool. Usage: Put tools.lg_slates.on=True in the[global] section in your config file to enable this tool. tools.lg_slates.storage_type may be specified to change the storage medium(defaults to 'ram' for RamStorage) \"\"\" __all__=[ 'Slate', 'init_session'] __author__='Walt Woods' import cherrypy from..common import * from.slates import Slate from.session import init_session config.Slate=Slate ","sourceWithComments":"\"\"\"LameGame Productions' cherrypy slates tool.\n\nUsage: Put tools.lg_slates.on = True in the [global] section in your config file to enable this tool.\n\ntools.lg_slates.storage_type may be specified to change the storage medium (defaults to 'ram' for RamStorage)\n\"\"\"\n\n__all__ = [ 'Slate', 'init_session' ]\n__author__ = 'Walt Woods'\n\nimport cherrypy\nfrom ..common import *\nfrom .slates import Slate\nfrom .session import init_session\n\n#Seed global config with Slate variable\nconfig.Slate = Slate\n\n"},"\/lg_authority\/slates\/session.py":{"changes":[{"diff":"\n     # the requested session data.\n     cherrypy.serving.session = sess = Session(id, **kwargs)\n     \n+def send_session_cookie(\n+    session_path=None\n+    , session_path_header=None\n+    , session_domain=None\n+    , session_secure=False\n+    , session_httponly=True\n+    , session_persistent=True\n+    , **kwargs\n+    ):\n+    \"\"\"Send the session cookie after the body in case the request\n+    regenerated the session id and it needs to be retransmitted.\n+    \"\"\"\n+    sess = cherrypy.serving.session\n     if sess.is_response_cookie_needed():\n+        session_cookie = kwargs.get('session_cookie', Session.session_cookie)\n+        cookie_timeout = kwargs.get('session_timeout', Session.timeout)\n         if not session_persistent:\n             # See http:\/\/support.microsoft.com\/kb\/223799\/EN-US\/\n             # and http:\/\/support.mozilla.com\/en-US\/kb\/Cookies\n             cookie_timeout = None\n         set_response_cookie(\n           path=session_path, path_header=session_path_header\n-          , name=name\n+          , name=session_cookie\n           , timeout=cookie_timeout\n           , domain=session_domain\n           , secure=session_sec","add":16,"remove":1,"filename":"\/lg_authority\/slates\/session.py","badparts":["          , name=name"],"goodparts":["def send_session_cookie(","    session_path=None","    , session_path_header=None","    , session_domain=None","    , session_secure=False","    , session_httponly=True","    , session_persistent=True","    , **kwargs","    ):","    \"\"\"Send the session cookie after the body in case the request","    regenerated the session id and it needs to be retransmitted.","    \"\"\"","    sess = cherrypy.serving.session","        session_cookie = kwargs.get('session_cookie', Session.session_cookie)","        cookie_timeout = kwargs.get('session_timeout', Session.timeout)","          , name=session_cookie"]},{"diff":"\n     # the requested session data.\n     cherrypy.serving.session = sess = Session(id, **kwargs)\n     \n+def send_session_cookie(\n+    session_path=None\n+    , session_path_header=None\n+    , session_domain=None\n+    , session_secure=False\n+    , session_httponly=True\n+    , session_persistent=True\n+    , **kwargs\n+    ):\n+    \"\"\"Send the session cookie after the body in case the request\n+    regenerated the session id and it needs to be retransmitted.\n+    \"\"\"\n+    sess = cherrypy.serving.session\n     if sess.is_response_cookie_needed():\n+        session_cookie = kwargs.get('session_cookie', Session.session_cookie)\n+        cookie_timeout = kwargs.get('session_timeout', Session.timeout)\n         if not session_persistent:\n             # See http:\/\/support.microsoft.com\/kb\/223799\/EN-US\/\n             # and http:\/\/support.mozilla.com\/en-US\/kb\/Cookies\n             cookie_timeout = None\n         set_response_cookie(\n           path=session_path, path_header=session_path_header\n-          , name=name\n+          , name=session_cookie\n           , timeout=cookie_timeout\n           , domain=session_domain\n           , secure=session_sec","add":16,"remove":1,"filename":"\/lg_authority\/slates\/session.py","badparts":["          , name=name"],"goodparts":["def send_session_cookie(","    session_path=None","    , session_path_header=None","    , session_domain=None","    , session_secure=False","    , session_httponly=True","    , session_persistent=True","    , **kwargs","    ):","    \"\"\"Send the session cookie after the body in case the request","    regenerated the session id and it needs to be retransmitted.","    \"\"\"","    sess = cherrypy.serving.session","        session_cookie = kwargs.get('session_cookie', Session.session_cookie)","        cookie_timeout = kwargs.get('session_timeout', Session.timeout)","          , name=session_cookie"]}],"source":"\n\"\"\"The session functionality of lg_authority\/slates. \"\"\" import os import datetime import time import binascii from cherrypy.lib import httputil import cherrypy from..common import * from.slates import Slate class Session(Slate): \"\"\"A container that maps session ID's to an underlying slate.\"\"\" session_cookie='session_id' session_cookie__doc=\"\"\"Name of cookie where session id is stored\"\"\" timeout=60 timeout__doc=\"\"\"Timeout(in minutes) until session expiration\"\"\" originalid=None originalid__doc=\"\"\"Client-sent identifier for the session slate\"\"\" def __init__(self, id=None, **kwargs): self.timeout=kwargs.pop('session_timeout', Session.timeout) * 60 self.session_cookie=kwargs.get('session_cookie', self.session_cookie) self.originalid=id self.id=id self._test_id() if not self.is_expired(): ttl=self.time_to_expire() if ttl < self.timeout \/\/ 2 or ttl < self.timeout -60*60: self.touch() self._update_cookie=True def is_response_cookie_needed(self): return True if self.id !=self.originalid: return True if hasattr(self, '_update_cookie'): return True return False def expire(self): \"\"\"Expires the session both client-side and slate-side\"\"\" Slate.expire(self) one_year=60 * 60 * 24 * 365 e=time.time() -one_year cherrypy.serving.response.cookie[self.session_cookie]='expired' cherrypy.serving.response.cookie[self.session_cookie]['expires']=httputil.HTTPDate(e) def _test_id(self): \"\"\"Test if we are expired. If we are, assign a new id\"\"\" new_timeout=self.timeout Slate.__init__( self , 'session' , self.id , timeout=new_timeout , force_timeout=True ) if self.is_expired(): while True: self.id=self._generate_id() Slate.__init__(self, 'session', self.id, timeout=new_timeout) if self.is_expired(): break log('Session{0} expired ->{1}'.format(self.originalid, self.id)) def _generate_id(self): \"\"\"Return a new session id.\"\"\" return binascii.hexlify(os.urandom(20)).decode('ascii') def init_session( session_path=None , session_path_header=None , session_domain=None , session_secure=False , session_httponly=True , session_persistent=True , **kwargs ): \"\"\"Initialize session object(using cookies). Attached to before_request_body. session_path: the 'path' value to stick in the response cookie metadata. session_path_header: if 'path' is None(the default), then the response cookie 'path' will be pulled from request.headers[path_header]. session_cookie: the name of the cookie. session_timeout: the expiration timeout(in minutes) for the stored session data. If 'persistent' is True(the default), this is also the timeout for the cookie. session_domain: the cookie domain. session_secure: if False(the default) the cookie 'secure' value will not be set. If True, the cookie 'secure' value will be set(to 1). session_httponly: If True(the default) the cookie 'httponly' value will be set, which prevents client scripts from reading the cookie. This helps to guard against XSS. session_persistent: if True(the default), the 'timeout' argument will be used to expire the cookie. If False, the cookie will not have an expiry, and the cookie will be a \"session cookie\" which expires when the browser is closed. Any additional kwargs will be bound to the new Session instance, and may be specific to the storage type. See the subclass of Session you're using for more information. \"\"\" if hasattr(cherrypy.serving, \"session\"): return request=cherrypy.serving.request name=session_cookie=kwargs.get('session_cookie', Session.session_cookie) cookie_timeout=kwargs.get('session_timeout', Session.timeout) id=None if session_cookie in request.cookie: id=request.cookie[session_cookie].value log('ID obtained from request.cookie: %r' % id) else: log('New session(no cookie)') cherrypy.serving.session=sess=Session(id, **kwargs) if sess.is_response_cookie_needed(): if not session_persistent: cookie_timeout=None set_response_cookie( path=session_path, path_header=session_path_header , name=name , timeout=cookie_timeout , domain=session_domain , secure=session_secure , httponly=session_httponly ) def set_response_cookie(path=None, path_header=None, name='session_id', timeout=60, domain=None, secure=False, httponly=True): \"\"\"Set a response cookie for the client. path: the 'path' value to stick in the response cookie metadata. path_header: if 'path' is None(the default), then the response cookie 'path' will be pulled from request.headers[path_header]. name: the name of the cookie. timeout: the expiration timeout for the cookie. If 0 or other boolean False, no 'expires' param will be set, and the cookie will be a \"session cookie\" which expires when the browser is closed. domain: the cookie domain. secure: if False(the default) the cookie 'secure' value will not be set. If True, the cookie 'secure' value will be set(to 1). httponly: if True(the default) the cookie's 'httponly' value will be set, preventing client scripts from reading the cookie. Helps prevent XSS, see https:\/\/www.owasp.org\/index.php\/HttpOnly \"\"\" cookie=cherrypy.serving.response.cookie cookie[name]=cherrypy.serving.session.id cookie[name]['path']=(path or cherrypy.serving.request.headers.get(path_header) or '\/') if timeout: e=time.time() +(timeout * 60) cookie[name]['expires']=httputil.HTTPDate(e) if domain is not None: cookie[name]['domain']=domain if secure: cookie[name]['secure']=1 if httponly: cookie[name]['httponly']=1 ","sourceWithComments":"\"\"\"The session functionality of lg_authority\/slates.\n\"\"\"\n\nimport os\nimport datetime\nimport time\nimport binascii\nfrom cherrypy.lib import httputil\nimport cherrypy\nfrom ..common import *\nfrom .slates import Slate\n\nclass Session(Slate):\n    \"\"\"A container that maps session ID's to an underlying slate.\"\"\"\n\n    session_cookie = 'session_id'\n    session_cookie__doc = \"\"\"Name of cookie where session id is stored\"\"\"\n\n    timeout=60\n    timeout__doc = \"\"\"Timeout (in minutes) until session expiration\"\"\"\n\n    originalid = None\n    originalid__doc = \"\"\"Client-sent identifier for the session slate\"\"\"\n\n    def __init__(self, id=None, **kwargs):\n        self.timeout = kwargs.pop('session_timeout', Session.timeout) * 60\n        self.session_cookie = kwargs.get('session_cookie', self.session_cookie)\n\n        self.originalid = id\n        self.id = id\n        #Check for expired session, and assign new identifier if\n        #necessary.  _test_id calls Slate.__init__\n        self._test_id()\n\n        if not self.is_expired():\n            #Check for the need to update the session's expiration date.\n            #Update if we're either halfway through our session timeout or\n            #at one hour intervals, whichever comes first.\n            #Remember that by this point, timeout is in seconds instead of\n            #minutes.\n            ttl = self.time_to_expire()\n            if ttl < self.timeout \/\/ 2 or ttl < self.timeout - 60*60:\n                self.touch()\n                self._update_cookie = True\n\n        #The response cookie is set in init_session(), at the bottom of this\n        #file.\n\n    def is_response_cookie_needed(self):\n        #Turns out, a lot of caching mechanisms determine whether to cache\n        #or not based on whether or not the response contains a cookie.\n        #It's best to always return one.\n        return True\n\n        if self.id != self.originalid:\n            return True\n        if hasattr(self, '_update_cookie'):\n            return True\n        return False\n\n    def expire(self):\n        \"\"\"Expires the session both client-side and slate-side\"\"\"\n        Slate.expire(self)\n\n        one_year = 60 * 60 * 24 * 365\n        e = time.time() - one_year\n        cherrypy.serving.response.cookie[self.session_cookie] = 'expired'\n        cherrypy.serving.response.cookie[self.session_cookie]['expires'] = httputil.HTTPDate(e)\n\n    def _test_id(self):\n        \"\"\"Test if we are expired.  If we are, assign a new id\"\"\"\n        #Force the session timeout to always update with the site's preferences.\n        new_timeout = self.timeout\n        Slate.__init__(\n            self\n            , 'session'\n            , self.id\n            , timeout=new_timeout\n            , force_timeout=True\n            )\n        if self.is_expired():\n            while True:\n                self.id = self._generate_id()\n                #We are looking for expired (non-existant) sessions, so no\n                #need to set force_timeout\n                Slate.__init__(self, 'session', self.id, timeout=new_timeout)\n                if self.is_expired():\n                    break\n            log('Session {0} expired -> {1}'.format(self.originalid, self.id))\n\n    def _generate_id(self):\n        \"\"\"Return a new session id.\"\"\"\n        return binascii.hexlify(os.urandom(20)).decode('ascii')\n    \ndef init_session(\n    session_path=None\n    , session_path_header=None\n    , session_domain=None\n    , session_secure=False\n    , session_httponly=True\n    , session_persistent=True\n    , **kwargs\n    ):\n    \"\"\"Initialize session object (using cookies).  \n    Attached to before_request_body.\n    \n    session_path: the 'path' value to stick in the response cookie metadata.\n    session_path_header: if 'path' is None (the default), then the response\n        cookie 'path' will be pulled from request.headers[path_header].\n    session_cookie: the name of the cookie.\n    session_timeout: the expiration timeout (in minutes) for the stored session \n        data. If 'persistent' is True (the default), this is also the timeout\n        for the cookie.\n    session_domain: the cookie domain.\n    session_secure: if False (the default) the cookie 'secure' value will not\n        be set. If True, the cookie 'secure' value will be set (to 1).\n    session_httponly: If True (the default) the cookie 'httponly' value will be\n        set, which prevents client scripts from reading the cookie.  This\n        helps to guard against XSS.\n    session_persistent: if True (the default), the 'timeout' argument will be \n        used to expire the cookie. If False, the cookie will not have an expiry,\n        and the cookie will be a \"session cookie\" which expires when the\n        browser is closed.\n    \n    Any additional kwargs will be bound to the new Session instance,\n    and may be specific to the storage type. See the subclass of Session\n    you're using for more information.\n    \"\"\"\n    \n    # Guard against running twice\n    if hasattr(cherrypy.serving, \"session\"):\n        return\n    \n    request = cherrypy.serving.request\n    name = session_cookie = kwargs.get('session_cookie', Session.session_cookie)\n    cookie_timeout = kwargs.get('session_timeout', Session.timeout)\n    \n    # Check if request came with a session ID\n    id = None\n    if session_cookie in request.cookie:\n        id = request.cookie[session_cookie].value\n        log('ID obtained from request.cookie: %r' % id)\n    else:\n        log('New session (no cookie)')\n    \n    # Create and attach a new Session instance to cherrypy.serving.\n    # It will possess a reference to (and lock, and lazily load)\n    # the requested session data.\n    cherrypy.serving.session = sess = Session(id, **kwargs)\n    \n    if sess.is_response_cookie_needed():\n        if not session_persistent:\n            # See http:\/\/support.microsoft.com\/kb\/223799\/EN-US\/\n            # and http:\/\/support.mozilla.com\/en-US\/kb\/Cookies\n            cookie_timeout = None\n        set_response_cookie(\n          path=session_path, path_header=session_path_header\n          , name=name\n          , timeout=cookie_timeout\n          , domain=session_domain\n          , secure=session_secure\n          , httponly=session_httponly\n          )\n\n\ndef set_response_cookie(path=None, path_header=None, name='session_id',\n                        timeout=60, domain=None, secure=False, httponly=True):\n    \"\"\"Set a response cookie for the client.\n    \n    path: the 'path' value to stick in the response cookie metadata.\n    path_header: if 'path' is None (the default), then the response\n        cookie 'path' will be pulled from request.headers[path_header].\n    name: the name of the cookie.\n    timeout: the expiration timeout for the cookie. If 0 or other boolean\n        False, no 'expires' param will be set, and the cookie will be a\n        \"session cookie\" which expires when the browser is closed.\n    domain: the cookie domain.\n    secure: if False (the default) the cookie 'secure' value will not\n        be set. If True, the cookie 'secure' value will be set (to 1).\n    httponly: if True (the default) the cookie's 'httponly' value will be\n        set, preventing client scripts from reading the cookie.  Helps prevent\n        XSS, see https:\/\/www.owasp.org\/index.php\/HttpOnly\n    \"\"\"\n    # Set response cookie\n    cookie = cherrypy.serving.response.cookie\n    cookie[name] = cherrypy.serving.session.id\n    cookie[name]['path'] = (path or cherrypy.serving.request.headers.get(path_header)\n                            or '\/')\n    \n    # We'd like to use the \"max-age\" param as indicated in\n    # http:\/\/www.faqs.org\/rfcs\/rfc2109.html but IE doesn't\n    # save it to disk and the session is lost if people close\n    # the browser. So we have to use the old \"expires\" ... sigh ...\n##    cookie[name]['max-age'] = timeout * 60\n    if timeout:\n        e = time.time() + (timeout * 60)\n        cookie[name]['expires'] = httputil.HTTPDate(e)\n    if domain is not None:\n        cookie[name]['domain'] = domain\n    if secure:\n        cookie[name]['secure'] = 1\n    if httponly:\n        cookie[name]['httponly'] = 1\n\n"}},"msg":"Reconfigured sessions a bit - by default, persist the session.  Create a new session id if the session specified in the client's cookie is expired.  Touch the new session to make it persistent.  When a login information is transmitted, change the session id to prevent some types of session fixation."}},"https:\/\/github.com\/ltkhiem\/rckit":{"f5fc67e6098cf91fbe928c45ec0dd00992a746da":{"url":"https:\/\/api.github.com\/repos\/ltkhiem\/rckit\/commits\/f5fc67e6098cf91fbe928c45ec0dd00992a746da","html_url":"https:\/\/github.com\/ltkhiem\/rckit\/commit\/f5fc67e6098cf91fbe928c45ec0dd00992a746da","message":":bug: [Bug Fix] Blank fixation group and Invalid blink segments\n\nIgnore empty fixation groups. Blinks that fall outside of the session are ignored.","sha":"f5fc67e6098cf91fbe928c45ec0dd00992a746da","keyword":"session fixation fix","diff":"diff --git a\/__init__.py b\/__init__.py\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a\/ocular_movement_detection.py b\/ocular_movement_detection.py\nindex 15aa946..a71ad3d 100644\n--- a\/ocular_movement_detection.py\n+++ b\/ocular_movement_detection.py\n@@ -38,15 +38,18 @@ def _detect_fixations():\n         fixations = []\n         for fpogid, fpogs in fx_groups:\n             fpogs_valid = fpogs[fpogs['FPOGV'] == 1]\n+            if len(fpogs_valid) == 0: \n+                continue\n+\n             fxh = fpogs_valid['FPOGX'].mean()\n             fxv = fpogs_valid['FPOGY'].mean()\n             fxdur = fpogs_valid['FPOGD'].values[-1]\n-            fxtime = fpogs_valid['TIME'].values[0] - session_time\n+            fxtime = fpogs_valid['TIME'].values[0] - session_start_time\n \n+            # Checks\n             if th_fxdur is not None and fxdur * 1000 <= th_fxdur: \n                 # Fixation duration requirement not meet.\n                 continue\n-\n             if 0 <= fxh <= 1 and 0 <= fxv <= 1:\n                 # Only take fixation that is inside the screen.\n                 fixations.append([fxh, fxv, fxdur, fxtime])\n@@ -69,21 +72,18 @@ def _detect_saccades():\n             - scdur : duration in seconds of saccade.\n             - sctime : starting time in seconds since the start of the session. \n         \"\"\"\n-        print(fixations[0:4])\n         fxend = (fixations[:, 2] + fixations[:, 3]).reshape(-1,1)\n-        print(fxend[:4])\n         time_diff = (fixations[1:][:, 3] - fxend[:-1, 0]).reshape(-1,1)\n-        print(time_diff[:4])\n         saccades = np.concatenate([\n                 fixations[:-1][:, :2],  # start_x, start_y\n                 fixations[1:][:, :2],   # end_x, end_y\n                 time_diff,              # saccades duration\n-                fxend[:-1]               # saccades start will be end of last fixation\n+                fxend[:-1]              # saccades start will be end of last fixation\n             ], axis=1)\n         return saccades\n         ### Remove prints, add threshold ... \n \n-    def _detect_blink():\n+    def _detect_blinks():\n         \"\"\"\n         Take eye tracking data from outer function and perform detection.\n         Blinks that fall outside of a given threshold (if available) are eliminated.\n@@ -100,9 +100,22 @@ def _detect_blink():\n         bk_groups = df[df['BKID'] != 0].groupby(by=['BKID'])\n         for bkid, bk in bk_groups:\n             bktime = bk['TIME'].values[0] - session_start_time\n-            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']\n+            # Blink duration is calculated after the blink is over. Hence, the duration\n+            # is available in the next data entry ...\n+            next_id = bk.tail(1).index[0]+1\n+            if next_id >= len(df):\n+                # Out of bound\n+                continue\n+ \n+            bkdur = df.iloc[next_id]['BKDUR']\n+\n+            # Checks\n+            if bkdur == 0:\n+                # Session is over before blink is over ... eliminate this\n+                continue\n             if th_bkdur is not None and not inside_th(th_bkdur, bkdur):\n                 continue\n+\n             blinks.append([bkdur, bktime])\n         blinks = np.array(blinks)\n         return blinks\n@@ -111,7 +124,7 @@ def _detect_blink():\n     session_start_time = df.iloc[0]['TIME']\n     fixations = _detect_fixations()\n     saccades = _detect_saccades()\n-    blinks = _detect_blink()\n+    blinks = _detect_blinks()\n     return fixations, saccades, blinks\n \n \n","files":{"\/ocular_movement_detection.py":{"changes":[{"diff":"\n         fixations = []\n         for fpogid, fpogs in fx_groups:\n             fpogs_valid = fpogs[fpogs['FPOGV'] == 1]\n+            if len(fpogs_valid) == 0: \n+                continue\n+\n             fxh = fpogs_valid['FPOGX'].mean()\n             fxv = fpogs_valid['FPOGY'].mean()\n             fxdur = fpogs_valid['FPOGD'].values[-1]\n-            fxtime = fpogs_valid['TIME'].values[0] - session_time\n+            fxtime = fpogs_valid['TIME'].values[0] - session_start_time\n \n+            # Checks\n             if th_fxdur is not None and fxdur * 1000 <= th_fxdur: \n                 # Fixation duration requirement not meet.\n                 continue\n-\n             if 0 <= fxh <= 1 and 0 <= fxv <= 1:\n                 # Only take fixation that is inside the screen.\n                 fixations.append([fxh, fxv, fxdur, fxtime])\n","add":5,"remove":2,"filename":"\/ocular_movement_detection.py","badparts":["            fxtime = fpogs_valid['TIME'].values[0] - session_time"],"goodparts":["            if len(fpogs_valid) == 0: ","                continue","            fxtime = fpogs_valid['TIME'].values[0] - session_start_time"]},{"diff":"\n             - scdur : duration in seconds of saccade.\n             - sctime : starting time in seconds since the start of the session. \n         \"\"\"\n-        print(fixations[0:4])\n         fxend = (fixations[:, 2] + fixations[:, 3]).reshape(-1,1)\n-        print(fxend[:4])\n         time_diff = (fixations[1:][:, 3] - fxend[:-1, 0]).reshape(-1,1)\n-        print(time_diff[:4])\n         saccades = np.concatenate([\n                 fixations[:-1][:, :2],  # start_x, start_y\n                 fixations[1:][:, :2],   # end_x, end_y\n                 time_diff,              # saccades duration\n-                fxend[:-1]               # saccades start will be end of last fixation\n+                fxend[:-1]              # saccades start will be end of last fixation\n             ], axis=1)\n         return saccades\n         ### Remove prints, add threshold ... \n \n-    def _detect_blink():\n+    def _detect_blinks():\n         \"\"\"\n         Take eye tracking data from outer function and perform detection.\n         Blinks that fall outside of a given threshold (if available) are eliminated.\n","add":2,"remove":5,"filename":"\/ocular_movement_detection.py","badparts":[" scdur : duration in seconds of saccade."," sctime : starting time in seconds since the start of the session. ","        print(fixations[0:4])","        print(fxend[:4])","        print(time_diff[:4])","                fxend[:-1]               # saccades start will be end of last fixation","    def _detect_blink():"],"goodparts":["                fxend[:-1]              # saccades start will be end of last fixation","    def _detect_blinks():"]},{"diff":"\n         bk_groups = df[df['BKID'] != 0].groupby(by=['BKID'])\n         for bkid, bk in bk_groups:\n             bktime = bk['TIME'].values[0] - session_start_time\n-            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']\n+            # Blink duration is calculated after the blink is over. Hence, the duration\n+            # is available in the next data entry ...\n+            next_id = bk.tail(1).index[0]+1\n+            if next_id >= len(df):\n+                # Out of bound\n+                continue\n+ \n+            bkdur = df.iloc[next_id]['BKDUR']\n+\n+            # Checks\n+            if bkdur == 0:\n+                # Session is over before blink is over ... eliminate this\n+                continue\n             if th_bkdur is not None and not inside_th(th_bkdur, bkdur):\n                 continue\n+\n             blinks.append([bkdur, bktime])\n         blinks = np.array(blinks)\n         return blinks\n","add":14,"remove":1,"filename":"\/ocular_movement_detection.py","badparts":["            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']"],"goodparts":["            next_id = bk.tail(1).index[0]+1","            if next_id >= len(df):","                continue","            bkdur = df.iloc[next_id]['BKDUR']","            if bkdur == 0:","                continue"]},{"diff":"\n     session_start_time = df.iloc[0]['TIME']\n     fixations = _detect_fixations()\n     saccades = _detect_saccades()\n-    blinks = _detect_blink()\n+    blinks = _detect_blinks()\n     return fixations, saccades, blinks\n \n \n","add":1,"remove":1,"filename":"\/ocular_movement_detection.py","badparts":["    blinks = _detect_blink()"],"goodparts":["    blinks = _detect_blinks()"]},{"diff":"\n         fixations = []\n         for fpogid, fpogs in fx_groups:\n             fpogs_valid = fpogs[fpogs['FPOGV'] == 1]\n+            if len(fpogs_valid) == 0: \n+                continue\n+\n             fxh = fpogs_valid['FPOGX'].mean()\n             fxv = fpogs_valid['FPOGY'].mean()\n             fxdur = fpogs_valid['FPOGD'].values[-1]\n-            fxtime = fpogs_valid['TIME'].values[0] - session_time\n+            fxtime = fpogs_valid['TIME'].values[0] - session_start_time\n \n+            # Checks\n             if th_fxdur is not None and fxdur * 1000 <= th_fxdur: \n                 # Fixation duration requirement not meet.\n                 continue\n-\n             if 0 <= fxh <= 1 and 0 <= fxv <= 1:\n                 # Only take fixation that is inside the screen.\n                 fixations.append([fxh, fxv, fxdur, fxtime])\n","add":5,"remove":2,"filename":"\/ocular_movement_detection.py","badparts":["            fxtime = fpogs_valid['TIME'].values[0] - session_time"],"goodparts":["            if len(fpogs_valid) == 0: ","                continue","            fxtime = fpogs_valid['TIME'].values[0] - session_start_time"]},{"diff":"\n             - scdur : duration in seconds of saccade.\n             - sctime : starting time in seconds since the start of the session. \n         \"\"\"\n-        print(fixations[0:4])\n         fxend = (fixations[:, 2] + fixations[:, 3]).reshape(-1,1)\n-        print(fxend[:4])\n         time_diff = (fixations[1:][:, 3] - fxend[:-1, 0]).reshape(-1,1)\n-        print(time_diff[:4])\n         saccades = np.concatenate([\n                 fixations[:-1][:, :2],  # start_x, start_y\n                 fixations[1:][:, :2],   # end_x, end_y\n                 time_diff,              # saccades duration\n-                fxend[:-1]               # saccades start will be end of last fixation\n+                fxend[:-1]              # saccades start will be end of last fixation\n             ], axis=1)\n         return saccades\n         ### Remove prints, add threshold ... \n \n-    def _detect_blink():\n+    def _detect_blinks():\n         \"\"\"\n         Take eye tracking data from outer function and perform detection.\n         Blinks that fall outside of a given threshold (if available) are eliminated.\n","add":2,"remove":5,"filename":"\/ocular_movement_detection.py","badparts":[" scdur : duration in seconds of saccade."," sctime : starting time in seconds since the start of the session. ","        print(fixations[0:4])","        print(fxend[:4])","        print(time_diff[:4])","                fxend[:-1]               # saccades start will be end of last fixation","    def _detect_blink():"],"goodparts":["                fxend[:-1]              # saccades start will be end of last fixation","    def _detect_blinks():"]},{"diff":"\n         bk_groups = df[df['BKID'] != 0].groupby(by=['BKID'])\n         for bkid, bk in bk_groups:\n             bktime = bk['TIME'].values[0] - session_start_time\n-            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']\n+            # Blink duration is calculated after the blink is over. Hence, the duration\n+            # is available in the next data entry ...\n+            next_id = bk.tail(1).index[0]+1\n+            if next_id >= len(df):\n+                # Out of bound\n+                continue\n+ \n+            bkdur = df.iloc[next_id]['BKDUR']\n+\n+            # Checks\n+            if bkdur == 0:\n+                # Session is over before blink is over ... eliminate this\n+                continue\n             if th_bkdur is not None and not inside_th(th_bkdur, bkdur):\n                 continue\n+\n             blinks.append([bkdur, bktime])\n         blinks = np.array(blinks)\n         return blinks\n","add":14,"remove":1,"filename":"\/ocular_movement_detection.py","badparts":["            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']"],"goodparts":["            next_id = bk.tail(1).index[0]+1","            if next_id >= len(df):","                continue","            bkdur = df.iloc[next_id]['BKDUR']","            if bkdur == 0:","                continue"]},{"diff":"\n     session_start_time = df.iloc[0]['TIME']\n     fixations = _detect_fixations()\n     saccades = _detect_saccades()\n-    blinks = _detect_blink()\n+    blinks = _detect_blinks()\n     return fixations, saccades, blinks\n \n \n","add":1,"remove":1,"filename":"\/ocular_movement_detection.py","badparts":["    blinks = _detect_blink()"],"goodparts":["    blinks = _detect_blinks()"]}],"source":"\nimport pandas as pd import numpy as np from settings import _TH_FIXA_DUR from utils.checker import inside_th def _detect_by_gazepoint_filter(df, th_fxdur=None, th_scdur=None, th_bkdur=None): \"\"\" Detect fixations, saccades and blinks using the annotation provided by Gazepoint's internal filter. Parameters ---------- Returns ------- \"\"\" def _detect_fixations(): \"\"\" Take eye tracking data from outer function and perform detection. Only consider valid POG to calculate fixations. The fixations that fall outside of the screen area or a given threshold (if available) are eliminated. Returns ------- fixations: array-like of shape(n_fixations, 4) Each element in the array is a fixation described in the format [fxh, fxv, fxdur, fxtime], where: -fxh: position of fixation on horizontal axis. -fxv: position of fixation on vertical axis. -fxdur: duration in seconds of fixation. -fxtime: starting time in seconds since the start of the session. \"\"\" fx_groups=df.groupby(by=['FPOGID']) fixations=[] for fpogid, fpogs in fx_groups: fpogs_valid=fpogs[fpogs['FPOGV']==1] fxh=fpogs_valid['FPOGX'].mean() fxv=fpogs_valid['FPOGY'].mean() fxdur=fpogs_valid['FPOGD'].values[-1] fxtime=fpogs_valid['TIME'].values[0] -session_time if th_fxdur is not None and fxdur * 1000 <=th_fxdur: continue if 0 <=fxh <=1 and 0 <=fxv <=1: fixations.append([fxh, fxv, fxdur, fxtime]) return np.array(fixations) def _detect_saccades(): \"\"\" Calculate saccades based on a list of fixations. Saccades that fall outside of a given threshold(if available) are eliminated. Returns ------- saccades: array-like of shape(n_saccades, 6) Each element in the array is a saccade described in the format [scsh, scsv, sceh, scev, scdur, sctime], where: -scsh: position of starting POG on horizontal axis. -scsv: position of starting POG on vertical axis. -sceh: position of ending POG on horizontal axis. -scev: position of ending POG on vertical axis. -scdur: duration in seconds of saccade. -sctime: starting time in seconds since the start of the session. \"\"\" print(fixations[0:4]) fxend=(fixations[:, 2] +fixations[:, 3]).reshape(-1,1) print(fxend[:4]) time_diff=(fixations[1:][:, 3] -fxend[:-1, 0]).reshape(-1,1) print(time_diff[:4]) saccades=np.concatenate([ fixations[:-1][:,:2], fixations[1:][:,:2], time_diff, fxend[:-1] ], axis=1) return saccades def _detect_blink(): \"\"\" Take eye tracking data from outer function and perform detection. Blinks that fall outside of a given threshold(if available) are eliminated. Returns ------- blinks: array-like of shape(n_fixations, 2) Each element in the array is a blink described in the format [bkdur, bktime], where: -bkdur: duration in seconds of blink. -bktime: starting time in seconds since the start of the session. \"\"\" blinks=[] bk_groups=df[df['BKID'] !=0].groupby(by=['BKID']) for bkid, bk in bk_groups: bktime=bk['TIME'].values[0] -session_start_time bkdur=df.iloc[bk.tail(1).index[0]+1]['BKDUR'] if th_bkdur is not None and not inside_th(th_bkdur, bkdur): continue blinks.append([bkdur, bktime]) blinks=np.array(blinks) return blinks session_start_time=df.iloc[0]['TIME'] fixations=_detect_fixations() saccades=_detect_saccades() blinks=_detect_blink() return fixations, saccades, blinks def detect(df, method='gazepoint'): \"\"\" Detect fixations, saccades and blinks from eye-tracking data Parameters ---------- Returns ------- \"\"\" if method=='gazepoint': ocular_events=_detect_by_gazepoint_filter(df) return ocular_events if __name__==\"__main__\": print(_TH_FIXA_DUR) df_data=pd.read_csv('\/mnt\/DATA\/ltkhiem\/rcir\/dataset\/0000\/fixed_et\/tracker_data_log_0.tsv', delimiter='\\t') detect(df_data) ","sourceWithComments":"import pandas as pd\nimport numpy as np\nfrom settings import _TH_FIXA_DUR\nfrom utils.checker import inside_th\n\ndef _detect_by_gazepoint_filter(df, th_fxdur=None, th_scdur=None, th_bkdur=None):\n    \"\"\" \n    Detect fixations, saccades and blinks using the annotation provided \n    by Gazepoint's internal filter.\n\n    Parameters\n    ----------\n\n    Returns\n    -------\n\n    \"\"\"\n    def _detect_fixations():\n        \"\"\"\n        Take eye tracking data from outer function and perform detection.\n        Only consider valid POG to calculate fixations.\n        The fixations that fall outside of the screen area or a given threshold\n        (if available) are eliminated.\n\n        Returns\n        -------\n        fixations : array-like of shape (n_fixations, 4)\n            Each element in the array is a fixation described in the format\n            [fxh, fxv, fxdur, fxtime], where:\n            - fxh : position of fixation on horizontal axis.\n            - fxv : position of fixation on vertical axis.\n            - fxdur : duration in seconds of fixation.\n            - fxtime : starting time in seconds since the start of the session. \n        \"\"\"\n        fx_groups = df.groupby(by=['FPOGID'])\n        # Should we ignore the first fixation (as it could be the remaining \n        # of the last fixation in the previous session)?\n        fixations = []\n        for fpogid, fpogs in fx_groups:\n            fpogs_valid = fpogs[fpogs['FPOGV'] == 1]\n            fxh = fpogs_valid['FPOGX'].mean()\n            fxv = fpogs_valid['FPOGY'].mean()\n            fxdur = fpogs_valid['FPOGD'].values[-1]\n            fxtime = fpogs_valid['TIME'].values[0] - session_time\n\n            if th_fxdur is not None and fxdur * 1000 <= th_fxdur: \n                # Fixation duration requirement not meet.\n                continue\n\n            if 0 <= fxh <= 1 and 0 <= fxv <= 1:\n                # Only take fixation that is inside the screen.\n                fixations.append([fxh, fxv, fxdur, fxtime])\n        return np.array(fixations)\n\n    def _detect_saccades():\n        \"\"\"\n        Calculate saccades based on a list of fixations.\n        Saccades that fall outside of a given threshold (if available) are eliminated.\n\n        Returns\n        -------\n        saccades : array-like of shape (n_saccades, 6)\n            Each element in the array is a saccade described in the format\n            [scsh, scsv, sceh, scev, scdur, sctime], where:\n            - scsh : position of starting POG on horizontal axis.\n            - scsv : position of starting POG on vertical axis.\n            - sceh : position of ending POG on horizontal axis.\n            - scev : position of ending POG on vertical axis.\n            - scdur : duration in seconds of saccade.\n            - sctime : starting time in seconds since the start of the session. \n        \"\"\"\n        print(fixations[0:4])\n        fxend = (fixations[:, 2] + fixations[:, 3]).reshape(-1,1)\n        print(fxend[:4])\n        time_diff = (fixations[1:][:, 3] - fxend[:-1, 0]).reshape(-1,1)\n        print(time_diff[:4])\n        saccades = np.concatenate([\n                fixations[:-1][:, :2],  # start_x, start_y\n                fixations[1:][:, :2],   # end_x, end_y\n                time_diff,              # saccades duration\n                fxend[:-1]               # saccades start will be end of last fixation\n            ], axis=1)\n        return saccades\n        ### Remove prints, add threshold ... \n\n    def _detect_blink():\n        \"\"\"\n        Take eye tracking data from outer function and perform detection.\n        Blinks that fall outside of a given threshold (if available) are eliminated.\n\n        Returns\n        -------\n        blinks : array-like of shape (n_fixations, 2)\n            Each element in the array is a blink described in the format\n            [bkdur, bktime], where:\n            - bkdur : duration in seconds of blink.\n            - bktime : starting time in seconds since the start of the session. \n        \"\"\"\n        blinks = []\n        bk_groups = df[df['BKID'] != 0].groupby(by=['BKID'])\n        for bkid, bk in bk_groups:\n            bktime = bk['TIME'].values[0] - session_start_time\n            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']\n            if th_bkdur is not None and not inside_th(th_bkdur, bkdur):\n                continue\n            blinks.append([bkdur, bktime])\n        blinks = np.array(blinks)\n        return blinks\n\n        \n    session_start_time = df.iloc[0]['TIME']\n    fixations = _detect_fixations()\n    saccades = _detect_saccades()\n    blinks = _detect_blink()\n    return fixations, saccades, blinks\n\n\ndef detect(df, method='gazepoint'):\n    \"\"\" Detect fixations, saccades and blinks from eye-tracking data\n    \n    Parameters\n    ----------\n\n    Returns\n    -------\n    \n    \"\"\"\n    if method=='gazepoint':\n        ocular_events = _detect_by_gazepoint_filter(df)\n    return ocular_events\n\n\n    \nif __name__ == \"__main__\":\n    print(_TH_FIXA_DUR)\n    df_data = pd.read_csv('\/mnt\/DATA\/ltkhiem\/rcir\/dataset\/0000\/fixed_et\/tracker_data_log_0.tsv', delimiter = '\\t')\n    detect(df_data) \n"}},"msg":":bug: [Bug Fix] Blank fixation group and Invalid blink segments\n\nIgnore empty fixation groups. Blinks that fall outside of the session are ignored."}},"https:\/\/github.com\/LairdCP\/weblcm-python":{"6548dcbb454b7223076c9f44f29cfbaa5e00f121":{"url":"https:\/\/api.github.com\/repos\/LairdCP\/weblcm-python\/commits\/6548dcbb454b7223076c9f44f29cfbaa5e00f121","html_url":"https:\/\/github.com\/LairdCP\/weblcm-python\/commit\/6548dcbb454b7223076c9f44f29cfbaa5e00f121","message":"weblcm-python: fix Session Fixation error\n\nWith the `get` method the session id will be saved first\nwhich results in session fixation vulnerability.\n\nBug 18953","sha":"6548dcbb454b7223076c9f44f29cfbaa5e00f121","keyword":"session fixation fix","diff":"diff --git a\/__main__.py b\/__main__.py\nindex 3df8d39..ac73166 100644\n--- a\/__main__.py\n+++ b\/__main__.py\n@@ -67,7 +67,9 @@ def force_session_checking():\n \t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\"\n \t\t\t)\n \n-\tif not cherrypy.session.get('USERNAME', None):\n+\t#With the `get` method the session id will be saved which could result in session fixation vulnerability.\n+\t#Session ids will be destroyed periodically so we have to check 'USERNAME' to make sure the session is not valid after logout.\n+\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):\n \t\turl = cherrypy.url().split('\/')[-1]\n \t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths):\n \t\t\traise cherrypy.HTTPError(401)\n","files":{"\/__main__.py":{"changes":[{"diff":"\n \t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\"\n \t\t\t)\n \n-\tif not cherrypy.session.get('USERNAME', None):\n+\t#With the `get` method the session id will be saved which could result in session fixation vulnerability.\n+\t#Session ids will be destroyed periodically so we have to check 'USERNAME' to make sure the session is not valid after logout.\n+\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):\n \t\turl = cherrypy.url().split('\/')[-1]\n \t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths):\n \t\t\traise cherrypy.HTTPError(401)\n","add":3,"remove":1,"filename":"\/__main__.py","badparts":["\tif not cherrypy.session.get('USERNAME', None):"],"goodparts":["\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):"]},{"diff":"\n \t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\"\n \t\t\t)\n \n-\tif not cherrypy.session.get('USERNAME', None):\n+\t#With the `get` method the session id will be saved which could result in session fixation vulnerability.\n+\t#Session ids will be destroyed periodically so we have to check 'USERNAME' to make sure the session is not valid after logout.\n+\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):\n \t\turl = cherrypy.url().split('\/')[-1]\n \t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths):\n \t\t\traise cherrypy.HTTPError(401)\n","add":3,"remove":1,"filename":"\/__main__.py","badparts":["\tif not cherrypy.session.get('USERNAME', None):"],"goodparts":["\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):"]}],"source":"\nimport os import cherrypy import weblcm_def import logging from weblcm_network_status import NetworkStatus from weblcm_network import NetworkInterfaces, NetworkConnections, NetworkConnection, NetworkAccessPoints, Version from weblcm_log import LogData, LogSetting from weblcm_swupdate import SWUpdate from weblcm_users import UserManage, LoginManage, LoginManageHelper from weblcm_files import FileManage, FilesManage, AWMCfgManage from weblcm_advanced import Reboot, FactoryReset from weblcm_datetime import DateTimeSetting from weblcm_settings import SystemSettingsManage class Root(object): \t_firewalld_disabled=os.system('systemctl is-active --quiet firewalld') \t@cherrypy.expose \t@cherrypy.tools.accept(media='application\/json') \t@cherrypy.tools.json_out() \tdef definitions(self, *args, **kwargs): \t\tplugins=[] \t\tfor k in cherrypy.request.app.config['plugins']: \t\t\tplugins.append(k) \t\tsettings={} \t\t \t\tsettings['firewalld_disabled']=Root._firewalld_disabled \t\tsettings['session_timeout']=SystemSettingsManage.get_session_timeout() \t\treturn{ \t\t\t'SDCERR': weblcm_def.WEBLCM_ERRORS, \t\t\t'PERMISSIONS': weblcm_def.USER_PERMISSION_TYPES, \t\t\t'PLUGINS': plugins, \t\t\t'SETTINGS': settings, \t\t} def force_tls(): \tif cherrypy.request.scheme==\"http\": \t\traise cherrypy.HTTPRedirect(cherrypy.url().replace(\"http:\", \"https:\"), status=301) def setup_http_server(): \thttpServer=cherrypy._cpserver.Server() \thttpServer.socket_host=\"::\" \thttpServer.socket_port=80 \thttpServer.thread_pool=0 \thttpServer.subscribe() \tcherrypy.request.hooks.attach('on_start_resource', force_tls) def force_session_checking(): \t\"\"\" \t\tRaise HTTP 401 Unauthorized client error if a session with invalid id tries to assess following resources. \t\tHTMLs still can be loaded to keep consistency, i.e. loaded from local cache or remotely. \t\"\"\" \tpaths=( \t\t\t\t\"connections\", \"connection\", \"accesspoints\", \"networkInterfaces\", \t\t\t\t\"file\", \"users\", \"firmware\", \"logData\", \"awm\", \t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\" \t\t\t) \tif not cherrypy.session.get('USERNAME', None): \t\turl=cherrypy.url().split('\/')[-1] \t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths): \t\t\traise cherrypy.HTTPError(401) @cherrypy.tools.register('before_finalize', priority=60) def secureheaders(): \theaders=cherrypy.response.headers \theaders['X-Frame-Options']='DENY' \theaders['X-XSS-Protection']='1; mode=block' \theaders['X-Content-Type-Options']='nosniff' \theaders['Content-Security-Policy']=\"default-src 'self'\" \t \theaders['Strict-Transport-Security']='max-age=31536000' if __name__=='__main__': \twebapp=Root() \twebapp.login=LoginManage() \twebapp.networkStatus=NetworkStatus() \twebapp.connections=NetworkConnections() \twebapp.connection=NetworkConnection() \twebapp.accesspoints=NetworkAccessPoints() \twebapp.networkInterfaces=NetworkInterfaces() \twebapp.version=Version() \twebapp.logData=LogData() \twebapp.logSetting=LogSetting() \twebapp.users=UserManage() \twebapp.file=FileManage() \twebapp.files=FilesManage() \twebapp.awm=AWMCfgManage() \twebapp.firmware=SWUpdate() \twebapp.reboot=Reboot() \twebapp.factoryReset=FactoryReset() \twebapp.datetime=DateTimeSetting() \tsetup_http_server() \tlogging.getLogger(\"cherrypy\").propagate=False \tcherrypy.request.hooks.attach('before_handler', force_session_checking) \t \tcherrypy.config.update({ \t\t\t'tools.sessions.timeout': SystemSettingsManage.get_session_timeout(), \t\t}) \tcherrypy.quickstart(webapp, '\/', config=weblcm_def.WEBLCM_PYTHON_SERVER_CONF_FILE) ","sourceWithComments":"import os\nimport cherrypy\nimport weblcm_def\nimport logging\nfrom weblcm_network_status import NetworkStatus\nfrom weblcm_network import NetworkInterfaces, NetworkConnections, NetworkConnection, NetworkAccessPoints, Version\nfrom weblcm_log import LogData, LogSetting\nfrom weblcm_swupdate import SWUpdate\nfrom weblcm_users import UserManage, LoginManage, LoginManageHelper\nfrom weblcm_files import FileManage, FilesManage, AWMCfgManage\nfrom weblcm_advanced import Reboot, FactoryReset\nfrom weblcm_datetime import DateTimeSetting\nfrom weblcm_settings import SystemSettingsManage\n\nclass Root(object):\n\n\t_firewalld_disabled = os.system('systemctl is-active --quiet firewalld')\n\n\t@cherrypy.expose\n\t@cherrypy.tools.accept(media='application\/json')\n\t@cherrypy.tools.json_out()\n\tdef definitions(self, *args, **kwargs):\n\n\t\tplugins = []\n\t\tfor k in cherrypy.request.app.config['plugins']:\n\t\t\tplugins.append(k)\n\n\t\tsettings = {}\n\t\t#Whether to display 'zone' on the 'edit connection' page\n\t\tsettings['firewalld_disabled'] = Root._firewalld_disabled\n\t\tsettings['session_timeout'] = SystemSettingsManage.get_session_timeout()\n\n\t\treturn {\n\t\t\t'SDCERR': weblcm_def.WEBLCM_ERRORS,\n\t\t\t'PERMISSIONS': weblcm_def.USER_PERMISSION_TYPES,\n\t\t\t'PLUGINS': plugins,\n\t\t\t'SETTINGS': settings,\n\t\t}\n\n\n#Redirect http to https\ndef force_tls():\n\n\tif cherrypy.request.scheme == \"http\":\n\t\traise cherrypy.HTTPRedirect(cherrypy.url().replace(\"http:\", \"https:\"), status=301)\n\ndef setup_http_server():\n\n\thttpServer = cherrypy._cpserver.Server()\n\thttpServer.socket_host = \"::\"\n\thttpServer.socket_port = 80\n\thttpServer.thread_pool = 0\n\thttpServer.subscribe()\n\n\tcherrypy.request.hooks.attach('on_start_resource', force_tls)\n\ndef force_session_checking():\n\n\t\"\"\"\n\t\tRaise HTTP 401 Unauthorized client error if a session with invalid id tries to assess following resources.\n\t\tHTMLs still can be loaded to keep consistency, i.e. loaded from local cache or remotely.\n\t\"\"\"\n\n\tpaths = (\n\t\t\t\t\"connections\", \"connection\", \"accesspoints\", \"networkInterfaces\",\n\t\t\t\t\"file\", \"users\", \"firmware\", \"logData\", \"awm\",\n\t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\"\n\t\t\t)\n\n\tif not cherrypy.session.get('USERNAME', None):\n\t\turl = cherrypy.url().split('\/')[-1]\n\t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths):\n\t\t\traise cherrypy.HTTPError(401)\n\n@cherrypy.tools.register('before_finalize', priority=60)\ndef secureheaders():\n\theaders = cherrypy.response.headers\n\theaders['X-Frame-Options'] = 'DENY'\n\theaders['X-XSS-Protection'] = '1; mode=block'\n\theaders['X-Content-Type-Options'] = 'nosniff'\n\theaders['Content-Security-Policy'] = \"default-src 'self'\"\n\t#Add Strict-Transport headers\n\theaders['Strict-Transport-Security'] = 'max-age=31536000'  # one year\n\n\nif __name__ == '__main__':\n\n\twebapp = Root()\n\n\twebapp.login = LoginManage()\n\n\twebapp.networkStatus = NetworkStatus()\n\twebapp.connections = NetworkConnections()\n\twebapp.connection = NetworkConnection()\n\twebapp.accesspoints = NetworkAccessPoints()\n\twebapp.networkInterfaces = NetworkInterfaces()\n\twebapp.version = Version()\n\n\twebapp.logData = LogData()\n\twebapp.logSetting = LogSetting()\n\n\twebapp.users = UserManage()\n\twebapp.file = FileManage()\n\twebapp.files = FilesManage()\n\twebapp.awm = AWMCfgManage()\n\n\twebapp.firmware = SWUpdate()\n\n\twebapp.reboot = Reboot()\n\twebapp.factoryReset = FactoryReset()\n\twebapp.datetime = DateTimeSetting()\n\n\tsetup_http_server()\n\n\tlogging.getLogger(\"cherrypy\").propagate = False\n\n\tcherrypy.request.hooks.attach('before_handler', force_session_checking)\n\n\t#Server config\n\tcherrypy.config.update({\n\t\t\t'tools.sessions.timeout': SystemSettingsManage.get_session_timeout(),\n\t\t})\n\n\tcherrypy.quickstart(webapp, '\/', config=weblcm_def.WEBLCM_PYTHON_SERVER_CONF_FILE)\n"}},"msg":"weblcm-python: fix Session Fixation error\n\nWith the `get` method the session id will be saved first\nwhich results in session fixation vulnerability.\n\nBug 18953"}},"https:\/\/github.com\/Monia234\/hail":{"d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9":{"url":"https:\/\/api.github.com\/repos\/Monia234\/hail\/commits\/d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","html_url":"https:\/\/github.com\/Monia234\/hail\/commit\/d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","message":"[auth] maybe fix auth flow & close security hole (#8052)\n\n* [auth] maybe fix auth flow & close security hole\n\nIt seems that sessions sometimes become inaccessible to auth. Using some\nlogging, I realized that `\/login` will set some session parameters that do not\nreappear in `\/oauth2callback`. While trying to debug this, I deleted my cookie\nand everything started working again. Luckily, my phone was still borked. The\nfix is to use `new_session` which I discovered with a big red warning in\naiohttp-session's docs: [Always use new_session() instead of get_session() in\nyour login views to guard against Session Fixation\nattacks!](https:\/\/aiohttp-session.readthedocs.io\/en\/stable\/reference.html#aiohttp_session.new_session).\n\nIf nothing else, we are now safe from session fixation attacks. I do not\nunderstand why this is necessary for correctness.\n\n* bump\n\n* bump","sha":"d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","keyword":"session fixation fix","diff":"diff --git a\/auth\/auth\/auth.py b\/auth\/auth\/auth.py\nindex e22a8ad2c2..6cd4e23d68 100644\n--- a\/auth\/auth\/auth.py\n+++ b\/auth\/auth\/auth.py\n@@ -59,7 +59,7 @@ async def login(request, userdata):\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","files":{"\/auth\/auth\/auth.py":{"changes":[{"diff":"\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","add":1,"remove":1,"filename":"\/auth\/auth\/auth.py","badparts":["    session = await aiohttp_session.get_session(request)"],"goodparts":["    session = await aiohttp_session.new_session(request)"]},{"diff":"\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","add":1,"remove":1,"filename":"\/auth\/auth\/auth.py","badparts":["    session = await aiohttp_session.get_session(request)"],"goodparts":["    session = await aiohttp_session.new_session(request)"]}],"source":"\nimport logging import aiohttp from aiohttp import web import aiohttp_session import uvloop import google.auth.transport.requests import google.oauth2.id_token import google.cloud.storage import google_auth_oauthlib.flow from hailtop.config import get_deploy_config from gear import setup_aiohttp_session, create_database_pool, \\ rest_authenticated_users_only, web_authenticated_developers_only, \\ web_maybe_authenticated_user, create_session, check_csrf_token from web_common import setup_aiohttp_jinja2, setup_common_static_routes, \\ set_message, render_template log=logging.getLogger('auth') uvloop.install() deploy_config=get_deploy_config() routes=web.RouteTableDef() def get_flow(redirect_uri, state=None): scopes=[ 'https:\/\/www.googleapis.com\/auth\/userinfo.profile', 'https:\/\/www.googleapis.com\/auth\/userinfo.email', 'openid' ] flow=google_auth_oauthlib.flow.Flow.from_client_secrets_file( '\/auth-oauth2-client-secret\/client_secret.json', scopes=scopes, state=state) flow.redirect_uri=redirect_uri return flow @routes.get('\/healthcheck') async def get_healthcheck(request): return web.Response() @routes.get('') @routes.get('\/') async def get_index(request): return aiohttp.web.HTTPFound(deploy_config.external_url('auth', '\/login')) @routes.get('\/login') @web_maybe_authenticated_user async def login(request, userdata): next=request.query.get('next', deploy_config.external_url('notebook', '')) if userdata: return aiohttp.web.HTTPFound(next) flow=get_flow(deploy_config.external_url('auth', '\/oauth2callback')) authorization_url, state=flow.authorization_url( access_type='offline', include_granted_scopes='true') session=await aiohttp_session.get_session(request) session['state']=state session['next']=next return aiohttp.web.HTTPFound(authorization_url) @routes.get('\/oauth2callback') async def callback(request): session=await aiohttp_session.get_session(request) if 'state' not in session: raise web.HTTPUnauthorized() state=session['state'] flow=get_flow(deploy_config.external_url('auth', '\/oauth2callback'), state=state) try: flow.fetch_token(code=request.query['code']) token=google.oauth2.id_token.verify_oauth2_token( flow.credentials.id_token, google.auth.transport.requests.Request()) email=token['email'] except Exception: log.exception('oauth2 callback: could not fetch and verify token') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(\"SELECT * FROM users WHERE email=%s AND state='active';\", email) users=await cursor.fetchall() if len(users) !=1: raise web.HTTPUnauthorized() user=users[0] session_id=await create_session(dbpool, user['id']) del session['state'] session['session_id']=session_id next=session.pop('next') return aiohttp.web.HTTPFound(next) @routes.post('\/logout') @check_csrf_token @web_maybe_authenticated_user async def logout(request, userdata): if not userdata: return web.HTTPFound(deploy_config.external_url('notebook', '')) dbpool=request.app['dbpool'] session_id=userdata['session_id'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('DELETE FROM sessions WHERE session_id=%s;', session_id) session=await aiohttp_session.get_session(request) if 'session_id' in session: del session['session_id'] return web.HTTPFound(deploy_config.external_url('notebook', '')) @routes.get('\/api\/v1alpha\/login') async def rest_login(request): callback_port=request.query['callback_port'] flow=get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback') authorization_url, state=flow.authorization_url( access_type='offline', include_granted_scopes='true') return web.json_response({ 'authorization_url': authorization_url, 'state': state }) @routes.get('\/users') @web_authenticated_developers_only() async def get_users(request, userdata): dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('SELECT * FROM users;') users=await cursor.fetchall() page_context={ 'users': users } return await render_template('auth', request, userdata, 'users.html', page_context) @routes.post('\/users') @check_csrf_token @web_authenticated_developers_only() async def post_create_user(request, userdata): session=await aiohttp_session.get_session(request) dbpool=request.app['dbpool'] post=await request.post() username=post['username'] email=post['email'] is_developer=post.get('is_developer')=='1' async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute( ''' INSERT INTO users(state, username, email, is_developer) VALUES(%s, %s, %s, %s); ''', ('creating', username, email, is_developer)) user_id=cursor.lastrowid set_message(session, f'Created user{user_id}{username}.', 'info') return web.HTTPFound(deploy_config.external_url('auth', '\/users')) @routes.post('\/users\/delete') @check_csrf_token @web_authenticated_developers_only() async def delete_user(request, userdata): session=await aiohttp_session.get_session(request) dbpool=request.app['dbpool'] post=await request.post() id=post['id'] username=post['username'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: n_rows=await cursor.execute( ''' UPDATE users SET state='deleting' WHERE id=%s AND username=%s; ''', (id, username)) if n_rows !=1: assert n_rows==0 set_message(session, f'Delete failed, no such user{id}{username}.', 'error') set_message(session, f'Deleted user{id}{username}.', 'info') return web.HTTPFound(deploy_config.external_url('auth', '\/users')) @routes.get('\/api\/v1alpha\/oauth2callback') async def rest_callback(request): state=request.query['state'] code=request.query['code'] callback_port=request.query['callback_port'] try: flow=get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback', state=state) flow.fetch_token(code=code) token=google.oauth2.id_token.verify_oauth2_token( flow.credentials.id_token, google.auth.transport.requests.Request()) email=token['email'] except Exception: log.exception('fetching and decoding token') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(\"SELECT * FROM users WHERE email=%s AND state='active';\", email) users=await cursor.fetchall() if len(users) !=1: raise web.HTTPUnauthorized() user=users[0] session_id=await create_session(dbpool, user['id']) return web.json_response({ 'token': session_id, 'username': user['username'] }) @routes.post('\/api\/v1alpha\/logout') @rest_authenticated_users_only async def rest_logout(request, userdata): session_id=userdata['session_id'] dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('DELETE FROM sessions WHERE session_id=%s;', session_id) return web.Response(status=200) @routes.get('\/api\/v1alpha\/userinfo') async def userinfo(request): if 'Authorization' not in request.headers: log.info('Authorization not in request.headers') raise web.HTTPUnauthorized() auth_header=request.headers['Authorization'] if not auth_header.startswith('Bearer '): log.info('Bearer not in Authorization header') raise web.HTTPUnauthorized() session_id=auth_header[7:] if len(session_id) !=44: log.info('Session id !=44 bytes') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(''' SELECT users.*, sessions.session_id FROM users INNER JOIN sessions ON users.id=sessions.user_id WHERE users.state='active' AND(sessions.session_id=%s) AND(ISNULL(sessions.max_age_secs) OR(NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created))); ''', session_id) users=await cursor.fetchall() if len(users) !=1: log.info(f'Unknown session id:{session_id}') raise web.HTTPUnauthorized() user=users[0] return web.json_response(user) async def on_startup(app): app['dbpool']=await create_database_pool() async def on_cleanup(app): dbpool=app['dbpool'] dbpool.close() await dbpool.wait_closed() def run(): app=web.Application() setup_aiohttp_jinja2(app, 'auth') setup_aiohttp_session(app) setup_common_static_routes(routes) app.add_routes(routes) app.on_startup.append(on_startup) app.on_cleanup.append(on_cleanup) web.run_app(deploy_config.prefix_application(app, 'auth'), host='0.0.0.0', port=5000) ","sourceWithComments":"import logging\nimport aiohttp\nfrom aiohttp import web\nimport aiohttp_session\nimport uvloop\nimport google.auth.transport.requests\nimport google.oauth2.id_token\nimport google.cloud.storage\nimport google_auth_oauthlib.flow\nfrom hailtop.config import get_deploy_config\nfrom gear import setup_aiohttp_session, create_database_pool, \\\n    rest_authenticated_users_only, web_authenticated_developers_only, \\\n    web_maybe_authenticated_user, create_session, check_csrf_token\nfrom web_common import setup_aiohttp_jinja2, setup_common_static_routes, \\\n    set_message, render_template\n\nlog = logging.getLogger('auth')\n\nuvloop.install()\n\ndeploy_config = get_deploy_config()\n\nroutes = web.RouteTableDef()\n\n\ndef get_flow(redirect_uri, state=None):\n    scopes = [\n        'https:\/\/www.googleapis.com\/auth\/userinfo.profile',\n        'https:\/\/www.googleapis.com\/auth\/userinfo.email',\n        'openid'\n    ]\n    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n        '\/auth-oauth2-client-secret\/client_secret.json', scopes=scopes, state=state)\n    flow.redirect_uri = redirect_uri\n    return flow\n\n\n@routes.get('\/healthcheck')\nasync def get_healthcheck(request):  # pylint: disable=W0613\n    return web.Response()\n\n\n@routes.get('')\n@routes.get('\/')\nasync def get_index(request):  # pylint: disable=unused-argument\n    return aiohttp.web.HTTPFound(deploy_config.external_url('auth', '\/login'))\n\n\n@routes.get('\/login')\n@web_maybe_authenticated_user\nasync def login(request, userdata):\n    next = request.query.get('next', deploy_config.external_url('notebook', ''))\n    if userdata:\n        return aiohttp.web.HTTPFound(next)\n\n    flow = get_flow(deploy_config.external_url('auth', '\/oauth2callback'))\n\n    authorization_url, state = flow.authorization_url(\n        access_type='offline',\n        include_granted_scopes='true')\n\n    session = await aiohttp_session.get_session(request)\n    session['state'] = state\n    session['next'] = next\n\n    return aiohttp.web.HTTPFound(authorization_url)\n\n\n@routes.get('\/oauth2callback')\nasync def callback(request):\n    session = await aiohttp_session.get_session(request)\n    if 'state' not in session:\n        raise web.HTTPUnauthorized()\n    state = session['state']\n\n    flow = get_flow(deploy_config.external_url('auth', '\/oauth2callback'), state=state)\n\n    try:\n        flow.fetch_token(code=request.query['code'])\n        token = google.oauth2.id_token.verify_oauth2_token(\n            flow.credentials.id_token, google.auth.transport.requests.Request())\n        email = token['email']\n    except Exception:\n        log.exception('oauth2 callback: could not fetch and verify token')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\"SELECT * FROM users WHERE email = %s AND state = 'active';\", email)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    session_id = await create_session(dbpool, user['id'])\n\n    del session['state']\n    session['session_id'] = session_id\n    next = session.pop('next')\n    return aiohttp.web.HTTPFound(next)\n\n\n@routes.post('\/logout')\n@check_csrf_token\n@web_maybe_authenticated_user\nasync def logout(request, userdata):\n    if not userdata:\n        return web.HTTPFound(deploy_config.external_url('notebook', ''))\n\n    dbpool = request.app['dbpool']\n    session_id = userdata['session_id']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('DELETE FROM sessions WHERE session_id = %s;', session_id)\n\n    session = await aiohttp_session.get_session(request)\n    if 'session_id' in session:\n        del session['session_id']\n\n    return web.HTTPFound(deploy_config.external_url('notebook', ''))\n\n\n@routes.get('\/api\/v1alpha\/login')\nasync def rest_login(request):\n    callback_port = request.query['callback_port']\n\n    flow = get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback')\n    authorization_url, state = flow.authorization_url(\n        access_type='offline',\n        include_granted_scopes='true')\n\n    return web.json_response({\n        'authorization_url': authorization_url,\n        'state': state\n    })\n\n\n@routes.get('\/users')\n@web_authenticated_developers_only()\nasync def get_users(request, userdata):\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('SELECT * FROM users;')\n            users = await cursor.fetchall()\n    page_context = {\n        'users': users\n    }\n    return await render_template('auth', request, userdata, 'users.html', page_context)\n\n\n@routes.post('\/users')\n@check_csrf_token\n@web_authenticated_developers_only()\nasync def post_create_user(request, userdata):  # pylint: disable=unused-argument\n    session = await aiohttp_session.get_session(request)\n    dbpool = request.app['dbpool']\n    post = await request.post()\n    username = post['username']\n    email = post['email']\n    is_developer = post.get('is_developer') == '1'\n\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\n                '''\nINSERT INTO users (state, username, email, is_developer)\nVALUES (%s, %s, %s, %s);\n''',\n                ('creating', username, email, is_developer))\n            user_id = cursor.lastrowid\n\n    set_message(session, f'Created user {user_id} {username}.', 'info')\n\n    return web.HTTPFound(deploy_config.external_url('auth', '\/users'))\n\n\n@routes.post('\/users\/delete')\n@check_csrf_token\n@web_authenticated_developers_only()\nasync def delete_user(request, userdata):  # pylint: disable=unused-argument\n    session = await aiohttp_session.get_session(request)\n    dbpool = request.app['dbpool']\n    post = await request.post()\n    id = post['id']\n    username = post['username']\n\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            n_rows = await cursor.execute(\n                '''\nUPDATE users\nSET state = 'deleting'\nWHERE id = %s AND username = %s;\n''',\n                (id, username))\n            if n_rows != 1:\n                assert n_rows == 0\n                set_message(session, f'Delete failed, no such user {id} {username}.', 'error')\n\n    set_message(session, f'Deleted user {id} {username}.', 'info')\n\n    return web.HTTPFound(deploy_config.external_url('auth', '\/users'))\n\n\n@routes.get('\/api\/v1alpha\/oauth2callback')\nasync def rest_callback(request):\n    state = request.query['state']\n    code = request.query['code']\n    callback_port = request.query['callback_port']\n\n    try:\n        flow = get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback', state=state)\n        flow.fetch_token(code=code)\n        token = google.oauth2.id_token.verify_oauth2_token(\n            flow.credentials.id_token, google.auth.transport.requests.Request())\n        email = token['email']\n    except Exception:\n        log.exception('fetching and decoding token')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\"SELECT * FROM users WHERE email = %s AND state = 'active';\", email)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    session_id = await create_session(dbpool, user['id'])\n\n    return web.json_response({\n        'token': session_id,\n        'username': user['username']\n    })\n\n\n@routes.post('\/api\/v1alpha\/logout')\n@rest_authenticated_users_only\nasync def rest_logout(request, userdata):\n    session_id = userdata['session_id']\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('DELETE FROM sessions WHERE session_id = %s;', session_id)\n\n    return web.Response(status=200)\n\n\n@routes.get('\/api\/v1alpha\/userinfo')\nasync def userinfo(request):\n    if 'Authorization' not in request.headers:\n        log.info('Authorization not in request.headers')\n        raise web.HTTPUnauthorized()\n\n    auth_header = request.headers['Authorization']\n    if not auth_header.startswith('Bearer '):\n        log.info('Bearer not in Authorization header')\n        raise web.HTTPUnauthorized()\n    session_id = auth_header[7:]\n\n    # b64 encoding of 32-byte session ID is 44 bytes\n    if len(session_id) != 44:\n        log.info('Session id != 44 bytes')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('''\nSELECT users.*, sessions.session_id FROM users\nINNER JOIN sessions ON users.id = sessions.user_id\nWHERE users.state = 'active' AND (sessions.session_id = %s) AND (ISNULL(sessions.max_age_secs) OR (NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created)));\n''', session_id)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        log.info(f'Unknown session id: {session_id}')\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    return web.json_response(user)\n\n\nasync def on_startup(app):\n    app['dbpool'] = await create_database_pool()\n\n\nasync def on_cleanup(app):\n    dbpool = app['dbpool']\n    dbpool.close()\n    await dbpool.wait_closed()\n\n\ndef run():\n    app = web.Application()\n\n    setup_aiohttp_jinja2(app, 'auth')\n    setup_aiohttp_session(app)\n\n    setup_common_static_routes(routes)\n    app.add_routes(routes)\n    app.on_startup.append(on_startup)\n    app.on_cleanup.append(on_cleanup)\n\n    web.run_app(deploy_config.prefix_application(app, 'auth'), host='0.0.0.0', port=5000)\n"}},"msg":"[auth] maybe fix auth flow & close security hole (#8052)\n\n* [auth] maybe fix auth flow & close security hole\n\nIt seems that sessions sometimes become inaccessible to auth. Using some\nlogging, I realized that `\/login` will set some session parameters that do not\nreappear in `\/oauth2callback`. While trying to debug this, I deleted my cookie\nand everything started working again. Luckily, my phone was still borked. The\nfix is to use `new_session` which I discovered with a big red warning in\naiohttp-session's docs: [Always use new_session() instead of get_session() in\nyour login views to guard against Session Fixation\nattacks!](https:\/\/aiohttp-session.readthedocs.io\/en\/stable\/reference.html#aiohttp_session.new_session).\n\nIf nothing else, we are now safe from session fixation attacks. I do not\nunderstand why this is necessary for correctness.\n\n* bump\n\n* bump"}},"https:\/\/github.com\/hail-is\/hail":{"d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9":{"url":"https:\/\/api.github.com\/repos\/hail-is\/hail\/commits\/d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","html_url":"https:\/\/github.com\/hail-is\/hail\/commit\/d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","message":"[auth] maybe fix auth flow & close security hole (#8052)\n\n* [auth] maybe fix auth flow & close security hole\n\nIt seems that sessions sometimes become inaccessible to auth. Using some\nlogging, I realized that `\/login` will set some session parameters that do not\nreappear in `\/oauth2callback`. While trying to debug this, I deleted my cookie\nand everything started working again. Luckily, my phone was still borked. The\nfix is to use `new_session` which I discovered with a big red warning in\naiohttp-session's docs: [Always use new_session() instead of get_session() in\nyour login views to guard against Session Fixation\nattacks!](https:\/\/aiohttp-session.readthedocs.io\/en\/stable\/reference.html#aiohttp_session.new_session).\n\nIf nothing else, we are now safe from session fixation attacks. I do not\nunderstand why this is necessary for correctness.\n\n* bump\n\n* bump","sha":"d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","keyword":"session fixation fix","diff":"diff --git a\/auth\/auth\/auth.py b\/auth\/auth\/auth.py\nindex e22a8ad2c2e..6cd4e23d68d 100644\n--- a\/auth\/auth\/auth.py\n+++ b\/auth\/auth\/auth.py\n@@ -59,7 +59,7 @@ async def login(request, userdata):\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","files":{"\/auth\/auth\/auth.py":{"changes":[{"diff":"\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","add":1,"remove":1,"filename":"\/auth\/auth\/auth.py","badparts":["    session = await aiohttp_session.get_session(request)"],"goodparts":["    session = await aiohttp_session.new_session(request)"]},{"diff":"\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","add":1,"remove":1,"filename":"\/auth\/auth\/auth.py","badparts":["    session = await aiohttp_session.get_session(request)"],"goodparts":["    session = await aiohttp_session.new_session(request)"]}],"source":"\nimport logging import aiohttp from aiohttp import web import aiohttp_session import uvloop import google.auth.transport.requests import google.oauth2.id_token import google.cloud.storage import google_auth_oauthlib.flow from hailtop.config import get_deploy_config from gear import setup_aiohttp_session, create_database_pool, \\ rest_authenticated_users_only, web_authenticated_developers_only, \\ web_maybe_authenticated_user, create_session, check_csrf_token from web_common import setup_aiohttp_jinja2, setup_common_static_routes, \\ set_message, render_template log=logging.getLogger('auth') uvloop.install() deploy_config=get_deploy_config() routes=web.RouteTableDef() def get_flow(redirect_uri, state=None): scopes=[ 'https:\/\/www.googleapis.com\/auth\/userinfo.profile', 'https:\/\/www.googleapis.com\/auth\/userinfo.email', 'openid' ] flow=google_auth_oauthlib.flow.Flow.from_client_secrets_file( '\/auth-oauth2-client-secret\/client_secret.json', scopes=scopes, state=state) flow.redirect_uri=redirect_uri return flow @routes.get('\/healthcheck') async def get_healthcheck(request): return web.Response() @routes.get('') @routes.get('\/') async def get_index(request): return aiohttp.web.HTTPFound(deploy_config.external_url('auth', '\/login')) @routes.get('\/login') @web_maybe_authenticated_user async def login(request, userdata): next=request.query.get('next', deploy_config.external_url('notebook', '')) if userdata: return aiohttp.web.HTTPFound(next) flow=get_flow(deploy_config.external_url('auth', '\/oauth2callback')) authorization_url, state=flow.authorization_url( access_type='offline', include_granted_scopes='true') session=await aiohttp_session.get_session(request) session['state']=state session['next']=next return aiohttp.web.HTTPFound(authorization_url) @routes.get('\/oauth2callback') async def callback(request): session=await aiohttp_session.get_session(request) if 'state' not in session: raise web.HTTPUnauthorized() state=session['state'] flow=get_flow(deploy_config.external_url('auth', '\/oauth2callback'), state=state) try: flow.fetch_token(code=request.query['code']) token=google.oauth2.id_token.verify_oauth2_token( flow.credentials.id_token, google.auth.transport.requests.Request()) email=token['email'] except Exception: log.exception('oauth2 callback: could not fetch and verify token') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(\"SELECT * FROM users WHERE email=%s AND state='active';\", email) users=await cursor.fetchall() if len(users) !=1: raise web.HTTPUnauthorized() user=users[0] session_id=await create_session(dbpool, user['id']) del session['state'] session['session_id']=session_id next=session.pop('next') return aiohttp.web.HTTPFound(next) @routes.post('\/logout') @check_csrf_token @web_maybe_authenticated_user async def logout(request, userdata): if not userdata: return web.HTTPFound(deploy_config.external_url('notebook', '')) dbpool=request.app['dbpool'] session_id=userdata['session_id'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('DELETE FROM sessions WHERE session_id=%s;', session_id) session=await aiohttp_session.get_session(request) if 'session_id' in session: del session['session_id'] return web.HTTPFound(deploy_config.external_url('notebook', '')) @routes.get('\/api\/v1alpha\/login') async def rest_login(request): callback_port=request.query['callback_port'] flow=get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback') authorization_url, state=flow.authorization_url( access_type='offline', include_granted_scopes='true') return web.json_response({ 'authorization_url': authorization_url, 'state': state }) @routes.get('\/users') @web_authenticated_developers_only() async def get_users(request, userdata): dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('SELECT * FROM users;') users=await cursor.fetchall() page_context={ 'users': users } return await render_template('auth', request, userdata, 'users.html', page_context) @routes.post('\/users') @check_csrf_token @web_authenticated_developers_only() async def post_create_user(request, userdata): session=await aiohttp_session.get_session(request) dbpool=request.app['dbpool'] post=await request.post() username=post['username'] email=post['email'] is_developer=post.get('is_developer')=='1' async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute( ''' INSERT INTO users(state, username, email, is_developer) VALUES(%s, %s, %s, %s); ''', ('creating', username, email, is_developer)) user_id=cursor.lastrowid set_message(session, f'Created user{user_id}{username}.', 'info') return web.HTTPFound(deploy_config.external_url('auth', '\/users')) @routes.post('\/users\/delete') @check_csrf_token @web_authenticated_developers_only() async def delete_user(request, userdata): session=await aiohttp_session.get_session(request) dbpool=request.app['dbpool'] post=await request.post() id=post['id'] username=post['username'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: n_rows=await cursor.execute( ''' UPDATE users SET state='deleting' WHERE id=%s AND username=%s; ''', (id, username)) if n_rows !=1: assert n_rows==0 set_message(session, f'Delete failed, no such user{id}{username}.', 'error') set_message(session, f'Deleted user{id}{username}.', 'info') return web.HTTPFound(deploy_config.external_url('auth', '\/users')) @routes.get('\/api\/v1alpha\/oauth2callback') async def rest_callback(request): state=request.query['state'] code=request.query['code'] callback_port=request.query['callback_port'] try: flow=get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback', state=state) flow.fetch_token(code=code) token=google.oauth2.id_token.verify_oauth2_token( flow.credentials.id_token, google.auth.transport.requests.Request()) email=token['email'] except Exception: log.exception('fetching and decoding token') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(\"SELECT * FROM users WHERE email=%s AND state='active';\", email) users=await cursor.fetchall() if len(users) !=1: raise web.HTTPUnauthorized() user=users[0] session_id=await create_session(dbpool, user['id']) return web.json_response({ 'token': session_id, 'username': user['username'] }) @routes.post('\/api\/v1alpha\/logout') @rest_authenticated_users_only async def rest_logout(request, userdata): session_id=userdata['session_id'] dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('DELETE FROM sessions WHERE session_id=%s;', session_id) return web.Response(status=200) @routes.get('\/api\/v1alpha\/userinfo') async def userinfo(request): if 'Authorization' not in request.headers: log.info('Authorization not in request.headers') raise web.HTTPUnauthorized() auth_header=request.headers['Authorization'] if not auth_header.startswith('Bearer '): log.info('Bearer not in Authorization header') raise web.HTTPUnauthorized() session_id=auth_header[7:] if len(session_id) !=44: log.info('Session id !=44 bytes') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(''' SELECT users.*, sessions.session_id FROM users INNER JOIN sessions ON users.id=sessions.user_id WHERE users.state='active' AND(sessions.session_id=%s) AND(ISNULL(sessions.max_age_secs) OR(NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created))); ''', session_id) users=await cursor.fetchall() if len(users) !=1: log.info(f'Unknown session id:{session_id}') raise web.HTTPUnauthorized() user=users[0] return web.json_response(user) async def on_startup(app): app['dbpool']=await create_database_pool() async def on_cleanup(app): dbpool=app['dbpool'] dbpool.close() await dbpool.wait_closed() def run(): app=web.Application() setup_aiohttp_jinja2(app, 'auth') setup_aiohttp_session(app) setup_common_static_routes(routes) app.add_routes(routes) app.on_startup.append(on_startup) app.on_cleanup.append(on_cleanup) web.run_app(deploy_config.prefix_application(app, 'auth'), host='0.0.0.0', port=5000) ","sourceWithComments":"import logging\nimport aiohttp\nfrom aiohttp import web\nimport aiohttp_session\nimport uvloop\nimport google.auth.transport.requests\nimport google.oauth2.id_token\nimport google.cloud.storage\nimport google_auth_oauthlib.flow\nfrom hailtop.config import get_deploy_config\nfrom gear import setup_aiohttp_session, create_database_pool, \\\n    rest_authenticated_users_only, web_authenticated_developers_only, \\\n    web_maybe_authenticated_user, create_session, check_csrf_token\nfrom web_common import setup_aiohttp_jinja2, setup_common_static_routes, \\\n    set_message, render_template\n\nlog = logging.getLogger('auth')\n\nuvloop.install()\n\ndeploy_config = get_deploy_config()\n\nroutes = web.RouteTableDef()\n\n\ndef get_flow(redirect_uri, state=None):\n    scopes = [\n        'https:\/\/www.googleapis.com\/auth\/userinfo.profile',\n        'https:\/\/www.googleapis.com\/auth\/userinfo.email',\n        'openid'\n    ]\n    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n        '\/auth-oauth2-client-secret\/client_secret.json', scopes=scopes, state=state)\n    flow.redirect_uri = redirect_uri\n    return flow\n\n\n@routes.get('\/healthcheck')\nasync def get_healthcheck(request):  # pylint: disable=W0613\n    return web.Response()\n\n\n@routes.get('')\n@routes.get('\/')\nasync def get_index(request):  # pylint: disable=unused-argument\n    return aiohttp.web.HTTPFound(deploy_config.external_url('auth', '\/login'))\n\n\n@routes.get('\/login')\n@web_maybe_authenticated_user\nasync def login(request, userdata):\n    next = request.query.get('next', deploy_config.external_url('notebook', ''))\n    if userdata:\n        return aiohttp.web.HTTPFound(next)\n\n    flow = get_flow(deploy_config.external_url('auth', '\/oauth2callback'))\n\n    authorization_url, state = flow.authorization_url(\n        access_type='offline',\n        include_granted_scopes='true')\n\n    session = await aiohttp_session.get_session(request)\n    session['state'] = state\n    session['next'] = next\n\n    return aiohttp.web.HTTPFound(authorization_url)\n\n\n@routes.get('\/oauth2callback')\nasync def callback(request):\n    session = await aiohttp_session.get_session(request)\n    if 'state' not in session:\n        raise web.HTTPUnauthorized()\n    state = session['state']\n\n    flow = get_flow(deploy_config.external_url('auth', '\/oauth2callback'), state=state)\n\n    try:\n        flow.fetch_token(code=request.query['code'])\n        token = google.oauth2.id_token.verify_oauth2_token(\n            flow.credentials.id_token, google.auth.transport.requests.Request())\n        email = token['email']\n    except Exception:\n        log.exception('oauth2 callback: could not fetch and verify token')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\"SELECT * FROM users WHERE email = %s AND state = 'active';\", email)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    session_id = await create_session(dbpool, user['id'])\n\n    del session['state']\n    session['session_id'] = session_id\n    next = session.pop('next')\n    return aiohttp.web.HTTPFound(next)\n\n\n@routes.post('\/logout')\n@check_csrf_token\n@web_maybe_authenticated_user\nasync def logout(request, userdata):\n    if not userdata:\n        return web.HTTPFound(deploy_config.external_url('notebook', ''))\n\n    dbpool = request.app['dbpool']\n    session_id = userdata['session_id']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('DELETE FROM sessions WHERE session_id = %s;', session_id)\n\n    session = await aiohttp_session.get_session(request)\n    if 'session_id' in session:\n        del session['session_id']\n\n    return web.HTTPFound(deploy_config.external_url('notebook', ''))\n\n\n@routes.get('\/api\/v1alpha\/login')\nasync def rest_login(request):\n    callback_port = request.query['callback_port']\n\n    flow = get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback')\n    authorization_url, state = flow.authorization_url(\n        access_type='offline',\n        include_granted_scopes='true')\n\n    return web.json_response({\n        'authorization_url': authorization_url,\n        'state': state\n    })\n\n\n@routes.get('\/users')\n@web_authenticated_developers_only()\nasync def get_users(request, userdata):\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('SELECT * FROM users;')\n            users = await cursor.fetchall()\n    page_context = {\n        'users': users\n    }\n    return await render_template('auth', request, userdata, 'users.html', page_context)\n\n\n@routes.post('\/users')\n@check_csrf_token\n@web_authenticated_developers_only()\nasync def post_create_user(request, userdata):  # pylint: disable=unused-argument\n    session = await aiohttp_session.get_session(request)\n    dbpool = request.app['dbpool']\n    post = await request.post()\n    username = post['username']\n    email = post['email']\n    is_developer = post.get('is_developer') == '1'\n\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\n                '''\nINSERT INTO users (state, username, email, is_developer)\nVALUES (%s, %s, %s, %s);\n''',\n                ('creating', username, email, is_developer))\n            user_id = cursor.lastrowid\n\n    set_message(session, f'Created user {user_id} {username}.', 'info')\n\n    return web.HTTPFound(deploy_config.external_url('auth', '\/users'))\n\n\n@routes.post('\/users\/delete')\n@check_csrf_token\n@web_authenticated_developers_only()\nasync def delete_user(request, userdata):  # pylint: disable=unused-argument\n    session = await aiohttp_session.get_session(request)\n    dbpool = request.app['dbpool']\n    post = await request.post()\n    id = post['id']\n    username = post['username']\n\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            n_rows = await cursor.execute(\n                '''\nUPDATE users\nSET state = 'deleting'\nWHERE id = %s AND username = %s;\n''',\n                (id, username))\n            if n_rows != 1:\n                assert n_rows == 0\n                set_message(session, f'Delete failed, no such user {id} {username}.', 'error')\n\n    set_message(session, f'Deleted user {id} {username}.', 'info')\n\n    return web.HTTPFound(deploy_config.external_url('auth', '\/users'))\n\n\n@routes.get('\/api\/v1alpha\/oauth2callback')\nasync def rest_callback(request):\n    state = request.query['state']\n    code = request.query['code']\n    callback_port = request.query['callback_port']\n\n    try:\n        flow = get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback', state=state)\n        flow.fetch_token(code=code)\n        token = google.oauth2.id_token.verify_oauth2_token(\n            flow.credentials.id_token, google.auth.transport.requests.Request())\n        email = token['email']\n    except Exception:\n        log.exception('fetching and decoding token')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\"SELECT * FROM users WHERE email = %s AND state = 'active';\", email)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    session_id = await create_session(dbpool, user['id'])\n\n    return web.json_response({\n        'token': session_id,\n        'username': user['username']\n    })\n\n\n@routes.post('\/api\/v1alpha\/logout')\n@rest_authenticated_users_only\nasync def rest_logout(request, userdata):\n    session_id = userdata['session_id']\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('DELETE FROM sessions WHERE session_id = %s;', session_id)\n\n    return web.Response(status=200)\n\n\n@routes.get('\/api\/v1alpha\/userinfo')\nasync def userinfo(request):\n    if 'Authorization' not in request.headers:\n        log.info('Authorization not in request.headers')\n        raise web.HTTPUnauthorized()\n\n    auth_header = request.headers['Authorization']\n    if not auth_header.startswith('Bearer '):\n        log.info('Bearer not in Authorization header')\n        raise web.HTTPUnauthorized()\n    session_id = auth_header[7:]\n\n    # b64 encoding of 32-byte session ID is 44 bytes\n    if len(session_id) != 44:\n        log.info('Session id != 44 bytes')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('''\nSELECT users.*, sessions.session_id FROM users\nINNER JOIN sessions ON users.id = sessions.user_id\nWHERE users.state = 'active' AND (sessions.session_id = %s) AND (ISNULL(sessions.max_age_secs) OR (NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created)));\n''', session_id)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        log.info(f'Unknown session id: {session_id}')\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    return web.json_response(user)\n\n\nasync def on_startup(app):\n    app['dbpool'] = await create_database_pool()\n\n\nasync def on_cleanup(app):\n    dbpool = app['dbpool']\n    dbpool.close()\n    await dbpool.wait_closed()\n\n\ndef run():\n    app = web.Application()\n\n    setup_aiohttp_jinja2(app, 'auth')\n    setup_aiohttp_session(app)\n\n    setup_common_static_routes(routes)\n    app.add_routes(routes)\n    app.on_startup.append(on_startup)\n    app.on_cleanup.append(on_cleanup)\n\n    web.run_app(deploy_config.prefix_application(app, 'auth'), host='0.0.0.0', port=5000)\n"}},"msg":"[auth] maybe fix auth flow & close security hole (#8052)\n\n* [auth] maybe fix auth flow & close security hole\n\nIt seems that sessions sometimes become inaccessible to auth. Using some\nlogging, I realized that `\/login` will set some session parameters that do not\nreappear in `\/oauth2callback`. While trying to debug this, I deleted my cookie\nand everything started working again. Luckily, my phone was still borked. The\nfix is to use `new_session` which I discovered with a big red warning in\naiohttp-session's docs: [Always use new_session() instead of get_session() in\nyour login views to guard against Session Fixation\nattacks!](https:\/\/aiohttp-session.readthedocs.io\/en\/stable\/reference.html#aiohttp_session.new_session).\n\nIf nothing else, we are now safe from session fixation attacks. I do not\nunderstand why this is necessary for correctness.\n\n* bump\n\n* bump"}},"https:\/\/github.com\/HarrisonSong\/cookie_management_security_scanner":{"f7c6f051bffda989acc51ddadfba602dd1097a08":{"url":"https:\/\/api.github.com\/repos\/HarrisonSong\/cookie_management_security_scanner\/commits\/f7c6f051bffda989acc51ddadfba602dd1097a08","html_url":"https:\/\/github.com\/HarrisonSong\/cookie_management_security_scanner\/commit\/f7c6f051bffda989acc51ddadfba602dd1097a08","sha":"f7c6f051bffda989acc51ddadfba602dd1097a08","keyword":"session fixation update","diff":"diff --git a\/App1\/automation.py b\/App1\/automation.py\ndeleted file mode 100644\nindex 22435ce..0000000\n--- a\/App1\/automation.py\n+++ \/dev\/null\n@@ -1,13 +0,0 @@\n-from selenium import webdriver\n-url = \"http:\/\/app1.com\"\n-wd = webdriver.Chrome()\n-\n-wd.get(url)\n-\n-# enable input and submit button\n-wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")\n-wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")\n-\n-# fill in -1 value in input and submit\n-wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)\n-wd.find_element_by_css_selector(\"form\").submit()\ndiff --git a\/App1\/phase3output.json b\/App1\/phase3output.json\nnew file mode 100644\nindex 0000000..e74cd9c\n--- \/dev\/null\n+++ b\/App1\/phase3output.json\n@@ -0,0 +1 @@\n+[{\"form_parameter\": {\"account\": \"username\", \"password\": \"password\", \"account_value\": \"bryce\", \"password_value\": \"bryce\"}, \"cookie\": {\"attack\": \"sessionFixation\", \"name\": \"PHPSESSID\", \"httpOnly\": false, \"secure\": false}, \"button\": \"login\", \"link\": \"https:\/\/app1.com\/users\/login.php\"}]\ndiff --git a\/App1\/starter.sh b\/App1\/starter.sh\ndeleted file mode 100755\nindex 4dc0306..0000000\n--- a\/App1\/starter.sh\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-#!\/bin\/bash\n-python 1.py\ndiff --git a\/attack_category_detector.py b\/attack_category_detector.py\nindex d3a07c9..a447084 100644\n--- a\/attack_category_detector.py\n+++ b\/attack_category_detector.py\n@@ -8,12 +8,12 @@ def __init__(self, attack_specs):\n     \"\"\"Return a Attack_category_detector object.\"\"\"\n     self.attacks_list = []\n     for index, attack in enumerate(attack_specs):\n-      if attack[\"cookie\"][\"attack\"][0].strip() == \"sessionFixation\":\n+      if attack[\"cookie\"][\"attack\"].strip() == \"sessionFixation\":\n         self.attacks_list.append(SessionFixationAttack(attack[\"link\"], attack[\"form_parameter\"], attack[\"button\"], attack[\"cookie\"]))\n-      elif attack[\"cookie\"][\"attack\"][0].strip() == \"sessionHijacking\":\n+      elif attack[\"cookie\"][\"attack\"].strip() == \"sessionHijacking\":\n         self.attacks_list.append(SessionHijackingAttack(attack[\"link\"], attack[\"form_parameter\"], attack[\"button\"], attack[\"cookie\"]))\n-      elif attack[\"cookie\"][\"attack\"][0].strip() == \"predictableCookie\":\n-        self.attacks_list.append(PredictableCookieAttack(attack[\"link\"], attack[\"form_parameter\"], attack[\"button\"], attack[\"cookie\"], \"predictableCookies\"))\n+      elif attack[\"cookie\"][\"attack\"].strip() == \"predictableCookie\":\n+        self.attacks_list.append(PredictableCookieAttack(attack[\"link\"], attack[\"form_parameter\"], attack[\"button\"], attack[\"cookie\"]))\n \n   def get_attacks_list(self):\n     return self.attacks_list\ndiff --git a\/attack_category_detector.sh b\/attack_category_detector.sh\ndeleted file mode 100644\nindex e69de29..0000000\ndiff --git a\/attacks.json b\/attacks.json\ndeleted file mode 100644\nindex 4f0a9cb..0000000\n--- a\/attacks.json\n+++ \/dev\/null\n@@ -1,50 +0,0 @@\n- [\n-  {\n-    \"link\": [\n-      \"https:\/\/app1.com\/admin\/index.php?page=login\"\n-    ],\n-    \"form_parameter\": [\n-      {\n-        \"account\": \"adminname\",\n-        \"account_value\": \"admin\",\n-        \"password\": \"password\",\n-        \"password_value\": \"admin\"\n-      }\n-    ],\n-    \"button\": [\n-      \"submit\"\n-    ],\n-    \"cookie\": [\n-      {\n-        \"name\":\"session\",\n-        \"secure\":false,\n-        \"httpOnly\":false,\n-        \"attack\": [\"sessionHijacking \",\"predictableCookies\"]\n-      }\n-    ]\n-  },\n-  {\n-    \"link\": [\n-      \"https:\/\/app1.com\/users\/login.php\"\n-    ],\n-    \"form_parameter\": [\n-      {\n-        \"account\": \"username\",\n-        \"account_value\": \"scanner1\",\n-        \"password\": \"password\",\n-        \"password_value\": \"scanner1\"\n-      }\n-    ],\n-    \"button\": [\n-      \"login\"\n-    ],\n-        \"cookie\": [\n-      {\n-        \"name\":\"PHPSESSION\",\n-        \"secure\":false,\n-        \"httpOnly\":false,\n-        \"attack\": [\"sessionFixation\"]\n-      }\n-    ]\n-  }\n-]\ndiff --git a\/test.py b\/automation_starter.py\nsimilarity index 64%\nrename from test.py\nrename to automation_starter.py\nindex 7cb7d7c..14013d7 100644\n--- a\/test.py\n+++ b\/automation_starter.py\n@@ -1,10 +1,11 @@\n import json\n from attack_category_detector import AttackCategoryDetector\n \n-attacks = open('phase3output.json')\n+attacks = open('App1\/phase3output.json')\n json_string = attacks.read().decode(\"utf-8-sig\")\n data = json.loads(json_string)\n detector = AttackCategoryDetector(data)\n \n for index, attack in enumerate(detector.get_attacks_list()):\n-  attack.perform()\n+  if attack.type == \"session_fixation\" or attack.type == \"session_hijacking\":\n+    attack.perform()\ndiff --git a\/mitm_session_fixation.py b\/mitm_scripts\/mitm_predictable_cookie_attack.py\nsimilarity index 100%\nrename from mitm_session_fixation.py\nrename to mitm_scripts\/mitm_predictable_cookie_attack.py\ndiff --git a\/mitm_scripts\/mitm_session_fixation.py b\/mitm_scripts\/mitm_session_fixation.py\nnew file mode 100644\nindex 0000000..1105dd1\n--- \/dev\/null\n+++ b\/mitm_scripts\/mitm_session_fixation.py\n@@ -0,0 +1,24 @@\n+import Cookie\n+import json\n+import os.path\n+\n+def request(context, flow):\n+  print flow.request.headers\n+  if os.path.isfile(\"tmp_cookie.txt\") :\n+    with open('tmp_cookie.txt', 'r') as f:\n+      cookie_name = f.read()\n+    print \"COOKIE NAME IS %s\" % cookie_name\n+    if \"Cookie\" in flow.request.headers :\n+      cookie = Cookie.SimpleCookie(flow.request.headers[\"Cookie\"])\n+      print \"request cookie is: %s\" % cookie[cookie_name].value\n+      cookie[cookie_name].set(cookie_name, \"12345\", \"12345\")\n+      print \"update request cookie is: %s\" % cookie.output()\n+      flow.request.headers[\"Cookie\"] = cookie.output().replace(\"Set-Cookie:\", \"\").strip()\n+      print(\"final updated request cookie: %s\" % (flow.request.headers[\"Cookie\"]))\n+  else :\n+    print \"No specific cookie need to investigate\"\n+\n+def response(context, flow):\n+  print flow.response.headers\n+  if \"Set-Cookie\" in flow.response.headers :\n+    print(\"response flag cookie: %s\" % (flow.response.headers[\"Set-Cookie\"]))\ndiff --git a\/mitm_scripts\/mitm_session_hijacking.py b\/mitm_scripts\/mitm_session_hijacking.py\nnew file mode 100644\nindex 0000000..6121b91\n--- \/dev\/null\n+++ b\/mitm_scripts\/mitm_session_hijacking.py\n@@ -0,0 +1,3 @@\n+def request(context, flow):\n+  if(flow.request.headers[\"Cookie\"]) :\n+    print(\"flag cookie: %s\" % (flow.request.headers[\"Cookie\"]))\ndiff --git a\/nohup.out b\/nohup.out\ndeleted file mode 100644\nindex 3a9ef73..0000000\n--- a\/nohup.out\n+++ \/dev\/null\n@@ -1,388 +0,0 @@\n-Error starting proxy server: error(48, 'Address already in use')\n-Error starting proxy server: error(48, 'Address already in use')\n-Error starting proxy server: error(48, 'Address already in use')\n-127.0.0.1:63450: clientconnect\n-127.0.0.1:63452: clientconnect\n-127.0.0.1:63455: clientconnect\n-127.0.0.1:63455: ProtocolException(\"Error in HTTP connection: HttpSyntaxException('Bad HTTP request line: \\\\x05\\\\x01\\\\x00',)\",)\n-127.0.0.1:63452: ProtocolException(\"Error in HTTP connection: HttpSyntaxException('Bad HTTP request line: \\\\x05\\\\x01\\\\x00',)\",)\n-127.0.0.1:63450: ProtocolException(\"Error in HTTP connection: HttpSyntaxException('Bad HTTP request line: \\\\x05\\\\x01\\\\x00',)\",)\n-127.0.0.1:63452: clientdisconnect\n-127.0.0.1:63455: clientdisconnect\n-127.0.0.1:63450: clientdisconnect\n-127.0.0.1:49348: clientconnect\n-127.0.0.1:49348: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49348: Ignoring server verification error, continuing with connection\n-Script error:\n-'Cookie'\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49350: clientconnect\n-127.0.0.1:49351: clientconnect\n-127.0.0.1:49352: clientconnect\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/screen.css\n- << 200 OK 2.62kB\n-127.0.0.1:49351: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49351: Ignoring server verification error, continuing with connection\n-127.0.0.1:49350: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49350: Ignoring server verification error, continuing with connection\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/stylings.css\n- << 200 OK 838B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/print.css\n- << 200 OK 674B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/images\/search_button_white.gif\n- << 200 OK 508B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/images\/menu\/menu_tabs.gif\n- << 200 OK 3.87kB\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 POST https:\/\/app1.com\/users\/login.php\n- << 303 See Other 0B\n-flag cookie: PHPSESSID=910v97jn0kr1a9vaf0k33uog71\n-updated flag cookie: 12345\n-127.0.0.1:49361: clientconnect\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/home.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=fqan4jb3ot14ehk58bl9pqiki2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49350: clientdisconnect\n-Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-mitmproxy has crashed!\n-Please lodge a bug report at: https:\/\/github.com\/mitmproxy\/mitmproxy\n-127.0.0.1:49351: clientdisconnect\n-127.0.0.1:49348: clientdisconnect\n-127.0.0.1:49352: Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-127.0.0.1:49352: clientdisconnect\n-127.0.0.1:49415: clientconnect\n-127.0.0.1:49415: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49415: Ignoring server verification error, continuing with connection\n-Script error:\n-'Cookie'\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49417: clientconnect\n-127.0.0.1:49418: clientconnect\n-127.0.0.1:49419: clientconnect\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/screen.css\n- << 200 OK 2.62kB\n-127.0.0.1:49420: clientconnect\n-127.0.0.1:49417: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49417: Ignoring server verification error, continuing with connection\n-127.0.0.1:49418: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49418: Ignoring server verification error, continuing with connection\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/print.css\n- << 200 OK 674B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/css\/stylings.css\n- << 200 OK 838B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/images\/search_button_white.gif\n- << 200 OK 508B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/images\/menu\/menu_tabs.gif\n- << 200 OK 3.87kB\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 POST https:\/\/app1.com\/users\/login.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=n5etrl84fpt5pulfhkbcl4e713\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/home.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eeiaq10qnejfrhnaflt9qm49t3\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-mitmproxy has crashed!\n-Please lodge a bug report at: https:\/\/github.com\/mitmproxy\/mitmproxy\n-127.0.0.1:49417: clientdisconnect\n-127.0.0.1:49418: clientdisconnect\n-127.0.0.1:49415: clientdisconnect\n-127.0.0.1:49419: Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-127.0.0.1:49419: clientdisconnect\n-127.0.0.1:49478: clientconnect\n-127.0.0.1:49478: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49478: Ignoring server verification error, continuing with connection\n-127.0.0.1:49480: clientconnect\n-Script error:\n-'Cookie'\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49482: clientconnect\n-127.0.0.1:49483: clientconnect\n-127.0.0.1:49484: clientconnect\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/screen.css\n- << 200 OK 2.62kB\n-127.0.0.1:49483: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49483: Ignoring server verification error, continuing with connection\n-127.0.0.1:49482: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49482: Ignoring server verification error, continuing with connection\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/stylings.css\n- << 200 OK 838B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/print.css\n- << 200 OK 674B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/images\/search_button_white.gif\n- << 200 OK 508B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/images\/menu\/menu_tabs.gif\n- << 200 OK 3.87kB\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 POST https:\/\/app1.com\/users\/login.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=8b4pvdr9orn6qg9h4ou2enrq42\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/home.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=3vgt3pdsajeicmtvctuiqg78n6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-mitmproxy has crashed!\n-Please lodge a bug report at: https:\/\/github.com\/mitmproxy\/mitmproxy\n-127.0.0.1:49482: clientdisconnect\n-127.0.0.1:49484: Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-127.0.0.1:49484: clientdisconnect\n-127.0.0.1:49483: clientdisconnect\n-127.0.0.1:49478: clientdisconnect\n-127.0.0.1:49535: clientconnect\n-127.0.0.1:49535: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49535: Ignoring server verification error, continuing with connection\n-127.0.0.1:49537: clientconnect\n-Script error:\n-'Cookie'\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49539: clientconnect\n-127.0.0.1:49540: clientconnect\n-127.0.0.1:49541: clientconnect\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/screen.css\n- << 200 OK 2.62kB\n-127.0.0.1:49539: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49539: Ignoring server verification error, continuing with connection\n-127.0.0.1:49540: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49540: Ignoring server verification error, continuing with connection\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/stylings.css\n- << 200 OK 838B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/print.css\n- << 200 OK 674B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/images\/search_button_white.gif\n- << 200 OK 508B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/images\/menu\/menu_tabs.gif\n- << 200 OK 3.87kB\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 POST https:\/\/app1.com\/users\/login.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=de0cqp7k5tuj5mjbh6b7s9ipa0\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/home.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=921qj45r065fq4808eeecoprm4\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-mitmproxy has crashed!\n-Please lodge a bug report at: https:\/\/github.com\/mitmproxy\/mitmproxy\n-127.0.0.1:49540: clientdisconnect\n-127.0.0.1:49539: clientdisconnect\n-127.0.0.1:49535: clientdisconnect\n-127.0.0.1:49541: Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-127.0.0.1:49541: clientdisconnect\ndiff --git a\/phase3output.json b\/phase3output.json\ndeleted file mode 100755\nindex 63f5704..0000000\n--- a\/phase3output.json\n+++ \/dev\/null\n@@ -1,18 +0,0 @@\n-[{\n-  \"form_parameter\":{\n-     \"account\":\"username\",\n-     \"password\":\"password\",\n-     \"account_value\":\"bryce\",\n-     \"password_value\":\"bryce\"\n-  },\n-  \"cookie\":{\n-     \"attack\":[\n-        \"sessionFixation\"\n-     ],\n-     \"name\":\"PHPSESSID\",\n-     \"httpOnly\":false,\n-     \"secure\":false\n-  },\n-  \"button\":\"login\",\n-  \"link\":\"https:\/\/app1.com\/users\/login.php\"\n-}]\ndiff --git a\/phase4output.json b\/phase4output.json\nindex effc557..e69de29 100644\n--- a\/phase4output.json\n+++ b\/phase4output.json\n@@ -1 +0,0 @@\n-[{\"cookie\": [{\"attack\": \"sessionFixation\", \"secure\": false, \"httpOnly\": false}], \"page\": \"https:\/\/app1.com\/users\/login.php\"}]\n\\ No newline at end of file\ndiff --git a\/scripts\/client\/6_client.py b\/scripts\/client\/6_client.py\ndeleted file mode 100644\nindex 29ba1a9..0000000\n--- a\/scripts\/client\/6_client.py\n+++ \/dev\/null\n@@ -1,4 +0,0 @@\n-import webbrowser\n-url = 'http:\/\/www.wsb.com\/Assignment2\/case06.php'\n-new = 2 #open in new window\n-webbrowser.open(url,new=new)\ndiff --git a\/scripts\/client\/6_client.sh b\/scripts\/client\/6_client.sh\ndeleted file mode 100644\nindex feb9dba..0000000\n--- a\/scripts\/client\/6_client.sh\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-#!\/bin\/bash\n-python 6_client.py\ndiff --git a\/scripts\/proxy\/6_proxy.sh b\/scripts\/proxy\/6_proxy.sh\ndeleted file mode 100644\nindex 6c34129..0000000\n--- a\/scripts\/proxy\/6_proxy.sh\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-#!\/bin\/bash\n-sudo .\/mitm.sh\ndiff --git a\/scripts\/proxy\/clean.sh b\/scripts\/proxy\/clean.sh\ndeleted file mode 100644\nindex 23c1dd3..0000000\n--- a\/scripts\/proxy\/clean.sh\n+++ \/dev\/null\n@@ -1,3 +0,0 @@\n-#!\/bin\/bash\n-sudo iptables -t nat -F\n-sudo sysctl -w net.ipv4.ip_forward=0\ndiff --git a\/scripts\/proxy\/mitm.sh b\/scripts\/proxy\/mitm.sh\ndeleted file mode 100644\nindex db044a0..0000000\n--- a\/scripts\/proxy\/mitm.sh\n+++ \/dev\/null\n@@ -1,5 +0,0 @@\n-#!\/bin\/bash\n-.\/clean.sh\n-sysctl -w net.ipv4.ip_forward=1\n-iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080\n-mitmdump -T --host -s request.py\ndiff --git a\/scripts\/proxy\/request.py b\/scripts\/proxy\/request.py\ndeleted file mode 100644\nindex c06af92..0000000\n--- a\/scripts\/proxy\/request.py\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-def request(context, flow):\n-\tprint(\"flag cookie: %s\" % (flow.request.headers[\"Cookie\"]))\ndiff --git a\/session_fixation_attack.py b\/session_fixation_attack.py\nindex 924220a..0779231 100644\n--- a\/session_fixation_attack.py\n+++ b\/session_fixation_attack.py\n@@ -31,21 +31,40 @@ def perform(self):\n         profile.set_preference(\"general.useragent.override\",\"Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit\/537.75.14 (KHTML, like Gecko) Version\/7.0.3 Safari\/7046A194A\")\n         profile.update_preferences()\n         wd = webdriver.Firefox(firefox_profile=profile)\n-        subprocess.Popen([\"nohup\", \"mitmdump\", \"-s\", \"mitm_session_fixation.py\"])\n+        #subprocess.Popen([\"nohup\", \"mitmdump\", \"-s\", \"mitm_scripts\/mitm_session_fixation.py\"])\n+        with open('tmp_cookie.txt', 'w+') as f:\n+            f.write(self.cookie[\"name\"])\n         time.sleep(1)\n+\n         wd.get(self.link)\n         wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"account\"] + \"']\").send_keys(self.form_parameter[\"account_value\"])\n         wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"password\"] + \"']\").send_keys(self.form_parameter[\"password_value\"])\n         wd.find_element_by_xpath(\"\/\/input[@value='\" + self.button + \"']\").click()\n         proceed_to_server_side_fixation_attack = False\n-        try:\n-            wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"account\"] + \"']\")\n-            wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"password\"] + \"']\")\n+        recived_cookie = \"\"\n+        for cookie in wd.get_cookies():\n+            if cookie[\"name\"] == self.cookie[\"name\"]:\n+                recived_cookie = cookie[\"value\"]\n+                break\n+        print \"recived_cookie is: %s \" % recived_cookie\n+        if recived_cookie == \"12345\":\n+            print \"CONFIRMED: login sucessfully. client side fixation attack successful.\"\n+            expliot = {\n+                \"page\": self.link,\n+                \"cookie\": [{\n+                    \"name\": self.cookie[\"name\"],\n+                    \"secure\": self.cookie[\"secure\"],\n+                    \"httpOnly\": self.cookie[\"httpOnly\"],\n+                    \"attack\": \"sessionFixation\"\n+                }]\n+            }\n+            self.phase4_output(expliot)\n+        else :\n             print \"CONFIRMED: login unsucessfully. client side fixation attack failed.\"\n             proceed_to_server_side_fixation_attack = True\n-        except NoSuchElementException:\n-            print \"CONFIRMED: login sucessfully. client side fixation attack successful.\"\n-        subprocess.Popen(\"kill $(ps -efw | grep mitmdump | grep -v grep | awk '{print $2}')\", shell=True)\n+        #subprocess.Popen(\"kill $(ps -efw | grep mitmdump | grep -v grep | awk '{print $2}')\", shell=True)\n+        subprocess.Popen(\"rm nohup.out\", shell=True)\n+        subprocess.Popen(\"rm tmp_cookie.txt\", shell=True)\n         wd.close()\n \n         if proceed_to_server_side_fixation_attack :\n@@ -73,6 +92,7 @@ def perform(self):\n                     expliot = {\n                         \"page\": self.link,\n                         \"cookie\": [{\n+                            \"name\": self.cookie[\"name\"],\n                             \"secure\": self.cookie[\"secure\"],\n                             \"httpOnly\": self.cookie[\"httpOnly\"],\n                             \"attack\": \"sessionFixation\"\ndiff --git a\/session_hijacking_attack.py b\/session_hijacking_attack.py\nindex 32dc2ef..c206e7c 100644\n--- a\/session_hijacking_attack.py\n+++ b\/session_hijacking_attack.py\n@@ -3,6 +3,11 @@\n from selenium.webdriver.common.by import By\n from selenium.webdriver.support.ui import WebDriverWait\n from selenium.webdriver.support import expected_conditions as EC\n+from selenium.common.exceptions import NoSuchElementException\n+import subprocess\n+import time\n+import json\n+import os\n \n class SessionHijackingAttack(Attack):\n   def __init__(self, link, form_parameter, button, cookie):\n@@ -10,19 +15,45 @@ def __init__(self, link, form_parameter, button, cookie):\n \n   def perform(self):\n     print \"start session_hijacking_attack.\"\n-    wd = webdriver.Chrome()\n+    print \"=============== TRY: session hijacking attack ========================\"\n+    profile = webdriver.FirefoxProfile()\n+    profile.set_preference(\"network.proxy.type\", 1)\n+    profile.set_preference(\"network.proxy.http\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.https\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.ssl\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.ftp\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.socks\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.http_port\", 8080)\n+    profile.set_preference(\"networky.proxy.https_port\", 8080)\n+    profile.set_preference(\"network.proxy.ssl_port\", 8080)\n+    profile.set_preference(\"network.proxy.ftp_port\", 8080)\n+    profile.set_preference(\"network.proxy.socks_port\", 8080)\n+    profile.set_preference(\"general.useragent.override\",\"Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit\/537.75.14 (KHTML, like Gecko) Version\/7.0.3 Safari\/7046A194A\")\n+    profile.update_preferences()\n+    wd = webdriver.Firefox(firefox_profile=profile)\n+    subprocess.Popen([\"nohup\", \"mitmdump\", \"-s\", \"mitm_scripts\/mitm_session_hijacking.py\"])\n+    time.sleep(1)\n+    wd.get(self.link)\n+    wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"account\"] + \"']\").send_keys(self.form_parameter[\"account_value\"])\n+    wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"password\"] + \"']\").send_keys(self.form_parameter[\"password_value\"])\n+    wd.find_element_by_xpath(\"\/\/input[@value='\" + self.button + \"']\").click()\n+    print \"CONFIRMED: session hijacking attack successful.\"\n+    subprocess.Popen(\"kill $(ps -efw | grep mitmdump | grep -v grep | awk '{print $2}')\", shell=True)\n+    subprocess.Popen(\"rm nohup.out\", shell=True)\n+    subprocess.Popen(\"rm tmp_cookie.txt\", shell=True)\n+    wd.close()\n \n-    wd.get(self.link[0])\n-    wd.find_element_by_css_selector(\"input[name=\" + self.form_parameter[0][\"account\"] + \"]\").send_keys(self.form_parameter[0][\"account_value\"])\n-    wd.find_element_by_css_selector(\"input[name=\" + self.form_parameter[0][\"password\"] + \"]\").send_keys(self.form_parameter[0][\"password_value\"])\n-    wd.find_element_by_css_selector(\"input[value=\" + self.button[0] + \"]\").click()\n-    fixed_cookie = \"\"\n-    for cookie in wd.get_cookies():\n-        if cookie[\"name\"] == self.cookie[0][\"name\"]:\n-            fixed_cookie = cookie[\"value\"]\n-            break\n-    print fixed_cookie\n-\n-    WebDriverWait(wd, 10).until(\n-        EC.presence_of_element_located((By.ID, \"myDynamicElement\"))\n-    )\n+    def phase4_output(self, source):\n+        try:\n+            if os.stat(\"phase4output.json\").st_size > 0:\n+                with open('phase4output.json') as f:\n+                    data = json.load(f)\n+                data.append(source)\n+                with open('phase4output.json', 'w') as f:\n+                    json.dump(data, f)\n+            else:\n+                with open('phase4output.json', 'w') as f:\n+                    json.dump([source], f)\n+        except OSError:\n+            with open('phase4output.json', 'w+') as f:\n+                json.dump([source], f)\n","message":"","files":{"\/App1\/automation.py":{"changes":[{"diff":"\n-from selenium import webdriver\n-url = \"http:\/\/app1.com\"\n-wd = webdriver.Chrome()\n-\n-wd.get(url)\n-\n-# enable input and submit button\n-wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")\n-wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")\n-\n-# fill in -1 value in input and submit\n-wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)\n-wd.find_element_by_css_selector(\"form\").submit()","add":0,"remove":13,"filename":"\/App1\/automation.py","badparts":["from selenium import webdriver","url = \"http:\/\/app1.com\"","wd = webdriver.Chrome()","wd.get(url)","wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")","wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")","wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)","wd.find_element_by_css_selector(\"form\").submit()"],"goodparts":[]},{"diff":"\n-from selenium import webdriver\n-url = \"http:\/\/app1.com\"\n-wd = webdriver.Chrome()\n-\n-wd.get(url)\n-\n-# enable input and submit button\n-wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")\n-wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")\n-\n-# fill in -1 value in input and submit\n-wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)\n-wd.find_element_by_css_selector(\"form\").submit()","add":0,"remove":13,"filename":"\/App1\/automation.py","badparts":["from selenium import webdriver","url = \"http:\/\/app1.com\"","wd = webdriver.Chrome()","wd.get(url)","wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")","wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")","wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)","wd.find_element_by_css_selector(\"form\").submit()"],"goodparts":[]}],"source":"\nfrom selenium import webdriver url=\"http:\/\/app1.com\" wd=webdriver.Chrome() wd.get(url) wd.execute_script(\"document.getElementsByTagName('input')[0].disabled=false\") wd.execute_script(\"document.getElementsByTagName('input')[1].disabled=false\") wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1) wd.find_element_by_css_selector(\"form\").submit() ","sourceWithComments":"from selenium import webdriver\nurl = \"http:\/\/app1.com\"\nwd = webdriver.Chrome()\n\nwd.get(url)\n\n# enable input and submit button\nwd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")\nwd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")\n\n# fill in -1 value in input and submit\nwd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)\nwd.find_element_by_css_selector(\"form\").submit()\n"}},"msg":"update session_fixation automation"}},"https:\/\/github.com\/usingnamespace\/pyramid_pluggable_session":{"27dcea599b6307878bf904c736b83a875fa4e9f2":{"url":"https:\/\/api.github.com\/repos\/usingnamespace\/pyramid_pluggable_session\/commits\/27dcea599b6307878bf904c736b83a875fa4e9f2","html_url":"https:\/\/github.com\/usingnamespace\/pyramid_pluggable_session\/commit\/27dcea599b6307878bf904c736b83a875fa4e9f2","message":"Add more cases where we regenerate the session id\n\nIn an attempt to stop session fixation attacks, we want to make sure we\ndon't reuse the same session ID after it has expired, or the backend\ndata failed to to unpack\/deserialize.","sha":"27dcea599b6307878bf904c736b83a875fa4e9f2","keyword":"session fixation attack","diff":"diff --git a\/pyramid_pluggable_session\/__init__.py b\/pyramid_pluggable_session\/__init__.py\nindex a2b16cc..b2e0264 100644\n--- a\/pyramid_pluggable_session\/__init__.py\n+++ b\/pyramid_pluggable_session\/__init__.py\n@@ -204,6 +204,7 @@ def __init__(self, request):\n                     value = None\n                     # Cleanup the session, since it failed to deserialize\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n             if value is not None:\n                 try:\n@@ -218,6 +219,7 @@ def __init__(self, request):\n                     state = {}\n                     # Clean up the session since it failed to unpack\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n             if self._timeout is not None:\n                 if now - renewed > self._timeout:\n@@ -226,9 +228,11 @@ def __init__(self, request):\n                     state = {}\n                     # Session expired, cleanup this session\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n+            # Generate a new session id\n             if self._session_id is None:\n-                self._session_id = text_(binascii.hexlify(os.urandom(20)))\n+                self._generate_new_id()\n \n             self.created = created\n             self.accessed = renewed\n@@ -324,6 +328,9 @@ def _save_session(self, response):\n \n             return True\n \n+        def _generate_new_id(self):\n+            self._session_id = text_(binascii.hexlify(os.urandom(20)))\n+\n     return PluggableSession\n \n \n","files":{"\/pyramid_pluggable_session\/__init__.py":{"changes":[{"diff":"\n                     state = {}\n                     # Session expired, cleanup this session\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n+            # Generate a new session id\n             if self._session_id is None:\n-                self._session_id = text_(binascii.hexlify(os.urandom(20)))\n+                self._generate_new_id()\n \n             self.created = created\n             self.accessed = renewed\n","add":3,"remove":1,"filename":"\/pyramid_pluggable_session\/__init__.py","badparts":["                self._session_id = text_(binascii.hexlify(os.urandom(20)))"],"goodparts":["                    self._session_id = None","                self._generate_new_id()"]},{"diff":"\n                     state = {}\n                     # Session expired, cleanup this session\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n+            # Generate a new session id\n             if self._session_id is None:\n-                self._session_id = text_(binascii.hexlify(os.urandom(20)))\n+                self._generate_new_id()\n \n             self.created = created\n             self.accessed = renewed\n","add":3,"remove":1,"filename":"\/pyramid_pluggable_session\/__init__.py","badparts":["                self._session_id = text_(binascii.hexlify(os.urandom(20)))"],"goodparts":["                    self._session_id = None","                self._generate_new_id()"]}],"source":"\nimport base64 import binascii import hashlib import hmac import os import time from webob.cookies import( SignedCookieProfile as CookieHelper, SignedSerializer, ) from zope.interface import implementer from pyramid.interfaces import ISession from pyramid.settings import( asbool, aslist, ) from pyramid.session import( manage_accessed, manage_changed, PickleSerializer, ) from pyramid.compat import( PY3, text_, bytes_, native_, ) from.interfaces import IPlugSession def PluggableSessionFactory( secret, cookie_name='session', max_age=None, path='\/', domain=None, secure=False, httponly=False, set_on_exception=True, timeout=1200, reissue_time=0, hashalg='sha512', salt='pyramid_pluggable_session.', serializer=None, ): \"\"\" .. versionadded:: 1.5 Configure a:term:`session factory` which will provide signed cookie-based sessions. The return value of this function is a:term:`session factory`, which may be provided as the ``session_factory`` argument of a :class:`pyramid.config.Configurator` constructor, or used as the ``session_factory`` argument of the :meth:`pyramid.config.Configurator.set_session_factory` method. The session factory returned by this function will create sessions which are limited to storing fewer than 4000 bytes of data(as the payload must fit into a single cookie). Parameters: ``secret`` A string which is used to sign the cookie. The secret should be at least as long as the block size of the selected hash algorithm. For ``sha512`` this would mean a 128 bit(64 character) secret. It should be unique within the set of secret values provided to Pyramid for its various subsystems(see:ref:`admonishment_against_secret_sharing`). ``hashalg`` The HMAC digest algorithm to use for signing. The algorithm must be supported by the:mod:`hashlib` library. Default: ``'sha512'``. ``salt`` A namespace to avoid collisions between different uses of a shared secret. Reusing a secret for different parts of an application is strongly discouraged(see:ref:`admonishment_against_secret_sharing`). Default: ``'pyramid.session.'``. ``cookie_name`` The name of the cookie used for sessioning. Default: ``'session'``. ``max_age`` The maximum age of the cookie used for sessioning(in seconds). Default: ``None``(browser scope). ``path`` The path used for the session cookie. Default: ``'\/'``. ``domain`` The domain used for the session cookie. Default: ``None``(no domain). ``secure`` The 'secure' flag of the session cookie. Default: ``False``. ``httponly`` Hide the cookie from Javascript by setting the 'HttpOnly' flag of the session cookie. Default: ``False``. ``timeout`` A number of seconds of inactivity before a session times out. If ``None`` then the cookie never expires. This lifetime only applies to the *value* within the cookie. Meaning that if the cookie expires due to a lower ``max_age``, then this setting has no effect. Default: ``1200``. ``reissue_time`` The number of seconds that must pass before the cookie is automatically reissued as the result of accessing the session. The duration is measured as the number of seconds since the last session cookie was issued and 'now'. If this value is ``0``, a new cookie will be reissued on every request accessing the session. If ``None`` then the cookie's lifetime will never be extended. A good rule of thumb: if you want auto-expired cookies based on inactivity: set the ``timeout`` value to 1200(20 mins) and set the ``reissue_time`` value to perhaps a tenth of the ``timeout`` value (120 or 2 mins). It's nonsensical to set the ``timeout`` value lower than the ``reissue_time`` value, as the ticket will never be reissued. However, such a configuration is not explicitly prevented. Default: ``0``. ``set_on_exception`` If ``True``, set a session cookie even if an exception occurs while rendering a view. Default: ``True``. ``serializer`` An object with two methods: ``loads`` and ``dumps``. The ``loads`` method should accept bytes and return a Python object. The ``dumps`` method should accept a Python object and return bytes. A ``ValueError`` should be raised for malformed inputs. If a serializer is not passed, the:class:`pyramid.session.PickleSerializer` serializer will be used. \"\"\" if serializer is None: serializer=PickleSerializer() signed_serializer=SignedSerializer( secret +'_internal_use', salt +'_internal_use', hashalg, serializer=serializer, ) serializer=signed_serializer @implementer(ISession) class PluggableSession(dict): \"\"\" Dictionary-like session object \"\"\" _cookie_on_exception=set_on_exception _timeout=timeout _reissue_time=reissue_time _dirty=False def __init__(self, request): self._cookie=CookieHelper( secret, salt, cookie_name, secure=secure, max_age=max_age, httponly=httponly, path=path, domains=domain, hashalg=hashalg, ) self._session_id=None self.request=request reg=request.registry plug=reg.queryUtility(IPlugSession) if plug is None: raise RuntimeError('Unable to find any registered IPlugSession') now=time.time() created=renewed=now new=True value=None state={} self._session_id=self._cookie.bind(request).get_value() if self._session_id is not None: try: sess_val=plug.loads(self, request) value=serializer.loads(bytes_(sess_val)) except ValueError: value=None plug.clear(self, request) if value is not None: try: rval, cval, sval=value renewed=float(rval) created=float(cval) state=sval new=False except(TypeError, ValueError): state={} plug.clear(self, request) if self._timeout is not None: if now -renewed > self._timeout: state={} plug.clear(self, request) if self._session_id is None: self._session_id=text_(binascii.hexlify(os.urandom(20))) self.created=created self.accessed=renewed self.renewed=renewed self.new=new self._plug=plug dict.__init__(self, state) def changed(self): if not self._dirty: self._dirty=True def save_session_callback(request, response): self._save_session(response) self.request=None self.request.add_response_callback(save_session_callback) def invalidate(self): self._plug.clear(self, self.request) self.clear() get=manage_accessed(dict.get) __getitem__=manage_accessed(dict.__getitem__) items=manage_accessed(dict.items) values=manage_accessed(dict.values) keys=manage_accessed(dict.keys) __contains__=manage_accessed(dict.__contains__) __len__=manage_accessed(dict.__len__) __iter__=manage_accessed(dict.__iter__) if not PY3: iteritems=manage_accessed(dict.iteritems) itervalues=manage_accessed(dict.itervalues) iterkeys=manage_accessed(dict.iterkeys) has_key=manage_accessed(dict.has_key) clear=manage_changed(dict.clear) update=manage_changed(dict.update) setdefault=manage_changed(dict.setdefault) pop=manage_changed(dict.pop) popitem=manage_changed(dict.popitem) __setitem__=manage_changed(dict.__setitem__) __delitem__=manage_changed(dict.__delitem__) @manage_changed def flash(self, msg, queue='', allow_duplicate=True): storage=self.setdefault('_f_' +queue,[]) if allow_duplicate or(msg not in storage): storage.append(msg) @manage_changed def pop_flash(self, queue=''): storage=self.pop('_f_' +queue,[]) return storage @manage_accessed def peek_flash(self, queue=''): storage=self.get('_f_' +queue,[]) return storage @manage_changed def new_csrf_token(self): token=text_(binascii.hexlify(os.urandom(20))) self['_csrft_']=token return token @manage_accessed def get_csrf_token(self): token=self.get('_csrft_', None) if token is None: token=self.new_csrf_token() return token def _save_session(self, response): if not self._cookie_on_exception: exception=getattr(self.request, 'exception', None) if exception is not None: return False sess_val=native_( serializer.dumps( (self.accessed, self.created, dict(self)) ) ) self._plug.dumps(self, self.request, sess_val) self._cookie.set_cookies(response, self._session_id) return True return PluggableSession required_settings=[ 'secret', ] default_settings=[ ('cookie_name', str, 'session'), ('max_age', int, '864000'), ('path', str, '\/'), ('domain', aslist, ''), ('secure', asbool, 'false'), ('httponly', asbool, 'true'), ('set_on_exception', asbool, 'true'), ('timeout', int, '1200'), ('reissue_time', int, '0'), ('hashalg', str, 'sha512'), ('salt', str, 'pyramid_pluggable_session.'), ('serializer', str, ''), ] def parse_settings(settings): parsed={} def populate(name, convert, default): sname='%s%s' %('pluggable_session.', name) value=convert(settings.get(sname, default)) parsed[name]=value for name, convert, default in default_settings: populate(name, convert, default) return parsed def set_session_plug(config, dotted): \"\"\" Set the pluggable session that should be used... \"\"\" dotted=config.maybe_dotted(dotted) config.registry.registerUtility(dotted(config), IPlugSession) def includeme(config): for _required in required_settings: _required='pluggable_session.' +_required if not _required in config.registry.settings: raise ValueError(_required +' has to be set in config.settings') settings=parse_settings(config.registry.settings) if not settings['domain']: del settings['domain'] if not settings['serializer']: del settings['serializer'] else: settings['serializer']=config.maybe_dotted(settings['serializer']) _session_factory=PluggableSessionFactory( config.registry.settings['pluggable_session.secret'], **settings ) config.set_session_factory(_session_factory) config.add_directive('set_session_plug', set_session_plug) if 'pluggable_session.plug' in config.registry.settings: config.set_session_plug(config.registry.settings['pluggable_session.plug']) ","sourceWithComments":"import base64\nimport binascii\nimport hashlib\nimport hmac\nimport os\nimport time\n\nfrom webob.cookies import (\n        SignedCookieProfile as CookieHelper,\n        SignedSerializer,\n        )\n\nfrom zope.interface import implementer\nfrom pyramid.interfaces import ISession\n\nfrom pyramid.settings import (\n        asbool,\n        aslist,\n        )\n\nfrom pyramid.session import (\n    manage_accessed,\n    manage_changed,\n    PickleSerializer,\n    )\n\nfrom pyramid.compat import (\n    PY3,\n    text_,\n    bytes_,\n    native_,\n    )\n\nfrom .interfaces import IPlugSession\n\n# Most of this code was shamelessly lifted from pyramid\/session.py, all\n# original code is under the Pyramid LICENSE, modifications are under BSD\n\ndef PluggableSessionFactory(\n    secret,\n    cookie_name='session',\n    max_age=None,\n    path='\/',\n    domain=None,\n    secure=False,\n    httponly=False,\n    set_on_exception=True,\n    timeout=1200,\n    reissue_time=0,\n    hashalg='sha512',\n    salt='pyramid_pluggable_session.',\n    serializer=None,\n    ):\n    \"\"\"\n    .. versionadded:: 1.5\n\n    Configure a :term:`session factory` which will provide signed\n    cookie-based sessions.  The return value of this\n    function is a :term:`session factory`, which may be provided as\n    the ``session_factory`` argument of a\n    :class:`pyramid.config.Configurator` constructor, or used\n    as the ``session_factory`` argument of the\n    :meth:`pyramid.config.Configurator.set_session_factory`\n    method.\n\n    The session factory returned by this function will create sessions\n    which are limited to storing fewer than 4000 bytes of data (as the\n    payload must fit into a single cookie).\n\n    Parameters:\n\n    ``secret``\n      A string which is used to sign the cookie. The secret should be at\n      least as long as the block size of the selected hash algorithm. For\n      ``sha512`` this would mean a 128 bit (64 character) secret.  It should\n      be unique within the set of secret values provided to Pyramid for\n      its various subsystems (see :ref:`admonishment_against_secret_sharing`).\n\n    ``hashalg``\n      The HMAC digest algorithm to use for signing. The algorithm must be\n      supported by the :mod:`hashlib` library. Default: ``'sha512'``.\n\n    ``salt``\n      A namespace to avoid collisions between different uses of a shared\n      secret. Reusing a secret for different parts of an application is\n      strongly discouraged (see :ref:`admonishment_against_secret_sharing`).\n      Default: ``'pyramid.session.'``.\n\n    ``cookie_name``\n      The name of the cookie used for sessioning. Default: ``'session'``.\n\n    ``max_age``\n      The maximum age of the cookie used for sessioning (in seconds).\n      Default: ``None`` (browser scope).\n\n    ``path``\n      The path used for the session cookie. Default: ``'\/'``.\n\n    ``domain``\n      The domain used for the session cookie.  Default: ``None`` (no domain).\n\n    ``secure``\n      The 'secure' flag of the session cookie. Default: ``False``.\n\n    ``httponly``\n      Hide the cookie from Javascript by setting the 'HttpOnly' flag of the\n      session cookie. Default: ``False``.\n\n    ``timeout``\n      A number of seconds of inactivity before a session times out. If\n      ``None`` then the cookie never expires. This lifetime only applies\n      to the *value* within the cookie. Meaning that if the cookie expires\n      due to a lower ``max_age``, then this setting has no effect.\n      Default: ``1200``.\n\n    ``reissue_time``\n      The number of seconds that must pass before the cookie is automatically\n      reissued as the result of accessing the session. The\n      duration is measured as the number of seconds since the last session\n      cookie was issued and 'now'.  If this value is ``0``, a new cookie\n      will be reissued on every request accessing the session. If ``None``\n      then the cookie's lifetime will never be extended.\n\n      A good rule of thumb: if you want auto-expired cookies based on\n      inactivity: set the ``timeout`` value to 1200 (20 mins) and set the\n      ``reissue_time`` value to perhaps a tenth of the ``timeout`` value\n      (120 or 2 mins).  It's nonsensical to set the ``timeout`` value lower\n      than the ``reissue_time`` value, as the ticket will never be reissued.\n      However, such a configuration is not explicitly prevented.\n\n      Default: ``0``.\n\n    ``set_on_exception``\n      If ``True``, set a session cookie even if an exception occurs\n      while rendering a view. Default: ``True``.\n\n    ``serializer``\n      An object with two methods: ``loads`` and ``dumps``.  The ``loads``\n      method should accept bytes and return a Python object.  The ``dumps``\n      method should accept a Python object and return bytes.  A ``ValueError``\n      should be raised for malformed inputs.  If a serializer is not passed,\n      the :class:`pyramid.session.PickleSerializer` serializer will be used.\n    \"\"\"\n\n    if serializer is None:\n        serializer = PickleSerializer()\n\n    signed_serializer = SignedSerializer(\n            secret + '_internal_use',\n            salt + '_internal_use',\n            hashalg,\n            serializer=serializer,\n        )\n\n    serializer = signed_serializer\n\n    @implementer(ISession)\n    class PluggableSession(dict):\n        \"\"\" Dictionary-like session object \"\"\"\n\n        # configuration parameters\n        _cookie_on_exception = set_on_exception\n        _timeout = timeout\n        _reissue_time = reissue_time\n\n        # dirty flag\n        _dirty = False\n\n        def __init__(self, request):\n            self._cookie = CookieHelper(\n                secret,\n                salt,\n                cookie_name,\n                secure=secure,\n                max_age=max_age,\n                httponly=httponly,\n                path=path,\n                domains=domain,\n                hashalg=hashalg,\n            )\n            self._session_id = None\n            self.request = request\n\n            reg = request.registry\n            plug = reg.queryUtility(IPlugSession)\n\n            if plug is None:\n                raise RuntimeError('Unable to find any registered IPlugSession')\n\n            now = time.time()\n            created = renewed = now\n            new = True\n            value = None\n            state = {}\n\n            # Get the session_id\n            self._session_id = self._cookie.bind(request).get_value()\n\n            if self._session_id is not None:\n                try:\n                    sess_val = plug.loads(self, request)\n                    value = serializer.loads(bytes_(sess_val))\n                except ValueError:\n                    value = None\n                    # Cleanup the session, since it failed to deserialize\n                    plug.clear(self, request)\n\n            if value is not None:\n                try:\n                    rval, cval, sval = value\n                    renewed = float(rval)\n                    created = float(cval)\n                    state = sval\n                    new = False\n                except (TypeError, ValueError):\n                    # value failed to unpack properly or renewed was not\n                    # a numeric type so we'll fail deserialization here\n                    state = {}\n                    # Clean up the session since it failed to unpack\n                    plug.clear(self, request)\n\n            if self._timeout is not None:\n                if now - renewed > self._timeout:\n                    # expire the session because it was not renewed\n                    # before the timeout threshold\n                    state = {}\n                    # Session expired, cleanup this session\n                    plug.clear(self, request)\n\n            if self._session_id is None:\n                self._session_id = text_(binascii.hexlify(os.urandom(20)))\n\n            self.created = created\n            self.accessed = renewed\n            self.renewed = renewed\n            self.new = new\n            self._plug = plug\n            dict.__init__(self, state)\n\n        # ISession methods\n        def changed(self):\n            if not self._dirty:\n                self._dirty = True\n                def save_session_callback(request, response):\n                    self._save_session(response)\n                    self.request = None # explicitly break cycle for gc\n                self.request.add_response_callback(save_session_callback)\n\n        def invalidate(self):\n            self._plug.clear(self, self.request)\n            self.clear()\n\n        # non-modifying dictionary methods\n        get = manage_accessed(dict.get)\n        __getitem__ = manage_accessed(dict.__getitem__)\n        items = manage_accessed(dict.items)\n        values = manage_accessed(dict.values)\n        keys = manage_accessed(dict.keys)\n        __contains__ = manage_accessed(dict.__contains__)\n        __len__ = manage_accessed(dict.__len__)\n        __iter__ = manage_accessed(dict.__iter__)\n\n        if not PY3:\n            iteritems = manage_accessed(dict.iteritems)\n            itervalues = manage_accessed(dict.itervalues)\n            iterkeys = manage_accessed(dict.iterkeys)\n            has_key = manage_accessed(dict.has_key)\n\n        # modifying dictionary methods\n        clear = manage_changed(dict.clear)\n        update = manage_changed(dict.update)\n        setdefault = manage_changed(dict.setdefault)\n        pop = manage_changed(dict.pop)\n        popitem = manage_changed(dict.popitem)\n        __setitem__ = manage_changed(dict.__setitem__)\n        __delitem__ = manage_changed(dict.__delitem__)\n\n        # flash API methods\n        @manage_changed\n        def flash(self, msg, queue='', allow_duplicate=True):\n            storage = self.setdefault('_f_' + queue, [])\n            if allow_duplicate or (msg not in storage):\n                storage.append(msg)\n\n        @manage_changed\n        def pop_flash(self, queue=''):\n            storage = self.pop('_f_' + queue, [])\n            return storage\n\n        @manage_accessed\n        def peek_flash(self, queue=''):\n            storage = self.get('_f_' + queue, [])\n            return storage\n\n        # CSRF API methods\n        @manage_changed\n        def new_csrf_token(self):\n            token = text_(binascii.hexlify(os.urandom(20)))\n            self['_csrft_'] = token\n            return token\n\n        @manage_accessed\n        def get_csrf_token(self):\n            token = self.get('_csrft_', None)\n            if token is None:\n                token = self.new_csrf_token()\n            return token\n\n        # non-API methods\n        def _save_session(self, response):\n            if not self._cookie_on_exception:\n                exception = getattr(self.request, 'exception', None)\n                if exception is not None: # dont set a cookie during exceptions\n                    return False\n\n            sess_val = native_(\n                    serializer.dumps(\n                            (self.accessed, self.created, dict(self))\n                        )\n                    )\n\n            self._plug.dumps(self, self.request, sess_val)\n            self._cookie.set_cookies(response, self._session_id)\n\n            return True\n\n    return PluggableSession\n\n\nrequired_settings =  [\n        'secret',\n        ]\n\ndefault_settings = [\n    ('cookie_name', str, 'session'),\n    ('max_age', int, '864000'),\n    ('path', str, '\/'),\n    ('domain', aslist, ''),\n    ('secure', asbool, 'false'),\n    ('httponly', asbool, 'true'),\n    ('set_on_exception', asbool, 'true'),\n    ('timeout', int, '1200'),\n    ('reissue_time', int, '0'),\n    ('hashalg', str, 'sha512'),\n    ('salt', str, 'pyramid_pluggable_session.'),\n    ('serializer', str, ''),\n]\n\ndef parse_settings(settings):\n    parsed = {}\n\n    def populate(name, convert, default):\n        sname = '%s%s' % ('pluggable_session.', name)\n        value = convert(settings.get(sname, default))\n        parsed[name] = value\n\n    for name, convert, default in default_settings:\n        populate(name, convert, default)\n    return parsed\n\ndef set_session_plug(config, dotted):\n    \"\"\" Set the pluggable session that should be used...\n    \"\"\"\n\n    dotted = config.maybe_dotted(dotted)\n    config.registry.registerUtility(dotted(config), IPlugSession)\n\ndef includeme(config):\n    # We can't continue unless at least this is set...\n    for _required in required_settings:\n        _required = 'pluggable_session.' + _required\n        if not _required in config.registry.settings:\n            raise ValueError(_required +' has to be set in config.settings')\n\n    # Get all of the settings into a neat little dictionary\n    settings = parse_settings(config.registry.settings)\n\n    if not settings['domain']:\n        del settings['domain']\n\n    if not settings['serializer']:\n        del settings['serializer']\n    else:\n        settings['serializer'] = config.maybe_dotted(settings['serializer'])\n\n    _session_factory = PluggableSessionFactory(\n                config.registry.settings['pluggable_session.secret'],\n                **settings\n            )\n    config.set_session_factory(_session_factory)\n    config.add_directive('set_session_plug', set_session_plug)\n\n    if 'pluggable_session.plug' in config.registry.settings:\n        config.set_session_plug(config.registry.settings['pluggable_session.plug'])\n\n"}},"msg":"Add more cases where we regenerate the session id\n\nIn an attempt to stop session fixation attacks, we want to make sure we\ndon't reuse the same session ID after it has expired, or the backend\ndata failed to to unpack\/deserialize."}},"https:\/\/github.com\/CAMBI-tech\/BciPy":{"34887278308431aac991d8847066b676cff25115":{"url":"https:\/\/api.github.com\/repos\/CAMBI-tech\/BciPy\/commits\/34887278308431aac991d8847066b676cff25115","html_url":"https:\/\/github.com\/CAMBI-tech\/BciPy\/commit\/34887278308431aac991d8847066b676cff25115","message":"#181489190 ; updated stimuli labels in copy phrase session to ensure that fixation stimuli are labeled as 'fixation' rather than 'nontarget'","sha":"34887278308431aac991d8847066b676cff25115","keyword":"session fixation update","diff":"diff --git a\/bcipy\/helpers\/task.py b\/bcipy\/helpers\/task.py\nindex 33aae84f..31be263f 100644\n--- a\/bcipy\/helpers\/task.py\n+++ b\/bcipy\/helpers\/task.py\n@@ -1,16 +1,16 @@\n import logging\n import os\n import random\n-\n from string import ascii_uppercase\n from typing import Any, List, Tuple, Union\n \n-from bcipy.helpers.clock import Clock\n-from bcipy.task.exceptions import InsufficientDataException\n-\n import numpy as np\n from psychopy import core, event, visual\n \n+from bcipy.helpers.clock import Clock\n+from bcipy.helpers.stimuli import get_fixation\n+from bcipy.task.exceptions import InsufficientDataException\n+\n log = logging.getLogger(__name__)\n \n SPACE_CHAR = '_'\n@@ -125,24 +125,23 @@ def construct_triggers(inquiry_timing: List[List]) -> List[Tuple[str, float]]:\n \n \n def target_info(triggers: List[Tuple[str, float]],\n-                target_letter: str = None) -> List[str]:\n+                target_letter: str = None,\n+                is_txt: bool = True) -> List[str]:\n     \"\"\"Targetness for each item in triggers.\n \n     Parameters\n     ----------\n     - triggers : list of (stim, offset)\n     - target_letter : letter the user is attempting to spell\n+    - is_txt : bool indicating whether the triggers are text stimuli\n \n     Returns\n     -------\n     list of ('target' | 'nontarget') for each trigger.\n     \"\"\"\n-    if target_letter:\n-        return [\n-            'target' if trg[0] == target_letter else 'nontarget'\n-            for trg in triggers\n-        ]\n-    return ['nontarget'] * len(triggers)\n+    fixation = get_fixation(is_txt)\n+    labels = {target_letter: 'target', fixation: 'fixation'}\n+    return [labels.get(trg[0], 'nontarget') for trg in triggers]\n \n \n def get_data_for_decision(inquiry_timing,\ndiff --git a\/bcipy\/helpers\/tests\/test_task.py b\/bcipy\/helpers\/tests\/test_task.py\nindex e63de17c..328ef40d 100644\n--- a\/bcipy\/helpers\/tests\/test_task.py\n+++ b\/bcipy\/helpers\/tests\/test_task.py\n@@ -211,14 +211,14 @@ def test_target_info(self):\n                     ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                     ('W', 2.4198898100003134)]\n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ]\n         self.assertEqual(expected, target_info(triggers, target_letter='Z'))\n \n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ]\ndiff --git a\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py b\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py\nindex 02c7e157..13106b6d 100644\n--- a\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py\n+++ b\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py\n@@ -542,7 +542,7 @@ def new_data_record(self,\n                         target_stimuli: str,\n                         current_text: str,\n                         decision: Decision,\n-                        evidence_types: List[EvidenceType] = []) -> Inquiry:\n+                        evidence_types: List[EvidenceType] = None) -> Inquiry:\n         \"\"\"Construct a new inquiry data record.\n \n         Parameters\n@@ -560,11 +560,13 @@ def new_data_record(self,\n         evidence for the provided evidence_types, leaving the other types empty\n         \"\"\"\n         assert self.current_inquiry, \"Current inquiry is required\"\n+        evidence_types = evidence_types or []\n         triggers = construct_triggers(self.stims_for_decision(stim_times))\n         data = Inquiry(stimuli=self.current_inquiry.stimuli,\n                        timing=self.current_inquiry.durations,\n                        triggers=triggers,\n-                       target_info=target_info(triggers, target_stimuli),\n+                       target_info=target_info(triggers, target_stimuli,\n+                                               self.parameters['is_txt_stim']),\n                        target_letter=target_stimuli,\n                        current_text=current_text,\n                        target_text=self.copy_phrase,\n","files":{"\/bcipy\/helpers\/task.py":{"changes":[{"diff":"\n import logging\n import os\n import random\n-\n from string import ascii_uppercase\n from typing import Any, List, Tuple, Union\n \n-from bcipy.helpers.clock import Clock\n-from bcipy.task.exceptions import InsufficientDataException\n-\n import numpy as np\n from psychopy import core, event, visual\n \n+from bcipy.helpers.clock import Clock\n+from bcipy.helpers.stimuli import get_fixation\n+from bcipy.task.exceptions import InsufficientDataException\n+\n log = logging.getLogger(__name__)\n \n SPACE_CHAR = '_'\n","add":4,"remove":4,"filename":"\/bcipy\/helpers\/task.py","badparts":["from bcipy.helpers.clock import Clock","from bcipy.task.exceptions import InsufficientDataException"],"goodparts":["from bcipy.helpers.clock import Clock","from bcipy.helpers.stimuli import get_fixation","from bcipy.task.exceptions import InsufficientDataException"]},{"diff":"\n \n \n def target_info(triggers: List[Tuple[str, float]],\n-                target_letter: str = None) -> List[str]:\n+                target_letter: str = None,\n+                is_txt: bool = True) -> List[str]:\n     \"\"\"Targetness for each item in triggers.\n \n     Parameters\n     ----------\n     - triggers : list of (stim, offset)\n     - target_letter : letter the user is attempting to spell\n+    - is_txt : bool indicating whether the triggers are text stimuli\n \n     Returns\n     -------\n     list of ('target' | 'nontarget') for each trigger.\n     \"\"\"\n-    if target_letter:\n-        return [\n-            'target' if trg[0] == target_letter else 'nontarget'\n-            for trg in triggers\n-        ]\n-    return ['nontarget'] * len(triggers)\n+    fixation = get_fixation(is_txt)\n+    labels = {target_letter: 'target', fixation: 'fixation'}\n+    return [labels.get(trg[0], 'nontarget') for trg in triggers]\n \n \n def get_data_for_decision(inquiry_timing,","add":6,"remove":7,"filename":"\/bcipy\/helpers\/task.py","badparts":["                target_letter: str = None) -> List[str]:","---------"," triggers : list of (stim, offset)"," target_letter : letter the user is attempting to spell","------","    if target_letter:","        return [","            'target' if trg[0] == target_letter else 'nontarget'","            for trg in triggers","        ]","    return ['nontarget'] * len(triggers)"],"goodparts":["                target_letter: str = None,","                is_txt: bool = True) -> List[str]:","    - is_txt : bool indicating whether the triggers are text stimuli","    fixation = get_fixation(is_txt)","    labels = {target_letter: 'target', fixation: 'fixation'}","    return [labels.get(trg[0], 'nontarget') for trg in triggers]"]},{"diff":"\n import logging\n import os\n import random\n-\n from string import ascii_uppercase\n from typing import Any, List, Tuple, Union\n \n-from bcipy.helpers.clock import Clock\n-from bcipy.task.exceptions import InsufficientDataException\n-\n import numpy as np\n from psychopy import core, event, visual\n \n+from bcipy.helpers.clock import Clock\n+from bcipy.helpers.stimuli import get_fixation\n+from bcipy.task.exceptions import InsufficientDataException\n+\n log = logging.getLogger(__name__)\n \n SPACE_CHAR = '_'\n","add":4,"remove":4,"filename":"\/bcipy\/helpers\/task.py","badparts":["from bcipy.helpers.clock import Clock","from bcipy.task.exceptions import InsufficientDataException"],"goodparts":["from bcipy.helpers.clock import Clock","from bcipy.helpers.stimuli import get_fixation","from bcipy.task.exceptions import InsufficientDataException"]},{"diff":"\n \n \n def target_info(triggers: List[Tuple[str, float]],\n-                target_letter: str = None) -> List[str]:\n+                target_letter: str = None,\n+                is_txt: bool = True) -> List[str]:\n     \"\"\"Targetness for each item in triggers.\n \n     Parameters\n     ----------\n     - triggers : list of (stim, offset)\n     - target_letter : letter the user is attempting to spell\n+    - is_txt : bool indicating whether the triggers are text stimuli\n \n     Returns\n     -------\n     list of ('target' | 'nontarget') for each trigger.\n     \"\"\"\n-    if target_letter:\n-        return [\n-            'target' if trg[0] == target_letter else 'nontarget'\n-            for trg in triggers\n-        ]\n-    return ['nontarget'] * len(triggers)\n+    fixation = get_fixation(is_txt)\n+    labels = {target_letter: 'target', fixation: 'fixation'}\n+    return [labels.get(trg[0], 'nontarget') for trg in triggers]\n \n \n def get_data_for_decision(inquiry_timing,","add":6,"remove":7,"filename":"\/bcipy\/helpers\/task.py","badparts":["                target_letter: str = None) -> List[str]:","---------"," triggers : list of (stim, offset)"," target_letter : letter the user is attempting to spell","------","    if target_letter:","        return [","            'target' if trg[0] == target_letter else 'nontarget'","            for trg in triggers","        ]","    return ['nontarget'] * len(triggers)"],"goodparts":["                target_letter: str = None,","                is_txt: bool = True) -> List[str]:","    - is_txt : bool indicating whether the triggers are text stimuli","    fixation = get_fixation(is_txt)","    labels = {target_letter: 'target', fixation: 'fixation'}","    return [labels.get(trg[0], 'nontarget') for trg in triggers]"]}],"source":"\nimport logging import os import random from string import ascii_uppercase from typing import Any, List, Tuple, Union from bcipy.helpers.clock import Clock from bcipy.task.exceptions import InsufficientDataException import numpy as np from psychopy import core, event, visual log=logging.getLogger(__name__) SPACE_CHAR='_' BACKSPACE_CHAR='<' def fake_copy_phrase_decision(copy_phrase, target_letter, text_task): \"\"\"Fake Copy Phrase Decision. Parameters ---------- copy_phrase(str): phrase to be copied target_letter(str): the letter supposed to be typed text_task(str): phrase spelled at this time Returns ------- (next_target_letter, text_task, run) tuple \"\"\" if text_task=='*': length_of_spelled_letters=0 else: length_of_spelled_letters=len(text_task) length_of_phrase=len(copy_phrase) if length_of_spelled_letters==0: text_task=copy_phrase[length_of_spelled_letters] else: text_task +=copy_phrase[length_of_spelled_letters] length_of_spelled_letters +=1 if length_of_spelled_letters < length_of_phrase: next_target_letter=copy_phrase[length_of_spelled_letters] run=True else: run=False next_target_letter=None text_task=copy_phrase return next_target_letter, text_task, run def calculate_stimulation_freq(flash_time: float) -> float: \"\"\"Calculate Stimulation Frequency. In an RSVP paradigm, the inquiry itself will produce an SSVEP response to the stimulation. Here we calculate what that frequency should be based on the presentation time. PARAMETERS ---------- :param: flash_time: time in seconds to present RSVP inquiry letters :returns: frequency: stimulation frequency of the inquiry \"\"\" return 1 \/ flash_time def alphabet(parameters=None, include_path=True): \"\"\"Alphabet. Function used to standardize the symbols we use as alphabet. Returns ------- array of letters. \"\"\" if parameters and not parameters['is_txt_stim']: path=parameters['path_to_presentation_images'] stimulus_array=[] for stimulus_filename in sorted(os.listdir(path)): if stimulus_filename.endswith( '.png') and not stimulus_filename.endswith('PLUS.png'): if include_path: img=os.path.join(path, stimulus_filename) else: img=os.path.splitext(stimulus_filename)[0] stimulus_array.append(img) return stimulus_array return list(ascii_uppercase) +[BACKSPACE_CHAR, SPACE_CHAR] def construct_triggers(inquiry_timing: List[List]) -> List[Tuple[str, float]]: \"\"\"Construct triggers from inquiry_timing data. Parameters ---------- -inquiry_timing: list of tuples containing stimulus timing and text Returns ------- list of(stim, offset) tuples, where offset is calculated relative to the first stim time. \"\"\" if inquiry_timing: _, first_stim_time=inquiry_timing[0] return[(stim,((timing) -first_stim_time)) for stim, timing in inquiry_timing] return[] def target_info(triggers: List[Tuple[str, float]], target_letter: str=None) -> List[str]: \"\"\"Targetness for each item in triggers. Parameters ---------- -triggers: list of(stim, offset) -target_letter: letter the user is attempting to spell Returns ------- list of('target' | 'nontarget') for each trigger. \"\"\" if target_letter: return[ 'target' if trg[0]==target_letter else 'nontarget' for trg in triggers ] return['nontarget'] * len(triggers) def get_data_for_decision(inquiry_timing, daq, offset=0.0, prestim=0.0, poststim=0.0): \"\"\"Queries the acquisition client for a slice of data and processes the resulting raw data into a form that can be passed to signal processing and classifiers. Parameters ---------- -inquiry_timing(list): list of tuples containing stimuli timing and labels. We assume the list progresses in -daq(DataAcquisitionClient): bcipy data acquisition client with a get_data method and device_info with fs defined -offset(float): offset present in the system which should be accounted for when creating data for classification. This is determined experimentally. -prestim(float): length of data needed before the first sample to reshape and apply transformations -poststim(float): length of data needed after the last sample in order to reshape and apply transformations Returns ------- (raw_data, triggers) tuple \"\"\" _, first_stim_time=inquiry_timing[0] _, last_stim_time=inquiry_timing[-1] time1=first_stim_time +offset -prestim time2=last_stim_time +offset if time2 < time1: raise InsufficientDataException( f'Invalid data query[{time1}-{time2}] with parameters:' f'[inquiry={inquiry_timing}, offset={offset}, prestim={prestim}, poststim={poststim}]') triggers=[(text,((timing) -first_stim_time)) for text, timing in inquiry_timing] data_limit=round((time2 -time1 +poststim) * daq.device_info.fs) log.debug(f'Need{data_limit} records for processing') raw_data=daq.get_data(start=time1, limit=data_limit) if len(raw_data) < data_limit: message=f'Process Data Error: Not enough data received to process. ' \\ f'Data Limit={data_limit}. Data received={len(raw_data)}' log.error(message) raise InsufficientDataException(message) raw_data=np.array([ np.array([_float_val(col) for col in record.data]) for record in raw_data ], dtype=np.float64).transpose() return raw_data, triggers def _float_val(col: Any) -> float: \"\"\"Convert marker data to float values so we can put them in a typed np.array. The marker column has type float if it has a 0.0 value, and would only have type str for a marker value.\"\"\" if isinstance(col, str): return 1.0 return float(col) def trial_complete_message(win, parameters) -> List[visual.TextStim]: \"\"\"Trial Complete Message. Function return a TextStim Object(see Psychopy) to complete the trial. Parameters ---------- win(object): Psychopy Window Object, should be the same as the one used in the experiment parameters(dict): Dictionary of session parameters Returns ------- array of message_stim(trial complete message to be displayed). \"\"\" message_stim=visual.TextStim( win=win, height=parameters['info_height'], text=parameters['trial_complete_message'], font=parameters['info_font'], pos=(parameters['info_pos_x'], parameters['info_pos_y']), wrapWidth=None, color=parameters['trial_complete_message_color'], colorSpace='rgb', opacity=1, depth=-6.0) return[message_stim] def print_message(window: visual.Window, message: str=\"Initializing...\"): \"\"\"Draws a message on the display window using default config. Parameters ---------- window(object): Psychopy Window Object, should be the same as the one used in the experiment parameters(dict): Dictionary of session parameters Returns ------- TextStim object \"\"\" message_stim=visual.TextStim(win=window, text=message) message_stim.draw() window.flip() return message_stim def get_user_input(window, message, color, first_run=False): \"\"\"Get User Input. Function returns whether or not to stop a trial. If a key of interest is passed(e.g. space), it will act on it. Parameters ---------- window[psychopy task window]: task window. *assumes wait_screen method Returns ------- True\/False: whether or not to stop a trial(based on escape key). \"\"\" if not first_run: pause=False keys=event.getKeys(keyList=['space', 'escape']) if keys: if keys[0]=='space': pause=True if keys[0]=='escape': return False else: pause=True while pause: window.wait_screen(message, color) keys=event.getKeys(keyList=['space', 'escape']) if keys: if keys[0]=='escape': return False pause=False return True def get_key_press( key_list: List[str], clock: Clock, stamp_label: str='bcipy_key_press') -> Union[list, None]: \"\"\"Get Key Press. A method to retrieve keys pressed of interest and get back a timestamp with a custom label Parameters ---------- key_list(List[str]): list of keys to look for being pressed. Ex.['space'] clock(Clock): clock to use for timestamping any key press stamp_label(str): custom label to use for timstamping along with the key itself Returns ------- Key Press Timing(List[stamp_label, timestamp]) \"\"\" response=event.getKeys(keyList=key_list, timeStamped=True) if response: key, stamp=response[0] offset=clock.getTime() -core.getTime() timestamp=stamp +offset return[f'{stamp_label}_{key}', timestamp] return None def pause_calibration(window, display, current_index: int, parameters: dict): \"\"\"Pause calibration. Pauses calibration for a given number of seconds and displays a countdown to the user. PARAMETERS ---------- :param: window: Currently active PsychoPy window :param: display: The current display :param: current_index: number of trials that have already taken place :param: trials_before_break: number of trials before break :param: break_len: length of the break time(in seconds) :param: break_message: message to display to the user during the break :returns: bool: break has taken place \"\"\" trials_before_break=parameters['trials_before_break'] break_len=parameters['break_len'] break_message=parameters['break_message'] if(current_index !=0) and(current_index % trials_before_break)==0: for counter in range(break_len): time=break_len -counter message=f'{break_message}{time}s' display.update_task_state( text=message, color_list=['white']) display.draw_static() window.flip() core.wait(1) return True return False def generate_targets(alp, stim_number): \"\"\"Generate a list of targets for each trial, minimizing duplication.\"\"\" if(stim_number <=len(alp)): return random.sample(alp, stim_number) times, remainder=divmod(stim_number, len(alp)) lists=[random.sample(alp, len(alp)) for _ in range(times)] lists.append(random.sample(alp, remainder)) targets=[target for sublist in lists for target in sublist] return targets ","sourceWithComments":"import logging\nimport os\nimport random\n\nfrom string import ascii_uppercase\nfrom typing import Any, List, Tuple, Union\n\nfrom bcipy.helpers.clock import Clock\nfrom bcipy.task.exceptions import InsufficientDataException\n\nimport numpy as np\nfrom psychopy import core, event, visual\n\nlog = logging.getLogger(__name__)\n\nSPACE_CHAR = '_'\nBACKSPACE_CHAR = '<'\n\n\ndef fake_copy_phrase_decision(copy_phrase, target_letter, text_task):\n    \"\"\"Fake Copy Phrase Decision.\n\n    Parameters\n    ----------\n        copy_phrase(str): phrase to be copied\n        target_letter(str): the letter supposed to be typed\n        text_task(str): phrase spelled at this time\n\n    Returns\n    -------\n        (next_target_letter, text_task, run) tuple\n    \"\"\"\n    if text_task == '*':\n        length_of_spelled_letters = 0\n    else:\n        length_of_spelled_letters = len(text_task)\n\n    length_of_phrase = len(copy_phrase)\n\n    if length_of_spelled_letters == 0:\n        text_task = copy_phrase[length_of_spelled_letters]\n    else:\n        text_task += copy_phrase[length_of_spelled_letters]\n\n    length_of_spelled_letters += 1\n\n    # If there is still text to be spelled, update the text_task\n    # and target letter\n    if length_of_spelled_letters < length_of_phrase:\n        next_target_letter = copy_phrase[length_of_spelled_letters]\n\n        run = True\n\n    # else, end the run\n    else:\n        run = False\n        next_target_letter = None\n        text_task = copy_phrase\n\n    return next_target_letter, text_task, run\n\n\ndef calculate_stimulation_freq(flash_time: float) -> float:\n    \"\"\"Calculate Stimulation Frequency.\n\n    In an RSVP paradigm, the inquiry itself will produce an\n        SSVEP response to the stimulation. Here we calculate\n        what that frequency should be based on the presentation\n        time.\n\n    PARAMETERS\n    ----------\n    :param: flash_time: time in seconds to present RSVP inquiry letters\n    :returns: frequency: stimulation frequency of the inquiry\n    \"\"\"\n\n    # We want to know how many stimuli will present in a second\n    return 1 \/ flash_time\n\n\ndef alphabet(parameters=None, include_path=True):\n    \"\"\"Alphabet.\n\n    Function used to standardize the symbols we use as alphabet.\n\n    Returns\n    -------\n        array of letters.\n    \"\"\"\n    if parameters and not parameters['is_txt_stim']:\n        # construct an array of paths to images\n        path = parameters['path_to_presentation_images']\n        stimulus_array = []\n        for stimulus_filename in sorted(os.listdir(path)):\n            # PLUS.png is reserved for the fixation symbol\n            if stimulus_filename.endswith(\n                    '.png') and not stimulus_filename.endswith('PLUS.png'):\n                if include_path:\n                    img = os.path.join(path, stimulus_filename)\n                else:\n                    img = os.path.splitext(stimulus_filename)[0]\n                stimulus_array.append(img)\n        return stimulus_array\n\n    return list(ascii_uppercase) + [BACKSPACE_CHAR, SPACE_CHAR]\n\n\ndef construct_triggers(inquiry_timing: List[List]) -> List[Tuple[str, float]]:\n    \"\"\"Construct triggers from inquiry_timing data.\n\n    Parameters\n    ----------\n    - inquiry_timing: list of tuples containing stimulus timing and text\n\n    Returns\n    -------\n    list of (stim, offset) tuples, where offset is calculated relative to the\n    first stim time.\n    \"\"\"\n    if inquiry_timing:\n        _, first_stim_time = inquiry_timing[0]\n        return [(stim, ((timing) - first_stim_time))\n                for stim, timing in inquiry_timing]\n    return []\n\n\ndef target_info(triggers: List[Tuple[str, float]],\n                target_letter: str = None) -> List[str]:\n    \"\"\"Targetness for each item in triggers.\n\n    Parameters\n    ----------\n    - triggers : list of (stim, offset)\n    - target_letter : letter the user is attempting to spell\n\n    Returns\n    -------\n    list of ('target' | 'nontarget') for each trigger.\n    \"\"\"\n    if target_letter:\n        return [\n            'target' if trg[0] == target_letter else 'nontarget'\n            for trg in triggers\n        ]\n    return ['nontarget'] * len(triggers)\n\n\ndef get_data_for_decision(inquiry_timing,\n                          daq,\n                          offset=0.0,\n                          prestim=0.0,\n                          poststim=0.0):\n    \"\"\"Queries the acquisition client for a slice of data and processes the\n    resulting raw data into a form that can be passed to signal processing and\n    classifiers.\n\n    Parameters\n    ----------\n    - inquiry_timing(list): list of tuples containing stimuli timing and labels. We assume the list progresses in\n    - daq (DataAcquisitionClient): bcipy data acquisition client with a get_data method and device_info with fs defined\n    - offset (float): offset present in the system which should be accounted for when creating data for classification.\n        This is determined experimentally.\n    - prestim (float): length of data needed before the first sample to reshape and apply transformations\n    - poststim (float): length of data needed after the last sample in order to reshape and apply transformations\n\n    Returns\n    -------\n    (raw_data, triggers) tuple\n    \"\"\"\n    _, first_stim_time = inquiry_timing[0]\n    _, last_stim_time = inquiry_timing[-1]\n\n    # adjust for offsets\n    time1 = first_stim_time + offset - prestim\n    time2 = last_stim_time + offset\n\n    if time2 < time1:\n        raise InsufficientDataException(\n            f'Invalid data query [{time1}-{time2}] with parameters:'\n            f'[inquiry={inquiry_timing}, offset={offset}, prestim={prestim}, poststim={poststim}]')\n\n    # Construct triggers to send off for processing. This should not be zero anymore. it would be for prestim_len = 0\n    triggers = [(text, ((timing) - first_stim_time))\n                for text, timing in inquiry_timing]\n\n    # Define the amount of data required for any processing to occur.\n    data_limit = round((time2 - time1 + poststim) * daq.device_info.fs)\n    log.debug(f'Need {data_limit} records for processing')\n\n    # Query for raw data\n    raw_data = daq.get_data(start=time1, limit=data_limit)\n\n    if len(raw_data) < data_limit:\n        message = f'Process Data Error: Not enough data received to process. ' \\\n            f'Data Limit = {data_limit}. Data received = {len(raw_data)}'\n        log.error(message)\n        raise InsufficientDataException(message)\n\n    # Take only the sensor data from raw data and transpose it\n    raw_data = np.array([\n        np.array([_float_val(col) for col in record.data])\n        for record in raw_data\n    ],\n        dtype=np.float64).transpose()\n\n    return raw_data, triggers\n\n\ndef _float_val(col: Any) -> float:\n    \"\"\"Convert marker data to float values so we can put them in a\n    typed np.array. The marker column has type float if it has a 0.0\n    value, and would only have type str for a marker value.\"\"\"\n    if isinstance(col, str):\n        return 1.0\n    return float(col)\n\n\ndef trial_complete_message(win, parameters) -> List[visual.TextStim]:\n    \"\"\"Trial Complete Message.\n\n    Function return a TextStim Object (see Psychopy) to complete the trial.\n\n    Parameters\n    ----------\n\n        win (object): Psychopy Window Object, should be the same as the one\n            used in the experiment\n        parameters (dict): Dictionary of session parameters\n\n    Returns\n    -------\n        array of message_stim (trial complete message to be displayed).\n    \"\"\"\n    message_stim = visual.TextStim(\n        win=win,\n        height=parameters['info_height'],\n        text=parameters['trial_complete_message'],\n        font=parameters['info_font'],\n        pos=(parameters['info_pos_x'],\n             parameters['info_pos_y']),\n        wrapWidth=None,\n        color=parameters['trial_complete_message_color'],\n        colorSpace='rgb',\n        opacity=1, depth=-6.0)\n    return [message_stim]\n\n\ndef print_message(window: visual.Window, message: str = \"Initializing...\"):\n    \"\"\"Draws a message on the display window using default config.\n\n    Parameters\n    ----------\n        window (object): Psychopy Window Object, should be the same as the one\n            used in the experiment\n        parameters (dict): Dictionary of session parameters\n\n    Returns\n    -------\n        TextStim object\n    \"\"\"\n    message_stim = visual.TextStim(win=window, text=message)\n    message_stim.draw()\n    window.flip()\n    return message_stim\n\n\ndef get_user_input(window, message, color, first_run=False):\n    \"\"\"Get User Input.\n\n    Function returns whether or not to stop a trial. If a key of interest is\n        passed (e.g. space), it will act on it.\n\n    Parameters\n    ----------\n\n        window[psychopy task window]: task window.  *assumes wait_screen method\n\n    Returns\n    -------\n        True\/False: whether or not to stop a trial (based on escape key).\n    \"\"\"\n    if not first_run:\n        pause = False\n        # check user input to make sure we should be going\n        keys = event.getKeys(keyList=['space', 'escape'])\n\n        if keys:\n            # pause?\n            if keys[0] == 'space':\n                pause = True\n\n            # escape?\n            if keys[0] == 'escape':\n                return False\n\n    else:\n        pause = True\n\n    while pause:\n        window.wait_screen(message, color)\n        keys = event.getKeys(keyList=['space', 'escape'])\n\n        if keys:\n            if keys[0] == 'escape':\n                return False\n            pause = False\n\n    return True\n\n\ndef get_key_press(\n        key_list: List[str],\n        clock: Clock,\n        stamp_label: str = 'bcipy_key_press') -> Union[list, None]:\n    \"\"\"Get Key Press.\n\n    A method to retrieve keys pressed of interest and get back a timestamp with\n        a custom label\n\n\n    Parameters\n    ----------\n        key_list(List[str]): list of keys to look for being pressed. Ex. ['space']\n        clock(Clock): clock to use for timestamping any key press\n        stamp_label(str): custom label to use for timstamping along with the key itself\n\n    Returns\n    -------\n        Key Press Timing(List[stamp_label, timestamp])\n    \"\"\"\n    response = event.getKeys(keyList=key_list, timeStamped=True)\n    if response:\n        # The timestamp from the response uses the psychopy.core.monotonicClock\n        # which records the number of seconds since the experiment start (core\n        # was imported).\n        key, stamp = response[0]\n        offset = clock.getTime() - core.getTime()\n        timestamp = stamp + offset\n        return [f'{stamp_label}_{key}', timestamp]\n    return None\n\n\ndef pause_calibration(window, display, current_index: int, parameters: dict):\n    \"\"\"Pause calibration.\n\n    Pauses calibration for a given number of seconds and displays a countdown\n    to the user.\n\n\n    PARAMETERS\n    ----------\n    :param: window: Currently active PsychoPy window\n    :param: display: The current display\n    :param: current_index: number of trials that have already taken place\n    :param: trials_before_break: number of trials before break\n    :param: break_len: length of the break time (in seconds)\n    :param: break_message: message to display to the user during the break\n\n    :returns: bool: break has taken place\n    \"\"\"\n    # Check whether or not to present a break\n    trials_before_break = parameters['trials_before_break']\n    break_len = parameters['break_len']\n    break_message = parameters['break_message']\n\n    if (current_index != 0) and (current_index % trials_before_break) == 0:\n\n        # present break message for break length\n        for counter in range(break_len):\n            time = break_len - counter\n            message = f'{break_message} {time}s'\n            display.update_task_state(\n                text=message,\n                color_list=['white'])\n            display.draw_static()\n            window.flip()\n            core.wait(1)\n        return True\n\n    return False\n\n\ndef generate_targets(alp, stim_number):\n    \"\"\"Generate a list of targets for each trial, minimizing duplication.\"\"\"\n    if (stim_number <= len(alp)):\n        return random.sample(alp, stim_number)\n\n    # minimize duplicates\n    times, remainder = divmod(stim_number, len(alp))\n\n    lists = [random.sample(alp, len(alp)) for _ in range(times)]\n    lists.append(random.sample(alp, remainder))\n\n    # flatten list of lists\n    targets = [target for sublist in lists for target in sublist]\n\n    return targets\n"},"\/bcipy\/helpers\/tests\/test_task.py":{"changes":[{"diff":"\n                     ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                     ('W', 2.4198898100003134)]\n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ]\n         self.assertEqual(expected, target_info(triggers, target_letter='Z'))\n \n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ","add":2,"remove":2,"filename":"\/bcipy\/helpers\/tests\/test_task.py","badparts":["            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',","            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',"],"goodparts":["            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',","            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',"]},{"diff":"\n                     ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                     ('W', 2.4198898100003134)]\n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ]\n         self.assertEqual(expected, target_info(triggers, target_letter='Z'))\n \n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ","add":2,"remove":2,"filename":"\/bcipy\/helpers\/tests\/test_task.py","badparts":["            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',","            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',"],"goodparts":["            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',","            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',"]}],"source":"\nimport unittest from typing import List from collections import Counter from mockito import unstub, mock, when, verify, verifyStubbedInvocationsAreUsed import numpy as np import psychopy from bcipy.acquisition.client import DataAcquisitionClient from bcipy.acquisition.record import Record from bcipy.task.exceptions import InsufficientDataException from bcipy.helpers.task import( _float_val, alphabet, calculate_stimulation_freq, construct_triggers, generate_targets, get_data_for_decision, get_key_press, target_info ) class TestAlphabet(unittest.TestCase): def test_alphabet_text(self): parameters={} parameters['is_txt_stim']=True alp=alphabet(parameters) self.assertEqual( alp, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '<', '_']) def test_alphabet_images(self): parameters={} parameters['is_txt_stim']=False parameters['path_to_presentation_images']=('bcipy\/static\/images\/' 'rsvp\/') alp=alphabet(parameters) self.assertNotEqual( alp, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'V', 'Y', 'Z', '<', '_']) class TestCalculateStimulationFreq(unittest.TestCase): def test_calculate_stimulate_frequency_returns_number_less_one(self): flash_time=5 stimulation_frequency=calculate_stimulation_freq(flash_time) expected=1 \/ flash_time self.assertEqual(stimulation_frequency, expected) def test_calculate_stimulate_frequency_handles_zero(self): flash_time=0 with self.assertRaises(ZeroDivisionError): calculate_stimulation_freq(flash_time) class TestFloatVal(unittest.TestCase): def test_float_val_as_str(self): col='Apple' result=_float_val(col) expected=1.0 self.assertEqual(result, expected) def test_float_val_as_int(self): col=3 result=_float_val(col) expected=3.0 self.assertEqual(result, expected) class TestTargetGeneration(unittest.TestCase): \"\"\"Tests for generation of target inquiries\"\"\" def test_target_number_less_than_alp(self): \"\"\"Test when requested number of targets is less than the length of the alphabet.\"\"\" alp=list(range(10)) targets=generate_targets(alp, 5) self.assertEqual(len(targets), 5) self.assertEqual(len(targets), len(set(targets))) def test_target_greater_than_alp(self): \"\"\"Test behavior when number of targets is greater than the length of the alphabet\"\"\" alp=list(range(5)) targets=generate_targets(alp, 10) self.assertEqual(len(targets), 10) counts=Counter(targets) for item in alp: self.assertEqual(counts[item], 2) def test_remainder(self): \"\"\"Test behavior when number of targets is greater than the length of the alphabet by a value other than a multiple of the alphabet length. \"\"\" alp=list(range(5)) targets=generate_targets(alp, 12) counts=Counter(targets) for item in alp: self.assertGreaterEqual(counts[item], 2) self.assertLessEqual(counts[item], 3) class TestGetKeyPress(unittest.TestCase): \"\"\"Tests for the get key press method\"\"\" def tearDown(self): verifyStubbedInvocationsAreUsed() unstub() def test_get_key_press_appends_stamp_label_defaults(self): \"\"\"Test for the stamp label defaults, ensures the calls occur with the correct inputs to psychopy\"\"\" key_list=['space'] clock=mock() key_response=[[key_list[0], 1000]] when(psychopy.event).getKeys(keyList=key_list, timeStamped=True).thenReturn(key_response) when(clock).getTime().thenReturn(psychopy.core.getTime()) stamp_label='bcipy_key_press' expected=[f'{stamp_label}_{key_response[0][0]}', key_response[0][1]] response=get_key_press(key_list, clock) self.assertEqual(expected[0], response[0]) self.assertAlmostEqual(expected[1], response[1], delta=0.01) def test_get_key_press_clock_adjustment(self): \"\"\"Test for the stamp label defaults, ensures the calls occur with the correct inputs to psychopy\"\"\" key_list=['space'] clock=mock() key_response=[[key_list[0], 1000]] when(psychopy.event).getKeys(keyList=key_list, timeStamped=True).thenReturn(key_response) when(clock).getTime().thenReturn(psychopy.core.getTime() +100) stamp_label='bcipy_key_press' expected=[f'{stamp_label}_{key_response[0][0]}', key_response[0][1]] response=get_key_press(key_list, clock) self.assertEqual(expected[0], response[0]) self.assertAlmostEqual(1100, response[1], delta=0.01) def test_get_key_press_returns_none_if_no_keys_pressed(self): \"\"\"Test for the case not keys are returned, ensures the calls occur with the correct inputs to psychopy\"\"\" key_list=['space'] key_response=None clock=mock() when(psychopy.event).getKeys(keyList=key_list, timeStamped=True).thenReturn(key_response) response=get_key_press(key_list, clock) self.assertEqual(None, response) def test_get_key_press_set_custom_stamp_message(self): \"\"\"Test for a custom stamp label, ensures the calls occur with the correct inputs to psychopy\"\"\" clock=mock() key_list=['space'] key_response=[[key_list[0], 1000]] when(psychopy.event).getKeys(keyList=key_list, timeStamped=True).thenReturn(key_response) when(clock).getTime().thenReturn(psychopy.core.getTime()) stamp_label='custom_label' expected=[f'{stamp_label}_{key_response[0][0]}', key_response[0][1]] response=get_key_press(key_list, clock, stamp_label=stamp_label) self.assertEqual(expected[0], response[0]) self.assertAlmostEqual(expected[1], response[1], delta=0.01) class TestTriggers(unittest.TestCase): \"\"\"Tests related to triggers\"\"\" def test_construct_triggers(self): stim_times=[['+', 7.009946188016329],['<', 7.477798109990545], ['_', 7.69470399999409],['Z', 7.911495972017292], ['U', 8.128477902995655],['S', 8.345279764995212], ['T', 8.562265532993479],['V', 8.779025560012087], ['X', 8.995945784990909],['Y', 9.213076218002243], ['W', 9.429835998016642]] expected=[('+', 0.0),('<', 0.46785192197421566), ('_', 0.6847578119777609),('Z', 0.901549784000963), ('U', 1.1185317149793264),('S', 1.3353335769788828), ('T', 1.5523193449771497),('V', 1.7690793719957583), ('X', 1.9859995969745796),('Y', 2.203130029985914), ('W', 2.4198898100003134)] self.assertEqual(expected, construct_triggers(stim_times)) self.assertEqual([], construct_triggers([])) def test_target_info(self): triggers=[('+', 0.0),('<', 0.46785192197421566), ('_', 0.6847578119777609),('Z', 0.901549784000963), ('U', 1.1185317149793264),('S', 1.3353335769788828), ('T', 1.5523193449771497),('V', 1.7690793719957583), ('X', 1.9859995969745796),('Y', 2.203130029985914), ('W', 2.4198898100003134)] expected=[ 'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget' ] self.assertEqual(expected, target_info(triggers, target_letter='Z')) expected=[ 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget' ] self.assertEqual(expected, target_info(triggers)) self.assertEqual([], target_info([])) def mock_get_data_response(samples: int, high: float, low: float, channels: int) -> List[Record]: \"\"\"Mock DataAcquisitionClient Response. The data acquisition client returns a list of records that need to be looped through to get the raw data without other items attached. \"\"\" data=[np.random.uniform(low, high) for _ in range(channels)] record_data=[] for i in range(samples): record_data.append(Record(data, i, None)) return record_data class TestGetDataForDecision(unittest.TestCase): def setUp(self) -> None: self.inquiry_timing=[('A', 1),('B', 2),('C', 3)] self.daq=mock(spec=DataAcquisitionClient) self.daq.device_info=mock() self.daq.device_info.fs=10 self.mock_eeg=mock_get_data_response(samples=1000, high=1000, low=-1000, channels=4) def tearDown(self) -> None: unstub() def test_get_data_for_decision_returns_tuple_of_eeg_data_and_triggers(self): when(self.daq).get_data(start=any, limit=any).thenReturn(self.mock_eeg) response=get_data_for_decision(self.inquiry_timing, self.daq) self.assertIsInstance(response, tuple) eeg_data, timing=response self.assertIsInstance(timing, list) def test_get_data_for_decision_prestim(self): prestim=1 first_stim_time=self.inquiry_timing[0][1] last_stim_time=self.inquiry_timing[-1][1] expected_start=first_stim_time -prestim expected_stop=last_stim_time expected_triggers=[(text,((timing) -first_stim_time)) for text, timing in self.inquiry_timing] expected_data_limit=round((expected_stop -expected_start) * self.daq.device_info.fs) when(self.daq).get_data(start=expected_start, limit=expected_data_limit).thenReturn(self.mock_eeg) _, timing=get_data_for_decision( self.inquiry_timing, self.daq, prestim=prestim) self.assertEqual(timing, expected_triggers) verify(self.daq, times=1).get_data(start=expected_start, limit=expected_data_limit) def test_get_data_for_decision_poststim(self): poststim=1 first_stim_time=self.inquiry_timing[0][1] last_stim_time=self.inquiry_timing[-1][1] expected_triggers=[(text,((timing) -first_stim_time)) for text, timing in self.inquiry_timing] expected_data_limit=round((last_stim_time -first_stim_time +poststim) * self.daq.device_info.fs) when(self.daq).get_data(start=first_stim_time, limit=expected_data_limit).thenReturn(self.mock_eeg) _, timing=get_data_for_decision( self.inquiry_timing, self.daq, poststim=poststim) self.assertEqual(timing, expected_triggers) verify(self.daq, times=1).get_data(start=first_stim_time, limit=expected_data_limit) def test_get_data_for_decision_offset(self): offset=1 first_stim_time=self.inquiry_timing[0][1] last_stim_time=self.inquiry_timing[-1][1] expected_start=first_stim_time +offset expected_stop=last_stim_time +offset expected_triggers=[(text,((timing) -first_stim_time)) for text, timing in self.inquiry_timing] expected_data_limit=round((expected_stop -expected_start) * self.daq.device_info.fs) when(self.daq).get_data(start=expected_start, limit=expected_data_limit).thenReturn(self.mock_eeg) _, timing=get_data_for_decision( self.inquiry_timing, self.daq, offset=offset) self.assertEqual(timing, expected_triggers) verify(self.daq, times=1).get_data(start=expected_start, limit=expected_data_limit) def test_get_data_for_decision_throws_insufficient_data_error_if_less_than_data_limit(self): when(self.daq).get_data(start=any, limit=any).thenReturn([]) with self.assertRaises(InsufficientDataException): get_data_for_decision(self.inquiry_timing, self.daq) def test_get_data_for_decision_throws_insufficient_data_error_if_data_query_out_of_bounds(self): inquiry_timing=[('A', 10),('D', 1)] with self.assertRaises(InsufficientDataException): get_data_for_decision(inquiry_timing, self.daq) if __name__=='__main__': unittest.main() ","sourceWithComments":"import unittest\n\nfrom typing import List\nfrom collections import Counter\nfrom mockito import unstub, mock, when, verify, verifyStubbedInvocationsAreUsed\n\nimport numpy as np\nimport psychopy\n\nfrom bcipy.acquisition.client import DataAcquisitionClient\nfrom bcipy.acquisition.record import Record\nfrom bcipy.task.exceptions import InsufficientDataException\n\nfrom bcipy.helpers.task import (\n    _float_val,\n    alphabet,\n    calculate_stimulation_freq,\n    construct_triggers,\n    generate_targets,\n    get_data_for_decision,\n    get_key_press,\n    target_info\n)\n\n\nclass TestAlphabet(unittest.TestCase):\n    def test_alphabet_text(self):\n        parameters = {}\n\n        parameters['is_txt_stim'] = True\n\n        alp = alphabet(parameters)\n\n        self.assertEqual(\n            alp,\n            ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\n             'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n             'Y', 'Z', '<',\n             '_'])\n\n    def test_alphabet_images(self):\n        parameters = {}\n        parameters['is_txt_stim'] = False\n        parameters['path_to_presentation_images'] = ('bcipy\/static\/images\/'\n                                                     'rsvp\/')\n\n        alp = alphabet(parameters)\n\n        self.assertNotEqual(\n            alp,\n            ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\n             'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'V', 'Y', 'Z', '<',\n             '_'])\n\n\nclass TestCalculateStimulationFreq(unittest.TestCase):\n    def test_calculate_stimulate_frequency_returns_number_less_one(self):\n        flash_time = 5\n        stimulation_frequency = calculate_stimulation_freq(flash_time)\n        expected = 1 \/ flash_time\n        self.assertEqual(stimulation_frequency, expected)\n\n    def test_calculate_stimulate_frequency_handles_zero(self):\n        flash_time = 0\n        with self.assertRaises(ZeroDivisionError):\n            calculate_stimulation_freq(flash_time)\n\n\nclass TestFloatVal(unittest.TestCase):\n    def test_float_val_as_str(self):\n        col = 'Apple'\n        result = _float_val(col)\n        expected = 1.0\n        self.assertEqual(result, expected)\n\n    def test_float_val_as_int(self):\n        col = 3\n        result = _float_val(col)\n        expected = 3.0\n        self.assertEqual(result, expected)\n\n\nclass TestTargetGeneration(unittest.TestCase):\n    \"\"\"Tests for generation of target inquiries\"\"\"\n\n    def test_target_number_less_than_alp(self):\n        \"\"\"Test when requested number of targets is less than the length of\n        the alphabet.\"\"\"\n        alp = list(range(10))\n        targets = generate_targets(alp, 5)\n        self.assertEqual(len(targets), 5)\n        self.assertEqual(len(targets), len(set(targets)))\n\n    def test_target_greater_than_alp(self):\n        \"\"\"Test behavior when number of targets is greater than the length\n        of the alphabet\"\"\"\n        alp = list(range(5))\n        targets = generate_targets(alp, 10)\n        self.assertEqual(len(targets), 10)\n\n        counts = Counter(targets)\n\n        for item in alp:\n            self.assertEqual(counts[item], 2)\n\n    def test_remainder(self):\n        \"\"\"Test behavior when number of targets is greater than the length of\n        the alphabet by a value other than a multiple of the alphabet length.\n        \"\"\"\n        alp = list(range(5))\n        targets = generate_targets(alp, 12)\n\n        counts = Counter(targets)\n        for item in alp:\n            self.assertGreaterEqual(counts[item], 2)\n            self.assertLessEqual(counts[item], 3)\n\n\nclass TestGetKeyPress(unittest.TestCase):\n    \"\"\"Tests for the get key press method\"\"\"\n\n    def tearDown(self):\n        verifyStubbedInvocationsAreUsed()\n        unstub()\n\n    def test_get_key_press_appends_stamp_label_defaults(self):\n        \"\"\"Test for the stamp label defaults, ensures the calls occur with the correct inputs to psychopy\"\"\"\n        key_list = ['space']\n        clock = mock()\n        # get keys returns a list of lists with the key and timestamp per hit\n        key_response = [[key_list[0], 1000]]\n        when(psychopy.event).getKeys(keyList=key_list,\n                                     timeStamped=True).thenReturn(key_response)\n        when(clock).getTime().thenReturn(psychopy.core.getTime())\n        # use the default label\n        stamp_label = 'bcipy_key_press'\n        expected = [f'{stamp_label}_{key_response[0][0]}', key_response[0][1]]\n        response = get_key_press(key_list, clock)\n        self.assertEqual(expected[0], response[0])\n        self.assertAlmostEqual(expected[1], response[1], delta=0.01)\n\n    def test_get_key_press_clock_adjustment(self):\n        \"\"\"Test for the stamp label defaults, ensures the calls occur with the correct inputs to psychopy\"\"\"\n        key_list = ['space']\n        clock = mock()\n        # get keys returns a list of lists with the key and timestamp per hit\n        key_response = [[key_list[0], 1000]]\n        when(psychopy.event).getKeys(keyList=key_list,\n                                     timeStamped=True).thenReturn(key_response)\n        when(clock).getTime().thenReturn(psychopy.core.getTime() + 100)\n        # use the default label\n        stamp_label = 'bcipy_key_press'\n        expected = [f'{stamp_label}_{key_response[0][0]}', key_response[0][1]]\n        response = get_key_press(key_list, clock)\n        self.assertEqual(expected[0], response[0])\n        self.assertAlmostEqual(1100, response[1], delta=0.01)\n\n    def test_get_key_press_returns_none_if_no_keys_pressed(self):\n        \"\"\"Test for the case not keys are returned, ensures the calls occur with the correct inputs to psychopy\"\"\"\n\n        key_list = ['space']\n        key_response = None\n        clock = mock()\n        when(psychopy.event).getKeys(keyList=key_list,\n                                     timeStamped=True).thenReturn(key_response)\n\n        response = get_key_press(key_list, clock)\n        self.assertEqual(None, response)\n\n    def test_get_key_press_set_custom_stamp_message(self):\n        \"\"\"Test for a custom stamp label, ensures the calls occur with the correct inputs to psychopy\"\"\"\n        clock = mock()\n        key_list = ['space']\n        # get keys returns a list of lists with the key and timestamp per hit\n        key_response = [[key_list[0], 1000]]\n        when(psychopy.event).getKeys(keyList=key_list,\n                                     timeStamped=True).thenReturn(key_response)\n        when(clock).getTime().thenReturn(psychopy.core.getTime())\n        # set a custom label\n        stamp_label = 'custom_label'\n        expected = [f'{stamp_label}_{key_response[0][0]}', key_response[0][1]]\n        response = get_key_press(key_list, clock, stamp_label=stamp_label)\n        self.assertEqual(expected[0], response[0])\n        self.assertAlmostEqual(expected[1], response[1], delta=0.01)\n\n\nclass TestTriggers(unittest.TestCase):\n    \"\"\"Tests related to triggers\"\"\"\n\n    def test_construct_triggers(self):\n        stim_times = [['+', 7.009946188016329], ['<', 7.477798109990545],\n                      ['_', 7.69470399999409], ['Z', 7.911495972017292],\n                      ['U', 8.128477902995655], ['S', 8.345279764995212],\n                      ['T', 8.562265532993479], ['V', 8.779025560012087],\n                      ['X', 8.995945784990909], ['Y', 9.213076218002243],\n                      ['W', 9.429835998016642]]\n        expected = [('+', 0.0), ('<', 0.46785192197421566),\n                    ('_', 0.6847578119777609), ('Z', 0.901549784000963),\n                    ('U', 1.1185317149793264), ('S', 1.3353335769788828),\n                    ('T', 1.5523193449771497), ('V', 1.7690793719957583),\n                    ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                    ('W', 2.4198898100003134)]\n        self.assertEqual(expected, construct_triggers(stim_times))\n        self.assertEqual([], construct_triggers([]))\n\n    def test_target_info(self):\n        triggers = [('+', 0.0), ('<', 0.46785192197421566),\n                    ('_', 0.6847578119777609), ('Z', 0.901549784000963),\n                    ('U', 1.1185317149793264), ('S', 1.3353335769788828),\n                    ('T', 1.5523193449771497), ('V', 1.7690793719957583),\n                    ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                    ('W', 2.4198898100003134)]\n        expected = [\n            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',\n            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n            'nontarget'\n        ]\n        self.assertEqual(expected, target_info(triggers, target_letter='Z'))\n\n        expected = [\n            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n            'nontarget'\n        ]\n        self.assertEqual(expected, target_info(triggers))\n        self.assertEqual([], target_info([]))\n\n\ndef mock_get_data_response(samples: int, high: float, low: float, channels: int) -> List[Record]:\n    \"\"\"Mock DataAcquisitionClient Response.\n\n    The data acquisition client returns a list of records that need to be looped through\n        to get the raw data without other items attached.\n    \"\"\"\n    data = [np.random.uniform(low, high) for _ in range(channels)]\n    record_data = []\n    for i in range(samples):\n        record_data.append(Record(data, i, None))\n    return record_data\n\n\nclass TestGetDataForDecision(unittest.TestCase):\n\n    def setUp(self) -> None:\n        self.inquiry_timing = [('A', 1), ('B', 2), ('C', 3)]\n        self.daq = mock(spec=DataAcquisitionClient)\n        self.daq.device_info = mock()\n        self.daq.device_info.fs = 10\n        self.mock_eeg = mock_get_data_response(samples=1000, high=1000, low=-1000, channels=4)\n\n    def tearDown(self) -> None:\n        unstub()\n\n    def test_get_data_for_decision_returns_tuple_of_eeg_data_and_triggers(self):\n        when(self.daq).get_data(start=any, limit=any).thenReturn(self.mock_eeg)\n\n        response = get_data_for_decision(self.inquiry_timing, self.daq)\n\n        self.assertIsInstance(response, tuple)\n\n        eeg_data, timing = response\n\n        # self.assertEqual(eeg_data[:1][0], self.mock_eeg[0].data[0])\n        self.assertIsInstance(timing, list)\n\n    def test_get_data_for_decision_prestim(self):\n        prestim = 1\n        first_stim_time = self.inquiry_timing[0][1]\n        last_stim_time = self.inquiry_timing[-1][1]\n\n        expected_start = first_stim_time - prestim\n        expected_stop = last_stim_time\n        expected_triggers = [(text, ((timing) - first_stim_time))\n                             for text, timing in self.inquiry_timing]\n        expected_data_limit = round((expected_stop - expected_start) * self.daq.device_info.fs)\n\n        when(self.daq).get_data(start=expected_start, limit=expected_data_limit).thenReturn(self.mock_eeg)\n        _, timing = get_data_for_decision(\n            self.inquiry_timing,\n            self.daq,\n            prestim=prestim)\n\n        # self.assertEqual(eeg_data[:1][0], self.mock_eeg[0].data[0])\n        self.assertEqual(timing, expected_triggers)\n        verify(self.daq, times=1).get_data(start=expected_start, limit=expected_data_limit)\n\n    def test_get_data_for_decision_poststim(self):\n        poststim = 1\n        first_stim_time = self.inquiry_timing[0][1]\n        last_stim_time = self.inquiry_timing[-1][1]\n\n        expected_triggers = [(text, ((timing) - first_stim_time))\n                             for text, timing in self.inquiry_timing]\n        expected_data_limit = round((last_stim_time - first_stim_time + poststim) * self.daq.device_info.fs)\n\n        when(self.daq).get_data(start=first_stim_time, limit=expected_data_limit).thenReturn(self.mock_eeg)\n        _, timing = get_data_for_decision(\n            self.inquiry_timing,\n            self.daq,\n            poststim=poststim)\n\n        # self.assertEqual(eeg_data[:1][0], self.mock_eeg[0].data[0])\n        self.assertEqual(timing, expected_triggers)\n        verify(self.daq, times=1).get_data(start=first_stim_time, limit=expected_data_limit)\n\n    def test_get_data_for_decision_offset(self):\n        offset = 1\n        first_stim_time = self.inquiry_timing[0][1]\n        last_stim_time = self.inquiry_timing[-1][1]\n\n        expected_start = first_stim_time + offset\n        expected_stop = last_stim_time + offset\n        expected_triggers = [(text, ((timing) - first_stim_time))\n                             for text, timing in self.inquiry_timing]\n        expected_data_limit = round((expected_stop - expected_start) * self.daq.device_info.fs)\n\n        when(self.daq).get_data(start=expected_start, limit=expected_data_limit).thenReturn(self.mock_eeg)\n        _, timing = get_data_for_decision(\n            self.inquiry_timing,\n            self.daq,\n            offset=offset)\n\n        # self.assertEqual(eeg_data[:1][0], self.mock_eeg[0].data[0])\n        self.assertEqual(timing, expected_triggers)\n        verify(self.daq, times=1).get_data(start=expected_start, limit=expected_data_limit)\n\n    def test_get_data_for_decision_throws_insufficient_data_error_if_less_than_data_limit(self):\n\n        # return an empty list from the get data call\n        when(self.daq).get_data(start=any, limit=any).thenReturn([])\n\n        with self.assertRaises(InsufficientDataException):\n            get_data_for_decision(self.inquiry_timing, self.daq)\n\n    def test_get_data_for_decision_throws_insufficient_data_error_if_data_query_out_of_bounds(self):\n        inquiry_timing = [('A', 10), ('D', 1)]\n\n        with self.assertRaises(InsufficientDataException):\n            get_data_for_decision(inquiry_timing, self.daq)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"},"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py":{"changes":[{"diff":"\n                         target_stimuli: str,\n                         current_text: str,\n                         decision: Decision,\n-                        evidence_types: List[EvidenceType] = []) -> Inquiry:\n+                        evidence_types: List[EvidenceType] = None) -> Inquiry:\n         \"\"\"Construct a new inquiry data record.\n \n         Parameters\n","add":1,"remove":1,"filename":"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py","badparts":["                        evidence_types: List[EvidenceType] = []) -> Inquiry:"],"goodparts":["                        evidence_types: List[EvidenceType] = None) -> Inquiry:"]},{"diff":"\n         evidence for the provided evidence_types, leaving the other types empty\n         \"\"\"\n         assert self.current_inquiry, \"Current inquiry is required\"\n+        evidence_types = evidence_types or []\n         triggers = construct_triggers(self.stims_for_decision(stim_times))\n         data = Inquiry(stimuli=self.current_inquiry.stimuli,\n                        timing=self.current_inquiry.durations,\n                        triggers=triggers,\n-                       target_info=target_info(triggers, target_stimuli),\n+                       target_info=target_info(triggers, target_stimuli,\n+                                               self.parameters['is_txt_stim']),\n                        target_letter=target_stimuli,\n                        current_text=current_text,\n                        target_text=self.copy_phrase,\n","add":3,"remove":1,"filename":"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py","badparts":["                       target_info=target_info(triggers, target_stimuli),"],"goodparts":["        evidence_types = evidence_types or []","                       target_info=target_info(triggers, target_stimuli,","                                               self.parameters['is_txt_stim']),"]},{"diff":"\n                         target_stimuli: str,\n                         current_text: str,\n                         decision: Decision,\n-                        evidence_types: List[EvidenceType] = []) -> Inquiry:\n+                        evidence_types: List[EvidenceType] = None) -> Inquiry:\n         \"\"\"Construct a new inquiry data record.\n \n         Parameters\n","add":1,"remove":1,"filename":"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py","badparts":["                        evidence_types: List[EvidenceType] = []) -> Inquiry:"],"goodparts":["                        evidence_types: List[EvidenceType] = None) -> Inquiry:"]},{"diff":"\n         evidence for the provided evidence_types, leaving the other types empty\n         \"\"\"\n         assert self.current_inquiry, \"Current inquiry is required\"\n+        evidence_types = evidence_types or []\n         triggers = construct_triggers(self.stims_for_decision(stim_times))\n         data = Inquiry(stimuli=self.current_inquiry.stimuli,\n                        timing=self.current_inquiry.durations,\n                        triggers=triggers,\n-                       target_info=target_info(triggers, target_stimuli),\n+                       target_info=target_info(triggers, target_stimuli,\n+                                               self.parameters['is_txt_stim']),\n                        target_letter=target_stimuli,\n                        current_text=current_text,\n                        target_text=self.copy_phrase,\n","add":3,"remove":1,"filename":"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py","badparts":["                       target_info=target_info(triggers, target_stimuli),"],"goodparts":["        evidence_types = evidence_types or []","                       target_info=target_info(triggers, target_stimuli,","                                               self.parameters['is_txt_stim']),"]}]}},"msg":"#181489190 ; updated stimuli labels in copy phrase session to ensure that fixation stimuli are labeled as 'fixation' rather than 'nontarget'"}},"https:\/\/github.com\/Open-MSS\/MSS":{"9cf29bbb7d3f2dd8e83abec623e81c35dcbc3cf7":{"url":"https:\/\/api.github.com\/repos\/Open-MSS\/MSS\/commits\/9cf29bbb7d3f2dd8e83abec623e81c35dcbc3cf7","html_url":"https:\/\/github.com\/Open-MSS\/MSS\/commit\/9cf29bbb7d3f2dd8e83abec623e81c35dcbc3cf7","message":"Verify valid token, fixes #975 (#987)\n\n* fixed error message (#962)\r\n\r\n* improved install\/update of MSS (#966)\r\n\r\n* improved install\/update of MSS\r\n\r\n* updated env order and added an important hint\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* preparation v3.0.4 (#967)\r\n\r\n* Changed vertical section interpolation to treat masked values as NaN (#983)\r\n\r\nArray is properly masked, but interpolation routine ignored mask.\r\nFilling the array with NaN should solve this issue.\r\nResulting array is properly masked again.\r\n\r\nFix #811\r\n\r\n* Import\/Export Extensions, fixes #918 (#981)\r\n\r\n* export plugins added\r\n\r\n* import plugins added\r\n\r\n* removed a doubled import\r\n\r\n* popup message when all is done\r\n\r\n* first change model than reload views\r\n\r\n* waypoints_model.dataChanged added\r\n\r\n* saved after import\r\n\r\n* reorganized, removed double commits\r\n\r\n* import saves xml content, worklocally with ftml files\r\n\r\n* Added option to display a secondary axis in SideView. (#980)\r\n\r\nFix #571\r\n\r\nCo-authored-by: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* enables to configure a EXPIRATION time in seconds, fixes #948 (#974)\r\n\r\n* enables to configure a EXPIRATION time in seconds\r\n\r\nwe catch now various problems for an expired session,\r\nbesides on a timelimit a session also expires on server restart.\r\n\r\n* popup message for new login requires added\r\n\r\n* flake8 fix\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* verbose output on chat who made changes\r\n\r\n* fixed typo\r\n\r\n* ToDo added\r\n\r\n* verifies expired user token and forces login\r\n\r\n* fixation of qt (#988)\r\n\r\n* added sorting for project list (#990)\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* Mscolab: collaborator can access version history (#925)\r\n\r\n* Mscolab: collaborator can access version history\r\n\r\n* updated mscolab.py\r\n\r\n* mscolab docs updated\r\n\r\n* mscolab.py updated\r\n\r\nCo-Authored-By: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* added \"collaborator\" in file_manager\r\n\r\n* fixed: flake8\r\n\r\n* file_manager.py updated\r\n\r\n* updated file_manager.py\r\n\r\n* refactored mscolab permissions\r\n\r\n* update\r\n\r\n* refactored permissions in  \"set_active_pid\"\r\n\r\nCo-Authored-By: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* closed windows after permission updated\r\n\r\n* merged: permission based closing of mscolab windows and disabling buttons to single function\r\n\r\nIt will increase maintainability\r\n\r\nCo-Authored-By: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\n* called `handle_mscolab_buttons` inside other functions\r\n\r\nCo-Authored-By: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\nCo-authored-by: ReimarBauer <rb.proj@gmail.com>\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\nCo-authored-by: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\n* flake8 fix\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\nCo-authored-by: Aravind Murali <aravindmurali711@gmail.com>\r\nCo-authored-by: Jatin Jain <72596619+Jatin2020-24@users.noreply.github.com>\r\nCo-authored-by: J. Ungermann <28449201+joernu76@users.noreply.github.com>","sha":"9cf29bbb7d3f2dd8e83abec623e81c35dcbc3cf7","keyword":"session fixation update","diff":"diff --git a\/mslib\/mscolab\/sockets_manager.py b\/mslib\/mscolab\/sockets_manager.py\nindex 647b37868..95beed07e 100644\n--- a\/mslib\/mscolab\/sockets_manager.py\n+++ b\/mslib\/mscolab\/sockets_manager.py\n@@ -206,12 +206,14 @@ def handle_file_save(self, json_req):\n             # if permission is correct and file saved properly\n             if perm and self.fm.save_file(int(p_id), content, user, comment):\n                 # send service message\n-                message_ = \"[service message] saved changes\"\n+                message_ = f\"[service message] **{user.username}** saved changes\"\n                 new_message = self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE)\n                 new_message_dict = get_message_dict(new_message)\n                 socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                 # emit file-changed event to trigger reload of flight track\n                 socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id))\n+        else:\n+            logging.debug(f'login expired for {user.username}, state unauthorized!')\n \n     def emit_file_change(self, p_id):\n         socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id))\ndiff --git a\/mslib\/msui\/mscolab.py b\/mslib\/msui\/mscolab.py\nindex e4e2e9d9d..7a5010b15 100644\n--- a\/mslib\/msui\/mscolab.py\n+++ b\/mslib\/msui\/mscolab.py\n@@ -279,61 +279,70 @@ def text_changed(self):\n         self.loginButton.setEnabled(self.emailid.text() != \"\" and self.password.text() != \"\")\n \n     def handle_import(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n-        else:\n-            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]\n-            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        dir_path, file_name = fs.path.split(file_path)\n-        file_name = fs.path.basename(file_path)\n-        name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            with open_fs(dir_path) as file_dir:\n-                xml_content = file_dir.readtext(file_name)\n-            try:\n-                model = ft.WaypointsTableModel(xml_content=xml_content)\n-            except SyntaxError:\n-                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n-                return\n-            self.waypoints_model = model\n+        if self.verify_user_token():\n             if self.workLocallyCheckBox.isChecked():\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n             else:\n+                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"\n+                                                         for ext in self.import_plugins.keys()]\n+                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            dir_path, file_name = fs.path.split(file_path)\n+            file_name = fs.path.basename(file_path)\n+            name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                with open_fs(dir_path) as file_dir:\n+                    xml_content = file_dir.readtext(file_name)\n+                try:\n+                    model = ft.WaypointsTableModel(xml_content=xml_content)\n+                except SyntaxError:\n+                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n+                    return\n+                self.waypoints_model = model\n+                if self.workLocallyCheckBox.isChecked():\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                else:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            else:\n+                _function = self.import_plugins[file_ext[1:]]\n+                _, new_waypoints = _function(file_path)\n+                model = ft.WaypointsTableModel(waypoints=new_waypoints)\n+                self.waypoints_model = model\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n                 self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n                 self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            self.reload_view_windows()\n+            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n         else:\n-            _function = self.import_plugins[file_ext[1:]]\n-            _, new_waypoints = _function(file_path)\n-            model = ft.WaypointsTableModel(waypoints=new_waypoints)\n-            self.waypoints_model = model\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n-            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-        self.reload_view_windows()\n-        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_export(self):\n-        # Setting default filename path for filedialogue\n-        default_filename = self.active_project_name + \".ftml\"\n-        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n-        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        file_name = fs.path.basename(file_path)\n-        file_name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            dir_path, file_name = fs.path.split(file_path)\n-            with open_fs(dir_path).open(file_name, 'w') as file:\n-                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+        if self.verify_user_token():\n+            # Setting default filename path for filedialogue\n+            default_filename = self.active_project_name + \".ftml\"\n+            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n+            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            file_name = fs.path.basename(file_path)\n+            file_name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                dir_path, file_name = fs.path.split(file_path)\n+                with open_fs(dir_path).open(file_name, 'w') as file:\n+                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+            else:\n+                _function = self.export_plugins[file_ext[1:]]\n+                _function(file_path, file_name, self.waypoints_model.waypoints)\n+                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n         else:\n-            _function = self.export_plugins[file_ext[1:]]\n-            _function(file_path, file_name, self.waypoints_model.waypoints)\n-            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def disable_project_buttons(self):\n         self.save_ft.setEnabled(False)\n@@ -399,16 +408,20 @@ def add_project_handler(self):\n             return\n         else:\n             logging.debug(self.token)\n-        self.proj_diag = QtWidgets.QDialog()\n-        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n-        self.add_proj_dialog.setupUi(self.proj_diag)\n-        self.add_proj_dialog.f_content = None\n-        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n-        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n-        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n-        self.proj_diag.show()\n+        if self.verify_user_token():\n+            self.proj_diag = QtWidgets.QDialog()\n+            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n+            self.add_proj_dialog.setupUi(self.proj_diag)\n+            self.add_proj_dialog.f_content = None\n+            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n+            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n+            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n+            self.proj_diag.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def check_and_enable_project_accept(self):\n         if self.add_proj_dialog.path.text() != \"\" and self.add_proj_dialog.description.toPlainText() != \"\":\n@@ -517,84 +530,100 @@ def open_help_dialog(self):\n             self.help_dialog.show()\n \n     def handle_delete_project(self):\n-        entered_project_name, ok = QtWidgets.QInputDialog.getText(\n-            self,\n-            self.tr('Delete Project'),\n-            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n-                    f\"Enter the project name to confirm: \"))\n-        if ok:\n-            if entered_project_name == self.active_project_name:\n-                data = {\n-                    \"token\": self.token,\n-                    \"p_id\": self.active_pid\n-                }\n-                url = url_join(self.mscolab_server_url, 'delete_project')\n-                try:\n-                    res = requests.post(url, data=data)\n-                    res.raise_for_status()\n-                except requests.exceptions.RequestException as e:\n-                    logging.debug(e)\n-                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n-            else:\n-                show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        if self.verify_user_token():\n+            entered_project_name, ok = QtWidgets.QInputDialog.getText(\n+                self,\n+                self.tr('Delete Project'),\n+                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n+                        f\"Enter the project name to confirm: \"))\n+            if ok:\n+                if entered_project_name == self.active_project_name:\n+                    data = {\n+                        \"token\": self.token,\n+                        \"p_id\": self.active_pid\n+                    }\n+                    url = url_join(self.mscolab_server_url, 'delete_project')\n+                    try:\n+                        res = requests.post(url, data=data)\n+                        res.raise_for_status()\n+                    except requests.exceptions.RequestException as e:\n+                        logging.debug(e)\n+                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n+                else:\n+                    show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_chat_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.chat_window is not None:\n-            self.chat_window.raise_()\n-            self.chat_window.activateWindow()\n-            return\n+            if self.chat_window is not None:\n+                self.chat_window.raise_()\n+                self.chat_window.activateWindow()\n+                return\n \n-        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n-                                                   self.access_level, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.chat_window.viewCloses.connect(self.close_chat_window)\n-        self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.chat_window.show()\n+            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n+                                                       self.access_level, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.chat_window.viewCloses.connect(self.close_chat_window)\n+            self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.chat_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_chat_window(self):\n         self.raise_()\n         self.chat_window = None\n \n     def open_admin_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.admin_window is not None:\n-            self.admin_window.raise_()\n-            self.admin_window.activateWindow()\n-            return\n+            if self.admin_window is not None:\n+                self.admin_window.raise_()\n+                self.admin_window.activateWindow()\n+                return\n \n-        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n-                                                   self.active_project_name, self.projects, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.admin_window.viewCloses.connect(self.close_admin_window)\n-        self.admin_window.show()\n+            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n+                                                       self.active_project_name, self.projects, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.admin_window.viewCloses.connect(self.close_admin_window)\n+            self.admin_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_admin_window(self):\n         self.raise_()\n         self.admin_window = None\n \n     def open_version_history_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.version_window is not None:\n-            self.version_window.raise_()\n-            self.version_window.activateWindow()\n-            return\n+            if self.version_window is not None:\n+                self.version_window.raise_()\n+                self.version_window.activateWindow()\n+                return\n \n-        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n-                                                        self.active_project_name, self.conn,\n-                                                        mscolab_server_url=self.mscolab_server_url)\n-        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.version_window.viewCloses.connect(self.close_version_history_window)\n-        self.version_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.version_window.show()\n+            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n+                                                            self.active_project_name, self.conn,\n+                                                            mscolab_server_url=self.mscolab_server_url)\n+            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.version_window.viewCloses.connect(self.close_version_history_window)\n+            self.version_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.version_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_version_history_window(self):\n         self.raise_()\n@@ -611,34 +640,49 @@ def create_local_project_file(self):\n             mss_dir.writetext(rel_file_path, server_data)\n \n     def handle_work_locally_toggle(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            if self.version_window is not None:\n-                self.version_window.close()\n-            self.create_local_project_file()\n-            self.local_ftml_file = fs.path.combine(self.data_dir,\n-                                                   fs.path.join('local_mscolab_data',\n-                                                                self.user['username'], self.active_project_name,\n-                                                                'mscolab_project.ftml'))\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Local File. Your changes are only available to you.\"\n-                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n-            self.save_ft.setEnabled(True)\n-            self.fetch_ft.setEnabled(True)\n-            self.versionHistoryBtn.setEnabled(False)\n-            self.reload_local_wp()\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                if self.version_window is not None:\n+                    self.version_window.close()\n+                self.create_local_project_file()\n+                self.local_ftml_file = fs.path.combine(self.data_dir,\n+                                                       fs.path.join('local_mscolab_data',\n+                                                                    self.user['username'], self.active_project_name,\n+                                                                    'mscolab_project.ftml'))\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Local File. Your changes are only available to you.\"\n+                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n+                self.save_ft.setEnabled(True)\n+                self.fetch_ft.setEnabled(True)\n+                self.versionHistoryBtn.setEnabled(False)\n+                self.reload_local_wp()\n \n+            else:\n+                self.local_ftml_file = None\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n+                            \"Turn on work locally to work on local flight track file\"))\n+                self.save_ft.setEnabled(False)\n+                self.fetch_ft.setEnabled(False)\n+                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n+                    self.versionHistoryBtn.setEnabled(True)\n+                self.waypoints_model = None\n+                self.load_wps_from_server()\n+            self.reload_view_windows()\n         else:\n-            self.local_ftml_file = None\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                        \"Turn on work locally to work on local flight track file\"))\n-            self.save_ft.setEnabled(False)\n-            self.fetch_ft.setEnabled(False)\n-            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n-                self.versionHistoryBtn.setEnabled(True)\n-            self.waypoints_model = None\n-            self.load_wps_from_server()\n-        self.reload_view_windows()\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n+\n+    def verify_user_token(self):\n+        data = {\n+            \"token\": self.token\n+        }\n+        try:\n+            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)\n+        except requests.exceptions.ConnectionError as ex:\n+            logging.error(\"unexpected error: %s %s\", type(ex), ex)\n+            return False\n+        return r.text == \"True\"\n \n     def authorize(self):\n         for key, value in config_loader(dataset=\"MSC_login\").items():\n@@ -701,52 +745,64 @@ def after_authorize(self, emailid, r):\n \n     def add_projects(self):\n         # add projects\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            self.projects = _json[\"projects\"]\n-            self.add_projects_to_ui(self.projects)\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                self.projects = _json[\"projects\"]\n+                self.add_projects_to_ui(self.projects)\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_pid(self):\n         \"\"\"\n         get most recent project's p_id\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            p_id = None\n-            if projects:\n-                p_id = projects[-1][\"p_id\"]\n-            return p_id\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                p_id = None\n+                if projects:\n+                    p_id = projects[-1][\"p_id\"]\n+                return p_id\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_project(self):\n         \"\"\"\n         get most recent project\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            recent_project = None\n-            if projects:\n-                recent_project = projects[-1]\n-            return recent_project\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                recent_project = None\n+                if projects:\n+                    recent_project = projects[-1]\n+                return recent_project\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def add_projects_to_ui(self, projects):\n         logging.debug(\"adding projects to ui\")\n@@ -772,45 +828,47 @@ def force_close_view_windows(self):\n         self.active_windows = []\n \n     def set_active_pid(self, item):\n-        if item.p_id == self.active_pid:\n-            return\n-        # close all hanging window\n-        self.force_close_view_windows()\n-        self.close_external_windows()\n-        # Turn off work locally toggle\n-        self.workLocallyCheckBox.blockSignals(True)\n-        self.workLocallyCheckBox.setChecked(False)\n-        self.workLocallyCheckBox.blockSignals(False)\n-        self.save_ft.setEnabled(False)\n-        self.fetch_ft.setEnabled(False)\n-\n-        # set active_pid here\n-        self.active_pid = item.p_id\n-        self.access_level = item.access_level\n-        self.active_project_name = item.text().split(\"-\")[0].strip()\n-        self.waypoints_model = None\n-        # set active flightpath here\n-        self.load_wps_from_server()\n-        # enable project specific buttons\n-        self.helperTextLabel.setVisible(True)\n-        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                                             \"Turn on work locally to work on local flight track file\"))\n-        self.importBtn.setEnabled(True)\n-        self.exportBtn.setEnabled(True)\n-        self.topview.setEnabled(True)\n-        self.sideview.setEnabled(True)\n-        self.tableview.setEnabled(True)\n-        self.workLocallyCheckBox.setEnabled(True)\n-\n-        # enable access level specific buttons\n-        self.handle_mscolab_buttons()\n-\n-        # change font style for selected\n-        font = QtGui.QFont()\n-        for i in range(self.listProjects.count()):\n-            self.listProjects.item(i).setFont(font)\n-        font.setBold(True)\n-        item.setFont(font)\n+        if self.verify_user_token():\n+            if item.p_id == self.active_pid:\n+                return\n+            # close all hanging window\n+            self.force_close_view_windows()\n+            self.close_external_windows()\n+            # Turn off work locally toggle\n+            self.workLocallyCheckBox.blockSignals(True)\n+            self.workLocallyCheckBox.setChecked(False)\n+            self.workLocallyCheckBox.blockSignals(False)\n+            self.save_ft.setEnabled(False)\n+            self.fetch_ft.setEnabled(False)\n+            # set active_pid here\n+            self.active_pid = item.p_id\n+            self.access_level = item.access_level\n+            self.active_project_name = item.text().split(\"-\")[0].strip()\n+            self.waypoints_model = None\n+            # set active flightpath here\n+            self.load_wps_from_server()\n+            # enable project specific buttons\n+            self.helperTextLabel.setVisible(True)\n+            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"\n+                                                 \"All your changes will be shared with everyone.\"\n+                                                 \"Turn on work locally to work on local flight track file\"))\n+            self.importBtn.setEnabled(True)\n+            self.exportBtn.setEnabled(True)\n+            self.topview.setEnabled(True)\n+            self.sideview.setEnabled(True)\n+            self.tableview.setEnabled(True)\n+            self.workLocallyCheckBox.setEnabled(True)\n+            # enable access level specific buttons\n+            self.handle_mscolab_buttons()\n+            # change font style for selected\n+            font = QtGui.QFont()\n+            for i in range(self.listProjects.count()):\n+                self.listProjects.item(i).setFont(font)\n+            font.setBold(True)\n+            item.setFont(font)\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_wps_from_server(self):\n         if self.active_pid is None:\n@@ -819,16 +877,20 @@ def reload_wps_from_server(self):\n         self.reload_view_windows()\n \n     def request_wps_from_server(self):\n-        data = {\n-            \"token\": self.token,\n-            \"p_id\": self.active_pid\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n-        if r.text != \"False\":\n-            xml_content = json.loads(r.text)[\"content\"]\n-            return xml_content\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token,\n+                \"p_id\": self.active_pid\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n+            if r.text != \"False\":\n+                xml_content = json.loads(r.text)[\"content\"]\n+                return xml_content\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def load_wps_from_server(self):\n         if self.workLocallyCheckBox.isChecked():\n@@ -840,21 +902,33 @@ def load_wps_from_server(self):\n \n     def open_topview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"topview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"topview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_sideview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"sideview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"sideview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_tableview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"tableview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"tableview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def create_view_window(self, _type):\n         for active_window in self.active_windows:\n@@ -943,18 +1017,22 @@ def logout(self):\n         self.password.setEnabled(True)\n \n     def delete_account(self):\n-        w = QtWidgets.QWidget()\n-        qm = QtWidgets.QMessageBox\n-        reply = qm.question(w, self.tr('Continue?'),\n-                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n-                            qm.Yes, qm.No)\n-        if reply == QtWidgets.QMessageBox.No:\n-            return\n-        data = {\n-            \"token\": self.token\n-        }\n-        requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n-        self.clean_up_window()\n+        if self.verify_user_token():\n+            w = QtWidgets.QWidget()\n+            qm = QtWidgets.QMessageBox\n+            reply = qm.question(w, self.tr('Continue?'),\n+                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n+                                qm.Yes, qm.No)\n+            if reply == QtWidgets.QMessageBox.No:\n+                return\n+            data = {\n+                \"token\": self.token\n+            }\n+            requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n+            self.clean_up_window()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_external_windows(self):\n         if self.chat_window is not None:\n@@ -995,27 +1073,35 @@ def clean_up_window(self):\n         save_settings_qsettings('mscolab', self.settings)\n \n     def save_wp_mscolab(self, comment=None):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_waypoints_changed(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+            else:\n+                xml_content = self.waypoints_model.get_xml_content()\n+                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n         else:\n-            xml_content = self.waypoints_model.get_xml_content()\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_view_windows(self):\n         for window in self.active_windows:\n@@ -1032,19 +1118,23 @@ def reload_local_wp(self):\n         self.reload_view_windows()\n \n     def fetch_wp_mscolab(self):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int, int, str)\n     def handle_update_permission(self, p_id, u_id, access_level):\n@@ -1147,7 +1237,8 @@ def render_new_permission(self, p_id, u_id):\n             if self.chat_window is not None:\n                 self.chat_window.load_users()\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int)\n     def handle_project_deleted(self, p_id):\ndiff --git a\/mslib\/msui\/socket_control.py b\/mslib\/msui\/socket_control.py\nindex 21ca4b038..b7e03e060 100644\n--- a\/mslib\/msui\/socket_control.py\n+++ b\/mslib\/msui\/socket_control.py\n@@ -161,6 +161,7 @@ def delete_message(self, message_id, p_id):\n         })\n \n     def save_file(self, token, p_id, content, comment=None):\n+        # ToDo refactor API\n         logging.debug(\"saving file\")\n         self.sio.emit('file-save', {\n                       \"p_id\": p_id,\n","files":{"\/mslib\/mscolab\/sockets_manager.py":{"changes":[{"diff":"\n             # if permission is correct and file saved properly\n             if perm and self.fm.save_file(int(p_id), content, user, comment):\n                 # send service message\n-                message_ = \"[service message] saved changes\"\n+                message_ = f\"[service message] **{user.username}** saved changes\"\n                 new_message = self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE)\n                 new_message_dict = get_message_dict(new_message)\n                 socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                 # emit file-changed event to trigger reload of flight track\n                 socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id))\n+        else:\n+            logging.debug(f'login expired for {user.username}, state unauthorized!')\n \n     def emit_file_change(self, p_id):\n         socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id))","add":3,"remove":1,"filename":"\/mslib\/mscolab\/sockets_manager.py","badparts":["                message_ = \"[service message] saved changes\""],"goodparts":["                message_ = f\"[service message] **{user.username}** saved changes\"","        else:","            logging.debug(f'login expired for {user.username}, state unauthorized!')"]},{"diff":"\n             # if permission is correct and file saved properly\n             if perm and self.fm.save_file(int(p_id), content, user, comment):\n                 # send service message\n-                message_ = \"[service message] saved changes\"\n+                message_ = f\"[service message] **{user.username}** saved changes\"\n                 new_message = self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE)\n                 new_message_dict = get_message_dict(new_message)\n                 socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                 # emit file-changed event to trigger reload of flight track\n                 socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id))\n+        else:\n+            logging.debug(f'login expired for {user.username}, state unauthorized!')\n \n     def emit_file_change(self, p_id):\n         socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id))","add":3,"remove":1,"filename":"\/mslib\/mscolab\/sockets_manager.py","badparts":["                message_ = \"[service message] saved changes\""],"goodparts":["                message_ = f\"[service message] **{user.username}** saved changes\"","        else:","            logging.debug(f'login expired for {user.username}, state unauthorized!')"]}],"source":"\n \"\"\" mslib.mscolab.sockets_manager ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Code to handle socket connections in mscolab This file is part of mss. :copyright: Copyright 2019 Shivashis Padhi :copyright: Copyright 2019-2021 by the mss team, see AUTHORS. :license: APACHE-2.0, see LICENSE for details. Licensed under the Apache License, Version 2.0(the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:\/\/www.apache.org\/licenses\/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. \"\"\" import json import logging from flask import request from flask_socketio import SocketIO, join_room, leave_room from mslib.mscolab.chat_manager import ChatManager from mslib.mscolab.file_manager import FileManager from mslib.mscolab.models import MessageType, Permission, User from mslib.mscolab.utils import get_message_dict from mslib.mscolab.utils import get_session_id socketio=SocketIO() class SocketsManager(object): \"\"\"Class with handler functions for socket related\"\"\" def __init__(self, chat_manager, file_manager): \"\"\" chat_manager: Instance of ChatManager file_manager: Instance of FileManager \"\"\" super(SocketsManager, self).__init__() self.sockets=[] self.cm=chat_manager self.fm=file_manager def handle_connect(self): logging.debug(request.sid) def join_creator_to_room(self, json_config): \"\"\" json_config has: -token: authentication token -p_id: project id \"\"\" token=json_config['token'] user=User.verify_auth_token(token) if not user: return p_id=json_config['p_id'] join_room(str(p_id)) def join_collaborator_to_room(self, u_id, p_id): \"\"\" json has: -u_id: user id(collaborator's id) -p_id: project id \"\"\" s_id=get_session_id(self.sockets, u_id) if s_id is not None: join_room(str(p_id), sid=s_id, namespace='\/') def remove_collaborator_from_room(self, u_id, p_id): s_id=get_session_id(self.sockets, u_id) if s_id is not None: leave_room(str(p_id), sid=s_id, namespace='\/') def handle_start_event(self, json): \"\"\" json is a dictionary version of data sent to backend \"\"\" logging.info('received json: ' +str(json)) token=json['token'] user=User.verify_auth_token(token) if not user: return permissions=Permission.query.filter_by(u_id=user.id).all() for permission in permissions: \"\"\" -a client is always registered as a room with name equal to the session id of the client. -so the rooms can safely be named as stringified versions of the project id. -thus, an abstraction is unnecessary. if it will be, it'll be considered during later developments. -so joining the actual socketio room would be enough \"\"\" join_room(str(permission.p_id)) socket_storage={ 's_id': request.sid, 'u_id': user.id } self.sockets.append(socket_storage) def handle_disconnect(self): logging.info(\"disconnected\") logging.info(request.sid) self.sockets[:]=[d for d in self.sockets if d['s_id'] !=request.sid] def handle_message(self, _json): \"\"\" json is a dictionary version of data sent to back-end \"\"\" p_id=_json['p_id'] reply_id=int(_json[\"reply_id\"]) user=User.verify_auth_token(_json['token']) if user is not None: perm=self.permission_check_emit(user.id, int(p_id)) if perm: new_message=self.cm.add_message(user, _json['message_text'], str(p_id), reply_id=reply_id) new_message_dict=get_message_dict(new_message) if reply_id==-1: socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id)) else: socketio.emit('chat-message-reply-client', json.dumps(new_message_dict), room=str(p_id)) def handle_message_edit(self, socket_message): message_id=socket_message[\"message_id\"] p_id=socket_message[\"p_id\"] new_message_text=socket_message[\"new_message_text\"] user=User.verify_auth_token(socket_message[\"token\"]) if user is not None: perm=self.permission_check_emit(user.id, int(p_id)) if perm: self.cm.edit_message(message_id, new_message_text) socketio.emit('edit-message-client', json.dumps({ \"message_id\": message_id, \"new_message_text\": new_message_text }), room=str(p_id)) def handle_message_delete(self, socket_message): message_id=socket_message[\"message_id\"] p_id=socket_message[\"p_id\"] user=User.verify_auth_token(socket_message['token']) if user is not None: perm=self.permission_check_emit(user.id, int(p_id)) if perm: self.cm.delete_message(message_id) socketio.emit('delete-message-client', json.dumps({\"message_id\": message_id}), room=str(p_id)) def permission_check_emit(self, u_id, p_id): \"\"\" u_id: user-id p_id: project-id \"\"\" permission=Permission.query.filter_by(u_id=u_id, p_id=p_id).first() if not permission: return False if permission.access_level==\"viewer\": return False return True def permission_check_admin(self, u_id, p_id): \"\"\" u_id: user-id p_id: project-id \"\"\" permission=Permission.query.filter_by(u_id=u_id, p_id=p_id).first() if permission.access_level==\"creator\" or permission.access_level==\"admin\": return True else: return False def handle_file_save(self, json_req): \"\"\" json_req:{ \"p_id\": process id \"content\": content of the file \"comment\": comment for file-save, defaults to None } \"\"\" p_id=json_req['p_id'] content=json_req['content'] comment=json_req.get('comment', \"\") user=User.verify_auth_token(json_req['token']) if user is not None: perm=self.permission_check_emit(user.id, int(p_id)) if perm and self.fm.save_file(int(p_id), content, user, comment): message_=\"[service message] saved changes\" new_message=self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE) new_message_dict=get_message_dict(new_message) socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id)) socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id)) def emit_file_change(self, p_id): socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id)) def emit_new_permission(self, u_id, p_id): \"\"\" to refresh project list of u_id and to refresh collaborators' list \"\"\" socketio.emit('new-permission', json.dumps({\"p_id\": p_id, \"u_id\": u_id}), room=str(p_id)) def emit_update_permission(self, u_id, p_id, access_level=None): \"\"\" to refresh permissions in msui \"\"\" if access_level is None: perm=Permission.query.filter_by(u_id=u_id, p_id=p_id).first() access_level=perm.access_level logging.debug(\"access_level by database query\") socketio.emit('update-permission', json.dumps({\"p_id\": p_id, \"u_id\": u_id, \"access_level\": access_level}), room=str(p_id)) def emit_revoke_permission(self, u_id, p_id): socketio.emit(\"revoke-permission\", json.dumps({\"p_id\": p_id, \"u_id\": u_id}), room=str(p_id)) def emit_project_permissions_updated(self, u_id, p_id): socketio.emit(\"project-permissions-updated\", json.dumps({\"u_id\": u_id}), room=str(p_id)) def emit_project_delete(self, p_id): socketio.emit(\"project-deleted\", json.dumps({\"p_id\": p_id}), room=str(p_id)) def setup_managers(app): \"\"\" takes app as parameter to extract config data, initializes ChatManager, FileManager, SocketManager and return them similarly for FileManager and SocketManager(already done for this) \"\"\" cm=ChatManager() fm=FileManager(app.config[\"MSCOLAB_DATA_DIR\"]) sm=SocketsManager(cm, fm) socketio.on_event('connect', sm.handle_connect) socketio.on_event('start', sm.handle_start_event) socketio.on_event('disconnect', sm.handle_disconnect) socketio.on_event('chat-message', sm.handle_message) socketio.on_event('edit-message', sm.handle_message_edit) socketio.on_event('delete-message', sm.handle_message_delete) socketio.on_event('file-save', sm.handle_file_save) socketio.on_event('add-user-to-room', sm.join_creator_to_room) socketio.sm=sm return socketio, cm, fm ","sourceWithComments":"# -*- coding: utf-8 -*-\n\"\"\"\n\n    mslib.mscolab.sockets_manager\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Code to handle socket connections in mscolab\n\n    This file is part of mss.\n\n    :copyright: Copyright 2019 Shivashis Padhi\n    :copyright: Copyright 2019-2021 by the mss team, see AUTHORS.\n    :license: APACHE-2.0, see LICENSE for details.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\nimport json\nimport logging\nfrom flask import request\nfrom flask_socketio import SocketIO, join_room, leave_room\n\nfrom mslib.mscolab.chat_manager import ChatManager\nfrom mslib.mscolab.file_manager import FileManager\nfrom mslib.mscolab.models import MessageType, Permission, User\nfrom mslib.mscolab.utils import get_message_dict\nfrom mslib.mscolab.utils import get_session_id\n\nsocketio = SocketIO()\n\n\nclass SocketsManager(object):\n    \"\"\"Class with handler functions for socket related\"\"\"\n\n    def __init__(self, chat_manager, file_manager):\n        \"\"\"\n        chat_manager: Instance of ChatManager\n        file_manager: Instance of FileManager\n        \"\"\"\n        super(SocketsManager, self).__init__()\n        self.sockets = []\n        self.cm = chat_manager\n        self.fm = file_manager\n\n    def handle_connect(self):\n        logging.debug(request.sid)\n\n    def join_creator_to_room(self, json_config):\n        \"\"\"\n        json_config has:\n            - token: authentication token\n            - p_id: project id\n        \"\"\"\n        token = json_config['token']\n        user = User.verify_auth_token(token)\n        if not user:\n            return\n        p_id = json_config['p_id']\n        join_room(str(p_id))\n\n    def join_collaborator_to_room(self, u_id, p_id):\n        \"\"\"\n        json has:\n            - u_id: user id(collaborator's id)\n            - p_id: project id\n        \"\"\"\n        s_id = get_session_id(self.sockets, u_id)\n        if s_id is not None:\n            join_room(str(p_id), sid=s_id, namespace='\/')\n\n    def remove_collaborator_from_room(self, u_id, p_id):\n        s_id = get_session_id(self.sockets, u_id)\n        if s_id is not None:\n            leave_room(str(p_id), sid=s_id, namespace='\/')\n\n    def handle_start_event(self, json):\n        \"\"\"\n        json is a dictionary version of data sent to backend\n        \"\"\"\n        logging.info('received json: ' + str(json))\n        # authenticate socket\n        token = json['token']\n        user = User.verify_auth_token(token)\n        if not user:\n            return\n\n        # fetch projects\n        permissions = Permission.query.filter_by(u_id=user.id).all()\n\n        # for all the p_id in permissions, there'd be chatrooms in self.rooms\n        # search and add user to respective rooms\n        for permission in permissions:\n            # for each project with p_id, search rooms\n            # socketio.join_room(room, sid=None, namespace=None)\n            \"\"\"\n            - a client is always registered as a room with name equal to\n            the session id of the client.\n            - so the rooms can safely be named as stringified versions of\n            the project id.\n            - thus, an abstraction is unnecessary. if it will be, it'll be\n            considered during later developments.\n            - so joining the actual socketio room would be enough\n            \"\"\"\n            join_room(str(permission.p_id))\n        socket_storage = {\n            's_id': request.sid,\n            'u_id': user.id\n        }\n        self.sockets.append(socket_storage)\n\n    def handle_disconnect(self):\n        logging.info(\"disconnected\")\n        logging.info(request.sid)\n        # remove socket from socket_storage\n        self.sockets[:] = [d for d in self.sockets if d['s_id'] != request.sid]\n\n    def handle_message(self, _json):\n        \"\"\"\n        json is a dictionary version of data sent to back-end\n        \"\"\"\n        p_id = _json['p_id']\n        reply_id = int(_json[\"reply_id\"])\n        user = User.verify_auth_token(_json['token'])\n        if user is not None:\n            perm = self.permission_check_emit(user.id, int(p_id))\n            if perm:\n                new_message = self.cm.add_message(user, _json['message_text'], str(p_id), reply_id=reply_id)\n                new_message_dict = get_message_dict(new_message)\n                if reply_id == -1:\n                    socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                else:\n                    socketio.emit('chat-message-reply-client', json.dumps(new_message_dict), room=str(p_id))\n\n    def handle_message_edit(self, socket_message):\n        message_id = socket_message[\"message_id\"]\n        p_id = socket_message[\"p_id\"]\n        new_message_text = socket_message[\"new_message_text\"]\n        user = User.verify_auth_token(socket_message[\"token\"])\n        if user is not None:\n            perm = self.permission_check_emit(user.id, int(p_id))\n            if perm:\n                self.cm.edit_message(message_id, new_message_text)\n                socketio.emit('edit-message-client', json.dumps({\n                    \"message_id\": message_id,\n                    \"new_message_text\": new_message_text\n                }), room=str(p_id))\n\n    def handle_message_delete(self, socket_message):\n        message_id = socket_message[\"message_id\"]\n        p_id = socket_message[\"p_id\"]\n        user = User.verify_auth_token(socket_message['token'])\n        if user is not None:\n            perm = self.permission_check_emit(user.id, int(p_id))\n            if perm:\n                self.cm.delete_message(message_id)\n                socketio.emit('delete-message-client', json.dumps({\"message_id\": message_id}), room=str(p_id))\n\n    def permission_check_emit(self, u_id, p_id):\n        \"\"\"\n        u_id: user-id\n        p_id: project-id\n        \"\"\"\n        permission = Permission.query.filter_by(u_id=u_id, p_id=p_id).first()\n        if not permission:\n            return False\n        if permission.access_level == \"viewer\":\n            return False\n        return True\n\n    def permission_check_admin(self, u_id, p_id):\n        \"\"\"\n        u_id: user-id\n        p_id: project-id\n        \"\"\"\n        permission = Permission.query.filter_by(u_id=u_id, p_id=p_id).first()\n        if permission.access_level == \"creator\" or permission.access_level == \"admin\":\n            return True\n        else:\n            return False\n\n    def handle_file_save(self, json_req):\n        \"\"\"\n        json_req: {\n            \"p_id\": process id\n            \"content\": content of the file\n            \"comment\": comment for file-save, defaults to None\n        }\n        \"\"\"\n\n        p_id = json_req['p_id']\n        content = json_req['content']\n        comment = json_req.get('comment', \"\")\n        user = User.verify_auth_token(json_req['token'])\n        if user is not None:\n            # when the socket connection is expired this in None and also on wrong tokens\n            perm = self.permission_check_emit(user.id, int(p_id))\n            # if permission is correct and file saved properly\n            if perm and self.fm.save_file(int(p_id), content, user, comment):\n                # send service message\n                message_ = \"[service message] saved changes\"\n                new_message = self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE)\n                new_message_dict = get_message_dict(new_message)\n                socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                # emit file-changed event to trigger reload of flight track\n                socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id))\n\n    def emit_file_change(self, p_id):\n        socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id))\n\n    def emit_new_permission(self, u_id, p_id):\n        \"\"\"\n        to refresh project list of u_id\n        and to refresh collaborators' list\n        \"\"\"\n        socketio.emit('new-permission', json.dumps({\"p_id\": p_id, \"u_id\": u_id}), room=str(p_id))\n\n    def emit_update_permission(self, u_id, p_id, access_level=None):\n        \"\"\"\n        to refresh permissions in msui\n        \"\"\"\n        if access_level is None:\n            perm = Permission.query.filter_by(u_id=u_id, p_id=p_id).first()\n            access_level = perm.access_level\n            logging.debug(\"access_level by database query\")\n\n        socketio.emit('update-permission', json.dumps({\"p_id\": p_id,\n                                                       \"u_id\": u_id,\n                                                       \"access_level\": access_level}), room=str(p_id))\n\n    def emit_revoke_permission(self, u_id, p_id):\n        socketio.emit(\"revoke-permission\", json.dumps({\"p_id\": p_id, \"u_id\": u_id}), room=str(p_id))\n\n    def emit_project_permissions_updated(self, u_id, p_id):\n        socketio.emit(\"project-permissions-updated\", json.dumps({\"u_id\": u_id}), room=str(p_id))\n\n    def emit_project_delete(self, p_id):\n        socketio.emit(\"project-deleted\", json.dumps({\"p_id\": p_id}), room=str(p_id))\n\n\ndef setup_managers(app):\n    \"\"\"\n    takes app as parameter to extract config data,\n    initializes ChatManager, FileManager, SocketManager and return them\n    #ToDo return socketio and integrate socketio.cm = ChatManager()\n    similarly for FileManager and SocketManager(already done for this)\n    \"\"\"\n\n    cm = ChatManager()\n    fm = FileManager(app.config[\"MSCOLAB_DATA_DIR\"])\n    sm = SocketsManager(cm, fm)\n    # sockets related handlers\n    socketio.on_event('connect', sm.handle_connect)\n    socketio.on_event('start', sm.handle_start_event)\n    socketio.on_event('disconnect', sm.handle_disconnect)\n    socketio.on_event('chat-message', sm.handle_message)\n    socketio.on_event('edit-message', sm.handle_message_edit)\n    socketio.on_event('delete-message', sm.handle_message_delete)\n    socketio.on_event('file-save', sm.handle_file_save)\n    socketio.on_event('add-user-to-room', sm.join_creator_to_room)\n    socketio.sm = sm\n    return socketio, cm, fm\n"},"\/mslib\/msui\/mscolab.py":{"changes":[{"diff":"\n         self.loginButton.setEnabled(self.emailid.text() != \"\" and self.password.text() != \"\")\n \n     def handle_import(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n-        else:\n-            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]\n-            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        dir_path, file_name = fs.path.split(file_path)\n-        file_name = fs.path.basename(file_path)\n-        name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            with open_fs(dir_path) as file_dir:\n-                xml_content = file_dir.readtext(file_name)\n-            try:\n-                model = ft.WaypointsTableModel(xml_content=xml_content)\n-            except SyntaxError:\n-                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n-                return\n-            self.waypoints_model = model\n+        if self.verify_user_token():\n             if self.workLocallyCheckBox.isChecked():\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n             else:\n+                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"\n+                                                         for ext in self.import_plugins.keys()]\n+                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            dir_path, file_name = fs.path.split(file_path)\n+            file_name = fs.path.basename(file_path)\n+            name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                with open_fs(dir_path) as file_dir:\n+                    xml_content = file_dir.readtext(file_name)\n+                try:\n+                    model = ft.WaypointsTableModel(xml_content=xml_content)\n+                except SyntaxError:\n+                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n+                    return\n+                self.waypoints_model = model\n+                if self.workLocallyCheckBox.isChecked():\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                else:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            else:\n+                _function = self.import_plugins[file_ext[1:]]\n+                _, new_waypoints = _function(file_path)\n+                model = ft.WaypointsTableModel(waypoints=new_waypoints)\n+                self.waypoints_model = model\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n                 self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n                 self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            self.reload_view_windows()\n+            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n         else:\n-            _function = self.import_plugins[file_ext[1:]]\n-            _, new_waypoints = _function(file_path)\n-            model = ft.WaypointsTableModel(waypoints=new_waypoints)\n-            self.waypoints_model = model\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n-            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-        self.reload_view_windows()\n-        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_export(self):\n-        # Setting default filename path for filedialogue\n-        default_filename = self.active_project_name + \".ftml\"\n-        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n-        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        file_name = fs.path.basename(file_path)\n-        file_name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            dir_path, file_name = fs.path.split(file_path)\n-            with open_fs(dir_path).open(file_name, 'w') as file:\n-                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+        if self.verify_user_token():\n+            # Setting default filename path for filedialogue\n+            default_filename = self.active_project_name + \".ftml\"\n+            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n+            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            file_name = fs.path.basename(file_path)\n+            file_name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                dir_path, file_name = fs.path.split(file_path)\n+                with open_fs(dir_path).open(file_name, 'w') as file:\n+                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+            else:\n+                _function = self.export_plugins[file_ext[1:]]\n+                _function(file_path, file_name, self.waypoints_model.waypoints)\n+                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n         else:\n-            _function = self.export_plugins[file_ext[1:]]\n-            _function(file_path, file_name, self.waypoints_model.waypoints)\n-            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def disable_project_buttons(self):\n         self.save_ft.setEnabled(False)\n","add":56,"remove":47,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.workLocallyCheckBox.isChecked():","            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")","        else:","            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]","            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))","        if file_path is None:","            return","        dir_path, file_name = fs.path.split(file_path)","        file_name = fs.path.basename(file_path)","        name, file_ext = fs.path.splitext(file_name)","        if file_ext[1:] == \"ftml\":","            with open_fs(dir_path) as file_dir:","                xml_content = file_dir.readtext(file_name)","            try:","                model = ft.WaypointsTableModel(xml_content=xml_content)","            except SyntaxError:","                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")","                return","            self.waypoints_model = model","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","            _function = self.import_plugins[file_ext[1:]]","            _, new_waypoints = _function(file_path)","            model = ft.WaypointsTableModel(waypoints=new_waypoints)","            self.waypoints_model = model","            xml_doc = self.waypoints_model.get_xml_doc()","            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")","            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","        self.reload_view_windows()","        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)","        default_filename = self.active_project_name + \".ftml\"","        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]","        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))","        if file_path is None:","            return","        file_name = fs.path.basename(file_path)","        file_name, file_ext = fs.path.splitext(file_name)","        if file_ext[1:] == \"ftml\":","            xml_doc = self.waypoints_model.get_xml_doc()","            dir_path, file_name = fs.path.split(file_path)","            with open_fs(dir_path).open(file_name, 'w') as file:","                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")","            _function = self.export_plugins[file_ext[1:]]","            _function(file_path, file_name, self.waypoints_model.waypoints)","            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)"],"goodparts":["        if self.verify_user_token():","                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")","                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"","                                                         for ext in self.import_plugins.keys()]","                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))","            if file_path is None:","                return","            dir_path, file_name = fs.path.split(file_path)","            file_name = fs.path.basename(file_path)","            name, file_ext = fs.path.splitext(file_name)","            if file_ext[1:] == \"ftml\":","                with open_fs(dir_path) as file_dir:","                    xml_content = file_dir.readtext(file_name)","                try:","                    model = ft.WaypointsTableModel(xml_content=xml_content)","                except SyntaxError:","                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")","                    return","                self.waypoints_model = model","                if self.workLocallyCheckBox.isChecked():","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                else:","                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","            else:","                _function = self.import_plugins[file_ext[1:]]","                _, new_waypoints = _function(file_path)","                model = ft.WaypointsTableModel(waypoints=new_waypoints)","                self.waypoints_model = model","                xml_doc = self.waypoints_model.get_xml_doc()","                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")","            self.reload_view_windows()","            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            default_filename = self.active_project_name + \".ftml\"","            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]","            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))","            if file_path is None:","                return","            file_name = fs.path.basename(file_path)","            file_name, file_ext = fs.path.splitext(file_name)","            if file_ext[1:] == \"ftml\":","                xml_doc = self.waypoints_model.get_xml_doc()","                dir_path, file_name = fs.path.split(file_path)","                with open_fs(dir_path).open(file_name, 'w') as file:","                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")","            else:","                _function = self.export_plugins[file_ext[1:]]","                _function(file_path, file_name, self.waypoints_model.waypoints)","                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             return\n         else:\n             logging.debug(self.token)\n-        self.proj_diag = QtWidgets.QDialog()\n-        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n-        self.add_proj_dialog.setupUi(self.proj_diag)\n-        self.add_proj_dialog.f_content = None\n-        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n-        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n-        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n-        self.proj_diag.show()\n+        if self.verify_user_token():\n+            self.proj_diag = QtWidgets.QDialog()\n+            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n+            self.add_proj_dialog.setupUi(self.proj_diag)\n+            self.add_proj_dialog.f_content = None\n+            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n+            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n+            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n+            self.proj_diag.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def check_and_enable_project_accept(self):\n         if self.add_proj_dialog.path.text() != \"\" and self.add_proj_dialog.description.toPlainText() != \"\":\n","add":14,"remove":10,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        self.proj_diag = QtWidgets.QDialog()","        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()","        self.add_proj_dialog.setupUi(self.proj_diag)","        self.add_proj_dialog.f_content = None","        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)","        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)","        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)","        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)","        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)","        self.proj_diag.show()"],"goodparts":["        if self.verify_user_token():","            self.proj_diag = QtWidgets.QDialog()","            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()","            self.add_proj_dialog.setupUi(self.proj_diag)","            self.add_proj_dialog.f_content = None","            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)","            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)","            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)","            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)","            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)","            self.proj_diag.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             self.help_dialog.show()\n \n     def handle_delete_project(self):\n-        entered_project_name, ok = QtWidgets.QInputDialog.getText(\n-            self,\n-            self.tr('Delete Project'),\n-            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n-                    f\"Enter the project name to confirm: \"))\n-        if ok:\n-            if entered_project_name == self.active_project_name:\n-                data = {\n-                    \"token\": self.token,\n-                    \"p_id\": self.active_pid\n-                }\n-                url = url_join(self.mscolab_server_url, 'delete_project')\n-                try:\n-                    res = requests.post(url, data=data)\n-                    res.raise_for_status()\n-                except requests.exceptions.RequestException as e:\n-                    logging.debug(e)\n-                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n-            else:\n-                show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        if self.verify_user_token():\n+            entered_project_name, ok = QtWidgets.QInputDialog.getText(\n+                self,\n+                self.tr('Delete Project'),\n+                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n+                        f\"Enter the project name to confirm: \"))\n+            if ok:\n+                if entered_project_name == self.active_project_name:\n+                    data = {\n+                        \"token\": self.token,\n+                        \"p_id\": self.active_pid\n+                    }\n+                    url = url_join(self.mscolab_server_url, 'delete_project')\n+                    try:\n+                        res = requests.post(url, data=data)\n+                        res.raise_for_status()\n+                    except requests.exceptions.RequestException as e:\n+                        logging.debug(e)\n+                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n+                else:\n+                    show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_chat_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.chat_window is not None:\n-            self.chat_window.raise_()\n-            self.chat_window.activateWindow()\n-            return\n+            if self.chat_window is not None:\n+                self.chat_window.raise_()\n+                self.chat_window.activateWindow()\n+                return\n \n-        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n-                                                   self.access_level, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.chat_window.viewCloses.connect(self.close_chat_window)\n-        self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.chat_window.show()\n+            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n+                                                       self.access_level, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.chat_window.viewCloses.connect(self.close_chat_window)\n+            self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.chat_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_chat_window(self):\n         self.raise_()\n         self.chat_window = None\n \n     def open_admin_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.admin_window is not None:\n-            self.admin_window.raise_()\n-            self.admin_window.activateWindow()\n-            return\n+            if self.admin_window is not None:\n+                self.admin_window.raise_()\n+                self.admin_window.activateWindow()\n+                return\n \n-        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n-                                                   self.active_project_name, self.projects, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.admin_window.viewCloses.connect(self.close_admin_window)\n-        self.admin_window.show()\n+            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n+                                                       self.active_project_name, self.projects, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.admin_window.viewCloses.connect(self.close_admin_window)\n+            self.admin_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_admin_window(self):\n         self.raise_()\n         self.admin_window = None\n \n     def open_version_history_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.version_window is not None:\n-            self.version_window.raise_()\n-            self.version_window.activateWindow()\n-            return\n+            if self.version_window is not None:\n+                self.version_window.raise_()\n+                self.version_window.activateWindow()\n+                return\n \n-        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n-                                                        self.active_project_name, self.conn,\n-                                                        mscolab_server_url=self.mscolab_server_url)\n-        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.version_window.viewCloses.connect(self.close_version_history_window)\n-        self.version_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.version_window.show()\n+            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n+                                                            self.active_project_name, self.conn,\n+                                                            mscolab_server_url=self.mscolab_server_url)\n+            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.version_window.viewCloses.connect(self.close_version_history_window)\n+            self.version_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.version_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_version_history_window(self):\n         self.raise_()\n","add":74,"remove":58,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        entered_project_name, ok = QtWidgets.QInputDialog.getText(","            self,","            self.tr('Delete Project'),","            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"","                    f\"Enter the project name to confirm: \"))","        if ok:","            if entered_project_name == self.active_project_name:","                data = {","                    \"token\": self.token,","                    \"p_id\": self.active_pid","                }","                url = url_join(self.mscolab_server_url, 'delete_project')","                try:","                    res = requests.post(url, data=data)","                    res.raise_for_status()","                except requests.exceptions.RequestException as e:","                    logging.debug(e)","                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")","            else:","                show_popup(self, \"Error\", \"Entered project name did not match!\")","        if self.active_pid is None:","            return","        if self.chat_window is not None:","            self.chat_window.raise_()","            self.chat_window.activateWindow()","            return","        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,","                                                   self.access_level, self.conn,","                                                   mscolab_server_url=self.mscolab_server_url)","        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.chat_window.viewCloses.connect(self.close_chat_window)","        self.chat_window.reloadWindows.connect(self.reload_windows_slot)","        self.chat_window.show()","        if self.active_pid is None:","            return","        if self.admin_window is not None:","            self.admin_window.raise_()","            self.admin_window.activateWindow()","            return","        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,","                                                   self.active_project_name, self.projects, self.conn,","                                                   mscolab_server_url=self.mscolab_server_url)","        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.admin_window.viewCloses.connect(self.close_admin_window)","        self.admin_window.show()","        if self.active_pid is None:","            return","        if self.version_window is not None:","            self.version_window.raise_()","            self.version_window.activateWindow()","            return","        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,","                                                        self.active_project_name, self.conn,","                                                        mscolab_server_url=self.mscolab_server_url)","        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.version_window.viewCloses.connect(self.close_version_history_window)","        self.version_window.reloadWindows.connect(self.reload_windows_slot)","        self.version_window.show()"],"goodparts":["        if self.verify_user_token():","            entered_project_name, ok = QtWidgets.QInputDialog.getText(","                self,","                self.tr('Delete Project'),","                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"","                        f\"Enter the project name to confirm: \"))","            if ok:","                if entered_project_name == self.active_project_name:","                    data = {","                        \"token\": self.token,","                        \"p_id\": self.active_pid","                    }","                    url = url_join(self.mscolab_server_url, 'delete_project')","                    try:","                        res = requests.post(url, data=data)","                        res.raise_for_status()","                    except requests.exceptions.RequestException as e:","                        logging.debug(e)","                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")","                else:","                    show_popup(self, \"Error\", \"Entered project name did not match!\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.chat_window is not None:","                self.chat_window.raise_()","                self.chat_window.activateWindow()","                return","            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,","                                                       self.access_level, self.conn,","                                                       mscolab_server_url=self.mscolab_server_url)","            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.chat_window.viewCloses.connect(self.close_chat_window)","            self.chat_window.reloadWindows.connect(self.reload_windows_slot)","            self.chat_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.admin_window is not None:","                self.admin_window.raise_()","                self.admin_window.activateWindow()","                return","            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,","                                                       self.active_project_name, self.projects, self.conn,","                                                       mscolab_server_url=self.mscolab_server_url)","            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.admin_window.viewCloses.connect(self.close_admin_window)","            self.admin_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.version_window is not None:","                self.version_window.raise_()","                self.version_window.activateWindow()","                return","            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,","                                                            self.active_project_name, self.conn,","                                                            mscolab_server_url=self.mscolab_server_url)","            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.version_window.viewCloses.connect(self.close_version_history_window)","            self.version_window.reloadWindows.connect(self.reload_windows_slot)","            self.version_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             mss_dir.writetext(rel_file_path, server_data)\n \n     def handle_work_locally_toggle(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            if self.version_window is not None:\n-                self.version_window.close()\n-            self.create_local_project_file()\n-            self.local_ftml_file = fs.path.combine(self.data_dir,\n-                                                   fs.path.join('local_mscolab_data',\n-                                                                self.user['username'], self.active_project_name,\n-                                                                'mscolab_project.ftml'))\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Local File. Your changes are only available to you.\"\n-                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n-            self.save_ft.setEnabled(True)\n-            self.fetch_ft.setEnabled(True)\n-            self.versionHistoryBtn.setEnabled(False)\n-            self.reload_local_wp()\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                if self.version_window is not None:\n+                    self.version_window.close()\n+                self.create_local_project_file()\n+                self.local_ftml_file = fs.path.combine(self.data_dir,\n+                                                       fs.path.join('local_mscolab_data',\n+                                                                    self.user['username'], self.active_project_name,\n+                                                                    'mscolab_project.ftml'))\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Local File. Your changes are only available to you.\"\n+                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n+                self.save_ft.setEnabled(True)\n+                self.fetch_ft.setEnabled(True)\n+                self.versionHistoryBtn.setEnabled(False)\n+                self.reload_local_wp()\n \n+            else:\n+                self.local_ftml_file = None\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n+                            \"Turn on work locally to work on local flight track file\"))\n+                self.save_ft.setEnabled(False)\n+                self.fetch_ft.setEnabled(False)\n+                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n+                    self.versionHistoryBtn.setEnabled(True)\n+                self.waypoints_model = None\n+                self.load_wps_from_server()\n+            self.reload_view_windows()\n         else:\n-            self.local_ftml_file = None\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                        \"Turn on work locally to work on local flight track file\"))\n-            self.save_ft.setEnabled(False)\n-            self.fetch_ft.setEnabled(False)\n-            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n-                self.versionHistoryBtn.setEnabled(True)\n-            self.waypoints_model = None\n-            self.load_wps_from_server()\n-        self.reload_view_windows()\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n+\n+    def verify_user_token(self):\n+        data = {\n+            \"token\": self.token\n+        }\n+        try:\n+            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)\n+        except requests.exceptions.ConnectionError as ex:\n+            logging.error(\"unexpected error: %s %s\", type(ex), ex)\n+            return False\n+        return r.text == \"True\"\n \n     def authorize(self):\n         for key, value in config_loader(dataset=\"MSC_login\").items():\n","add":41,"remove":26,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.workLocallyCheckBox.isChecked():","            if self.version_window is not None:","                self.version_window.close()","            self.create_local_project_file()","            self.local_ftml_file = fs.path.combine(self.data_dir,","                                                   fs.path.join('local_mscolab_data',","                                                                self.user['username'], self.active_project_name,","                                                                'mscolab_project.ftml'))","            self.helperTextLabel.setText(","                self.tr(\"Working On: Local File. Your changes are only available to you.\"","                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))","            self.save_ft.setEnabled(True)","            self.fetch_ft.setEnabled(True)","            self.versionHistoryBtn.setEnabled(False)","            self.reload_local_wp()","            self.local_ftml_file = None","            self.helperTextLabel.setText(","                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                        \"Turn on work locally to work on local flight track file\"))","            self.save_ft.setEnabled(False)","            self.fetch_ft.setEnabled(False)","            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:","                self.versionHistoryBtn.setEnabled(True)","            self.waypoints_model = None","            self.load_wps_from_server()","        self.reload_view_windows()"],"goodparts":["        if self.verify_user_token():","            if self.workLocallyCheckBox.isChecked():","                if self.version_window is not None:","                    self.version_window.close()","                self.create_local_project_file()","                self.local_ftml_file = fs.path.combine(self.data_dir,","                                                       fs.path.join('local_mscolab_data',","                                                                    self.user['username'], self.active_project_name,","                                                                    'mscolab_project.ftml'))","                self.helperTextLabel.setText(","                    self.tr(\"Working On: Local File. Your changes are only available to you.\"","                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))","                self.save_ft.setEnabled(True)","                self.fetch_ft.setEnabled(True)","                self.versionHistoryBtn.setEnabled(False)","                self.reload_local_wp()","            else:","                self.local_ftml_file = None","                self.helperTextLabel.setText(","                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                            \"Turn on work locally to work on local flight track file\"))","                self.save_ft.setEnabled(False)","                self.fetch_ft.setEnabled(False)","                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:","                    self.versionHistoryBtn.setEnabled(True)","                self.waypoints_model = None","                self.load_wps_from_server()","            self.reload_view_windows()","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","    def verify_user_token(self):","        data = {","            \"token\": self.token","        }","        try:","            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)","        except requests.exceptions.ConnectionError as ex:","            logging.error(\"unexpected error: %s %s\", type(ex), ex)","            return False","        return r.text == \"True\""]},{"diff":"\n \n     def add_projects(self):\n         # add projects\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            self.projects = _json[\"projects\"]\n-            self.add_projects_to_ui(self.projects)\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                self.projects = _json[\"projects\"]\n+                self.add_projects_to_ui(self.projects)\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_pid(self):\n         \"\"\"\n         get most recent project's p_id\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            p_id = None\n-            if projects:\n-                p_id = projects[-1][\"p_id\"]\n-            return p_id\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                p_id = None\n+                if projects:\n+                    p_id = projects[-1][\"p_id\"]\n+                return p_id\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_project(self):\n         \"\"\"\n         get most recent project\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            recent_project = None\n-            if projects:\n-                recent_project = projects[-1]\n-            return recent_project\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                recent_project = None\n+                if projects:\n+                    recent_project = projects[-1]\n+                return recent_project\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def add_projects_to_ui(self, projects):\n         logging.debug(\"adding projects to ui\")\n","add":45,"remove":33,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            self.projects = _json[\"projects\"]","            self.add_projects_to_ui(self.projects)","            show_popup(self, \"Error\", \"Session expired, new login required\")","        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            projects = _json[\"projects\"]","            p_id = None","            if projects:","                p_id = projects[-1][\"p_id\"]","            return p_id","            show_popup(self, \"Error\", \"Session expired, new login required\")","        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            projects = _json[\"projects\"]","            recent_project = None","            if projects:","                recent_project = projects[-1]","            return recent_project","            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                self.projects = _json[\"projects\"]","                self.add_projects_to_ui(self.projects)","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                projects = _json[\"projects\"]","                p_id = None","                if projects:","                    p_id = projects[-1][\"p_id\"]","                return p_id","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                projects = _json[\"projects\"]","                recent_project = None","                if projects:","                    recent_project = projects[-1]","                return recent_project","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.active_windows = []\n \n     def set_active_pid(self, item):\n-        if item.p_id == self.active_pid:\n-            return\n-        # close all hanging window\n-        self.force_close_view_windows()\n-        self.close_external_windows()\n-        # Turn off work locally toggle\n-        self.workLocallyCheckBox.blockSignals(True)\n-        self.workLocallyCheckBox.setChecked(False)\n-        self.workLocallyCheckBox.blockSignals(False)\n-        self.save_ft.setEnabled(False)\n-        self.fetch_ft.setEnabled(False)\n-\n-        # set active_pid here\n-        self.active_pid = item.p_id\n-        self.access_level = item.access_level\n-        self.active_project_name = item.text().split(\"-\")[0].strip()\n-        self.waypoints_model = None\n-        # set active flightpath here\n-        self.load_wps_from_server()\n-        # enable project specific buttons\n-        self.helperTextLabel.setVisible(True)\n-        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                                             \"Turn on work locally to work on local flight track file\"))\n-        self.importBtn.setEnabled(True)\n-        self.exportBtn.setEnabled(True)\n-        self.topview.setEnabled(True)\n-        self.sideview.setEnabled(True)\n-        self.tableview.setEnabled(True)\n-        self.workLocallyCheckBox.setEnabled(True)\n-\n-        # enable access level specific buttons\n-        self.handle_mscolab_buttons()\n-\n-        # change font style for selected\n-        font = QtGui.QFont()\n-        for i in range(self.listProjects.count()):\n-            self.listProjects.item(i).setFont(font)\n-        font.setBold(True)\n-        item.setFont(font)\n+        if self.verify_user_token():\n+            if item.p_id == self.active_pid:\n+                return\n+            # close all hanging window\n+            self.force_close_view_windows()\n+            self.close_external_windows()\n+            # Turn off work locally toggle\n+            self.workLocallyCheckBox.blockSignals(True)\n+            self.workLocallyCheckBox.setChecked(False)\n+            self.workLocallyCheckBox.blockSignals(False)\n+            self.save_ft.setEnabled(False)\n+            self.fetch_ft.setEnabled(False)\n+            # set active_pid here\n+            self.active_pid = item.p_id\n+            self.access_level = item.access_level\n+            self.active_project_name = item.text().split(\"-\")[0].strip()\n+            self.waypoints_model = None\n+            # set active flightpath here\n+            self.load_wps_from_server()\n+            # enable project specific buttons\n+            self.helperTextLabel.setVisible(True)\n+            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"\n+                                                 \"All your changes will be shared with everyone.\"\n+                                                 \"Turn on work locally to work on local flight track file\"))\n+            self.importBtn.setEnabled(True)\n+            self.exportBtn.setEnabled(True)\n+            self.topview.setEnabled(True)\n+            self.sideview.setEnabled(True)\n+            self.tableview.setEnabled(True)\n+            self.workLocallyCheckBox.setEnabled(True)\n+            # enable access level specific buttons\n+            self.handle_mscolab_buttons()\n+            # change font style for selected\n+            font = QtGui.QFont()\n+            for i in range(self.listProjects.count()):\n+                self.listProjects.item(i).setFont(font)\n+            font.setBold(True)\n+            item.setFont(font)\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_wps_from_server(self):\n         if self.active_pid is None:\n","add":41,"remove":39,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if item.p_id == self.active_pid:","            return","        self.force_close_view_windows()","        self.close_external_windows()","        self.workLocallyCheckBox.blockSignals(True)","        self.workLocallyCheckBox.setChecked(False)","        self.workLocallyCheckBox.blockSignals(False)","        self.save_ft.setEnabled(False)","        self.fetch_ft.setEnabled(False)","        self.active_pid = item.p_id","        self.access_level = item.access_level","        self.active_project_name = item.text().split(\"-\")[0].strip()","        self.waypoints_model = None","        self.load_wps_from_server()","        self.helperTextLabel.setVisible(True)","        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                                             \"Turn on work locally to work on local flight track file\"))","        self.importBtn.setEnabled(True)","        self.exportBtn.setEnabled(True)","        self.topview.setEnabled(True)","        self.sideview.setEnabled(True)","        self.tableview.setEnabled(True)","        self.workLocallyCheckBox.setEnabled(True)","        self.handle_mscolab_buttons()","        font = QtGui.QFont()","        for i in range(self.listProjects.count()):","            self.listProjects.item(i).setFont(font)","        font.setBold(True)","        item.setFont(font)"],"goodparts":["        if self.verify_user_token():","            if item.p_id == self.active_pid:","                return","            self.force_close_view_windows()","            self.close_external_windows()","            self.workLocallyCheckBox.blockSignals(True)","            self.workLocallyCheckBox.setChecked(False)","            self.workLocallyCheckBox.blockSignals(False)","            self.save_ft.setEnabled(False)","            self.fetch_ft.setEnabled(False)","            self.active_pid = item.p_id","            self.access_level = item.access_level","            self.active_project_name = item.text().split(\"-\")[0].strip()","            self.waypoints_model = None","            self.load_wps_from_server()","            self.helperTextLabel.setVisible(True)","            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"","                                                 \"All your changes will be shared with everyone.\"","                                                 \"Turn on work locally to work on local flight track file\"))","            self.importBtn.setEnabled(True)","            self.exportBtn.setEnabled(True)","            self.topview.setEnabled(True)","            self.sideview.setEnabled(True)","            self.tableview.setEnabled(True)","            self.workLocallyCheckBox.setEnabled(True)","            self.handle_mscolab_buttons()","            font = QtGui.QFont()","            for i in range(self.listProjects.count()):","                self.listProjects.item(i).setFont(font)","            font.setBold(True)","            item.setFont(font)","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.reload_view_windows()\n \n     def request_wps_from_server(self):\n-        data = {\n-            \"token\": self.token,\n-            \"p_id\": self.active_pid\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n-        if r.text != \"False\":\n-            xml_content = json.loads(r.text)[\"content\"]\n-            return xml_content\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token,\n+                \"p_id\": self.active_pid\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n+            if r.text != \"False\":\n+                xml_content = json.loads(r.text)[\"content\"]\n+                return xml_content\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def load_wps_from_server(self):\n         if self.workLocallyCheckBox.isChecked():\n","add":13,"remove":9,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        data = {","            \"token\": self.token,","            \"p_id\": self.active_pid","        }","        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)","        if r.text != \"False\":","            xml_content = json.loads(r.text)[\"content\"]","            return xml_content","            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["        if self.verify_user_token():","            data = {","                \"token\": self.token,","                \"p_id\": self.active_pid","            }","            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)","            if r.text != \"False\":","                xml_content = json.loads(r.text)[\"content\"]","                return xml_content","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n \n     def open_topview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"topview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"topview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_sideview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"sideview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"sideview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_tableview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"tableview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"tableview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def create_view_window(self, _type):\n         for active_window in self.active_windows:\n","add":21,"remove":9,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.active_pid is None:","            return","        self.create_view_window(\"topview\")","        if self.active_pid is None:","            return","        self.create_view_window(\"sideview\")","        if self.active_pid is None:","            return","        self.create_view_window(\"tableview\")"],"goodparts":["        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"topview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"sideview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"tableview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.password.setEnabled(True)\n \n     def delete_account(self):\n-        w = QtWidgets.QWidget()\n-        qm = QtWidgets.QMessageBox\n-        reply = qm.question(w, self.tr('Continue?'),\n-                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n-                            qm.Yes, qm.No)\n-        if reply == QtWidgets.QMessageBox.No:\n-            return\n-        data = {\n-            \"token\": self.token\n-        }\n-        requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n-        self.clean_up_window()\n+        if self.verify_user_token():\n+            w = QtWidgets.QWidget()\n+            qm = QtWidgets.QMessageBox\n+            reply = qm.question(w, self.tr('Continue?'),\n+                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n+                                qm.Yes, qm.No)\n+            if reply == QtWidgets.QMessageBox.No:\n+                return\n+            data = {\n+                \"token\": self.token\n+            }\n+            requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n+            self.clean_up_window()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_external_windows(self):\n         if self.chat_window is not None:\n","add":16,"remove":12,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        w = QtWidgets.QWidget()","        qm = QtWidgets.QMessageBox","        reply = qm.question(w, self.tr('Continue?'),","                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),","                            qm.Yes, qm.No)","        if reply == QtWidgets.QMessageBox.No:","            return","        data = {","            \"token\": self.token","        }","        requests.post(self.mscolab_server_url + '\/delete_user', data=data)","        self.clean_up_window()"],"goodparts":["        if self.verify_user_token():","            w = QtWidgets.QWidget()","            qm = QtWidgets.QMessageBox","            reply = qm.question(w, self.tr('Continue?'),","                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),","                                qm.Yes, qm.No)","            if reply == QtWidgets.QMessageBox.No:","                return","            data = {","                \"token\": self.token","            }","            requests.post(self.mscolab_server_url + '\/delete_user', data=data)","            self.clean_up_window()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         save_settings_qsettings('mscolab', self.settings)\n \n     def save_wp_mscolab(self, comment=None):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_waypoints_changed(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+            else:\n+                xml_content = self.waypoints_model.get_xml_content()\n+                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n         else:\n-            xml_content = self.waypoints_model.get_xml_content()\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_view_windows(self):\n         for window in self.active_windows:\n","add":26,"remove":18,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        server_xml = self.request_wps_from_server()","        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)","        self.merge_dialog.saveBtn.setDisabled(True)","        if self.merge_dialog.exec_():","            xml_content = self.merge_dialog.get_values()","            if xml_content is not None:","                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)","                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                self.reload_view_windows()","                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)","        self.merge_dialog = None","        if self.workLocallyCheckBox.isChecked():","            self.waypoints_model.save_to_ftml(self.local_ftml_file)","            xml_content = self.waypoints_model.get_xml_content()","            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)"],"goodparts":["        if self.verify_user_token():","            server_xml = self.request_wps_from_server()","            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)","            self.merge_dialog.saveBtn.setDisabled(True)","            if self.merge_dialog.exec_():","                xml_content = self.merge_dialog.get_values()","                if xml_content is not None:","                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)","                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                    self.reload_view_windows()","                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)","            self.merge_dialog = None","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.workLocallyCheckBox.isChecked():","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","            else:","                xml_content = self.waypoints_model.get_xml_content()","                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.reload_view_windows()\n \n     def fetch_wp_mscolab(self):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int, int, str)\n     def handle_update_permission(self, p_id, u_id, access_level):\n","add":17,"remove":13,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        server_xml = self.request_wps_from_server()","        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)","        self.merge_dialog.saveBtn.setDisabled(True)","        if self.merge_dialog.exec_():","            xml_content = self.merge_dialog.get_values()","            if xml_content is not None:","                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                self.reload_view_windows()","                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)","        self.merge_dialog = None"],"goodparts":["        if self.verify_user_token():","            server_xml = self.request_wps_from_server()","            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)","            self.merge_dialog.saveBtn.setDisabled(True)","            if self.merge_dialog.exec_():","                xml_content = self.merge_dialog.get_values()","                if xml_content is not None:","                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                    self.reload_view_windows()","                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)","            self.merge_dialog = None","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             if self.chat_window is not None:\n                 self.chat_window.load_users()\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int)\n     def handle_project_deleted(self, p_id)","add":2,"remove":1,"filename":"\/mslib\/msui\/mscolab.py","badparts":["            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.loginButton.setEnabled(self.emailid.text() != \"\" and self.password.text() != \"\")\n \n     def handle_import(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n-        else:\n-            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]\n-            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        dir_path, file_name = fs.path.split(file_path)\n-        file_name = fs.path.basename(file_path)\n-        name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            with open_fs(dir_path) as file_dir:\n-                xml_content = file_dir.readtext(file_name)\n-            try:\n-                model = ft.WaypointsTableModel(xml_content=xml_content)\n-            except SyntaxError:\n-                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n-                return\n-            self.waypoints_model = model\n+        if self.verify_user_token():\n             if self.workLocallyCheckBox.isChecked():\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n             else:\n+                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"\n+                                                         for ext in self.import_plugins.keys()]\n+                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            dir_path, file_name = fs.path.split(file_path)\n+            file_name = fs.path.basename(file_path)\n+            name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                with open_fs(dir_path) as file_dir:\n+                    xml_content = file_dir.readtext(file_name)\n+                try:\n+                    model = ft.WaypointsTableModel(xml_content=xml_content)\n+                except SyntaxError:\n+                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n+                    return\n+                self.waypoints_model = model\n+                if self.workLocallyCheckBox.isChecked():\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                else:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            else:\n+                _function = self.import_plugins[file_ext[1:]]\n+                _, new_waypoints = _function(file_path)\n+                model = ft.WaypointsTableModel(waypoints=new_waypoints)\n+                self.waypoints_model = model\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n                 self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n                 self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            self.reload_view_windows()\n+            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n         else:\n-            _function = self.import_plugins[file_ext[1:]]\n-            _, new_waypoints = _function(file_path)\n-            model = ft.WaypointsTableModel(waypoints=new_waypoints)\n-            self.waypoints_model = model\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n-            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-        self.reload_view_windows()\n-        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_export(self):\n-        # Setting default filename path for filedialogue\n-        default_filename = self.active_project_name + \".ftml\"\n-        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n-        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        file_name = fs.path.basename(file_path)\n-        file_name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            dir_path, file_name = fs.path.split(file_path)\n-            with open_fs(dir_path).open(file_name, 'w') as file:\n-                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+        if self.verify_user_token():\n+            # Setting default filename path for filedialogue\n+            default_filename = self.active_project_name + \".ftml\"\n+            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n+            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            file_name = fs.path.basename(file_path)\n+            file_name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                dir_path, file_name = fs.path.split(file_path)\n+                with open_fs(dir_path).open(file_name, 'w') as file:\n+                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+            else:\n+                _function = self.export_plugins[file_ext[1:]]\n+                _function(file_path, file_name, self.waypoints_model.waypoints)\n+                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n         else:\n-            _function = self.export_plugins[file_ext[1:]]\n-            _function(file_path, file_name, self.waypoints_model.waypoints)\n-            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def disable_project_buttons(self):\n         self.save_ft.setEnabled(False)\n","add":56,"remove":47,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.workLocallyCheckBox.isChecked():","            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")","        else:","            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]","            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))","        if file_path is None:","            return","        dir_path, file_name = fs.path.split(file_path)","        file_name = fs.path.basename(file_path)","        name, file_ext = fs.path.splitext(file_name)","        if file_ext[1:] == \"ftml\":","            with open_fs(dir_path) as file_dir:","                xml_content = file_dir.readtext(file_name)","            try:","                model = ft.WaypointsTableModel(xml_content=xml_content)","            except SyntaxError:","                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")","                return","            self.waypoints_model = model","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","            _function = self.import_plugins[file_ext[1:]]","            _, new_waypoints = _function(file_path)","            model = ft.WaypointsTableModel(waypoints=new_waypoints)","            self.waypoints_model = model","            xml_doc = self.waypoints_model.get_xml_doc()","            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")","            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","        self.reload_view_windows()","        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)","        default_filename = self.active_project_name + \".ftml\"","        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]","        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))","        if file_path is None:","            return","        file_name = fs.path.basename(file_path)","        file_name, file_ext = fs.path.splitext(file_name)","        if file_ext[1:] == \"ftml\":","            xml_doc = self.waypoints_model.get_xml_doc()","            dir_path, file_name = fs.path.split(file_path)","            with open_fs(dir_path).open(file_name, 'w') as file:","                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")","            _function = self.export_plugins[file_ext[1:]]","            _function(file_path, file_name, self.waypoints_model.waypoints)","            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)"],"goodparts":["        if self.verify_user_token():","                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")","                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"","                                                         for ext in self.import_plugins.keys()]","                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))","            if file_path is None:","                return","            dir_path, file_name = fs.path.split(file_path)","            file_name = fs.path.basename(file_path)","            name, file_ext = fs.path.splitext(file_name)","            if file_ext[1:] == \"ftml\":","                with open_fs(dir_path) as file_dir:","                    xml_content = file_dir.readtext(file_name)","                try:","                    model = ft.WaypointsTableModel(xml_content=xml_content)","                except SyntaxError:","                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")","                    return","                self.waypoints_model = model","                if self.workLocallyCheckBox.isChecked():","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                else:","                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","            else:","                _function = self.import_plugins[file_ext[1:]]","                _, new_waypoints = _function(file_path)","                model = ft.WaypointsTableModel(waypoints=new_waypoints)","                self.waypoints_model = model","                xml_doc = self.waypoints_model.get_xml_doc()","                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")","            self.reload_view_windows()","            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            default_filename = self.active_project_name + \".ftml\"","            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]","            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))","            if file_path is None:","                return","            file_name = fs.path.basename(file_path)","            file_name, file_ext = fs.path.splitext(file_name)","            if file_ext[1:] == \"ftml\":","                xml_doc = self.waypoints_model.get_xml_doc()","                dir_path, file_name = fs.path.split(file_path)","                with open_fs(dir_path).open(file_name, 'w') as file:","                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")","            else:","                _function = self.export_plugins[file_ext[1:]]","                _function(file_path, file_name, self.waypoints_model.waypoints)","                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             return\n         else:\n             logging.debug(self.token)\n-        self.proj_diag = QtWidgets.QDialog()\n-        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n-        self.add_proj_dialog.setupUi(self.proj_diag)\n-        self.add_proj_dialog.f_content = None\n-        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n-        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n-        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n-        self.proj_diag.show()\n+        if self.verify_user_token():\n+            self.proj_diag = QtWidgets.QDialog()\n+            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n+            self.add_proj_dialog.setupUi(self.proj_diag)\n+            self.add_proj_dialog.f_content = None\n+            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n+            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n+            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n+            self.proj_diag.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def check_and_enable_project_accept(self):\n         if self.add_proj_dialog.path.text() != \"\" and self.add_proj_dialog.description.toPlainText() != \"\":\n","add":14,"remove":10,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        self.proj_diag = QtWidgets.QDialog()","        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()","        self.add_proj_dialog.setupUi(self.proj_diag)","        self.add_proj_dialog.f_content = None","        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)","        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)","        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)","        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)","        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)","        self.proj_diag.show()"],"goodparts":["        if self.verify_user_token():","            self.proj_diag = QtWidgets.QDialog()","            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()","            self.add_proj_dialog.setupUi(self.proj_diag)","            self.add_proj_dialog.f_content = None","            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)","            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)","            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)","            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)","            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)","            self.proj_diag.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             self.help_dialog.show()\n \n     def handle_delete_project(self):\n-        entered_project_name, ok = QtWidgets.QInputDialog.getText(\n-            self,\n-            self.tr('Delete Project'),\n-            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n-                    f\"Enter the project name to confirm: \"))\n-        if ok:\n-            if entered_project_name == self.active_project_name:\n-                data = {\n-                    \"token\": self.token,\n-                    \"p_id\": self.active_pid\n-                }\n-                url = url_join(self.mscolab_server_url, 'delete_project')\n-                try:\n-                    res = requests.post(url, data=data)\n-                    res.raise_for_status()\n-                except requests.exceptions.RequestException as e:\n-                    logging.debug(e)\n-                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n-            else:\n-                show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        if self.verify_user_token():\n+            entered_project_name, ok = QtWidgets.QInputDialog.getText(\n+                self,\n+                self.tr('Delete Project'),\n+                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n+                        f\"Enter the project name to confirm: \"))\n+            if ok:\n+                if entered_project_name == self.active_project_name:\n+                    data = {\n+                        \"token\": self.token,\n+                        \"p_id\": self.active_pid\n+                    }\n+                    url = url_join(self.mscolab_server_url, 'delete_project')\n+                    try:\n+                        res = requests.post(url, data=data)\n+                        res.raise_for_status()\n+                    except requests.exceptions.RequestException as e:\n+                        logging.debug(e)\n+                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n+                else:\n+                    show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_chat_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.chat_window is not None:\n-            self.chat_window.raise_()\n-            self.chat_window.activateWindow()\n-            return\n+            if self.chat_window is not None:\n+                self.chat_window.raise_()\n+                self.chat_window.activateWindow()\n+                return\n \n-        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n-                                                   self.access_level, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.chat_window.viewCloses.connect(self.close_chat_window)\n-        self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.chat_window.show()\n+            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n+                                                       self.access_level, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.chat_window.viewCloses.connect(self.close_chat_window)\n+            self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.chat_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_chat_window(self):\n         self.raise_()\n         self.chat_window = None\n \n     def open_admin_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.admin_window is not None:\n-            self.admin_window.raise_()\n-            self.admin_window.activateWindow()\n-            return\n+            if self.admin_window is not None:\n+                self.admin_window.raise_()\n+                self.admin_window.activateWindow()\n+                return\n \n-        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n-                                                   self.active_project_name, self.projects, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.admin_window.viewCloses.connect(self.close_admin_window)\n-        self.admin_window.show()\n+            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n+                                                       self.active_project_name, self.projects, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.admin_window.viewCloses.connect(self.close_admin_window)\n+            self.admin_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_admin_window(self):\n         self.raise_()\n         self.admin_window = None\n \n     def open_version_history_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.version_window is not None:\n-            self.version_window.raise_()\n-            self.version_window.activateWindow()\n-            return\n+            if self.version_window is not None:\n+                self.version_window.raise_()\n+                self.version_window.activateWindow()\n+                return\n \n-        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n-                                                        self.active_project_name, self.conn,\n-                                                        mscolab_server_url=self.mscolab_server_url)\n-        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.version_window.viewCloses.connect(self.close_version_history_window)\n-        self.version_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.version_window.show()\n+            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n+                                                            self.active_project_name, self.conn,\n+                                                            mscolab_server_url=self.mscolab_server_url)\n+            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.version_window.viewCloses.connect(self.close_version_history_window)\n+            self.version_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.version_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_version_history_window(self):\n         self.raise_()\n","add":74,"remove":58,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        entered_project_name, ok = QtWidgets.QInputDialog.getText(","            self,","            self.tr('Delete Project'),","            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"","                    f\"Enter the project name to confirm: \"))","        if ok:","            if entered_project_name == self.active_project_name:","                data = {","                    \"token\": self.token,","                    \"p_id\": self.active_pid","                }","                url = url_join(self.mscolab_server_url, 'delete_project')","                try:","                    res = requests.post(url, data=data)","                    res.raise_for_status()","                except requests.exceptions.RequestException as e:","                    logging.debug(e)","                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")","            else:","                show_popup(self, \"Error\", \"Entered project name did not match!\")","        if self.active_pid is None:","            return","        if self.chat_window is not None:","            self.chat_window.raise_()","            self.chat_window.activateWindow()","            return","        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,","                                                   self.access_level, self.conn,","                                                   mscolab_server_url=self.mscolab_server_url)","        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.chat_window.viewCloses.connect(self.close_chat_window)","        self.chat_window.reloadWindows.connect(self.reload_windows_slot)","        self.chat_window.show()","        if self.active_pid is None:","            return","        if self.admin_window is not None:","            self.admin_window.raise_()","            self.admin_window.activateWindow()","            return","        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,","                                                   self.active_project_name, self.projects, self.conn,","                                                   mscolab_server_url=self.mscolab_server_url)","        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.admin_window.viewCloses.connect(self.close_admin_window)","        self.admin_window.show()","        if self.active_pid is None:","            return","        if self.version_window is not None:","            self.version_window.raise_()","            self.version_window.activateWindow()","            return","        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,","                                                        self.active_project_name, self.conn,","                                                        mscolab_server_url=self.mscolab_server_url)","        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.version_window.viewCloses.connect(self.close_version_history_window)","        self.version_window.reloadWindows.connect(self.reload_windows_slot)","        self.version_window.show()"],"goodparts":["        if self.verify_user_token():","            entered_project_name, ok = QtWidgets.QInputDialog.getText(","                self,","                self.tr('Delete Project'),","                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"","                        f\"Enter the project name to confirm: \"))","            if ok:","                if entered_project_name == self.active_project_name:","                    data = {","                        \"token\": self.token,","                        \"p_id\": self.active_pid","                    }","                    url = url_join(self.mscolab_server_url, 'delete_project')","                    try:","                        res = requests.post(url, data=data)","                        res.raise_for_status()","                    except requests.exceptions.RequestException as e:","                        logging.debug(e)","                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")","                else:","                    show_popup(self, \"Error\", \"Entered project name did not match!\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.chat_window is not None:","                self.chat_window.raise_()","                self.chat_window.activateWindow()","                return","            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,","                                                       self.access_level, self.conn,","                                                       mscolab_server_url=self.mscolab_server_url)","            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.chat_window.viewCloses.connect(self.close_chat_window)","            self.chat_window.reloadWindows.connect(self.reload_windows_slot)","            self.chat_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.admin_window is not None:","                self.admin_window.raise_()","                self.admin_window.activateWindow()","                return","            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,","                                                       self.active_project_name, self.projects, self.conn,","                                                       mscolab_server_url=self.mscolab_server_url)","            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.admin_window.viewCloses.connect(self.close_admin_window)","            self.admin_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.version_window is not None:","                self.version_window.raise_()","                self.version_window.activateWindow()","                return","            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,","                                                            self.active_project_name, self.conn,","                                                            mscolab_server_url=self.mscolab_server_url)","            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.version_window.viewCloses.connect(self.close_version_history_window)","            self.version_window.reloadWindows.connect(self.reload_windows_slot)","            self.version_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             mss_dir.writetext(rel_file_path, server_data)\n \n     def handle_work_locally_toggle(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            if self.version_window is not None:\n-                self.version_window.close()\n-            self.create_local_project_file()\n-            self.local_ftml_file = fs.path.combine(self.data_dir,\n-                                                   fs.path.join('local_mscolab_data',\n-                                                                self.user['username'], self.active_project_name,\n-                                                                'mscolab_project.ftml'))\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Local File. Your changes are only available to you.\"\n-                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n-            self.save_ft.setEnabled(True)\n-            self.fetch_ft.setEnabled(True)\n-            self.versionHistoryBtn.setEnabled(False)\n-            self.reload_local_wp()\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                if self.version_window is not None:\n+                    self.version_window.close()\n+                self.create_local_project_file()\n+                self.local_ftml_file = fs.path.combine(self.data_dir,\n+                                                       fs.path.join('local_mscolab_data',\n+                                                                    self.user['username'], self.active_project_name,\n+                                                                    'mscolab_project.ftml'))\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Local File. Your changes are only available to you.\"\n+                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n+                self.save_ft.setEnabled(True)\n+                self.fetch_ft.setEnabled(True)\n+                self.versionHistoryBtn.setEnabled(False)\n+                self.reload_local_wp()\n \n+            else:\n+                self.local_ftml_file = None\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n+                            \"Turn on work locally to work on local flight track file\"))\n+                self.save_ft.setEnabled(False)\n+                self.fetch_ft.setEnabled(False)\n+                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n+                    self.versionHistoryBtn.setEnabled(True)\n+                self.waypoints_model = None\n+                self.load_wps_from_server()\n+            self.reload_view_windows()\n         else:\n-            self.local_ftml_file = None\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                        \"Turn on work locally to work on local flight track file\"))\n-            self.save_ft.setEnabled(False)\n-            self.fetch_ft.setEnabled(False)\n-            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n-                self.versionHistoryBtn.setEnabled(True)\n-            self.waypoints_model = None\n-            self.load_wps_from_server()\n-        self.reload_view_windows()\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n+\n+    def verify_user_token(self):\n+        data = {\n+            \"token\": self.token\n+        }\n+        try:\n+            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)\n+        except requests.exceptions.ConnectionError as ex:\n+            logging.error(\"unexpected error: %s %s\", type(ex), ex)\n+            return False\n+        return r.text == \"True\"\n \n     def authorize(self):\n         for key, value in config_loader(dataset=\"MSC_login\").items():\n","add":41,"remove":26,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.workLocallyCheckBox.isChecked():","            if self.version_window is not None:","                self.version_window.close()","            self.create_local_project_file()","            self.local_ftml_file = fs.path.combine(self.data_dir,","                                                   fs.path.join('local_mscolab_data',","                                                                self.user['username'], self.active_project_name,","                                                                'mscolab_project.ftml'))","            self.helperTextLabel.setText(","                self.tr(\"Working On: Local File. Your changes are only available to you.\"","                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))","            self.save_ft.setEnabled(True)","            self.fetch_ft.setEnabled(True)","            self.versionHistoryBtn.setEnabled(False)","            self.reload_local_wp()","            self.local_ftml_file = None","            self.helperTextLabel.setText(","                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                        \"Turn on work locally to work on local flight track file\"))","            self.save_ft.setEnabled(False)","            self.fetch_ft.setEnabled(False)","            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:","                self.versionHistoryBtn.setEnabled(True)","            self.waypoints_model = None","            self.load_wps_from_server()","        self.reload_view_windows()"],"goodparts":["        if self.verify_user_token():","            if self.workLocallyCheckBox.isChecked():","                if self.version_window is not None:","                    self.version_window.close()","                self.create_local_project_file()","                self.local_ftml_file = fs.path.combine(self.data_dir,","                                                       fs.path.join('local_mscolab_data',","                                                                    self.user['username'], self.active_project_name,","                                                                    'mscolab_project.ftml'))","                self.helperTextLabel.setText(","                    self.tr(\"Working On: Local File. Your changes are only available to you.\"","                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))","                self.save_ft.setEnabled(True)","                self.fetch_ft.setEnabled(True)","                self.versionHistoryBtn.setEnabled(False)","                self.reload_local_wp()","            else:","                self.local_ftml_file = None","                self.helperTextLabel.setText(","                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                            \"Turn on work locally to work on local flight track file\"))","                self.save_ft.setEnabled(False)","                self.fetch_ft.setEnabled(False)","                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:","                    self.versionHistoryBtn.setEnabled(True)","                self.waypoints_model = None","                self.load_wps_from_server()","            self.reload_view_windows()","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","    def verify_user_token(self):","        data = {","            \"token\": self.token","        }","        try:","            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)","        except requests.exceptions.ConnectionError as ex:","            logging.error(\"unexpected error: %s %s\", type(ex), ex)","            return False","        return r.text == \"True\""]},{"diff":"\n \n     def add_projects(self):\n         # add projects\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            self.projects = _json[\"projects\"]\n-            self.add_projects_to_ui(self.projects)\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                self.projects = _json[\"projects\"]\n+                self.add_projects_to_ui(self.projects)\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_pid(self):\n         \"\"\"\n         get most recent project's p_id\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            p_id = None\n-            if projects:\n-                p_id = projects[-1][\"p_id\"]\n-            return p_id\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                p_id = None\n+                if projects:\n+                    p_id = projects[-1][\"p_id\"]\n+                return p_id\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_project(self):\n         \"\"\"\n         get most recent project\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            recent_project = None\n-            if projects:\n-                recent_project = projects[-1]\n-            return recent_project\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                recent_project = None\n+                if projects:\n+                    recent_project = projects[-1]\n+                return recent_project\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def add_projects_to_ui(self, projects):\n         logging.debug(\"adding projects to ui\")\n","add":45,"remove":33,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            self.projects = _json[\"projects\"]","            self.add_projects_to_ui(self.projects)","            show_popup(self, \"Error\", \"Session expired, new login required\")","        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            projects = _json[\"projects\"]","            p_id = None","            if projects:","                p_id = projects[-1][\"p_id\"]","            return p_id","            show_popup(self, \"Error\", \"Session expired, new login required\")","        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            projects = _json[\"projects\"]","            recent_project = None","            if projects:","                recent_project = projects[-1]","            return recent_project","            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                self.projects = _json[\"projects\"]","                self.add_projects_to_ui(self.projects)","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                projects = _json[\"projects\"]","                p_id = None","                if projects:","                    p_id = projects[-1][\"p_id\"]","                return p_id","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                projects = _json[\"projects\"]","                recent_project = None","                if projects:","                    recent_project = projects[-1]","                return recent_project","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.active_windows = []\n \n     def set_active_pid(self, item):\n-        if item.p_id == self.active_pid:\n-            return\n-        # close all hanging window\n-        self.force_close_view_windows()\n-        self.close_external_windows()\n-        # Turn off work locally toggle\n-        self.workLocallyCheckBox.blockSignals(True)\n-        self.workLocallyCheckBox.setChecked(False)\n-        self.workLocallyCheckBox.blockSignals(False)\n-        self.save_ft.setEnabled(False)\n-        self.fetch_ft.setEnabled(False)\n-\n-        # set active_pid here\n-        self.active_pid = item.p_id\n-        self.access_level = item.access_level\n-        self.active_project_name = item.text().split(\"-\")[0].strip()\n-        self.waypoints_model = None\n-        # set active flightpath here\n-        self.load_wps_from_server()\n-        # enable project specific buttons\n-        self.helperTextLabel.setVisible(True)\n-        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                                             \"Turn on work locally to work on local flight track file\"))\n-        self.importBtn.setEnabled(True)\n-        self.exportBtn.setEnabled(True)\n-        self.topview.setEnabled(True)\n-        self.sideview.setEnabled(True)\n-        self.tableview.setEnabled(True)\n-        self.workLocallyCheckBox.setEnabled(True)\n-\n-        # enable access level specific buttons\n-        self.handle_mscolab_buttons()\n-\n-        # change font style for selected\n-        font = QtGui.QFont()\n-        for i in range(self.listProjects.count()):\n-            self.listProjects.item(i).setFont(font)\n-        font.setBold(True)\n-        item.setFont(font)\n+        if self.verify_user_token():\n+            if item.p_id == self.active_pid:\n+                return\n+            # close all hanging window\n+            self.force_close_view_windows()\n+            self.close_external_windows()\n+            # Turn off work locally toggle\n+            self.workLocallyCheckBox.blockSignals(True)\n+            self.workLocallyCheckBox.setChecked(False)\n+            self.workLocallyCheckBox.blockSignals(False)\n+            self.save_ft.setEnabled(False)\n+            self.fetch_ft.setEnabled(False)\n+            # set active_pid here\n+            self.active_pid = item.p_id\n+            self.access_level = item.access_level\n+            self.active_project_name = item.text().split(\"-\")[0].strip()\n+            self.waypoints_model = None\n+            # set active flightpath here\n+            self.load_wps_from_server()\n+            # enable project specific buttons\n+            self.helperTextLabel.setVisible(True)\n+            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"\n+                                                 \"All your changes will be shared with everyone.\"\n+                                                 \"Turn on work locally to work on local flight track file\"))\n+            self.importBtn.setEnabled(True)\n+            self.exportBtn.setEnabled(True)\n+            self.topview.setEnabled(True)\n+            self.sideview.setEnabled(True)\n+            self.tableview.setEnabled(True)\n+            self.workLocallyCheckBox.setEnabled(True)\n+            # enable access level specific buttons\n+            self.handle_mscolab_buttons()\n+            # change font style for selected\n+            font = QtGui.QFont()\n+            for i in range(self.listProjects.count()):\n+                self.listProjects.item(i).setFont(font)\n+            font.setBold(True)\n+            item.setFont(font)\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_wps_from_server(self):\n         if self.active_pid is None:\n","add":41,"remove":39,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if item.p_id == self.active_pid:","            return","        self.force_close_view_windows()","        self.close_external_windows()","        self.workLocallyCheckBox.blockSignals(True)","        self.workLocallyCheckBox.setChecked(False)","        self.workLocallyCheckBox.blockSignals(False)","        self.save_ft.setEnabled(False)","        self.fetch_ft.setEnabled(False)","        self.active_pid = item.p_id","        self.access_level = item.access_level","        self.active_project_name = item.text().split(\"-\")[0].strip()","        self.waypoints_model = None","        self.load_wps_from_server()","        self.helperTextLabel.setVisible(True)","        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                                             \"Turn on work locally to work on local flight track file\"))","        self.importBtn.setEnabled(True)","        self.exportBtn.setEnabled(True)","        self.topview.setEnabled(True)","        self.sideview.setEnabled(True)","        self.tableview.setEnabled(True)","        self.workLocallyCheckBox.setEnabled(True)","        self.handle_mscolab_buttons()","        font = QtGui.QFont()","        for i in range(self.listProjects.count()):","            self.listProjects.item(i).setFont(font)","        font.setBold(True)","        item.setFont(font)"],"goodparts":["        if self.verify_user_token():","            if item.p_id == self.active_pid:","                return","            self.force_close_view_windows()","            self.close_external_windows()","            self.workLocallyCheckBox.blockSignals(True)","            self.workLocallyCheckBox.setChecked(False)","            self.workLocallyCheckBox.blockSignals(False)","            self.save_ft.setEnabled(False)","            self.fetch_ft.setEnabled(False)","            self.active_pid = item.p_id","            self.access_level = item.access_level","            self.active_project_name = item.text().split(\"-\")[0].strip()","            self.waypoints_model = None","            self.load_wps_from_server()","            self.helperTextLabel.setVisible(True)","            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"","                                                 \"All your changes will be shared with everyone.\"","                                                 \"Turn on work locally to work on local flight track file\"))","            self.importBtn.setEnabled(True)","            self.exportBtn.setEnabled(True)","            self.topview.setEnabled(True)","            self.sideview.setEnabled(True)","            self.tableview.setEnabled(True)","            self.workLocallyCheckBox.setEnabled(True)","            self.handle_mscolab_buttons()","            font = QtGui.QFont()","            for i in range(self.listProjects.count()):","                self.listProjects.item(i).setFont(font)","            font.setBold(True)","            item.setFont(font)","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.reload_view_windows()\n \n     def request_wps_from_server(self):\n-        data = {\n-            \"token\": self.token,\n-            \"p_id\": self.active_pid\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n-        if r.text != \"False\":\n-            xml_content = json.loads(r.text)[\"content\"]\n-            return xml_content\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token,\n+                \"p_id\": self.active_pid\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n+            if r.text != \"False\":\n+                xml_content = json.loads(r.text)[\"content\"]\n+                return xml_content\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def load_wps_from_server(self):\n         if self.workLocallyCheckBox.isChecked():\n","add":13,"remove":9,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        data = {","            \"token\": self.token,","            \"p_id\": self.active_pid","        }","        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)","        if r.text != \"False\":","            xml_content = json.loads(r.text)[\"content\"]","            return xml_content","            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["        if self.verify_user_token():","            data = {","                \"token\": self.token,","                \"p_id\": self.active_pid","            }","            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)","            if r.text != \"False\":","                xml_content = json.loads(r.text)[\"content\"]","                return xml_content","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n \n     def open_topview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"topview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"topview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_sideview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"sideview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"sideview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_tableview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"tableview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"tableview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def create_view_window(self, _type):\n         for active_window in self.active_windows:\n","add":21,"remove":9,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.active_pid is None:","            return","        self.create_view_window(\"topview\")","        if self.active_pid is None:","            return","        self.create_view_window(\"sideview\")","        if self.active_pid is None:","            return","        self.create_view_window(\"tableview\")"],"goodparts":["        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"topview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"sideview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"tableview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.password.setEnabled(True)\n \n     def delete_account(self):\n-        w = QtWidgets.QWidget()\n-        qm = QtWidgets.QMessageBox\n-        reply = qm.question(w, self.tr('Continue?'),\n-                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n-                            qm.Yes, qm.No)\n-        if reply == QtWidgets.QMessageBox.No:\n-            return\n-        data = {\n-            \"token\": self.token\n-        }\n-        requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n-        self.clean_up_window()\n+        if self.verify_user_token():\n+            w = QtWidgets.QWidget()\n+            qm = QtWidgets.QMessageBox\n+            reply = qm.question(w, self.tr('Continue?'),\n+                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n+                                qm.Yes, qm.No)\n+            if reply == QtWidgets.QMessageBox.No:\n+                return\n+            data = {\n+                \"token\": self.token\n+            }\n+            requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n+            self.clean_up_window()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_external_windows(self):\n         if self.chat_window is not None:\n","add":16,"remove":12,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        w = QtWidgets.QWidget()","        qm = QtWidgets.QMessageBox","        reply = qm.question(w, self.tr('Continue?'),","                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),","                            qm.Yes, qm.No)","        if reply == QtWidgets.QMessageBox.No:","            return","        data = {","            \"token\": self.token","        }","        requests.post(self.mscolab_server_url + '\/delete_user', data=data)","        self.clean_up_window()"],"goodparts":["        if self.verify_user_token():","            w = QtWidgets.QWidget()","            qm = QtWidgets.QMessageBox","            reply = qm.question(w, self.tr('Continue?'),","                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),","                                qm.Yes, qm.No)","            if reply == QtWidgets.QMessageBox.No:","                return","            data = {","                \"token\": self.token","            }","            requests.post(self.mscolab_server_url + '\/delete_user', data=data)","            self.clean_up_window()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         save_settings_qsettings('mscolab', self.settings)\n \n     def save_wp_mscolab(self, comment=None):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_waypoints_changed(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+            else:\n+                xml_content = self.waypoints_model.get_xml_content()\n+                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n         else:\n-            xml_content = self.waypoints_model.get_xml_content()\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_view_windows(self):\n         for window in self.active_windows:\n","add":26,"remove":18,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        server_xml = self.request_wps_from_server()","        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)","        self.merge_dialog.saveBtn.setDisabled(True)","        if self.merge_dialog.exec_():","            xml_content = self.merge_dialog.get_values()","            if xml_content is not None:","                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)","                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                self.reload_view_windows()","                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)","        self.merge_dialog = None","        if self.workLocallyCheckBox.isChecked():","            self.waypoints_model.save_to_ftml(self.local_ftml_file)","            xml_content = self.waypoints_model.get_xml_content()","            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)"],"goodparts":["        if self.verify_user_token():","            server_xml = self.request_wps_from_server()","            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)","            self.merge_dialog.saveBtn.setDisabled(True)","            if self.merge_dialog.exec_():","                xml_content = self.merge_dialog.get_values()","                if xml_content is not None:","                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)","                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                    self.reload_view_windows()","                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)","            self.merge_dialog = None","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.workLocallyCheckBox.isChecked():","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","            else:","                xml_content = self.waypoints_model.get_xml_content()","                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.reload_view_windows()\n \n     def fetch_wp_mscolab(self):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int, int, str)\n     def handle_update_permission(self, p_id, u_id, access_level):\n","add":17,"remove":13,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        server_xml = self.request_wps_from_server()","        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)","        self.merge_dialog.saveBtn.setDisabled(True)","        if self.merge_dialog.exec_():","            xml_content = self.merge_dialog.get_values()","            if xml_content is not None:","                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                self.reload_view_windows()","                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)","        self.merge_dialog = None"],"goodparts":["        if self.verify_user_token():","            server_xml = self.request_wps_from_server()","            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)","            self.merge_dialog.saveBtn.setDisabled(True)","            if self.merge_dialog.exec_():","                xml_content = self.merge_dialog.get_values()","                if xml_content is not None:","                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                    self.reload_view_windows()","                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)","            self.merge_dialog = None","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             if self.chat_window is not None:\n                 self.chat_window.load_users()\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int)\n     def handle_project_deleted(self, p_id)","add":2,"remove":1,"filename":"\/mslib\/msui\/mscolab.py","badparts":["            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]}]}},"msg":"Verify valid token, fixes #975 (#987)\n\n* fixed error message (#962)\r\n\r\n* improved install\/update of MSS (#966)\r\n\r\n* improved install\/update of MSS\r\n\r\n* updated env order and added an important hint\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* preparation v3.0.4 (#967)\r\n\r\n* Changed vertical section interpolation to treat masked values as NaN (#983)\r\n\r\nArray is properly masked, but interpolation routine ignored mask.\r\nFilling the array with NaN should solve this issue.\r\nResulting array is properly masked again.\r\n\r\nFix #811\r\n\r\n* Import\/Export Extensions, fixes #918 (#981)\r\n\r\n* export plugins added\r\n\r\n* import plugins added\r\n\r\n* removed a doubled import\r\n\r\n* popup message when all is done\r\n\r\n* first change model than reload views\r\n\r\n* waypoints_model.dataChanged added\r\n\r\n* saved after import\r\n\r\n* reorganized, removed double commits\r\n\r\n* import saves xml content, worklocally with ftml files\r\n\r\n* Added option to display a secondary axis in SideView. (#980)\r\n\r\nFix #571\r\n\r\nCo-authored-by: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* enables to configure a EXPIRATION time in seconds, fixes #948 (#974)\r\n\r\n* enables to configure a EXPIRATION time in seconds\r\n\r\nwe catch now various problems for an expired session,\r\nbesides on a timelimit a session also expires on server restart.\r\n\r\n* popup message for new login requires added\r\n\r\n* flake8 fix\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* verbose output on chat who made changes\r\n\r\n* fixed typo\r\n\r\n* ToDo added\r\n\r\n* verifies expired user token and forces login\r\n\r\n* fixation of qt (#988)\r\n\r\n* added sorting for project list (#990)\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* Mscolab: collaborator can access version history (#925)\r\n\r\n* Mscolab: collaborator can access version history\r\n\r\n* updated mscolab.py\r\n\r\n* mscolab docs updated\r\n\r\n* mscolab.py updated\r\n\r\nCo-Authored-By: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* added \"collaborator\" in file_manager\r\n\r\n* fixed: flake8\r\n\r\n* file_manager.py updated\r\n\r\n* updated file_manager.py\r\n\r\n* refactored mscolab permissions\r\n\r\n* update\r\n\r\n* refactored permissions in  \"set_active_pid\"\r\n\r\nCo-Authored-By: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* closed windows after permission updated\r\n\r\n* merged: permission based closing of mscolab windows and disabling buttons to single function\r\n\r\nIt will increase maintainability\r\n\r\nCo-Authored-By: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\n* called `handle_mscolab_buttons` inside other functions\r\n\r\nCo-Authored-By: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\nCo-authored-by: ReimarBauer <rb.proj@gmail.com>\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\nCo-authored-by: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\n* flake8 fix\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\nCo-authored-by: Aravind Murali <aravindmurali711@gmail.com>\r\nCo-authored-by: Jatin Jain <72596619+Jatin2020-24@users.noreply.github.com>\r\nCo-authored-by: J. Ungermann <28449201+joernu76@users.noreply.github.com>"}},"https:\/\/github.com\/iverissimo\/Crowding_VS_features":{"1230ac8273e080ab0e158386231f852853a5edcf":{"url":"https:\/\/api.github.com\/repos\/iverissimo\/Crowding_VS_features\/commits\/1230ac8273e080ab0e158386231f852853a5edcf","html_url":"https:\/\/github.com\/iverissimo\/Crowding_VS_features\/commit\/1230ac8273e080ab0e158386231f852853a5edcf","message":"added training session for crowding, need to give feedback on fixation cross and check for fixations","sha":"1230ac8273e080ab0e158386231f852853a5edcf","keyword":"session fixation check","diff":"diff --git a\/experiment\/main.py b\/experiment\/main.py\nindex 519bce9..c2e2111 100644\n--- a\/experiment\/main.py\n+++ b\/experiment\/main.py\n@@ -3,7 +3,7 @@\n import os\n import os.path as op\n #import appnope\n-from session import VsearchSession, CrowdingSession \n+from session import VsearchSession, CrowdingSession, TrainCrowdingSession \n \n \n # define main function\n@@ -21,18 +21,18 @@ def main():\n                         'as 2nd argument in the command line!')\n     \n     sj_num = str(sys.argv[1]).zfill(3) # subject number\n-    ses_num = str(sys.argv[2]) # run number\n+    ses_type = str(sys.argv[2]) # run number\n \n     # task name dictionary\n     tasks = {'search': 'VisualSearch', 'crowding': 'Crowding'}\n     \n-    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))\n+    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))\n \n     exp_type = ''\n     while exp_type not in ('search','crowding'):\n         exp_type = input('Which experiment to run (search\/crowding)?: ')\n \n-    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))\n+    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))\n \n     # make output dir\n     base_dir = op.split(os.getcwd())[0] # main path for all folders of project\n@@ -44,7 +44,7 @@ def main():\n     print('saving files in %s'%output_dir)\n \n     # string for output data\n-    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])\n+    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])\n \n     # if file already exists\n     behav_file = op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str))\n@@ -60,18 +60,28 @@ def main():\n \n \n     # load approriate class object to be run\n-    if exp_type == 'search': # run standard pRF mapper\n+    #\n+    if exp_type == 'search': # run visual search task\n \n         exp_sess = VsearchSession(output_str = output_str,\n                               output_dir = output_dir,\n                               settings_file = 'experiment_settings.yml',\n                               eyetracker_on = False) #True)\n \n-    elif exp_type == 'crowding': # run feature pRF mapper\n-         exp_sess = CrowdingSession(output_str = output_str,\n+    elif exp_type == 'crowding': # run crowding task\n+        \n+        if ses_type in ['practice', 'train']: # short practice ses, to understand task\n+\n+            exp_sess = TrainCrowdingSession(output_str = output_str,\n                                   output_dir = output_dir,\n                                   settings_file = 'experiment_settings.yml',\n                                   eyetracker_on = False) #True)\n+        \n+        else: # real deal\n+            exp_sess = CrowdingSession(output_str = output_str,\n+                                    output_dir = output_dir,\n+                                    settings_file = 'experiment_settings.yml',\n+                                    eyetracker_on = False) #True)\n \n    \t                            \n     exp_sess.run()\ndiff --git a\/experiment\/session.py b\/experiment\/session.py\nindex ab8513a..f0d7ada 100644\n--- a\/experiment\/session.py\n+++ b\/experiment\/session.py\n@@ -4,7 +4,7 @@\n \n from exptools2.core import Session, PylinkEyetrackerSession\n \n-from trial import VsearchTrial, CrowdingTrial \n+from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial\n from stim import VsearchStim, CrowdingStim \n \n from psychopy import visual, tools\n@@ -547,7 +547,7 @@ def create_trials(self):\n                                 self.settings['crowding']['iti']\n                                 ])\n \n-                if blk_counter < self.settings['crowding']['num_blks']: \n+                if blk_counter < self.settings['crowding']['num_blks'] - 1: \n                     blk_counter += 1\n \n             else:\n@@ -633,6 +633,292 @@ def close_all(self):\n \n \n \n+    def run(self):\n+        \"\"\" Loops over trials and runs them \"\"\"\n+\n+        # create trials before running!\n+        self.create_stimuli()\n+        self.create_trials()\n+\n+        # create staircase\n+        self.create_staircase(stair_names = self.settings['crowding']['crwd_type'],\n+                            initial_val = self.distance_ratio_bounds[-1], \n+                            minVal = self.distance_ratio_bounds[0], \n+                            maxVal = self.distance_ratio_bounds[-1],\n+                            pThreshold = self.settings['crowding']['staircase']['pThreshold'],\n+                            nUp = self.settings['crowding']['staircase']['nUp'], \n+                            nDown = self.settings['crowding']['staircase']['nDown'], \n+                            stepSize = self.settings['crowding']['staircase']['stepSize'], \n+                            quest_stair = self.settings['crowding']['staircase']['quest']) \n+\n+        # if eyetracking then calibrate\n+        if self.eyetracker_on:\n+            self.calibrate_eyetracker()\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('During the experiment you will see several gabors.\\n\\n'\n+                                'They can be pink or blue,\\n'\n+                                'and be tilted to the right or left'\n+                                '\\n\\n\\n'\n+                                '[Press right arrow key\\nto continue]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = self.settings['keys']['right_index'])\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('Your task is to indicate\\n'\n+                                'the color and orientation\\n'\n+                                'of the middle gabor.'\n+                                '\\n\\n\\n'\n+                                '[Press right arrow key\\nto continue]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = self.settings['keys']['right_index'])\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('Sometimes, there will only be one shape presented\\n'\n+                                ' so do not let this confuse you.\\n'\n+                                '\\n\\n\\n'\n+                                '[Press right arrow key\\nto continue]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = self.settings['keys']['right_index'])\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('Do NOT look at the shapes!\\n'\n+                                    'Please fixate at the center,\\n'\n+                                    'and do not move your eyes\\n'\n+                                    '\\n\\n\\n'\n+                                    '[Press right arrow key\\nto continue]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = self.settings['keys']['right_index'])\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('\\n\\n\\n\\n'\n+                                '\\n\\n\\n\\nReady?\\n'\n+                                '[Press space bar\\nto start]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = ['space'], \n+                                image_path = [op.join(os.getcwd(),'instructions_imgs','crowding_keys.png')])\n+            \n+\n+        # start recording gaze\n+        if self.eyetracker_on:\n+            self.start_recording_eyetracker()\n+\n+        self.start_experiment()\n+        \n+        # cycle through trials\n+        for trl in self.all_trials: \n+            trl.run() # run forrest run\n+\n+        print('Expected number of responses: %d'%(self.total_trials))\n+        print('Total subject responses: %d'%self.total_responses)\n+        print('Correct responses: %d'%self.correct_responses)\n+        print('Overall accuracy %.2f %%'%(self.correct_responses\/self.total_trials*100))\n+\n+        self.close_all() # close session\n+\n+\n+class TrainCrowdingSession(CrowdingSession):\n+   \n+    def __init__(self, output_str, output_dir, settings_file, eyetracker_on):  # initialize child class\n+\n+        \"\"\" Initializes TrainCrowdingSession object.  \n+      \n+        Parameters\n+        ----------\n+        output_str : str\n+            Basename for all output-files (like logs), e.g., \"sub-01_task-PRFstandard_run-1\"\n+        output_dir : str\n+            Path to desired output-directory (default: None, which results in $pwd\/logs)\n+        settings_file : str\n+            Path to yaml-file with settings (default: None, which results in the package's\n+            default settings file (in data\/default_settings.yml)\n+        \"\"\"\n+\n+        # need to initialize parent class (ExpSession), indicating output infos\n+        super().__init__(output_str = output_str, output_dir = output_dir, settings_file = settings_file, \n+                        eyetracker_on = eyetracker_on)\n+\n+        # number of trials per visual hemifield, for a specific type of target and crowding type\n+        self.train_num_trl_cond = 4\n+        # ratio of unflanked trials\n+        self.unflank_ratio = 1\/6\n+\n+        self.stim_display_time = .15\n+        self.iti = 1\n+\n+    \n+    def create_trials(self):\n+\n+        \"\"\" Creates trials (before running the session) \"\"\"\n+\n+        # some counters for internal bookeeping\n+        self.total_responses = 0\n+        self.correct_responses = 0\n+        self.trial_counter = 0\n+        self.thisResp = []\n+\n+        # number of trials per condition\n+        num_cond_trials = {}\n+        total_trials = 0\n+        crowding_type = [] # to store crowding type\n+        hemifield = [] # to store hemifield\n+        target_name = [] # target name\n+                    \n+        for k in self.settings['crowding']['crwd_type']:\n+            \n+            # number of trials for this crowding type\n+            num_cond_trials[k] = len(self.settings['crowding']['target_names'].keys()) * \\\n+                                self.train_num_trl_cond * 2 # num target x min_num trials x 2 hemifields\n+            # update total number of trials\n+            total_trials += num_cond_trials[k]\n+\n+            # set list with crowdign type name, for bookeeping\n+            crowding_type += list(np.tile(k, num_cond_trials[k]))\n+            \n+            # target name\n+            target_name += list(np.repeat(list(self.settings['crowding']['target_names'].keys()),\n+                                    self.train_num_trl_cond * 2))\n+            \n+            # which hemifield we're displaying the stimuli\n+            hemifield += list(np.tile(['left', 'right'],\n+                                len(self.settings['crowding']['target_names'].keys()) * \\\n+                                    self.train_num_trl_cond))\n+            \n+        # need to add unflankered trials\n+        ## need to add same for unflankered trials\n+        num_cond_trials['unflankered'] = int(total_trials * self.unflank_ratio)\n+        self.total_trials = total_trials + num_cond_trials['unflankered']\n+\n+        crowding_type += list(np.tile('unflankered', num_cond_trials['unflankered']))\n+\n+        target_name += list(np.repeat(list(self.settings['crowding']['target_names'].keys()),\n+                                    int(num_cond_trials['unflankered']\/len(self.settings['crowding']['target_names'].keys()))))\n+\n+        hemifield += list(np.tile(['left', 'right'],\n+                                int(num_cond_trials['unflankered']\/2)))\n+\n+        print('Total number of trials: %i'%self.total_trials)\n+\n+        # now make df with trial info, \n+        # also including target and distractor positions on screen\n+        trials_df = pd.DataFrame(columns = ['index', 'crowding_type', 'hemifield',\n+                                            'target_name','target_pos', \n+                                            'target_color', 'target_ori', \n+                                            'distractor_name', 'distractor_pos',\n+                                            'distractor_color', 'distractor_ori'])\n+\n+        # randomize trials\n+        random_ind = np.arange(self.total_trials)\n+        np.random.shuffle(random_ind)\n+\n+        for trial_num, i in enumerate(random_ind):\n+\n+            # stimuli x position\n+            x_pos_stim = -self.ecc_pix  if hemifield[i] == 'left' else self.ecc_pix\n+\n+            # set initial distractor position\n+            dist_pos = utils.get_flanker_pos(num_fl = self.n_flankers, \n+                                            offset_ang = self.settings['crowding']['offset_ang'], \n+                                            distance_r = self.distance_ratio_bounds[-1], hemi = hemifield[i],\n+                                            ecc = self.ecc_pix)\n+\n+            # get distractor (flanker) names\n+            if crowding_type[i] == 'orientation':\n+\n+                dist_name = utils.get_flanker_name(target_name[i],\n+                                                        num_fl = self.n_flankers,\n+                                                        list_cond = list(self.ori_dict.keys()), \n+                                                        same_ori = False, same_color = True)\n+            elif crowding_type[i] == 'color':\n+\n+                dist_name = utils.get_flanker_name(target_name[i],\n+                                                        num_fl = self.n_flankers,\n+                                                        list_cond = list(self.ori_dict.keys()), \n+                                                        same_ori = True, same_color = False)\n+            elif crowding_type[i] == 'conjunction':\n+\n+                dist_name = utils.get_flanker_name(target_name[i],\n+                                                        num_fl = self.n_flankers,\n+                                                        list_cond = list(self.ori_dict.keys()), \n+                                                        same_ori = False, same_color = False)\n+\n+            else: ## unflankered\n+                dist_name = list(np.repeat(['None'],self.n_flankers))\n+\n+\n+            ## append distractor color and orientation\n+            if crowding_type[i] == 'unflankered':\n+                dist_col = list(np.repeat(['None'],self.n_flankers))\n+                dist_ori = list(np.repeat(['None'],self.n_flankers))\n+            else:\n+                dist_col = [self.colors_dict[x] for x in dist_name]\n+                dist_ori = [self.ori_dict[x] for x in dist_name]\n+\n+            # append trial!\n+            trials_df = trials_df.append(pd.DataFrame({'index': [trial_num],\n+                                                    'crowding_type': [crowding_type[i]],\n+                                                    'hemifield': [hemifield[i]],\n+                                                    'target_name': [target_name[i]],\n+                                                    'target_pos': [[x_pos_stim, 0]],\n+                                                    'target_color': [self.colors_dict[target_name[i]]],\n+                                                    'target_ori': [self.ori_dict[target_name[i]]],\n+                                                    'distractor_name':[dist_name],\n+                                                    'distractor_pos': [dist_pos],\n+                                                    'distractor_color': [dist_col],\n+                                                    'distractor_ori': [dist_ori]\n+                                                }))\n+\n+        ## save dataframe with all trial info\n+        trials_df.to_csv(op.join(self.output_dir, self.output_str+'_trial_info.csv'), index = False)\n+\n+        # trial number to start a new block\n+        # (this is, introduce a pause and maybe recalibration of eyetracker)\n+        self.blk_trials = np.linspace(0, self.total_trials, \n+                                self.settings['crowding']['num_blks']+1, dtype=int)[:-1]\n+        blk_counter = 0\n+\n+        # append all trials\n+        self.all_trials = []\n+        for i in np.arange(self.total_trials):\n+\n+            # set phase conditions (for logging) and durations\n+            if self.blk_trials[blk_counter] == i:\n+                # insert block phase, to pause trials for a bit\n+                phase_cond = tuple(['block_start', 'iti', 'stim', 'response_time','iti'])\n+                blk_start_dur = self.iti if blk_counter == 0 else 1000 # in first block, we just want to start\n+\n+                phase_dur = tuple([blk_start_dur, # make this extremely long\n+                                self.iti, # add iti here because we dont want to start immediately after block start\n+                                self.stim_display_time, \n+                                self.settings['crowding']['max_resp_time']-self.stim_display_time, # max time to respond, in seconds\n+                                self.iti\n+                                ])\n+\n+                if blk_counter < self.settings['crowding']['num_blks'] - 1: \n+                    blk_counter += 1\n+\n+            elif (i > 0) and (i == self.blk_trials[blk_counter] - 1):\n+                phase_cond = tuple(['stim','response_time','iti'])\n+                phase_dur = tuple([self.stim_display_time,\n+                                self.settings['crowding']['max_resp_time']-self.stim_display_time,\n+                                self.iti * 3\n+                                ])\n+            else:\n+                phase_cond = tuple(['stim','response_time','iti'])\n+                phase_dur = tuple([self.stim_display_time,\n+                                self.settings['crowding']['max_resp_time']-self.stim_display_time,\n+                                self.iti\n+                                ])\n+\n+            self.all_trials.append(TrainCrowdingTrial(session = self ,\n+                                                trial_nr = trials_df.iloc[i]['index'],\n+                                                phase_durations = phase_dur,\n+                                                phase_names = phase_cond,\n+                                                trial_dict = trials_df.iloc[i].to_dict(),\n+                                                blk_counter = blk_counter - 1 \n+                                                ))\n+\n+\n     def run(self):\n         \"\"\" Loops over trials and runs them \"\"\"\n \ndiff --git a\/experiment\/trial.py b\/experiment\/trial.py\nindex f9d99db..a13c706 100644\n--- a\/experiment\/trial.py\n+++ b\/experiment\/trial.py\n@@ -298,3 +298,165 @@ def get_events(self):\n                 for param, val in self.parameters.items():\n                     self.session.global_log.loc[idx, param] = val\n \n+\n+class TrainCrowdingTrial(Trial):\n+\n+    def __init__(self, session, trial_nr, phase_durations, phase_names, trial_dict, blk_counter = 0,\n+                 timing = 'seconds', *args, **kwargs):\n+\n+\n+        \"\"\" Initializes a CrowdingTrial object. \n+        Parameters\n+        ----------\n+        session : exptools Session object\n+            A Session object (needed for metadata)\n+        trial_nr: int\n+            Trial nr of trial\n+        timing : str\n+            The \"units\" of the phase durations. Default is 'seconds', where we\n+            assume the phase-durations are in seconds. The other option is\n+            'frames', where the phase-\"duration\" refers to the number of frames.\n+        \"\"\"\n+        \n+        self.ID = trial_nr # trial identifier, not sure if needed\n+        self.session = session\n+\n+        # phase durations for each condition \n+        self.phase_durations = phase_durations\n+        self.phase_names = phase_names\n+\n+        # trial dictionary with relevant info\n+        self.trial_dict = trial_dict\n+        self.blk_counter = blk_counter\n+\n+        super().__init__(session, trial_nr, phase_durations, phase_names, verbose=False, *args, **kwargs)\n+\n+    \n+    def draw(self): \n+\n+        \"\"\" Draw stimuli - target and flankers - for each trial \"\"\"\n+\n+        current_time = self.session.clock.getTime() # get time\n+\n+        if self.phase_names[int(self.phase)] == 'block_start':\n+\n+            # show instructions\n+            if self.blk_counter == 0:\n+                this_instruction_string = ('BLOCK %i\\n\\n\\n\\n\\n\\n'\n+                                '\\n\\n\\n'%(self.blk_counter + 1))\n+            else:\n+                this_instruction_string = ('BLOCK %i\\n\\n\\n\\n\\n\\n'\n+                                    '[Press space bar to start]\\n\\n'%(self.blk_counter + 1))\n+\n+            block_text = visual.TextStim(win = self.session.win, text = this_instruction_string,\n+                        color = (1, 1, 1), font = 'Helvetica Neue', pos = (0, 0), height = 40,\n+                        italic = True, anchorHoriz = 'center', anchorVert = 'center')\n+\n+            # draw text again\n+            block_text.draw()\n+\n+        elif self.phase_names[int(self.phase)] == 'stim':\n+\n+            # define spacing ratio given staircase\n+            if self.trial_dict['crowding_type'] == 'unflankered':\n+                spacing_val = 0\n+            else:\n+                if self.session.settings['crowding']['staircase']['quest']:\n+                    spacing_val = np.clip(self.session.staircases[self.trial_dict['crowding_type']].quantile(), \n+                                    self.session.distance_ratio_bounds[0], \n+                                    self.session.distance_ratio_bounds[1])\n+                else:\n+                    spacing_val = np.clip(self.session.staircases[self.trial_dict['crowding_type']]._nextIntensity,\n+                                    self.session.distance_ratio_bounds[0], \n+                                    self.session.distance_ratio_bounds[1]) \n+\n+            # draw target and distractors\n+            self.session.cwrd_stim.draw(this_phase = self.phase_names[int(self.phase)],\n+                                        trial_dict = self.trial_dict,\n+                                        spacing_val = spacing_val)\n+\n+        elif self.phase_names[int(self.phase)] == 'iti': # iti\n+            \n+            if self.session.trial_counter <= self.ID: # if no response was given before\n+\n+                user_response = 0\n+                if self.trial_dict['crowding_type'] != 'unflankered':\n+                    # update staircase\n+                    self.session.staircases[self.trial_dict['crowding_type']].addResponse(user_response)\n+\n+                self.session.trial_counter += 1 # update trial counter \n+\n+            if self.ID == int(self.session.blk_trials[self.blk_counter+1] - 1): # if last trial of the block\n+\n+                this_instruction_string = ('Accuracy is %.2f%%\\n\\n\\n\\n'%(self.session.correct_responses\/self.ID*100))\n+\n+                acc_text = visual.TextStim(win = self.session.win, text = this_instruction_string,\n+                        color = (1, 1, 1), font = 'Helvetica Neue', pos = (0, 0), height = 40,\n+                        italic = True, anchorHoriz = 'center', anchorVert = 'center')\n+\n+                # draw text again\n+                acc_text.draw()\n+\n+            if feedback_response[-1] == 1: # if last response was correct\n+                self.session.fixation.lineColor = [-1, 1, -1] # turn green\n+            else:\n+                self.session.fixation.lineColor = [1, -1, -1] # turn red (response incorrect)\n+\n+        ## fixation cross\n+        self.session.fixation.draw() \n+\n+        #print(self.phase_names[int(self.phase)])\n+\n+\n+    def get_events(self):\n+        \"\"\" Logs responses\/triggers \"\"\"\n+        for ev, t in event.getKeys(timeStamped=self.session.clock): # list of of (keyname, time) relative to Clock\u2019s last reset\n+            if len(ev) > 0:\n+                if ev in ['q']:\n+                    print('trial canceled by user')  \n+                    self.session.close_all()\n+                    self.session.quit()\n+\n+                elif (ev in ['space']) and (self.phase_names[int(self.phase)] == 'block_start'): # new block starts\n+                    event_type = 'block_start'\n+                    self.stop_phase()\n+\n+                else:\n+                    event_type = 'response'\n+                    self.session.total_responses += 1\n+\n+                    if self.phase_names[int(self.phase)] == 'response_time':\n+                    \n+                        if (ev in list(np.ravel(list(self.session.settings['keys']['target_key'].values())))): \n+\n+                            if self.session.trial_counter <= self.ID:\n+\n+                                ## get user response!\n+                                user_response = utils.get_response4staircase(event_key = ev, \n+                                                                        target_key = self.session.settings['keys']['target_key'][self.trial_dict['target_name']])\n+\n+                                self.session.thisResp.append(user_response)\n+                                self.session.correct_responses += user_response\n+\n+                                # update color with answer\n+                                if len(self.session.thisResp) > 0: # update with answer\n+                                    if self.trial_dict['crowding_type'] != 'unflankered':\n+                                        # update staircase\n+                                        self.session.staircases[self.trial_dict['crowding_type']].addResponse(self.session.thisResp[-1])\n+                                    # reset response again\n+                                    self.session.thisResp = []\n+\n+                                self.session.trial_counter += 1 # update trial counter   \n+\n+                            self.stop_phase()\n+\n+                # log everything into session data frame\n+                idx = self.session.global_log.shape[0]\n+                self.session.global_log.loc[idx, 'trial_nr'] = self.ID\n+                self.session.global_log.loc[idx, 'onset'] = t\n+                self.session.global_log.loc[idx, 'event_type'] = event_type\n+                self.session.global_log.loc[idx, 'phase'] = self.phase\n+                self.session.global_log.loc[idx, 'response'] = ev                \n+\n+                for param, val in self.parameters.items():\n+                    self.session.global_log.loc[idx, param] = val\n","files":{"\/experiment\/main.py":{"changes":[{"diff":"\n import os\n import os.path as op\n #import appnope\n-from session import VsearchSession, CrowdingSession \n+from session import VsearchSession, CrowdingSession, TrainCrowdingSession \n \n \n # define main function\n","add":1,"remove":1,"filename":"\/experiment\/main.py","badparts":["from session import VsearchSession, CrowdingSession "],"goodparts":["from session import VsearchSession, CrowdingSession, TrainCrowdingSession "]},{"diff":"\n                         'as 2nd argument in the command line!')\n     \n     sj_num = str(sys.argv[1]).zfill(3) # subject number\n-    ses_num = str(sys.argv[2]) # run number\n+    ses_type = str(sys.argv[2]) # run number\n \n     # task name dictionary\n     tasks = {'search': 'VisualSearch', 'crowding': 'Crowding'}\n     \n-    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))\n+    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))\n \n     exp_type = ''\n     while exp_type not in ('search','crowding'):\n         exp_type = input('Which experiment to run (search\/crowding)?: ')\n \n-    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))\n+    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))\n \n     # make output dir\n     base_dir = op.split(os.getcwd())[0] # main path for all folders of project\n","add":3,"remove":3,"filename":"\/experiment\/main.py","badparts":["    ses_num = str(sys.argv[2]) # run number","    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))","    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))"],"goodparts":["    ses_type = str(sys.argv[2]) # run number","    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))","    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))"]},{"diff":"\n     print('saving files in %s'%output_dir)\n \n     # string for output data\n-    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])\n+    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])\n \n     # if file already exists\n     behav_file = op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str))\n","add":1,"remove":1,"filename":"\/experiment\/main.py","badparts":["    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])"],"goodparts":["    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])"]},{"diff":"\n \n \n     # load approriate class object to be run\n-    if exp_type == 'search': # run standard pRF mapper\n+    #\n+    if exp_type == 'search': # run visual search task\n \n         exp_sess = VsearchSession(output_str = output_str,\n                               output_dir = output_dir,\n                               settings_file = 'experiment_settings.yml',\n                               eyetracker_on = False) #True)\n \n-    elif exp_type == 'crowding': # run feature pRF mapper\n-         exp_sess = CrowdingSession(output_str = output_str,\n+    elif exp_type == 'crowding': # run crowding task\n+        \n+        if ses_type in ['practice', 'train']: # short practice ses, to understand task\n+\n+            exp_sess = TrainCrowdingSession(output_str = output_str,\n                                   output_dir = output_dir,\n                                   settings_file = 'experiment_settings.yml',\n                                   eyetracker_on = False) #True)\n+        \n+        else: # real deal\n+            exp_sess = CrowdingSession(output_str = output_str,\n+                                    output_dir = output_dir,\n+                                    settings_file = 'experiment_settings.yml',\n+                                    eyetracker_on = False) #True)\n \n    \t                            \n     exp_sess.run()","add":13,"remove":3,"filename":"\/experiment\/main.py","badparts":["    if exp_type == 'search': # run standard pRF mapper","    elif exp_type == 'crowding': # run feature pRF mapper","         exp_sess = CrowdingSession(output_str = output_str,"],"goodparts":["    if exp_type == 'search': # run visual search task","    elif exp_type == 'crowding': # run crowding task","        if ses_type in ['practice', 'train']: # short practice ses, to understand task","            exp_sess = TrainCrowdingSession(output_str = output_str,","        else: # real deal","            exp_sess = CrowdingSession(output_str = output_str,","                                    output_dir = output_dir,","                                    settings_file = 'experiment_settings.yml',","                                    eyetracker_on = False) #True)"]},{"diff":"\n import os\n import os.path as op\n #import appnope\n-from session import VsearchSession, CrowdingSession \n+from session import VsearchSession, CrowdingSession, TrainCrowdingSession \n \n \n # define main function\n","add":1,"remove":1,"filename":"\/experiment\/main.py","badparts":["from session import VsearchSession, CrowdingSession "],"goodparts":["from session import VsearchSession, CrowdingSession, TrainCrowdingSession "]},{"diff":"\n                         'as 2nd argument in the command line!')\n     \n     sj_num = str(sys.argv[1]).zfill(3) # subject number\n-    ses_num = str(sys.argv[2]) # run number\n+    ses_type = str(sys.argv[2]) # run number\n \n     # task name dictionary\n     tasks = {'search': 'VisualSearch', 'crowding': 'Crowding'}\n     \n-    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))\n+    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))\n \n     exp_type = ''\n     while exp_type not in ('search','crowding'):\n         exp_type = input('Which experiment to run (search\/crowding)?: ')\n \n-    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))\n+    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))\n \n     # make output dir\n     base_dir = op.split(os.getcwd())[0] # main path for all folders of project\n","add":3,"remove":3,"filename":"\/experiment\/main.py","badparts":["    ses_num = str(sys.argv[2]) # run number","    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))","    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))"],"goodparts":["    ses_type = str(sys.argv[2]) # run number","    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))","    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))"]},{"diff":"\n     print('saving files in %s'%output_dir)\n \n     # string for output data\n-    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])\n+    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])\n \n     # if file already exists\n     behav_file = op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str))\n","add":1,"remove":1,"filename":"\/experiment\/main.py","badparts":["    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])"],"goodparts":["    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])"]},{"diff":"\n \n \n     # load approriate class object to be run\n-    if exp_type == 'search': # run standard pRF mapper\n+    #\n+    if exp_type == 'search': # run visual search task\n \n         exp_sess = VsearchSession(output_str = output_str,\n                               output_dir = output_dir,\n                               settings_file = 'experiment_settings.yml',\n                               eyetracker_on = False) #True)\n \n-    elif exp_type == 'crowding': # run feature pRF mapper\n-         exp_sess = CrowdingSession(output_str = output_str,\n+    elif exp_type == 'crowding': # run crowding task\n+        \n+        if ses_type in ['practice', 'train']: # short practice ses, to understand task\n+\n+            exp_sess = TrainCrowdingSession(output_str = output_str,\n                                   output_dir = output_dir,\n                                   settings_file = 'experiment_settings.yml',\n                                   eyetracker_on = False) #True)\n+        \n+        else: # real deal\n+            exp_sess = CrowdingSession(output_str = output_str,\n+                                    output_dir = output_dir,\n+                                    settings_file = 'experiment_settings.yml',\n+                                    eyetracker_on = False) #True)\n \n    \t                            \n     exp_sess.run()","add":13,"remove":3,"filename":"\/experiment\/main.py","badparts":["    if exp_type == 'search': # run standard pRF mapper","    elif exp_type == 'crowding': # run feature pRF mapper","         exp_sess = CrowdingSession(output_str = output_str,"],"goodparts":["    if exp_type == 'search': # run visual search task","    elif exp_type == 'crowding': # run crowding task","        if ses_type in ['practice', 'train']: # short practice ses, to understand task","            exp_sess = TrainCrowdingSession(output_str = output_str,","        else: # real deal","            exp_sess = CrowdingSession(output_str = output_str,","                                    output_dir = output_dir,","                                    settings_file = 'experiment_settings.yml',","                                    eyetracker_on = False) #True)"]}],"source":"\n\nimport sys import os import os.path as op from session import VsearchSession, CrowdingSession def main(): if len(sys.argv) < 2: raise NameError('Please add subject number(ex:1) ' 'as 1st argument in the command line!') elif len(sys.argv) < 3: raise NameError('Please add session number(ex:1) ' 'as 2nd argument in the command line!') sj_num=str(sys.argv[1]).zfill(3) ses_num=str(sys.argv[2]) tasks={'search': 'VisualSearch', 'crowding': 'Crowding'} print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num)) exp_type='' while exp_type not in('search','crowding'): exp_type=input('Which experiment to run(search\/crowding)?: ') print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num)) base_dir=op.split(os.getcwd())[0] output_dir=op.join(base_dir,'output','sourcedata', 'sub-{sj}'.format(sj=sj_num)) if not op.isdir(output_dir): os.makedirs(output_dir) print('saving files in %s'%output_dir) output_str='sub-{sj}_ses-{ses}_task-{task}'.format(sj=sj_num, ses=ses_num, task=tasks[exp_type]) behav_file=op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str)) if op.exists(behav_file): print('file already exists!') overwrite='' while overwrite not in('y','yes','n','no'): overwrite=input('overwrite %s\\n(y\/yes\/n\/no)?: '%behav_file) if overwrite in['no','n']: raise NameError('Run %s already in directory\\nstopping experiment!'%behav_file) if exp_type=='search': exp_sess=VsearchSession(output_str=output_str, output_dir=output_dir, settings_file='experiment_settings.yml', eyetracker_on=False) elif exp_type=='crowding': exp_sess=CrowdingSession(output_str=output_str, output_dir=output_dir, settings_file='experiment_settings.yml', eyetracker_on=False) \t exp_sess.run() if __name__=='__main__': main() ","sourceWithComments":"# import relevant packages\nimport sys\nimport os\nimport os.path as op\n#import appnope\nfrom session import VsearchSession, CrowdingSession \n\n\n# define main function\ndef main():\n    \n    # take user input\n    \n    # define participant number and open json parameter file\n    if len(sys.argv) < 2:\n        raise NameError('Please add subject number (ex:1) '\n                        'as 1st argument in the command line!')\n\n    elif len(sys.argv) < 3:\n        raise NameError('Please add session number (ex:1) '\n                        'as 2nd argument in the command line!')\n    \n    sj_num = str(sys.argv[1]).zfill(3) # subject number\n    ses_num = str(sys.argv[2]) # run number\n\n    # task name dictionary\n    tasks = {'search': 'VisualSearch', 'crowding': 'Crowding'}\n    \n    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))\n\n    exp_type = ''\n    while exp_type not in ('search','crowding'):\n        exp_type = input('Which experiment to run (search\/crowding)?: ')\n\n    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))\n\n    # make output dir\n    base_dir = op.split(os.getcwd())[0] # main path for all folders of project\n    output_dir = op.join(base_dir,'output','sourcedata', 'sub-{sj}'.format(sj=sj_num))\n\n    # if output path doesn't exist, create it\n    if not op.isdir(output_dir): \n        os.makedirs(output_dir)\n    print('saving files in %s'%output_dir)\n\n    # string for output data\n    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])\n\n    # if file already exists\n    behav_file = op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str))\n    if op.exists(behav_file): \n        print('file already exists!')\n\n        overwrite = ''\n        while overwrite not in ('y','yes','n','no'):\n            overwrite = input('overwrite %s\\n(y\/yes\/n\/no)?: '%behav_file)\n\n        if overwrite in ['no','n']:\n            raise NameError('Run %s already in directory\\nstopping experiment!'%behav_file)\n\n\n    # load approriate class object to be run\n    if exp_type == 'search': # run standard pRF mapper\n\n        exp_sess = VsearchSession(output_str = output_str,\n                              output_dir = output_dir,\n                              settings_file = 'experiment_settings.yml',\n                              eyetracker_on = False) #True)\n\n    elif exp_type == 'crowding': # run feature pRF mapper\n         exp_sess = CrowdingSession(output_str = output_str,\n                                  output_dir = output_dir,\n                                  settings_file = 'experiment_settings.yml',\n                                  eyetracker_on = False) #True)\n\n   \t                            \n    exp_sess.run()\n\n\nif __name__ == '__main__':\n    main()"},"\/experiment\/session.py":{"changes":[{"diff":"\n \n from exptools2.core import Session, PylinkEyetrackerSession\n \n-from trial import VsearchTrial, CrowdingTrial \n+from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial\n from stim import VsearchStim, CrowdingStim \n \n from psychopy import visual, tools\n","add":1,"remove":1,"filename":"\/experiment\/session.py","badparts":["from trial import VsearchTrial, CrowdingTrial "],"goodparts":["from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial"]},{"diff":"\n                                 self.settings['crowding']['iti']\n                                 ])\n \n-                if blk_counter < self.settings['crowding']['num_blks']: \n+                if blk_counter < self.settings['crowding']['num_blks'] - 1: \n                     blk_counter += 1\n \n             else:\n","add":1,"remove":1,"filename":"\/experiment\/session.py","badparts":["                if blk_counter < self.settings['crowding']['num_blks']: "],"goodparts":["                if blk_counter < self.settings['crowding']['num_blks'] - 1: "]},{"diff":"\n \n from exptools2.core import Session, PylinkEyetrackerSession\n \n-from trial import VsearchTrial, CrowdingTrial \n+from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial\n from stim import VsearchStim, CrowdingStim \n \n from psychopy import visual, tools\n","add":1,"remove":1,"filename":"\/experiment\/session.py","badparts":["from trial import VsearchTrial, CrowdingTrial "],"goodparts":["from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial"]},{"diff":"\n                                 self.settings['crowding']['iti']\n                                 ])\n \n-                if blk_counter < self.settings['crowding']['num_blks']: \n+                if blk_counter < self.settings['crowding']['num_blks'] - 1: \n                     blk_counter += 1\n \n             else:\n","add":1,"remove":1,"filename":"\/experiment\/session.py","badparts":["                if blk_counter < self.settings['crowding']['num_blks']: "],"goodparts":["                if blk_counter < self.settings['crowding']['num_blks'] - 1: "]}]}},"msg":"added training session for crowding, need to give feedback on fixation cross and check for fixations"}},"https:\/\/github.com\/MIT-LCP\/physionet-build":{"8fb7ab25d0e2a153cd340683efe29ee4b74b4bb8":{"url":"https:\/\/api.github.com\/repos\/MIT-LCP\/physionet-build\/commits\/8fb7ab25d0e2a153cd340683efe29ee4b74b4bb8","html_url":"https:\/\/github.com\/MIT-LCP\/physionet-build\/commit\/8fb7ab25d0e2a153cd340683efe29ee4b74b4bb8","sha":"8fb7ab25d0e2a153cd340683efe29ee4b74b4bb8","keyword":"session hijacking check","diff":"diff --git a\/physionet-django\/project\/utility.py b\/physionet-django\/project\/utility.py\nindex 6b230f6d4..8b82e766f 100644\n--- a\/physionet-django\/project\/utility.py\n+++ b\/physionet-django\/project\/utility.py\n@@ -1,3 +1,4 @@\n+import base64\n import datetime\n import errno\n import os\n@@ -5,12 +6,14 @@\n import pdb\n import uuid\n import logging\n+import re\n import requests\n import json\n \n-from django.contrib import messages\n+from django.contrib import auth, messages\n+from django.contrib.sites.shortcuts import get_current_site\n from django.conf import settings\n-from django.core.exceptions import ValidationError\n+from django.core.exceptions import (PermissionDenied, ValidationError)\n from django.http import HttpResponse, Http404\n from googleapiclient.errors import HttpError\n \n@@ -312,3 +315,108 @@ def grant_gcp_group_access(user, project, data_access, request):\n         messages.success(request, '{0} was previously awarded \\\n             to {1} for project: {2}'.format(access, email, project))\n         return False\n+\n+\n+# The following regular expression defines user agents that are\n+# permitted to use HTTP authentication for accessing protected\n+# databases.  This list should not include web browsers.  (If you are\n+# writing a new program for accessing protected databases, please use\n+# a distinctive UA string so that your program can be whitelisted\n+# here.  Do not use the generic UA string provided by your HTTP client\n+# library.)\n+HTTP_AUTH_USER_AGENT = re.compile('|'.join((\n+    'Wget\/',\n+    'libwfdb\/',\n+)))\n+\n+\n+def http_auth_allowed(request):\n+    \"\"\"\n+    Check if HTTP authentication is permitted for the given request.\n+\n+    Web browsers typically don't implement HTTP authentication in a\n+    very user-friendly or secure way, so this mechanism is only\n+    permitted for specific non-interactive user agents.  For safety,\n+    HTTP authentication is only permitted for GET and HEAD requests,\n+    and (unless settings.DEBUG is set) only via HTTPS.\n+    \"\"\"\n+\n+    if request.method not in ('GET', 'HEAD'):\n+        return False\n+    if not request.is_secure() and not settings.DEBUG:\n+        return False\n+\n+    ua = request.META.get('HTTP_USER_AGENT', '')\n+    if HTTP_AUTH_USER_AGENT.match(ua):\n+        return True\n+    else:\n+        return False\n+\n+\n+def check_http_auth(request):\n+    \"\"\"\n+    Check if a request includes HTTP authentication.\n+\n+    If HTTP authentication is permitted for the given request, and a\n+    valid username and password are provided, set request.user to the\n+    corresponding user object.  Otherwise, the request is not\n+    modified.\n+\n+    For safety, HTTP authentication is only used for certain requests\n+    from non-interactive user agents; see http_auth_allowed().\n+\n+    This should be invoked at the start of the view before checking\n+    user credentials, and should be paired with require_http_auth().\n+    \"\"\"\n+\n+    if 'HTTP_AUTHORIZATION' in request.META:\n+        # If an Authorization header is supplied, but this request is\n+        # not allowed to use HTTP authentication, ignore the header.\n+        if not http_auth_allowed(request):\n+            return\n+\n+        # If the user is already authenticated, ignore the header.\n+        if request.user.is_authenticated:\n+            return\n+\n+        tokens = request.META['HTTP_AUTHORIZATION'].split()\n+        if len(tokens) == 2 and tokens[0].lower() == 'basic':\n+            try:\n+                data = base64.b64decode(tokens[1], validate=True).decode()\n+                username, password = data.split(':', 1)\n+            except Exception:\n+                return\n+\n+            user = auth.authenticate(request=request,\n+                                     username=username,\n+                                     password=password)\n+            if user:\n+                request.user = user\n+\n+\n+def require_http_auth(request):\n+    \"\"\"\n+    Ask the client to authenticate itself and retry the request.\n+\n+    For safety, HTTP authentication is only allowed for certain\n+    requests from non-interactive user agents; see\n+    http_auth_allowed().  If this request is not allowed, or if the\n+    user is already authenticated, raise PermissionDenied.\n+\n+    Otherwise, return an HttpResponse with status 401 (Unauthorized),\n+    which indicates the client should repeat the request with a\n+    username and password.\n+\n+    This should be invoked after check_http_auth(), if the user is\n+    unknown or is not authorized to view the given resource.\n+    \"\"\"\n+\n+    if http_auth_allowed(request) and not request.user.is_authenticated:\n+        site = get_current_site(request)\n+        response = HttpResponse(status=401)\n+        response['WWW-Authenticate'] = (\n+            'Basic realm=\"{}\", charset=\"UTF-8\"'.format(site.name)\n+        )\n+        return response\n+    else:\n+        raise PermissionDenied()\n","message":"","files":{"\/physionet-django\/project\/utility.py":{"changes":[{"diff":"\n import uuid\n import logging\n+import re\n import requests\n import json\n \n-from django.contrib import messages\n+from django.contrib import auth, messages\n+from django.contrib.sites.shortcuts import get_current_site\n from django.conf import settings\n-from django.core.exceptions import ValidationError\n+from django.core.exceptions import (PermissionDenied, ValidationError)\n from django.http import HttpResponse, Http404\n from googleapiclient.errors import HttpError\n \n","add":4,"remove":2,"filename":"\/physionet-django\/project\/utility.py","badparts":["from django.contrib import messages","from django.core.exceptions import ValidationError"],"goodparts":["import re","from django.contrib import auth, messages","from django.contrib.sites.shortcuts import get_current_site","from django.core.exceptions import (PermissionDenied, ValidationError)"]}],"source":"\nimport datetime import errno import os import shutil import pdb import uuid import logging import requests import json from django.contrib import messages from django.conf import settings from django.core.exceptions import ValidationError from django.http import HttpResponse, Http404 from googleapiclient.errors import HttpError from console.utility import create_directory_service LOGGER=logging.getLogger(__name__) class FileInfo(): \"\"\" For displaying lists of files in project pages All attributes are human readable strings \"\"\" def __init__(self, name, size, last_modified): self.name=name self.size=size self.last_modified=last_modified class DirectoryInfo(): def __init__(self, name): self.name=name class DirectoryBreadcrumb(): \"\"\" For navigating through project file directories \"\"\" def __init__(self, name, rel_path, full_subdir, active=True): self.name=name self.rel_path=rel_path self.full_subdir=full_subdir self.active=active def get_dir_breadcrumbs(path, directory=True): \"\"\" Given a subdirectory, return all breadcrumb elements full_subdir for inputs: '' --> d1 -->['', 'd1'] d1\/ -->['', 'd1'] d1\/d2\/d3 d1\/d2\/d3\/ \"\"\" if path=='': return[DirectoryBreadcrumb(name='<base>', rel_path='', full_subdir='', active=False)] if path.endswith('\/'): path=path[:-1] dirs=path.split('\/') rel_path='..\/' * len(dirs) if not directory: rel_path=(rel_path[3:] or '.\/') dir_breadcrumbs=[DirectoryBreadcrumb(name='<base>', full_subdir='', rel_path=rel_path)] for i in range(len(dirs)): rel_path=(rel_path[3:] or '.\/') dir_breadcrumbs.append(DirectoryBreadcrumb( name=dirs[i], rel_path=rel_path, full_subdir='\/'.join([d.name for d in dir_breadcrumbs[1:]]+[dirs[i]]))) dir_breadcrumbs[-1].active=False return dir_breadcrumbs class StorageInfo(): \"\"\" Object for storing display information about a project's storage. \"\"\" def __init__(self, allowance, used, include_remaining=True, main_used=None, compressed_used=None): \"\"\" Initialize fields with optional args for published and unpublished projects The include_remaining argument has no effect and is kept for compatibility. \"\"\" self.allowance=allowance self.readable_allowance=readable_size(allowance) self.used=used if used is None: self.readable_used='unknown' self.remaining=None self.readable_remaining='unknown' self.p_used='?' self.p_remaining='?' else: self.readable_used=readable_size(used) self.remaining=allowance -used self.readable_remaining=readable_size(self.remaining) self.p_used=round(used * 100 \/ allowance) self.p_remaining=round(self.remaining * 100 \/ allowance) if main_used is not None: self.main_used=main_used self.readable_main_used=readable_size(main_used) if compressed_used is not None: self.compressed_used=compressed_used self.readable_compressed_used=readable_size(compressed_used) def list_files(directory): \"List files in a directory\" files=[] for ent in os.scandir(directory): if not ent.is_dir(): files.append(ent.name) return sorted(files) def list_directories(directory): \"List directories in a directory\" dirs=[] for ent in os.scandir(directory): if ent.is_dir(): dirs.append(ent.name) return sorted(dirs) def list_items(directory, return_separate=True): \"List files and directories in a directory. Return separate or combine lists\" if return_separate: dirs=[] files=[] for ent in os.scandir(directory): if ent.is_dir(): dirs.append(ent.name) else: files.append(ent.name) return(sorted(files), sorted(dirs)) else: return sorted(os.listdir(directory)) def remove_items(items, ignore_missing=True): \"\"\" Delete the list of(full file path) files\/directories. \"\"\" for item in items: try: os.remove(item) except IsADirectoryError: shutil.rmtree(item) except FileNotFoundError: if not ignore_missing: raise def clear_directory(directory): \"\"\" Delete all files and folders in a directory. \"\"\" remove_items(os.path.join(directory, i) for i in os.listdir(directory)) def rename_file(old_path, new_path): \"\"\" Rename a file, without overwriting an existing file. If the destination path already exists, this will attempt to raise a FileExistsError. This is not guaranteed to work correctly in all cases. \"\"\" if os.path.exists(new_path): raise FileExistsError(errno.EEXIST, os.strerror(errno.EEXIST), old_path, new_path) os.rename(old_path, new_path) def move_items(items, target_folder): \"\"\" Move items(full path) into target folder(full path) \"\"\" for item in items: rename_file(item, os.path.join(target_folder, os.path.split(item)[-1])) def get_file_info(file_path): \"Given a file path, get the information used to display it\" name=os.path.split(file_path)[-1] size=readable_size(os.path.getsize(file_path)) last_modified=datetime.date.fromtimestamp(os.path.getmtime(file_path)).strftime(\"%Y-%m-%d\") return FileInfo(name, size, last_modified) def get_directory_info(dir_path): \"Given a directory path, get the information used to display it\" return DirectoryInfo(os.path.split(dir_path)[-1]) def get_tree_size(path): \"\"\"Return total size of files in given path and subdirs.\"\"\" total=0 for entry in os.scandir(path): if entry.is_dir(follow_symlinks=False): total +=get_tree_size(entry.path) else: total +=entry.stat(follow_symlinks=False).st_size return total def readable_size(num, suffix='B'): \"Display human readable size of byte number\" for unit in['','K','M','G','T','P','E','Z']: if abs(num) < 1024: readsize='{0:g}'.format(num) if '.' not in readsize: return readsize+' '+unit+suffix else: return '{:3.1f}{:s}{:s}'.format(num, unit, suffix) num \/=1024.0 return '{:.1f}{:s}{:s}'.format(num, 'Y', suffix) def write_uploaded_file(file, write_file_path, overwrite=True): \"\"\" file: request.FILE write_file_path: full file path to be written \"\"\" if overwrite: try: os.unlink(write_file_path) except FileNotFoundError: pass with open(write_file_path, 'xb') as destination: for chunk in file.chunks(): destination.write(chunk) def get_form_errors(form): \"\"\" Extract all errors from a form eith errors \"\"\" all_errors=[] for field in form.errors: all_errors +=form.errors[field] return all_errors def grant_aws_open_data_access(user, project): \"\"\" Function to grant a AWS ID access to the bukets in the Open Data AWS platform. \"\"\" url=settings.AWS_CLOUD_FORMATION payload={'accountid':[\"{}\".format(user.cloud_information.aws_id)]} headers={settings.AWS_HEADER_KEY: settings.AWS_HEADER_VALUE, settings.AWS_HEADER_KEY2: settings.AWS_HEADER_VALUE2} response=requests.post(url, data=json.dumps(payload), headers=headers) message=response.json()['message'].split(',')[0] LOGGER.info(\"AWS message '{0}' for project{1}\".format( response.json()['message'], project)) return message def grant_gcp_group_access(user, project, data_access, request): \"\"\" Add a specific email address to a organizational google group Returns two things: The first argument is if access was awarded. The second argument is if the access was awarded in a previous time. \"\"\" email=user.cloud_information.gcp_email.email service=create_directory_service(settings.GCP_DELEGATION_EMAIL) members=service.members().list(groupKey=data_access.location).execute() access=\"Access to the GCP BigQuery\" if data_access==3: access=\"Access to the GCP bucket\" if email not in str(members): try: outcome=service.members().insert(groupKey=data_access.location, body={\"email\": email, \"delivery_settings\": \"NONE\"}).execute() if outcome['role']==\"MEMBER\": messages.success(request, '{0} has been granted \\ to{1} for project:{2}'.format(access, email, project)) LOGGER.info(\"Added user{0} to BigQuery group{1}\".format( email, data_access.location)) return True except HttpError as e: if json.loads(e.content)['error']['message']=='Member already exists.': messages.success(request, '{0} was previously awarded \\ to{1} for project:{2}'.format(access, email, project)) return False else: raise e else: messages.success(request, 'There was an error granting \\ access.') LOGGER.info(\"Error adding the user{0} to Bigquery group \\ {1}. Error:{2}\".format(email, data_access.location, outcome)) else: messages.success(request, '{0} was previously awarded \\ to{1} for project:{2}'.format(access, email, project)) return False ","sourceWithComments":"import datetime\nimport errno\nimport os\nimport shutil\nimport pdb\nimport uuid\nimport logging\nimport requests\nimport json\n\nfrom django.contrib import messages\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpResponse, Http404\nfrom googleapiclient.errors import HttpError\n\nfrom console.utility import create_directory_service\n\nLOGGER = logging.getLogger(__name__)\n\nclass FileInfo():\n    \"\"\"\n    For displaying lists of files in project pages\n    All attributes are human readable strings\n    \"\"\"\n    def __init__(self, name, size, last_modified):\n        self.name = name\n        self.size = size\n        self.last_modified= last_modified\n\n\nclass DirectoryInfo():\n     def __init__(self, name):\n        self.name = name\n\n\nclass DirectoryBreadcrumb():\n    \"\"\"\n    For navigating through project file directories\n    \"\"\"\n    def __init__(self, name, rel_path, full_subdir, active=True):\n        self.name = name\n        self.rel_path = rel_path\n        self.full_subdir = full_subdir\n        self.active = active\n\n\ndef get_dir_breadcrumbs(path, directory=True):\n    \"\"\"\n    Given a subdirectory, return all breadcrumb elements\n\n    full_subdir for inputs:\n    ''  -->\n    d1  --> ['', 'd1']\n    d1\/  --> ['', 'd1']\n    d1\/d2\/d3\n    d1\/d2\/d3\/\n    \"\"\"\n\n    if path == '':\n        return [DirectoryBreadcrumb(name='<base>', rel_path='',\n                                    full_subdir='', active=False)]\n    if path.endswith('\/'):\n        path = path[:-1]\n    dirs = path.split('\/')\n    rel_path = '..\/' * len(dirs)\n    if not directory:\n        rel_path = (rel_path[3:] or '.\/')\n    dir_breadcrumbs = [DirectoryBreadcrumb(name='<base>', full_subdir='',\n                                           rel_path=rel_path)]\n    for i in range(len(dirs)):\n        rel_path = (rel_path[3:] or '.\/')\n        dir_breadcrumbs.append(DirectoryBreadcrumb(\n            name=dirs[i], rel_path=rel_path,\n            full_subdir='\/'.join([d.name for d in dir_breadcrumbs[1:]]+ [dirs[i]])))\n    dir_breadcrumbs[-1].active = False\n    return dir_breadcrumbs\n\n\nclass StorageInfo():\n    \"\"\"\n    Object for storing display information about a project's storage.\n    \"\"\"\n    def __init__(self, allowance, used, include_remaining=True,\n        main_used=None, compressed_used=None):\n        \"\"\"\n        Initialize fields with optional args for published and\n        unpublished projects\n\n        The include_remaining argument has no effect and is kept for\n        compatibility.\n        \"\"\"\n        self.allowance = allowance\n        self.readable_allowance = readable_size(allowance)\n\n        # Total used\n        self.used = used\n        if used is None:\n            self.readable_used = 'unknown'\n            self.remaining = None\n            self.readable_remaining = 'unknown'\n            self.p_used = '?'\n            self.p_remaining = '?'\n        else:\n            self.readable_used = readable_size(used)\n            self.remaining = allowance - used\n            self.readable_remaining = readable_size(self.remaining)\n            self.p_used = round(used * 100 \/ allowance)\n            self.p_remaining = round(self.remaining * 100 \/ allowance)\n\n        if main_used is not None:\n            self.main_used = main_used\n            self.readable_main_used = readable_size(main_used)\n\n        if compressed_used is not None:\n            self.compressed_used = compressed_used\n            self.readable_compressed_used = readable_size(compressed_used)\n\n\ndef list_files(directory):\n    \"List files in a directory\"\n    files = []\n    for ent in os.scandir(directory):\n        if not ent.is_dir():\n            files.append(ent.name)\n    return sorted(files)\n\n\ndef list_directories(directory):\n    \"List directories in a directory\"\n    dirs = []\n    for ent in os.scandir(directory):\n        if ent.is_dir():\n            dirs.append(ent.name)\n    return sorted(dirs)\n\n\ndef list_items(directory, return_separate=True):\n    \"List files and directories in a directory. Return separate or combine lists\"\n    if return_separate:\n        dirs = []\n        files = []\n        for ent in os.scandir(directory):\n            if ent.is_dir():\n                dirs.append(ent.name)\n            else:\n                files.append(ent.name)\n        return (sorted(files), sorted(dirs))\n    else:\n        return sorted(os.listdir(directory))\n\ndef remove_items(items, ignore_missing=True):\n    \"\"\"\n    Delete the list of (full file path) files\/directories.\n    \"\"\"\n    for item in items:\n        try:\n            os.remove(item)\n        except IsADirectoryError:\n            shutil.rmtree(item)\n        except FileNotFoundError:\n            if not ignore_missing:\n                raise\n\ndef clear_directory(directory):\n    \"\"\"\n    Delete all files and folders in a directory.\n    \"\"\"\n    remove_items(os.path.join(directory, i) for i in os.listdir(directory))\n\ndef rename_file(old_path, new_path):\n    \"\"\"\n    Rename a file, without overwriting an existing file.\n\n    If the destination path already exists, this will attempt to raise\n    a FileExistsError.  This is not guaranteed to work correctly in\n    all cases.\n    \"\"\"\n    if os.path.exists(new_path):\n        raise FileExistsError(errno.EEXIST, os.strerror(errno.EEXIST),\n                              old_path, new_path)\n    os.rename(old_path, new_path)\n\ndef move_items(items, target_folder):\n    \"\"\"\n    Move items (full path) into target folder (full path)\n    \"\"\"\n    for item in items:\n        rename_file(item, os.path.join(target_folder, os.path.split(item)[-1]))\n\ndef get_file_info(file_path):\n    \"Given a file path, get the information used to display it\"\n    name = os.path.split(file_path)[-1]\n    size = readable_size(os.path.getsize(file_path))\n    last_modified = datetime.date.fromtimestamp(os.path.getmtime(file_path)).strftime(\"%Y-%m-%d\")\n    return FileInfo(name, size, last_modified)\n\ndef get_directory_info(dir_path):\n    \"Given a directory path, get the information used to display it\"\n    return DirectoryInfo(os.path.split(dir_path)[-1])\n\ndef get_tree_size(path):\n    \"\"\"Return total size of files in given path and subdirs.\"\"\"\n    total = 0\n    for entry in os.scandir(path):\n        if entry.is_dir(follow_symlinks=False):\n            total += get_tree_size(entry.path)\n        else:\n            total += entry.stat(follow_symlinks=False).st_size\n    return total\n\n\ndef readable_size(num, suffix='B'):\n    \"Display human readable size of byte number\"\n    for unit in ['','K','M','G','T','P','E','Z']:\n        if abs(num) < 1024:\n            readsize = '{0:g}'.format(num)\n\n            if '.' not in readsize:\n                return readsize+' '+unit+suffix\n            else:\n                return '{:3.1f} {:s}{:s}'.format(num, unit, suffix)\n\n        num \/= 1024.0\n    return '{:.1f}{:s}{:s}'.format(num, 'Y', suffix)\n\n\ndef write_uploaded_file(file, write_file_path, overwrite=True):\n    \"\"\"\n    file: request.FILE\n    write_file_path: full file path to be written\n    \"\"\"\n    if overwrite:\n        try:\n            os.unlink(write_file_path)\n        except FileNotFoundError:\n            pass\n    with open(write_file_path, 'xb') as destination:\n        for chunk in file.chunks():\n            destination.write(chunk)\n\n\ndef get_form_errors(form):\n    \"\"\"\n    Extract all errors from a form eith errors\n    \"\"\"\n    all_errors = []\n    for field in form.errors:\n        all_errors += form.errors[field]\n    return all_errors\n\ndef grant_aws_open_data_access(user, project):\n    \"\"\"\n    Function to grant a AWS ID access to the bukets in the Open Data\n    AWS platform.\n    \"\"\"\n    url = settings.AWS_CLOUD_FORMATION\n    # The payload has to be a string in an array\n    payload = {'accountid': [\"{}\".format(user.cloud_information.aws_id)]}\n    # Custom headers set as a key for a lambda function in AWS to grant access\n    headers = {settings.AWS_HEADER_KEY: settings.AWS_HEADER_VALUE,\n        settings.AWS_HEADER_KEY2: settings.AWS_HEADER_VALUE2}\n    # Do a request to AWS and try to add the user ID to the bucket\n    response = requests.post(url, data=json.dumps(payload), headers=headers)\n    message = response.json()['message'].split(',')[0]\n    # The message can differ if the ID is already there, or non-existent\n    LOGGER.info(\"AWS message '{0}' for project {1}\".format(\n        response.json()['message'], project))\n    return message\n\ndef grant_gcp_group_access(user, project, data_access, request):\n    \"\"\"\n    Add a specific email address to a organizational google group\n    Returns two things:\n        The first argument is if access was awarded.\n        The second argument is if the access was awarded in a previous time.\n    \"\"\"\n    email = user.cloud_information.gcp_email.email\n    service = create_directory_service(settings.GCP_DELEGATION_EMAIL)\n    # Get all the members of the Google group\n    members = service.members().list(groupKey=data_access.location).execute()\n    # Set the type of access depending on the  request\n    # Access == 3 is for the GCP Bucket\n    # Access == 4 is for the GCP Big Query\n    access = \"Access to the GCP BigQuery\"\n    if data_access == 3:\n        access = \"Access to the GCP bucket\"\n    if email not in str(members):\n        # if not a member, add to the group\n        try:\n            outcome = service.members().insert(groupKey=data_access.location, \n                body={\"email\": email, \"delivery_settings\": \"NONE\"}).execute()\n            if outcome['role'] == \"MEMBER\":\n                messages.success(request, '{0} has been granted \\\n                    to {1} for project: {2}'.format(access, email, project))\n                LOGGER.info(\"Added user {0} to BigQuery group {1}\".format(\n                    email, data_access.location))\n                return True\n        except HttpError as e:\n            if json.loads(e.content)['error']['message'] == 'Member already exists.':\n                messages.success(request, '{0} was previously awarded \\\n                    to {1} for project: {2}'.format(access, email, project))\n                return False\n            else:\n                raise e\n        else:\n            messages.success(request, 'There was an error granting \\\n                access.')\n            LOGGER.info(\"Error adding the user {0} to Bigquery group \\\n                {1}. Error: {2}\".format(email, data_access.location, outcome))\n    else:\n        messages.success(request, '{0} was previously awarded \\\n            to {1} for project: {2}'.format(access, email, project))\n        return False\n"}},"msg":"New functions for performing HTTP authentication.\n\nThese functions can be used by a view in order to allow clients to\nauthenticate themselves with a username and password (rather than\nusing the normal Django user authentication system with a session ID\ncookie.)\n\nIn particular, we want to provide a simple, copy-and-pasteable \"wget\"\ncommand that users can run to download one or more files, and that\ncommand should not *itself* include any passwords or authentication\ntokens (rather, the user should be prompted for their password\ninteractively when they run the command.)\n\nFor various reasons, we don't want to allow web browsers to use HTTP\nauthentication, even if the user stumbles upon a URL that allows it:\n\n- most browsers don't present HTTP authentication prompts in a very\n  user-friendly way\n\n- most browsers keep HTTP credentials cached, without showing any\n  indication of the fact, or providing any way for the user to \"log\n  out\" short of closing the browser\n\n- random clients with JavaScript enabled could be hijacked into a\n  distributed brute-force password guessing attack\n\n- older implementations are ambiguous in their handling of non-ASCII\n  passwords, which could lead to confusing authentication failures\n\nIn particular, the risk of browser hijacking is the reason the normal\nDjango login process is so convoluted (requiring multiple cookies,\nhidden form fields, Referer headers...) which makes authentication\npainful for programmatic access.\n\nThus, the http_auth_allowed function permits authentication only for\nwhitelisted user agents (currently wget and libwfdb.)  It's fine to\nadd additional UAs to this list, but before doing so we should verify\nthat:\n\n(a) the UA in question handles passwords (and password-protected data)\n    in a relatively sane and secure manner\n\n(b) the UA doesn't provide a mechanism for untrusted scripts to issue\n    HTTP requests on the user's behalf\n\nFor a view to enable HTTP authentication requires two steps:\n\n- The view must check the provided credentials (to authenticate the\n  user) by calling check_http_auth().\n\n- If the user does not have permission to access the given resource,\n  the view must call require_http_auth() to return a \"401\n  Unauthorized\" response.\n\n(Note that many documents, including the HTTP standards, use the words\n\"authentication\" and \"authorization\" confusingly and often\ninterchangeably.  \"401 Unauthorized\" really means that the user is\nnot *authenticated* - they haven't provided credentials, or the\ncredentials they provided were incorrect.  If the user is known but\ndoesn't have permission to access a resource, they should receive a\n\"403 Forbidden\" response.)"}},"https:\/\/github.com\/dwayne314\/simp-budget":{"3850a94f44faab18b74fd21cee122c6c9b6ce7bc":{"url":"https:\/\/api.github.com\/repos\/dwayne314\/simp-budget\/commits\/3850a94f44faab18b74fd21cee122c6c9b6ce7bc","html_url":"https:\/\/github.com\/dwayne314\/simp-budget\/commit\/3850a94f44faab18b74fd21cee122c6c9b6ce7bc","message":"Add logout app wide logout support\n\nOn the frontend, user logouts have been refactored to a singular logout\naction that correctly sets the state. On the backend, when users logout,\ntheir user session is destroyed so the session cannot be hijacked.","sha":"3850a94f44faab18b74fd21cee122c6c9b6ce7bc","keyword":"session hijacking correct","diff":"diff --git a\/backend\/app\/api\/routes.py b\/backend\/app\/api\/routes.py\nindex fa21472..66544df 100644\n--- a\/backend\/app\/api\/routes.py\n+++ b\/backend\/app\/api\/routes.py\n@@ -82,11 +82,13 @@ def post_token():\n @bp.route('\/tokens', methods=['DELETE'])\n @token_auth.login_required\n @csrf_enforced()\n-@roles_required(['admin'])\n def revoke_token():\n     \"\"\"Deletes the current user's token\"\"\"\n     g.current_user.revoke_token()\n     db.session.commit()\n+\n+    # Clear the session\n+    session.clear()\n     return {'success': True, 'message': 'Token deleted', 'data': {}}, 200\n \n #\ndiff --git a\/frontend\/src\/redux\/actions\/authActions.js b\/frontend\/src\/redux\/actions\/authActions.js\nindex e907da6..d5bbdfa 100644\n--- a\/frontend\/src\/redux\/actions\/authActions.js\n+++ b\/frontend\/src\/redux\/actions\/authActions.js\n@@ -8,7 +8,8 @@ import {\n     set_transactions,\n     setFlashMessages\n } from '.\/'\n-import { isEmpty } from '..\/..\/utilities';\n+import { getCsrfToken } from '..\/selectors';\n+import { isEmpty, generateCsrfHeader } from '..\/..\/utilities';\n \n \/\/ \n \/\/ Login Actions \n@@ -47,8 +48,7 @@ export const getToken = () => (dispatch, getState) => {\n         })\n         .catch(err => {\n             \/\/ Logs the user out and clears transactions \n-            dispatch(login({}));\n-            dispatch(set_transactions([]));\n+            dispatch(logout());\n             return {success: false, error: 'Authentication error: Please login in'};\n         })\n }\n@@ -71,8 +71,7 @@ export const postLogin = authParams => (dispatch, getState) => {\n         })\n         .catch(err => {\n             \/\/ Logs the user out and clears transactions             \n-            dispatch(login({}));\n-            dispatch(set_transactions([]));\n+            dispatch(logout());\n             return {success: false, error: 'Authentication error: Invalid email\/password'};\n         })\n };\n@@ -81,11 +80,16 @@ export const postLogin = authParams => (dispatch, getState) => {\n \/\/ Logout Actions\n \/\/ \n \n-export const logout = () => dispatch => {\n-    dispatch(login({}));\n-    dispatch(set_transactions([]));\n-    dispatch(set_accounts([]));\n-    dispatch(setFlashMessages([]));\n+export const logout = () => (dispatch, getState) => {\n+    return axios\n+        .delete('\/tokens', generateCsrfHeader(getCsrfToken(getState())))\n+        .then(response => {\n+            dispatch(login({}));\n+            dispatch(set_transactions([]));\n+            dispatch(set_accounts([]));\n+            dispatch(setFlashMessages([]));\n+        })\n+        .catch(err => console.log('error'))\n };\n \n \/\/ \n@@ -98,7 +102,7 @@ export const postRegister = userData => dispatch => {\n     return axios\n         .post('\/users', userData)\n         .then(response => {\n-            dispatch(login({}));\n+            dispatch(logout());\n             return {success: true};\n         })\n         .catch(err => {\ndiff --git a\/frontend\/src\/utilities\/helpers.js b\/frontend\/src\/utilities\/helpers.js\ndeleted file mode 100644\nindex 90ce63c..0000000\n--- a\/frontend\/src\/utilities\/helpers.js\n+++ \/dev\/null\n@@ -1 +0,0 @@\n-export const isEmpty = (obj) => Object.keys(obj).length === 0;\n","files":{"\/backend\/app\/api\/routes.py":{"changes":[{"diff":"\n @bp.route('\/tokens', methods=['DELETE'])\n @token_auth.login_required\n @csrf_enforced()\n-@roles_required(['admin'])\n def revoke_token():\n     \"\"\"Deletes the current user's token\"\"\"\n     g.current_user.revoke_token()\n     db.session.commit()\n+\n+    # Clear the session\n+    session.clear()\n     return {'success': True, 'message': 'Token deleted', 'data': {}}, 200\n \n #","add":3,"remove":1,"filename":"\/backend\/app\/api\/routes.py","badparts":["@roles_required(['admin'])"],"goodparts":["    session.clear()"]}],"source":"\n\"\"\"This module contains all of the api routes\"\"\" from flask import current_app, request, abort, jsonify, g, make_response, session from app import db from app.api import bp from app.models import Users, Accounts, Transactions from app.utilities.helpers import create_token from app.utilities.decorators import(err_if_not_found, roles_required, enforce_owner_by_id, add_child_result, csrf_enforced) from app.api.validators import(UserValidator, AccountValidator, TransationValidator) from app.api.auth import basic_auth, token_auth @bp.route('\/', methods=['GET']) def index(): \"\"\"The api index route\"\"\" return dict(version=1.0, app_name=current_app.config['APP_NAME']) @bp.route('\/tokens', methods=['GET']) @token_auth.login_required def get_token(): \"\"\"Retrieves the auth token for a user authenticated with bearer auth The auth token is also attached to the response as a cookie with an auth_token key. \"\"\" csrf_token=create_token() auth_token=g.current_user.get_token() db.session.commit() resp=make_response( jsonify({ 'token': auth_token, 'user': Users.serialize_one(g.current_user.id) })) resp.set_cookie('auth_token', auth_token, httponly=True, secure=current_app.config['SESSION_COOKIE_SECURE']) resp.set_cookie('csrf_token', csrf_token, httponly=False, secure=current_app.config['SESSION_COOKIE_SECURE']) session['csrf_token']=csrf_token return resp @bp.route('\/tokens', methods=['POST']) @basic_auth.login_required def post_token(): \"\"\"Retrieves auth and csrf tokens for a user authenticated with basic auth The auth token is also attached to the response as a cookie with an auth_token key. \"\"\" csrf_token=create_token() auth_token=g.current_user.get_token() db.session.commit() resp=make_response( jsonify({ 'token': auth_token, 'user': Users.serialize_one(g.current_user.id) })) resp.set_cookie('auth_token', auth_token, httponly=True, secure=current_app.config['SESSION_COOKIE_SECURE']) resp.set_cookie('csrf_token', csrf_token, httponly=False, secure=current_app.config['SESSION_COOKIE_SECURE']) session['csrf_token']=csrf_token return resp @bp.route('\/tokens', methods=['DELETE']) @token_auth.login_required @csrf_enforced() @roles_required(['admin']) def revoke_token(): \"\"\"Deletes the current user's token\"\"\" g.current_user.revoke_token() db.session.commit() return{'success': True, 'message': 'Token deleted', 'data':{}}, 200 @bp.route('\/users', methods=['GET']) @token_auth.login_required @roles_required(['admin']) def get_users(): \"\"\"Gets all users\"\"\" users=Users.serialize_all() message='Data found' if users else 'Data not found' return{'success': True, 'message': message, 'data': users}, 200 @bp.route('\/users', methods=['POST']) def post_users(): \"\"\"Creates a user\"\"\" validator=UserValidator(**request.get_json()) validate_results=validator.validate_create_user() if validate_results['isValid']: password=validate_results['result'].pop('password') new_user=Users(**validate_results['result']) new_user.hash_password(password) db.session.add(new_user) db.session.commit() serialized_user=Users.serialize_one(new_user.id) return{'success': True, 'message': 'User created', 'data': serialized_user}, 201 return abort(400, validate_results[\"errors\"]) @bp.route('\/users\/<int:user_id>', methods=['GET']) @token_auth.login_required @err_if_not_found(Users, 'user_id') @enforce_owner_by_id('user_id',['admin']) def get_user(user_id): \"\"\"Gets a user by id\"\"\" user=Users.serialize_one(user_id) return{'success': True, 'message': 'User found', 'data': user}, 200 @bp.route('\/users\/<int:user_id>', methods=['PATCH']) @token_auth.login_required @csrf_enforced() @err_if_not_found(Users, 'user_id') @enforce_owner_by_id('user_id',['admin']) def patch_user(user_id): \"\"\"Patches a user by id\"\"\" user=Users.query.get(user_id) validator=UserValidator({'email': user.email}, **request.get_json()) validate_results=validator.validate_patch_user() if validate_results['isValid']: for key, val in validate_results['result'].items(): setattr(user, key, val) db.session.commit() serialized_user=Users.serialize_one(user_id) return{'success': True, 'message': 'User updated', 'data': serialized_user}, 200 return abort(400, validate_results[\"errors\"]) @bp.route('\/users\/<int:user_id>', methods=['DELETE']) @token_auth.login_required @csrf_enforced() @err_if_not_found(Users, 'user_id') @enforce_owner_by_id('user_id',['admin']) def delete_user(user_id): \"\"\"Deletes a user by id\"\"\" user=Users.query.get(user_id) db.session.delete(user) db.session.commit() return{'success': True, 'message': 'User deleted', 'data':{}}, 200 @bp.route('\/users\/<int:user_id>\/accounts', methods=['GET']) @token_auth.login_required @err_if_not_found(Users, 'user_id') @enforce_owner_by_id('user_id',['admin']) def get_accounts(user_id): \"\"\"Gets all accounts\"\"\" user=Users.query.get(user_id) accounts=[Accounts.serialize_one(acct.id) for acct in user.accounts.all()] message='Data found' if accounts else 'Data not found' return{'success': True, 'message': message, 'data': accounts}, 200 @bp.route('\/users\/<int:user_id>\/accounts', methods=['POST']) @token_auth.login_required @csrf_enforced() @enforce_owner_by_id('user_id',['admin']) def post_accounts(user_id): \"\"\"Creates an account\"\"\" validator=AccountValidator(**request.get_json()) validate_results=validator.validate_create_account() if validate_results['isValid']: new_account=Accounts(**validate_results['result']) setattr(new_account, 'user_id', user_id) db.session.add(new_account) db.session.commit() serialized_account=Accounts.serialize_one(new_account.id) return{'success': True, 'message': 'Account created', 'data': serialized_account}, 201 return abort(400, validate_results[\"errors\"]) @bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>', methods=['GET']) @token_auth.login_required @enforce_owner_by_id('user_id',['admin']) @add_child_result('user_id', 'account_id') def get_account(user_id, account_id, result): \"\"\"Gets an account by id\"\"\" account=Accounts.serialize_one(result.id) return{'success': True, 'message': 'Account found', 'data': account}, 200 @bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>', methods=['PATCH']) @token_auth.login_required @csrf_enforced() @enforce_owner_by_id('user_id',['admin']) @add_child_result('user_id', 'account_id') def patch_account(user_id, account_id, result): \"\"\"Patches an account by id\"\"\" validator=AccountValidator(**request.get_json()) validate_results=validator.validate_patch_account() if validate_results['isValid']: for key, val in validate_results['result'].items(): setattr(result, key, val) db.session.commit() serialized_account=Accounts.serialize_one(account_id) return{'success': True, 'message': 'Account updated', 'data': serialized_account}, 200 return abort(400, validate_results[\"errors\"]) @bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>', methods=['DELETE']) @token_auth.login_required @csrf_enforced() @enforce_owner_by_id('user_id',['admin']) @add_child_result('user_id', 'account_id') def delete_account(user_id, account_id, result): \"\"\"Deletes an account by id\"\"\" account=Accounts.query.get(result.id) db.session.delete(account) db.session.commit() return{'success': True, 'message': 'Account deleted', 'data':{}}, 200 @bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>\/transactions', methods=['GET']) @token_auth.login_required @enforce_owner_by_id('user_id',['admin']) @err_if_not_found(Accounts, 'account_id') @add_child_result('user_id', 'account_id') def get_transactions(user_id, account_id, result): \"\"\"Gets all transactions for an account\"\"\" transactions=[Transactions.serialize_one(tran.id) for tran in result.transactions.all()] message='Data found' if transactions else 'Data not found' return{'success': True, 'message': message, 'data': transactions}, 200 @bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>\/transactions', methods=['POST']) @token_auth.login_required @csrf_enforced() @enforce_owner_by_id('user_id',['admin']) @add_child_result('user_id', 'account_id') def post_transactions(user_id, account_id, result): \"\"\"Creates a transaction for an account\"\"\" validator=TransationValidator(**request.get_json()) validate_results=validator.validate_create_transaction() if validate_results['isValid']: validate_results['result']['account_id']=result.id new_transaction=Transactions(**validate_results['result']) db.session.add(new_transaction) db.session.commit() serialized_transaction=Transactions.serialize_one(new_transaction.id) return{'success': True, 'message': 'Transaction created', 'data': serialized_transaction}, 201 return abort(400, validate_results[\"errors\"]) @bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>\/transactions' '\/<int:transaction_id>', methods=['GET']) @token_auth.login_required @enforce_owner_by_id('user_id',['admin']) @add_child_result('account_id', 'transaction_id') def get_transaction(user_id, account_id, transaction_id, result): \"\"\"Gets a transaction from an account by id\"\"\" account=Accounts.query.get_or_404(account_id) if user_id==account.user_id: serialized_transaction=result.serialize_one(result.id) return{'success': True, 'message': 'Transaction found', 'data': serialized_transaction}, 200 return abort(404) @bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>\/transactions' '\/<int:transaction_id>', methods=['PATCH']) @token_auth.login_required @csrf_enforced() @enforce_owner_by_id('user_id',['admin']) @add_child_result('account_id', 'transaction_id') def patch_transaction(user_id, account_id, transaction_id, result): \"\"\"Patches a transaction from an account by id\"\"\" account=Accounts.query.get_or_404(account_id) if user_id==account.user_id: validator=TransationValidator(**request.get_json()) validate_results=validator.validate_patch_transaction() if validate_results['isValid']: for key, val in validate_results['result'].items(): setattr(result, key, val) db.session.commit() serialized_transaction=Transactions.serialize_one( transaction_id) return{'success': True, 'message': 'Account updated', 'data': serialized_transaction}, 200 return abort(400, validate_results[\"errors\"]) return abort(404) @bp.route('users\/<int:user_id>\/accounts\/<int:account_id>\/transactions' '\/<int:transaction_id>', methods=['DELETE']) @token_auth.login_required @csrf_enforced() @enforce_owner_by_id('user_id',['admin']) @add_child_result('account_id', 'transaction_id') def delete_transaction(user_id, account_id, transaction_id, result): \"\"\"Api router for a single account transaction resource\"\"\" db.session.delete(result) db.session.commit() message=f'Transaction deleted' return{'success': True, 'message': message, 'data':{}}, 200 ","sourceWithComments":"\"\"\"This module contains all of the api routes\"\"\"\n\nfrom flask import current_app, request, abort, jsonify, g, make_response, session\nfrom app import db\nfrom app.api import bp\nfrom app.models import Users, Accounts, Transactions\nfrom app.utilities.helpers import create_token\nfrom app.utilities.decorators import (err_if_not_found, roles_required,\n                                      enforce_owner_by_id, add_child_result,\n                                      csrf_enforced)\nfrom app.api.validators import (UserValidator, AccountValidator,\n                                TransationValidator)\nfrom app.api.auth import basic_auth, token_auth\n\n\n@bp.route('\/', methods=['GET'])\ndef index():\n    \"\"\"The api index route\"\"\"\n    return dict(version=1.0, app_name=current_app.config['APP_NAME'])\n\n#\n# Token Routes\n#\n\n@bp.route('\/tokens', methods=['GET'])\n@token_auth.login_required\ndef get_token():\n    \"\"\"Retrieves the auth token for a user authenticated with bearer auth\n\n    The auth token is also attached to the response as a cookie with an\n    auth_token key.\n\n    \"\"\"\n\n    csrf_token = create_token()\n    auth_token = g.current_user.get_token()\n    db.session.commit()\n    # Generate CSRF token and attach to another cookie\n    resp = make_response(\n        jsonify({\n            'token': auth_token,\n            'user': Users.serialize_one(g.current_user.id)\n        }))\n    resp.set_cookie('auth_token', auth_token, httponly=True,\n                    secure=current_app.config['SESSION_COOKIE_SECURE'])\n\n    resp.set_cookie('csrf_token', csrf_token, httponly=False,\n                    secure=current_app.config['SESSION_COOKIE_SECURE'])\n\n    # Sets the csrf token for the session\n    session['csrf_token'] = csrf_token\n    return resp\n\n@bp.route('\/tokens', methods=['POST'])\n@basic_auth.login_required\ndef post_token():\n    \"\"\"Retrieves auth and csrf tokens for a user authenticated with basic auth\n\n    The auth token is also attached to the response as a cookie with an\n    auth_token key.\n\n    \"\"\"\n\n    csrf_token = create_token()\n    auth_token = g.current_user.get_token()\n    db.session.commit()\n    resp = make_response(\n        jsonify({\n            'token': auth_token,\n            'user': Users.serialize_one(g.current_user.id)\n        }))\n    resp.set_cookie('auth_token', auth_token, httponly=True,\n                    secure=current_app.config['SESSION_COOKIE_SECURE'])\n\n    resp.set_cookie('csrf_token', csrf_token, httponly=False,\n                    secure=current_app.config['SESSION_COOKIE_SECURE'])\n\n    # Sets the csrf token for the session\n    session['csrf_token'] = csrf_token\n    return resp\n\n@bp.route('\/tokens', methods=['DELETE'])\n@token_auth.login_required\n@csrf_enforced()\n@roles_required(['admin'])\ndef revoke_token():\n    \"\"\"Deletes the current user's token\"\"\"\n    g.current_user.revoke_token()\n    db.session.commit()\n    return {'success': True, 'message': 'Token deleted', 'data': {}}, 200\n\n#\n# User Routes\n#\n\n@bp.route('\/users', methods=['GET'])\n@token_auth.login_required\n@roles_required(['admin'])\ndef get_users():\n    \"\"\"Gets all users\"\"\"\n    users = Users.serialize_all()\n    message = 'Data found' if users else 'Data not found'\n    return {'success': True, 'message': message, 'data': users}, 200\n\n@bp.route('\/users', methods=['POST'])\ndef post_users():\n    \"\"\"Creates a user\"\"\"\n    validator = UserValidator(**request.get_json())\n    validate_results = validator.validate_create_user()\n    if validate_results['isValid']:\n        password = validate_results['result'].pop('password')\n        new_user = Users(**validate_results['result'])\n        new_user.hash_password(password)\n\n        db.session.add(new_user)\n        db.session.commit()\n        serialized_user = Users.serialize_one(new_user.id)\n        return {'success': True,\n                'message': 'User created',\n                'data': serialized_user}, 201\n    return abort(400, validate_results[\"errors\"])\n\n@bp.route('\/users\/<int:user_id>', methods=['GET'])\n@token_auth.login_required\n@err_if_not_found(Users, 'user_id')\n@enforce_owner_by_id('user_id', ['admin'])\ndef get_user(user_id):\n    \"\"\"Gets a user by id\"\"\"\n    user = Users.serialize_one(user_id)\n    return {'success': True, 'message': 'User found', 'data': user}, 200\n\n@bp.route('\/users\/<int:user_id>', methods=['PATCH'])\n@token_auth.login_required\n@csrf_enforced()\n@err_if_not_found(Users, 'user_id')\n@enforce_owner_by_id('user_id', ['admin'])\ndef patch_user(user_id):\n    \"\"\"Patches a user by id\"\"\"\n    user = Users.query.get(user_id)\n    validator = UserValidator({'email': user.email}, **request.get_json())\n    validate_results = validator.validate_patch_user()\n    if validate_results['isValid']:\n        for key, val in validate_results['result'].items():\n            setattr(user, key, val)\n        db.session.commit()\n\n        # Pull updated user data\n        serialized_user = Users.serialize_one(user_id)\n        return {'success': True,\n                'message': 'User updated',\n                'data': serialized_user}, 200\n\n    return abort(400, validate_results[\"errors\"])\n\n@bp.route('\/users\/<int:user_id>', methods=['DELETE'])\n@token_auth.login_required\n@csrf_enforced()\n@err_if_not_found(Users, 'user_id')\n@enforce_owner_by_id('user_id', ['admin'])\ndef delete_user(user_id):\n    \"\"\"Deletes a user by id\"\"\"\n    user = Users.query.get(user_id)\n    db.session.delete(user)\n    db.session.commit()\n    return {'success': True, 'message': 'User deleted', 'data': {}}, 200\n\n#\n# Account Routes\n#\n\n@bp.route('\/users\/<int:user_id>\/accounts', methods=['GET'])\n@token_auth.login_required\n@err_if_not_found(Users, 'user_id')\n@enforce_owner_by_id('user_id', ['admin'])\ndef get_accounts(user_id):\n    \"\"\"Gets all accounts\"\"\"\n    user = Users.query.get(user_id)\n    accounts = [Accounts.serialize_one(acct.id) for acct\n                in user.accounts.all()]\n    message = 'Data found' if accounts else 'Data not found'\n    return {'success': True, 'message': message, 'data': accounts}, 200\n\n@bp.route('\/users\/<int:user_id>\/accounts', methods=['POST'])\n@token_auth.login_required\n@csrf_enforced()\n@enforce_owner_by_id('user_id', ['admin'])\ndef post_accounts(user_id):\n    \"\"\"Creates an account\"\"\"\n    validator = AccountValidator(**request.get_json())\n    validate_results = validator.validate_create_account()\n    if validate_results['isValid']:\n        new_account = Accounts(**validate_results['result'])\n        setattr(new_account, 'user_id', user_id)\n        db.session.add(new_account)\n\n        db.session.commit()\n        serialized_account = Accounts.serialize_one(new_account.id)\n        return {'success': True,\n                'message': 'Account created',\n                'data': serialized_account}, 201\n    return abort(400, validate_results[\"errors\"])\n\n@bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>', methods=['GET'])\n@token_auth.login_required\n@enforce_owner_by_id('user_id', ['admin'])\n@add_child_result('user_id', 'account_id')\ndef get_account(user_id, account_id, result):\n    \"\"\"Gets an account by id\"\"\"\n    account = Accounts.serialize_one(result.id)\n    return {'success': True, 'message': 'Account found', 'data': account}, 200\n\n@bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>', methods=['PATCH'])\n@token_auth.login_required\n@csrf_enforced()\n@enforce_owner_by_id('user_id', ['admin'])\n@add_child_result('user_id', 'account_id')\ndef patch_account(user_id, account_id, result):\n    \"\"\"Patches an account by id\"\"\"\n    validator = AccountValidator(**request.get_json())\n    validate_results = validator.validate_patch_account()\n    if validate_results['isValid']:\n        for key, val in validate_results['result'].items():\n            setattr(result, key, val)\n        db.session.commit()\n\n        # Pull updated account data\n        serialized_account = Accounts.serialize_one(account_id)\n        return {'success': True,\n                'message': 'Account updated',\n                'data': serialized_account}, 200\n\n    return abort(400, validate_results[\"errors\"])\n\n@bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>', methods=['DELETE'])\n@token_auth.login_required\n@csrf_enforced()\n@enforce_owner_by_id('user_id', ['admin'])\n@add_child_result('user_id', 'account_id')\ndef delete_account(user_id, account_id, result):\n    \"\"\"Deletes an account by id\"\"\"\n    account = Accounts.query.get(result.id)\n    db.session.delete(account)\n    db.session.commit()\n    return {'success': True, 'message': 'Account deleted', 'data': {}}, 200\n\n#\n# Transaction Routes\n#\n\n@bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>\/transactions',\n          methods=['GET'])\n@token_auth.login_required\n@enforce_owner_by_id('user_id', ['admin'])\n@err_if_not_found(Accounts, 'account_id')\n@add_child_result('user_id', 'account_id')\ndef get_transactions(user_id, account_id, result):\n    \"\"\"Gets all transactions for an account\"\"\"\n    transactions = [Transactions.serialize_one(tran.id) for tran\n                    in result.transactions.all()]\n    message = 'Data found' if transactions else 'Data not found'\n    return {'success': True,\n            'message': message,\n            'data': transactions}, 200\n\n@bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>\/transactions',\n          methods=['POST'])\n@token_auth.login_required\n@csrf_enforced()\n@enforce_owner_by_id('user_id', ['admin'])\n@add_child_result('user_id', 'account_id')\ndef post_transactions(user_id, account_id, result):\n    \"\"\"Creates a transaction for an account\"\"\"\n    validator = TransationValidator(**request.get_json())\n    validate_results = validator.validate_create_transaction()\n\n    if validate_results['isValid']:\n        validate_results['result']['account_id'] = result.id\n        new_transaction = Transactions(**validate_results['result'])\n        db.session.add(new_transaction)\n        db.session.commit()\n        serialized_transaction = Transactions.serialize_one(new_transaction.id)\n        return {'success': True,\n                'message': 'Transaction created',\n                'data': serialized_transaction}, 201\n    return abort(400, validate_results[\"errors\"])\n\n@bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>\/transactions'\n          '\/<int:transaction_id>', methods=['GET'])\n@token_auth.login_required\n@enforce_owner_by_id('user_id', ['admin'])\n@add_child_result('account_id', 'transaction_id')\ndef get_transaction(user_id, account_id, transaction_id, result):\n    \"\"\"Gets a transaction from an account by id\"\"\"\n    account = Accounts.query.get_or_404(account_id)\n    if user_id == account.user_id:\n        serialized_transaction = result.serialize_one(result.id)\n        return {'success': True,\n                'message': 'Transaction found',\n                'data': serialized_transaction}, 200\n    return abort(404)\n\n@bp.route('\/users\/<int:user_id>\/accounts\/<int:account_id>\/transactions'\n          '\/<int:transaction_id>', methods=['PATCH'])\n@token_auth.login_required\n@csrf_enforced()\n@enforce_owner_by_id('user_id', ['admin'])\n@add_child_result('account_id', 'transaction_id')\ndef patch_transaction(user_id, account_id, transaction_id, result):\n    \"\"\"Patches a transaction from an account by id\"\"\"\n    account = Accounts.query.get_or_404(account_id)\n    if user_id == account.user_id:\n        validator = TransationValidator(**request.get_json())\n        validate_results = validator.validate_patch_transaction()\n\n        if validate_results['isValid']:\n            for key, val in validate_results['result'].items():\n                setattr(result, key, val)\n            db.session.commit()\n            serialized_transaction = Transactions.serialize_one(\n                transaction_id)\n            return {'success': True,\n                    'message': 'Account updated',\n                    'data': serialized_transaction}, 200\n\n        return abort(400, validate_results[\"errors\"])\n    return abort(404)\n\n@bp.route('users\/<int:user_id>\/accounts\/<int:account_id>\/transactions'\n          '\/<int:transaction_id>', methods=['DELETE'])\n@token_auth.login_required\n@csrf_enforced()\n@enforce_owner_by_id('user_id', ['admin'])\n@add_child_result('account_id', 'transaction_id')\ndef delete_transaction(user_id, account_id, transaction_id, result):\n    \"\"\"Api router for a single account transaction resource\"\"\"\n    db.session.delete(result)\n    db.session.commit()\n    message = f'Transaction deleted'\n    return {'success': True, 'message': message, 'data': {}}, 200\n"}},"msg":"Add logout app wide logout support\n\nOn the frontend, user logouts have been refactored to a singular logout\naction that correctly sets the state. On the backend, when users logout,\ntheir user session is destroyed so the session cannot be hijacked."}},"https:\/\/github.com\/DataDog\/datadogpy":{"e112ec1c6fc452ac38e44d4f2adaf72dc3bdb501":{"url":"https:\/\/api.github.com\/repos\/DataDog\/datadogpy\/commits\/e112ec1c6fc452ac38e44d4f2adaf72dc3bdb501","html_url":"https:\/\/github.com\/DataDog\/datadogpy\/commit\/e112ec1c6fc452ac38e44d4f2adaf72dc3bdb501","message":"update requests library, per CVE-2015-2296\n\nVersions prior to 2.6.0 are vulnerable to a specific session hijack\nattack. While we do not use cookies when interacting with the Datadog\nAPI, it is good practice to keep up with security patches like this.\n\nMore info: http:\/\/www.openwall.com\/lists\/oss-security\/2015\/03\/14\/4","sha":"e112ec1c6fc452ac38e44d4f2adaf72dc3bdb501","keyword":"session hijacking update","diff":"diff --git a\/setup.py b\/setup.py\nindex c9214fb27..5997155e7 100644\n--- a\/setup.py\n+++ b\/setup.py\n@@ -3,7 +3,7 @@\n \n install_reqs = [\n     \"decorator>=3.3.2\",\n-    \"requests>=0.8.8\",\n+    \"requests>=2.6.0\",\n ]\n if sys.version_info[0] == 2:\n     # simplejson is not python3 compatible\n","files":{"\/setup.py":{"changes":[{"diff":"\n \n install_reqs = [\n     \"decorator>=3.3.2\",\n-    \"requests>=0.8.8\",\n+    \"requests>=2.6.0\",\n ]\n if sys.version_info[0] == 2:\n     # simplejson is not python3 compatible\n","add":1,"remove":1,"filename":"\/setup.py","badparts":["    \"requests>=0.8.8\","],"goodparts":["    \"requests>=2.6.0\","]}],"source":"\nfrom setuptools import setup import sys install_reqs=[ \"decorator>=3.3.2\", \"requests>=0.8.8\", ] if sys.version_info[0]==2: install_reqs.append(\"simplejson>=2.0.9\") if[sys.version_info[0], sys.version_info[1]] <[2, 7]: install_reqs.append(\"argparse>=1.2\") setup( name=\"datadog\", version=\"0.3.0\", install_requires=install_reqs, tests_require=[\"tox\", \"nose\", \"mock\", \"six\", \"pillow\"], packages=[ 'datadog', 'datadog.api', 'datadog.dogstatsd', 'datadog.threadstats', 'datadog.util', 'datadog.dogshell' ], author=\"Datadog, Inc.\", author_email=\"dev@datadoghq.com\", description=\"The Datadog Python library\", license=\"BSD\", keywords=\"datadog data\", url=\"http:\/\/www.datadoghq.com\", entry_points={ 'console_scripts':[ 'dog=datadog.dogshell:main', 'dogwrap=datadog.dogshell.wrap:main', ], }, test_suite=\"nose.collector\" ) ","sourceWithComments":"from setuptools import setup\nimport sys\n\ninstall_reqs = [\n    \"decorator>=3.3.2\",\n    \"requests>=0.8.8\",\n]\nif sys.version_info[0] == 2:\n    # simplejson is not python3 compatible\n    install_reqs.append(\"simplejson>=2.0.9\")\n\nif [sys.version_info[0], sys.version_info[1]] < [2, 7]:\n    install_reqs.append(\"argparse>=1.2\")\n\nsetup(\n    name=\"datadog\",\n    version=\"0.3.0\",\n    install_requires=install_reqs,\n    tests_require=[\"tox\", \"nose\", \"mock\", \"six\", \"pillow\"],\n    packages=[\n        'datadog',\n        'datadog.api',\n        'datadog.dogstatsd',\n        'datadog.threadstats',\n        'datadog.util',\n        'datadog.dogshell'\n    ],\n    author=\"Datadog, Inc.\",\n    author_email=\"dev@datadoghq.com\",\n    description=\"The Datadog Python library\",\n    license=\"BSD\",\n    keywords=\"datadog data\",\n    url=\"http:\/\/www.datadoghq.com\",\n    entry_points={\n        'console_scripts': [\n            'dog = datadog.dogshell:main',\n            'dogwrap = datadog.dogshell.wrap:main',\n        ],\n    },\n    test_suite=\"nose.collector\"\n)\n"}},"msg":"update requests library, per CVE-2015-2296\n\nVersions prior to 2.6.0 are vulnerable to a specific session hijack\nattack. While we do not use cookies when interacting with the Datadog\nAPI, it is good practice to keep up with security patches like this.\n\nMore info: http:\/\/www.openwall.com\/lists\/oss-security\/2015\/03\/14\/4"}},"https:\/\/github.com\/uniphore\/kai-datadogpy":{"e112ec1c6fc452ac38e44d4f2adaf72dc3bdb501":{"url":"https:\/\/api.github.com\/repos\/uniphore\/kai-datadogpy\/commits\/e112ec1c6fc452ac38e44d4f2adaf72dc3bdb501","html_url":"https:\/\/github.com\/uniphore\/kai-datadogpy\/commit\/e112ec1c6fc452ac38e44d4f2adaf72dc3bdb501","message":"update requests library, per CVE-2015-2296\n\nVersions prior to 2.6.0 are vulnerable to a specific session hijack\nattack. While we do not use cookies when interacting with the Datadog\nAPI, it is good practice to keep up with security patches like this.\n\nMore info: http:\/\/www.openwall.com\/lists\/oss-security\/2015\/03\/14\/4","sha":"e112ec1c6fc452ac38e44d4f2adaf72dc3bdb501","keyword":"session hijacking update","diff":"diff --git a\/setup.py b\/setup.py\nindex c9214fb..5997155 100644\n--- a\/setup.py\n+++ b\/setup.py\n@@ -3,7 +3,7 @@\n \n install_reqs = [\n     \"decorator>=3.3.2\",\n-    \"requests>=0.8.8\",\n+    \"requests>=2.6.0\",\n ]\n if sys.version_info[0] == 2:\n     # simplejson is not python3 compatible\n","files":{"\/setup.py":{"changes":[{"diff":"\n \n install_reqs = [\n     \"decorator>=3.3.2\",\n-    \"requests>=0.8.8\",\n+    \"requests>=2.6.0\",\n ]\n if sys.version_info[0] == 2:\n     # simplejson is not python3 compatible\n","add":1,"remove":1,"filename":"\/setup.py","badparts":["    \"requests>=0.8.8\","],"goodparts":["    \"requests>=2.6.0\","]}],"source":"\nfrom setuptools import setup import sys install_reqs=[ \"decorator>=3.3.2\", \"requests>=0.8.8\", ] if sys.version_info[0]==2: install_reqs.append(\"simplejson>=2.0.9\") if[sys.version_info[0], sys.version_info[1]] <[2, 7]: install_reqs.append(\"argparse>=1.2\") setup( name=\"datadog\", version=\"0.3.0\", install_requires=install_reqs, tests_require=[\"tox\", \"nose\", \"mock\", \"six\", \"pillow\"], packages=[ 'datadog', 'datadog.api', 'datadog.dogstatsd', 'datadog.threadstats', 'datadog.util', 'datadog.dogshell' ], author=\"Datadog, Inc.\", author_email=\"dev@datadoghq.com\", description=\"The Datadog Python library\", license=\"BSD\", keywords=\"datadog data\", url=\"http:\/\/www.datadoghq.com\", entry_points={ 'console_scripts':[ 'dog=datadog.dogshell:main', 'dogwrap=datadog.dogshell.wrap:main', ], }, test_suite=\"nose.collector\" ) ","sourceWithComments":"from setuptools import setup\nimport sys\n\ninstall_reqs = [\n    \"decorator>=3.3.2\",\n    \"requests>=0.8.8\",\n]\nif sys.version_info[0] == 2:\n    # simplejson is not python3 compatible\n    install_reqs.append(\"simplejson>=2.0.9\")\n\nif [sys.version_info[0], sys.version_info[1]] < [2, 7]:\n    install_reqs.append(\"argparse>=1.2\")\n\nsetup(\n    name=\"datadog\",\n    version=\"0.3.0\",\n    install_requires=install_reqs,\n    tests_require=[\"tox\", \"nose\", \"mock\", \"six\", \"pillow\"],\n    packages=[\n        'datadog',\n        'datadog.api',\n        'datadog.dogstatsd',\n        'datadog.threadstats',\n        'datadog.util',\n        'datadog.dogshell'\n    ],\n    author=\"Datadog, Inc.\",\n    author_email=\"dev@datadoghq.com\",\n    description=\"The Datadog Python library\",\n    license=\"BSD\",\n    keywords=\"datadog data\",\n    url=\"http:\/\/www.datadoghq.com\",\n    entry_points={\n        'console_scripts': [\n            'dog = datadog.dogshell:main',\n            'dogwrap = datadog.dogshell.wrap:main',\n        ],\n    },\n    test_suite=\"nose.collector\"\n)\n"}},"msg":"update requests library, per CVE-2015-2296\n\nVersions prior to 2.6.0 are vulnerable to a specific session hijack\nattack. While we do not use cookies when interacting with the Datadog\nAPI, it is good practice to keep up with security patches like this.\n\nMore info: http:\/\/www.openwall.com\/lists\/oss-security\/2015\/03\/14\/4"}},"https:\/\/github.com\/circuits\/circuits":{"ed3fc320e452940f918756f88c2b5ffdab8c3899":{"url":"https:\/\/api.github.com\/repos\/circuits\/circuits\/commits\/ed3fc320e452940f918756f88c2b5ffdab8c3899","html_url":"https:\/\/github.com\/circuits\/circuits\/commit\/ed3fc320e452940f918756f88c2b5ffdab8c3899","message":"Improved in-memory Sessions circuis.web Component to be easier to override as well as prevent Session hijacking","sha":"ed3fc320e452940f918756f88c2b5ffdab8c3899","keyword":"session hijacking improve","diff":"diff --git a\/circuits\/web\/sessions.py b\/circuits\/web\/sessions.py\nindex 544b41b5d..a1a2ebb4a 100644\n--- a\/circuits\/web\/sessions.py\n+++ b\/circuits\/web\/sessions.py\n@@ -2,41 +2,84 @@\n # Date:     22nd February 2009\n # Author:   James Mills, prologic at shortcircuit dot net dot au\n \n+\n \"\"\"Session Components\n \n This module implements Session Components that can be used to store\n and access persistent information.\n \"\"\"\n \n+\n from uuid import uuid4 as uuid\n+from hashlib import sha1 as sha\n from collections import defaultdict\n \n+\n from circuits import handler, Component\n \n \n+def who(request):\n+    \"\"\"Create a SHA1 Hash of the User's IP Address and User-Agent\"\"\"\n+\n+    ip = request.remote.ip\n+    agent = request.headers.get(\"User-Agent\", \"\")\n+\n+    return sha(\"{0:s}{1:s}\".format(ip, agent)).hexdigest()\n+\n+\n+def create_session(request):\n+    \"\"\"Create a unique session id from the request\n+\n+    Returns a unique session using ``uuid4()`` and a ``sha1()`` hash\n+    of the users IP Address and User Agent in the form of ``sid\/who``.\n+    \"\"\"\n+\n+    return \"{0:s}\/{1:s}\".format(uuid().hex, who(request))\n+\n+\n+def verify_session(request, sid):\n+    \"\"\"Verify a User's Session\n+\n+    This verifies the User's Session by verifying the SHA1 Hash\n+    of the User's IP Address and User-Agent match the provided\n+    Session ID.\n+    \"\"\"\n+\n+    if \"\/\" not in sid:\n+        return create_session(request)\n+\n+    user = sid.split(\"\/\", 1)[1]\n+\n+    if user != who(request):\n+        return create_session(request)\n+\n+    return sid\n+\n+\n class Sessions(Component):\n \n     channel = \"web\"\n \n-    def __init__(self, name=\"circuits.session\", *args, **kwargs):\n-        super(Sessions, self).__init__(*args, **kwargs)\n+    def __init__(self, name=\"circuits.session\", channel=channel):\n+        super(Sessions, self).__init__(channel=channel)\n \n         self._name = name\n         self._data = defaultdict(dict)\n \n-    def _load(self, id):\n-        return self._data[id]\n+    def load(self, sid):\n+        return self._data[sid]\n \n-    def _save(self, id, data):\n-        self._data[id] = data\n+    def save(self, sid, data):\n+        \"\"\"Save User Session Data for sid\"\"\"\n \n     @handler(\"request\", priority=10)\n     def request(self, request, response):\n         if self._name in request.cookie:\n-            id = request.cookie[self._name].value\n+            sid = request.cookie[self._name].value\n+            sid = verify_session(request, sid)\n         else:\n-            id = str(uuid())\n+            sid = create_session(request)\n \n-        request.sid = id\n-        request.session = self._load(id)\n-        response.cookie[self._name] = id\n+        request.sid = sid\n+        request.session = self.load(sid)\n+        response.cookie[self._name] = sid\n","files":{"\/circuits\/web\/sessions.py":{"changes":[{"diff":"\n # Date:     22nd February 2009\n # Author:   James Mills, prologic at shortcircuit dot net dot au\n \n+\n \"\"\"Session Components\n \n This module implements Session Components that can be used to store\n and access persistent information.\n \"\"\"\n \n+\n from uuid import uuid4 as uuid\n+from hashlib import sha1 as sha\n from collections import defaultdict\n \n+\n from circuits import handler, Component\n \n \n+def who(request):\n+    \"\"\"Create a SHA1 Hash of the User's IP Address and User-Agent\"\"\"\n+\n+    ip = request.remote.ip\n+    agent = request.headers.get(\"User-Agent\", \"\")\n+\n+    return sha(\"{0:s}{1:s}\".format(ip, agent)).hexdigest()\n+\n+\n+def create_session(request):\n+    \"\"\"Create a unique session id from the request\n+\n+    Returns a unique session using ``uuid4()`` and a ``sha1()`` hash\n+    of the users IP Address and User Agent in the form of ``sid\/who``.\n+    \"\"\"\n+\n+    return \"{0:s}\/{1:s}\".format(uuid().hex, who(request))\n+\n+\n+def verify_session(request, sid):\n+    \"\"\"Verify a User's Session\n+\n+    This verifies the User's Session by verifying the SHA1 Hash\n+    of the User's IP Address and User-Agent match the provided\n+    Session ID.\n+    \"\"\"\n+\n+    if \"\/\" not in sid:\n+        return create_session(request)\n+\n+    user = sid.split(\"\/\", 1)[1]\n+\n+    if user != who(request):\n+        return create_session(request)\n+\n+    return sid\n+\n+\n class Sessions(Component):\n \n     channel = \"web\"\n \n-    def __init__(self, name=\"circuits.session\", *args, **kwargs):\n-        super(Sessions, self).__init__(*args, **kwargs)\n+    def __init__(self, name=\"circuits.session\", channel=channel):\n+        super(Sessions, self).__init__(channel=channel)\n \n         self._name = name\n         self._data = defaultdict(dict)\n \n-    def _load(self, id):\n-        return self._data[id]\n+    def load(self, sid):\n+        return self._data[sid]\n \n-    def _save(self, id, data):\n-        self._data[id] = data\n+    def save(self, sid, data):\n+        \"\"\"Save User Session Data for sid\"\"\"\n \n     @handler(\"request\", priority=10)\n     def request(self, request, response):\n         if self._name in request.cookie:\n-            id = request.cookie[self._name].value\n+            sid = request.cookie[self._name].value\n+            sid = verify_session(request, sid)\n         else:\n-            id = str(uuid())\n+            sid = create_session(request)\n \n-        request.sid = id\n-        request.session = self._load(id)\n-        response.cookie[self._name] = id\n+        request.sid = sid\n+        request.session = self.load(sid)\n+        response.cookie[self._name] = sid\n","add":54,"remove":11,"filename":"\/circuits\/web\/sessions.py","badparts":["    def __init__(self, name=\"circuits.session\", *args, **kwargs):","        super(Sessions, self).__init__(*args, **kwargs)","    def _load(self, id):","        return self._data[id]","    def _save(self, id, data):","        self._data[id] = data","            id = request.cookie[self._name].value","            id = str(uuid())","        request.sid = id","        request.session = self._load(id)","        response.cookie[self._name] = id"],"goodparts":["from hashlib import sha1 as sha","def who(request):","    \"\"\"Create a SHA1 Hash of the User's IP Address and User-Agent\"\"\"","    ip = request.remote.ip","    agent = request.headers.get(\"User-Agent\", \"\")","    return sha(\"{0:s}{1:s}\".format(ip, agent)).hexdigest()","def create_session(request):","    \"\"\"Create a unique session id from the request","    Returns a unique session using ``uuid4()`` and a ``sha1()`` hash","    of the users IP Address and User Agent in the form of ``sid\/who``.","    \"\"\"","    return \"{0:s}\/{1:s}\".format(uuid().hex, who(request))","def verify_session(request, sid):","    \"\"\"Verify a User's Session","    This verifies the User's Session by verifying the SHA1 Hash","    of the User's IP Address and User-Agent match the provided","    Session ID.","    \"\"\"","    if \"\/\" not in sid:","        return create_session(request)","    user = sid.split(\"\/\", 1)[1]","    if user != who(request):","        return create_session(request)","    return sid","    def __init__(self, name=\"circuits.session\", channel=channel):","        super(Sessions, self).__init__(channel=channel)","    def load(self, sid):","        return self._data[sid]","    def save(self, sid, data):","        \"\"\"Save User Session Data for sid\"\"\"","            sid = request.cookie[self._name].value","            sid = verify_session(request, sid)","            sid = create_session(request)","        request.sid = sid","        request.session = self.load(sid)","        response.cookie[self._name] = sid"]}],"source":"\n \"\"\"Session Components This module implements Session Components that can be used to store and access persistent information. \"\"\" from uuid import uuid4 as uuid from collections import defaultdict from circuits import handler, Component class Sessions(Component): channel=\"web\" def __init__(self, name=\"circuits.session\", *args, **kwargs): super(Sessions, self).__init__(*args, **kwargs) self._name=name self._data=defaultdict(dict) def _load(self, id): return self._data[id] def _save(self, id, data): self._data[id]=data @handler(\"request\", priority=10) def request(self, request, response): if self._name in request.cookie: id=request.cookie[self._name].value else: id=str(uuid()) request.sid=id request.session=self._load(id) response.cookie[self._name]=id ","sourceWithComments":"# Module:   sessions\n# Date:     22nd February 2009\n# Author:   James Mills, prologic at shortcircuit dot net dot au\n\n\"\"\"Session Components\n\nThis module implements Session Components that can be used to store\nand access persistent information.\n\"\"\"\n\nfrom uuid import uuid4 as uuid\nfrom collections import defaultdict\n\nfrom circuits import handler, Component\n\n\nclass Sessions(Component):\n\n    channel = \"web\"\n\n    def __init__(self, name=\"circuits.session\", *args, **kwargs):\n        super(Sessions, self).__init__(*args, **kwargs)\n\n        self._name = name\n        self._data = defaultdict(dict)\n\n    def _load(self, id):\n        return self._data[id]\n\n    def _save(self, id, data):\n        self._data[id] = data\n\n    @handler(\"request\", priority=10)\n    def request(self, request, response):\n        if self._name in request.cookie:\n            id = request.cookie[self._name].value\n        else:\n            id = str(uuid())\n\n        request.sid = id\n        request.session = self._load(id)\n        response.cookie[self._name] = id\n"}},"msg":"Improved in-memory Sessions circuis.web Component to be easier to override as well as prevent Session hijacking"}},"https:\/\/github.com\/lavadax\/Halliday-Games":{"c5398bdd00998a156eb6358a4f330bb8e9eceb28":{"url":"https:\/\/api.github.com\/repos\/lavadax\/Halliday-Games\/commits\/c5398bdd00998a156eb6358a4f330bb8e9eceb28","html_url":"https:\/\/github.com\/lavadax\/Halliday-Games\/commit\/c5398bdd00998a156eb6358a4f330bb8e9eceb28","message":"Add change_password checks to limit session hijack","sha":"c5398bdd00998a156eb6358a4f330bb8e9eceb28","keyword":"session hijacking change","diff":"diff --git a\/app.py b\/app.py\nindex 6cac7c3..1ef7e86 100644\n--- a\/app.py\n+++ b\/app.py\n@@ -113,7 +113,7 @@ def logout():\n def get_account(user):\n     if session[\"user\"]:\n         user = mongo.db.users.find_one(\n-            {\"username\": session[\"user\"]})[\"username\"]\n+            {\"username\": session[\"user\"]})\n         return render_template(\"account.html\", user=user)\n     else:\n         # return to login page if user is not logged in\n@@ -121,11 +121,10 @@ def get_account(user):\n         return render_template(\"login\")\n \n \n-@app.route(\"\/change_password\", methods=[\"GET\", \"POST\"])\n-def change_password():\n-    if session[\"user\"]:\n-        user = mongo.db.users.find_one(\n-            {\"username\": session[\"user\"]})\n+@app.route(\"\/change_password\/<user_id>\", methods=[\"GET\", \"POST\"])\n+def change_password(user_id):\n+    user = mongo.db.users.find_one({\"_id\": ObjectId(user_id)})\n+    if session[\"user\"] == user[\"username\"]:\n         if check_password_hash(\n             user[\"password\"], request.form.get(\"check-password\")):\n             if request.form.get(\"password\") == request.form.get(\"password2\"):\ndiff --git a\/templates\/account.html b\/templates\/account.html\nindex 36427c2..f94796e 100644\n--- a\/templates\/account.html\n+++ b\/templates\/account.html\n@@ -1,12 +1,12 @@\n {% extends \"base.html\" %}\n {% block content %}\n     <h3 class=\"center-align\">\n-        Hello {{ user }}. Not you? \n+        Hello {{ user.username }}. Not you? \n         <a href=\"{{ url_for('logout') }}\" class=\"light-blue-text text-darken-4\">Log out here!<\/a>\n     <\/h3>\n \n     <div class=\"row\">\n-        <form class=\"col s12\" method=\"POST\" action=\"{{ url_for('change_password') }}\">\n+        <form class=\"col s12\" method=\"POST\" action=\"{{ url_for('change_password', user_id=user._id) }}\">\n             <table>\n                 <tr>\n                     <td rowspan=\"2\" class=\"border-right border-bottom border-top\">\n@@ -16,7 +16,7 @@ <h4>Account information<\/h4>\n                         Account Name: \n                     <\/td>\n                     <td class=\"border-top\">\n-                        {{ user }}\n+                        {{ user.username }}\n                     <\/td>\n                 <\/tr>\n                 <tr>\n","files":{"\/app.py":{"changes":[{"diff":"\n def get_account(user):\n     if session[\"user\"]:\n         user = mongo.db.users.find_one(\n-            {\"username\": session[\"user\"]})[\"username\"]\n+            {\"username\": session[\"user\"]})\n         return render_template(\"account.html\", user=user)\n     else:\n         # return to login page if user is not logged in\n","add":1,"remove":1,"filename":"\/app.py","badparts":["            {\"username\": session[\"user\"]})[\"username\"]"],"goodparts":["            {\"username\": session[\"user\"]})"]},{"diff":"\n         return render_template(\"login\")\n \n \n-@app.route(\"\/change_password\", methods=[\"GET\", \"POST\"])\n-def change_password():\n-    if session[\"user\"]:\n-        user = mongo.db.users.find_one(\n-            {\"username\": session[\"user\"]})\n+@app.route(\"\/change_password\/<user_id>\", methods=[\"GET\", \"POST\"])\n+def change_password(user_id):\n+    user = mongo.db.users.find_one({\"_id\": ObjectId(user_id)})\n+    if session[\"user\"] == user[\"username\"]:\n         if check_password_hash(\n             user[\"password\"], request.form.get(\"check-password\")):\n             if request.form.get(\"password\") == request.form.get(\"password2\"):","add":4,"remove":5,"filename":"\/app.py","badparts":["@app.route(\"\/change_password\", methods=[\"GET\", \"POST\"])","def change_password():","    if session[\"user\"]:","        user = mongo.db.users.find_one(","            {\"username\": session[\"user\"]})"],"goodparts":["@app.route(\"\/change_password\/<user_id>\", methods=[\"GET\", \"POST\"])","def change_password(user_id):","    user = mongo.db.users.find_one({\"_id\": ObjectId(user_id)})","    if session[\"user\"] == user[\"username\"]:"]}],"source":"\nimport os from flask import( Flask, render_template, redirect, url_for, request, flash, session) from flask_pymongo import PyMongo from bson.objectid import ObjectId from werkzeug.security import generate_password_hash, check_password_hash if os.path.exists(\"env.py\"): import env app=Flask(__name__) app.config[\"MONGO_DBNAME\"]=os.environ.get(\"MONGO_DBNAME\") app.config[\"MONGO_URI\"]=os.environ.get(\"MONGO_URI\") app.secret_key=os.environ.get(\"SECRET_KEY\") mongo=PyMongo(app) @app.route(\"\/\") @app.route(\"\/get_reviews\") def get_reviews(): reviews=list(mongo.db.reviews.find()) return render_template(\"reviews.html\", reviews=reviews) @app.route(\"\/search\") def search(): reviews=list(mongo.db.reviews.find()) return render_template(\"search.html\", reviews=reviews) @app.route(\"\/login\", methods=[\"GET\", \"POST\"]) def login(): if request.method==\"POST\": user=request.form.get(\"username\") existing_user=mongo.db.users.find_one( {\"username\": user.lower()} ) if existing_user: if check_password_hash( existing_user[\"password\"], request.form.get(\"password\")): session[\"user\"]=user.lower() flash(\"Welcome,{}\".format(user)) return redirect(url_for( \"get_account\", user=session[\"user\"])) else: flash(\"Incorrect Username and\/or Password\") return redirect(url_for(\"login\")) else: flash(\"Incorrect Username and\/or Password\") return redirect(url_for(\"login\")) return render_template(\"login.html\") @app.route(\"\/register\", methods=[\"GET\", \"POST\"]) def register(): if request.method==\"POST\": user=request.form.get(\"username\").lower() existing_user=mongo.db.users.find_one( {\"username\": user} ) if existing_user: flash(\"Username is unavailable.\") return redirect(url_for(\"register\")) pass1=request.form.get(\"password\") pass2=request.form.get(\"password2\") if pass1 !=pass2: flash(\"Passwords don't match.\") return redirect(url_for(\"register\")) details={ \"username\": user, \"password\": generate_password_hash(pass1) } mongo.db.users.insert_one(details) session[\"user\"]=user.lower() flash(\"Registration successful\") return redirect(url_for(\"get_account\", user=session[\"user\"])) return render_template(\"register.html\") @app.route(\"\/add_review\") def add_review(): return render_template(\"add_review.html\") @app.route(\"\/logout\") def logout(): flash(\"You've been logged out successfully\") session.pop(\"user\") return redirect(url_for(\"login\")) @app.route(\"\/get_account\/<user>\") def get_account(user): if session[\"user\"]: user=mongo.db.users.find_one( {\"username\": session[\"user\"]})[\"username\"] return render_template(\"account.html\", user=user) else: flash(\"Unable to access account details without logging in\") return render_template(\"login\") @app.route(\"\/change_password\", methods=[\"GET\", \"POST\"]) def change_password(): if session[\"user\"]: user=mongo.db.users.find_one( {\"username\": session[\"user\"]}) if check_password_hash( user[\"password\"], request.form.get(\"check-password\")): if request.form.get(\"password\")==request.form.get(\"password2\"): new_data={ \"username\": user[\"username\"], \"password\": generate_password_hash(request.form.get(\"password\")) } mongo.db.users.update_one({\"_id\": ObjectId(user[\"_id\"])},{\"$set\": new_data}) flash(\"Password has successfully been changed\") return redirect(url_for(\"get_account\", user=session[\"user\"])) else: flash(\"New passwords did not match\") return redirect(url_for(\"get_account\", user=session[\"user\"])) else: flash(\"Old password is incorrect\") return redirect(url_for(\"get_account\", user=session[\"user\"])) else: flash(\"Unable to change password without logging in\") return render_template(\"login\") @app.route(\"\/read_review\/<review_id>\") def read_review(review_id): review=mongo.db.reviews.find_one({\"_id\": ObjectId(review_id)}) return render_template(\"read_review.html\", review=review) if __name__==\"__main__\": app.run(host=os.environ.get(\"IP\"), port=int(os.environ.get(\"PORT\")), debug=True) ","sourceWithComments":"import os\nfrom flask import (\n    Flask, render_template, redirect, \n    url_for, request, flash, session)\nfrom flask_pymongo import PyMongo\nfrom bson.objectid import ObjectId\nfrom werkzeug.security import generate_password_hash, check_password_hash\nif os.path.exists(\"env.py\"):\n    import env\n\n\napp = Flask(__name__)\n\napp.config[\"MONGO_DBNAME\"] = os.environ.get(\"MONGO_DBNAME\")\napp.config[\"MONGO_URI\"] = os.environ.get(\"MONGO_URI\")\napp.secret_key = os.environ.get(\"SECRET_KEY\")\n\nmongo = PyMongo(app)\n\n\n@app.route(\"\/\")\n@app.route(\"\/get_reviews\")\ndef get_reviews():\n    reviews = list(mongo.db.reviews.find())\n    return render_template(\"reviews.html\", reviews=reviews)\n\n\n@app.route(\"\/search\")\ndef search(): \n    # TODO add query & mongodb index\n    reviews = list(mongo.db.reviews.find())\n    return render_template(\"search.html\", reviews=reviews)\n\n\n@app.route(\"\/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    if request.method == \"POST\":\n        #check if username exists in db\n        user = request.form.get(\"username\")\n        existing_user = mongo.db.users.find_one(\n            {\"username\": user.lower()}\n        )\n\n        if existing_user:\n            # ensure hashed password matches user input\n            if check_password_hash(\n                existing_user[\"password\"], request.form.get(\"password\")):\n                session[\"user\"] = user.lower()\n                flash(\"Welcome, {}\".format(user))\n                return redirect(url_for(\n                    \"get_account\", user=session[\"user\"]))\n            else:\n                # invalid password match\n                flash(\"Incorrect Username and\/or Password\")\n                return redirect(url_for(\"login\"))\n        else:\n            # username doesn't exist\n            flash(\"Incorrect Username and\/or Password\")\n            return redirect(url_for(\"login\"))\n\n    return render_template(\"login.html\")\n\n\n@app.route(\"\/register\", methods=[\"GET\", \"POST\"])\ndef register():\n    if request.method == \"POST\":\n        # Check if the username is taken\n        user = request.form.get(\"username\").lower()\n        existing_user = mongo.db.users.find_one(\n            {\"username\": user}\n        )\n\n        if existing_user:\n            flash(\"Username is unavailable.\")\n            return redirect(url_for(\"register\"))\n        \n        # Check of the passwords match\n        pass1 = request.form.get(\"password\")\n        pass2 = request.form.get(\"password2\")\n\n        if pass1 != pass2:\n            flash(\"Passwords don't match.\")\n            return redirect(url_for(\"register\"))\n\n        # Add new user to database\n        details = {\n            \"username\": user,\n            \"password\": generate_password_hash(pass1)\n        }\n        mongo.db.users.insert_one(details)\n\n        # Add the user into session cookie\n        session[\"user\"] = user.lower()\n        flash(\"Registration successful\")\n        return redirect(url_for(\"get_account\", user=session[\"user\"]))\n\n    return render_template(\"register.html\")\n\n\n@app.route(\"\/add_review\")\ndef add_review():\n    return render_template(\"add_review.html\")\n\n\n@app.route(\"\/logout\")\ndef logout():\n    flash(\"You've been logged out successfully\")\n    session.pop(\"user\")\n    return redirect(url_for(\"login\"))\n\n\n@app.route(\"\/get_account\/<user>\")\ndef get_account(user):\n    if session[\"user\"]:\n        user = mongo.db.users.find_one(\n            {\"username\": session[\"user\"]})[\"username\"]\n        return render_template(\"account.html\", user=user)\n    else:\n        # return to login page if user is not logged in\n        flash(\"Unable to access account details without logging in\")\n        return render_template(\"login\")\n\n\n@app.route(\"\/change_password\", methods=[\"GET\", \"POST\"])\ndef change_password():\n    if session[\"user\"]:\n        user = mongo.db.users.find_one(\n            {\"username\": session[\"user\"]})\n        if check_password_hash(\n            user[\"password\"], request.form.get(\"check-password\")):\n            if request.form.get(\"password\") == request.form.get(\"password2\"):\n                new_data = {\n                    \"username\": user[\"username\"],\n                    \"password\": generate_password_hash(request.form.get(\"password\"))\n                }\n                mongo.db.users.update_one({\"_id\": ObjectId(user[\"_id\"])}, {\"$set\": new_data})\n                flash(\"Password has successfully been changed\")\n                return redirect(url_for(\"get_account\", user=session[\"user\"]))\n            else:\n                flash(\"New passwords did not match\")\n                return redirect(url_for(\"get_account\", user=session[\"user\"]))\n        else:\n            flash(\"Old password is incorrect\")\n            return redirect(url_for(\"get_account\", user=session[\"user\"]))\n    else:\n        # return to login page if user is not logged in\n        flash(\"Unable to change password without logging in\")\n        return render_template(\"login\")\n\n\n\n@app.route(\"\/read_review\/<review_id>\")\ndef read_review(review_id):\n    review = mongo.db.reviews.find_one({\"_id\": ObjectId(review_id)})\n    return render_template(\"read_review.html\", review=review)\n\n\nif __name__ == \"__main__\":\n    app.run(host=os.environ.get(\"IP\"),\n            port=int(os.environ.get(\"PORT\")),\n            debug=True) "}},"msg":"Add change_password checks to limit session hijack"}},"https:\/\/github.com\/zogzog\/cubicweb":{"d9b587e18928f702e72763a67574fef9e2d41169":{"url":"https:\/\/api.github.com\/repos\/zogzog\/cubicweb\/commits\/d9b587e18928f702e72763a67574fef9e2d41169","html_url":"https:\/\/github.com\/zogzog\/cubicweb\/commit\/d9b587e18928f702e72763a67574fef9e2d41169","message":"[hooks] Change get_user_sessions prototype, necessary for hijacking from other session implementations (e.g. pyramid)","sha":"d9b587e18928f702e72763a67574fef9e2d41169","keyword":"session hijacking change","diff":"diff --git a\/cubicweb\/hooks\/syncsession.py b\/cubicweb\/hooks\/syncsession.py\nindex 9984bc560..200a946cf 100644\n--- a\/cubicweb\/hooks\/syncsession.py\n+++ b\/cubicweb\/hooks\/syncsession.py\n@@ -26,8 +26,9 @@\n from cubicweb.entities.authobjs import user_session_cache_key\n \n \n-def get_user_sessions(repo, ueid):\n-    for session in repo._sessions.values():\n+# take cnx and not repo because it's needed for other sessions implementation (e.g. pyramid)\n+def get_user_sessions(cnx, ueid):\n+    for session in cnx.repo._sessions.values():\n         if ueid == session.user.eid:\n             yield session\n \n@@ -107,7 +108,7 @@ def __call__(self):\n             opcls = _DeleteGroupOp\n         else:\n             opcls = _AddGroupOp\n-        for session in get_user_sessions(self._cw.repo, self.eidfrom):\n+        for session in get_user_sessions(self._cw, self.eidfrom):\n             opcls(self._cw, session=session, group_eid=self.eidto)\n \n \n@@ -131,7 +132,7 @@ class UserDeletedHook(SyncSessionHook):\n     events = ('after_delete_entity',)\n \n     def __call__(self):\n-        for session in get_user_sessions(self._cw.repo, self.entity.eid):\n+        for session in get_user_sessions(self._cw, self.entity.eid):\n             _CloseSessionOp(self._cw, session=session)\n \n \n@@ -228,7 +229,7 @@ def __call__(self):\n         except ValueError as ex:\n             raise validation_error(entity, {('value', 'subject'): str(ex)})\n         if entity.for_user:\n-            for session in get_user_sessions(cnx.repo, entity.for_user[0].eid):\n+            for session in get_user_sessions(cnx, entity.for_user[0].eid):\n                 _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n         else:\n             _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity)\n@@ -263,7 +264,7 @@ def __call__(self):\n         if cnx.vreg.property_info(key)['sitewide']:\n             msg = _(\"site-wide property can't be set for user\")\n             raise validation_error(eidfrom, {('for_user', 'subject'): msg})\n-        for session in get_user_sessions(cnx.repo, self.eidto):\n+        for session in get_user_sessions(cnx, self.eidto):\n             _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n \n \n@@ -276,5 +277,5 @@ def __call__(self):\n         key = cnx.execute('Any K WHERE P eid %(x)s, P pkey K', {'x': self.eidfrom})[0][0]\n         cnx.transaction_data.setdefault('pendingrelations', []).append(\n             (self.eidfrom, self.rtype, self.eidto))\n-        for session in get_user_sessions(cnx.repo, self.eidto):\n+        for session in get_user_sessions(cnx, self.eidto):\n             _DelUserCWPropertyOp(cnx, session=session, key=key)\n","files":{"\/cubicweb\/hooks\/syncsession.py":{"changes":[{"diff":"\n from cubicweb.entities.authobjs import user_session_cache_key\n \n \n-def get_user_sessions(repo, ueid):\n-    for session in repo._sessions.values():\n+# take cnx and not repo because it's needed for other sessions implementation (e.g. pyramid)\n+def get_user_sessions(cnx, ueid):\n+    for session in cnx.repo._sessions.values():\n         if ueid == session.user.eid:\n             yield session\n \n","add":3,"remove":2,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["def get_user_sessions(repo, ueid):","    for session in repo._sessions.values():"],"goodparts":["def get_user_sessions(cnx, ueid):","    for session in cnx.repo._sessions.values():"]},{"diff":"\n             opcls = _DeleteGroupOp\n         else:\n             opcls = _AddGroupOp\n-        for session in get_user_sessions(self._cw.repo, self.eidfrom):\n+        for session in get_user_sessions(self._cw, self.eidfrom):\n             opcls(self._cw, session=session, group_eid=self.eidto)\n \n \n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["        for session in get_user_sessions(self._cw.repo, self.eidfrom):"],"goodparts":["        for session in get_user_sessions(self._cw, self.eidfrom):"]},{"diff":"\n     events = ('after_delete_entity',)\n \n     def __call__(self):\n-        for session in get_user_sessions(self._cw.repo, self.entity.eid):\n+        for session in get_user_sessions(self._cw, self.entity.eid):\n             _CloseSessionOp(self._cw, session=session)\n \n \n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["        for session in get_user_sessions(self._cw.repo, self.entity.eid):"],"goodparts":["        for session in get_user_sessions(self._cw, self.entity.eid):"]},{"diff":"\n         except ValueError as ex:\n             raise validation_error(entity, {('value', 'subject'): str(ex)})\n         if entity.for_user:\n-            for session in get_user_sessions(cnx.repo, entity.for_user[0].eid):\n+            for session in get_user_sessions(cnx, entity.for_user[0].eid):\n                 _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n         else:\n             _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity)\n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["            for session in get_user_sessions(cnx.repo, entity.for_user[0].eid):"],"goodparts":["            for session in get_user_sessions(cnx, entity.for_user[0].eid):"]},{"diff":"\n         if cnx.vreg.property_info(key)['sitewide']:\n             msg = _(\"site-wide property can't be set for user\")\n             raise validation_error(eidfrom, {('for_user', 'subject'): msg})\n-        for session in get_user_sessions(cnx.repo, self.eidto):\n+        for session in get_user_sessions(cnx, self.eidto):\n             _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n \n \n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["        for session in get_user_sessions(cnx.repo, self.eidto):"],"goodparts":["        for session in get_user_sessions(cnx, self.eidto):"]},{"diff":"\n         key = cnx.execute('Any K WHERE P eid %(x)s, P pkey K', {'x': self.eidfrom})[0][0]\n         cnx.transaction_data.setdefault('pendingrelations', []).append(\n             (self.eidfrom, self.rtype, self.eidto))\n-        for session in get_user_sessions(cnx.repo, self.eidto):\n+        for session in get_user_sessions(cnx, self.eidto):\n             _DelUserCWPropertyOp(cnx, session=session, key=key)\n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["        for session in get_user_sessions(cnx.repo, self.eidto):"],"goodparts":["        for session in get_user_sessions(cnx, self.eidto):"]}],"source":"\n \"\"\"Core hooks: synchronize living session on persistent data changes\"\"\" __docformat__=\"restructuredtext en\" from cubicweb import _ from cubicweb import UnknownProperty, BadConnectionId, validation_error from cubicweb.predicates import is_instance from cubicweb.server import hook from cubicweb.entities.authobjs import user_session_cache_key def get_user_sessions(repo, ueid): for session in repo._sessions.values(): if ueid==session.user.eid: yield session class CachedValueMixin(object): \"\"\"Mixin class providing methods to retrieve some value, specified through `value_name` attribute, in session data. \"\"\" value_name=None session=None @property def cached_value(self): \"\"\"Return cached value for the user, or None\"\"\" key=user_session_cache_key(self.session.user.eid, self.value_name) return self.session.data.get(key, None) def update_cached_value(self, value): \"\"\"Update cached value for the user(modifying the set returned by cached_value may not be necessary depending on session data implementation, e.g. redis) \"\"\" key=user_session_cache_key(self.session.user.eid, self.value_name) self.session.data[key]=value class SyncSessionHook(hook.Hook): __abstract__=True category='syncsession' class _GroupOperation(CachedValueMixin, hook.Operation): \"\"\"Base class for group operation\"\"\" value_name='groups' def __init__(self, cnx, *args, **kwargs): \"\"\"Override to get the group name before actual groups manipulation we may temporarily loose right access during a commit event, so no query should be emitted while comitting \"\"\" rql='Any N WHERE G eid %(x)s, G name N' result=cnx.execute(rql,{'x': kwargs['group_eid']}, build_descr=False) hook.Operation.__init__(self, cnx, *args, **kwargs) self.group=result[0][0] class _DeleteGroupOp(_GroupOperation): \"\"\"Synchronize user when a in_group relation has been deleted\"\"\" def postcommit_event(self): cached_groups=self.cached_value if cached_groups is not None: cached_groups.remove(self.group) self.update_cached_value(cached_groups) class _AddGroupOp(_GroupOperation): \"\"\"Synchronize user when a in_group relation has been added\"\"\" def postcommit_event(self): cached_groups=self.cached_value if cached_groups is not None: cached_groups.add(self.group) self.update_cached_value(cached_groups) class SyncInGroupHook(SyncSessionHook): \"\"\"Watch addition\/removal of in_group relation to synchronize living sessions accordingly\"\"\" __regid__='syncingroup' __select__=SyncSessionHook.__select__ & hook.match_rtype('in_group') events=('after_delete_relation', 'after_add_relation') def __call__(self): if self.event=='after_delete_relation': opcls=_DeleteGroupOp else: opcls=_AddGroupOp for session in get_user_sessions(self._cw.repo, self.eidfrom): opcls(self._cw, session=session, group_eid=self.eidto) class _CloseSessionOp(hook.Operation): \"\"\"Close user's session when it has been deleted\"\"\" def postcommit_event(self): try: key=user_session_cache_key(self.session.user.eid, 'groups') self.session.data.pop(key, None) self.session.repo.close(self.session.sessionid) except BadConnectionId: pass class UserDeletedHook(SyncSessionHook): \"\"\"Watch deletion of user to close its opened session\"\"\" __regid__='closession' __select__=SyncSessionHook.__select__ & is_instance('CWUser') events=('after_delete_entity',) def __call__(self): for session in get_user_sessions(self._cw.repo, self.entity.eid): _CloseSessionOp(self._cw, session=session) class _UserPropertyOperation(CachedValueMixin, hook.Operation): \"\"\"Base class for property operation\"\"\" value_name='properties' key=None class _ChangeUserCWPropertyOp(_UserPropertyOperation): \"\"\"Synchronize cached user's properties when one has been added\/updated\"\"\" value=None def postcommit_event(self): cached_props=self.cached_value if cached_props is not None: cached_props[self.key]=self.value self.update_cached_value(cached_props) class _DelUserCWPropertyOp(_UserPropertyOperation): \"\"\"Synchronize cached user's properties when one has been deleted\"\"\" def postcommit_event(self): cached_props=self.cached_value if cached_props is not None: cached_props.pop(self.key, None) self.update_cached_value(cached_props) class _ChangeSiteWideCWPropertyOp(hook.Operation): \"\"\"Synchronize site wide properties when one has been added\/updated\"\"\" cwprop=None def postcommit_event(self): cwprop=self.cwprop if not cwprop.for_user: self.cnx.vreg['propertyvalues'][cwprop.pkey]=\\ self.cnx.vreg.typed_value(cwprop.pkey, cwprop.value) class _DelSiteWideCWPropertyOp(hook.Operation): \"\"\"Synchronize site wide properties when one has been deleted\"\"\" key=None def postcommit_event(self): self.cnx.vreg['propertyvalues'].pop(self.key, None) class AddCWPropertyHook(SyncSessionHook): __regid__='addcwprop' __select__=SyncSessionHook.__select__ & is_instance('CWProperty') events=('after_add_entity',) def __call__(self): key, value=self.entity.pkey, self.entity.value if key.startswith('sources.'): return cnx=self._cw try: value=cnx.vreg.typed_value(key, value) except UnknownProperty: msg=_('unknown property key %s') raise validation_error(self.entity,{('pkey', 'subject'): msg},(key,)) except ValueError as ex: raise validation_error(self.entity,{('value', 'subject'): str(ex)}) if cnx.user.matching_groups('managers'): _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity) else: cnx.add_relation(self.entity.eid, 'for_user', cnx.user.eid) class UpdateCWPropertyHook(AddCWPropertyHook): __regid__='updatecwprop' events=('after_update_entity',) def __call__(self): entity=self.entity if not('pkey' in entity.cw_edited or 'value' in entity.cw_edited): return key, value=entity.pkey, entity.value if key.startswith('sources.'): return cnx=self._cw try: value=cnx.vreg.typed_value(key, value) except UnknownProperty: return except ValueError as ex: raise validation_error(entity,{('value', 'subject'): str(ex)}) if entity.for_user: for session in get_user_sessions(cnx.repo, entity.for_user[0].eid): _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value) else: _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity) class DeleteCWPropertyHook(AddCWPropertyHook): __regid__='delcwprop' events=('before_delete_entity',) def __call__(self): cnx=self._cw for eidfrom, rtype, eidto in cnx.transaction_data.get('pendingrelations',()): if rtype=='for_user' and eidfrom==self.entity.eid: break else: _DelSiteWideCWPropertyOp(cnx, key=self.entity.pkey) class AddForUserRelationHook(SyncSessionHook): __regid__='addcwpropforuser' __select__=SyncSessionHook.__select__ & hook.match_rtype('for_user') events=('after_add_relation',) def __call__(self): cnx=self._cw eidfrom=self.eidfrom if not cnx.entity_metas(eidfrom)['type']=='CWProperty': return key, value=cnx.execute('Any K,V WHERE P eid %(x)s,P pkey K,P value V', {'x': eidfrom})[0] if cnx.vreg.property_info(key)['sitewide']: msg=_(\"site-wide property can't be set for user\") raise validation_error(eidfrom,{('for_user', 'subject'): msg}) for session in get_user_sessions(cnx.repo, self.eidto): _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value) class DelForUserRelationHook(AddForUserRelationHook): __regid__='delcwpropforuser' events=('after_delete_relation',) def __call__(self): cnx=self._cw key=cnx.execute('Any K WHERE P eid %(x)s, P pkey K',{'x': self.eidfrom})[0][0] cnx.transaction_data.setdefault('pendingrelations',[]).append( (self.eidfrom, self.rtype, self.eidto)) for session in get_user_sessions(cnx.repo, self.eidto): _DelUserCWPropertyOp(cnx, session=session, key=key) ","sourceWithComments":"# copyright 2003-2016 LOGILAB S.A. (Paris, FRANCE), all rights reserved.\n# contact http:\/\/www.logilab.fr\/ -- mailto:contact@logilab.fr\n#\n# This file is part of CubicWeb.\n#\n# CubicWeb is free software: you can redistribute it and\/or modify it under the\n# terms of the GNU Lesser General Public License as published by the Free\n# Software Foundation, either version 2.1 of the License, or (at your option)\n# any later version.\n#\n# CubicWeb is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Lesser General Public License along\n# with CubicWeb.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n\"\"\"Core hooks: synchronize living session on persistent data changes\"\"\"\n\n__docformat__ = \"restructuredtext en\"\n\nfrom cubicweb import _\nfrom cubicweb import UnknownProperty, BadConnectionId, validation_error\nfrom cubicweb.predicates import is_instance\nfrom cubicweb.server import hook\nfrom cubicweb.entities.authobjs import user_session_cache_key\n\n\ndef get_user_sessions(repo, ueid):\n    for session in repo._sessions.values():\n        if ueid == session.user.eid:\n            yield session\n\n\nclass CachedValueMixin(object):\n    \"\"\"Mixin class providing methods to retrieve some value, specified through\n    `value_name` attribute, in session data.\n    \"\"\"\n    value_name = None\n    session = None  # make pylint happy\n\n    @property\n    def cached_value(self):\n        \"\"\"Return cached value for the user, or None\"\"\"\n        key = user_session_cache_key(self.session.user.eid, self.value_name)\n        return self.session.data.get(key, None)\n\n    def update_cached_value(self, value):\n        \"\"\"Update cached value for the user (modifying the set returned by cached_value may not be\n        necessary depending on session data implementation, e.g. redis)\n        \"\"\"\n        key = user_session_cache_key(self.session.user.eid, self.value_name)\n        self.session.data[key] = value\n\n\nclass SyncSessionHook(hook.Hook):\n    __abstract__ = True\n    category = 'syncsession'\n\n\n# user\/groups synchronisation #################################################\n\nclass _GroupOperation(CachedValueMixin, hook.Operation):\n    \"\"\"Base class for group operation\"\"\"\n    value_name = 'groups'\n\n    def __init__(self, cnx, *args, **kwargs):\n        \"\"\"Override to get the group name before actual groups manipulation\n\n        we may temporarily loose right access during a commit event, so\n        no query should be emitted while comitting\n        \"\"\"\n        rql = 'Any N WHERE G eid %(x)s, G name N'\n        result = cnx.execute(rql, {'x': kwargs['group_eid']}, build_descr=False)\n        hook.Operation.__init__(self, cnx, *args, **kwargs)\n        self.group = result[0][0]\n\n\nclass _DeleteGroupOp(_GroupOperation):\n    \"\"\"Synchronize user when a in_group relation has been deleted\"\"\"\n\n    def postcommit_event(self):\n        cached_groups = self.cached_value\n        if cached_groups is not None:\n            cached_groups.remove(self.group)\n            self.update_cached_value(cached_groups)\n\n\nclass _AddGroupOp(_GroupOperation):\n    \"\"\"Synchronize user when a in_group relation has been added\"\"\"\n\n    def postcommit_event(self):\n        cached_groups = self.cached_value\n        if cached_groups is not None:\n            cached_groups.add(self.group)\n            self.update_cached_value(cached_groups)\n\n\nclass SyncInGroupHook(SyncSessionHook):\n    \"\"\"Watch addition\/removal of in_group relation to synchronize living sessions accordingly\"\"\"\n    __regid__ = 'syncingroup'\n    __select__ = SyncSessionHook.__select__ & hook.match_rtype('in_group')\n    events = ('after_delete_relation', 'after_add_relation')\n\n    def __call__(self):\n        if self.event == 'after_delete_relation':\n            opcls = _DeleteGroupOp\n        else:\n            opcls = _AddGroupOp\n        for session in get_user_sessions(self._cw.repo, self.eidfrom):\n            opcls(self._cw, session=session, group_eid=self.eidto)\n\n\nclass _CloseSessionOp(hook.Operation):\n    \"\"\"Close user's session when it has been deleted\"\"\"\n\n    def postcommit_event(self):\n        try:\n            # remove cached groups for the user\n            key = user_session_cache_key(self.session.user.eid, 'groups')\n            self.session.data.pop(key, None)\n            self.session.repo.close(self.session.sessionid)\n        except BadConnectionId:\n            pass  # already closed\n\n\nclass UserDeletedHook(SyncSessionHook):\n    \"\"\"Watch deletion of user to close its opened session\"\"\"\n    __regid__ = 'closession'\n    __select__ = SyncSessionHook.__select__ & is_instance('CWUser')\n    events = ('after_delete_entity',)\n\n    def __call__(self):\n        for session in get_user_sessions(self._cw.repo, self.entity.eid):\n            _CloseSessionOp(self._cw, session=session)\n\n\n# CWProperty hooks #############################################################\n\n\nclass _UserPropertyOperation(CachedValueMixin, hook.Operation):\n    \"\"\"Base class for property operation\"\"\"\n    value_name = 'properties'\n    key = None  # make pylint happy\n\n\nclass _ChangeUserCWPropertyOp(_UserPropertyOperation):\n    \"\"\"Synchronize cached user's properties when one has been added\/updated\"\"\"\n    value = None  # make pylint happy\n\n    def postcommit_event(self):\n        cached_props = self.cached_value\n        if cached_props is not None:\n            cached_props[self.key] = self.value\n            self.update_cached_value(cached_props)\n\n\nclass _DelUserCWPropertyOp(_UserPropertyOperation):\n    \"\"\"Synchronize cached user's properties when one has been deleted\"\"\"\n\n    def postcommit_event(self):\n        cached_props = self.cached_value\n        if cached_props is not None:\n            cached_props.pop(self.key, None)\n            self.update_cached_value(cached_props)\n\n\nclass _ChangeSiteWideCWPropertyOp(hook.Operation):\n    \"\"\"Synchronize site wide properties when one has been added\/updated\"\"\"\n    cwprop = None  # make pylint happy\n\n    def postcommit_event(self):\n        cwprop = self.cwprop\n        if not cwprop.for_user:\n            self.cnx.vreg['propertyvalues'][cwprop.pkey] = \\\n                self.cnx.vreg.typed_value(cwprop.pkey, cwprop.value)\n        # if for_user is set, update is handled by a ChangeUserCWPropertyOp operation\n\n\nclass _DelSiteWideCWPropertyOp(hook.Operation):\n    \"\"\"Synchronize site wide properties when one has been deleted\"\"\"\n    key = None  # make pylint happy\n\n    def postcommit_event(self):\n        self.cnx.vreg['propertyvalues'].pop(self.key, None)\n\n\nclass AddCWPropertyHook(SyncSessionHook):\n    __regid__ = 'addcwprop'\n    __select__ = SyncSessionHook.__select__ & is_instance('CWProperty')\n    events = ('after_add_entity',)\n\n    def __call__(self):\n        key, value = self.entity.pkey, self.entity.value\n        if key.startswith('sources.'):\n            return\n        cnx = self._cw\n        try:\n            value = cnx.vreg.typed_value(key, value)\n        except UnknownProperty:\n            msg = _('unknown property key %s')\n            raise validation_error(self.entity, {('pkey', 'subject'): msg}, (key,))\n        except ValueError as ex:\n            raise validation_error(self.entity, {('value', 'subject'): str(ex)})\n        if cnx.user.matching_groups('managers'):\n            _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity)\n        else:\n            cnx.add_relation(self.entity.eid, 'for_user', cnx.user.eid)\n\n\nclass UpdateCWPropertyHook(AddCWPropertyHook):\n    __regid__ = 'updatecwprop'\n    events = ('after_update_entity',)\n\n    def __call__(self):\n        entity = self.entity\n        if not ('pkey' in entity.cw_edited or\n                'value' in entity.cw_edited):\n            return\n        key, value = entity.pkey, entity.value\n        if key.startswith('sources.'):\n            return\n        cnx = self._cw\n        try:\n            value = cnx.vreg.typed_value(key, value)\n        except UnknownProperty:\n            return\n        except ValueError as ex:\n            raise validation_error(entity, {('value', 'subject'): str(ex)})\n        if entity.for_user:\n            for session in get_user_sessions(cnx.repo, entity.for_user[0].eid):\n                _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n        else:\n            _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity)\n\n\nclass DeleteCWPropertyHook(AddCWPropertyHook):\n    __regid__ = 'delcwprop'\n    events = ('before_delete_entity',)\n\n    def __call__(self):\n        cnx = self._cw\n        for eidfrom, rtype, eidto in cnx.transaction_data.get('pendingrelations', ()):\n            if rtype == 'for_user' and eidfrom == self.entity.eid:\n                # if for_user was set, delete already handled by hook on for_user deletion\n                break\n        else:\n            _DelSiteWideCWPropertyOp(cnx, key=self.entity.pkey)\n\n\nclass AddForUserRelationHook(SyncSessionHook):\n    __regid__ = 'addcwpropforuser'\n    __select__ = SyncSessionHook.__select__ & hook.match_rtype('for_user')\n    events = ('after_add_relation',)\n\n    def __call__(self):\n        cnx = self._cw\n        eidfrom = self.eidfrom\n        if not cnx.entity_metas(eidfrom)['type'] == 'CWProperty':\n            return\n        key, value = cnx.execute('Any K,V WHERE P eid %(x)s,P pkey K,P value V',\n                                 {'x': eidfrom})[0]\n        if cnx.vreg.property_info(key)['sitewide']:\n            msg = _(\"site-wide property can't be set for user\")\n            raise validation_error(eidfrom, {('for_user', 'subject'): msg})\n        for session in get_user_sessions(cnx.repo, self.eidto):\n            _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n\n\nclass DelForUserRelationHook(AddForUserRelationHook):\n    __regid__ = 'delcwpropforuser'\n    events = ('after_delete_relation',)\n\n    def __call__(self):\n        cnx = self._cw\n        key = cnx.execute('Any K WHERE P eid %(x)s, P pkey K', {'x': self.eidfrom})[0][0]\n        cnx.transaction_data.setdefault('pendingrelations', []).append(\n            (self.eidfrom, self.rtype, self.eidto))\n        for session in get_user_sessions(cnx.repo, self.eidto):\n            _DelUserCWPropertyOp(cnx, session=session, key=key)\n"}},"msg":"[hooks] Change get_user_sessions prototype, necessary for hijacking from other session implementations (e.g. pyramid)"}},"https:\/\/github.com\/gurneyalex\/cubicweb":{"69b5444eb9b0264a8e154a8747ea62eb1e5215f6":{"url":"https:\/\/api.github.com\/repos\/gurneyalex\/cubicweb\/commits\/69b5444eb9b0264a8e154a8747ea62eb1e5215f6","html_url":"https:\/\/github.com\/gurneyalex\/cubicweb\/commit\/69b5444eb9b0264a8e154a8747ea62eb1e5215f6","message":"[hooks] Change get_user_sessions prototype, necessary for hijacking from other session implementations (e.g. pyramid)","sha":"69b5444eb9b0264a8e154a8747ea62eb1e5215f6","keyword":"session hijacking change","diff":"diff --git a\/cubicweb\/hooks\/syncsession.py b\/cubicweb\/hooks\/syncsession.py\nindex 9984bc560..200a946cf 100644\n--- a\/cubicweb\/hooks\/syncsession.py\n+++ b\/cubicweb\/hooks\/syncsession.py\n@@ -26,8 +26,9 @@\n from cubicweb.entities.authobjs import user_session_cache_key\n \n \n-def get_user_sessions(repo, ueid):\n-    for session in repo._sessions.values():\n+# take cnx and not repo because it's needed for other sessions implementation (e.g. pyramid)\n+def get_user_sessions(cnx, ueid):\n+    for session in cnx.repo._sessions.values():\n         if ueid == session.user.eid:\n             yield session\n \n@@ -107,7 +108,7 @@ def __call__(self):\n             opcls = _DeleteGroupOp\n         else:\n             opcls = _AddGroupOp\n-        for session in get_user_sessions(self._cw.repo, self.eidfrom):\n+        for session in get_user_sessions(self._cw, self.eidfrom):\n             opcls(self._cw, session=session, group_eid=self.eidto)\n \n \n@@ -131,7 +132,7 @@ class UserDeletedHook(SyncSessionHook):\n     events = ('after_delete_entity',)\n \n     def __call__(self):\n-        for session in get_user_sessions(self._cw.repo, self.entity.eid):\n+        for session in get_user_sessions(self._cw, self.entity.eid):\n             _CloseSessionOp(self._cw, session=session)\n \n \n@@ -228,7 +229,7 @@ def __call__(self):\n         except ValueError as ex:\n             raise validation_error(entity, {('value', 'subject'): str(ex)})\n         if entity.for_user:\n-            for session in get_user_sessions(cnx.repo, entity.for_user[0].eid):\n+            for session in get_user_sessions(cnx, entity.for_user[0].eid):\n                 _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n         else:\n             _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity)\n@@ -263,7 +264,7 @@ def __call__(self):\n         if cnx.vreg.property_info(key)['sitewide']:\n             msg = _(\"site-wide property can't be set for user\")\n             raise validation_error(eidfrom, {('for_user', 'subject'): msg})\n-        for session in get_user_sessions(cnx.repo, self.eidto):\n+        for session in get_user_sessions(cnx, self.eidto):\n             _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n \n \n@@ -276,5 +277,5 @@ def __call__(self):\n         key = cnx.execute('Any K WHERE P eid %(x)s, P pkey K', {'x': self.eidfrom})[0][0]\n         cnx.transaction_data.setdefault('pendingrelations', []).append(\n             (self.eidfrom, self.rtype, self.eidto))\n-        for session in get_user_sessions(cnx.repo, self.eidto):\n+        for session in get_user_sessions(cnx, self.eidto):\n             _DelUserCWPropertyOp(cnx, session=session, key=key)\n","files":{"\/cubicweb\/hooks\/syncsession.py":{"changes":[{"diff":"\n from cubicweb.entities.authobjs import user_session_cache_key\n \n \n-def get_user_sessions(repo, ueid):\n-    for session in repo._sessions.values():\n+# take cnx and not repo because it's needed for other sessions implementation (e.g. pyramid)\n+def get_user_sessions(cnx, ueid):\n+    for session in cnx.repo._sessions.values():\n         if ueid == session.user.eid:\n             yield session\n \n","add":3,"remove":2,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["def get_user_sessions(repo, ueid):","    for session in repo._sessions.values():"],"goodparts":["def get_user_sessions(cnx, ueid):","    for session in cnx.repo._sessions.values():"]},{"diff":"\n             opcls = _DeleteGroupOp\n         else:\n             opcls = _AddGroupOp\n-        for session in get_user_sessions(self._cw.repo, self.eidfrom):\n+        for session in get_user_sessions(self._cw, self.eidfrom):\n             opcls(self._cw, session=session, group_eid=self.eidto)\n \n \n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["        for session in get_user_sessions(self._cw.repo, self.eidfrom):"],"goodparts":["        for session in get_user_sessions(self._cw, self.eidfrom):"]},{"diff":"\n     events = ('after_delete_entity',)\n \n     def __call__(self):\n-        for session in get_user_sessions(self._cw.repo, self.entity.eid):\n+        for session in get_user_sessions(self._cw, self.entity.eid):\n             _CloseSessionOp(self._cw, session=session)\n \n \n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["        for session in get_user_sessions(self._cw.repo, self.entity.eid):"],"goodparts":["        for session in get_user_sessions(self._cw, self.entity.eid):"]},{"diff":"\n         except ValueError as ex:\n             raise validation_error(entity, {('value', 'subject'): str(ex)})\n         if entity.for_user:\n-            for session in get_user_sessions(cnx.repo, entity.for_user[0].eid):\n+            for session in get_user_sessions(cnx, entity.for_user[0].eid):\n                 _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n         else:\n             _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity)\n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["            for session in get_user_sessions(cnx.repo, entity.for_user[0].eid):"],"goodparts":["            for session in get_user_sessions(cnx, entity.for_user[0].eid):"]},{"diff":"\n         if cnx.vreg.property_info(key)['sitewide']:\n             msg = _(\"site-wide property can't be set for user\")\n             raise validation_error(eidfrom, {('for_user', 'subject'): msg})\n-        for session in get_user_sessions(cnx.repo, self.eidto):\n+        for session in get_user_sessions(cnx, self.eidto):\n             _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n \n \n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["        for session in get_user_sessions(cnx.repo, self.eidto):"],"goodparts":["        for session in get_user_sessions(cnx, self.eidto):"]},{"diff":"\n         key = cnx.execute('Any K WHERE P eid %(x)s, P pkey K', {'x': self.eidfrom})[0][0]\n         cnx.transaction_data.setdefault('pendingrelations', []).append(\n             (self.eidfrom, self.rtype, self.eidto))\n-        for session in get_user_sessions(cnx.repo, self.eidto):\n+        for session in get_user_sessions(cnx, self.eidto):\n             _DelUserCWPropertyOp(cnx, session=session, key=key)\n","add":1,"remove":1,"filename":"\/cubicweb\/hooks\/syncsession.py","badparts":["        for session in get_user_sessions(cnx.repo, self.eidto):"],"goodparts":["        for session in get_user_sessions(cnx, self.eidto):"]}],"source":"\n \"\"\"Core hooks: synchronize living session on persistent data changes\"\"\" __docformat__=\"restructuredtext en\" from cubicweb import _ from cubicweb import UnknownProperty, BadConnectionId, validation_error from cubicweb.predicates import is_instance from cubicweb.server import hook from cubicweb.entities.authobjs import user_session_cache_key def get_user_sessions(repo, ueid): for session in repo._sessions.values(): if ueid==session.user.eid: yield session class CachedValueMixin(object): \"\"\"Mixin class providing methods to retrieve some value, specified through `value_name` attribute, in session data. \"\"\" value_name=None session=None @property def cached_value(self): \"\"\"Return cached value for the user, or None\"\"\" key=user_session_cache_key(self.session.user.eid, self.value_name) return self.session.data.get(key, None) def update_cached_value(self, value): \"\"\"Update cached value for the user(modifying the set returned by cached_value may not be necessary depending on session data implementation, e.g. redis) \"\"\" key=user_session_cache_key(self.session.user.eid, self.value_name) self.session.data[key]=value class SyncSessionHook(hook.Hook): __abstract__=True category='syncsession' class _GroupOperation(CachedValueMixin, hook.Operation): \"\"\"Base class for group operation\"\"\" value_name='groups' def __init__(self, cnx, *args, **kwargs): \"\"\"Override to get the group name before actual groups manipulation we may temporarily loose right access during a commit event, so no query should be emitted while comitting \"\"\" rql='Any N WHERE G eid %(x)s, G name N' result=cnx.execute(rql,{'x': kwargs['group_eid']}, build_descr=False) hook.Operation.__init__(self, cnx, *args, **kwargs) self.group=result[0][0] class _DeleteGroupOp(_GroupOperation): \"\"\"Synchronize user when a in_group relation has been deleted\"\"\" def postcommit_event(self): cached_groups=self.cached_value if cached_groups is not None: cached_groups.remove(self.group) self.update_cached_value(cached_groups) class _AddGroupOp(_GroupOperation): \"\"\"Synchronize user when a in_group relation has been added\"\"\" def postcommit_event(self): cached_groups=self.cached_value if cached_groups is not None: cached_groups.add(self.group) self.update_cached_value(cached_groups) class SyncInGroupHook(SyncSessionHook): \"\"\"Watch addition\/removal of in_group relation to synchronize living sessions accordingly\"\"\" __regid__='syncingroup' __select__=SyncSessionHook.__select__ & hook.match_rtype('in_group') events=('after_delete_relation', 'after_add_relation') def __call__(self): if self.event=='after_delete_relation': opcls=_DeleteGroupOp else: opcls=_AddGroupOp for session in get_user_sessions(self._cw.repo, self.eidfrom): opcls(self._cw, session=session, group_eid=self.eidto) class _CloseSessionOp(hook.Operation): \"\"\"Close user's session when it has been deleted\"\"\" def postcommit_event(self): try: key=user_session_cache_key(self.session.user.eid, 'groups') self.session.data.pop(key, None) self.session.repo.close(self.session.sessionid) except BadConnectionId: pass class UserDeletedHook(SyncSessionHook): \"\"\"Watch deletion of user to close its opened session\"\"\" __regid__='closession' __select__=SyncSessionHook.__select__ & is_instance('CWUser') events=('after_delete_entity',) def __call__(self): for session in get_user_sessions(self._cw.repo, self.entity.eid): _CloseSessionOp(self._cw, session=session) class _UserPropertyOperation(CachedValueMixin, hook.Operation): \"\"\"Base class for property operation\"\"\" value_name='properties' key=None class _ChangeUserCWPropertyOp(_UserPropertyOperation): \"\"\"Synchronize cached user's properties when one has been added\/updated\"\"\" value=None def postcommit_event(self): cached_props=self.cached_value if cached_props is not None: cached_props[self.key]=self.value self.update_cached_value(cached_props) class _DelUserCWPropertyOp(_UserPropertyOperation): \"\"\"Synchronize cached user's properties when one has been deleted\"\"\" def postcommit_event(self): cached_props=self.cached_value if cached_props is not None: cached_props.pop(self.key, None) self.update_cached_value(cached_props) class _ChangeSiteWideCWPropertyOp(hook.Operation): \"\"\"Synchronize site wide properties when one has been added\/updated\"\"\" cwprop=None def postcommit_event(self): cwprop=self.cwprop if not cwprop.for_user: self.cnx.vreg['propertyvalues'][cwprop.pkey]=\\ self.cnx.vreg.typed_value(cwprop.pkey, cwprop.value) class _DelSiteWideCWPropertyOp(hook.Operation): \"\"\"Synchronize site wide properties when one has been deleted\"\"\" key=None def postcommit_event(self): self.cnx.vreg['propertyvalues'].pop(self.key, None) class AddCWPropertyHook(SyncSessionHook): __regid__='addcwprop' __select__=SyncSessionHook.__select__ & is_instance('CWProperty') events=('after_add_entity',) def __call__(self): key, value=self.entity.pkey, self.entity.value if key.startswith('sources.'): return cnx=self._cw try: value=cnx.vreg.typed_value(key, value) except UnknownProperty: msg=_('unknown property key %s') raise validation_error(self.entity,{('pkey', 'subject'): msg},(key,)) except ValueError as ex: raise validation_error(self.entity,{('value', 'subject'): str(ex)}) if cnx.user.matching_groups('managers'): _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity) else: cnx.add_relation(self.entity.eid, 'for_user', cnx.user.eid) class UpdateCWPropertyHook(AddCWPropertyHook): __regid__='updatecwprop' events=('after_update_entity',) def __call__(self): entity=self.entity if not('pkey' in entity.cw_edited or 'value' in entity.cw_edited): return key, value=entity.pkey, entity.value if key.startswith('sources.'): return cnx=self._cw try: value=cnx.vreg.typed_value(key, value) except UnknownProperty: return except ValueError as ex: raise validation_error(entity,{('value', 'subject'): str(ex)}) if entity.for_user: for session in get_user_sessions(cnx.repo, entity.for_user[0].eid): _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value) else: _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity) class DeleteCWPropertyHook(AddCWPropertyHook): __regid__='delcwprop' events=('before_delete_entity',) def __call__(self): cnx=self._cw for eidfrom, rtype, eidto in cnx.transaction_data.get('pendingrelations',()): if rtype=='for_user' and eidfrom==self.entity.eid: break else: _DelSiteWideCWPropertyOp(cnx, key=self.entity.pkey) class AddForUserRelationHook(SyncSessionHook): __regid__='addcwpropforuser' __select__=SyncSessionHook.__select__ & hook.match_rtype('for_user') events=('after_add_relation',) def __call__(self): cnx=self._cw eidfrom=self.eidfrom if not cnx.entity_metas(eidfrom)['type']=='CWProperty': return key, value=cnx.execute('Any K,V WHERE P eid %(x)s,P pkey K,P value V', {'x': eidfrom})[0] if cnx.vreg.property_info(key)['sitewide']: msg=_(\"site-wide property can't be set for user\") raise validation_error(eidfrom,{('for_user', 'subject'): msg}) for session in get_user_sessions(cnx.repo, self.eidto): _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value) class DelForUserRelationHook(AddForUserRelationHook): __regid__='delcwpropforuser' events=('after_delete_relation',) def __call__(self): cnx=self._cw key=cnx.execute('Any K WHERE P eid %(x)s, P pkey K',{'x': self.eidfrom})[0][0] cnx.transaction_data.setdefault('pendingrelations',[]).append( (self.eidfrom, self.rtype, self.eidto)) for session in get_user_sessions(cnx.repo, self.eidto): _DelUserCWPropertyOp(cnx, session=session, key=key) ","sourceWithComments":"# copyright 2003-2016 LOGILAB S.A. (Paris, FRANCE), all rights reserved.\n# contact http:\/\/www.logilab.fr\/ -- mailto:contact@logilab.fr\n#\n# This file is part of CubicWeb.\n#\n# CubicWeb is free software: you can redistribute it and\/or modify it under the\n# terms of the GNU Lesser General Public License as published by the Free\n# Software Foundation, either version 2.1 of the License, or (at your option)\n# any later version.\n#\n# CubicWeb is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Lesser General Public License along\n# with CubicWeb.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n\"\"\"Core hooks: synchronize living session on persistent data changes\"\"\"\n\n__docformat__ = \"restructuredtext en\"\n\nfrom cubicweb import _\nfrom cubicweb import UnknownProperty, BadConnectionId, validation_error\nfrom cubicweb.predicates import is_instance\nfrom cubicweb.server import hook\nfrom cubicweb.entities.authobjs import user_session_cache_key\n\n\ndef get_user_sessions(repo, ueid):\n    for session in repo._sessions.values():\n        if ueid == session.user.eid:\n            yield session\n\n\nclass CachedValueMixin(object):\n    \"\"\"Mixin class providing methods to retrieve some value, specified through\n    `value_name` attribute, in session data.\n    \"\"\"\n    value_name = None\n    session = None  # make pylint happy\n\n    @property\n    def cached_value(self):\n        \"\"\"Return cached value for the user, or None\"\"\"\n        key = user_session_cache_key(self.session.user.eid, self.value_name)\n        return self.session.data.get(key, None)\n\n    def update_cached_value(self, value):\n        \"\"\"Update cached value for the user (modifying the set returned by cached_value may not be\n        necessary depending on session data implementation, e.g. redis)\n        \"\"\"\n        key = user_session_cache_key(self.session.user.eid, self.value_name)\n        self.session.data[key] = value\n\n\nclass SyncSessionHook(hook.Hook):\n    __abstract__ = True\n    category = 'syncsession'\n\n\n# user\/groups synchronisation #################################################\n\nclass _GroupOperation(CachedValueMixin, hook.Operation):\n    \"\"\"Base class for group operation\"\"\"\n    value_name = 'groups'\n\n    def __init__(self, cnx, *args, **kwargs):\n        \"\"\"Override to get the group name before actual groups manipulation\n\n        we may temporarily loose right access during a commit event, so\n        no query should be emitted while comitting\n        \"\"\"\n        rql = 'Any N WHERE G eid %(x)s, G name N'\n        result = cnx.execute(rql, {'x': kwargs['group_eid']}, build_descr=False)\n        hook.Operation.__init__(self, cnx, *args, **kwargs)\n        self.group = result[0][0]\n\n\nclass _DeleteGroupOp(_GroupOperation):\n    \"\"\"Synchronize user when a in_group relation has been deleted\"\"\"\n\n    def postcommit_event(self):\n        cached_groups = self.cached_value\n        if cached_groups is not None:\n            cached_groups.remove(self.group)\n            self.update_cached_value(cached_groups)\n\n\nclass _AddGroupOp(_GroupOperation):\n    \"\"\"Synchronize user when a in_group relation has been added\"\"\"\n\n    def postcommit_event(self):\n        cached_groups = self.cached_value\n        if cached_groups is not None:\n            cached_groups.add(self.group)\n            self.update_cached_value(cached_groups)\n\n\nclass SyncInGroupHook(SyncSessionHook):\n    \"\"\"Watch addition\/removal of in_group relation to synchronize living sessions accordingly\"\"\"\n    __regid__ = 'syncingroup'\n    __select__ = SyncSessionHook.__select__ & hook.match_rtype('in_group')\n    events = ('after_delete_relation', 'after_add_relation')\n\n    def __call__(self):\n        if self.event == 'after_delete_relation':\n            opcls = _DeleteGroupOp\n        else:\n            opcls = _AddGroupOp\n        for session in get_user_sessions(self._cw.repo, self.eidfrom):\n            opcls(self._cw, session=session, group_eid=self.eidto)\n\n\nclass _CloseSessionOp(hook.Operation):\n    \"\"\"Close user's session when it has been deleted\"\"\"\n\n    def postcommit_event(self):\n        try:\n            # remove cached groups for the user\n            key = user_session_cache_key(self.session.user.eid, 'groups')\n            self.session.data.pop(key, None)\n            self.session.repo.close(self.session.sessionid)\n        except BadConnectionId:\n            pass  # already closed\n\n\nclass UserDeletedHook(SyncSessionHook):\n    \"\"\"Watch deletion of user to close its opened session\"\"\"\n    __regid__ = 'closession'\n    __select__ = SyncSessionHook.__select__ & is_instance('CWUser')\n    events = ('after_delete_entity',)\n\n    def __call__(self):\n        for session in get_user_sessions(self._cw.repo, self.entity.eid):\n            _CloseSessionOp(self._cw, session=session)\n\n\n# CWProperty hooks #############################################################\n\n\nclass _UserPropertyOperation(CachedValueMixin, hook.Operation):\n    \"\"\"Base class for property operation\"\"\"\n    value_name = 'properties'\n    key = None  # make pylint happy\n\n\nclass _ChangeUserCWPropertyOp(_UserPropertyOperation):\n    \"\"\"Synchronize cached user's properties when one has been added\/updated\"\"\"\n    value = None  # make pylint happy\n\n    def postcommit_event(self):\n        cached_props = self.cached_value\n        if cached_props is not None:\n            cached_props[self.key] = self.value\n            self.update_cached_value(cached_props)\n\n\nclass _DelUserCWPropertyOp(_UserPropertyOperation):\n    \"\"\"Synchronize cached user's properties when one has been deleted\"\"\"\n\n    def postcommit_event(self):\n        cached_props = self.cached_value\n        if cached_props is not None:\n            cached_props.pop(self.key, None)\n            self.update_cached_value(cached_props)\n\n\nclass _ChangeSiteWideCWPropertyOp(hook.Operation):\n    \"\"\"Synchronize site wide properties when one has been added\/updated\"\"\"\n    cwprop = None  # make pylint happy\n\n    def postcommit_event(self):\n        cwprop = self.cwprop\n        if not cwprop.for_user:\n            self.cnx.vreg['propertyvalues'][cwprop.pkey] = \\\n                self.cnx.vreg.typed_value(cwprop.pkey, cwprop.value)\n        # if for_user is set, update is handled by a ChangeUserCWPropertyOp operation\n\n\nclass _DelSiteWideCWPropertyOp(hook.Operation):\n    \"\"\"Synchronize site wide properties when one has been deleted\"\"\"\n    key = None  # make pylint happy\n\n    def postcommit_event(self):\n        self.cnx.vreg['propertyvalues'].pop(self.key, None)\n\n\nclass AddCWPropertyHook(SyncSessionHook):\n    __regid__ = 'addcwprop'\n    __select__ = SyncSessionHook.__select__ & is_instance('CWProperty')\n    events = ('after_add_entity',)\n\n    def __call__(self):\n        key, value = self.entity.pkey, self.entity.value\n        if key.startswith('sources.'):\n            return\n        cnx = self._cw\n        try:\n            value = cnx.vreg.typed_value(key, value)\n        except UnknownProperty:\n            msg = _('unknown property key %s')\n            raise validation_error(self.entity, {('pkey', 'subject'): msg}, (key,))\n        except ValueError as ex:\n            raise validation_error(self.entity, {('value', 'subject'): str(ex)})\n        if cnx.user.matching_groups('managers'):\n            _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity)\n        else:\n            cnx.add_relation(self.entity.eid, 'for_user', cnx.user.eid)\n\n\nclass UpdateCWPropertyHook(AddCWPropertyHook):\n    __regid__ = 'updatecwprop'\n    events = ('after_update_entity',)\n\n    def __call__(self):\n        entity = self.entity\n        if not ('pkey' in entity.cw_edited or\n                'value' in entity.cw_edited):\n            return\n        key, value = entity.pkey, entity.value\n        if key.startswith('sources.'):\n            return\n        cnx = self._cw\n        try:\n            value = cnx.vreg.typed_value(key, value)\n        except UnknownProperty:\n            return\n        except ValueError as ex:\n            raise validation_error(entity, {('value', 'subject'): str(ex)})\n        if entity.for_user:\n            for session in get_user_sessions(cnx.repo, entity.for_user[0].eid):\n                _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n        else:\n            _ChangeSiteWideCWPropertyOp(cnx, cwprop=self.entity)\n\n\nclass DeleteCWPropertyHook(AddCWPropertyHook):\n    __regid__ = 'delcwprop'\n    events = ('before_delete_entity',)\n\n    def __call__(self):\n        cnx = self._cw\n        for eidfrom, rtype, eidto in cnx.transaction_data.get('pendingrelations', ()):\n            if rtype == 'for_user' and eidfrom == self.entity.eid:\n                # if for_user was set, delete already handled by hook on for_user deletion\n                break\n        else:\n            _DelSiteWideCWPropertyOp(cnx, key=self.entity.pkey)\n\n\nclass AddForUserRelationHook(SyncSessionHook):\n    __regid__ = 'addcwpropforuser'\n    __select__ = SyncSessionHook.__select__ & hook.match_rtype('for_user')\n    events = ('after_add_relation',)\n\n    def __call__(self):\n        cnx = self._cw\n        eidfrom = self.eidfrom\n        if not cnx.entity_metas(eidfrom)['type'] == 'CWProperty':\n            return\n        key, value = cnx.execute('Any K,V WHERE P eid %(x)s,P pkey K,P value V',\n                                 {'x': eidfrom})[0]\n        if cnx.vreg.property_info(key)['sitewide']:\n            msg = _(\"site-wide property can't be set for user\")\n            raise validation_error(eidfrom, {('for_user', 'subject'): msg})\n        for session in get_user_sessions(cnx.repo, self.eidto):\n            _ChangeUserCWPropertyOp(cnx, session=session, key=key, value=value)\n\n\nclass DelForUserRelationHook(AddForUserRelationHook):\n    __regid__ = 'delcwpropforuser'\n    events = ('after_delete_relation',)\n\n    def __call__(self):\n        cnx = self._cw\n        key = cnx.execute('Any K WHERE P eid %(x)s, P pkey K', {'x': self.eidfrom})[0][0]\n        cnx.transaction_data.setdefault('pendingrelations', []).append(\n            (self.eidfrom, self.rtype, self.eidto))\n        for session in get_user_sessions(cnx.repo, self.eidto):\n            _DelUserCWPropertyOp(cnx, session=session, key=key)\n"}},"msg":"[hooks] Change get_user_sessions prototype, necessary for hijacking from other session implementations (e.g. pyramid)"}},"https:\/\/github.com\/bbangert\/beaker":{"f77f92a31a8f3a271ff518384bc9985116f1bc83":{"url":"https:\/\/api.github.com\/repos\/bbangert\/beaker\/commits\/f77f92a31a8f3a271ff518384bc9985116f1bc83","html_url":"https:\/\/github.com\/bbangert\/beaker\/commit\/f77f92a31a8f3a271ff518384bc9985116f1bc83","message":"adding tests for previous fix\n\nEven though I added the changes first, I backed them out after\ncommit to make sure this test fails.  Then put them back in and\nthe test passes.\n\n#75 Session.regenerate_id() needed to help avoid session hijacking\n\n--HG--\nbranch : trunk","sha":"f77f92a31a8f3a271ff518384bc9985116f1bc83","keyword":"session hijacking change","diff":"diff --git a\/tests\/test_session.py b\/tests\/test_session.py\nindex 3c0670a1..bc1adc13 100644\n--- a\/tests\/test_session.py\n+++ b\/tests\/test_session.py\n@@ -85,21 +85,39 @@ def test_invalidate():\n \n def test_regenerate_id():\n     \"\"\"Test :meth:`Session.regenerate_id`\"\"\"\n-    session = get_session(user_cookies=True)\n+    # new session & save\n+    session = get_session()\n     orig_id = session.id\n     session[u'foo'] = u'bar'\n+    session.save()\n \n-    # cookie should be there\n-    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n+    # load session\n+    session = get_session(id=session.id)\n+    # data should still be there\n+    assert session[u'foo'] == u'bar'\n \n+    # regenerate the id\n     session.regenerate_id()\n \n     assert session.id != orig_id\n+\n+    # data is still there\n     assert session[u'foo'] == u'bar'\n \n     # should be the new id\n     assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n \n+    # get a new session before calling save\n+    bunk_sess = get_session(id=session.id)\n+    assert u'foo' not in bunk_sess\n+\n+    # save it\n+    session.save()\n+\n+    # make sure we get the data back\n+    session = get_session(id=session.id)\n+    assert session[u'foo'] == u'bar'\n+\n \n def test_timeout():\n     \"\"\"Test if the session times out properly\"\"\"\n","files":{"\/tests\/test_session.py":{"changes":[{"diff":"\n \n def test_regenerate_id():\n     \"\"\"Test :meth:`Session.regenerate_id`\"\"\"\n-    session = get_session(user_cookies=True)\n+    # new session & save\n+    session = get_session()\n     orig_id = session.id\n     session[u'foo'] = u'bar'\n+    session.save()\n \n-    # cookie should be there\n-    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n+    # load session\n+    session = get_session(id=session.id)\n+    # data should still be there\n+    assert session[u'foo'] == u'bar'\n \n+    # regenerate the id\n     session.regenerate_id()\n \n     assert session.id != orig_id\n+\n+    # data is still there\n     assert session[u'foo'] == u'bar'\n \n     # should be the new id\n     assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n \n+    # get a new session before calling save\n+    bunk_sess = get_session(id=session.id)\n+    assert u'foo' not in bunk_sess\n+\n+    # save it\n+    session.save()\n+\n+    # make sure we get the data back\n+    session = get_session(id=session.id)\n+    assert session[u'foo'] == u'bar'\n+\n \n def test_timeout():\n     \"\"\"Test if the session times out properly\"\"\"\n","add":21,"remove":3,"filename":"\/tests\/test_session.py","badparts":["    session = get_session(user_cookies=True)","    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']"],"goodparts":["    session = get_session()","    session.save()","    session = get_session(id=session.id)","    assert session[u'foo'] == u'bar'","    bunk_sess = get_session(id=session.id)","    assert u'foo' not in bunk_sess","    session.save()","    session = get_session(id=session.id)","    assert session[u'foo'] == u'bar'"]}],"source":"\n\nimport sys import time import warnings from beaker.session import Session from beaker import util def get_session(**kwargs): \"\"\"A shortcut for creating:class:`Session` instance\"\"\" options={} options.update(**kwargs) return Session({}, **options) def test_save_load(): \"\"\"Test if the data is actually persistent across requests\"\"\" session=get_session() session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.save() session=get_session(id=session.id) assert u'Suomi' in session assert u'Great Britain' in session assert u'Deutchland' in session assert session[u'Suomi']==u'Kimi R\u00e4ikk\u00f6nen' assert session[u'Great Britain']==u'Jenson Button' assert session[u'Deutchland']==u'Sebastian Vettel' def test_delete(): \"\"\"Test:meth:`Session.delete`\"\"\" session=get_session() session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.delete() assert u'Suomi' not in session assert u'Great Britain' not in session assert u'Deutchland' not in session def test_revert(): \"\"\"Test:meth:`Session.revert`\"\"\" session=get_session() session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.save() session=get_session(id=session.id) del session[u'Suomi'] session[u'Great Britain']=u'Lewis Hamilton' session[u'Deutchland']=u'Michael Schumacher' session[u'Espa\u00f1a']=u'Fernando Alonso' session.revert() assert session[u'Suomi']==u'Kimi R\u00e4ikk\u00f6nen' assert session[u'Great Britain']==u'Jenson Button' assert session[u'Deutchland']==u'Sebastian Vettel' assert u'Espa\u00f1a' not in session def test_invalidate(): \"\"\"Test:meth:`Session.invalidate`\"\"\" session=get_session() id=session.id created=session.created session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.invalidate() assert session.id !=id assert session.created !=created assert u'Suomi' not in session assert u'Great Britain' not in session assert u'Deutchland' not in session def test_regenerate_id(): \"\"\"Test:meth:`Session.regenerate_id`\"\"\" session=get_session(user_cookies=True) orig_id=session.id session[u'foo']=u'bar' assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] session.regenerate_id() assert session.id !=orig_id assert session[u'foo']==u'bar' assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] def test_timeout(): \"\"\"Test if the session times out properly\"\"\" session=get_session(timeout=2) id=session.id created=session.created session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.save() session=get_session(id=session.id, timeout=2) assert session.id==id assert session.created==created assert session[u'Suomi']==u'Kimi R\u00e4ikk\u00f6nen' assert session[u'Great Britain']==u'Jenson Button' assert session[u'Deutchland']==u'Sebastian Vettel' time.sleep(2) session=get_session(id=session.id, timeout=2) assert session.id !=id assert session.created !=created assert u'Suomi' not in session assert u'Great Britain' not in session assert u'Deutchland' not in session def test_cookies_enabled(): \"\"\" Test if cookies are sent out properly when ``use_cookies`` is set to ``True`` \"\"\" session=get_session(use_cookies=True) assert 'cookie_out' in session.request assert session.request['set_cookie']==False session.domain='example.com' session.path='\/example' assert session.request['set_cookie']==True assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] assert 'Domain=example.com' in session.request['cookie_out'] assert 'Path=\/' in session.request['cookie_out'] session=get_session(use_cookies=True) session.save() assert session.request['set_cookie']==True assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] session=get_session(use_cookies=True, id=session.id) session.delete() assert session.request['set_cookie']==True assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] assert 'expires=' in session.request['cookie_out'] session=get_session(use_cookies=True, secure=True) assert 'secure' in session.request['cookie_out'] class ShowWarning(object): def __init__(self): self.msg=None def __call__(self, message, category, filename, lineno, file=None, line=None): self.msg=str(message) orig_sw=warnings.showwarning sw=ShowWarning() warnings.showwarning=sw session=get_session(use_cookies=True, httponly=True) if sys.version_info <(2, 6): assert sw.msg=='Python 2.6+is required to use httponly' else: assert 'httponly' in session.request['cookie_out'] warnings.showwarning=orig_sw def test_cookies_disabled(): \"\"\" Test that no cookies are sent when ``use_cookies`` is set to ``False`` \"\"\" session=get_session(use_cookies=False) assert 'set_cookie' not in session.request assert 'cookie_out' not in session.request session.save() assert 'set_cookie' not in session.request assert 'cookie_out' not in session.request session=get_session(use_cookies=False, id=session.id) assert 'set_cookie' not in session.request assert 'cookie_out' not in session.request session.delete() assert 'set_cookie' not in session.request assert 'cookie_out' not in session.request def test_file_based_replace_optimization(): \"\"\"Test the file-based backend with session, which includes the 'replace' optimization. \"\"\" session=get_session(use_cookies=False, type='file', data_dir='.\/cache') session['foo']='foo' session['bar']='bar' session.save() session=get_session(use_cookies=False, type='file', data_dir='.\/cache', id=session.id) assert session['foo']=='foo' assert session['bar']=='bar' session['bar']='bat' session['bat']='hoho' session.save() session.namespace.do_open('c', False) session.namespace['test']='some test' session.namespace.do_close() session=get_session(use_cookies=False, type='file', data_dir='.\/cache', id=session.id) session.namespace.do_open('r', False) assert session.namespace['test']=='some test' session.namespace.do_close() assert session['foo']=='foo' assert session['bar']=='bat' assert session['bat']=='hoho' session.save() session.namespace.do_open('r', False) assert 'test' not in session.namespace session.namespace.do_close() def test_invalidate_corrupt(): session=get_session(use_cookies=False, type='file', data_dir='.\/cache') session['foo']='bar' session.save() f=open(session.namespace.file, 'w') f.write(\"crap\") f.close() util.assert_raises( util.pickle.UnpicklingError, get_session, use_cookies=False, type='file', data_dir='.\/cache', id=session.id ) session=get_session(use_cookies=False, type='file', invalidate_corrupt=True, data_dir='.\/cache', id=session.id) assert \"foo\" not in dict(session) ","sourceWithComments":"# -*- coding: utf-8 -*-\nimport sys\nimport time\nimport warnings\n\nfrom beaker.session import Session\nfrom beaker import util\n\n\ndef get_session(**kwargs):\n    \"\"\"A shortcut for creating :class:`Session` instance\"\"\"\n    options = {}\n    options.update(**kwargs)\n    return Session({}, **options)\n\n\ndef test_save_load():\n    \"\"\"Test if the data is actually persistent across requests\"\"\"\n    session = get_session()\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.save()\n\n    session = get_session(id=session.id)\n    assert u'Suomi' in session\n    assert u'Great Britain' in session\n    assert u'Deutchland' in session\n\n    assert session[u'Suomi'] == u'Kimi R\u00e4ikk\u00f6nen'\n    assert session[u'Great Britain'] == u'Jenson Button'\n    assert session[u'Deutchland'] == u'Sebastian Vettel'\n\n\ndef test_delete():\n    \"\"\"Test :meth:`Session.delete`\"\"\"\n    session = get_session()\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.delete()\n\n    assert u'Suomi' not in session\n    assert u'Great Britain' not in session\n    assert u'Deutchland' not in session\n\n\ndef test_revert():\n    \"\"\"Test :meth:`Session.revert`\"\"\"\n    session = get_session()\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.save()\n\n    session = get_session(id=session.id)\n    del session[u'Suomi']\n    session[u'Great Britain'] = u'Lewis Hamilton'\n    session[u'Deutchland'] = u'Michael Schumacher'\n    session[u'Espa\u00f1a'] = u'Fernando Alonso'\n    session.revert()\n\n    assert session[u'Suomi'] == u'Kimi R\u00e4ikk\u00f6nen'\n    assert session[u'Great Britain'] == u'Jenson Button'\n    assert session[u'Deutchland'] == u'Sebastian Vettel'\n    assert u'Espa\u00f1a' not in session\n\n\ndef test_invalidate():\n    \"\"\"Test :meth:`Session.invalidate`\"\"\"\n    session = get_session()\n    id = session.id\n    created = session.created\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.invalidate()\n\n    assert session.id != id\n    assert session.created != created\n    assert u'Suomi' not in session\n    assert u'Great Britain' not in session\n    assert u'Deutchland' not in session\n\n\ndef test_regenerate_id():\n    \"\"\"Test :meth:`Session.regenerate_id`\"\"\"\n    session = get_session(user_cookies=True)\n    orig_id = session.id\n    session[u'foo'] = u'bar'\n\n    # cookie should be there\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n\n    session.regenerate_id()\n\n    assert session.id != orig_id\n    assert session[u'foo'] == u'bar'\n\n    # should be the new id\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n\n\ndef test_timeout():\n    \"\"\"Test if the session times out properly\"\"\"\n    session = get_session(timeout=2)\n    id = session.id\n    created = session.created\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.save()\n\n    session = get_session(id=session.id, timeout=2)\n    assert session.id == id\n    assert session.created == created\n    assert session[u'Suomi'] == u'Kimi R\u00e4ikk\u00f6nen'\n    assert session[u'Great Britain'] == u'Jenson Button'\n    assert session[u'Deutchland'] == u'Sebastian Vettel'\n\n    time.sleep(2)\n    session = get_session(id=session.id, timeout=2)\n    assert session.id != id\n    assert session.created != created\n    assert u'Suomi' not in session\n    assert u'Great Britain' not in session\n    assert u'Deutchland' not in session\n\n\ndef test_cookies_enabled():\n    \"\"\"\n    Test if cookies are sent out properly when ``use_cookies``\n    is set to ``True``\n    \"\"\"\n    session = get_session(use_cookies=True)\n    assert 'cookie_out' in session.request\n    assert session.request['set_cookie'] == False\n\n    session.domain = 'example.com'\n    session.path = '\/example'\n    assert session.request['set_cookie'] == True\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n    assert 'Domain=example.com' in session.request['cookie_out']\n    assert 'Path=\/' in session.request['cookie_out']\n\n    session = get_session(use_cookies=True)\n    session.save()\n    assert session.request['set_cookie'] == True\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n\n    session = get_session(use_cookies=True, id=session.id)\n    session.delete()\n    assert session.request['set_cookie'] == True\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n    assert 'expires=' in session.request['cookie_out']\n\n    # test for secure\n    session = get_session(use_cookies=True, secure=True)\n    assert 'secure' in session.request['cookie_out']\n\n    # test for httponly\n    class ShowWarning(object):\n        def __init__(self):\n            self.msg = None\n        def __call__(self, message, category, filename, lineno, file=None, line=None):\n            self.msg = str(message)\n    orig_sw = warnings.showwarning\n    sw = ShowWarning()\n    warnings.showwarning = sw\n    session = get_session(use_cookies=True, httponly=True)\n    if sys.version_info < (2, 6):\n        assert sw.msg == 'Python 2.6+ is required to use httponly'\n    else:\n        assert 'httponly' in session.request['cookie_out']\n    warnings.showwarning = orig_sw\n\ndef test_cookies_disabled():\n    \"\"\"\n    Test that no cookies are sent when ``use_cookies`` is set to ``False``\n    \"\"\"\n    session = get_session(use_cookies=False)\n    assert 'set_cookie' not in session.request\n    assert 'cookie_out' not in session.request\n\n    session.save()\n    assert 'set_cookie' not in session.request\n    assert 'cookie_out' not in session.request\n\n    session = get_session(use_cookies=False, id=session.id)\n    assert 'set_cookie' not in session.request\n    assert 'cookie_out' not in session.request\n\n    session.delete()\n    assert 'set_cookie' not in session.request\n    assert 'cookie_out' not in session.request\n\n\ndef test_file_based_replace_optimization():\n    \"\"\"Test the file-based backend with session,\n    which includes the 'replace' optimization.\n\n    \"\"\"\n\n    session = get_session(use_cookies=False, type='file',\n                            data_dir='.\/cache')\n\n    session['foo'] = 'foo'\n    session['bar'] = 'bar'\n    session.save()\n\n    session = get_session(use_cookies=False, type='file',\n                            data_dir='.\/cache', id=session.id)\n    assert session['foo'] == 'foo'\n    assert session['bar'] == 'bar'\n\n    session['bar'] = 'bat'\n    session['bat'] = 'hoho'\n    session.save()\n\n    session.namespace.do_open('c', False)\n    session.namespace['test'] = 'some test'\n    session.namespace.do_close()\n\n    session = get_session(use_cookies=False, type='file',\n                            data_dir='.\/cache', id=session.id)\n\n    session.namespace.do_open('r', False)\n    assert session.namespace['test'] == 'some test'\n    session.namespace.do_close()\n\n    assert session['foo'] == 'foo'\n    assert session['bar'] == 'bat'\n    assert session['bat'] == 'hoho'\n    session.save()\n\n    # the file has been replaced, so our out-of-session\n    # key is gone\n    session.namespace.do_open('r', False)\n    assert 'test' not in session.namespace\n    session.namespace.do_close()\n\n\ndef test_invalidate_corrupt():\n    session = get_session(use_cookies=False, type='file',\n                            data_dir='.\/cache')\n    session['foo'] = 'bar'\n    session.save()\n\n    f = open(session.namespace.file, 'w')\n    f.write(\"crap\")\n    f.close()\n\n    util.assert_raises(\n        util.pickle.UnpicklingError,\n        get_session,\n        use_cookies=False, type='file',\n                data_dir='.\/cache', id=session.id\n    )\n\n    session = get_session(use_cookies=False, type='file',\n                            invalidate_corrupt=True,\n                            data_dir='.\/cache', id=session.id)\n    assert \"foo\" not in dict(session)\n"}},"msg":"adding tests for previous fix\n\nEven though I added the changes first, I backed them out after\ncommit to make sure this test fails.  Then put them back in and\nthe test passes.\n\n#75 Session.regenerate_id() needed to help avoid session hijacking\n\n--HG--\nbranch : trunk"}},"https:\/\/github.com\/DataDog\/beaker":{"f77f92a31a8f3a271ff518384bc9985116f1bc83":{"url":"https:\/\/api.github.com\/repos\/DataDog\/beaker\/commits\/f77f92a31a8f3a271ff518384bc9985116f1bc83","html_url":"https:\/\/github.com\/DataDog\/beaker\/commit\/f77f92a31a8f3a271ff518384bc9985116f1bc83","message":"adding tests for previous fix\n\nEven though I added the changes first, I backed them out after\ncommit to make sure this test fails.  Then put them back in and\nthe test passes.\n\n#75 Session.regenerate_id() needed to help avoid session hijacking\n\n--HG--\nbranch : trunk","sha":"f77f92a31a8f3a271ff518384bc9985116f1bc83","keyword":"session hijacking change","diff":"diff --git a\/tests\/test_session.py b\/tests\/test_session.py\nindex 3c0670a..bc1adc1 100644\n--- a\/tests\/test_session.py\n+++ b\/tests\/test_session.py\n@@ -85,21 +85,39 @@ def test_invalidate():\n \n def test_regenerate_id():\n     \"\"\"Test :meth:`Session.regenerate_id`\"\"\"\n-    session = get_session(user_cookies=True)\n+    # new session & save\n+    session = get_session()\n     orig_id = session.id\n     session[u'foo'] = u'bar'\n+    session.save()\n \n-    # cookie should be there\n-    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n+    # load session\n+    session = get_session(id=session.id)\n+    # data should still be there\n+    assert session[u'foo'] == u'bar'\n \n+    # regenerate the id\n     session.regenerate_id()\n \n     assert session.id != orig_id\n+\n+    # data is still there\n     assert session[u'foo'] == u'bar'\n \n     # should be the new id\n     assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n \n+    # get a new session before calling save\n+    bunk_sess = get_session(id=session.id)\n+    assert u'foo' not in bunk_sess\n+\n+    # save it\n+    session.save()\n+\n+    # make sure we get the data back\n+    session = get_session(id=session.id)\n+    assert session[u'foo'] == u'bar'\n+\n \n def test_timeout():\n     \"\"\"Test if the session times out properly\"\"\"\n","files":{"\/tests\/test_session.py":{"changes":[{"diff":"\n \n def test_regenerate_id():\n     \"\"\"Test :meth:`Session.regenerate_id`\"\"\"\n-    session = get_session(user_cookies=True)\n+    # new session & save\n+    session = get_session()\n     orig_id = session.id\n     session[u'foo'] = u'bar'\n+    session.save()\n \n-    # cookie should be there\n-    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n+    # load session\n+    session = get_session(id=session.id)\n+    # data should still be there\n+    assert session[u'foo'] == u'bar'\n \n+    # regenerate the id\n     session.regenerate_id()\n \n     assert session.id != orig_id\n+\n+    # data is still there\n     assert session[u'foo'] == u'bar'\n \n     # should be the new id\n     assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n \n+    # get a new session before calling save\n+    bunk_sess = get_session(id=session.id)\n+    assert u'foo' not in bunk_sess\n+\n+    # save it\n+    session.save()\n+\n+    # make sure we get the data back\n+    session = get_session(id=session.id)\n+    assert session[u'foo'] == u'bar'\n+\n \n def test_timeout():\n     \"\"\"Test if the session times out properly\"\"\"\n","add":21,"remove":3,"filename":"\/tests\/test_session.py","badparts":["    session = get_session(user_cookies=True)","    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']"],"goodparts":["    session = get_session()","    session.save()","    session = get_session(id=session.id)","    assert session[u'foo'] == u'bar'","    bunk_sess = get_session(id=session.id)","    assert u'foo' not in bunk_sess","    session.save()","    session = get_session(id=session.id)","    assert session[u'foo'] == u'bar'"]}],"source":"\n\nimport sys import time import warnings from beaker.session import Session from beaker import util def get_session(**kwargs): \"\"\"A shortcut for creating:class:`Session` instance\"\"\" options={} options.update(**kwargs) return Session({}, **options) def test_save_load(): \"\"\"Test if the data is actually persistent across requests\"\"\" session=get_session() session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.save() session=get_session(id=session.id) assert u'Suomi' in session assert u'Great Britain' in session assert u'Deutchland' in session assert session[u'Suomi']==u'Kimi R\u00e4ikk\u00f6nen' assert session[u'Great Britain']==u'Jenson Button' assert session[u'Deutchland']==u'Sebastian Vettel' def test_delete(): \"\"\"Test:meth:`Session.delete`\"\"\" session=get_session() session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.delete() assert u'Suomi' not in session assert u'Great Britain' not in session assert u'Deutchland' not in session def test_revert(): \"\"\"Test:meth:`Session.revert`\"\"\" session=get_session() session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.save() session=get_session(id=session.id) del session[u'Suomi'] session[u'Great Britain']=u'Lewis Hamilton' session[u'Deutchland']=u'Michael Schumacher' session[u'Espa\u00f1a']=u'Fernando Alonso' session.revert() assert session[u'Suomi']==u'Kimi R\u00e4ikk\u00f6nen' assert session[u'Great Britain']==u'Jenson Button' assert session[u'Deutchland']==u'Sebastian Vettel' assert u'Espa\u00f1a' not in session def test_invalidate(): \"\"\"Test:meth:`Session.invalidate`\"\"\" session=get_session() id=session.id created=session.created session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.invalidate() assert session.id !=id assert session.created !=created assert u'Suomi' not in session assert u'Great Britain' not in session assert u'Deutchland' not in session def test_regenerate_id(): \"\"\"Test:meth:`Session.regenerate_id`\"\"\" session=get_session(user_cookies=True) orig_id=session.id session[u'foo']=u'bar' assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] session.regenerate_id() assert session.id !=orig_id assert session[u'foo']==u'bar' assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] def test_timeout(): \"\"\"Test if the session times out properly\"\"\" session=get_session(timeout=2) id=session.id created=session.created session[u'Suomi']=u'Kimi R\u00e4ikk\u00f6nen' session[u'Great Britain']=u'Jenson Button' session[u'Deutchland']=u'Sebastian Vettel' session.save() session=get_session(id=session.id, timeout=2) assert session.id==id assert session.created==created assert session[u'Suomi']==u'Kimi R\u00e4ikk\u00f6nen' assert session[u'Great Britain']==u'Jenson Button' assert session[u'Deutchland']==u'Sebastian Vettel' time.sleep(2) session=get_session(id=session.id, timeout=2) assert session.id !=id assert session.created !=created assert u'Suomi' not in session assert u'Great Britain' not in session assert u'Deutchland' not in session def test_cookies_enabled(): \"\"\" Test if cookies are sent out properly when ``use_cookies`` is set to ``True`` \"\"\" session=get_session(use_cookies=True) assert 'cookie_out' in session.request assert session.request['set_cookie']==False session.domain='example.com' session.path='\/example' assert session.request['set_cookie']==True assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] assert 'Domain=example.com' in session.request['cookie_out'] assert 'Path=\/' in session.request['cookie_out'] session=get_session(use_cookies=True) session.save() assert session.request['set_cookie']==True assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] session=get_session(use_cookies=True, id=session.id) session.delete() assert session.request['set_cookie']==True assert 'beaker.session.id=%s' % session.id in session.request['cookie_out'] assert 'expires=' in session.request['cookie_out'] session=get_session(use_cookies=True, secure=True) assert 'secure' in session.request['cookie_out'] class ShowWarning(object): def __init__(self): self.msg=None def __call__(self, message, category, filename, lineno, file=None, line=None): self.msg=str(message) orig_sw=warnings.showwarning sw=ShowWarning() warnings.showwarning=sw session=get_session(use_cookies=True, httponly=True) if sys.version_info <(2, 6): assert sw.msg=='Python 2.6+is required to use httponly' else: assert 'httponly' in session.request['cookie_out'] warnings.showwarning=orig_sw def test_cookies_disabled(): \"\"\" Test that no cookies are sent when ``use_cookies`` is set to ``False`` \"\"\" session=get_session(use_cookies=False) assert 'set_cookie' not in session.request assert 'cookie_out' not in session.request session.save() assert 'set_cookie' not in session.request assert 'cookie_out' not in session.request session=get_session(use_cookies=False, id=session.id) assert 'set_cookie' not in session.request assert 'cookie_out' not in session.request session.delete() assert 'set_cookie' not in session.request assert 'cookie_out' not in session.request def test_file_based_replace_optimization(): \"\"\"Test the file-based backend with session, which includes the 'replace' optimization. \"\"\" session=get_session(use_cookies=False, type='file', data_dir='.\/cache') session['foo']='foo' session['bar']='bar' session.save() session=get_session(use_cookies=False, type='file', data_dir='.\/cache', id=session.id) assert session['foo']=='foo' assert session['bar']=='bar' session['bar']='bat' session['bat']='hoho' session.save() session.namespace.do_open('c', False) session.namespace['test']='some test' session.namespace.do_close() session=get_session(use_cookies=False, type='file', data_dir='.\/cache', id=session.id) session.namespace.do_open('r', False) assert session.namespace['test']=='some test' session.namespace.do_close() assert session['foo']=='foo' assert session['bar']=='bat' assert session['bat']=='hoho' session.save() session.namespace.do_open('r', False) assert 'test' not in session.namespace session.namespace.do_close() def test_invalidate_corrupt(): session=get_session(use_cookies=False, type='file', data_dir='.\/cache') session['foo']='bar' session.save() f=open(session.namespace.file, 'w') f.write(\"crap\") f.close() util.assert_raises( util.pickle.UnpicklingError, get_session, use_cookies=False, type='file', data_dir='.\/cache', id=session.id ) session=get_session(use_cookies=False, type='file', invalidate_corrupt=True, data_dir='.\/cache', id=session.id) assert \"foo\" not in dict(session) ","sourceWithComments":"# -*- coding: utf-8 -*-\nimport sys\nimport time\nimport warnings\n\nfrom beaker.session import Session\nfrom beaker import util\n\n\ndef get_session(**kwargs):\n    \"\"\"A shortcut for creating :class:`Session` instance\"\"\"\n    options = {}\n    options.update(**kwargs)\n    return Session({}, **options)\n\n\ndef test_save_load():\n    \"\"\"Test if the data is actually persistent across requests\"\"\"\n    session = get_session()\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.save()\n\n    session = get_session(id=session.id)\n    assert u'Suomi' in session\n    assert u'Great Britain' in session\n    assert u'Deutchland' in session\n\n    assert session[u'Suomi'] == u'Kimi R\u00e4ikk\u00f6nen'\n    assert session[u'Great Britain'] == u'Jenson Button'\n    assert session[u'Deutchland'] == u'Sebastian Vettel'\n\n\ndef test_delete():\n    \"\"\"Test :meth:`Session.delete`\"\"\"\n    session = get_session()\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.delete()\n\n    assert u'Suomi' not in session\n    assert u'Great Britain' not in session\n    assert u'Deutchland' not in session\n\n\ndef test_revert():\n    \"\"\"Test :meth:`Session.revert`\"\"\"\n    session = get_session()\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.save()\n\n    session = get_session(id=session.id)\n    del session[u'Suomi']\n    session[u'Great Britain'] = u'Lewis Hamilton'\n    session[u'Deutchland'] = u'Michael Schumacher'\n    session[u'Espa\u00f1a'] = u'Fernando Alonso'\n    session.revert()\n\n    assert session[u'Suomi'] == u'Kimi R\u00e4ikk\u00f6nen'\n    assert session[u'Great Britain'] == u'Jenson Button'\n    assert session[u'Deutchland'] == u'Sebastian Vettel'\n    assert u'Espa\u00f1a' not in session\n\n\ndef test_invalidate():\n    \"\"\"Test :meth:`Session.invalidate`\"\"\"\n    session = get_session()\n    id = session.id\n    created = session.created\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.invalidate()\n\n    assert session.id != id\n    assert session.created != created\n    assert u'Suomi' not in session\n    assert u'Great Britain' not in session\n    assert u'Deutchland' not in session\n\n\ndef test_regenerate_id():\n    \"\"\"Test :meth:`Session.regenerate_id`\"\"\"\n    session = get_session(user_cookies=True)\n    orig_id = session.id\n    session[u'foo'] = u'bar'\n\n    # cookie should be there\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n\n    session.regenerate_id()\n\n    assert session.id != orig_id\n    assert session[u'foo'] == u'bar'\n\n    # should be the new id\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n\n\ndef test_timeout():\n    \"\"\"Test if the session times out properly\"\"\"\n    session = get_session(timeout=2)\n    id = session.id\n    created = session.created\n    session[u'Suomi'] = u'Kimi R\u00e4ikk\u00f6nen'\n    session[u'Great Britain'] = u'Jenson Button'\n    session[u'Deutchland'] = u'Sebastian Vettel'\n    session.save()\n\n    session = get_session(id=session.id, timeout=2)\n    assert session.id == id\n    assert session.created == created\n    assert session[u'Suomi'] == u'Kimi R\u00e4ikk\u00f6nen'\n    assert session[u'Great Britain'] == u'Jenson Button'\n    assert session[u'Deutchland'] == u'Sebastian Vettel'\n\n    time.sleep(2)\n    session = get_session(id=session.id, timeout=2)\n    assert session.id != id\n    assert session.created != created\n    assert u'Suomi' not in session\n    assert u'Great Britain' not in session\n    assert u'Deutchland' not in session\n\n\ndef test_cookies_enabled():\n    \"\"\"\n    Test if cookies are sent out properly when ``use_cookies``\n    is set to ``True``\n    \"\"\"\n    session = get_session(use_cookies=True)\n    assert 'cookie_out' in session.request\n    assert session.request['set_cookie'] == False\n\n    session.domain = 'example.com'\n    session.path = '\/example'\n    assert session.request['set_cookie'] == True\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n    assert 'Domain=example.com' in session.request['cookie_out']\n    assert 'Path=\/' in session.request['cookie_out']\n\n    session = get_session(use_cookies=True)\n    session.save()\n    assert session.request['set_cookie'] == True\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n\n    session = get_session(use_cookies=True, id=session.id)\n    session.delete()\n    assert session.request['set_cookie'] == True\n    assert 'beaker.session.id=%s' % session.id in session.request['cookie_out']\n    assert 'expires=' in session.request['cookie_out']\n\n    # test for secure\n    session = get_session(use_cookies=True, secure=True)\n    assert 'secure' in session.request['cookie_out']\n\n    # test for httponly\n    class ShowWarning(object):\n        def __init__(self):\n            self.msg = None\n        def __call__(self, message, category, filename, lineno, file=None, line=None):\n            self.msg = str(message)\n    orig_sw = warnings.showwarning\n    sw = ShowWarning()\n    warnings.showwarning = sw\n    session = get_session(use_cookies=True, httponly=True)\n    if sys.version_info < (2, 6):\n        assert sw.msg == 'Python 2.6+ is required to use httponly'\n    else:\n        assert 'httponly' in session.request['cookie_out']\n    warnings.showwarning = orig_sw\n\ndef test_cookies_disabled():\n    \"\"\"\n    Test that no cookies are sent when ``use_cookies`` is set to ``False``\n    \"\"\"\n    session = get_session(use_cookies=False)\n    assert 'set_cookie' not in session.request\n    assert 'cookie_out' not in session.request\n\n    session.save()\n    assert 'set_cookie' not in session.request\n    assert 'cookie_out' not in session.request\n\n    session = get_session(use_cookies=False, id=session.id)\n    assert 'set_cookie' not in session.request\n    assert 'cookie_out' not in session.request\n\n    session.delete()\n    assert 'set_cookie' not in session.request\n    assert 'cookie_out' not in session.request\n\n\ndef test_file_based_replace_optimization():\n    \"\"\"Test the file-based backend with session,\n    which includes the 'replace' optimization.\n\n    \"\"\"\n\n    session = get_session(use_cookies=False, type='file',\n                            data_dir='.\/cache')\n\n    session['foo'] = 'foo'\n    session['bar'] = 'bar'\n    session.save()\n\n    session = get_session(use_cookies=False, type='file',\n                            data_dir='.\/cache', id=session.id)\n    assert session['foo'] == 'foo'\n    assert session['bar'] == 'bar'\n\n    session['bar'] = 'bat'\n    session['bat'] = 'hoho'\n    session.save()\n\n    session.namespace.do_open('c', False)\n    session.namespace['test'] = 'some test'\n    session.namespace.do_close()\n\n    session = get_session(use_cookies=False, type='file',\n                            data_dir='.\/cache', id=session.id)\n\n    session.namespace.do_open('r', False)\n    assert session.namespace['test'] == 'some test'\n    session.namespace.do_close()\n\n    assert session['foo'] == 'foo'\n    assert session['bar'] == 'bat'\n    assert session['bat'] == 'hoho'\n    session.save()\n\n    # the file has been replaced, so our out-of-session\n    # key is gone\n    session.namespace.do_open('r', False)\n    assert 'test' not in session.namespace\n    session.namespace.do_close()\n\n\ndef test_invalidate_corrupt():\n    session = get_session(use_cookies=False, type='file',\n                            data_dir='.\/cache')\n    session['foo'] = 'bar'\n    session.save()\n\n    f = open(session.namespace.file, 'w')\n    f.write(\"crap\")\n    f.close()\n\n    util.assert_raises(\n        util.pickle.UnpicklingError,\n        get_session,\n        use_cookies=False, type='file',\n                data_dir='.\/cache', id=session.id\n    )\n\n    session = get_session(use_cookies=False, type='file',\n                            invalidate_corrupt=True,\n                            data_dir='.\/cache', id=session.id)\n    assert \"foo\" not in dict(session)\n"}},"msg":"adding tests for previous fix\n\nEven though I added the changes first, I backed them out after\ncommit to make sure this test fails.  Then put them back in and\nthe test passes.\n\n#75 Session.regenerate_id() needed to help avoid session hijacking\n\n--HG--\nbranch : trunk"}},"https:\/\/github.com\/Solaireis\/CWC-ISPJ":{"b554f3d3248b58dd0e38924d315339ddb3124dec":{"url":"https:\/\/api.github.com\/repos\/Solaireis\/CWC-ISPJ\/commits\/b554f3d3248b58dd0e38924d315339ddb3124dec","html_url":"https:\/\/github.com\/Solaireis\/CWC-ISPJ\/commit\/b554f3d3248b58dd0e38924d315339ddb3124dec","message":"added more checks to the session to prevent session hijacking","sha":"b554f3d3248b58dd0e38924d315339ddb3124dec","keyword":"session hijacking check","diff":"diff --git a\/src\/app\/routers\/api\/admin.py b\/src\/app\/routers\/api\/admin.py\nindex 606df97d..ced1d93b 100644\n--- a\/src\/app\/routers\/api\/admin.py\n+++ b\/src\/app\/routers\/api\/admin.py\n@@ -46,6 +46,7 @@\n #     if request.session.get(C.SESSION_COOKIE) is not None:\n #         try:\n #             current_user = await mongo.get_user_from_session(\n+#                 request=request,\n #                 session_id=request.session[C.SESSION_COOKIE], \n #                 col=col,\n #             )\ndiff --git a\/src\/app\/routers\/api\/users.py b\/src\/app\/routers\/api\/users.py\nindex 8d2bcc03..22fdadfd 100644\n--- a\/src\/app\/routers\/api\/users.py\n+++ b\/src\/app\/routers\/api\/users.py\n@@ -138,6 +138,7 @@ async def edit_profile(request: Request, data: schemas.EditProfile):\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -289,6 +290,7 @@ async def edit_profile_picture(\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -329,6 +331,7 @@ async def reset_profile_picture(request: Request):\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -416,6 +419,7 @@ async def edit_banner_picture(\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -457,6 +461,7 @@ async def reset_banner_picture(request: Request):\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -539,6 +544,7 @@ async def upload_post(\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     author = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -573,6 +579,7 @@ async def get_upload_id(request: Request, data: schemas.GetUploadId):\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -710,6 +717,7 @@ async def upload_chat_file(\n     receiver = bson.ObjectId(receiver)\n     user_col = db[C.USER_COLLECTION]\n     sender_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=user_col,\n     )\n@@ -842,6 +850,7 @@ async def forgot_chat_password_token(request: Request, token: str):\n     db = mongo.get_db_client()\n     user_col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=user_col,\n     )\n@@ -898,7 +907,10 @@ async def forgot_chat_password(request: Request, data: schemas.RecaptchaToken):\n             }\n         )\n \n-    user_doc = await mongo.get_user_from_session(request.session[C.SESSION_COOKIE])\n+    user_doc = await mongo.get_user_from_session(\n+        request=request,\n+        session_id=request.session[C.SESSION_COOKIE]\n+    )\n     if user_doc is None:\n         request.session.clear()\n         return ORJSONResponse(\n@@ -938,6 +950,7 @@ async def chat_update_settings(request: Request, data: schemas.ChatPrivacy):\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -1017,6 +1030,7 @@ async def chat_update_password(request: Request, data: schemas.ChatPassword):\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -1138,6 +1152,7 @@ async def chat_ws(websocket: WebSocket, receiver_uid: str):\n \n     sender_session_id = websocket.session[C.SESSION_COOKIE]\n     sender_user_doc = await mongo.get_user_from_session(\n+        request=websocket,\n         session_id=sender_session_id,\n         col=user_col,\n     )\n@@ -1566,6 +1581,7 @@ async def toggle_email_2fa(request: Request):\n     db = mongo.get_db_client()\n     user_col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=user_col,\n     )\n@@ -1616,6 +1632,7 @@ async def generate_backup_code(request: Request, data: schemas.RecaptchaToken):\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -1644,6 +1661,7 @@ async def generate_two_fa_token(request: Request):\n     db = mongo.get_db_client()\n     user_col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=user_col,\n     )\n@@ -1674,6 +1692,7 @@ async def remove_two_fa_token(request: Request):\n     db = mongo.get_db_client()\n     user_col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=user_col,\n     )\n@@ -1708,6 +1727,7 @@ async def set_two_fa_token(request: Request, data: schemas.SetTwoFAToken):\n     db = mongo.get_db_client()\n     user_col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=user_col,\n     )\ndiff --git a\/src\/app\/routers\/web\/admin.py b\/src\/app\/routers\/web\/admin.py\nindex eb8f1728..196ed00c 100644\n--- a\/src\/app\/routers\/web\/admin.py\n+++ b\/src\/app\/routers\/web\/admin.py\n@@ -41,6 +41,7 @@ async def admin_db(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\n@@ -95,6 +96,7 @@ async def admin_user_list(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\n@@ -145,6 +147,7 @@ async def admin_reports(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\n@@ -195,6 +198,7 @@ async def admin_ban(request: Request, username: str):\n         if request.session.get(C.SESSION_COOKIE) is not None:\n             try:\n                 current_user = await mongo.get_user_from_session(\n+                    request=request,\n                     session_id=request.session[C.SESSION_COOKIE], \n                     col=col,\n                 )\ndiff --git a\/src\/app\/routers\/web\/general.py b\/src\/app\/routers\/web\/general.py\nindex 6e778323..d8386535 100644\n--- a\/src\/app\/routers\/web\/general.py\n+++ b\/src\/app\/routers\/web\/general.py\n@@ -26,6 +26,7 @@ async def index(request: Request):\n         col = db[C.USER_COLLECTION]\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\ndiff --git a\/src\/app\/routers\/web\/maintenance.py b\/src\/app\/routers\/web\/maintenance.py\nindex 4867dd36..0de4941a 100644\n--- a\/src\/app\/routers\/web\/maintenance.py\n+++ b\/src\/app\/routers\/web\/maintenance.py\n@@ -41,6 +41,7 @@ async def maintenance_db(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\n@@ -83,6 +84,7 @@ async def maintenance_create_admin(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\n@@ -131,6 +133,7 @@ async def get_admin(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\ndiff --git a\/src\/app\/routers\/web\/super_root.py b\/src\/app\/routers\/web\/super_root.py\nindex aee95fa6..8bef4552 100644\n--- a\/src\/app\/routers\/web\/super_root.py\n+++ b\/src\/app\/routers\/web\/super_root.py\n@@ -40,6 +40,7 @@ async def sroot_db(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\n@@ -82,6 +83,7 @@ async def create_maintenance(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\n@@ -130,6 +132,7 @@ async def get_root(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\ndiff --git a\/src\/app\/routers\/web\/users.py b\/src\/app\/routers\/web\/users.py\nindex 18fccec1..89d9f3c4 100644\n--- a\/src\/app\/routers\/web\/users.py\n+++ b\/src\/app\/routers\/web\/users.py\n@@ -39,6 +39,7 @@ async def chat_1_to_1(request: Request, receiver_uid: str):\n         return RedirectResponse(url=useful.url_for(request, \"chat\"))\n \n     sender_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -63,6 +64,7 @@ async def chat(request: Request):\n     db = mongo.get_db_client()\n     col = db[C.USER_COLLECTION]\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=col,\n     )\n@@ -113,6 +115,7 @@ async def profile(request: Request, username: str):\n     if request.session.get(C.SESSION_COOKIE) is not None:\n         try:\n             current_user = await mongo.get_user_from_session(\n+                request=request,\n                 session_id=request.session[C.SESSION_COOKIE], \n                 col=col,\n             )\n@@ -176,6 +179,7 @@ async def followers(request:Request, follower_type:str):\n     user_collection = db[C.USER_COLLECTION]\n \n     user = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n         col=user_collection\n     )\n@@ -202,6 +206,7 @@ async def followers(request:Request, follower_type:str):\n @rbac.USER_RBAC()\n async def two_fa_settings(request: Request):\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n     )\n \n@@ -218,6 +223,7 @@ async def two_fa_settings(request: Request):\n @rbac.USER_RBAC()\n async def two_fa_settings(request: Request):\n     user_doc = await mongo.get_user_from_session(\n+        request=request,\n         session_id=request.session[C.SESSION_COOKIE],\n     )\n \ndiff --git a\/src\/app\/utils\/functions\/database.py b\/src\/app\/utils\/functions\/database.py\nindex 4cbd5ba2..28bc115e 100644\n--- a\/src\/app\/utils\/functions\/database.py\n+++ b\/src\/app\/utils\/functions\/database.py\n@@ -1,5 +1,5 @@\n # import third-party libraries\n-from fastapi import Request\n+from fastapi import Request, WebSocket\n import pymongo\n import bson\n from dicebear import DAvatar, DStyle\n@@ -9,8 +9,8 @@\n \n # import local Python libraries\n from utils import constants as C\n+from .useful import get_location_str\n from gcp import SECRET_MANAGER\n-import schemas\n \n # import Python's standard libraries\n import urllib.parse as urlparse\n@@ -134,10 +134,12 @@ def get_db_client(get_default: bool | None = True,\n         )\n     return client[C.DB_NAME] if get_default else client\n \n-async def get_user_from_session(session_id: str, col: Collection = None) -> dict | None:\n+async def get_user_from_session(request: Request | WebSocket, session_id: str, col: Collection = None) -> dict | None:\n     \"\"\"Get the user document from the session ID.\n \n     Args:\n+        request (Request | WebSocket):\n+            The request or websocket object.\n         session_id (str):\n             The session ID.\n         col (Collection, optional):\n@@ -153,9 +155,11 @@ async def get_user_from_session(session_id: str, col: Collection = None) -> dict\n         col = db[C.USER_COLLECTION]\n \n     time_now = datetime.utcnow()\n+    user_location = get_location_str(request)\n     user_doc: dict | None = await col.find_one({\n         \"sessions.session_id\": session_id, \n         \"sessions.expiry_date\": {\"$gt\": time_now},\n+        \"sessions.location\": user_location,\n     })\n     return user_doc\n \n@@ -174,7 +178,11 @@ async def get_user_role(request: Request, session_id: str, col: Collection = Non\n     if session_id is None:\n         return default\n \n-    user_doc = await get_user_from_session(session_id, col)\n+    user_doc = await get_user_from_session(\n+        request=request,\n+        session_id=session_id, \n+        col=col,\n+    )\n     if user_doc is None:\n         # The session ID is invalid\n         request.session.pop(C.SESSION_COOKIE)\ndiff --git a\/src\/app\/utils\/functions\/useful.py b\/src\/app\/utils\/functions\/useful.py\nindex a409485d..3dee4fac 100644\n--- a\/src\/app\/utils\/functions\/useful.py\n+++ b\/src\/app\/utils\/functions\/useful.py\n@@ -4,7 +4,7 @@\n import orjson\n from pydantic import BaseModel, HttpUrl\n from pydantic.error_wrappers import ValidationError\n-from fastapi import Request, FastAPI\n+from fastapi import Request, FastAPI, WebSocket\n from fastapi.exceptions import HTTPException\n \n # import local Python libraries\n@@ -53,12 +53,12 @@ def truncate_text(text: str, max_length: int = 20) -> str:\n         return text[:max_length].strip() + \"...\"\n     return text\n \n-def get_location_str(request: Request, get_parts: bool | None = False) -> str | tuple[str, str, str]:\n+def get_location_str(request: Request | WebSocket, get_parts: bool | None = False) -> str | tuple[str, str, str]:\n     \"\"\"Gets the location string from the request headers (Cloudflare proxy)\n \n     Args:\n-        request (Request):\n-            The request object.\n+        request (Request | WebSocket):\n+            The request or websocket to get the location string from.\n         get_parts (bool, Optional):\n             Whether to return the city, country, and location string as a tuple.\n             Defaults to False.\n","files":{"\/src\/app\/routers\/api\/users.py":{"changes":[{"diff":"\n             }\n         )\n \n-    user_doc = await mongo.get_user_from_session(request.session[C.SESSION_COOKIE])\n+    user_doc = await mongo.get_user_from_session(\n+        request=request,\n+        session_id=request.session[C.SESSION_COOKIE]\n+    )\n     if user_doc is None:\n         request.session.clear()\n         return ORJSONResponse(\n","add":4,"remove":1,"filename":"\/src\/app\/routers\/api\/users.py","badparts":["    user_doc = await mongo.get_user_from_session(request.session[C.SESSION_COOKIE])"],"goodparts":["    user_doc = await mongo.get_user_from_session(","        request=request,","        session_id=request.session[C.SESSION_COOKIE]","    )"]}]},"\/src\/app\/utils\/functions\/database.py":{"changes":[{"diff":"\n # import third-party libraries\n-from fastapi import Request\n+from fastapi import Request, WebSocket\n import pymongo\n import bson\n from dicebear import DAvatar, DStyle\n","add":1,"remove":1,"filename":"\/src\/app\/utils\/functions\/database.py","badparts":["from fastapi import Request"],"goodparts":["from fastapi import Request, WebSocket"]},{"diff":"\n # import local Python libraries\n from utils import constants as C\n+from .useful import get_location_str\n from gcp import SECRET_MANAGER\n-import schemas\n \n # import Python's standard libraries\n import urllib.parse as urlparse\n","add":1,"remove":1,"filename":"\/src\/app\/utils\/functions\/database.py","badparts":["import schemas"],"goodparts":["from .useful import get_location_str"]},{"diff":"\n         )\n     return client[C.DB_NAME] if get_default else client\n \n-async def get_user_from_session(session_id: str, col: Collection = None) -> dict | None:\n+async def get_user_from_session(request: Request | WebSocket, session_id: str, col: Collection = None) -> dict | None:\n     \"\"\"Get the user document from the session ID.\n \n     Args:\n+        request (Request | WebSocket):\n+            The request or websocket object.\n         session_id (str):\n             The session ID.\n         col (Collection, optional):\n","add":3,"remove":1,"filename":"\/src\/app\/utils\/functions\/database.py","badparts":["async def get_user_from_session(session_id: str, col: Collection = None) -> dict | None:"],"goodparts":["async def get_user_from_session(request: Request | WebSocket, session_id: str, col: Collection = None) -> dict | None:","        request (Request | WebSocket):","            The request or websocket object."]},{"diff":"\n     if session_id is None:\n         return default\n \n-    user_doc = await get_user_from_session(session_id, col)\n+    user_doc = await get_user_from_session(\n+        request=request,\n+        session_id=session_id, \n+        col=col,\n+    )\n     if user_doc is None:\n         # The session ID is invalid\n         request.session.pop(C.SESSION_","add":5,"remove":1,"filename":"\/src\/app\/utils\/functions\/database.py","badparts":["    user_doc = await get_user_from_session(session_id, col)"],"goodparts":["    user_doc = await get_user_from_session(","        request=request,","        session_id=session_id, ","        col=col,","    )"]}],"source":"\n\nfrom fastapi import Request import pymongo import bson from dicebear import DAvatar, DStyle from pymongo.collection import Collection from pymongo.database import Database import motor.motor_asyncio as mongodb from utils import constants as C from gcp import SECRET_MANAGER import schemas import urllib.parse as urlparse from datetime import datetime CONN_STR=( f\"\"\" mongodb+srv:\/\/ {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.DB_USERNAME_SECRET_ID))} : {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.DB_PASSWORD_SECRET_ID))} @mirai.qlwjl.mongodb.net\/?retryWrites=true&w=majority \"\"\".replace(\"\\n\", \"\").replace(\" \", \"\"), \"mongodb:\/\/localhost:27017\", ) def get_default_user_doc(email: str, username: str, password_hash: bytes | None=None, session_info: dict | None=None, **kwargs) -> dict: \"\"\"Returns the default user document to be inserted into the database for a new user. Args: email(str): The user's email address. Must be lowercase. username(str): The user's username. Must be lowercase. password_hash(bytes | None): The user's password hash. If None, the user will be created without a password. session_info(dict | None): The user's session information. Must contain the following keys: \"id\"(str), \"expiry\"(datetime). **kwargs: Any other key-value pairs to be added to the user document. Returns: dict: The default user document. \"\"\" user_doc={ \"created_at\": datetime.utcnow(), \"email\": email, \"display_name\": username, \"username\": username, \"mirai_plus\": False, \"blur_risky_images\": True, \"verified\": False, \"profile\":{ \"image_url\": DAvatar(style=DStyle.initials, seed=username).url_png, \"banner_image_url\":\"https:\/\/image-assets.eu-2.volcanic.cloud\/api\/v1\/assets\/images\/7cf6c0d7de9c8a38729c02aff196e391?t=1664372891&webp_fallback=png\", \"bio\": \"Hello! I'm new to Mirai!\", \"location\": \"Earth\", \"url\": \"https:\/\/mirai.network\", }, \"privacy\":{ \"send_direct_messages\": C.FRIENDSHIP_TYPE.FOLLOWERS, \"be_follower\": C.FRIENDSHIP_TYPE.REQUEST_NEEDED, \"see_posts\": C.FRIENDSHIP_TYPE.FOLLOWERS, \"see_profile\": C.FRIENDSHIP_TYPE.FOLLOWERS, }, \"social\":{ follower_type:[] for follower_type in C.FOLLOWER_TYPE }, \"security\":{ \"role\":[C.USER], \"email_2fa\": False, }, \"chat\":{ \"online\": False, \"message_timer\": 0, \"password_protection\": None, \"hide_online_status\": False, }, \"banned_status\":{ \"is_banned\": False, }, } if password_hash is not None: user_doc[\"password\"]=bson.Binary(password_hash) if session_info is not None: user_doc[\"sessions\"]=[ {\"session_id\": session_info[\"id\"], \"expiry_date\": session_info[\"expiry\"]}, ] user_doc.update(kwargs) return user_doc def get_db_client(get_default: bool | None=True, get_async: bool | None=True, debug: bool=C.DEBUG_MODE) -> pymongo.MongoClient | Database: \"\"\"Get a MongoDB client or the database connection. Args: get_default(bool, optional): Get the default database. Defaults to True. Otherwise, get the client to connect to other databases. get_async(bool, optional): Get the async client. Defaults to True. Otherwise, get the normal\/synchronous client. debug_mode(bool): True if debug mode is enabled which will connect to the local database instead of a remote instance\/cluster. Defaults to the value in constants.py. Returns: pymongo.MongoClient | Database: The MongoDB client or database connection. \"\"\" conn_str=CONN_STR[debug] kwargs={ \"host\": conn_str, \"tls\": not debug, } if get_async: client=mongodb.AsyncIOMotorClient( **kwargs, ) else: client=pymongo.MongoClient( **kwargs, ) return client[C.DB_NAME] if get_default else client async def get_user_from_session(session_id: str, col: Collection=None) -> dict | None: \"\"\"Get the user document from the session ID. Args: session_id(str): The session ID. col(Collection, optional): The collection to search in. Defaults to None. If None, a new client to the database will be created. Returns: dict | None: The user document if found, otherwise None. \"\"\" if col is None: db=get_db_client() col=db[C.USER_COLLECTION] time_now=datetime.utcnow() user_doc: dict | None=await col.find_one({ \"sessions.session_id\": session_id, \"sessions.expiry_date\":{\"$gt\": time_now}, }) return user_doc async def get_user_role(request: Request, session_id: str, col: Collection=None) -> list[str]: \"\"\"Get the role of the user from the session ID. Args: session_id(str): The session ID. Returns: list[str]: The role of the user. \"\"\" default=[C.GUEST] if session_id is None: return default user_doc=await get_user_from_session(session_id, col) if user_doc is None: request.session.pop(C.SESSION_COOKIE) return default else: return user_doc[\"security\"][\"role\"] async def get_account_count(db: Database, acc_type: str) -> str: if acc_type==\"user\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^User \\d+$\" } }) elif acc_type==\"admin\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Admin \\d+$\" } }) elif acc_type==\"root\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Maintenance \\d+$\" } }) elif acc_type==\"super_root\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Super Root$\" } }) elif acc_type==\"all\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^(User|Admin|Maintenance|Super Root) \\d+$\" } }) elif acc_type==\"fake_reporter\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Fakereporter \\d+$\" } }) elif acc_type==\"victim99\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Victim99 \\d+$\" } }) else: raise ValueError(\"Invalid account type\") return user_count async def get_report_count(db: Database) -> str: report_count=await db[C.REPORT_COLLECTION].count_documents( { \"status\": \"open\"} ) if report_count==0: return 0 return report_count async def get_all_users(db: Database, acc_type: str) -> list[dict]: if acc_type==\"user\": users=db[C.USER_COLLECTION].find({ \"security\":{ \"role\":[C.USER], }, }) elif acc_type==\"admin\": users= db[C.USER_COLLECTION].find({ \"security\":{ \"role\":[C.ADMIN], }, }) elif acc_type==\"root\": users= db[C.USER_COLLECTION].find({ \"security\":{ \"role\":[C.ROOT], }, }) elif acc_type==\"super_root\": users= db[C.USER_COLLECTION].find({ \"security\":{ \"role\":[C.SUPER_ROOT], }, }) elif acc_type==\"all\": users= db[C.USER_COLLECTION].find({ \"security\":{ \"role\":[C.USER, C.ADMIN, C.ROOT, C.SUPER_ROOT], }, }) else: raise ValueError(\"Invalid account type\") return await users.to_list(None) async def get_all_reports(db: Database) -> list[dict]: users=db[C.REPORT_COLLECTION].find({ \"status\": \"open\", }) return await users.to_list(None) async def get_all_bans(db: Database) -> list[dict]: users=db[C.BAN_COLLECTION].find({}) return await users.to_list(None) ","sourceWithComments":"# import third-party libraries\nfrom fastapi import Request\nimport pymongo\nimport bson\nfrom dicebear import DAvatar, DStyle\nfrom pymongo.collection import Collection\nfrom pymongo.database import Database\nimport motor.motor_asyncio as mongodb\n\n# import local Python libraries\nfrom utils import constants as C\nfrom gcp import SECRET_MANAGER\nimport schemas\n\n# import Python's standard libraries\nimport urllib.parse as urlparse\nfrom datetime import datetime\n\n# docs: https:\/\/github.com\/mongodb\/motor\/blob\/master\/doc\/tutorial-asyncio.rst\nCONN_STR = (\n    f\"\"\"\n        mongodb+srv:\/\/\n        {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.DB_USERNAME_SECRET_ID))}\n        :\n        {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.DB_PASSWORD_SECRET_ID))}\n        @mirai.qlwjl.mongodb.net\/?retryWrites=true&w=majority\n    \"\"\".replace(\"\\n\", \"\").replace(\" \", \"\"),\n    \"mongodb:\/\/localhost:27017\",\n)\n\ndef get_default_user_doc(email: str, username: str, \n                         password_hash: bytes | None = None, session_info: dict | None = None, **kwargs) -> dict:\n    \"\"\"Returns the default user document to be inserted into the database for a new user.\n\n    Args:\n        email (str):\n            The user's email address. Must be lowercase.\n        username (str):\n            The user's username. Must be lowercase.\n        password_hash (bytes | None):\n            The user's password hash. If None, the user will be created without a password.\n        session_info (dict | None):\n            The user's session information. Must contain the following\n            keys: \"id\" (str), \"expiry\" (datetime).\n        **kwargs:\n            Any other key-value pairs to be added to the user document.\n\n    Returns:\n        dict: \n            The default user document.\n    \"\"\"\n    user_doc = {\n        \"created_at\": datetime.utcnow(),\n        \"email\": email,\n        \"display_name\": username,\n        \"username\": username,\n        \"mirai_plus\": False,\n        \"blur_risky_images\": True,\n        \"verified\": False,\n        \"profile\": {\n            \"image_url\": DAvatar(style=DStyle.initials, seed=username).url_png, \n            \"banner_image_url\":\"https:\/\/image-assets.eu-2.volcanic.cloud\/api\/v1\/assets\/images\/7cf6c0d7de9c8a38729c02aff196e391?t=1664372891&webp_fallback=png\",\n            \"bio\": \"Hello! I'm new to Mirai!\",\n            \"location\": \"Earth\",\n            \"url\": \"https:\/\/mirai.network\",\n        },\n        \"privacy\": {\n            \"send_direct_messages\": C.FRIENDSHIP_TYPE.FOLLOWERS,\n            \"be_follower\": C.FRIENDSHIP_TYPE.REQUEST_NEEDED,\n            \"see_posts\": C.FRIENDSHIP_TYPE.FOLLOWERS,\n            \"see_profile\": C.FRIENDSHIP_TYPE.FOLLOWERS,\n        },\n        \"social\": {\n            follower_type: [] \n            for follower_type in C.FOLLOWER_TYPE\n        },\n        \"security\": {\n            \"role\": [C.USER],\n            \"email_2fa\": False,\n        },\n        \"chat\": {\n            \"online\": False,\n            \"message_timer\": 0,\n            \"password_protection\": None,\n            \"hide_online_status\": False,\n        },\n        \"banned_status\": {\n            \"is_banned\": False,\n        },\n    }\n    if password_hash is not None:\n        user_doc[\"password\"] = bson.Binary(password_hash)\n\n    if session_info is not None:\n        user_doc[\"sessions\"] = [\n            {\"session_id\": session_info[\"id\"], \"expiry_date\": session_info[\"expiry\"]},\n        ]\n\n    user_doc.update(kwargs)\n    return user_doc\n\ndef get_db_client(get_default: bool | None = True, \n                  get_async: bool | None = True, debug: bool = C.DEBUG_MODE) -> pymongo.MongoClient | Database:\n    \"\"\"Get a MongoDB client or the database connection.\n\n    Args:\n        get_default (bool, optional): \n            Get the default database. Defaults to True.\n            Otherwise, get the client to connect to other databases.\n        get_async (bool, optional):\n            Get the async client. Defaults to True.\n            Otherwise, get the normal\/synchronous client.\n        debug_mode (bool):\n            True if debug mode is enabled which will\n            connect to the local database instead of a remote instance\/cluster.\n            Defaults to the value in constants.py.\n\n    Returns:\n        pymongo.MongoClient | Database:\n            The MongoDB client or database connection.\n    \"\"\"\n    conn_str = CONN_STR[debug]\n    kwargs = {\n        \"host\": conn_str,\n        \"tls\": not debug,\n    }\n    if get_async:\n        client = mongodb.AsyncIOMotorClient(\n            **kwargs,\n        )\n    else:\n        client = pymongo.MongoClient(\n            **kwargs,\n        )\n    return client[C.DB_NAME] if get_default else client\n\nasync def get_user_from_session(session_id: str, col: Collection = None) -> dict | None:\n    \"\"\"Get the user document from the session ID.\n\n    Args:\n        session_id (str):\n            The session ID.\n        col (Collection, optional):\n            The collection to search in. Defaults to None.\n            If None, a new client to the database will be created.\n\n    Returns:\n        dict | None:\n            The user document if found, otherwise None.\n    \"\"\"\n    if col is None:\n        db = get_db_client()\n        col = db[C.USER_COLLECTION]\n\n    time_now = datetime.utcnow()\n    user_doc: dict | None = await col.find_one({\n        \"sessions.session_id\": session_id, \n        \"sessions.expiry_date\": {\"$gt\": time_now},\n    })\n    return user_doc\n\nasync def get_user_role(request: Request, session_id: str, col: Collection = None) -> list[str]:\n    \"\"\"Get the role of the user from the session ID.\n\n    Args:\n        session_id (str): \n            The session ID.\n\n    Returns:\n        list[str]:\n            The role of the user.\n    \"\"\"\n    default = [C.GUEST]\n    if session_id is None:\n        return default\n\n    user_doc = await get_user_from_session(session_id, col)\n    if user_doc is None:\n        # The session ID is invalid\n        request.session.pop(C.SESSION_COOKIE)\n        return default\n    else:\n        return user_doc[\"security\"][\"role\"]\n\nasync def get_account_count(db: Database, acc_type: str) -> str:\n    if acc_type == \"user\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^User \\d+$\"\n            }\n        })\n\n    elif acc_type == \"admin\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Admin \\d+$\"\n            }\n        })\n\n    elif acc_type == \"root\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Maintenance \\d+$\"\n            }\n        })\n\n    elif acc_type == \"super_root\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Super Root$\"\n            }\n        })\n    elif acc_type == \"all\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^(User|Admin|Maintenance|Super Root) \\d+$\"\n            }\n        })\n    elif acc_type == \"fake_reporter\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Fakereporter \\d+$\"\n            }\n        })\n    elif acc_type == \"victim99\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Victim99 \\d+$\"\n            }\n        })\n    else:\n        raise ValueError(\"Invalid account type\")\n    return user_count\n\nasync def get_report_count(db: Database) -> str:\n    report_count = await db[C.REPORT_COLLECTION].count_documents(\n        { \"status\": \"open\" }\n    )\n    if report_count == 0:\n        return 0\n    return report_count \n\n# retrieve all users in the databases\nasync def get_all_users(db: Database, acc_type: str) -> list[dict]:\n    if acc_type == \"user\":\n        users = db[C.USER_COLLECTION].find({\n            \"security\": {\n                \"role\": [C.USER],\n            },\n        })\n        \n    elif acc_type == \"admin\":\n        users =  db[C.USER_COLLECTION].find({\n            \"security\": {\n                \"role\": [C.ADMIN],\n            },\n        })\n        \n    elif acc_type == \"root\":\n        users =  db[C.USER_COLLECTION].find({\n            \"security\": {\n                \"role\": [C.ROOT],\n            },\n        })\n        \n    elif acc_type == \"super_root\":\n        users =  db[C.USER_COLLECTION].find({\n            \"security\": {\n                \"role\": [C.SUPER_ROOT],\n            },\n        })\n        \n    elif acc_type == \"all\":\n        users =  db[C.USER_COLLECTION].find({\n            \"security\": {\n                \"role\": [C.USER, C.ADMIN, C.ROOT, C.SUPER_ROOT],\n            },\n        })\n        \n    else:\n        raise ValueError(\"Invalid account type\")\n    return await users.to_list(None)\n\nasync def get_all_reports(db: Database) -> list[dict]:\n    users = db[C.REPORT_COLLECTION].find({\n        \"status\": \"open\",\n    })\n\n    return await users.to_list(None)\n\nasync def get_all_bans(db: Database) -> list[dict]:\n    users = db[C.BAN_COLLECTION].find({})\n\n    return await users.to_list(None)"},"\/src\/app\/utils\/functions\/useful.py":{"changes":[{"diff":"\n import orjson\n from pydantic import BaseModel, HttpUrl\n from pydantic.error_wrappers import ValidationError\n-from fastapi import Request, FastAPI\n+from fastapi import Request, FastAPI, WebSocket\n from fastapi.exceptions import HTTPException\n \n # import local Python libraries\n","add":1,"remove":1,"filename":"\/src\/app\/utils\/functions\/useful.py","badparts":["from fastapi import Request, FastAPI"],"goodparts":["from fastapi import Request, FastAPI, WebSocket"]},{"diff":"\n         return text[:max_length].strip() + \"...\"\n     return text\n \n-def get_location_str(request: Request, get_parts: bool | None = False) -> str | tuple[str, str, str]:\n+def get_location_str(request: Request | WebSocket, get_parts: bool | None = False) -> str | tuple[str, str, str]:\n     \"\"\"Gets the location string from the request headers (Cloudflare proxy)\n \n     Args:\n-        request (Request):\n-            The request object.\n+        request (Request | WebSocket):\n+            The request or websocket to get the location string from.\n         get_parts (bool, Optional):\n             Whether to return the city, country, and location string as a tuple.\n             Defaults to False.\n","add":3,"remove":3,"filename":"\/src\/app\/utils\/functions\/useful.py","badparts":["def get_location_str(request: Request, get_parts: bool | None = False) -> str | tuple[str, str, str]:","        request (Request):","            The request object."],"goodparts":["def get_location_str(request: Request | WebSocket, get_parts: bool | None = False) -> str | tuple[str, str, str]:","        request (Request | WebSocket):","            The request or websocket to get the location string from."]}],"source":"\n\nimport bson import httpx import orjson from pydantic import BaseModel, HttpUrl from pydantic.error_wrappers import ValidationError from fastapi import Request, FastAPI from fastapi.exceptions import HTTPException from utils import constants as C import base64 from typing import Any from datetime import datetime class UrlModel(BaseModel): url: HttpUrl def check_if_str_is_url(string: str) -> bool: \"\"\"Checks if a string is a URL. Args: string(str): The string to check. Returns: bool: True if the string is a URL, False otherwise. \"\"\" try: UrlModel(url=string) except(ValidationError): return False else: return True def truncate_text(text: str, max_length: int=20) -> str: \"\"\"Truncates a string to a maximum length. Args: text(str): The text to truncate. max_length(int, optional): The maximum length of the string. Defaults to 20. Returns: str: The truncated string. \"\"\" if len(text) > max_length: return text[:max_length].strip() +\"...\" return text def get_location_str(request: Request, get_parts: bool | None=False) -> str | tuple[str, str, str]: \"\"\"Gets the location string from the request headers(Cloudflare proxy) Args: request(Request): The request object. get_parts(bool, Optional): Whether to return the city, country, and location string as a tuple. Defaults to False. Returns: str | tuple[str, str, str]: The location string or a tuple of the city, country, and location string. \"\"\" city=request.headers.get(\"CF-IPCity\", \"Unknown\") country=request.headers.get(\"CF-IPCountry\", \"Unknown\") location=city +\", \" +country location=location.strip() if get_parts: return(city, country, location) return location def browser_str_to_png_url(request: Request, browser: str) -> str: \"\"\"Converts a browser string to a PNG URL. Args: browser(str): The browser string. Returns: str: The PNG URL. E.g. \"\/static\/img\/browsers\/chrome_64x64.png\" \"\"\" suffix_uri=C.BROWSER_TABLE.get(browser, \"unknown.png\") return url_for(request, \"static\", path=\"img\/browsers\/\" +suffix_uri) def get_user_ip(request: Request) -> str: \"\"\"Returns the user's IP address as a string. For cloudflare proxy, we need to get from the request headers: https:\/\/developers.cloudflare.com\/fundamentals\/get-started\/reference\/http-request-headers\/ Args: request(Request): The request object Returns: str: The user's IP address(127.0.0.1 if not found) \"\"\" cloudflare_proxy=request.headers.get(key=\"CF-Connecting-IP\", default=None) if cloudflare_proxy is not None: return cloudflare_proxy requestIP=request.client if requestIP is not None: return requestIP.host return \"127.0.0.1\" def url_for(request: Request, name: str, external: bool=False, **path_params: Any) -> str: \"\"\"Returns the URL path for the given endpoint name. Args: request(Request): The request object name(str): The endpoint name external(bool): Whether to return an absolute URL path **path_params(Any): The path parameters Returns: str: The URL path \"\"\" app: FastAPI=request.app relative_path=app.url_path_for(name, **path_params) if external: return C.DOMAIN +relative_path else: return relative_path def flash(request: Request, message: str, category: str=\"primary\") -> None: \"\"\"Adds a message to the session. Note: Use the get_flashed_messages function in Jinja2 to retrieve the messages. Args: request(Request): The request object message(str): The message to add category(str): The category of the message Returns: None \"\"\" flash_message={\"message\": message, \"category\": category} if C.FLASH_MESSAGES not in request.session: request.session[C.FLASH_MESSAGES]=[] request.session[C.FLASH_MESSAGES].append(flash_message) async def do_request(url: str, method: str, get_json:bool=False, check_status: bool=True, http2: bool=True, get_response: bool=False, client_kwargs: dict={}, request_kwargs: dict={}) -> httpx.Response | dict | tuple[httpx.Response, dict]: \"\"\"Makes a request asynchronously to the given URL with error handling. Args: url(str): The URL to make the request to method(str): The HTTP method to use get_json(bool, optional): Whether to return the response in JSON. Defaults to False. check_status(bool, optional): Whether to check the status code of the response and if it is not 200 OK, the error will be logged. Defaults to True. get_response(bool, optional): Whether to return the response object if get_json was True. Defaults to False. client_kwargs(dict, optional): The keyword arguments to pass to the httpx.AsyncClient. Defaults to{}. request_kwargs(dict, optional): The keyword arguments to pass to the request. Defaults to{}. Returns: httpx.Response | dict: The response or the response in JSON \"\"\" async with httpx.AsyncClient(http2=http2, **client_kwargs) as client: try: response=await client.request( method=method, url=url, **request_kwargs, ) if check_status: response.raise_for_status() json_res={} if get_json: json_res=orjson.loads(response.content) except(httpx.HTTPStatusError) as e: log_msg=f\"Request to{url} was not successful as status code{e.response.status_code} response was received instead of 200 OK.\" print(\"Response content:\", response.content) except(orjson.JSONDecodeError) as e: log_msg=f\"Request to{url} was not successful as the response could not be decoded as JSON.\" except(httpx.HTTPError) as e: log_msg=f\"HTTP Exception for{url} -{e}\" else: if get_json and get_response: return response, json_res if get_json: return json_res return response print(log_msg) raise HTTPException( status_code=500, detail=\"An error has occurred. Please try again later.\", ) def format_json_response(bson_payload: dict) -> dict: \"\"\"Format the retrieved MongoDB bson payload for the JSON module to serialize it. Used when sending a JSON response to the client. Args: message(dict): The message to be formatted. Returns: dict: The formatted message. \"\"\" new_dict={} for key, value in bson_payload.items(): if isinstance(value, bson.objectid.ObjectId): new_dict[key]=str(value) elif isinstance(value, datetime): new_dict[key]=str(value) elif isinstance(value, bytes): new_dict[key]=base64.b64encode(value).decode(\"utf-8\") else: new_dict[key]=value return new_dict def get_following_status(_id, following_list, pending_list, requests_list): if _id in following_list: return \"followed\" elif _id in pending_list: return \"pending\" elif _id in requests_list: return \"requests\" else: return \"unfollowed\" ","sourceWithComments":"# import third-party libraries\nimport bson\nimport httpx\nimport orjson\nfrom pydantic import BaseModel, HttpUrl\nfrom pydantic.error_wrappers import ValidationError\nfrom fastapi import Request, FastAPI\nfrom fastapi.exceptions import HTTPException\n\n# import local Python libraries\nfrom utils import constants as C\n\n# import Python's standard libraries\nimport base64\nfrom typing import Any\nfrom datetime import datetime\n\nclass UrlModel(BaseModel):\n    url: HttpUrl\n\ndef check_if_str_is_url(string: str) -> bool:\n    \"\"\"Checks if a string is a URL.\n\n    Args:\n        string (str):\n            The string to check.\n\n    Returns:\n        bool:\n            True if the string is a URL, False otherwise.\n    \"\"\"\n    try:\n        UrlModel(url=string)\n    except (ValidationError):\n        return False\n    else:\n        return True\n\ndef truncate_text(text: str, max_length: int = 20) -> str:\n    \"\"\"Truncates a string to a maximum length.\n\n    Args:\n        text (str):\n            The text to truncate.\n        max_length (int, optional):\n            The maximum length of the string. Defaults to 20.\n\n    Returns:\n        str:\n            The truncated string.\n    \"\"\"\n    if len(text) > max_length:\n        return text[:max_length].strip() + \"...\"\n    return text\n\ndef get_location_str(request: Request, get_parts: bool | None = False) -> str | tuple[str, str, str]:\n    \"\"\"Gets the location string from the request headers (Cloudflare proxy)\n\n    Args:\n        request (Request):\n            The request object.\n        get_parts (bool, Optional):\n            Whether to return the city, country, and location string as a tuple.\n            Defaults to False.\n\n    Returns:\n        str | tuple[str, str, str]:\n            The location string or a tuple of the city, country, and location string.\n    \"\"\"\n    city = request.headers.get(\"CF-IPCity\", \"Unknown\")\n    country = request.headers.get(\"CF-IPCountry\", \"Unknown\")\n    location = city + \", \" + country\n    location = location.strip()\n    if get_parts:\n        return (city, country, location)\n    return location\n\ndef browser_str_to_png_url(request: Request, browser: str) -> str:\n    \"\"\"Converts a browser string to a PNG URL.\n\n    Args:\n        browser (str):\n            The browser string.\n\n    Returns:\n        str:\n            The PNG URL. E.g. \"\/static\/img\/browsers\/chrome_64x64.png\"\n    \"\"\"\n    suffix_uri = C.BROWSER_TABLE.get(browser, \"unknown.png\")\n    return url_for(request, \"static\", path=\"img\/browsers\/\" + suffix_uri)\n\ndef get_user_ip(request: Request) -> str:\n    \"\"\"Returns the user's IP address as a string.\n\n    For cloudflare proxy, we need to get from the request headers:\n    https:\/\/developers.cloudflare.com\/fundamentals\/get-started\/reference\/http-request-headers\/\n\n    Args:\n        request (Request): \n            The request object\n\n    Returns:\n        str:\n            The user's IP address (127.0.0.1 if not found)\n    \"\"\"\n    cloudflare_proxy = request.headers.get(key=\"CF-Connecting-IP\", default=None)\n    if cloudflare_proxy is not None:\n        return cloudflare_proxy\n\n    requestIP = request.client\n    if requestIP is not None:\n        return requestIP.host\n\n    return \"127.0.0.1\"\n\ndef url_for(request: Request, name: str, external: bool = False, **path_params: Any) -> str:\n    \"\"\"Returns the URL path for the given endpoint name.\n\n    Args:\n        request (Request):\n            The request object\n        name (str):\n            The endpoint name\n        external (bool):\n            Whether to return an absolute URL path\n        **path_params (Any):\n            The path parameters\n\n    Returns:\n        str:\n            The URL path\n    \"\"\"\n    app: FastAPI = request.app\n    relative_path = app.url_path_for(name, **path_params)\n    if external:\n        return C.DOMAIN + relative_path\n    else:\n        return relative_path\n\ndef flash(request: Request, message: str, category: str = \"primary\") -> None:\n    \"\"\"Adds a message to the session.\n\n    Note: Use the get_flashed_messages function in Jinja2 to retrieve the messages.\n\n    Args:\n        request (Request):\n            The request object\n        message (str):\n            The message to add\n        category (str):\n            The category of the message\n\n    Returns:\n        None\n    \"\"\"\n    flash_message = {\"message\": message, \"category\": category}\n    if C.FLASH_MESSAGES not in request.session:\n        request.session[C.FLASH_MESSAGES] = []\n    request.session[C.FLASH_MESSAGES].append(flash_message)\n\nasync def do_request(url: str, method: str, get_json:bool = False, check_status: bool = True, http2: bool = True,\n                     get_response: bool = False, client_kwargs: dict = {}, request_kwargs: dict = {}) -> httpx.Response | dict | tuple[httpx.Response, dict]:\n    \"\"\"Makes a request asynchronously to the given URL with error handling.\n\n    Args:\n        url (str):\n            The URL to make the request to\n        method (str):\n            The HTTP method to use\n        get_json (bool, optional):\n            Whether to return the response in JSON. Defaults to False.\n        check_status (bool, optional):\n            Whether to check the status code of the response and if it is not 200 OK, the error will be logged. \n            Defaults to True.\n        get_response (bool, optional):\n            Whether to return the response object if get_json was True. Defaults to False.\n        client_kwargs (dict, optional):\n            The keyword arguments to pass to the httpx.AsyncClient. Defaults to {}.\n        request_kwargs (dict, optional):\n            The keyword arguments to pass to the request. Defaults to {}.\n\n    Returns:\n        httpx.Response | dict:\n            The response or the response in JSON\n    \"\"\"\n    async with httpx.AsyncClient(http2=http2, **client_kwargs) as client:\n        try:\n            response = await client.request(\n                method=method,\n                url=url,\n                **request_kwargs,\n            )\n            if check_status:\n                response.raise_for_status()\n\n            json_res = {}\n            if get_json:\n                json_res = orjson.loads(response.content)\n        except (httpx.HTTPStatusError) as e:\n            log_msg = f\"Request to {url} was not successful as status code {e.response.status_code} response was received instead of 200 OK.\"\n            print(\"Response content:\", response.content)\n        except (orjson.JSONDecodeError) as e:\n            log_msg = f\"Request to {url} was not successful as the response could not be decoded as JSON.\"\n        except (httpx.HTTPError) as e:\n            # Usually this is a connection error on our end\n            log_msg = f\"HTTP Exception for {url} - {e}\"\n        else:\n            if get_json and get_response:\n                return response, json_res\n            if get_json:\n                return json_res\n            return response\n\n    # TODO: Might want to log the error\n    print(log_msg)\n    raise HTTPException(\n        status_code=500, \n        detail=\"An error has occurred. Please try again later.\",\n    )\n\ndef format_json_response(bson_payload: dict) -> dict:\n    \"\"\"Format the retrieved MongoDB bson payload for the JSON module to serialize it.\n\n    Used when sending a JSON response to the client.\n\n    Args:\n        message (dict): \n            The message to be formatted.\n\n    Returns:\n        dict: \n            The formatted message.\n    \"\"\"\n    new_dict = {}\n    for key, value in bson_payload.items():\n        if isinstance(value, bson.objectid.ObjectId):\n            new_dict[key] = str(value)\n        elif isinstance(value, datetime):\n            new_dict[key] = str(value)\n        elif isinstance(value, bytes):\n            new_dict[key] = base64.b64encode(value).decode(\"utf-8\")\n        else:\n            new_dict[key] = value\n    return new_dict\n\ndef get_following_status(_id, following_list, pending_list, requests_list):\n    if _id in following_list:\n        return \"followed\"\n    elif _id in pending_list:\n        return \"pending\"\n    elif _id in requests_list:\n        return \"requests\"\n    else:\n        return \"unfollowed\""}},"msg":"added more checks to the session to prevent session hijacking"},"ac9269cc3d55182b819e1d9f358c9b77e4b56192":{"url":"https:\/\/api.github.com\/repos\/Solaireis\/CWC-ISPJ\/commits\/ac9269cc3d55182b819e1d9f358c9b77e4b56192","html_url":"https:\/\/github.com\/Solaireis\/CWC-ISPJ\/commit\/ac9269cc3d55182b819e1d9f358c9b77e4b56192","sha":"ac9269cc3d55182b819e1d9f358c9b77e4b56192","keyword":"session hijacking check","diff":"diff --git a\/setup\/database_setup.py b\/setup\/database_setup.py\nindex 695cfc9b..732ecad3 100644\n--- a\/setup\/database_setup.py\n+++ b\/setup\/database_setup.py\n@@ -43,11 +43,6 @@ def create_user_collection(db: Database) -> None:\n         ),\n         MongoCollection.IndexModel(\n             keys=\"sessions.user_agent\",\n-            sparse=True,\n-        ),\n-        MongoCollection.IndexModel(\n-            keys=\"sessions.ip_address\",\n-            sparse=True,\n         ),\n         MongoCollection.IndexModel(\n             keys=\"blocked_users\",\ndiff --git a\/src\/app\/routers\/api\/general.py b\/src\/app\/routers\/api\/general.py\nindex 278d9559..439f9ba3 100644\n--- a\/src\/app\/routers\/api\/general.py\n+++ b\/src\/app\/routers\/api\/general.py\n@@ -245,10 +245,7 @@ async def get_privacy(request: Request, username: str | None = None, rbac_res: r\n             projection = {\"privacy\": True},\n         )\n     elif request.session.get(C.SESSION_COOKIE) is not None:\n-        data = await user_col.find_one(\n-            filter = {\"sessions.session_id\": request.session[C.SESSION_COOKIE]},\n-            projection = {\"privacy\": True},\n-        )\n+        data = rbac_res.user_doc\n     else:\n         data = None\n \ndiff --git a\/src\/app\/utils\/functions\/database.py b\/src\/app\/utils\/functions\/database.py\nindex b02838ff..7d111dd0 100644\n--- a\/src\/app\/utils\/functions\/database.py\n+++ b\/src\/app\/utils\/functions\/database.py\n@@ -14,6 +14,7 @@\n \n # import Python's standard libraries\n import time\n+import hashlib\n from datetime import datetime\n import urllib.parse as urlparse\n \n@@ -215,6 +216,7 @@ async def get_user_from_session(request: Request | WebSocket, session_id: str, c\n         \"sessions.session_id\": session_id, \n         \"sessions.expiry_date\": {\"$gt\": time_now},\n         \"sessions.location\": user_location,\n+        \"sessions.user_agent\": hashlib.sha256(request.headers.get(\"User-Agent\", \"\").encode(\"utf-8\")).hexdigest(),\n     }\n \n     user_doc: dict | None = await col.find_one(_filter)\n@@ -274,7 +276,7 @@ async def get_user_role(\n     return user_doc, user_doc[\"security\"][\"role\"]\n \n async def get_account_count(db: Database, acc_type: str) -> str:\n-    db = get_db_client(get_default=True, get_admin_db=False,)\n+    db = get_db_client(get_default=True, get_admin_db=False)\n     admin_db = get_db_client(get_admin_db=True)\n     if acc_type == \"user\":\n         user_count = await db[C.USER_COLLECTION].count_documents({\n@@ -335,39 +337,34 @@ async def get_report_count(db: Database) -> str:\n \n # retrieve all users in the databases\n async def get_all_users(db: Database, acc_type: str) -> list[dict]:\n-    \n     if acc_type == \"user\":\n         users =  db[C.USER_COLLECTION].find({\n             \"security.role\": {\n-                    \"$elemMatch\": {\n-                        \"$eq\": C.USER,\n-                        },\n-                \n+                \"$elemMatch\": {\n+                    \"$eq\": C.USER,\n+                },\n             },\n         })                          \n     elif acc_type == \"admin\":\n         users = db[C.ADMIN_COLLECTION].find({\n             \"security.role\": {\n-                    \"$elemMatch\": {\n-                        \"$eq\": C.ADMIN,\n-                        },\n-                \n+                \"$elemMatch\": {\n+                    \"$eq\": C.ADMIN,\n+                },\n             },\n         })\n \n     elif acc_type == \"root\":\n         users =  db[C.ADMIN_COLLECTION].find({\n             \"security.role\": {\n-                    \"$elemMatch\": {\n-                        \"$eq\": C.ROOT,\n-                        },\n-                \n+                \"$elemMatch\": {\n+                    \"$eq\": C.ROOT,\n+                },\n             },\n         })\n     else:\n         raise ValueError(\"Invalid account type\")\n     return await users.to_list(None)\n-    \n \n async def get_all_reports(db: Database) -> list[dict]:\n     users = db[C.REPORT_COLLECTION].find({\ndiff --git a\/src\/app\/utils\/functions\/security.py b\/src\/app\/utils\/functions\/security.py\nindex dbd76643..8c66d667 100644\n--- a\/src\/app\/utils\/functions\/security.py\n+++ b\/src\/app\/utils\/functions\/security.py\n@@ -376,15 +376,17 @@ async def add_session(request: Request, user_doc: dict, session_expiry: int, use\n     current_datetime = datetime.utcnow()\n     expiry_date = current_datetime + timedelta(seconds=session_expiry)\n \n-    ua = user_agents.parse(request.headers.get(\"User-Agent\", \"\"))\n-    os_name = ua.os.family + \" \" + ua.os.version_string\n+    ua = request.headers.get(\"User-Agent\", \"\")\n+    parsed_ua = user_agents.parse(ua)\n+    os_name = parsed_ua.os.family + \" \" + parsed_ua.os.version_string\n     session_data = {\n         \"session_id\": session_id,\n         \"added_on\": current_datetime,\n         \"expiry_date\": expiry_date,\n-        \"browser\": ua.browser.family,\n+        \"browser\": parsed_ua.browser.family,\n         \"os\": os_name.strip(),\n         \"location\": location,\n+        \"user_agent\": hashlib.sha256(ua.encode(\"utf-8\")).hexdigest(),\n     }\n     if session_expiry == C.DO_NOT_REMEMBER_EXPIRY:\n         request.session[C.EXPIRY_ONCLOSE] = True\ndiff --git a\/user-database.md b\/user-database.md\nindex 17c585b0..5e0bd7d2 100644\n--- a\/user-database.md\n+++ b\/user-database.md\n@@ -83,6 +83,7 @@ Many-to-Many - Prefer Referencing\n             \"os_name\": \"Windows 10\",\n             \"location\": \"New York, US\",\n             \"remember_chat\": true,\n+            \"user_agent\": \"hashed_user_agent\",\n         },\n         {\n             \"session_id\": \"random_string\",\n@@ -90,7 +91,6 @@ Many-to-Many - Prefer Referencing\n             \"browser\": \"Mobile Safari\",\n             \"os_name\": \"iOS 5.1\",\n             \"location\": \"Singapore, SG\",\n-            \"ip_address\": \"hashed_ip_addr\",\n             \"user_agent\": \"hashed_user_agent\",\n         },\n     ],\n@@ -115,8 +115,7 @@ Many-to-Many - Prefer Referencing\n \n For the `sessions.remember_chat`, the user would be able to view the chat without entering the password every time the user views the chat for the current session.\n \n-Additionally, if the session object has `ip_address` and `user_agent`, it means that the user has logged in with a longer expiry date by checking the `Stay Signed In` option on the login page. \n-Hence, the extra data are for a more stricter security check to reduce the risk of a session hijacking.\n+The `user_agent` field is to reduce the risk of a session hijacking.\n \n #### Privacy:\n \n","message":"","files":{"\/setup\/database_setup.py":{"changes":[{"diff":"\n         ),\n         MongoCollection.IndexModel(\n             keys=\"sessions.user_agent\",\n-            sparse=True,\n-        ),\n-        MongoCollection.IndexModel(\n-            keys=\"sessions.ip_address\",\n-            sparse=True,\n         ),\n         MongoCollection.IndexModel(\n             keys=\"blocked_users\",","add":0,"remove":5,"filename":"\/setup\/database_setup.py","badparts":["            sparse=True,","        ),","        MongoCollection.IndexModel(","            keys=\"sessions.ip_address\",","            sparse=True,"],"goodparts":[]}],"source":"\n\nfrom pymongo.database import Database import pymongo.collection as MongoCollection from pymongo.collation import Collation, CollationStrength import sys import pathlib FILE_PATH=pathlib.Path(__file__).parent.absolute() PYTHON_FILES_PATH=FILE_PATH.parent.joinpath(\"src\", \"app\") sys.path.append(str(PYTHON_FILES_PATH)) from utils import constants as C from utils.functions import database as mongo def create_user_collection(db: Database) -> None: db.create_collection( name=C.USER_COLLECTION, ) db[C.USER_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"email\", unique=True, collation=Collation(\"en\", strength=CollationStrength.PRIMARY), ), MongoCollection.IndexModel( keys=\"username\", unique=True, collation=Collation(\"en\", strength=CollationStrength.PRIMARY), ), MongoCollection.IndexModel( keys=\"display_name\", collation=Collation(\"en\", strength=CollationStrength.PRIMARY), ), MongoCollection.IndexModel( keys=\"sessions.session_id\", unique=True, sparse=True, ), MongoCollection.IndexModel( keys=\"sessions.expiry_date\", ), MongoCollection.IndexModel( keys=\"sessions.user_agent\", sparse=True, ), MongoCollection.IndexModel( keys=\"sessions.ip_address\", sparse=True, ), MongoCollection.IndexModel( keys=\"blocked_users\", unique=True, sparse=True, ), ]) def create_post_collection(db: Database) -> None: db.create_collection( name=C.POST_COLLECTION, ) db[C.POST_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"user_id\", ), MongoCollection.IndexModel( keys=\"images.blob_id\", unique=True, sparse=True, ), MongoCollection.IndexModel( keys=\"video.blob_id\", unique=True, sparse=True, ), MongoCollection.IndexModel( keys=\"description\", sparse=True, collation=Collation(\"en\", strength=CollationStrength.PRIMARY), ), ]) def create_comments_collection(db: Database) -> None: db.create_collection( name=C.COMMENTS_COLLECTION, ) db[C.COMMENTS_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"user_id\", ), MongoCollection.IndexModel( keys=\"post_id\", ), ]) def create_chat_collection(db: Database) -> None: db.create_collection( name=C.CHAT_COLLECTION, ) db[C.CHAT_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"sender\", ), MongoCollection.IndexModel( keys=\"receiver\", ), MongoCollection.IndexModel( keys=\"timestamp\", ), MongoCollection.IndexModel( keys=\"type\", ), MongoCollection.IndexModel( keys=\"files.blob_id\", unique=True, sparse=True, ), MongoCollection.IndexModel( keys=\"files.blob_name\", unique=True, sparse=True, ), MongoCollection.IndexModel( keys=\"files.compressed_blob_name\", unique=True, sparse=True, ), ]) def create_file_analysis_collection(db: Database) -> None: db.create_collection( name=C.FILE_ANALYSIS_COLLECTION, ) db[C.FILE_ANALYSIS_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"identifier\", unique=True, collation=Collation(\"en\", strength=CollationStrength.PRIMARY), ), ]) def create_upload_ids_collection(db: Database) -> None: db.create_collection( name=C.UPLOAD_IDS_COLLECTION, ) db[C.UPLOAD_IDS_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"created_at\", expireAfterSeconds=30 * 60, ), ]) def ban_logs(db: Database) -> None: db.create_collection( name=C.BAN_COLLECTION, ) db[C.BAN_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"user_id\", ), MongoCollection.IndexModel( keys=\"banned_by\", ), MongoCollection.IndexModel( keys=\"created_at\", ), ]) def report_logs(db: Database) -> None: db.create_collection( name=C.REPORT_COLLECTION, ) db[C.REPORT_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"reported_by\", ), MongoCollection.IndexModel( keys=\"created_at\", ), MongoCollection.IndexModel( keys=\"category\", ), MongoCollection.IndexModel( keys=\"user_id\", ), ]) def create_admin_collection(db: Database) -> None: db.create_collection( name=C.ADMIN_COLLECTION, ) db[C.ADMIN_COLLECTION].create_indexes([ MongoCollection.IndexModel( keys=\"email\", unique=True, collation=Collation(\"en\", strength=CollationStrength.PRIMARY), ), ]) def seed_super_admin(db: Database) -> None: email=C.ROOT_EMAIL username=email.split(\"@\")[0] db[C.ADMIN_COLLECTION].insert_one( mongo.get_default_user_doc( email=email, username=username, is_admin=True, display_name=username, password_hash=None, session_info=None, verified=True, security={ \"role\":[C.ROOT], }, oauth2=[\"google\"], ), ) def seed_admin(db: Database) -> None: email=C.ADMIN_EMAIL username=email.split(\"@\")[0] db[C.ADMIN_COLLECTION].insert_one( mongo.get_default_user_doc( email=email, username=username, is_admin=True, display_name=username, password_hash=None, session_info=None, verified=True, security={ \"role\":[C.ADMIN], }, oauth2=[\"google\"], ), ) def main() -> None: while True: debug_prompt=input(\"Debug mode?(Y\/n): \").lower().strip() if debug_prompt not in(\"y\", \"n\", \"\"): print(\"Invalid input\", end=\"\\n\\n\") continue else: debug_flag=(debug_prompt !=\"n\") break with( mongo.get_db_client(get_default=False, get_async=False, debug=debug_flag) as user_client, mongo.get_db_client(get_default=False, get_async=False, debug=debug_flag, get_admin_db=True) as admin_client, ): user_client.drop_database(C.DB_NAME) admin_client.drop_database(C.ADMIN_DB_NAME) client_db=user_client[C.DB_NAME] create_user_collection(client_db) create_chat_collection(client_db) client_db.create_collection(name=C.DELETED_CHAT_COLLECTION) create_file_analysis_collection(client_db) create_post_collection(client_db) create_comments_collection(client_db) create_upload_ids_collection(client_db) admin_db=admin_client[C.ADMIN_DB_NAME] ban_logs(admin_db) report_logs(admin_db) create_admin_collection(admin_db) seed_super_admin(admin_db) seed_admin(admin_db) if __name__==\"__main__\": main() print(\"Done\", end=\"\\n\\n\") ","sourceWithComments":"# import third-party libraries\nfrom pymongo.database import Database\nimport pymongo.collection as MongoCollection\nfrom pymongo.collation import Collation, CollationStrength # info: https:\/\/stackoverflow.com\/questions\/33736192\/mongo-unique-index-case-insensitive\n\n# import Python's standard libraries\nimport sys\nimport pathlib\n\n# import local python libraries\nFILE_PATH = pathlib.Path(__file__).parent.absolute()\nPYTHON_FILES_PATH = FILE_PATH.parent.joinpath(\"src\", \"app\")\nsys.path.append(str(PYTHON_FILES_PATH))\nfrom utils import constants as C # type: ignore\nfrom utils.functions import database as mongo # type: ignore\n\ndef create_user_collection(db: Database) -> None:\n    db.create_collection(\n        name=C.USER_COLLECTION,\n    )\n    db[C.USER_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"email\",\n            unique=True,\n            collation=Collation(\"en\", strength=CollationStrength.PRIMARY),\n        ),\n        MongoCollection.IndexModel(\n            keys=\"username\",\n            unique=True,\n            collation=Collation(\"en\", strength=CollationStrength.PRIMARY),\n        ),\n        MongoCollection.IndexModel(\n            keys=\"display_name\",\n            collation=Collation(\"en\", strength=CollationStrength.PRIMARY),\n        ),\n        MongoCollection.IndexModel(\n            keys=\"sessions.session_id\",\n            unique=True,\n            sparse=True,\n        ),\n        MongoCollection.IndexModel(\n            keys=\"sessions.expiry_date\",\n        ),\n        MongoCollection.IndexModel(\n            keys=\"sessions.user_agent\",\n            sparse=True,\n        ),\n        MongoCollection.IndexModel(\n            keys=\"sessions.ip_address\",\n            sparse=True,\n        ),\n        MongoCollection.IndexModel(\n            keys=\"blocked_users\",\n            unique=True,\n            sparse=True,\n        ),\n    ])\n\ndef create_post_collection(db: Database) -> None:\n    db.create_collection(\n        name=C.POST_COLLECTION,\n    )\n    db[C.POST_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"user_id\",\n        ),\n        MongoCollection.IndexModel(\n            keys=\"images.blob_id\",\n            unique=True,\n            sparse=True,\n        ),\n        MongoCollection.IndexModel(\n            keys=\"video.blob_id\",\n            unique=True,\n            sparse=True,\n        ),\n        MongoCollection.IndexModel(\n            keys=\"description\",\n            sparse=True,\n            collation=Collation(\"en\", strength=CollationStrength.PRIMARY),\n        ),\n    ])\n\ndef create_comments_collection(db: Database) -> None:\n    db.create_collection(\n        name=C.COMMENTS_COLLECTION,\n    )\n    db[C.COMMENTS_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"user_id\",\n        ),\n        MongoCollection.IndexModel(\n            keys=\"post_id\",\n        ),\n    ])\n\ndef create_chat_collection(db: Database) -> None:\n    db.create_collection(\n        name=C.CHAT_COLLECTION,\n    )\n    db[C.CHAT_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"sender\",\n        ),\n        MongoCollection.IndexModel(\n            keys=\"receiver\",\n        ),\n        MongoCollection.IndexModel(\n            keys=\"timestamp\",\n        ),\n        # For the cloud function to filter \n        # out messages that of type \"files\".\n        MongoCollection.IndexModel(\n            keys=\"type\",\n        ),\n        # For getting the individual file in the files array.\n        MongoCollection.IndexModel(\n            keys=\"files.blob_id\",\n            unique=True,\n            sparse=True,\n        ),\n        # For the cloud function to delete any \n        # GCS blobs that are not in the database.\n        MongoCollection.IndexModel(\n            keys=\"files.blob_name\",\n            unique=True,\n            sparse=True,\n        ),\n        MongoCollection.IndexModel(\n            keys=\"files.compressed_blob_name\",\n            unique=True,\n            sparse=True,\n        ),\n    ])\n\ndef create_file_analysis_collection(db: Database) -> None:\n    db.create_collection(\n        name=C.FILE_ANALYSIS_COLLECTION,\n    )\n    db[C.FILE_ANALYSIS_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"identifier\",\n            unique=True,\n            collation=Collation(\"en\", strength=CollationStrength.PRIMARY),\n        ),\n        # MongoCollection.IndexModel(\n        #     keys=\"url\",\n        #     unique=True,\n        # ),\n    ])\n\ndef create_upload_ids_collection(db: Database) -> None:\n    db.create_collection(\n        name=C.UPLOAD_IDS_COLLECTION,\n    )\n    db[C.UPLOAD_IDS_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"created_at\",\n            expireAfterSeconds=30 * 60, # 30 minutes\n        ),\n    ])\n\ndef ban_logs(db: Database) -> None:\n    db.create_collection(\n        name=C.BAN_COLLECTION,\n    )\n    db[C.BAN_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"user_id\", # the user id which is banned\n        ),\n        MongoCollection.IndexModel(\n            keys=\"banned_by\", # FK to the user who banned the user\n        ),\n        MongoCollection.IndexModel(\n            keys=\"created_at\", # search \n        ),\n    ])\n\ndef report_logs(db: Database) -> None:\n    db.create_collection(\n        name=C.REPORT_COLLECTION,\n    )\n\n    db[C.REPORT_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"reported_by\", # reported by which user\n        ),\n        MongoCollection.IndexModel(\n            keys=\"created_at\", # for search\n        ),\n        MongoCollection.IndexModel(\n            keys=\"category\", # for searching\n        ),\n        MongoCollection.IndexModel(\n            keys=\"user_id\", # who got reported\n        ),\n    ])\n\ndef create_admin_collection(db: Database) -> None:\n    db.create_collection(\n        name=C.ADMIN_COLLECTION,\n    )\n    db[C.ADMIN_COLLECTION].create_indexes([\n        MongoCollection.IndexModel(\n            keys=\"email\",\n            unique=True,\n            collation=Collation(\"en\", strength=CollationStrength.PRIMARY),\n        ),\n    ])\n\ndef seed_super_admin(db: Database) -> None:\n    email = C.ROOT_EMAIL\n    username = email.split(\"@\")[0]\n    db[C.ADMIN_COLLECTION].insert_one(\n        mongo.get_default_user_doc(\n            email=email,\n            username=username,\n            is_admin=True,\n            display_name=username,\n            password_hash=None,\n            session_info=None,\n            verified=True,\n            security={\n                \"role\": [C.ROOT],\n            },\n            oauth2=[\"google\"],\n        ),\n    )\n\ndef seed_admin(db: Database) -> None:\n    email = C.ADMIN_EMAIL\n    username = email.split(\"@\")[0]\n    db[C.ADMIN_COLLECTION].insert_one(\n        mongo.get_default_user_doc(\n            email=email,\n            username=username,\n            is_admin=True,\n            display_name=username,\n            password_hash=None,\n            session_info=None,\n            verified=True,\n            security={\n                \"role\": [C.ADMIN],\n            },\n            oauth2=[\"google\"],\n        ),\n    )\n\ndef main() -> None:\n    while True:\n        debug_prompt = input(\"Debug mode? (Y\/n): \").lower().strip()\n        if debug_prompt not in (\"y\", \"n\", \"\"):\n            print(\"Invalid input\", end=\"\\n\\n\")\n            continue\n        else:\n            debug_flag = (debug_prompt != \"n\")\n            break\n\n    with (\n        mongo.get_db_client(get_default=False, get_async=False, debug=debug_flag) as user_client,\n        mongo.get_db_client(get_default=False, get_async=False, debug=debug_flag, get_admin_db=True) as admin_client,\n    ):\n        user_client.drop_database(C.DB_NAME)\n        admin_client.drop_database(C.ADMIN_DB_NAME)\n\n        client_db = user_client[C.DB_NAME]\n        create_user_collection(client_db)\n        create_chat_collection(client_db)\n        client_db.create_collection(name=C.DELETED_CHAT_COLLECTION)\n        create_file_analysis_collection(client_db)\n        create_post_collection(client_db)\n        create_comments_collection(client_db)\n        create_upload_ids_collection(client_db)\n\n        admin_db = admin_client[C.ADMIN_DB_NAME]\n        ban_logs(admin_db)\n        report_logs(admin_db)\n        create_admin_collection(admin_db)\n        seed_super_admin(admin_db)\n        seed_admin(admin_db)\n\nif __name__ == \"__main__\":\n    main()\n    print(\"Done\", end=\"\\n\\n\")"},"\/src\/app\/routers\/api\/general.py":{"changes":[{"diff":"\n             projection = {\"privacy\": True},\n         )\n     elif request.session.get(C.SESSION_COOKIE) is not None:\n-        data = await user_col.find_one(\n-            filter = {\"sessions.session_id\": request.session[C.SESSION_COOKIE]},\n-            projection = {\"privacy\": True},\n-        )\n+        data = rbac_res.user_doc\n     else:\n         data = None\n","add":1,"remove":4,"filename":"\/src\/app\/routers\/api\/general.py","badparts":["        data = await user_col.find_one(","            filter = {\"sessions.session_id\": request.session[C.SESSION_COOKIE]},","            projection = {\"privacy\": True},","        )"],"goodparts":["        data = rbac_res.user_doc"]}],"source":"\n\nimport pymongo import bson from pymongo.collation import Collation, CollationStrength from fastapi import( APIRouter, Request, Query, Path, Depends, Form, ) from fastapi.responses import RedirectResponse from utils import constants as C from utils.functions import( rbac, security as sec, useful, ) import schemas from utils.classes.user import User from utils.functions.oauth2 import( get_facebook_sso, get_google_sso, process_oauth_callback, ) import html general_api=APIRouter( include_in_schema=True, prefix=C.API_PREFIX, dependencies=sec.get_rate_limiter_dependency(C.GENERAL_ROUTER), ) RBAC_DEPENDENCY=Depends(rbac.GENERAL_RBAC, use_cache=False) @general_api.get( path=\"\/get\/post\", description=\"Gets the next(few) posts from the database.\", summary=\"Get posts from Mirai.\", ) async def get_post( request: Request, offset: str | None=Query( default=None, min_length=24, max_length=24, regex=C.BSON_OBJECTID_REGEX, description=\"The offset of the post results using a post's ID\", ), user_id: str | None=Query( default=None, min_length=24, max_length=24, regex=C.BSON_OBJECTID_REGEX, description=\"The offset of the post results using a post's ID\", ), rbac_res: rbac.RBACResults | RedirectResponse=RBAC_DEPENDENCY, ): db=rbac_res.database post_col=db[C.POST_COLLECTION] post_list=[] _filter={} if offset is not None: _filter.update({ \"_id\":{ \"$lt\": bson.ObjectId(offset), }, }) if user_id is not None: _filter.update({ \"user_id\": bson.ObjectId(user_id), }) cursor=post_col.find(_filter) cached_user_info={} user_col=db[C.USER_COLLECTION] async for doc in cursor.sort(\"_id\", pymongo.DESCENDING).limit(5): user_id_str=str(doc[\"user_id\"]) if user_id_str not in cached_user_info: matched_user=await user_col.find_one({ \"_id\": doc[\"user_id\"], }) if matched_user is None: continue cached_user_info[user_id_str]={ \"username\": matched_user[\"username\"], \"display_name\": matched_user[\"display_name\"], \"profile_image\": matched_user[\"profile\"][\"image_url\"], \"mirai_plus\": matched_user[\"mirai_plus\"], } doc.update(cached_user_info[user_id_str]) doc=useful.format_value_for_json(doc) if \"description\" in doc and doc[\"description\"] is not None: doc[\"description\"]=html.unescape(doc[\"description\"]) post_list.append(doc) if not post_list: return[] return post_list @general_api.get( path=\"\/search\", description=\"Looks through the MongoDB to find for a match of search query.\", summary=\"Return search results\", ) async def api_search( request: Request, q: str=Query( default=\"\", min_length=0, ), search_type: schemas.SearchType=Query( default=schemas.SearchType.POST, description=\"The type of search to perform.\", ), offset: str | None=Query( default=None, min_length=24, max_length=24, regex=C.BSON_OBJECTID_REGEX, description=\"The offset of the search results using a user's ID\", ), rbac_res: rbac.RBACResults | RedirectResponse=RBAC_DEPENDENCY, ): q=q.strip() if q==\"\": return[] if len(q) > C.SEARCH_MAX_LENGTH: q=q[:C.SEARCH_MAX_LENGTH] db=rbac_res.database if offset is None: _filter={} else: _filter={ \"_id\":{\"$lt\": bson.ObjectId(offset)}, } user_col=db[C.USER_COLLECTION] post_col=db[C.POST_COLLECTION] if search_type==schemas.SearchType.USER: if q.startswith(\"@\"): _filter.update({ \"username\":{ \"$regex\": q[1:], \"$options\": \"i\", }, }) cursor=user_col.find(_filter).collation( Collation(locale=\"en\", strength=CollationStrength.PRIMARY), ) elif q !=\"\": _filter.update({ \"$or\":[ {\"username\":{ \"$regex\": q, \"$options\": \"i\", }}, {\"display_name\":{ \"$regex\": q, \"$options\": \"i\", }}, ] }) cursor=user_col.find(_filter) else: cursor=user_col.find(_filter) elif q !=\"\": _filter.update({ \"description\":{ \"$regex\": q, \"$options\": \"i\", }, }) cursor=post_col.find(_filter) else: cursor=post_col.find(_filter) results=[] cached_user_info={} async for doc in cursor.sort(\"_id\", pymongo.DESCENDING).limit(25): if search_type==schemas.SearchType.USER: results.append( useful.format_value_for_json({ \"_id\": doc[\"_id\"], \"username\": doc[\"username\"], \"display_name\": doc[\"display_name\"], \"profile_image\": doc[\"profile\"][\"image_url\"], \"bio\": doc[\"profile\"][\"bio\"], \"mirai_plus\": doc[\"mirai_plus\"], }), ) continue user_id_str=str(doc[\"user_id\"]) if user_id_str not in cached_user_info: matched_user=await user_col.find_one({ \"_id\": doc[\"user_id\"], }) if matched_user is None: continue cached_user_info[user_id_str]={ \"username\": matched_user[\"username\"], \"display_name\": matched_user[\"display_name\"], \"profile_image\": matched_user[\"profile\"][\"image_url\"], \"mirai_plus\": matched_user[\"mirai_plus\"], } doc.update(cached_user_info[user_id_str]) doc=useful.format_value_for_json(doc) if \"description\" in doc and doc[\"description\"] is not None: doc[\"description\"]=html.unescape(doc[\"description\"]) results.append(doc) return results @general_api.get( path=\"\/privacy\", response_model=schemas.Permission, response_model_exclude_unset=True, ) async def get_privacy(request: Request, username: str | None=None, rbac_res: rbac.RBACResults | RedirectResponse=RBAC_DEPENDENCY): if isinstance(rbac_res, RedirectResponse): return rbac_res db=rbac_res.database user_col=db[C.USER_COLLECTION] if username is not None: data=await user_col.find_one( filter={\"username\": username}, projection={\"privacy\": True}, ) elif request.session.get(C.SESSION_COOKIE) is not None: data=await user_col.find_one( filter={\"sessions.session_id\": request.session[C.SESSION_COOKIE]}, projection={\"privacy\": True}, ) else: data=None if data is not None: return data.get(\"privacy\") else: return{} @general_api.get( path=\"\/auth\/google\", description=\"Redirect to Google login page.\", ) async def login_google(request: Request, rbac_res: rbac.RBACResults | RedirectResponse=RBAC_DEPENDENCY): if isinstance(rbac_res, RedirectResponse): return rbac_res google_sso=await get_google_sso(request) return await google_sso.get_login_redirect( params={\"access_type\": \"offline\", \"include_granted_scopes\": \"true\"}, ) @general_api.get( path=\"\/auth\/google\/callback\", description=\"Callback from Google OAuth2 login flow for validations\", ) async def login_google_callback(request: Request, rbac_res: rbac.RBACResults | RedirectResponse=RBAC_DEPENDENCY): if isinstance(rbac_res, RedirectResponse): return rbac_res google_sso=await get_google_sso(request) return await process_oauth_callback( sso_obj=google_sso, request=request, oauth_type=\"google\", user_doc=rbac_res.user_doc, ) @general_api.get( path=\"\/auth\/facebook\", description=\"Redirect to Facebook login page.\", ) async def login_facebook(request: Request, rbac_res: rbac.RBACResults | RedirectResponse=RBAC_DEPENDENCY): if isinstance(rbac_res, RedirectResponse): return rbac_res facebook_sso=await get_facebook_sso(request) return await facebook_sso.get_login_redirect() @general_api.get( path=\"\/auth\/facebook\/callback\", description=\"Callback from Facebook OAuth2 login flow for validations\", ) async def login_facebook_callback(request: Request, rbac_res: rbac.RBACResults | RedirectResponse=RBAC_DEPENDENCY): if isinstance(rbac_res, RedirectResponse): return rbac_res facebook_sso=await get_facebook_sso(request) return await process_oauth_callback( sso_obj=facebook_sso, request=request, oauth_type=\"facebook\", user_doc=rbac_res.user_doc, ) ","sourceWithComments":"# import third-party libraries\nimport pymongo\nimport bson\nfrom pymongo.collation import Collation, CollationStrength\nfrom fastapi import (\n    APIRouter, \n    Request, \n    Query,\n    Path,\n    Depends,\n    Form,\n)\nfrom fastapi.responses import RedirectResponse\n# import local Python libraries\nfrom utils import constants as C\nfrom utils.functions import (\n    rbac,\n    security as sec,\n    useful,\n)\nimport schemas\nfrom utils.classes.user import User\nfrom utils.functions.oauth2 import (\n    get_facebook_sso, \n    get_google_sso, \n    process_oauth_callback,\n)\n\n# import Python's standard libraries\nimport html\n\ngeneral_api = APIRouter(\n    include_in_schema=True,\n    prefix=C.API_PREFIX,\n    dependencies=sec.get_rate_limiter_dependency(C.GENERAL_ROUTER),\n)\nRBAC_DEPENDENCY = Depends(rbac.GENERAL_RBAC, use_cache=False)\n\n@general_api.get(\n    path=\"\/get\/post\",\n    description=\"Gets the next (few) posts from the database.\",\n    summary=\"Get posts from Mirai.\",\n)\nasync def get_post(\n    request: Request,\n    offset: str | None = Query(\n        default=None,\n        min_length=24,\n        max_length=24,\n        regex=C.BSON_OBJECTID_REGEX,\n        description=\"The offset of the post results using a post's ID\",\n    ),\n    user_id: str | None = Query(\n        default=None,\n        min_length=24,\n        max_length=24,\n        regex=C.BSON_OBJECTID_REGEX,\n        description=\"The offset of the post results using a post's ID\",\n    ),\n    rbac_res: rbac.RBACResults | RedirectResponse = RBAC_DEPENDENCY,\n):\n    db = rbac_res.database\n    post_col = db[C.POST_COLLECTION]\n    post_list = []\n\n    _filter = {}\n    if offset is not None:\n        _filter.update({\n            \"_id\": {\n                \"$lt\": bson.ObjectId(offset),\n            },\n        })\n\n    if user_id is not None:\n        _filter.update({\n            \"user_id\": bson.ObjectId(user_id),\n        })\n\n    cursor = post_col.find(_filter)\n    cached_user_info = {}\n    user_col = db[C.USER_COLLECTION]\n    async for doc in cursor.sort(\"_id\", pymongo.DESCENDING).limit(5):\n        user_id_str = str(doc[\"user_id\"])\n        if user_id_str not in cached_user_info:\n            matched_user = await user_col.find_one({\n                \"_id\": doc[\"user_id\"],\n            })\n            if matched_user is None:\n                continue\n\n            cached_user_info[user_id_str] = {\n                \"username\": matched_user[\"username\"],\n                \"display_name\": matched_user[\"display_name\"],\n                \"profile_image\": matched_user[\"profile\"][\"image_url\"],\n                \"mirai_plus\": matched_user[\"mirai_plus\"],\n            }\n\n        doc.update(cached_user_info[user_id_str])\n        doc = useful.format_value_for_json(doc)\n        if \"description\" in doc and doc[\"description\"] is not None:\n            # We will be using DOMPurify to sanitize the HTML client-side\n            doc[\"description\"] = html.unescape(doc[\"description\"])\n\n        post_list.append(doc)\n\n    if not post_list:\n        return []\n\n    return post_list\n\n@general_api.get(\n    path=\"\/search\",\n    description=\"Looks through the MongoDB to find for a match of search query.\",\n    summary=\"Return search results\",\n)\nasync def api_search(\n    request: Request,\n    q: str = Query(\n        default=\"\",\n        min_length=0, \n    ),\n    search_type: schemas.SearchType = Query(\n        default=schemas.SearchType.POST,\n        description=\"The type of search to perform.\",\n    ),\n    offset: str | None = Query(\n        default=None,\n        min_length=24,\n        max_length=24,\n        regex=C.BSON_OBJECTID_REGEX,\n        description=\"The offset of the search results using a user's ID\",\n    ),\n    rbac_res: rbac.RBACResults | RedirectResponse = RBAC_DEPENDENCY,\n):\n    q = q.strip()\n    if q == \"\":\n        return []\n\n    if len(q) > C.SEARCH_MAX_LENGTH:\n        q = q[:C.SEARCH_MAX_LENGTH]\n\n    db = rbac_res.database\n    if offset is None:\n        _filter = {}\n    else:\n        _filter = {\n            \"_id\": {\"$lt\": bson.ObjectId(offset)},\n        }\n\n    user_col = db[C.USER_COLLECTION]\n    post_col = db[C.POST_COLLECTION]\n    if search_type == schemas.SearchType.USER:\n        if q.startswith(\"@\"):\n            _filter.update({\n                \"username\": {\n                    \"$regex\": q[1:], \n                    \"$options\": \"i\",\n                },\n            })\n            cursor = user_col.find(_filter).collation(\n                Collation(locale=\"en\", strength=CollationStrength.PRIMARY),\n            )\n        elif q != \"\":\n            _filter.update({\n                \"$or\": [\n                    {\"username\": {\n                        \"$regex\": q,\n                        \"$options\": \"i\",\n                    }},\n                    {\"display_name\": {\n                        \"$regex\": q,\n                        \"$options\": \"i\",\n                    }},\n                ]\n            })\n            cursor = user_col.find(_filter)\n        else:\n            cursor = user_col.find(_filter)\n    elif q != \"\": # post\n        _filter.update({\n            \"description\": {\n                \"$regex\": q,\n                \"$options\": \"i\",\n            },\n        })\n        cursor = post_col.find(_filter)\n    else: # list all posts\n        cursor = post_col.find(_filter)\n\n    results = []\n    cached_user_info = {}\n    async for doc in cursor.sort(\"_id\", pymongo.DESCENDING).limit(25):\n        if search_type == schemas.SearchType.USER:\n            results.append(\n                useful.format_value_for_json({\n                    \"_id\": doc[\"_id\"],\n                    \"username\": doc[\"username\"],\n                    \"display_name\": doc[\"display_name\"],\n                    \"profile_image\": doc[\"profile\"][\"image_url\"],\n                    \"bio\": doc[\"profile\"][\"bio\"],\n                    \"mirai_plus\": doc[\"mirai_plus\"],\n                }),\n            )\n            continue\n\n        user_id_str = str(doc[\"user_id\"])\n        if user_id_str not in cached_user_info:\n            matched_user = await user_col.find_one({\n                \"_id\": doc[\"user_id\"],\n            })\n            if matched_user is None:\n                continue\n\n            cached_user_info[user_id_str] = {\n                \"username\": matched_user[\"username\"],\n                \"display_name\": matched_user[\"display_name\"],\n                \"profile_image\": matched_user[\"profile\"][\"image_url\"],\n                \"mirai_plus\": matched_user[\"mirai_plus\"],\n            }\n\n        doc.update(cached_user_info[user_id_str])\n        doc = useful.format_value_for_json(doc)\n        if \"description\" in doc and doc[\"description\"] is not None:\n            # We will be using DOMPurify to sanitize the HTML client-side\n            doc[\"description\"] = html.unescape(doc[\"description\"])\n\n        results.append(doc)\n    return results\n\n@general_api.get(\n    path=\"\/privacy\",\n    response_model=schemas.Permission,\n    response_model_exclude_unset=True,\n)\nasync def get_privacy(request: Request, username: str | None = None, rbac_res: rbac.RBACResults | RedirectResponse = RBAC_DEPENDENCY):\n    if isinstance(rbac_res, RedirectResponse):\n        return rbac_res\n\n    db = rbac_res.database\n    user_col = db[C.USER_COLLECTION]\n\n    if username is not None:\n        data = await user_col.find_one(\n            filter = {\"username\": username},\n            projection = {\"privacy\": True},\n        )\n    elif request.session.get(C.SESSION_COOKIE) is not None:\n        data = await user_col.find_one(\n            filter = {\"sessions.session_id\": request.session[C.SESSION_COOKIE]},\n            projection = {\"privacy\": True},\n        )\n    else:\n        data = None\n\n    if data is not None:\n        return data.get(\"privacy\")\n    else:\n        return {}\n\n@general_api.get(\n    path=\"\/auth\/google\",\n    description=\"Redirect to Google login page.\",\n)\nasync def login_google(request: Request, rbac_res: rbac.RBACResults | RedirectResponse = RBAC_DEPENDENCY):\n    if isinstance(rbac_res, RedirectResponse):\n        return rbac_res\n\n    google_sso = await get_google_sso(request)\n    return await google_sso.get_login_redirect(\n        params={\"access_type\": \"offline\", \"include_granted_scopes\": \"true\"},\n    )\n\n@general_api.get(\n    path=\"\/auth\/google\/callback\",\n    description=\"Callback from Google OAuth2 login flow for validations\",\n)\nasync def login_google_callback(request: Request, rbac_res: rbac.RBACResults | RedirectResponse = RBAC_DEPENDENCY):\n    if isinstance(rbac_res, RedirectResponse):\n        return rbac_res\n\n    google_sso = await get_google_sso(request)\n    return await process_oauth_callback(\n        sso_obj=google_sso,\n        request=request,\n        oauth_type=\"google\",\n        user_doc=rbac_res.user_doc,\n    )\n\n@general_api.get(\n    path=\"\/auth\/facebook\",\n    description=\"Redirect to Facebook login page.\",\n)\nasync def login_facebook(request: Request, rbac_res: rbac.RBACResults | RedirectResponse = RBAC_DEPENDENCY):\n    if isinstance(rbac_res, RedirectResponse):\n        return rbac_res\n\n    facebook_sso = await get_facebook_sso(request)\n    return await facebook_sso.get_login_redirect()\n\n@general_api.get(\n    path=\"\/auth\/facebook\/callback\",\n    description=\"Callback from Facebook OAuth2 login flow for validations\",\n)\nasync def login_facebook_callback(request: Request, rbac_res: rbac.RBACResults | RedirectResponse = RBAC_DEPENDENCY):\n    if isinstance(rbac_res, RedirectResponse):\n        return rbac_res\n\n    facebook_sso = await get_facebook_sso(request)\n    return await process_oauth_callback(\n        sso_obj=facebook_sso,\n        request=request,\n        oauth_type=\"facebook\",\n        user_doc=rbac_res.user_doc,\n    )"},"\/src\/app\/utils\/functions\/database.py":{"changes":[{"diff":"\n     return user_doc, user_doc[\"security\"][\"role\"]\n \n async def get_account_count(db: Database, acc_type: str) -> str:\n-    db = get_db_client(get_default=True, get_admin_db=False,)\n+    db = get_db_client(get_default=True, get_admin_db=False)\n     admin_db = get_db_client(get_admin_db=True)\n     if acc_type == \"user\":\n         user_count = await db[C.USER_COLLECTION].count_documents({\n","add":1,"remove":1,"filename":"\/src\/app\/utils\/functions\/database.py","badparts":["    db = get_db_client(get_default=True, get_admin_db=False,)"],"goodparts":["    db = get_db_client(get_default=True, get_admin_db=False)"]},{"diff":"\n \n # retrieve all users in the databases\n async def get_all_users(db: Database, acc_type: str) -> list[dict]:\n-    \n     if acc_type == \"user\":\n         users =  db[C.USER_COLLECTION].find({\n             \"security.role\": {\n-                    \"$elemMatch\": {\n-                        \"$eq\": C.USER,\n-                        },\n-                \n+                \"$elemMatch\": {\n+                    \"$eq\": C.USER,\n+                },\n             },\n         })                          \n     elif acc_type == \"admin\":\n         users = db[C.ADMIN_COLLECTION].find({\n             \"security.role\": {\n-                    \"$elemMatch\": {\n-                        \"$eq\": C.ADMIN,\n-                        },\n-                \n+                \"$elemMatch\": {\n+                    \"$eq\": C.ADMIN,\n+                },\n             },\n         })\n \n     elif acc_type == \"root\":\n         users =  db[C.ADMIN_COLLECTION].find({\n             \"security.role\": {\n-                    \"$elemMatch\": {\n-                        \"$eq\": C.ROOT,\n-                        },\n-                \n+                \"$elemMatch\": {\n+                    \"$eq\": C.ROOT,\n+                },\n             },\n         })\n     else:\n         raise ValueError(\"Invalid account type\")\n     return await users.to_list(None)\n-    \n \n async def get_all_reports(db: Database) -> list[dict]:\n     users = db[C.REPORT_COLLECTION].find","add":9,"remove":14,"filename":"\/src\/app\/utils\/functions\/database.py","badparts":["                    \"$elemMatch\": {","                        \"$eq\": C.USER,","                        },","                    \"$elemMatch\": {","                        \"$eq\": C.ADMIN,","                        },","                    \"$elemMatch\": {","                        \"$eq\": C.ROOT,","                        },"],"goodparts":["                \"$elemMatch\": {","                    \"$eq\": C.USER,","                },","                \"$elemMatch\": {","                    \"$eq\": C.ADMIN,","                },","                \"$elemMatch\": {","                    \"$eq\": C.ROOT,","                },"]}],"source":"\n\nfrom fastapi import Request, WebSocket import pymongo import bson from dicebear import DAvatar, DStyle from pymongo.collection import Collection from pymongo.database import Database import motor.motor_asyncio as mongodb from utils import constants as C from.useful import get_location_str from gcp import SECRET_MANAGER import time from datetime import datetime import urllib.parse as urlparse USER_CONN_STR=( f\"\"\" mongodb+srv:\/\/ {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.DB_USERNAME_SECRET_ID))} : {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.DB_PASSWORD_SECRET_ID))} @mirai.qlwjl.mongodb.net\/?retryWrites=true&w=majority \"\"\".replace(\"\\n\", \"\").replace(\" \", \"\"), \"mongodb:\/\/localhost:27017\", ) ADMIN_CONN_STR=( f\"\"\" mongodb+srv:\/\/ {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.ADMIN_DB_USERNAME_SECRET_ID))} : {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.ADMIN_DB_PASSWORD_SECRET_ID))} @mirai-admin.qlwjl.mongodb.net\/?retryWrites=true&w=majority \"\"\".replace(\"\\n\", \"\").replace(\" \", \"\"), \"mongodb:\/\/localhost:27017\", ) def get_default_user_doc( email: str, username: str, is_registering: bool | None=False, is_admin: bool | None=False, password_hash: bytes | None=None, session_info: dict | None=None, **kwargs, ) -> dict: \"\"\"Returns the default user document to be inserted into the database for a new user. Args: email(str): The user's email address. Must be lowercase. username(str): The user's username. Must be lowercase. is_registering(bool | None): Whether the user is registering or not such that the user won't have to verify their login location after registering. Note: A location str must be passed in as the \"location\" keyword argument. is-admin(bool | None): Whether the user is an admin or not and return the corresponding user document. password_hash(bytes | None): The user's password hash. If None, the user will be created without a password. session_info(dict | None): The user's session information. Must contain the following keys: \"id\"(str), \"expiry\"(datetime). **kwargs: Any other key-value pairs to be added to the user document. Returns: dict: The default user document. \"\"\" if is_admin: user_doc={ \"email\": email, \"username\": username, \"display_name\": username, \"verified\": True, \"banned\": False, \"security\":{ \"role\":[C.ADMIN], }, \"profile\":{ \"image_url\": DAvatar(style=DStyle.initials, seed=username).url_png, \"banner_image_url\":\"https:\/\/image-assets.eu-2.volcanic.cloud\/api\/v1\/assets\/images\/7cf6c0d7de9c8a38729c02aff196e391?t=1664372891&webp_fallback=png\", }, \"created_at\": datetime.utcnow(), } else: user_doc={ \"created_at\": datetime.utcnow(), \"email\": email, \"display_name\": username, \"username\": username, \"mirai_plus\": False, \"banned\": False, \"content_moderation\":{ \"sexual_images\": True, \"violent_images\": True, \"meme_images\": False, }, \"verified\": False, \"profile\":{ \"image_url\": DAvatar(style=DStyle.initials, seed=username).url_png, \"banner_image_url\":\"https:\/\/image-assets.eu-2.volcanic.cloud\/api\/v1\/assets\/images\/7cf6c0d7de9c8a38729c02aff196e391?t=1664372891&webp_fallback=png\", \"bio\": \"Hello! I'm new to Mirai!\", \"location\": \"Earth\", \"url\": \"https:\/\/mirai.network\", }, \"privacy\":{ \"send_direct_messages\": C.FRIENDSHIP_TYPE.FOLLOWERS, \"be_follower\": C.FRIENDSHIP_TYPE.REQUEST_NEEDED, \"see_posts\": C.FRIENDSHIP_TYPE.FOLLOWERS, \"see_profile\": C.FRIENDSHIP_TYPE.FOLLOWERS, \"last_updated\": None, }, \"social\":{ follower_type:[] for follower_type in C.FOLLOWER_TYPE }, \"security\":{ \"role\":[C.USER], }, \"chat\":{ \"online\": False, \"message_timer\": 0, \"password_protection\": None, \"hide_online_status\": False, }, } if is_registering: user_doc[\"security\"][\"last_accessed\"]=[{ \"location\": kwargs.pop(\"location\"), \"datetime\": time.time(), }] if password_hash is not None: user_doc[\"password\"]=bson.Binary(password_hash) if session_info is not None: user_doc[\"sessions\"]=[ {\"session_id\": session_info[\"id\"], \"expiry_date\": session_info[\"expiry\"]}, ] user_doc.update(kwargs) return user_doc def get_db_client(get_default: bool | None=True, get_admin_db: bool | None=False, get_async: bool | None=True, debug: bool=C.DEBUG_MODE) -> pymongo.MongoClient | Database: \"\"\"Get a MongoDB client or the database connection. Args: get_default(bool, optional): Get the default database object. Defaults to True. Otherwise, get the client to connect to other databases. get_admin_db(bool, optional): Get the admin database server client. Defaults to False. get_async(bool, optional): Get the async client. Defaults to True. Otherwise, get the normal\/synchronous client. debug_mode(bool): True if debug mode is enabled which will connect to the local database instead of a remote instance\/cluster. Defaults to the value in constants.py. Returns: pymongo.MongoClient | Database: The MongoDB client or database connection. \"\"\" conn_str=USER_CONN_STR[debug] \\ if not get_admin_db else ADMIN_CONN_STR[debug] kwargs={ \"host\": conn_str, \"tls\": not debug, } if get_async: client=mongodb.AsyncIOMotorClient( **kwargs, ) else: client=pymongo.MongoClient( **kwargs, ) db_name=C.ADMIN_DB_NAME if get_admin_db else C.DB_NAME return client[db_name] if get_default else client async def get_user_from_session(request: Request | WebSocket, session_id: str, col: Collection=None) -> dict | None: \"\"\"Get the user document from the session ID. Args: request(Request | WebSocket): The request or websocket object. session_id(str): The session ID. col(Collection, optional): The collection to search in. Defaults to None. If None, a new client to the database will be created. Returns: dict | None: The user document if found, otherwise None. \"\"\" col_is_none=(col is None) if col_is_none: db=get_db_client() col=db[C.USER_COLLECTION] time_now=datetime.utcnow() user_location=await get_location_str(request) _filter={ \"sessions.session_id\": session_id, \"sessions.expiry_date\":{\"$gt\": time_now}, \"sessions.location\": user_location, } user_doc: dict | None=await col.find_one(_filter) if user_doc is None and not col_is_none: return None elif user_doc is not None: return user_doc db=get_db_client(get_admin_db=True) admin_col=db[C.ADMIN_COLLECTION] admin_doc: dict | None=await admin_col.find_one(_filter) if admin_doc is None: return None return admin_doc async def get_user_role( request: Request, session_id: str, col: Collection | None=None, clear_session_if_invalid: bool | None=True, ) -> tuple[dict | None, list[str]]: \"\"\"Get the role of the user from the session ID. Args: request(Request): The request object. session_id(str): The session ID. col(Collection, optional): Collection to search in. Defaults to None. If None, a new client to the database will be created. clear_session_if_invalid(bool, optional): Whether to clear the session if the session ID is invalid. Defaults to True. Returns: tuple[dict | None, list[str]]: The user document and the role of the user. \"\"\" default=[C.GUEST] if session_id is None: return None, default user_doc=await get_user_from_session( request=request, session_id=session_id, col=col, ) if user_doc is None: if clear_session_if_invalid: request.session.clear() return None, default return user_doc, user_doc[\"security\"][\"role\"] async def get_account_count(db: Database, acc_type: str) -> str: db=get_db_client(get_default=True, get_admin_db=False,) admin_db=get_db_client(get_admin_db=True) if acc_type==\"user\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^User \\d+$\" } }) elif acc_type==\"admin\": user_count=await admin_db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Admin \\d+$\" } }) elif acc_type==\"root\": user_count=await admin_db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Maintenance \\d+$\" } }) elif acc_type==\"super_root\": user_count=await admin_db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Super Root$\" } }) elif acc_type==\"all\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^(User|Admin|Maintenance|Super Root) \\d+$\" } }) elif acc_type==\"fake_reporter\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Fakereporter \\d+$\" } }) elif acc_type==\"victim99\": user_count=await db[C.USER_COLLECTION].count_documents({ \"username\":{ \"$regex\": r\"^Victim99 \\d+$\" } }) else: raise ValueError(\"Invalid account type\") return user_count async def get_report_count(db: Database) -> str: report_count=await db[C.REPORT_COLLECTION].count_documents( { \"status\": \"open\"} ) if report_count==0: return 0 return report_count async def get_all_users(db: Database, acc_type: str) -> list[dict]: if acc_type==\"user\": users= db[C.USER_COLLECTION].find({ \"security.role\":{ \"$elemMatch\":{ \"$eq\": C.USER, }, }, }) elif acc_type==\"admin\": users=db[C.ADMIN_COLLECTION].find({ \"security.role\":{ \"$elemMatch\":{ \"$eq\": C.ADMIN, }, }, }) elif acc_type==\"root\": users= db[C.ADMIN_COLLECTION].find({ \"security.role\":{ \"$elemMatch\":{ \"$eq\": C.ROOT, }, }, }) else: raise ValueError(\"Invalid account type\") return await users.to_list(None) async def get_all_reports(db: Database) -> list[dict]: users=db[C.REPORT_COLLECTION].find({ \"status\": \"open\", }) return await users.to_list(None) async def get_all_bans(db: Database) -> list[dict]: users=db[C.BAN_COLLECTION].find({}) return await users.to_list(None) async def ban_user(db: Database, users: str) -> None: await db[C.USER_COLLECTION].update_one() ","sourceWithComments":"# import third-party libraries\nfrom fastapi import Request, WebSocket\nimport pymongo\nimport bson\nfrom dicebear import DAvatar, DStyle\nfrom pymongo.collection import Collection\nfrom pymongo.database import Database\nimport motor.motor_asyncio as mongodb\n\n# import local Python libraries\nfrom utils import constants as C\nfrom .useful import get_location_str\nfrom gcp import SECRET_MANAGER\n\n# import Python's standard libraries\nimport time\nfrom datetime import datetime\nimport urllib.parse as urlparse\n\n# docs: https:\/\/github.com\/mongodb\/motor\/blob\/master\/doc\/tutorial-asyncio.rst\nUSER_CONN_STR = (\n    f\"\"\"\n        mongodb+srv:\/\/\n        {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.DB_USERNAME_SECRET_ID))}\n        :\n        {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.DB_PASSWORD_SECRET_ID))}\n        @mirai.qlwjl.mongodb.net\/?retryWrites=true&w=majority\n    \"\"\".replace(\"\\n\", \"\").replace(\" \", \"\"),\n    \"mongodb:\/\/localhost:27017\",\n)\nADMIN_CONN_STR = (\n    f\"\"\"\n        mongodb+srv:\/\/\n        {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.ADMIN_DB_USERNAME_SECRET_ID))}\n        :\n        {urlparse.quote_plus(SECRET_MANAGER.get_secret_payload(secret_id=C.ADMIN_DB_PASSWORD_SECRET_ID))}\n        @mirai-admin.qlwjl.mongodb.net\/?retryWrites=true&w=majority\n    \"\"\".replace(\"\\n\", \"\").replace(\" \", \"\"),\n    \"mongodb:\/\/localhost:27017\",\n)\n\ndef get_default_user_doc(\n    email: str, \n    username: str, \n    is_registering: bool | None = False,\n    is_admin: bool | None = False,\n    password_hash: bytes | None = None, \n    session_info: dict | None = None, \n    **kwargs,\n    ) -> dict:\n    \"\"\"Returns the default user document to be inserted into the database for a new user.\n\n    Args:\n        email (str):\n            The user's email address. Must be lowercase.\n        username (str):\n            The user's username. Must be lowercase.\n        is_registering (bool | None):\n            Whether the user is registering or not such that \n            the user won't have to verify their login location after registering.\n            Note: A location str must be passed in as the \"location\" keyword argument.\n        is-admin (bool | None):\n            Whether the user is an admin or not and return the corresponding user document.\n        password_hash (bytes | None):\n            The user's password hash. If None, the user will be created without a password.\n        session_info (dict | None):\n            The user's session information. Must contain the following\n            keys: \"id\" (str), \"expiry\" (datetime).\n        **kwargs:\n            Any other key-value pairs to be added to the user document.\n\n    Returns:\n        dict: \n            The default user document.\n    \"\"\"\n    if is_admin:\n        user_doc = {\n            \"email\": email,\n            \"username\": username,\n            \"display_name\": username,\n            \"verified\": True,\n            \"banned\": False,\n            \"security\": {\n                \"role\": [C.ADMIN],\n            },\n            \"profile\": {\n                \"image_url\": DAvatar(style=DStyle.initials, seed=username).url_png, \n                \"banner_image_url\":\"https:\/\/image-assets.eu-2.volcanic.cloud\/api\/v1\/assets\/images\/7cf6c0d7de9c8a38729c02aff196e391?t=1664372891&webp_fallback=png\",\n            },\n            \"created_at\": datetime.utcnow(),\n        }\n    else:\n        user_doc = {\n            \"created_at\": datetime.utcnow(),\n            \"email\": email,\n            \"display_name\": username,\n            \"username\": username,\n            \"mirai_plus\": False,\n            \"banned\": False,\n            \"content_moderation\": {\n                \"sexual_images\": True,\n                \"violent_images\": True,\n                \"meme_images\": False,\n            },\n            \"verified\": False,\n            \"profile\": {\n                \"image_url\": DAvatar(style=DStyle.initials, seed=username).url_png, \n                \"banner_image_url\":\"https:\/\/image-assets.eu-2.volcanic.cloud\/api\/v1\/assets\/images\/7cf6c0d7de9c8a38729c02aff196e391?t=1664372891&webp_fallback=png\",\n                \"bio\": \"Hello! I'm new to Mirai!\",\n                \"location\": \"Earth\",\n                \"url\": \"https:\/\/mirai.network\",\n            },\n            \"privacy\": {\n                \"send_direct_messages\": C.FRIENDSHIP_TYPE.FOLLOWERS,\n                \"be_follower\": C.FRIENDSHIP_TYPE.REQUEST_NEEDED,\n                \"see_posts\": C.FRIENDSHIP_TYPE.FOLLOWERS,\n                \"see_profile\": C.FRIENDSHIP_TYPE.FOLLOWERS,\n                \"last_updated\": None,\n            },\n            \"social\": {\n                follower_type: [] \n                for follower_type in C.FOLLOWER_TYPE\n            },\n            \"security\": {\n                \"role\": [C.USER],\n            },\n            \"chat\": {\n                \"online\": False,\n                \"message_timer\": 0,\n                \"password_protection\": None,\n                \"hide_online_status\": False,\n            },\n        }\n\n    if is_registering:\n        user_doc[\"security\"][\"last_accessed\"] = [{\n            \"location\": kwargs.pop(\"location\"),\n            \"datetime\": time.time(),\n        }]\n\n    if password_hash is not None:\n        user_doc[\"password\"] = bson.Binary(password_hash)\n\n    if session_info is not None:\n        user_doc[\"sessions\"] = [\n            {\"session_id\": session_info[\"id\"], \"expiry_date\": session_info[\"expiry\"]},\n        ]\n\n    user_doc.update(kwargs)\n    return user_doc\n\ndef get_db_client(get_default: bool | None = True, get_admin_db: bool | None = False, \n                  get_async: bool | None = True, debug: bool = C.DEBUG_MODE) -> pymongo.MongoClient | Database:\n    \"\"\"Get a MongoDB client or the database connection.\n\n    Args:\n        get_default (bool, optional): \n            Get the default database object. Defaults to True.\n            Otherwise, get the client to connect to other databases.\n        get_admin_db (bool, optional):\n            Get the admin database server client. Defaults to False.\n        get_async (bool, optional):\n            Get the async client. Defaults to True.\n            Otherwise, get the normal\/synchronous client.\n        debug_mode (bool):\n            True if debug mode is enabled which will\n            connect to the local database instead of a remote instance\/cluster.\n            Defaults to the value in constants.py.\n\n    Returns:\n        pymongo.MongoClient | Database:\n            The MongoDB client or database connection.\n    \"\"\"\n    conn_str = USER_CONN_STR[debug] \\\n                if not get_admin_db else ADMIN_CONN_STR[debug]\n    kwargs = {\n        \"host\": conn_str,\n        \"tls\": not debug,\n    }\n    if get_async:\n        client = mongodb.AsyncIOMotorClient(\n            **kwargs,\n        )\n    else:\n        client = pymongo.MongoClient(\n            **kwargs,\n        )\n    db_name = C.ADMIN_DB_NAME if get_admin_db else C.DB_NAME\n    return client[db_name] if get_default else client\n\nasync def get_user_from_session(request: Request | WebSocket, session_id: str, col: Collection = None) -> dict | None:\n    \"\"\"Get the user document from the session ID.\n\n    Args:\n        request (Request | WebSocket):\n            The request or websocket object.\n        session_id (str):\n            The session ID.\n        col (Collection, optional):\n            The collection to search in. Defaults to None.\n            If None, a new client to the database will be created.\n\n    Returns:\n        dict | None:\n            The user document if found, otherwise None.\n    \"\"\"\n    col_is_none = (col is None)\n    if col_is_none:\n        db = get_db_client()\n        col = db[C.USER_COLLECTION]\n\n    time_now = datetime.utcnow()\n    user_location = await get_location_str(request)\n    _filter = {\n        \"sessions.session_id\": session_id, \n        \"sessions.expiry_date\": {\"$gt\": time_now},\n        \"sessions.location\": user_location,\n    }\n\n    user_doc: dict | None = await col.find_one(_filter)\n    if user_doc is None and not col_is_none:\n        # The session ID is invalid\n        return None\n    elif user_doc is not None:\n        return user_doc\n\n    # check admin db\n    db = get_db_client(get_admin_db=True)\n    admin_col = db[C.ADMIN_COLLECTION]\n    admin_doc: dict | None = await admin_col.find_one(_filter)\n    if admin_doc is None:\n        # The session ID is invalid\n        return None\n    return admin_doc\n\nasync def get_user_role(\n    request: Request, session_id: str, \n    col: Collection | None = None, \n    clear_session_if_invalid: bool | None = True,\n) -> tuple[dict | None, list[str]]:\n    \"\"\"Get the role of the user from the session ID.\n\n    Args:\n        request (Request):\n            The request object.\n        session_id (str): \n            The session ID.\n        col (Collection, optional):\n            Collection to search in. Defaults to None.\n            If None, a new client to the database will be created.\n        clear_session_if_invalid (bool, optional):\n            Whether to clear the session if the session ID is invalid.\n            Defaults to True.\n\n    Returns:\n        tuple[dict | None, list[str]]:\n            The user document and the role of the user.\n    \"\"\"\n    default = [C.GUEST]\n    if session_id is None:\n        return None, default\n\n    user_doc = await get_user_from_session(\n        request=request,\n        session_id=session_id, \n        col=col,\n    )\n    if user_doc is None:\n        if clear_session_if_invalid:\n            # The session ID is invalid\n            request.session.clear()\n        return None, default\n\n    return user_doc, user_doc[\"security\"][\"role\"]\n\nasync def get_account_count(db: Database, acc_type: str) -> str:\n    db = get_db_client(get_default=True, get_admin_db=False,)\n    admin_db = get_db_client(get_admin_db=True)\n    if acc_type == \"user\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^User \\d+$\"\n            }\n        })\n\n    elif acc_type == \"admin\":\n        user_count = await admin_db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Admin \\d+$\"\n            }\n        })\n\n    elif acc_type == \"root\":\n        user_count = await admin_db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Maintenance \\d+$\"\n            }\n        })\n\n    elif acc_type == \"super_root\":\n        user_count = await admin_db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Super Root$\"\n            }\n        })\n    elif acc_type == \"all\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^(User|Admin|Maintenance|Super Root) \\d+$\"\n            }\n        })\n    elif acc_type == \"fake_reporter\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Fakereporter \\d+$\"\n            }\n        })\n    elif acc_type == \"victim99\":\n        user_count = await db[C.USER_COLLECTION].count_documents({\n            \"username\": {\n                \"$regex\": r\"^Victim99 \\d+$\"\n            }\n        })\n    else:\n        raise ValueError(\"Invalid account type\")\n    return user_count\n\nasync def get_report_count(db: Database) -> str:\n    report_count = await db[C.REPORT_COLLECTION].count_documents(\n        { \"status\": \"open\" }\n    )\n    if report_count == 0:\n        return 0\n    return report_count \n\n# retrieve all users in the databases\nasync def get_all_users(db: Database, acc_type: str) -> list[dict]:\n    \n    if acc_type == \"user\":\n        users =  db[C.USER_COLLECTION].find({\n            \"security.role\": {\n                    \"$elemMatch\": {\n                        \"$eq\": C.USER,\n                        },\n                \n            },\n        })                          \n    elif acc_type == \"admin\":\n        users = db[C.ADMIN_COLLECTION].find({\n            \"security.role\": {\n                    \"$elemMatch\": {\n                        \"$eq\": C.ADMIN,\n                        },\n                \n            },\n        })\n\n    elif acc_type == \"root\":\n        users =  db[C.ADMIN_COLLECTION].find({\n            \"security.role\": {\n                    \"$elemMatch\": {\n                        \"$eq\": C.ROOT,\n                        },\n                \n            },\n        })\n    else:\n        raise ValueError(\"Invalid account type\")\n    return await users.to_list(None)\n    \n\nasync def get_all_reports(db: Database) -> list[dict]:\n    users = db[C.REPORT_COLLECTION].find({\n        \"status\": \"open\",\n    })\n\n    return await users.to_list(None)\n\nasync def get_all_bans(db: Database) -> list[dict]:\n    users = db[C.BAN_COLLECTION].find({})\n\n    return await users.to_list(None)\n\nasync def ban_user(db: Database, users: str) -> None:\n    #updates the user's status to banned\n    await db[C.USER_COLLECTION].update_one()"},"\/src\/app\/utils\/functions\/security.py":{"changes":[{"diff":"\n     current_datetime = datetime.utcnow()\n     expiry_date = current_datetime + timedelta(seconds=session_expiry)\n \n-    ua = user_agents.parse(request.headers.get(\"User-Agent\", \"\"))\n-    os_name = ua.os.family + \" \" + ua.os.version_string\n+    ua = request.headers.get(\"User-Agent\", \"\")\n+    parsed_ua = user_agents.parse(ua)\n+    os_name = parsed_ua.os.family + \" \" + parsed_ua.os.version_string\n     session_data = {\n         \"session_id\": session_id,\n         \"added_on\": current_datetime,\n         \"expiry_date\": expiry_date,\n-        \"browser\": ua.browser.family,\n+        \"browser\": parsed_ua.browser.family,\n         \"os\": os_name.strip(),\n         \"location\": location,\n+        \"user_agent\": hashlib.sha256(ua.encode(\"utf-8\")).hexdigest(),\n     }\n     if session_expiry == C.DO_NOT_REMEMBER_EXPIRY:\n         request.session[C.EXPIRY_ONCLOSE] = T","add":5,"remove":3,"filename":"\/src\/app\/utils\/functions\/security.py","badparts":["    ua = user_agents.parse(request.headers.get(\"User-Agent\", \"\"))","    os_name = ua.os.family + \" \" + ua.os.version_string","        \"browser\": ua.browser.family,"],"goodparts":["    ua = request.headers.get(\"User-Agent\", \"\")","    parsed_ua = user_agents.parse(ua)","    os_name = parsed_ua.os.family + \" \" + parsed_ua.os.version_string","        \"browser\": parsed_ua.browser.family,","        \"user_agent\": hashlib.sha256(ua.encode(\"utf-8\")).hexdigest(),"]}],"source":"\n\nimport pyotp import qrcode import user_agents from fastapi import Request from fastapi.params import Depends import argon2.exceptions as argon2_e from pymongo.collection import Collection from fastapi.responses import ORJSONResponse from fastapi.exceptions import HTTPException from utils import constants as C from utils.functions.useful import( url_for, get_user_ip, download_url, ) from gcp import( AESGCM, GCPKMS, reCAPTCHA, NOREPLY_EMAIL, ) from.useful import get_location_str from utils.classes.hmac import get_hmac_signer import io import time import html import random import base64 import hashlib import secrets import asyncio import warnings from datetime import datetime, timedelta from binascii import Error as BinasciiError async def random_sleep(min_t: int | None=2, max_t: int | None=4) -> None: \"\"\"Sleeps for a random amount of time to make brute force attacks harder via security through obscurity. Args: min_t(int, optional): The minimum time to sleep for. Defaults to 2. max_t(int, optional): The maximum time to sleep for. Defaults to 4. Returns: None \"\"\" await asyncio.sleep(random.uniform(min_t, max_t)) async def encrypt_token(token: str, key_id: str | None=C.TOKEN_KEY) -> str: \"\"\"Encrypts a token using AESGCM. Args: token(str): The token to encrypt. key_id(str, optional): The key ID to use. Defaults to C.TOKEN_KEY. Returns: str: The encrypted token. \"\"\" encrypted_token=await AESGCM.symmetric_encrypt( plaintext=token, key_id=key_id, ) return base64.urlsafe_b64encode(encrypted_token).decode(\"utf-8\") async def decrypt_token(token: str, key_id: str | None=C.TOKEN_KEY) -> str | None: \"\"\"Decrypts a token using AESGCM. Args: token(str): The token to decrypt. key_id(str, optional): The key ID to use. Defaults to C.TOKEN_KEY. Returns: str | None: The decrypted token or None if the token is invalid. \"\"\" if token is None: return None try: token=base64.urlsafe_b64decode(token) decrypted_token=await AESGCM.symmetric_decrypt( ciphertext=token, key_id=key_id, ) except(HTTPException, BinasciiError, ValueError, TypeError): return None return decrypted_token async def send_email_token(request: Request, user_doc: dict, location: str, user_col: Collection) -> None: \"\"\"Sends an email token to the user for verification. Args: request(Request): The request object. user_doc(dict): The user document. location(str): The location string. user_col(Collection): The user collection. Returns: None: \"\"\" ip_addr=get_user_ip(request) current_datetime=datetime.utcnow().strftime(\"%d %B %Y, %H:%M:%S %z\") random_bytes=await GCPKMS.get_random_bytes( n_bytes=C.TWO_FA_TOKEN_BYTES, generate_from_hsm=not C.DEBUG_MODE, ) token=base64.b85encode(random_bytes).decode(\"utf-8\") msg=f\"\"\" Your Mirai account,{user_doc['email']}, was logged in to from a new IP address.<br><br> Time:{current_datetime}(UTC)<br>Location*:{location}<br> Login IP Address:{ip_addr}<br> *Location is approximate based on the login's IP address.<br><br> Please enter the generated code below to authenticate yourself.<br> Generated Code(will expire in{C.TWO_FA_TOKEN_EXPIRY \/\/ 60} minutes!):<br> <strong>{html.escape(token)}<\/strong><br><br> If this was not you, we recommend that you <strong>change your password immediately<\/strong> by clicking the link below.<br> Change password:<br> {url_for(request, \"index\", external=True)}\"\"\" existing_tokens=user_doc[\"security\"].get(\"email_tokens\",[]) if len(existing_tokens) >=C.MAX_EMAIL_TOKENS: existing_tokens.sort(key=lambda x: x[\"expiry\"]) await user_col.update_one( {\"_id\": user_doc[\"_id\"]}, {\"$set\":{ \"security.email_tokens\": existing_tokens[-C.MAX_EMAIL_TOKENS +1:], }}, ) await user_col.update_one( {\"_id\": user_doc[\"_id\"]}, {\"$push\":{ \"security.email_tokens\":{ \"token\": token, \"expiry\": time.time() +C.TWO_FA_TOKEN_EXPIRY, \"ip_address\": ip_addr, }, }}, ) await NOREPLY_EMAIL.send_email( to=user_doc[\"email\"], subject=\"Login from a different location\", message=msg, name=user_doc[\"display_name\"], ) async def verify_email_token(request: Request, email_token: str, user_doc: dict, user_col: Collection) -> None | ORJSONResponse: \"\"\"Verifies the email token sent to the user. Args: request(Request): The request object. email_token(str): The email token to verify. user_doc(dict): The user document. user_col(Collection): The user collection. Returns: None | ORJSONResponse: None if the token is valid, otherwise an error response. \"\"\" ip_addr=get_user_ip(request) email_token=email_token.strip() current_time=time.time() for token_doc in user_doc[\"security\"].get(\"email_tokens\",[]): if token_doc[\"token\"]==email_token and token_doc[\"expiry\"] > current_time and token_doc[\"ip_address\"]==ip_addr: return else: await user_col.update_one( {\"_id\": user_doc[\"_id\"]}, {\"$pull\":{ \"security.email_tokens\":{ \"token\": email_token, }, }}, ) return ORJSONResponse( status_code=401, content={ \"message\": \"Invalid or expired verification token.\", } ) async def generate_backup_code() -> bytes: \"\"\"Generates a backup code. Returns: bytes: The backup code. \"\"\" random_bytes=await GCPKMS.get_random_bytes( n_bytes=C.BACKUP_CODE_BYTES, generate_from_hsm=not C.DEBUG_MODE, ) return base64.b85encode(random_bytes).decode(\"utf-8\") def generate_sms_code() -> str: \"\"\"Generates a sms code securely using the secrets module to ensure high entropy. Returns: str: The sms code. \"\"\" return \"\".join([str(secrets.randbelow(10)) for _ in range(6)]) def verify_sms_code(code: str, user_doc: dict) -> None | ORJSONResponse: \"\"\"Verifies the token retrieved via an sms message. Args: code(str): The sms code to verify. user_doc(dict): The user document. Returns: None | ORJSONResponse: None if the code is valid, otherwise an error response. \"\"\" sms_code_dict=user_doc[\"security\"].get(\"sms_code\") if not sms_code_dict: return ORJSONResponse( status_code=400, content={ \"error\": \"No sms code found.\", } ) if sms_code_dict[\"code\"] !=code: return ORJSONResponse( status_code=401, content={ \"error\": \"Invalid sms code.\", } ) if sms_code_dict[\"expiry\"] < time.time(): return ORJSONResponse( status_code=401, content={ \"error\": \"Expired sms code. Please request a new one.\", } ) async def verify_totp_token(token: str, user_doc: dict) -> None | ORJSONResponse: \"\"\"Verifies the token retrieved via an authenticator app. Args: token(str): The totp token to verify against the totp secret. user_doc(dict): The user document. Returns: None | ORJSONResponse: None if the token is valid, otherwise an error response. \"\"\" encrypted_totp_secret=user_doc[\"security\"][\"secret_totp_token\"] totp_secret=await AESGCM.symmetric_decrypt( ciphertext=encrypted_totp_secret, key_id=C.DATABASE_KEY, ) if not pyotp.TOTP(totp_secret).verify(token): return ORJSONResponse( status_code=401, content={ \"message\": \"Invalid TOTP token.\", } ) async def generate_totp_secret(username: str) -> tuple[str, str]: \"\"\"Generates a totp secret to be generated from GCP KMS Cloud HSM and MUST be kept secret Args: username(str): The username of the user. Returns: tuple[str, str]: The generated totp secret, and the QR code for the totp secret. \"\"\" random_bytes=await GCPKMS.get_random_bytes( n_bytes=20, generate_from_hsm=not C.DEBUG_MODE, ) secret_token=base64.b32encode(random_bytes) totp=pyotp.totp.TOTP( s=secret_token, digits=6, digest=hashlib.sha1, ) totp_uri=totp.provisioning_uri( name=f\"@{username}\", issuer_name=\"Mirai\", ) stream=io.BytesIO() qr=qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_H, box_size=15, border=5, ) qr.add_data(totp_uri) qr.make(fit=True) qrcode_image=qr.make_image( fill_color=(234, 167, 199), back_color=\"white\", ) qrcode_image.save(stream) encoded_qrcode_data=base64.b64encode(stream.getvalue()).decode(\"utf-8\") return( secret_token.decode(\"utf-8\"), f\"data:image\/png;base64,{encoded_qrcode_data}\", ) async def add_session(request: Request, user_doc: dict, session_expiry: int, user_col: Collection, location: str | None=None) -> None: \"\"\"Adds a session to the user document. Args: request(Request): The request object. user_doc(dict): The user document. session_expiry(int): The session expiry in seconds. user_col(Collection): The user collection. location(str | None, optional): The location of the user. Defaults to None and will be automatically determined via the request object. Returns: None \"\"\" if location is None: location=await get_location_str(request) session_id=await GCPKMS.get_random_bytes( n_bytes=C.SESSION_BYTES, generate_from_hsm=not C.DEBUG_MODE, ) session_id=base64.b85encode(session_id).decode(\"utf-8\") request.session[C.SESSION_COOKIE]=session_id current_datetime=datetime.utcnow() expiry_date=current_datetime +timedelta(seconds=session_expiry) ua=user_agents.parse(request.headers.get(\"User-Agent\", \"\")) os_name=ua.os.family +\" \" +ua.os.version_string session_data={ \"session_id\": session_id, \"added_on\": current_datetime, \"expiry_date\": expiry_date, \"browser\": ua.browser.family, \"os\": os_name.strip(), \"location\": location, } if session_expiry==C.DO_NOT_REMEMBER_EXPIRY: request.session[C.EXPIRY_ONCLOSE]=True update_kwargs={ \"update\":{ \"$push\":{ \"sessions\": session_data, }, }, } matched_location=None for location_info in user_doc[\"security\"].get(\"last_accessed\",[]): if location_info[\"location\"]==location: matched_location=location_info break if matched_location is None: update_kwargs[\"update\"][\"$push\"][\"security.last_accessed\"]={ \"location\": location, \"datetime\": time.time(), } else: update_kwargs[\"update\"][\"$set\"]={ \"security.last_accessed.$[elem].datetime\": time.time(), } update_kwargs[\"array_filters\"]=[{\"elem.location\": location}] await user_col.update_one( {\"_id\": user_doc[\"_id\"]}, **update_kwargs, ) def validate_2fa_request(request: Request, error_msg: str | None=\"Please login first.\") -> dict | ORJSONResponse: \"\"\"Validates the 2fa request. Args: request(Request): The request object. error_msg(str | None, optional): The error message to return if the request is invalid. Defaults to \"Please login first.\". Returns: dict | ORJSONResponse: The user info if the request is valid, else an ORJSONResponse. \"\"\" user_info=request.session.get(\"2fa\") if user_info is None or user_info.get(\"ttl\", 0) < time.time(): request.session.pop(\"2fa\", None) return ORJSONResponse( status_code=403, content={\"message\": error_msg}, ) return user_info def validate_2fa_reset_password(request: Request, user_doc: dict, token: str) -> None | ORJSONResponse: \"\"\"Validate 2FA for reset password flow. Args: request(Request): The request object. user_doc(dict): The user document. token(str): The reset password token. Returns: None | ORJSONResponse: None if the request is valid, else an ORJSONResponse for the user to authenticate themselves for 2FA before resetting their password. \"\"\" if request.session.get(\"2fa_password_flow\", \"\") !=\"completed\": redirect_response=redirect_to_2fa( request=request, user_doc=user_doc, purpose=\"reset_password\", redirect_url=url_for(request, \"forgot_password_token\", token=token), ) if isinstance(redirect_response, ORJSONResponse): return redirect_response def check_if_user_has_2fa(user_doc: dict) -> bool: \"\"\"Checks if the user has 2fa enabled. Args: user_doc(dict): The user doc Returns: bool: True if the user has 2fa enabled, else False. \"\"\" return(user_doc[\"security\"].get(\"sms_2fa\", False) or user_doc[\"security\"].get(\"secret_totp_token\") is not None) def redirect_to_2fa(request: Request, user_doc: dict, redirect_url: str, purpose: str, stay_signed_in: bool | None=None, add_session_after_2fa: bool | None=False) -> None | ORJSONResponse: \"\"\"Checks if the user has 2fa enabled and redirects the user to the 2fa page if they do. Args: request(Request): The request object. user_doc(dict): The user doc redirect_url(str): The redirect url to redirect the user after the 2FA flow. purpose(str): The purpose for the 2FA flow. stay_signed_in(bool | None, optional): Whether the user wants to stay signed in which will result in a login session that lasts longer. Defaults to None. add_session_after_2fa(bool | None, optional): Whether the user wants to add a session after 2fa. Defaults to False. Returns: None | ORJSONResponse: None if the user does not have 2fa enabled, else an ORJSONResponse. \"\"\" if check_if_user_has_2fa(user_doc): request.session[\"2fa\"]={ \"user_id\": str(user_doc[\"_id\"]), \"ttl\": time.time() +C.TWO_FA_TIMEOUT, \"redirect_url\": redirect_url, \"purpose\": purpose, \"add_session_after_2fa\": add_session_after_2fa, } if stay_signed_in is not None: request.session[\"2fa\"][\"stay_signed_in\"]=stay_signed_in return ORJSONResponse( status_code=403, content={ \"message\": f\"2fa required, please go to{url_for(request, 'two_fa')}\", } ) async def send_verify_email(request: Request, user_doc: dict) -> None: \"\"\"Sends the verification email to the user. Args: request(Request): The request object. user_doc(dict): The user document. Returns: None: \"\"\" hmac_signer=get_hmac_signer( max_age=C.EMAIL_VERIFICATION_EXPIRY ) signed_token=hmac_signer.sign({ \"email\": user_doc[\"email\"], }) encrypted_token=await encrypt_token(signed_token) msg=f\"\"\" Welcome to Mirai!<br> Please click the link below to verify your email address:<br> <a href='{url_for(request, \"verify_email\", external=True, token=encrypted_token)}' style='{C.EMAIL_BUTTON_STYLE}' target='_blank'>Verify Email<\/a><br> \"\"\" await NOREPLY_EMAIL.send_email( to=user_doc[\"email\"], subject=\"Email Verification\", message=msg, name=user_doc[\"display_name\"], ) PASSWORD_POLICIES_REGEX=( C.TWO_REPEAT_CHAR_REGEX, C.UPPERCASE_REGEX, C.LOWERCASE_REGEX, C.DIGIT_REGEX, C.SPECIAL_CHAR_REGEX, ) def check_password_requirements(password: str) -> bool: \"\"\"Checks the password against the password requirements. Args: password(str): The password to check. Returns: bool: Whether the password meets the requirements. \"\"\" conditions_met=0 for regex in PASSWORD_POLICIES_REGEX: if regex.search(password): conditions_met +=1 return(conditions_met >=(len(PASSWORD_POLICIES_REGEX) -1)) PASSWORD_TEXT_PATH=C.APP_ROOT_PATH.joinpath(\"utils\", \"misc\", \"common_passwords.txt\") PASSWORD_TEXT_PATH.parent.mkdir(parents=True, exist_ok=True) if C.DEBUG_MODE and not PASSWORD_TEXT_PATH.exists() and not PASSWORD_TEXT_PATH.is_file(): downloaded_common_passwords=asyncio.run( download_url( url=\"https:\/\/raw.githubusercontent.com\/danielmiessler\/SecLists\/master\/Passwords\/Common-Credentials\/10-million-password-list-top-1000000.txt\", method=\"GET\", download_bytes=False, ) ) PASSWORD_TEXT_PATH.write_text( data=\"\\n\".join(downloaded_common_passwords.splitlines()), ) COMMON_PASSWORD_ARR=set(PASSWORD_TEXT_PATH.read_text().splitlines()) async def check_common_passwords(password: str) -> bool: \"\"\"Checks if the password is a common password against the list of 10,000 common passwords. Args: password(str): The password to check. Returns: bool: True if the password is a common password, False otherwise. \"\"\" return(password in COMMON_PASSWORD_ARR) async def main_password_validations(email:str, password: str) -> ORJSONResponse | None: \"\"\"Does the main password validations like checking for illegal characters, etc. Args: email(str): The email of the user. password(str): The password to check. Returns: ORJSONResponse | None: A response if the password is invalid, None otherwise. \"\"\" if C.ALLOWED_PASS_CHAR.fullmatch(password) is None: return ORJSONResponse( status_code=400, content={ \"message\": \"Password should not contain any illegal characters.\", } ) if not check_password_requirements(password): return ORJSONResponse( status_code=400, content={ \"message\": \"Password is too simple, try adding uppercase letter, lowercase letter, number, and special character. Additionally, there must not be two or more repeated characters.\", } ) if await check_common_passwords(password): return ORJSONResponse( status_code=400, content={ \"message\": \"Password is too common. Please enter a more unique password.\", } ) if await reCAPTCHA.check_credentials(email, password): return ORJSONResponse( status_code=400, content={ \"message\": \"Your credentials has been compromised. Please enter another password.\", } ) async def secure_password(password: str) -> bytes | ORJSONResponse: \"\"\"Hashes the password using Argon2id and encrypts it(pepper) using AES-256-GCM. Args: password(str): The password to hash and pepper it. Returns: bytes | ORJSONResponse: The encrypted password hash in bytes if successful, ORJSONResponse otherwise if there was an error hashing the password. \"\"\" try: password_hash=C.HASHER.hash(password) except(argon2_e.HashingError): return ORJSONResponse( status_code=500, content={ \"message\": C.ERROR_MSG, } ) encrypted_password_hash=await AESGCM.symmetric_encrypt( plaintext=password_hash, key_id=C.DATABASE_KEY, ) return encrypted_password_hash def get_min_message_timer(sender_user_doc: dict, receiver_user_doc: dict) -> int: \"\"\"Returns the minimum message timer between the sender and receiver. Args: sender_user_doc(dict): The sender's user document. receiver_user_doc(dict): The receiver's user document. Returns: int: The minimum expiry interval.(0 if both users have message_timer set to 0 meaning no message timer) \"\"\" sender_expiry_setting=sender_user_doc[\"chat\"][\"message_timer\"] receiver_expiry_setting=receiver_user_doc[\"chat\"][\"message_timer\"] if sender_expiry_setting==0 or receiver_expiry_setting==0: return max(sender_expiry_setting, receiver_expiry_setting) return min(sender_expiry_setting, receiver_expiry_setting) def clean_filename(filename: str) -> str: \"\"\"Cleans the filename. Args: filename(str): The filename to clean. Returns: str: The cleaned filename. \"\"\" return C.FILENAME_BLACKLIST_REGEX.sub(\"-\", filename).replace(\" \", \"_\") def get_rate_limiter_dependency(router_name: str) -> list[Depends] | None: \"\"\"Gets the rate limiter dependency for the router. Args: router_name(str): The name of the router. Returns: list[Depends] | None: The rate limiter dependency for the router. \"\"\" if C.DEBUG_MODE: return None if router_name in C.RATE_LIMITER_TABLE: return[C.RATE_LIMITER_TABLE[router_name]] warnings.warn( message=f\"Rate limiter not found for{router_name}, using default rate limiter instead.\", category=RuntimeWarning, ) return[C.DEFAULT_RATE_LIMIT] ","sourceWithComments":"# import third-party libraries\nimport pyotp\nimport qrcode\nimport user_agents\nfrom fastapi import Request\nfrom fastapi.params import Depends\nimport argon2.exceptions as argon2_e\nfrom pymongo.collection import Collection\nfrom fastapi.responses import ORJSONResponse\nfrom fastapi.exceptions import HTTPException\n\n# import local Python libraries\nfrom utils import constants as C\nfrom utils.functions.useful import (\n    url_for,\n    get_user_ip,\n    download_url,\n)\nfrom gcp import (\n    AESGCM,\n    GCPKMS,\n    reCAPTCHA,\n    NOREPLY_EMAIL,\n)\nfrom .useful import get_location_str\nfrom utils.classes.hmac import get_hmac_signer\n\n# import Python's standard libraries\nimport io\nimport time\nimport html\nimport random\nimport base64\nimport hashlib\nimport secrets\nimport asyncio\nimport warnings\nfrom datetime import datetime, timedelta\nfrom binascii import Error as BinasciiError\n\nasync def random_sleep(min_t: int | None = 2, max_t: int | None = 4) -> None:\n    \"\"\"Sleeps for a random amount of time to \n    make brute force attacks harder via security through obscurity.\n\n    Args:\n        min_t (int, optional):\n            The minimum time to sleep for. Defaults to 2.\n        max_t (int, optional):\n            The maximum time to sleep for. Defaults to 4.\n\n    Returns:\n        None\n    \"\"\"\n    await asyncio.sleep(random.uniform(min_t, max_t))\n\nasync def encrypt_token(token: str, key_id: str | None = C.TOKEN_KEY) -> str:\n    \"\"\"Encrypts a token using AESGCM.\n\n    Args:\n        token (str):\n            The token to encrypt.\n        key_id (str, optional):\n            The key ID to use. Defaults to C.TOKEN_KEY.\n\n    Returns:\n        str: \n            The encrypted token.\n    \"\"\"\n    encrypted_token = await AESGCM.symmetric_encrypt(\n        plaintext=token,\n        key_id=key_id,\n    )\n    return base64.urlsafe_b64encode(encrypted_token).decode(\"utf-8\")\n\nasync def decrypt_token(token: str, key_id: str | None = C.TOKEN_KEY) -> str | None:\n    \"\"\"Decrypts a token using AESGCM.\n\n    Args:\n        token (str):\n            The token to decrypt.\n        key_id (str, optional):\n            The key ID to use. Defaults to C.TOKEN_KEY.\n\n    Returns:\n        str | None: \n            The decrypted token or None if the token is invalid.\n    \"\"\"\n    if token is None:\n        return None\n\n    try:\n        token = base64.urlsafe_b64decode(token)\n        decrypted_token = await AESGCM.symmetric_decrypt(\n            ciphertext=token,\n            key_id=key_id,\n        )\n    except (HTTPException, BinasciiError, ValueError, TypeError):\n        return None\n\n    return decrypted_token\n\nasync def send_email_token(request: Request, user_doc: dict, location: str, user_col: Collection) -> None:\n    \"\"\"Sends an email token to the user for verification.\n\n    Args:\n        request (Request):\n            The request object.\n        user_doc (dict):\n            The user document.\n        location (str):\n            The location string.\n        user_col (Collection):\n            The user collection.\n\n    Returns:\n        None:\n    \"\"\"\n    ip_addr = get_user_ip(request)\n    current_datetime = datetime.utcnow().strftime(\"%d %B %Y, %H:%M:%S %z\")\n    random_bytes = await GCPKMS.get_random_bytes(\n        n_bytes=C.TWO_FA_TOKEN_BYTES, \n        generate_from_hsm=not C.DEBUG_MODE,\n    )\n    token = base64.b85encode(random_bytes).decode(\"utf-8\")\n    msg = f\"\"\"\nYour Mirai account, {user_doc['email']}, was logged in to from a new IP address.<br><br>\n\nTime: {current_datetime} (UTC)<br>Location*: {location}<br>\nLogin IP Address: {ip_addr}<br>\n*Location is approximate based on the login's IP address.<br><br>\n\nPlease enter the generated code below to authenticate yourself.<br>\nGenerated Code (will expire in {C.TWO_FA_TOKEN_EXPIRY \/\/ 60} minutes!):<br>\n<strong>{html.escape(token)}<\/strong><br><br>\n\nIf this was not you, we recommend that you <strong>change your password immediately<\/strong> by clicking the link below.<br>\nChange password:<br>\n{url_for(request, \"index\", external=True)}\"\"\" # TODO: update password link\n\n    existing_tokens = user_doc[\"security\"].get(\"email_tokens\", [])\n    if len(existing_tokens) >= C.MAX_EMAIL_TOKENS:\n        # sort by expiry from oldest to newest\n        existing_tokens.sort(key=lambda x: x[\"expiry\"])\n        await user_col.update_one(\n            {\"_id\": user_doc[\"_id\"]},\n            {\"$set\": {\n                \"security.email_tokens\": existing_tokens[-C.MAX_EMAIL_TOKENS + 1:],\n            }},\n        )\n\n    await user_col.update_one(\n        {\"_id\": user_doc[\"_id\"]},\n        {\"$push\": {\n            \"security.email_tokens\": {\n                \"token\": token,\n                \"expiry\": time.time() + C.TWO_FA_TOKEN_EXPIRY,\n                \"ip_address\": ip_addr,\n            },\n        }},\n    )\n    await NOREPLY_EMAIL.send_email(\n        to=user_doc[\"email\"],\n        subject=\"Login from a different location\",\n        message=msg,\n        name=user_doc[\"display_name\"],\n    )\n\nasync def verify_email_token(request: Request, email_token: str, user_doc: dict, user_col: Collection) -> None | ORJSONResponse:\n    \"\"\"Verifies the email token sent to the user.\n\n    Args:\n        request (Request):\n            The request object.\n        email_token (str):\n            The email token to verify.\n        user_doc (dict):\n            The user document.\n        user_col (Collection):\n            The user collection.\n\n    Returns:\n        None | ORJSONResponse:\n            None if the token is valid, otherwise an error response.\n    \"\"\"\n    ip_addr = get_user_ip(request)\n    email_token = email_token.strip()\n    current_time = time.time()\n    for token_doc in user_doc[\"security\"].get(\"email_tokens\", []):\n        if token_doc[\"token\"] == email_token and token_doc[\"expiry\"] > current_time and token_doc[\"ip_address\"] == ip_addr:\n            return\n    else:\n        await user_col.update_one(\n            {\"_id\": user_doc[\"_id\"]},\n            {\"$pull\": {\n                \"security.email_tokens\": {\n                    \"token\": email_token,\n                },\n            }},\n        )\n        return ORJSONResponse(\n            status_code=401,\n            content={\n                \"message\": \"Invalid or expired verification token.\",\n            }\n        )\n\nasync def generate_backup_code() -> bytes:\n    \"\"\"Generates a backup code.\n\n    Returns:\n        bytes: \n            The backup code.\n    \"\"\"\n    random_bytes = await GCPKMS.get_random_bytes(\n        n_bytes=C.BACKUP_CODE_BYTES,\n        generate_from_hsm=not C.DEBUG_MODE,\n    )\n    return base64.b85encode(random_bytes).decode(\"utf-8\")\n\ndef generate_sms_code() -> str:\n    \"\"\"Generates a sms code securely using the secrets module to ensure high entropy.\n\n    Returns:\n        str: \n            The sms code.\n    \"\"\"\n    return \"\".join([str(secrets.randbelow(10)) for _ in range(6)])\n\ndef verify_sms_code(code: str, user_doc: dict) -> None | ORJSONResponse:\n    \"\"\"Verifies the token retrieved via an sms message.\n\n    Args:\n        code (str):\n            The sms code to verify.\n        user_doc (dict):\n            The user document.\n\n    Returns:\n        None | ORJSONResponse:\n            None if the code is valid, otherwise an error response.\n    \"\"\"\n    sms_code_dict = user_doc[\"security\"].get(\"sms_code\")\n    if not sms_code_dict:\n        return ORJSONResponse(\n            status_code=400,\n            content={\n                \"error\": \"No sms code found.\",\n            }\n        )\n\n    if sms_code_dict[\"code\"] != code:\n        return ORJSONResponse(\n            status_code=401,\n            content={\n                \"error\": \"Invalid sms code.\",\n            }\n        )\n\n    if sms_code_dict[\"expiry\"] < time.time():\n        return ORJSONResponse(\n            status_code=401,\n            content={\n                \"error\": \"Expired sms code. Please request a new one.\",\n            }\n        )\n\nasync def verify_totp_token(token: str, user_doc: dict) -> None | ORJSONResponse:\n    \"\"\"Verifies the token retrieved via an authenticator app.\n\n    Args:\n        token (str):\n            The totp token to verify against the totp secret.\n        user_doc (dict):\n            The user document.\n\n    Returns:\n        None | ORJSONResponse:\n            None if the token is valid, otherwise an error response.\n    \"\"\"\n    encrypted_totp_secret = user_doc[\"security\"][\"secret_totp_token\"]\n    totp_secret = await AESGCM.symmetric_decrypt(\n        ciphertext=encrypted_totp_secret,\n        key_id=C.DATABASE_KEY,\n    )\n    if not pyotp.TOTP(totp_secret).verify(token):\n        return ORJSONResponse(\n            status_code=401,\n            content={\n                \"message\": \"Invalid TOTP token.\",\n            }\n        )\n\nasync def generate_totp_secret(username: str) -> tuple[str, str]:\n    \"\"\"Generates a totp secret to be generated from GCP KMS Cloud HSM and MUST be kept secret\n\n    Args:\n        username (str):\n            The username of the user.\n\n    Returns:\n        tuple[str, str]:\n            The generated totp secret, and the QR code for the totp secret.\n    \"\"\"\n    random_bytes = await GCPKMS.get_random_bytes(\n        n_bytes=20,\n        generate_from_hsm=not C.DEBUG_MODE,\n    )\n    secret_token = base64.b32encode(random_bytes)\n\n    # generate totp uri to be \n    # used in the qrcode generation for convenience\n    totp = pyotp.totp.TOTP(\n        s=secret_token, \n        digits=6,\n        digest=hashlib.sha1, # to be compatible with most authenticator apps\n    )\n    totp_uri = totp.provisioning_uri(\n        name=f\"@{username}\", \n        issuer_name=\"Mirai\",\n    )\n\n    # generate QR code for convenience\n    stream = io.BytesIO()\n\n    # create a qrcode object\n    qr = qrcode.QRCode(\n        version=1,\n        error_correction=qrcode.constants.ERROR_CORRECT_H,\n        box_size=15,\n        border=5,\n    )\n    qr.add_data(totp_uri)\n    qr.make(fit=True)\n    qrcode_image = qr.make_image(\n        fill_color=(234, 167, 199), \n        back_color=\"white\",\n    )\n\n    # save the qrcode image in the memory buffer\n    qrcode_image.save(stream)\n\n    # get the image from the memory buffer and encode it into base64\n    encoded_qrcode_data = base64.b64encode(stream.getvalue()).decode(\"utf-8\")\n    return (\n        secret_token.decode(\"utf-8\"), \n        f\"data:image\/png;base64, {encoded_qrcode_data}\",\n    )\n\nasync def add_session(request: Request, user_doc: dict, session_expiry: int, user_col: Collection, location: str | None = None) -> None:\n    \"\"\"Adds a session to the user document.\n\n    Args:\n        request (Request):\n            The request object.\n        user_doc (dict):\n            The user document.\n        session_expiry (int):\n            The session expiry in seconds.\n        user_col (Collection):\n            The user collection.\n        location (str | None, optional):\n            The location of the user. Defaults to None and will be automatically determined via the request object.\n\n    Returns:\n        None\n    \"\"\"\n    if location is None:\n        location = await get_location_str(request)\n\n    session_id = await GCPKMS.get_random_bytes(\n        n_bytes=C.SESSION_BYTES,\n        generate_from_hsm=not C.DEBUG_MODE,\n    )\n    session_id = base64.b85encode(session_id).decode(\"utf-8\")\n    request.session[C.SESSION_COOKIE] = session_id\n    current_datetime = datetime.utcnow()\n    expiry_date = current_datetime + timedelta(seconds=session_expiry)\n\n    ua = user_agents.parse(request.headers.get(\"User-Agent\", \"\"))\n    os_name = ua.os.family + \" \" + ua.os.version_string\n    session_data = {\n        \"session_id\": session_id,\n        \"added_on\": current_datetime,\n        \"expiry_date\": expiry_date,\n        \"browser\": ua.browser.family,\n        \"os\": os_name.strip(),\n        \"location\": location,\n    }\n    if session_expiry == C.DO_NOT_REMEMBER_EXPIRY:\n        request.session[C.EXPIRY_ONCLOSE] = True\n\n    update_kwargs = {\n        \"update\": {\n            \"$push\": {\n                \"sessions\": session_data,\n            },\n        },\n    }\n\n    matched_location = None\n    for location_info in user_doc[\"security\"].get(\"last_accessed\", []):\n        if location_info[\"location\"] == location:\n            matched_location = location_info\n            break\n\n    if matched_location is None:\n        update_kwargs[\"update\"][\"$push\"][\"security.last_accessed\"] = {\n            \"location\": location,\n            \"datetime\": time.time(),\n        }\n    else:\n        update_kwargs[\"update\"][\"$set\"] = {\n            \"security.last_accessed.$[elem].datetime\": time.time(),\n        }\n        update_kwargs[\"array_filters\"] = [{\"elem.location\": location}]\n\n    await user_col.update_one(\n        {\"_id\": user_doc[\"_id\"]}, \n        **update_kwargs,\n    )\n\ndef validate_2fa_request(request: Request, error_msg: str | None = \"Please login first.\") -> dict | ORJSONResponse:\n    \"\"\"Validates the 2fa request.\n\n    Args:\n        request (Request):\n            The request object.\n        error_msg (str | None, optional):\n            The error message to return if the request is invalid. Defaults to \"Please login first.\".\n\n    Returns:\n        dict | ORJSONResponse:\n            The user info if the request is valid, else an ORJSONResponse.\n    \"\"\"\n    user_info = request.session.get(\"2fa\")\n    if user_info is None or user_info.get(\"ttl\", 0) < time.time():\n        request.session.pop(\"2fa\", None)\n        return ORJSONResponse(\n            status_code=403,\n            content={\"message\": error_msg},\n        )\n    return user_info\n\ndef validate_2fa_reset_password(request: Request, user_doc: dict, token: str) -> None | ORJSONResponse:\n    \"\"\"Validate 2FA for reset password flow.\n\n    Args:\n        request (Request):\n            The request object.\n        user_doc (dict):\n            The user document.\n        token (str):\n            The reset password token.\n\n    Returns:\n        None | ORJSONResponse:\n            None if the request is valid, else an ORJSONResponse \n            for the user to authenticate themselves for 2FA before resetting their password.\n    \"\"\"\n    if request.session.get(\"2fa_password_flow\", \"\") != \"completed\":\n        redirect_response = redirect_to_2fa(\n            request=request,\n            user_doc=user_doc,\n            purpose=\"reset_password\",\n            redirect_url=url_for(request, \"forgot_password_token\", token=token),\n        )\n        if isinstance(redirect_response, ORJSONResponse):\n            return redirect_response\n\ndef check_if_user_has_2fa(user_doc: dict) -> bool:\n    \"\"\"Checks if the user has 2fa enabled.\n\n    Args:\n        user_doc (dict):\n            The user doc\n\n    Returns:\n        bool:\n            True if the user has 2fa enabled, else False.\n    \"\"\"\n    return (user_doc[\"security\"].get(\"sms_2fa\", False) or user_doc[\"security\"].get(\"secret_totp_token\") is not None)\n\ndef redirect_to_2fa(request: Request, user_doc: dict, redirect_url: str, purpose: str,\n                    stay_signed_in: bool | None = None, add_session_after_2fa: bool | None = False) -> None | ORJSONResponse:\n    \"\"\"Checks if the user has 2fa enabled and redirects the user to the 2fa page if they do.\n\n    Args:\n        request (Request):\n            The request object.\n        user_doc (dict):\n            The user doc\n        redirect_url (str):\n            The redirect url to redirect the user after the 2FA flow.\n        purpose (str):\n            The purpose for the 2FA flow.\n        stay_signed_in (bool | None, optional):\n            Whether the user wants to stay signed in which will result in a login session that lasts longer. Defaults to None.\n        add_session_after_2fa (bool | None, optional):\n            Whether the user wants to add a session after 2fa. Defaults to False.\n\n    Returns:\n        None | ORJSONResponse:\n            None if the user does not have 2fa enabled, else an ORJSONResponse.\n    \"\"\"\n    if check_if_user_has_2fa(user_doc):\n        request.session[\"2fa\"] = {\n            \"user_id\": str(user_doc[\"_id\"]),\n            \"ttl\": time.time() + C.TWO_FA_TIMEOUT,\n            \"redirect_url\": redirect_url,\n            \"purpose\": purpose,\n            \"add_session_after_2fa\": add_session_after_2fa,\n        }\n        if stay_signed_in is not None:\n            request.session[\"2fa\"][\"stay_signed_in\"] = stay_signed_in\n\n        return ORJSONResponse(\n            status_code=403,\n            content={\n                \"message\": f\"2fa required, please go to {url_for(request, 'two_fa')}\",\n            }\n        )\n\nasync def send_verify_email(request: Request, user_doc: dict) -> None:\n    \"\"\"Sends the verification email to the user.\n\n    Args:\n        request (Request):\n            The request object.\n        user_doc (dict):\n            The user document.\n\n    Returns:\n        None:\n    \"\"\"\n    hmac_signer = get_hmac_signer(\n        max_age=C.EMAIL_VERIFICATION_EXPIRY\n    )\n    signed_token = hmac_signer.sign({\n        \"email\": user_doc[\"email\"],\n    })\n    encrypted_token = await encrypt_token(signed_token)\n    msg = f\"\"\"\nWelcome to Mirai!<br>\nPlease click the link below to verify your email address:<br>\n<a href='{url_for(request, \"verify_email\", external=True, token=encrypted_token)}' style='{C.EMAIL_BUTTON_STYLE}' target='_blank'>Verify Email<\/a><br>\n\"\"\"\n    await NOREPLY_EMAIL.send_email(\n        to=user_doc[\"email\"],\n        subject=\"Email Verification\",\n        message=msg,\n        name=user_doc[\"display_name\"],\n    )\n\nPASSWORD_POLICIES_REGEX = (\n    C.TWO_REPEAT_CHAR_REGEX,\n    C.UPPERCASE_REGEX,\n    C.LOWERCASE_REGEX,\n    C.DIGIT_REGEX,\n    C.SPECIAL_CHAR_REGEX,\n)\ndef check_password_requirements(password: str) -> bool:\n    \"\"\"Checks the password against the password requirements.\n\n    Args:\n        password (str):\n            The password to check.\n\n    Returns:\n        bool:\n            Whether the password meets the requirements.\n    \"\"\"\n    conditions_met = 0\n    for regex in PASSWORD_POLICIES_REGEX:\n        if regex.search(password):\n            conditions_met += 1\n    return (conditions_met >= (len(PASSWORD_POLICIES_REGEX) - 1))\n\nPASSWORD_TEXT_PATH = C.APP_ROOT_PATH.joinpath(\"utils\", \"misc\", \"common_passwords.txt\")\nPASSWORD_TEXT_PATH.parent.mkdir(parents=True, exist_ok=True)\nif C.DEBUG_MODE and not PASSWORD_TEXT_PATH.exists() and not PASSWORD_TEXT_PATH.is_file():\n    # Downloads the list of common passwords if it does not exist \n    # and ONLY in debug mode, when deployed, the container should have the file.\n    downloaded_common_passwords = asyncio.run(\n        download_url(\n            url=\"https:\/\/raw.githubusercontent.com\/danielmiessler\/SecLists\/master\/Passwords\/Common-Credentials\/10-million-password-list-top-1000000.txt\",\n            method=\"GET\",\n            download_bytes=False,\n        )\n    )\n    PASSWORD_TEXT_PATH.write_text(\n        data=\"\\n\".join(downloaded_common_passwords.splitlines()), \n    )\nCOMMON_PASSWORD_ARR = set(PASSWORD_TEXT_PATH.read_text().splitlines())\nasync def check_common_passwords(password: str) -> bool:\n    \"\"\"Checks if the password is a common password against the list of 10,000 common passwords.\n\n    Args:\n        password (str):\n            The password to check.\n\n    Returns:\n        bool:\n            True if the password is a common password, False otherwise.\n    \"\"\"\n    return (password in COMMON_PASSWORD_ARR)\n\nasync def main_password_validations(email:str, password: str) -> ORJSONResponse | None:\n    \"\"\"Does the main password validations like checking for illegal characters, etc.\n\n    Args:\n        email (str):\n            The email of the user.\n        password (str):\n            The password to check.\n\n    Returns:\n        ORJSONResponse | None:\n            A response if the password is invalid, None otherwise.\n    \"\"\"\n    if C.ALLOWED_PASS_CHAR.fullmatch(password) is None:\n        return ORJSONResponse(\n            status_code=400,\n            content={\n                \"message\": \"Password should not contain any illegal characters.\",\n            }\n        )\n\n    if not check_password_requirements(password):\n        return ORJSONResponse(\n            status_code=400,\n            content={\n                \"message\": \"Password is too simple, try adding uppercase letter, lowercase letter, number, and special character. Additionally, there must not be two or more repeated characters.\",\n            }\n        )\n\n    # check against 10,000 most common passwords\n    if await check_common_passwords(password):\n        return ORJSONResponse(\n            status_code=400,\n            content={\n                \"message\": \"Password is too common. Please enter a more unique password.\",\n            }\n        )\n\n    # check if the user's credentials has been compromised using Google Cloud's API\n    if await reCAPTCHA.check_credentials(email, password):\n        return ORJSONResponse(\n            status_code=400,\n            content={\n                \"message\": \"Your credentials has been compromised. Please enter another password.\",\n            }\n        )\n\nasync def secure_password(password: str) -> bytes | ORJSONResponse:\n    \"\"\"Hashes the password using Argon2id and encrypts it (pepper) using AES-256-GCM.\n\n    Args:\n        password (str):\n            The password to hash and pepper it.\n\n    Returns:\n        bytes | ORJSONResponse:\n            The encrypted password hash in bytes if successful, \n            ORJSONResponse otherwise if there was an error hashing the password.\n    \"\"\"\n    try:\n        password_hash = C.HASHER.hash(password)\n    except (argon2_e.HashingError):\n        return ORJSONResponse(\n            status_code=500,\n            content={\n                \"message\": C.ERROR_MSG,\n            }\n        )\n\n    encrypted_password_hash = await AESGCM.symmetric_encrypt(\n        plaintext=password_hash,\n        key_id=C.DATABASE_KEY,\n    )\n    return encrypted_password_hash\n\ndef get_min_message_timer(sender_user_doc: dict, receiver_user_doc: dict) -> int:\n    \"\"\"Returns the minimum message timer between the sender and receiver.\n\n    Args:\n        sender_user_doc (dict):\n            The sender's user document.\n        receiver_user_doc (dict):\n            The receiver's user document.\n\n    Returns:\n        int:\n            The minimum expiry interval. (0 if both users have message_timer set to 0 meaning no message timer)\n    \"\"\"\n    sender_expiry_setting = sender_user_doc[\"chat\"][\"message_timer\"]\n    receiver_expiry_setting = receiver_user_doc[\"chat\"][\"message_timer\"]\n\n    if sender_expiry_setting == 0 or receiver_expiry_setting == 0:\n        return max(sender_expiry_setting, receiver_expiry_setting)\n    return min(sender_expiry_setting, receiver_expiry_setting)\n\ndef clean_filename(filename: str) -> str:\n    \"\"\"Cleans the filename.\n\n    Args:\n        filename (str):\n            The filename to clean.\n\n    Returns:\n        str:\n            The cleaned filename.\n    \"\"\"\n    return C.FILENAME_BLACKLIST_REGEX.sub(\"-\", filename).replace(\" \", \"_\")\n\ndef get_rate_limiter_dependency(router_name: str) -> list[Depends] | None:\n    \"\"\"Gets the rate limiter dependency for the router.\n\n    Args:\n        router_name (str):\n            The name of the router.\n\n    Returns:\n        list[Depends] | None:\n            The rate limiter dependency for the router.\n    \"\"\"\n    if C.DEBUG_MODE:\n        return None\n\n    if router_name in C.RATE_LIMITER_TABLE:\n        return [C.RATE_LIMITER_TABLE[router_name]]\n\n    warnings.warn(\n        message=f\"Rate limiter not found for {router_name}, using default rate limiter instead.\", \n        category=RuntimeWarning,\n    )\n    return [C.DEFAULT_RATE_LIMIT]"}},"msg":"added user agent check to reduce session hijacking"}},"https:\/\/github.com\/jpylypiw\/easywall":{"afc08706b73668af3bf06469859e91e048afc6be":{"url":"https:\/\/api.github.com\/repos\/jpylypiw\/easywall\/commits\/afc08706b73668af3bf06469859e91e048afc6be","html_url":"https:\/\/github.com\/jpylypiw\/easywall\/commit\/afc08706b73668af3bf06469859e91e048afc6be","message":"login check ip address to prevent session hijacking","sha":"afc08706b73668af3bf06469859e91e048afc6be","keyword":"session hijacking check","diff":"diff --git a\/easywall_web\/apply.py b\/easywall_web\/apply.py\nindex 7888760..a4fefd7 100644\n--- a\/easywall_web\/apply.py\n+++ b\/easywall_web\/apply.py\n@@ -12,7 +12,7 @@ def apply(saved=False, step=1):\n     the function returns the apply page when the user is logged in\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Apply\")\n         payload.saved = saved\n         payload.step = step\n@@ -29,7 +29,7 @@ def apply_save():\n     \"\"\"\n     utils = Webutils()\n     step = 0\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         for key, value in request.form.items():\n             if key == \"step_1\":\n                 apply_step_one()\ndiff --git a\/easywall_web\/blacklist.py b\/easywall_web\/blacklist.py\nindex 4dadfae..a1d6303 100644\n--- a\/easywall_web\/blacklist.py\n+++ b\/easywall_web\/blacklist.py\n@@ -9,7 +9,7 @@ def blacklist(saved=False):\n     \"\"\"the function returns the blacklist page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Blacklist\")\n         payload.addresses = rules.get_rules_for_web(\"blacklist\")\n         payload.custom = rules.diff_new_current(\"blacklist\")\n@@ -24,7 +24,7 @@ def blacklist_save():\n     \"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         ipaddress = \"\"\n         rulelist = rules.get_rules_for_web(\"blacklist\")\n \ndiff --git a\/easywall_web\/custom.py b\/easywall_web\/custom.py\nindex 9cdaa45..14a2848 100644\n--- a\/easywall_web\/custom.py\n+++ b\/easywall_web\/custom.py\n@@ -9,7 +9,7 @@ def custom(saved=False):\n     \"\"\"the function returns the custom rules page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Custom\")\n         payload.rules = rules.get_rules_for_web(\"custom\")\n         payload.custom = rules.diff_new_current(\"custom\")\n@@ -22,7 +22,7 @@ def custom_save():\n     \"\"\"the function saves the custom rules into the corresponding rulesfile\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         for key, value in request.form.items():\n             key = str(key) + \"\"  # just for ignoring the warning\n             rulelist = value.split(\"\\n\")\ndiff --git a\/easywall_web\/error.py b\/easywall_web\/error.py\nindex 42e542d..7b4eda4 100644\n--- a\/easywall_web\/error.py\n+++ b\/easywall_web\/error.py\n@@ -1,5 +1,5 @@\n \"\"\"the module contains functions for custom error routes\"\"\"\n-from flask import render_template\n+from flask import render_template, request\n from easywall_web.login import login\n from easywall_web.webutils import Webutils\n \n@@ -7,7 +7,7 @@\n def page_not_found(error):\n     \"\"\"the function returns the 404 error page when the user is logged in\"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         return render_template(\n             '404.html', vars=utils.get_default_payload(\"404 Error\", \"error\")), 404\n     return login(\"\", None)\ndiff --git a\/easywall_web\/index.py b\/easywall_web\/index.py\nindex f72ea4e..c852ee4 100644\n--- a\/easywall_web\/index.py\n+++ b\/easywall_web\/index.py\n@@ -1,7 +1,7 @@\n \"\"\"\n the module contains functions for the index route\n \"\"\"\n-from flask import render_template\n+from flask import render_template, request\n from easywall_web.login import login\n from easywall_web.webutils import Webutils\n \n@@ -11,6 +11,6 @@ def index():\n     the function returns the index page when the user is logged in\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         return render_template('index.html', vars=utils.get_default_payload(\"Home\"))\n     return login(\"\", None)\ndiff --git a\/easywall_web\/login.py b\/easywall_web\/login.py\nindex 505bb5e..46f7680 100644\n--- a\/easywall_web\/login.py\n+++ b\/easywall_web\/login.py\n@@ -4,8 +4,8 @@\n import hashlib\n import platform\n \n-from easywall_web.webutils import Webutils\n from flask import redirect, render_template, request, session\n+from easywall_web.webutils import Webutils\n \n \n def login(message, messagetype):\n@@ -36,7 +36,10 @@ def login_post():\n     if request.form['username'] == utils.cfg.get_value(\n             \"WEB\", \"username\") and pw_hash == utils.cfg.get_value(\n                 \"WEB\", \"password\"):\n+        session.clear()\n         session['logged_in'] = True\n+        session['ip_address'] = request.remote_addr\n+        session.permanent = True\n         return redirect(\"\/\")\n     return login(\"Incorrect username or password.\", \"danger\")\n \n@@ -46,7 +49,7 @@ def logout():\n     the function removes the logged_in session variable if the user is logged in\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         session['logged_in'] = False\n         return redirect(\"\/\")\n     else:\ndiff --git a\/easywall_web\/options.py b\/easywall_web\/options.py\nindex cd41c80..c266d8d 100644\n--- a\/easywall_web\/options.py\n+++ b\/easywall_web\/options.py\n@@ -7,7 +7,7 @@\n def options(saved=False):\n     \"\"\"the function returns the options page when the user is logged in\"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Options\")\n         payload.config = utils.cfg_easywall\n         payload.saved = saved\n@@ -21,7 +21,7 @@ def options_save():\n     for example the Enabled flag in the IPv6 section is saved to the config file\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         section = request.form['section']\n         for key, value in request.form.items():\n             if key != \"section\":\ndiff --git a\/easywall_web\/ports.py b\/easywall_web\/ports.py\nindex dbaf83b..336eb57 100644\n--- a\/easywall_web\/ports.py\n+++ b\/easywall_web\/ports.py\n@@ -9,7 +9,7 @@ def ports(saved=False):\n     \"\"\"the function returns the ports page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Ports\")\n         payload.tcp = rules.get_rules_for_web(\"tcp\")\n         payload.udp = rules.get_rules_for_web(\"udp\")\n@@ -24,7 +24,7 @@ def ports(saved=False):\n def ports_save():\n     \"\"\"the function saves the tcp and udp rules into the corresponding rulesfiles\"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         action = \"add\"\n         ruletype = \"tcp\"\n         port = \"\"\ndiff --git a\/easywall_web\/webutils.py b\/easywall_web\/webutils.py\nindex 27a7b47..7e2e033 100644\n--- a\/easywall_web\/webutils.py\n+++ b\/easywall_web\/webutils.py\n@@ -20,10 +20,12 @@ def __init__(self):\n         self.cfg = Config(\"config\/web.ini\")\n         self.cfg_easywall = Config(CONFIG_PATH)\n \n-    def check_login(self):\n+    def check_login(self, request):\n         \"\"\"the function checks if the user\/session is logged in\"\"\"\n         if not session.get('logged_in'):\n             return False\n+        if request.remote_addr != session.get('ip_address'):\n+            return False\n         return True\n \n     # -------------------------\ndiff --git a\/easywall_web\/whitelist.py b\/easywall_web\/whitelist.py\nindex 4b60e24..517b522 100644\n--- a\/easywall_web\/whitelist.py\n+++ b\/easywall_web\/whitelist.py\n@@ -9,7 +9,7 @@ def whitelist(saved=False):\n     \"\"\"the function returns the whitelist page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Whitelist\")\n         payload.addresses = rules.get_rules_for_web(\"whitelist\")\n         payload.custom = rules.diff_new_current(\"whitelist\")\n@@ -24,7 +24,7 @@ def whitelist_save():\n     \"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         ipaddress = \"\"\n         rulelist = rules.get_rules_for_web(\"whitelist\")\n \n","files":{"\/easywall_web\/apply.py":{"changes":[{"diff":"\n     the function returns the apply page when the user is logged in\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Apply\")\n         payload.saved = saved\n         payload.step = step\n","add":1,"remove":1,"filename":"\/easywall_web\/apply.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]},{"diff":"\n     \"\"\"\n     utils = Webutils()\n     step = 0\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         for key, value in request.form.items():\n             if key == \"step_1\":\n                 apply_step_one()","add":1,"remove":1,"filename":"\/easywall_web\/apply.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]}],"source":"\n\"\"\" the module contains functions for the apply rules route \"\"\" from flask import render_template, request from easywall.utility import create_file_if_not_exists, write_into_file from easywall_web.login import login from easywall_web.webutils import Webutils def apply(saved=False, step=1): \"\"\" the function returns the apply page when the user is logged in \"\"\" utils=Webutils() if utils.check_login() is True: payload=utils.get_default_payload(\"Apply\") payload.saved=saved payload.step=step payload.lastapplied=utils.get_last_accept_time() payload.running=step > 1 payload.accepttime=utils.cfg_easywall.get_value(\"ACCEPTANCE\", \"duration\") return render_template('apply.html', vars=payload) return login(\"\", None) def apply_save(): \"\"\" the function applies the configuration and copies the rules to easywall core \"\"\" utils=Webutils() step=0 if utils.check_login() is True: for key, value in request.form.items(): if key==\"step_1\": apply_step_one() step=2 if key==\"step_2\": apply_step_two() step=3 return apply(True, step) return login(\"\", None) def apply_step_one() -> None: \"\"\" the function triggeres the easywall core to apply the new firewall rules \"\"\" create_file_if_not_exists(\".apply\") def apply_step_two() -> None: \"\"\"the function writes true into the accept file from easywall core\"\"\" write_into_file(\".acceptance\", \"true\") ","sourceWithComments":"\"\"\"\nthe module contains functions for the apply rules route\n\"\"\"\nfrom flask import render_template, request\nfrom easywall.utility import create_file_if_not_exists, write_into_file\nfrom easywall_web.login import login\nfrom easywall_web.webutils import Webutils\n\n\ndef apply(saved=False, step=1):\n    \"\"\"\n    the function returns the apply page when the user is logged in\n    \"\"\"\n    utils = Webutils()\n    if utils.check_login() is True:\n        payload = utils.get_default_payload(\"Apply\")\n        payload.saved = saved\n        payload.step = step\n        payload.lastapplied = utils.get_last_accept_time()\n        payload.running = step > 1\n        payload.accepttime = utils.cfg_easywall.get_value(\"ACCEPTANCE\", \"duration\")\n        return render_template('apply.html', vars=payload)\n    return login(\"\", None)\n\n\ndef apply_save():\n    \"\"\"\n    the function applies the configuration and copies the rules to easywall core\n    \"\"\"\n    utils = Webutils()\n    step = 0\n    if utils.check_login() is True:\n        for key, value in request.form.items():\n            if key == \"step_1\":\n                apply_step_one()\n                step = 2\n            if key == \"step_2\":\n                apply_step_two()\n                step = 3\n        return apply(True, step)\n    return login(\"\", None)\n\n\ndef apply_step_one() -> None:\n    \"\"\"\n    the function triggeres the easywall core to apply the new firewall rules\n    \"\"\"\n    create_file_if_not_exists(\".apply\")\n\n\ndef apply_step_two() -> None:\n    \"\"\"the function writes true into the accept file from easywall core\"\"\"\n    write_into_file(\".acceptance\", \"true\")\n"},"\/easywall_web\/blacklist.py":{"changes":[{"diff":"\n     \"\"\"the function returns the blacklist page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Blacklist\")\n         payload.addresses = rules.get_rules_for_web(\"blacklist\")\n         payload.custom = rules.diff_new_current(\"blacklist\")\n","add":1,"remove":1,"filename":"\/easywall_web\/blacklist.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]},{"diff":"\n     \"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         ipaddress = \"\"\n         rulelist = rules.get_rules_for_web(\"blacklist\")\n","add":1,"remove":1,"filename":"\/easywall_web\/blacklist.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]}],"source":"\n\"\"\"the module contains functions for the blacklist route\"\"\" from flask import render_template, request from easywall_web.login import login from easywall_web.webutils import Webutils from easywall.rules_handler import RulesHandler def blacklist(saved=False): \"\"\"the function returns the blacklist page when the user is logged in\"\"\" utils=Webutils() rules=RulesHandler() if utils.check_login() is True: payload=utils.get_default_payload(\"Blacklist\") payload.addresses=rules.get_rules_for_web(\"blacklist\") payload.custom=rules.diff_new_current(\"blacklist\") payload.saved=saved return render_template('blacklist.html', vars=payload) return login(\"\", None) def blacklist_save(): \"\"\" the function saves the blacklist rules into the corresponding rulesfile \"\"\" utils=Webutils() rules=RulesHandler() if utils.check_login() is True: ipaddress=\"\" rulelist=rules.get_rules_for_web(\"blacklist\") for key, value in request.form.items(): if key==\"ipadr\": ipaddress=value rulelist.append(ipaddress) rules.save_new_rules(\"blacklist\", rulelist) else: ipaddress=key rulelist.remove(ipaddress) rules.save_new_rules(\"blacklist\", rulelist) return blacklist(True) return login(\"\", None) ","sourceWithComments":"\"\"\"the module contains functions for the blacklist route\"\"\"\nfrom flask import render_template, request\nfrom easywall_web.login import login\nfrom easywall_web.webutils import Webutils\nfrom easywall.rules_handler import RulesHandler\n\n\ndef blacklist(saved=False):\n    \"\"\"the function returns the blacklist page when the user is logged in\"\"\"\n    utils = Webutils()\n    rules = RulesHandler()\n    if utils.check_login() is True:\n        payload = utils.get_default_payload(\"Blacklist\")\n        payload.addresses = rules.get_rules_for_web(\"blacklist\")\n        payload.custom = rules.diff_new_current(\"blacklist\")\n        payload.saved = saved\n        return render_template('blacklist.html', vars=payload)\n    return login(\"\", None)\n\n\ndef blacklist_save():\n    \"\"\"\n    the function saves the blacklist rules into the corresponding rulesfile\n    \"\"\"\n    utils = Webutils()\n    rules = RulesHandler()\n    if utils.check_login() is True:\n        ipaddress = \"\"\n        rulelist = rules.get_rules_for_web(\"blacklist\")\n\n        for key, value in request.form.items():\n            if key == \"ipadr\":\n                # then a new ip address is blacklisted\n                ipaddress = value\n                rulelist.append(ipaddress)\n                rules.save_new_rules(\"blacklist\", rulelist)\n            else:\n                # then a old ip address is removed\n                ipaddress = key\n                rulelist.remove(ipaddress)\n                rules.save_new_rules(\"blacklist\", rulelist)\n        return blacklist(True)\n    return login(\"\", None)\n"},"\/easywall_web\/custom.py":{"changes":[{"diff":"\n     \"\"\"the function returns the custom rules page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Custom\")\n         payload.rules = rules.get_rules_for_web(\"custom\")\n         payload.custom = rules.diff_new_current(\"custom\")\n","add":1,"remove":1,"filename":"\/easywall_web\/custom.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]},{"diff":"\n     \"\"\"the function saves the custom rules into the corresponding rulesfile\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         for key, value in request.form.items():\n             key = str(key) + \"\"  # just for ignoring the warning\n             rulelist = value.split(\"\\n","add":1,"remove":1,"filename":"\/easywall_web\/custom.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]}],"source":"\n\"\"\"the module contains functions for the custom rules route\"\"\" from flask import render_template, request from easywall_web.login import login from easywall_web.webutils import Webutils from easywall.rules_handler import RulesHandler def custom(saved=False): \"\"\"the function returns the custom rules page when the user is logged in\"\"\" utils=Webutils() rules=RulesHandler() if utils.check_login() is True: payload=utils.get_default_payload(\"Custom\") payload.rules=rules.get_rules_for_web(\"custom\") payload.custom=rules.diff_new_current(\"custom\") payload.saved=saved return render_template('custom.html', vars=payload) return login(\"\", None) def custom_save(): \"\"\"the function saves the custom rules into the corresponding rulesfile\"\"\" utils=Webutils() rules=RulesHandler() if utils.check_login() is True: for key, value in request.form.items(): key=str(key) +\"\" rulelist=value.split(\"\\n\") rules.save_new_rules(\"custom\", rulelist) return custom(True) return login(\"\", None) ","sourceWithComments":"\"\"\"the module contains functions for the custom rules route\"\"\"\nfrom flask import render_template, request\nfrom easywall_web.login import login\nfrom easywall_web.webutils import Webutils\nfrom easywall.rules_handler import RulesHandler\n\n\ndef custom(saved=False):\n    \"\"\"the function returns the custom rules page when the user is logged in\"\"\"\n    utils = Webutils()\n    rules = RulesHandler()\n    if utils.check_login() is True:\n        payload = utils.get_default_payload(\"Custom\")\n        payload.rules = rules.get_rules_for_web(\"custom\")\n        payload.custom = rules.diff_new_current(\"custom\")\n        payload.saved = saved\n        return render_template('custom.html', vars=payload)\n    return login(\"\", None)\n\n\ndef custom_save():\n    \"\"\"the function saves the custom rules into the corresponding rulesfile\"\"\"\n    utils = Webutils()\n    rules = RulesHandler()\n    if utils.check_login() is True:\n        for key, value in request.form.items():\n            key = str(key) + \"\"  # just for ignoring the warning\n            rulelist = value.split(\"\\n\")\n            rules.save_new_rules(\"custom\", rulelist)\n        return custom(True)\n    return login(\"\", None)\n"},"\/easywall_web\/error.py":{"changes":[{"diff":"\n \"\"\"the module contains functions for custom error routes\"\"\"\n-from flask import render_template\n+from flask import render_template, request\n from easywall_web.login import login\n from easywall_web.webutils import Webutils\n \n","add":1,"remove":1,"filename":"\/easywall_web\/error.py","badparts":["from flask import render_template"],"goodparts":["from flask import render_template, request"]},{"diff":"\n     \"\"\"the function returns the 404 error page when the user is logged in\"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         return render_template(\n             '404.html', vars=utils.get_default_payload(\"404 Error\", \"error\")), 404\n     return login(\"\", No","add":1,"remove":1,"filename":"\/easywall_web\/error.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]}],"source":"\n\"\"\"the module contains functions for custom error routes\"\"\" from flask import render_template from easywall_web.login import login from easywall_web.webutils import Webutils def page_not_found(error): \"\"\"the function returns the 404 error page when the user is logged in\"\"\" utils=Webutils() if utils.check_login() is True: return render_template( '404.html', vars=utils.get_default_payload(\"404 Error\", \"error\")), 404 return login(\"\", None) ","sourceWithComments":"\"\"\"the module contains functions for custom error routes\"\"\"\nfrom flask import render_template\nfrom easywall_web.login import login\nfrom easywall_web.webutils import Webutils\n\n\ndef page_not_found(error):\n    \"\"\"the function returns the 404 error page when the user is logged in\"\"\"\n    utils = Webutils()\n    if utils.check_login() is True:\n        return render_template(\n            '404.html', vars=utils.get_default_payload(\"404 Error\", \"error\")), 404\n    return login(\"\", None)\n"}},"msg":"login check ip address to prevent session hijacking"}},"https:\/\/github.com\/github-ydt\/easywall":{"afc08706b73668af3bf06469859e91e048afc6be":{"url":"https:\/\/api.github.com\/repos\/github-ydt\/easywall\/commits\/afc08706b73668af3bf06469859e91e048afc6be","html_url":"https:\/\/github.com\/github-ydt\/easywall\/commit\/afc08706b73668af3bf06469859e91e048afc6be","message":"login check ip address to prevent session hijacking","sha":"afc08706b73668af3bf06469859e91e048afc6be","keyword":"session hijacking check","diff":"diff --git a\/easywall_web\/apply.py b\/easywall_web\/apply.py\nindex 7888760..a4fefd7 100644\n--- a\/easywall_web\/apply.py\n+++ b\/easywall_web\/apply.py\n@@ -12,7 +12,7 @@ def apply(saved=False, step=1):\n     the function returns the apply page when the user is logged in\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Apply\")\n         payload.saved = saved\n         payload.step = step\n@@ -29,7 +29,7 @@ def apply_save():\n     \"\"\"\n     utils = Webutils()\n     step = 0\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         for key, value in request.form.items():\n             if key == \"step_1\":\n                 apply_step_one()\ndiff --git a\/easywall_web\/blacklist.py b\/easywall_web\/blacklist.py\nindex 4dadfae..a1d6303 100644\n--- a\/easywall_web\/blacklist.py\n+++ b\/easywall_web\/blacklist.py\n@@ -9,7 +9,7 @@ def blacklist(saved=False):\n     \"\"\"the function returns the blacklist page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Blacklist\")\n         payload.addresses = rules.get_rules_for_web(\"blacklist\")\n         payload.custom = rules.diff_new_current(\"blacklist\")\n@@ -24,7 +24,7 @@ def blacklist_save():\n     \"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         ipaddress = \"\"\n         rulelist = rules.get_rules_for_web(\"blacklist\")\n \ndiff --git a\/easywall_web\/custom.py b\/easywall_web\/custom.py\nindex 9cdaa45..14a2848 100644\n--- a\/easywall_web\/custom.py\n+++ b\/easywall_web\/custom.py\n@@ -9,7 +9,7 @@ def custom(saved=False):\n     \"\"\"the function returns the custom rules page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Custom\")\n         payload.rules = rules.get_rules_for_web(\"custom\")\n         payload.custom = rules.diff_new_current(\"custom\")\n@@ -22,7 +22,7 @@ def custom_save():\n     \"\"\"the function saves the custom rules into the corresponding rulesfile\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         for key, value in request.form.items():\n             key = str(key) + \"\"  # just for ignoring the warning\n             rulelist = value.split(\"\\n\")\ndiff --git a\/easywall_web\/error.py b\/easywall_web\/error.py\nindex 42e542d..7b4eda4 100644\n--- a\/easywall_web\/error.py\n+++ b\/easywall_web\/error.py\n@@ -1,5 +1,5 @@\n \"\"\"the module contains functions for custom error routes\"\"\"\n-from flask import render_template\n+from flask import render_template, request\n from easywall_web.login import login\n from easywall_web.webutils import Webutils\n \n@@ -7,7 +7,7 @@\n def page_not_found(error):\n     \"\"\"the function returns the 404 error page when the user is logged in\"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         return render_template(\n             '404.html', vars=utils.get_default_payload(\"404 Error\", \"error\")), 404\n     return login(\"\", None)\ndiff --git a\/easywall_web\/index.py b\/easywall_web\/index.py\nindex f72ea4e..c852ee4 100644\n--- a\/easywall_web\/index.py\n+++ b\/easywall_web\/index.py\n@@ -1,7 +1,7 @@\n \"\"\"\n the module contains functions for the index route\n \"\"\"\n-from flask import render_template\n+from flask import render_template, request\n from easywall_web.login import login\n from easywall_web.webutils import Webutils\n \n@@ -11,6 +11,6 @@ def index():\n     the function returns the index page when the user is logged in\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         return render_template('index.html', vars=utils.get_default_payload(\"Home\"))\n     return login(\"\", None)\ndiff --git a\/easywall_web\/login.py b\/easywall_web\/login.py\nindex 505bb5e..46f7680 100644\n--- a\/easywall_web\/login.py\n+++ b\/easywall_web\/login.py\n@@ -4,8 +4,8 @@\n import hashlib\n import platform\n \n-from easywall_web.webutils import Webutils\n from flask import redirect, render_template, request, session\n+from easywall_web.webutils import Webutils\n \n \n def login(message, messagetype):\n@@ -36,7 +36,10 @@ def login_post():\n     if request.form['username'] == utils.cfg.get_value(\n             \"WEB\", \"username\") and pw_hash == utils.cfg.get_value(\n                 \"WEB\", \"password\"):\n+        session.clear()\n         session['logged_in'] = True\n+        session['ip_address'] = request.remote_addr\n+        session.permanent = True\n         return redirect(\"\/\")\n     return login(\"Incorrect username or password.\", \"danger\")\n \n@@ -46,7 +49,7 @@ def logout():\n     the function removes the logged_in session variable if the user is logged in\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         session['logged_in'] = False\n         return redirect(\"\/\")\n     else:\ndiff --git a\/easywall_web\/options.py b\/easywall_web\/options.py\nindex cd41c80..c266d8d 100644\n--- a\/easywall_web\/options.py\n+++ b\/easywall_web\/options.py\n@@ -7,7 +7,7 @@\n def options(saved=False):\n     \"\"\"the function returns the options page when the user is logged in\"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Options\")\n         payload.config = utils.cfg_easywall\n         payload.saved = saved\n@@ -21,7 +21,7 @@ def options_save():\n     for example the Enabled flag in the IPv6 section is saved to the config file\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         section = request.form['section']\n         for key, value in request.form.items():\n             if key != \"section\":\ndiff --git a\/easywall_web\/ports.py b\/easywall_web\/ports.py\nindex dbaf83b..336eb57 100644\n--- a\/easywall_web\/ports.py\n+++ b\/easywall_web\/ports.py\n@@ -9,7 +9,7 @@ def ports(saved=False):\n     \"\"\"the function returns the ports page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Ports\")\n         payload.tcp = rules.get_rules_for_web(\"tcp\")\n         payload.udp = rules.get_rules_for_web(\"udp\")\n@@ -24,7 +24,7 @@ def ports(saved=False):\n def ports_save():\n     \"\"\"the function saves the tcp and udp rules into the corresponding rulesfiles\"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         action = \"add\"\n         ruletype = \"tcp\"\n         port = \"\"\ndiff --git a\/easywall_web\/webutils.py b\/easywall_web\/webutils.py\nindex 27a7b47..7e2e033 100644\n--- a\/easywall_web\/webutils.py\n+++ b\/easywall_web\/webutils.py\n@@ -20,10 +20,12 @@ def __init__(self):\n         self.cfg = Config(\"config\/web.ini\")\n         self.cfg_easywall = Config(CONFIG_PATH)\n \n-    def check_login(self):\n+    def check_login(self, request):\n         \"\"\"the function checks if the user\/session is logged in\"\"\"\n         if not session.get('logged_in'):\n             return False\n+        if request.remote_addr != session.get('ip_address'):\n+            return False\n         return True\n \n     # -------------------------\ndiff --git a\/easywall_web\/whitelist.py b\/easywall_web\/whitelist.py\nindex 4b60e24..517b522 100644\n--- a\/easywall_web\/whitelist.py\n+++ b\/easywall_web\/whitelist.py\n@@ -9,7 +9,7 @@ def whitelist(saved=False):\n     \"\"\"the function returns the whitelist page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Whitelist\")\n         payload.addresses = rules.get_rules_for_web(\"whitelist\")\n         payload.custom = rules.diff_new_current(\"whitelist\")\n@@ -24,7 +24,7 @@ def whitelist_save():\n     \"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         ipaddress = \"\"\n         rulelist = rules.get_rules_for_web(\"whitelist\")\n \n","files":{"\/easywall_web\/apply.py":{"changes":[{"diff":"\n     the function returns the apply page when the user is logged in\n     \"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Apply\")\n         payload.saved = saved\n         payload.step = step\n","add":1,"remove":1,"filename":"\/easywall_web\/apply.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]},{"diff":"\n     \"\"\"\n     utils = Webutils()\n     step = 0\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         for key, value in request.form.items():\n             if key == \"step_1\":\n                 apply_step_one()","add":1,"remove":1,"filename":"\/easywall_web\/apply.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]}],"source":"\n\"\"\" the module contains functions for the apply rules route \"\"\" from flask import render_template, request from easywall.utility import create_file_if_not_exists, write_into_file from easywall_web.login import login from easywall_web.webutils import Webutils def apply(saved=False, step=1): \"\"\" the function returns the apply page when the user is logged in \"\"\" utils=Webutils() if utils.check_login() is True: payload=utils.get_default_payload(\"Apply\") payload.saved=saved payload.step=step payload.lastapplied=utils.get_last_accept_time() payload.running=step > 1 payload.accepttime=utils.cfg_easywall.get_value(\"ACCEPTANCE\", \"duration\") return render_template('apply.html', vars=payload) return login(\"\", None) def apply_save(): \"\"\" the function applies the configuration and copies the rules to easywall core \"\"\" utils=Webutils() step=0 if utils.check_login() is True: for key, value in request.form.items(): if key==\"step_1\": apply_step_one() step=2 if key==\"step_2\": apply_step_two() step=3 return apply(True, step) return login(\"\", None) def apply_step_one() -> None: \"\"\" the function triggeres the easywall core to apply the new firewall rules \"\"\" create_file_if_not_exists(\".apply\") def apply_step_two() -> None: \"\"\"the function writes true into the accept file from easywall core\"\"\" write_into_file(\".acceptance\", \"true\") ","sourceWithComments":"\"\"\"\nthe module contains functions for the apply rules route\n\"\"\"\nfrom flask import render_template, request\nfrom easywall.utility import create_file_if_not_exists, write_into_file\nfrom easywall_web.login import login\nfrom easywall_web.webutils import Webutils\n\n\ndef apply(saved=False, step=1):\n    \"\"\"\n    the function returns the apply page when the user is logged in\n    \"\"\"\n    utils = Webutils()\n    if utils.check_login() is True:\n        payload = utils.get_default_payload(\"Apply\")\n        payload.saved = saved\n        payload.step = step\n        payload.lastapplied = utils.get_last_accept_time()\n        payload.running = step > 1\n        payload.accepttime = utils.cfg_easywall.get_value(\"ACCEPTANCE\", \"duration\")\n        return render_template('apply.html', vars=payload)\n    return login(\"\", None)\n\n\ndef apply_save():\n    \"\"\"\n    the function applies the configuration and copies the rules to easywall core\n    \"\"\"\n    utils = Webutils()\n    step = 0\n    if utils.check_login() is True:\n        for key, value in request.form.items():\n            if key == \"step_1\":\n                apply_step_one()\n                step = 2\n            if key == \"step_2\":\n                apply_step_two()\n                step = 3\n        return apply(True, step)\n    return login(\"\", None)\n\n\ndef apply_step_one() -> None:\n    \"\"\"\n    the function triggeres the easywall core to apply the new firewall rules\n    \"\"\"\n    create_file_if_not_exists(\".apply\")\n\n\ndef apply_step_two() -> None:\n    \"\"\"the function writes true into the accept file from easywall core\"\"\"\n    write_into_file(\".acceptance\", \"true\")\n"},"\/easywall_web\/blacklist.py":{"changes":[{"diff":"\n     \"\"\"the function returns the blacklist page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Blacklist\")\n         payload.addresses = rules.get_rules_for_web(\"blacklist\")\n         payload.custom = rules.diff_new_current(\"blacklist\")\n","add":1,"remove":1,"filename":"\/easywall_web\/blacklist.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]},{"diff":"\n     \"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         ipaddress = \"\"\n         rulelist = rules.get_rules_for_web(\"blacklist\")\n","add":1,"remove":1,"filename":"\/easywall_web\/blacklist.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]}],"source":"\n\"\"\"the module contains functions for the blacklist route\"\"\" from flask import render_template, request from easywall_web.login import login from easywall_web.webutils import Webutils from easywall.rules_handler import RulesHandler def blacklist(saved=False): \"\"\"the function returns the blacklist page when the user is logged in\"\"\" utils=Webutils() rules=RulesHandler() if utils.check_login() is True: payload=utils.get_default_payload(\"Blacklist\") payload.addresses=rules.get_rules_for_web(\"blacklist\") payload.custom=rules.diff_new_current(\"blacklist\") payload.saved=saved return render_template('blacklist.html', vars=payload) return login(\"\", None) def blacklist_save(): \"\"\" the function saves the blacklist rules into the corresponding rulesfile \"\"\" utils=Webutils() rules=RulesHandler() if utils.check_login() is True: ipaddress=\"\" rulelist=rules.get_rules_for_web(\"blacklist\") for key, value in request.form.items(): if key==\"ipadr\": ipaddress=value rulelist.append(ipaddress) rules.save_new_rules(\"blacklist\", rulelist) else: ipaddress=key rulelist.remove(ipaddress) rules.save_new_rules(\"blacklist\", rulelist) return blacklist(True) return login(\"\", None) ","sourceWithComments":"\"\"\"the module contains functions for the blacklist route\"\"\"\nfrom flask import render_template, request\nfrom easywall_web.login import login\nfrom easywall_web.webutils import Webutils\nfrom easywall.rules_handler import RulesHandler\n\n\ndef blacklist(saved=False):\n    \"\"\"the function returns the blacklist page when the user is logged in\"\"\"\n    utils = Webutils()\n    rules = RulesHandler()\n    if utils.check_login() is True:\n        payload = utils.get_default_payload(\"Blacklist\")\n        payload.addresses = rules.get_rules_for_web(\"blacklist\")\n        payload.custom = rules.diff_new_current(\"blacklist\")\n        payload.saved = saved\n        return render_template('blacklist.html', vars=payload)\n    return login(\"\", None)\n\n\ndef blacklist_save():\n    \"\"\"\n    the function saves the blacklist rules into the corresponding rulesfile\n    \"\"\"\n    utils = Webutils()\n    rules = RulesHandler()\n    if utils.check_login() is True:\n        ipaddress = \"\"\n        rulelist = rules.get_rules_for_web(\"blacklist\")\n\n        for key, value in request.form.items():\n            if key == \"ipadr\":\n                # then a new ip address is blacklisted\n                ipaddress = value\n                rulelist.append(ipaddress)\n                rules.save_new_rules(\"blacklist\", rulelist)\n            else:\n                # then a old ip address is removed\n                ipaddress = key\n                rulelist.remove(ipaddress)\n                rules.save_new_rules(\"blacklist\", rulelist)\n        return blacklist(True)\n    return login(\"\", None)\n"},"\/easywall_web\/custom.py":{"changes":[{"diff":"\n     \"\"\"the function returns the custom rules page when the user is logged in\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         payload = utils.get_default_payload(\"Custom\")\n         payload.rules = rules.get_rules_for_web(\"custom\")\n         payload.custom = rules.diff_new_current(\"custom\")\n","add":1,"remove":1,"filename":"\/easywall_web\/custom.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]},{"diff":"\n     \"\"\"the function saves the custom rules into the corresponding rulesfile\"\"\"\n     utils = Webutils()\n     rules = RulesHandler()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         for key, value in request.form.items():\n             key = str(key) + \"\"  # just for ignoring the warning\n             rulelist = value.split(\"\\n","add":1,"remove":1,"filename":"\/easywall_web\/custom.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]}],"source":"\n\"\"\"the module contains functions for the custom rules route\"\"\" from flask import render_template, request from easywall_web.login import login from easywall_web.webutils import Webutils from easywall.rules_handler import RulesHandler def custom(saved=False): \"\"\"the function returns the custom rules page when the user is logged in\"\"\" utils=Webutils() rules=RulesHandler() if utils.check_login() is True: payload=utils.get_default_payload(\"Custom\") payload.rules=rules.get_rules_for_web(\"custom\") payload.custom=rules.diff_new_current(\"custom\") payload.saved=saved return render_template('custom.html', vars=payload) return login(\"\", None) def custom_save(): \"\"\"the function saves the custom rules into the corresponding rulesfile\"\"\" utils=Webutils() rules=RulesHandler() if utils.check_login() is True: for key, value in request.form.items(): key=str(key) +\"\" rulelist=value.split(\"\\n\") rules.save_new_rules(\"custom\", rulelist) return custom(True) return login(\"\", None) ","sourceWithComments":"\"\"\"the module contains functions for the custom rules route\"\"\"\nfrom flask import render_template, request\nfrom easywall_web.login import login\nfrom easywall_web.webutils import Webutils\nfrom easywall.rules_handler import RulesHandler\n\n\ndef custom(saved=False):\n    \"\"\"the function returns the custom rules page when the user is logged in\"\"\"\n    utils = Webutils()\n    rules = RulesHandler()\n    if utils.check_login() is True:\n        payload = utils.get_default_payload(\"Custom\")\n        payload.rules = rules.get_rules_for_web(\"custom\")\n        payload.custom = rules.diff_new_current(\"custom\")\n        payload.saved = saved\n        return render_template('custom.html', vars=payload)\n    return login(\"\", None)\n\n\ndef custom_save():\n    \"\"\"the function saves the custom rules into the corresponding rulesfile\"\"\"\n    utils = Webutils()\n    rules = RulesHandler()\n    if utils.check_login() is True:\n        for key, value in request.form.items():\n            key = str(key) + \"\"  # just for ignoring the warning\n            rulelist = value.split(\"\\n\")\n            rules.save_new_rules(\"custom\", rulelist)\n        return custom(True)\n    return login(\"\", None)\n"},"\/easywall_web\/error.py":{"changes":[{"diff":"\n \"\"\"the module contains functions for custom error routes\"\"\"\n-from flask import render_template\n+from flask import render_template, request\n from easywall_web.login import login\n from easywall_web.webutils import Webutils\n \n","add":1,"remove":1,"filename":"\/easywall_web\/error.py","badparts":["from flask import render_template"],"goodparts":["from flask import render_template, request"]},{"diff":"\n     \"\"\"the function returns the 404 error page when the user is logged in\"\"\"\n     utils = Webutils()\n-    if utils.check_login() is True:\n+    if utils.check_login(request) is True:\n         return render_template(\n             '404.html', vars=utils.get_default_payload(\"404 Error\", \"error\")), 404\n     return login(\"\", No","add":1,"remove":1,"filename":"\/easywall_web\/error.py","badparts":["    if utils.check_login() is True:"],"goodparts":["    if utils.check_login(request) is True:"]}],"source":"\n\"\"\"the module contains functions for custom error routes\"\"\" from flask import render_template from easywall_web.login import login from easywall_web.webutils import Webutils def page_not_found(error): \"\"\"the function returns the 404 error page when the user is logged in\"\"\" utils=Webutils() if utils.check_login() is True: return render_template( '404.html', vars=utils.get_default_payload(\"404 Error\", \"error\")), 404 return login(\"\", None) ","sourceWithComments":"\"\"\"the module contains functions for custom error routes\"\"\"\nfrom flask import render_template\nfrom easywall_web.login import login\nfrom easywall_web.webutils import Webutils\n\n\ndef page_not_found(error):\n    \"\"\"the function returns the 404 error page when the user is logged in\"\"\"\n    utils = Webutils()\n    if utils.check_login() is True:\n        return render_template(\n            '404.html', vars=utils.get_default_payload(\"404 Error\", \"error\")), 404\n    return login(\"\", None)\n"}},"msg":"login check ip address to prevent session hijacking"}},"https:\/\/github.com\/ecs-org\/ecs":{"f421af1523c7e700d2f8dc65bca900ffc50a7e5f":{"url":"https:\/\/api.github.com\/repos\/ecs-org\/ecs\/commits\/f421af1523c7e700d2f8dc65bca900ffc50a7e5f","html_url":"https:\/\/github.com\/ecs-org\/ecs\/commit\/f421af1523c7e700d2f8dc65bca900ffc50a7e5f","message":"Make use of the X_SSL_Client_Verify HTTP header to check client certificates.\n\nThis allows to remove the old baroque authentication mechanism. We also\nnow always enforce presence of a certificate for internal users, not only\nat login-time. This makes session hijacking harder, because the attacker\nwill also need a client certificate to pull it off.","sha":"f421af1523c7e700d2f8dc65bca900ffc50a7e5f","keyword":"session hijacking check","diff":"diff --git a\/ecs\/pki\/middleware.py b\/ecs\/pki\/middleware.py\nindex 570437f78..bcc7dad5c 100644\n--- a\/ecs\/pki\/middleware.py\n+++ b\/ecs\/pki\/middleware.py\n@@ -1,19 +1,15 @@\n-from urllib.parse import urlencode\n-from django.http import HttpResponseRedirect\n-from django.core.urlresolvers import reverse\n+from django.http import HttpResponseForbidden\n from django.conf import settings\n \n+\n class ClientCertMiddleware(object):\n     def process_request(self, request):\n         if not getattr(settings, 'ECS_REQUIRE_CLIENT_CERTS', True):\n             return\n-        \n+\n         if request.user.is_authenticated():\n-            # nested to prevent premature imports\n-            url = reverse('ecs.pki.views.authenticate')\n             profile = request.user.profile\n-            if request.path != url and \\\n-                (profile.is_internal or profile.is_omniscient_member) and \\\n-                not request.session.get('ecs_pki_authenticated', False):\n-                return HttpResponseRedirect('%s?%s' % (url, urlencode({'next': request.get_full_path()})))\n-        \n+            if (profile.is_internal or profile.is_omniscient_member) and \\\n+                request.META.get('HTTP_X_SSL_CLIENT_VERIFY') != 'SUCCESS':\n+\n+                return HttpResponseForbidden()\ndiff --git a\/ecs\/pki\/urls.py b\/ecs\/pki\/urls.py\nindex 9a107197e..c2ebd6c62 100644\n--- a\/ecs\/pki\/urls.py\n+++ b\/ecs\/pki\/urls.py\n@@ -7,5 +7,4 @@\n     url(r'^pki\/certs\/new\/$', views.create_cert),\n     url(r'^pki\/certs\/$', views.cert_list),\n     url(r'^pki\/certs\/(?P<cert_pk>\\d+)\/revoke\/$', views.revoke_cert),\n-    url(r'^secure\/login\/$', views.authenticate),\n )\ndiff --git a\/ecs\/pki\/views.py b\/ecs\/pki\/views.py\nindex a95e8820c..1f61ad588 100644\n--- a\/ecs\/pki\/views.py\n+++ b\/ecs\/pki\/views.py\n@@ -3,15 +3,11 @@\n from django.conf import settings\n from django.shortcuts import render, redirect, get_object_or_404\n from django.views.decorators.http import require_POST\n-from django.http import HttpResponse\n-from django.core.urlresolvers import reverse\n from django.db.models import Count\n from django.utils.text import slugify\n from django.utils.translation import ugettext as _\n-from django.contrib import messages\n \n from ecs.communication.mailutils import deliver\n-from ecs.utils.viewutils import redirect_to_next_url\n from ecs.users.utils import user_group_required\n \n from ecs.pki.forms import CertForm\n@@ -70,12 +66,3 @@ def revoke_cert(request, cert_pk=None):\n     cert = get_object_or_404(Certificate, pk=cert_pk)\n     cert.revoke()\n     return redirect('ecs.pki.views.cert_list')\n-\n-\n-def authenticate(request):\n-    profile = request.user.profile\n-    if profile.is_internal or profile.is_omniscient_member:\n-        request.session['ecs_pki_authenticated'] = True\n-        request.session.modified = True\n-    return redirect_to_next_url(request, reverse('ecs.dashboard.views.view_dashboard'))\n-    \n","files":{"\/ecs\/pki\/middleware.py":{"changes":[{"diff":"\n-from urllib.parse import urlencode\n-from django.http import HttpResponseRedirect\n-from django.core.urlresolvers import reverse\n+from django.http import HttpResponseForbidden\n from django.conf import settings\n \n+\n class ClientCertMiddleware(object):\n     def process_request(self, request):\n         if not getattr(settings, 'ECS_REQUIRE_CLIENT_CERTS', True):\n             return\n-        \n+\n         if request.user.is_authenticated():\n-            # nested to prevent premature imports\n-            url = reverse('ecs.pki.views.authenticate')\n             profile = request.user.profile\n-            if request.path != url and \\\n-                (profile.is_internal or profile.is_omniscient_member) and \\\n-                not request.session.get('ecs_pki_authenticated', False):\n-                return HttpResponseRedirect('%s?%s' % (url, urlencode({'next': request.get_full_path()})))\n-        \n+            if (profile.is_internal or profile.is_omniscient_member) and \\\n+                request.META.get('HTTP_X_SSL_CLIENT_VERIFY') != 'SUCCESS':\n+\n+                return HttpResponseForbidden()","add":7,"remove":11,"filename":"\/ecs\/pki\/middleware.py","badparts":["from urllib.parse import urlencode","from django.http import HttpResponseRedirect","from django.core.urlresolvers import reverse","            url = reverse('ecs.pki.views.authenticate')","            if request.path != url and \\","                (profile.is_internal or profile.is_omniscient_member) and \\","                not request.session.get('ecs_pki_authenticated', False):","                return HttpResponseRedirect('%s?%s' % (url, urlencode({'next': request.get_full_path()})))"],"goodparts":["from django.http import HttpResponseForbidden","            if (profile.is_internal or profile.is_omniscient_member) and \\","                request.META.get('HTTP_X_SSL_CLIENT_VERIFY') != 'SUCCESS':","                return HttpResponseForbidden()"]}],"source":"\nfrom urllib.parse import urlencode from django.http import HttpResponseRedirect from django.core.urlresolvers import reverse from django.conf import settings class ClientCertMiddleware(object): def process_request(self, request): if not getattr(settings, 'ECS_REQUIRE_CLIENT_CERTS', True): return if request.user.is_authenticated(): url=reverse('ecs.pki.views.authenticate') profile=request.user.profile if request.path !=url and \\ (profile.is_internal or profile.is_omniscient_member) and \\ not request.session.get('ecs_pki_authenticated', False): return HttpResponseRedirect('%s?%s' %(url, urlencode({'next': request.get_full_path()}))) ","sourceWithComments":"from urllib.parse import urlencode\nfrom django.http import HttpResponseRedirect\nfrom django.core.urlresolvers import reverse\nfrom django.conf import settings\n\nclass ClientCertMiddleware(object):\n    def process_request(self, request):\n        if not getattr(settings, 'ECS_REQUIRE_CLIENT_CERTS', True):\n            return\n        \n        if request.user.is_authenticated():\n            # nested to prevent premature imports\n            url = reverse('ecs.pki.views.authenticate')\n            profile = request.user.profile\n            if request.path != url and \\\n                (profile.is_internal or profile.is_omniscient_member) and \\\n                not request.session.get('ecs_pki_authenticated', False):\n                return HttpResponseRedirect('%s?%s' % (url, urlencode({'next': request.get_full_path()})))\n        \n"},"\/ecs\/pki\/urls.py":{"changes":[{"diff":"\n     url(r'^pki\/certs\/new\/$', views.create_cert),\n     url(r'^pki\/certs\/$', views.cert_list),\n     url(r'^pki\/certs\/(?P<cert_pk>\\d+)\/revoke\/$', views.revoke_cert),\n-    url(r'^secure\/login\/$', views.authenticate),\n ","add":0,"remove":1,"filename":"\/ecs\/pki\/urls.py","badparts":["    url(r'^secure\/login\/$', views.authenticate),"],"goodparts":[]}],"source":"\nfrom django.conf.urls import url from ecs.pki import views urlpatterns=( url(r'^pki\/certs\/new\/$', views.create_cert), url(r'^pki\/certs\/$', views.cert_list), url(r'^pki\/certs\/(?P<cert_pk>\\d+)\/revoke\/$', views.revoke_cert), url(r'^secure\/login\/$', views.authenticate), ) ","sourceWithComments":"from django.conf.urls import url\n\nfrom ecs.pki import views\n\n\nurlpatterns = (\n    url(r'^pki\/certs\/new\/$', views.create_cert),\n    url(r'^pki\/certs\/$', views.cert_list),\n    url(r'^pki\/certs\/(?P<cert_pk>\\d+)\/revoke\/$', views.revoke_cert),\n    url(r'^secure\/login\/$', views.authenticate),\n)\n"},"\/ecs\/pki\/views.py":{"changes":[{"diff":"\n from django.conf import settings\n from django.shortcuts import render, redirect, get_object_or_404\n from django.views.decorators.http import require_POST\n-from django.http import HttpResponse\n-from django.core.urlresolvers import reverse\n from django.db.models import Count\n from django.utils.text import slugify\n from django.utils.translation import ugettext as _\n-from django.contrib import messages\n \n from ecs.communication.mailutils import deliver\n-from ecs.utils.viewutils import redirect_to_next_url\n from ecs.users.utils import user_group_required\n \n from ecs.pki.forms import CertForm\n","add":0,"remove":4,"filename":"\/ecs\/pki\/views.py","badparts":["from django.http import HttpResponse","from django.core.urlresolvers import reverse","from django.contrib import messages","from ecs.utils.viewutils import redirect_to_next_url"],"goodparts":[]},{"diff":"\n     cert = get_object_or_404(Certificate, pk=cert_pk)\n     cert.revoke()\n     return redirect('ecs.pki.views.cert_list')\n-\n-\n-def authenticate(request):\n-    profile = request.user.profile\n-    if profile.is_internal or profile.is_omniscient_member:\n-        request.session['ecs_pki_authenticated'] = True\n-        request.session.modified = True\n-    return redirect_to_next_url(request, reverse('ecs.dashboard.views.view_dashboard'))\n-    \n","add":0,"remove":9,"filename":"\/ecs\/pki\/views.py","badparts":["def authenticate(request):","    profile = request.user.profile","    if profile.is_internal or profile.is_omniscient_member:","        request.session['ecs_pki_authenticated'] = True","        request.session.modified = True","    return redirect_to_next_url(request, reverse('ecs.dashboard.views.view_dashboard'))"],"goodparts":[]}],"source":"\nimport tempfile from django.conf import settings from django.shortcuts import render, redirect, get_object_or_404 from django.views.decorators.http import require_POST from django.http import HttpResponse from django.core.urlresolvers import reverse from django.db.models import Count from django.utils.text import slugify from django.utils.translation import ugettext as _ from django.contrib import messages from ecs.communication.mailutils import deliver from ecs.utils.viewutils import redirect_to_next_url from ecs.users.utils import user_group_required from ecs.pki.forms import CertForm from ecs.pki.models import Certificate @user_group_required('EC-Signing', 'EC-Office') def cert_list(request): return render(request, 'pki\/cert_list.html',{ 'certs':( Certificate.objects .select_related('user') .annotate(is_revoked=Count('revoked_at')) .order_by('is_revoked', 'user__email', 'cn') ), }) @user_group_required('EC-Signing') def create_cert(request): form=CertForm(request.POST or None) if form.is_valid(): cn=form.cleaned_data.get('cn').strip() user=form.cleaned_data['user'] with tempfile.NamedTemporaryFile() as tmp: cert, passphrase=Certificate.create_for_user(tmp.name, user, cn=cn) pkcs12=tmp.read() filename='{}.p12'.format(slugify(cert.cn)) subject=_('Your Client Certificate') message=_('See Attachment.') attachments=( (filename, pkcs12, 'application\/x-pkcs12'), ) deliver(user.email, subject=subject, message=message, from_email=settings.DEFAULT_FROM_EMAIL, attachments=attachments) return render(request, 'pki\/cert_created.html',{ 'passphrase': passphrase, 'user': user, }) return render(request, 'pki\/create_cert.html',{ 'form': form, }) @require_POST @user_group_required('EC-Signing', 'EC-Office') def revoke_cert(request, cert_pk=None): cert=get_object_or_404(Certificate, pk=cert_pk) cert.revoke() return redirect('ecs.pki.views.cert_list') def authenticate(request): profile=request.user.profile if profile.is_internal or profile.is_omniscient_member: request.session['ecs_pki_authenticated']=True request.session.modified=True return redirect_to_next_url(request, reverse('ecs.dashboard.views.view_dashboard')) ","sourceWithComments":"import tempfile\n\nfrom django.conf import settings\nfrom django.shortcuts import render, redirect, get_object_or_404\nfrom django.views.decorators.http import require_POST\nfrom django.http import HttpResponse\nfrom django.core.urlresolvers import reverse\nfrom django.db.models import Count\nfrom django.utils.text import slugify\nfrom django.utils.translation import ugettext as _\nfrom django.contrib import messages\n\nfrom ecs.communication.mailutils import deliver\nfrom ecs.utils.viewutils import redirect_to_next_url\nfrom ecs.users.utils import user_group_required\n\nfrom ecs.pki.forms import CertForm\nfrom ecs.pki.models import Certificate\n\n\n@user_group_required('EC-Signing', 'EC-Office')\ndef cert_list(request):\n    return render(request, 'pki\/cert_list.html', {\n        'certs': (\n            Certificate.objects\n                .select_related('user')\n                .annotate(is_revoked=Count('revoked_at'))\n                .order_by('is_revoked', 'user__email', 'cn')\n        ),\n    })\n\n\n@user_group_required('EC-Signing')\ndef create_cert(request):\n    form = CertForm(request.POST or None)\n\n    if form.is_valid():\n        cn = form.cleaned_data.get('cn').strip()\n        user = form.cleaned_data['user']\n\n        with tempfile.NamedTemporaryFile() as tmp:\n            cert, passphrase = Certificate.create_for_user(tmp.name, user, cn=cn)\n            pkcs12 = tmp.read()\n\n        filename = '{}.p12'.format(slugify(cert.cn))\n\n        subject = _('Your Client Certificate')\n        message = _('See Attachment.')\n        attachments = (\n            (filename, pkcs12, 'application\/x-pkcs12'),\n        )\n\n        deliver(user.email, subject=subject, message=message,\n            from_email=settings.DEFAULT_FROM_EMAIL,\n            attachments=attachments)\n\n        return render(request, 'pki\/cert_created.html', {\n            'passphrase': passphrase,\n            'user': user,\n        })\n\n    return render(request, 'pki\/create_cert.html', {\n        'form': form,\n    })\n\n\n@require_POST\n@user_group_required('EC-Signing', 'EC-Office')\ndef revoke_cert(request, cert_pk=None):\n    cert = get_object_or_404(Certificate, pk=cert_pk)\n    cert.revoke()\n    return redirect('ecs.pki.views.cert_list')\n\n\ndef authenticate(request):\n    profile = request.user.profile\n    if profile.is_internal or profile.is_omniscient_member:\n        request.session['ecs_pki_authenticated'] = True\n        request.session.modified = True\n    return redirect_to_next_url(request, reverse('ecs.dashboard.views.view_dashboard'))\n    \n"}},"msg":"Make use of the X_SSL_Client_Verify HTTP header to check client certificates.\n\nThis allows to remove the old baroque authentication mechanism. We also\nnow always enforce presence of a certificate for internal users, not only\nat login-time. This makes session hijacking harder, because the attacker\nwill also need a client certificate to pull it off."}},"https:\/\/github.com\/Saevon\/webdnd":{"298f7647f7878a3d009f25cefa881ae9435c58de":{"url":"https:\/\/api.github.com\/repos\/Saevon\/webdnd\/commits\/298f7647f7878a3d009f25cefa881ae9435c58de","html_url":"https:\/\/github.com\/Saevon\/webdnd\/commit\/298f7647f7878a3d009f25cefa881ae9435c58de","message":"Login and View formatting.\n * Fixed up sessions, there is a problem with using secure session (check it out later)\n * Turned views into class based views, added login_required mixin\n * Hijacked bootstrap alert to be able to dismiss dismissible alerts by clicking anywhere in them","sha":"298f7647f7878a3d009f25cefa881ae9435c58de","keyword":"session hijacking check","diff":"diff --git a\/player\/urls.py b\/player\/urls.py\nindex 5b8099c..90ecdb5 100644\n--- a\/player\/urls.py\n+++ b\/player\/urls.py\n@@ -1,10 +1,14 @@\n from django.conf.urls.defaults import patterns, include, url\n from django.views.generic.simple import redirect_to\n \n+from webdnd.player.views import AccountHomeView\n+from webdnd.player.views import LoginView\n+\n \n urlpatterns = patterns('webdnd.player.views',\n     url(r'^$', redirect_to, {'url': '\/account\/login'}),\n-    url(r'^login', 'login'),\n-    url(r'^logout', 'logout'),\n-    url(r'^settigs', 'settings'),\n+    url(r'^home$', AccountHomeView.as_view(), name='account_home'),\n+    url(r'^login', LoginView.as_view(), name='account_login'),\n+    url(r'^logout', 'logout', name='account_logout'),\n+    url(r'^settings', 'settings', name='account_settings'),\n )\ndiff --git a\/player\/views.py b\/player\/views.py\nindex 9819982..31f464b 100644\n--- a\/player\/views.py\n+++ b\/player\/views.py\n@@ -1,7 +1,15 @@\n-from django.http import HttpResponse\n+from django.contrib.auth import authenticate, login\n+from django.http import HttpResponse, HttpResponseRedirect\n from django.template.loader import get_template\n-from django.template import Context, RequestContext\n+from django.template import RequestContext\n from django.shortcuts import render_to_response\n+from django.core.urlresolvers import reverse\n+from django.contrib.auth.decorators import login_required\n+from django.utils.decorators import method_decorator\n+from django.views.generic import View\n+\n+from webdnd.shared.views import LoginRequiredMixin\n+\n \n def homepage(request):\n     return render_to_response('game_main.html', {}, context_instance=RequestContext(request))\n@@ -9,6 +17,56 @@ def homepage(request):\n def display_sheet(request, character_name):\n     return render_to_response('character_sheet.html', {'character_name': character_name}, context_instance=RequestContext(request))\n \n-def login(request):\n-    return render_to_response('account\/login.html', {}, context_instance=RequestContext(request))\n+def settings(request):\n+    pass\n+\n+def logout(request):\n+    pass\n+\n+\n+class AccountHomeView(View, LoginRequiredMixin):\n+\n+    def get(self, request):\n+        return render_to_response(\n+            'account\/home.html',\n+            {},\n+            context_instance=RequestContext(request)\n+        )\n+\n+class LoginView(View):\n+\n+    def get(self, request):\n+        out = {\n+            'username': request.GET.get('username', ''),\n+            'password': '',\n+            # TODO: this does nothing right now, and isnt saved\n+            'remember': request.GET.get('remember', ''),\n+            'error': request.GET.get('error', False),\n+        }\n+\n+        return render_to_response(\n+            'account\/login.html',\n+            out,\n+            context_instance=RequestContext(request)\n+        )\n+\n+    def post(self, request):\n+        username = request.POST.get('username', '')\n+        password = request.POST.get('password', '')\n+        user = authenticate(username=username, password=password)\n+        if user is not None:\n+            if user.is_active:\n+                login(request, user)\n+                url = reverse('account_home')\n+            else:\n+                # Add a page for disabled\/banned users\n+                url = '%s?username=%s&error=1' % (reverse('account_login'), username)\n+        else:\n+            # Validation failed\n+            url = '%s?username=%s&error=1' % (reverse('account_login'), username)\n+\n+        return HttpResponseRedirect(url)\n+\n+\n+        \n \ndiff --git a\/settings.py b\/settings.py\nindex 6727482..f7b80bd 100644\n--- a\/settings.py\n+++ b\/settings.py\n@@ -127,10 +127,8 @@\n \n # How long cookies will last\n SESSION_COOKIE_AGE = 60 * 60 * 24\n-SESSION_ENGINE = 'django.contrib.sessions.backends.cache'\n SESSION_COOKIE_NAME = 'webdndID'\n-SESSION_COOKIE_SECURE = True\n-SESSION_EXPIRE_AT_BROWSER_CLOSE = True\n+SESSION_EXPIRE_AT_BROWSER_CLOSE = False\n \n # Default url to redirect to for login\n LOGIN_URL = '\/account\/login'\ndiff --git a\/shared\/__init__.py b\/shared\/__init__.py\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a\/shared\/static\/js\/bootstrap-plugins.js b\/shared\/static\/js\/bootstrap-plugins.js\nnew file mode 100644\nindex 0000000..a93fa55\n--- \/dev\/null\n+++ b\/shared\/static\/js\/bootstrap-plugins.js\n@@ -0,0 +1,23 @@\n+$(function() {\n+    \/*****************************\n+     * Alerts dismissal by clicking on any part of them\n+     * Only alerts with a 'close' button can be closed this way\n+     *   aka with a data-dismiss attr\n+     *\/\n+\n+    $('.alert').on('click', function() {\n+        $(this).alert('close')\n+    });\n+\n+    var old_alert = $.fn.alert;\n+\n+    $.fn.alert = function alert(opt) {\n+        \/\/ Hijack new alerts that have a close button\n+        if (opt === undefined && $(this).find('[data-dismiss]').length) {\n+            $(el).on('click', function() {\n+                $(this).alert('close');\n+            });\n+        };\n+        return old_alert.call(this, opt);\n+    }\n+});\n\\ No newline at end of file\ndiff --git a\/shared\/templates\/account\/home.html b\/shared\/templates\/account\/home.html\nnew file mode 100644\nindex 0000000..06ca8b7\n--- \/dev\/null\n+++ b\/shared\/templates\/account\/home.html\n@@ -0,0 +1,9 @@\n+{% extends \"account\/base.html\" %}\n+\n+\n+{% block title %}Webdnd ~ {{ user.username }}{% endblock %}\n+{% block tab_name %}home{% endblock %}\n+\n+\n+{% block content %}\n+{% endblock %}\ndiff --git a\/shared\/templates\/account\/login.html b\/shared\/templates\/account\/login.html\nindex cdb689a..d470369 100644\n--- a\/shared\/templates\/account\/login.html\n+++ b\/shared\/templates\/account\/login.html\n@@ -1,34 +1,42 @@\n {% extends \"account\/base.html\" %}\n \n-{% block title %}Webdnd ~ Login{% endblock %}\n \n+{% block title %}Webdnd ~ Login{% endblock %}\n {% block tab_name %}login{% endblock %}\n \n+\n {% block content %}\n-<form class=\"form-horizontal\" id=\"login\">\n+<form class=\"form-horizontal\" id=\"login\" method=\"POST\">\n+    {% if error %}\n+        <div class=\"alert alert-error fade in\">\n+            <button type=\"button\" class=\"close\" data-dismiss=\"alert\">\u00d7<\/button>\n+            <strong>Error!<\/strong> There was a problem logging you in. Check your credentials and try again.\n+        <\/div>\n+    {% endif %}\n \n-        \n-        <legend>\n-Login\n-<\/legend>\n-<div class=\"control-group\">\n-    <label class=\"control-label\" for=\"inputEmail\">Email<\/label>\n-    <div class=\"controls\">\n-      <input type=\"text\" id=\"inputEmail\" placeholder=\"Email\">\n-    <\/div>\n-  <\/div>\n-  <div class=\"control-group\">\n-    <label class=\"control-label\" for=\"inputPassword\">Password<\/label>\n-    <div class=\"controls\">\n-      <input type=\"password\" id=\"inputPassword\" placeholder=\"Password\">\n-    <\/div>\n-  <\/div>\n-  <div class=\"control-group\">\n-    <div class=\"controls\">\n-      <label class=\"checkbox\">\n-        <input type=\"checkbox\"> Remember me\n-      <\/label>\n-      <button type=\"submit\" class=\"btn btn-info\">Sign in<\/button>\n-    <\/div>\n-  <\/div>\n-    <\/form>{% endblock %}\n+    <legend> Login <\/legend>\n+    {{ request.error }}\n+        {% csrf_token %}\n+        <div class=\"control-group\">\n+            <label class=\"control-label\" for=\"inputEmail\">Email<\/label>\n+            <div class=\"controls\">\n+                <input type=\"text\" name=\"username\" placeholder=\"Username\"\n+                        value=\"{{ username }}\">\n+            <\/div>\n+        <\/div>\n+        <div class=\"control-group\">\n+            <label class=\"control-label\" for=\"inputPassword\">Password<\/label>\n+            <div class=\"controls\">\n+                <input type=\"password\" name=\"password\" placeholder=\"Password\">\n+            <\/div>\n+        <\/div>\n+        <div class=\"control-group\">\n+            <div class=\"controls\">\n+                <label class=\"checkbox\">\n+                    <input disabled class=\"disabled\" type=\"checkbox\" name=\"remember\" {{ remember }}> <span class=\"muted\">Remember me<\/span>\n+                <\/label>\n+                <button type=\"submit\" class=\"btn btn-info\">Sign in<\/button>\n+            <\/div>\n+        <\/div>\n+<\/form>\n+{% endblock %}\ndiff --git a\/shared\/templates\/base.html b\/shared\/templates\/base.html\nindex 92047e9..43a9684 100644\n--- a\/shared\/templates\/base.html\n+++ b\/shared\/templates\/base.html\n@@ -39,13 +39,13 @@\n           <a class=\"brand\" href=\"\/account\">Web D&amp;D<\/a>\n           <div class=\"nav-collapse collapse\">\n             <ul class=\"nav\">\n-              <li id=\"nav_home\"><a href=\"\/account\">Home<\/a><\/li>\n-              {% if logged_in %}\n+              <li id=\"nav_home\"><a href=\"\/account\/home\">Home<\/a><\/li>\n+              {% if user.is_active %}\n                 <li id=\"nav_settings\"><a href=\"\/account\/settings\">Settings<\/a><\/li>\n               {% endif %}\n             <\/ul>\n             <ul class=\"nav pull-right\">\n-              {% if logged_in %}\n+              {% if user.is_active %}\n                 <li id=\"nav_logout\" class=\"pull-right\"><a href=\"\/account\/logout\">Logout<\/a><\/li>\n               {% else %}\n                 <li id=\"nav_login\" class=\"pull-right\"><a href=\"\/account\/login\">Login<\/a><\/li>\n@@ -71,6 +71,7 @@\n     {% compress js %}\n       <script type=\"text\/javascript\" src=\"{% static 'shared\/js\/jquery.js' %}\"><\/script>\n       <script type=\"text\/javascript\" src=\"{% static 'shared\/js\/bootstrap.js' %}\"><\/script>\n+      <script type=\"text\/javascript\" src=\"{% static 'shared\/js\/bootstrap-plugins.js' %}\"><\/script>\n     {% endcompress %}\n     {% compress js %}\n       {% block extra_js %}{% endblock %}\ndiff --git a\/shared\/views.py b\/shared\/views.py\nnew file mode 100644\nindex 0000000..bcbb61f\n--- \/dev\/null\n+++ b\/shared\/views.py\n@@ -0,0 +1,10 @@\n+from django.contrib.auth.decorators import login_required\n+\n+class LoginRequiredMixin(object):\n+    \"\"\"\n+    Mixin that requires all methods for this view to have a logged in user\n+    \"\"\"\n+\n+    def as_view(cls):\n+        return login_required(super(LoginRequiredMixin, cls).as_view())\n+\ndiff --git a\/urls.py b\/urls.py\nindex cd8edf6..4144df6 100644\n--- a\/urls.py\n+++ b\/urls.py\n@@ -44,7 +44,6 @@\n     # (r'^game-admin\/', include(game_admin_site.urls)),\n     # (r'^library-admin\/', include(library_admin_site.urls)),\n ) + staticfiles_urlpatterns()\n-print staticfiles_urlpatterns()\n \n # Page to serve in case one of these errors occurs\n # handler404 = '.views.error_404'\n","files":{"\/player\/urls.py":{"changes":[{"diff":"\n from django.conf.urls.defaults import patterns, include, url\n from django.views.generic.simple import redirect_to\n \n+from webdnd.player.views import AccountHomeView\n+from webdnd.player.views import LoginView\n+\n \n urlpatterns = patterns('webdnd.player.views',\n     url(r'^$', redirect_to, {'url': '\/account\/login'}),\n-    url(r'^login', 'login'),\n-    url(r'^logout', 'logout'),\n-    url(r'^settigs', 'settings'),\n+    url(r'^home$', AccountHomeView.as_view(), name='account_home'),\n+    url(r'^login', LoginView.as_view(), name='account_login'),\n+    url(r'^logout', 'logout', name='account_logout'),\n+    url(r'^settings', 'settings', name='account_settings'),\n )","add":7,"remove":3,"filename":"\/player\/urls.py","badparts":["    url(r'^login', 'login'),","    url(r'^logout', 'logout'),","    url(r'^settigs', 'settings'),"],"goodparts":["from webdnd.player.views import AccountHomeView","from webdnd.player.views import LoginView","    url(r'^home$', AccountHomeView.as_view(), name='account_home'),","    url(r'^login', LoginView.as_view(), name='account_login'),","    url(r'^logout', 'logout', name='account_logout'),","    url(r'^settings', 'settings', name='account_settings'),"]}],"source":"\nfrom django.conf.urls.defaults import patterns, include, url from django.views.generic.simple import redirect_to urlpatterns=patterns('webdnd.player.views', url(r'^$', redirect_to,{'url': '\/account\/login'}), url(r'^login', 'login'), url(r'^logout', 'logout'), url(r'^settigs', 'settings'), ) ","sourceWithComments":"from django.conf.urls.defaults import patterns, include, url\nfrom django.views.generic.simple import redirect_to\n\n\nurlpatterns = patterns('webdnd.player.views',\n    url(r'^$', redirect_to, {'url': '\/account\/login'}),\n    url(r'^login', 'login'),\n    url(r'^logout', 'logout'),\n    url(r'^settigs', 'settings'),\n)\n"},"\/player\/views.py":{"changes":[{"diff":"\n-from django.http import HttpResponse\n+from django.contrib.auth import authenticate, login\n+from django.http import HttpResponse, HttpResponseRedirect\n from django.template.loader import get_template\n-from django.template import Context, RequestContext\n+from django.template import RequestContext\n from django.shortcuts import render_to_response\n+from django.core.urlresolvers import reverse\n+from django.contrib.auth.decorators import login_required\n+from django.utils.decorators import method_decorator\n+from django.views.generic import View\n+\n+from webdnd.shared.views import LoginRequiredMixin\n+\n \n def homepage(request):\n     return render_to_response('game_main.html', {}, context_instance=RequestContext(request))\n","add":10,"remove":2,"filename":"\/player\/views.py","badparts":["from django.http import HttpResponse","from django.template import Context, RequestContext"],"goodparts":["from django.contrib.auth import authenticate, login","from django.http import HttpResponse, HttpResponseRedirect","from django.template import RequestContext","from django.core.urlresolvers import reverse","from django.contrib.auth.decorators import login_required","from django.utils.decorators import method_decorator","from django.views.generic import View","from webdnd.shared.views import LoginRequiredMixin"]},{"diff":"\n def display_sheet(request, character_name):\n     return render_to_response('character_sheet.html', {'character_name': character_name}, context_instance=RequestContext(request))\n \n-def login(request):\n-    return render_to_response('account\/login.html', {}, context_instance=RequestContext(request))\n+def settings(request):\n+    pass\n+\n+def logout(request):\n+    pass\n+\n+\n+class AccountHomeView(View, LoginRequiredMixin):\n+\n+    def get(self, request):\n+        return render_to_response(\n+            'account\/home.html',\n+            {},\n+            context_instance=RequestContext(request)\n+        )\n+\n+class LoginView(View):\n+\n+    def get(self, request):\n+        out = {\n+            'username': request.GET.get('username', ''),\n+            'password': '',\n+            # TODO: this does nothing right now, and isnt saved\n+            'remember': request.GET.get('remember', ''),\n+            'error': request.GET.get('error', False),\n+        }\n+\n+        return render_to_response(\n+            'account\/login.html',\n+            out,\n+            context_instance=RequestContext(request)\n+        )\n+\n+    def post(self, request):\n+        username = request.POST.get('username', '')\n+        password = request.POST.get('password', '')\n+        user = authenticate(username=username, password=password)\n+        if user is not None:\n+            if user.is_active:\n+                login(request, user)\n+                url = reverse('account_home')\n+            else:\n+                # Add a page for disabled\/banned users\n+                url = '%s?username=%s&error=1' % (reverse('account_login'), username)\n+        else:\n+            # Validation failed\n+            url = '%s?username=%s&error=1' % (reverse('account_login'), username)\n+\n+        return HttpResponseRedirect(url)\n+\n+\n+        \n","add":52,"remove":2,"filename":"\/player\/views.py","badparts":["def login(request):","    return render_to_response('account\/login.html', {}, context_instance=RequestContext(request))"],"goodparts":["def settings(request):","    pass","def logout(request):","    pass","class AccountHomeView(View, LoginRequiredMixin):","    def get(self, request):","        return render_to_response(","            'account\/home.html',","            {},","            context_instance=RequestContext(request)","        )","class LoginView(View):","    def get(self, request):","        out = {","            'username': request.GET.get('username', ''),","            'password': '',","            'remember': request.GET.get('remember', ''),","            'error': request.GET.get('error', False),","        }","        return render_to_response(","            'account\/login.html',","            out,","            context_instance=RequestContext(request)","        )","    def post(self, request):","        username = request.POST.get('username', '')","        password = request.POST.get('password', '')","        user = authenticate(username=username, password=password)","        if user is not None:","            if user.is_active:","                login(request, user)","                url = reverse('account_home')","            else:","                url = '%s?username=%s&error=1' % (reverse('account_login'), username)","        else:","            url = '%s?username=%s&error=1' % (reverse('account_login'), username)","        return HttpResponseRedirect(url)"]}],"source":"\nfrom django.http import HttpResponse from django.template.loader import get_template from django.template import Context, RequestContext from django.shortcuts import render_to_response def homepage(request): return render_to_response('game_main.html',{}, context_instance=RequestContext(request)) def display_sheet(request, character_name): return render_to_response('character_sheet.html',{'character_name': character_name}, context_instance=RequestContext(request)) def login(request): return render_to_response('account\/login.html',{}, context_instance=RequestContext(request)) ","sourceWithComments":"from django.http import HttpResponse\nfrom django.template.loader import get_template\nfrom django.template import Context, RequestContext\nfrom django.shortcuts import render_to_response\n\ndef homepage(request):\n    return render_to_response('game_main.html', {}, context_instance=RequestContext(request))\n\ndef display_sheet(request, character_name):\n    return render_to_response('character_sheet.html', {'character_name': character_name}, context_instance=RequestContext(request))\n\ndef login(request):\n    return render_to_response('account\/login.html', {}, context_instance=RequestContext(request))\n\n"},"\/settings.py":{"changes":[{"diff":"\n \n # How long cookies will last\n SESSION_COOKIE_AGE = 60 * 60 * 24\n-SESSION_ENGINE = 'django.contrib.sessions.backends.cache'\n SESSION_COOKIE_NAME = 'webdndID'\n-SESSION_COOKIE_SECURE = True\n-SESSION_EXPIRE_AT_BROWSER_CLOSE = True\n+SESSION_EXPIRE_AT_BROWSER_CLOSE = False\n \n # Default url to redirect to for login\n LOGIN_URL = '\/account\/logi","add":1,"remove":3,"filename":"\/settings.py","badparts":["SESSION_ENGINE = 'django.contrib.sessions.backends.cache'","SESSION_COOKIE_SECURE = True","SESSION_EXPIRE_AT_BROWSER_CLOSE = True"],"goodparts":["SESSION_EXPIRE_AT_BROWSER_CLOSE = False"]}],"source":"\n\nimport os.path TEST_RUNNER=\"tests.runner.DiscoveryRunner\" BASE_PATH=os.path.dirname(__file__) TEST_DISCOVERY_ROOT=os.path.join(BASE_PATH, \"tests\") TEST_FILE_PATTERN='*_test.py' DEV_MODE=True DEBUG=True TEMPLATE_DEBUG=DEBUG COMPRESS_ENABLED=not DEBUG ROOT_URLCONF='webdnd.urls' INSTALLED_APPS=( 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.sites', 'django.contrib.messages', 'django.contrib.admin', 'compressor', 'django.contrib.staticfiles', ) DATABASES={ 'default':{ 'ENGINE': 'django.db.backends.sqlite3', 'NAME': '\/apps\/webdnd\/default.sqlite3', 'USER': '', 'PASSWORD': '', 'HOST': '', 'PORT': '', }, } TEMPLATE_DIRS=( '\/apps\/webdnd\/shared\/templates', ) MEDIA_ROOT='\/apps\/webdnd\/media\/' MEDIA_URL='\/media\/' STATIC_ROOT='\/apps\/webdnd\/static\/' STATIC_URL='\/static\/' STATICFILES_DIRS=( ('shared', '\/apps\/webdnd\/shared\/static\/'), ) STATICFILES_FINDERS=( 'django.contrib.staticfiles.finders.FileSystemFinder', 'django.contrib.staticfiles.finders.AppDirectoriesFinder', 'django.contrib.staticfiles.finders.DefaultStorageFinder', 'compressor.finders.CompressorFinder', ) COMPRESS_PARSER='compressor.parser.BeautifulSoupParser' COMPRESS_ROOT='\/apps\/webdnd\/static' COMPRESS_OUTPUT_DIR='\/compressed' COMPRESS_PRECOMPILERS=( ('text\/less', 'lessc{infile}{outfile}'), ) TEMPLATE_LOADERS=( 'django.template.loaders.filesystem.Loader', 'django.template.loaders.app_directories.Loader', ) SESSION_COOKIE_AGE=60 * 60 * 24 SESSION_ENGINE='django.contrib.sessions.backends.cache' SESSION_COOKIE_NAME='webdndID' SESSION_COOKIE_SECURE=True SESSION_EXPIRE_AT_BROWSER_CLOSE=True LOGIN_URL='\/account\/login' LOGIN_REDIRECT_URL='\/' ADMINS=( ) MANAGERS=ADMINS SERVER_EMAIL='' TIME_ZONE='Canada\/Eastern' LANGUAGE_CODE='en-ca' LANGUAGE_COOKIE_NAME='webdnd-language' SITE_ID=1 USE_I18N=True USE_L10N=True SECRET_KEY='1t2h3i4s5i6s7a8v9e0rysecretkeybecauseitisv0e9r8y7s6e5c4r3e2t1' MIDDLEWARE_CLASSES=( 'django.middleware.common.CommonMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', ) ","sourceWithComments":"# Django settings for webdnd project.\nimport os.path\n\n\n########################################\n# Testing\n########################################\n\nTEST_RUNNER = \"tests.runner.DiscoveryRunner\"\n\n# location of the tests folder\nBASE_PATH = os.path.dirname(__file__)\nTEST_DISCOVERY_ROOT = os.path.join(BASE_PATH, \"tests\")\n\n# Regexp pattern to match when looking for test files\n# The runner will look in these files for TestCase classes\nTEST_FILE_PATTERN = '*_test.py'\n\nDEV_MODE = True\nDEBUG = True\nTEMPLATE_DEBUG = DEBUG\nCOMPRESS_ENABLED = not DEBUG\n\n\n\n##################################################\n# App settings\n##################################################\n\nROOT_URLCONF = 'webdnd.urls'\n\nINSTALLED_APPS = (\n    # User login and authentication\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n\n    'django.contrib.sites',\n    'django.contrib.messages',\n\n    # Django Admin\n    'django.contrib.admin',\n    # 'django.contrib.admindocs',\n\n    # Webdnd apps\n    # 'webdnd.player',\n    # 'webdnd.dnd',\n\n    # Compression for static files\n    'compressor',\n    'django.contrib.staticfiles',\n)\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': '\/apps\/webdnd\/default.sqlite3',\n        'USER': '',\n        'PASSWORD': '',\n        'HOST': '',\n        'PORT': '',\n    },\n}\n\n# TODO: Prehaps we should get a cache?\n\n\n##################################################\n# Media and Static files\n##################################################\n\n# Locations of the template files\nTEMPLATE_DIRS = (\n    '\/apps\/webdnd\/shared\/templates',\n)\n\n# Absolute path to the directory that holds media.\nMEDIA_ROOT = '\/apps\/webdnd\/media\/'\n# URL that handles the media served from MEDIA_ROOT. Make sure to use a\nMEDIA_URL = '\/media\/'\n\n# Absolute path to the directory that holds static files.\nSTATIC_ROOT = '\/apps\/webdnd\/static\/'\n# URL that handles the static files served from STATIC_ROOT.\nSTATIC_URL = '\/static\/'\n# A list of locations of additional static files\nSTATICFILES_DIRS = (\n    ('shared', '\/apps\/webdnd\/shared\/static\/'),\n)\n\n# List of finder classes that know how to find static files in\n# various locations.\nSTATICFILES_FINDERS = (\n    'django.contrib.staticfiles.finders.FileSystemFinder',\n    'django.contrib.staticfiles.finders.AppDirectoriesFinder',\n    'django.contrib.staticfiles.finders.DefaultStorageFinder',\n    'compressor.finders.CompressorFinder',\n)\n\n# Parse to use for static file compression\nCOMPRESS_PARSER = 'compressor.parser.BeautifulSoupParser'\n# Location of the static files\nCOMPRESS_ROOT = '\/apps\/webdnd\/static'\nCOMPRESS_OUTPUT_DIR = '\/compressed'\n# COMPRESS_JS_FILTERS = ('compressor.filters.yui.YUIJSFilter',)\n# COMPRESS_CSS_FILTERS = ('compressor.filters.yui.YUICSSFilter',)\nCOMPRESS_PRECOMPILERS = (\n    # ('text\/coffeescript', 'coffee --compile --stdio'),\n    ('text\/less', 'lessc {infile} {outfile}'),\n    # ('text\/x-sass', 'sass {infile} {outfile}'),\n    # ('text\/x-scss', 'sass --scss {infile} {outfile}'),\n    # ('text\/foobar', 'path.to.MyPrecompilerFilter'),\n)\n\n# List of callables that know how to import templates from various sources.\nTEMPLATE_LOADERS = (\n    'django.template.loaders.filesystem.Loader',\n    'django.template.loaders.app_directories.Loader',\n    # 'django.template.loaders.eggs.Loader',\n)\n\n\n\n##################################################\n# Login\n##################################################\n\n# How long cookies will last\nSESSION_COOKIE_AGE = 60 * 60 * 24\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'\nSESSION_COOKIE_NAME = 'webdndID'\nSESSION_COOKIE_SECURE = True\nSESSION_EXPIRE_AT_BROWSER_CLOSE = True\n\n# Default url to redirect to for login\nLOGIN_URL = '\/account\/login'\nLOGIN_REDIRECT_URL = '\/'\n\n\n\n##################################################\n# Contact info and TZ\n##################################################\n\n# Site breakdowns\nADMINS = (\n    # ('Dmitry Blotsky', 'dmitry.blotsky@gmail.com'),\n)\n# Broken links\nMANAGERS = ADMINS\n# email server emails are sent from\nSERVER_EMAIL = ''\n\n# Local time zone for this installation. Choices can be found here:\n# http:\/\/en.wikipedia.org\/wiki\/List_of_tz_zones_by_name\n# although not all choices may be available on all operating systems.\n# On Unix systems, a value of None will cause Django to use the same\n# timezone as the operating system.\n# If running in a Windows environment this must be set to the same as your\n# system time zone.\nTIME_ZONE = 'Canada\/Eastern'\n\n# Language code for this installation. All choices can be found here:\n# http:\/\/www.i18nguy.com\/unicode\/language-identifiers.html\nLANGUAGE_CODE = 'en-ca'\nLANGUAGE_COOKIE_NAME = 'webdnd-language'\n\n\n\n##################################################\n# Misc\n##################################################\n\nSITE_ID = 1\n\n# If you set this to False, Django will make some optimizations so as not\n# to load the internationalization machinery.\nUSE_I18N = True\n\n# If you set this to False, Django will not format dates, numbers and\n# calendars according to the current locale\nUSE_L10N = True\n\n# Make this unique, and don't share it with anybody.\nSECRET_KEY = '1t2h3i4s5i6s7a8v9e0rysecretkeybecauseitisv0e9r8y7s6e5c4r3e2t1'\n\n\n\nMIDDLEWARE_CLASSES = (\n    'django.middleware.common.CommonMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n)\n\n\n"}},"msg":"Login and View formatting.\n * Fixed up sessions, there is a problem with using secure session (check it out later)\n * Turned views into class based views, added login_required mixin\n * Hijacked bootstrap alert to be able to dismiss dismissible alerts by clicking anywhere in them"}}}