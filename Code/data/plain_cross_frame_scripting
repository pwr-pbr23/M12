{"https:\/\/github.com\/pculture\/miro":{"97d7a92ed0cfa7d01a2bcd73ffd1cc346a6c9fa1":{"url":"https:\/\/api.github.com\/repos\/pculture\/miro\/commits\/97d7a92ed0cfa7d01a2bcd73ffd1cc346a6c9fa1","html_url":"https:\/\/github.com\/pculture\/miro\/commit\/97d7a92ed0cfa7d01a2bcd73ffd1cc346a6c9fa1","message":"- When a HTMLDisplay is created without a baseURL on OS X, now forcing a \"dummy\" one to avoid cross-frame scripting errors (fixes #9423).\n- Added an undocumented delegate method of WebView allowing to log (and therefore debug) javascript runtime errors.\n- Minor layout change of the guide-loading frameset.\n\n\ngit-svn-id: https:\/\/svn.participatoryculture.org\/svn\/dtv\/trunk@6510 bce20531-a64c-4166-8316-56baf4a01729\n\nOriginal sha1: a3a71d8a28eaf44016caab736f3adca048bf0c25","sha":"97d7a92ed0cfa7d01a2bcd73ffd1cc346a6c9fa1","keyword":"cross frame scripting fix","diff":"diff --git a\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py b\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py\nindex eb6a57fca8..68184ce65e 100644\n--- a\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py\n+++ b\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py\n@@ -257,8 +257,9 @@ def initWebView(self, initialHTML, sizeHint, baseURL):\n \n         html = NSString.stringWithString_(unicode(initialHTML))\n         data = html.dataUsingEncoding_(NSUTF8StringEncoding)\n-        if baseURL is not None:\n-            baseURL = NSURL.URLWithString_(unicode(baseURL))\n+        if baseURL is None:\n+            baseURL = os.path.join(NSBundle.mainBundle().resourcePath(), \"resources\")\n+        baseURL = NSURL.URLWithString_(unicode(baseURL))\n \n         self.view.mainFrame().loadData_MIMEType_textEncodingName_baseURL_(data, u'text\/html', u'utf-8', baseURL)        \n \n@@ -392,6 +393,9 @@ def openPanelDidEnd_returnCode_contextInfo_(self, panel, result, contextID):\n             filenames = panel.filenames()\n             listener.chooseFilename_(filenames[0])\n \n+    def webView_addMessageToConsole_(self, webview, message):\n+        logging.jsalert(message)\n+\n     def webView_runJavaScriptAlertPanelWithMessage_(self, webview, message):\n         logging.jsalert(message)\n \ndiff --git a\/tv\/resources\/templates\/guide-loading b\/tv\/resources\/templates\/guide-loading\nindex 439476c4e5..ae8630bd1b 100644\n--- a\/tv\/resources\/templates\/guide-loading\n+++ b\/tv\/resources\/templates\/guide-loading\n@@ -13,7 +13,7 @@ guide = views.guides.getObjectByID(int(kargs['id']))\n <link rel=\"stylesheet\" type=\"text\/css\" href=\"resource:css\/sidebar.css\" \/>\n <t:include filename=\"guide-loading.js\" \/>\n <\/head>\n-<frameset rows=\"25, *\" border=\"0\" frameborder=\"0\" framespacing=\"0\" >\n+<frameset rows=\"26, *\" border=\"0\" frameborder=\"0\" framespacing=\"0\" >\n     <frame onload=\"navBarLoaded()\" name=\"miro_navigation_frame\" src=\"resource:html\/guide-navigation.html\" frameborder=\"0\" noresize=\"noresize\" marginheight=\"0\" scrolling=\"no\" marginwidth=\"0\"\/>\n     <frame onload=\"guideLoaded()\" name=\"miro_guide_frame\" frameborder=\"0\" marginheight=\"0\" marginwidth=\"0\"\/>\n <\/frameset>\ndiff --git a\/tv\/resources\/templates\/guide-loading.js b\/tv\/resources\/templates\/guide-loading.js\nindex 8ad77f6484..4366867c52 100644\n--- a\/tv\/resources\/templates\/guide-loading.js\n+++ b\/tv\/resources\/templates\/guide-loading.js\n@@ -22,7 +22,11 @@\n         }\n         catch (e) {}\n         \n-        miro_navigation_frame.document.getElementById('load-indicator').style.display = 'none';\n+        var loadIndicator = miro_navigation_frame.document.getElementById('load-indicator');\n+        if (loadIndicator !== null)\n+        {\n+            loadIndicator.style.display = 'none';\n+        }\n     }\n \n     function guideUnloaded() \n@@ -34,6 +38,7 @@\n         }\n         catch (e) {}\n         \n-        miro_navigation_frame.document.getElementById('load-indicator').style.display = 'block';    \n+        miro_navigation_frame.document.getElementById('load-indicator').style.display = 'block';\n     }\n <\/script>\n+\n","files":{"\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py":{"changes":[{"diff":"\n \n         html = NSString.stringWithString_(unicode(initialHTML))\n         data = html.dataUsingEncoding_(NSUTF8StringEncoding)\n-        if baseURL is not None:\n-            baseURL = NSURL.URLWithString_(unicode(baseURL))\n+        if baseURL is None:\n+            baseURL = os.path.join(NSBundle.mainBundle().resourcePath(), \"resources\")\n+        baseURL = NSURL.URLWithString_(unicode(baseURL))\n \n         self.view.mainFrame().loadData_MIMEType_textEncodingName_baseURL_(data, u'text\/html', u'utf-8', baseURL)        \n \n","add":3,"remove":2,"filename":"\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py","badparts":["        if baseURL is not None:","            baseURL = NSURL.URLWithString_(unicode(baseURL))"],"goodparts":["        if baseURL is None:","            baseURL = os.path.join(NSBundle.mainBundle().resourcePath(), \"resources\")","        baseURL = NSURL.URLWithString_(unicode(baseURL))"]}],"source":"\n import os import re import urllib import logging from objc import YES, NO, nil from AppKit import * from WebKit import * from Foundation import * from PyObjCTools import AppHelper from miro import config from miro import prefs from miro.frontends.html import templatehelper from miro.frontends.html import keyboard from miro.frontends.html.displaybase import Display from miro.platform import resources from miro.platform.frontends.html.MainFrame import mapKey, handleKey from miro.platform.frontends.html import threads def getDTVAPICookie(): return None def getDTVAPIURL(): return None class HTMLDisplay(Display): \"HTML browser that can be shown in a MainFrame's right-hand pane.\" def __init__(self, html, existingView=None, frameHint=None, areaHint=None, baseURL=None): \"\"\"'html' is the initial contents of the display, as a string. If frameHint is provided, it is used to guess the initial size the HTML display will be rendered at, which might reduce flicker when the display is installed.\"\"\" self.readyToDisplayHook=None self.readyToDisplay=False self.html=html self.baseURL=baseURL if frameHint and areaHint: self.displaySizeHint=frameHint.getDisplaySizeHint(areaHint) else: self.displaySizeHint=None Display.__init__(self) def get_web(self): try: return self._web except AttributeError: self._web=ManagedWebView.alloc().initWithInitialHTML_existinView_loadFinished_loadURL_sizeHint_baseURL_( self.html, None, self.nowReadyToDisplay, lambda x:self.onURLLoad(unicode(x)), self.displaySizeHint, self.baseURL) return self._web web=property(get_web) def getEventCookie(self): return '' def getDTVPlatformName(self): return 'webkit' def getBodyTagExtra(self): return 'ondragstart=\"handleDragStart(event);\" ondragover=\"return handleDragOver(event);\" ondragleave=\"return handleDragLeave(event);\" ondrop=\"return handleDrop(event);\" ' def getView(self): return self.web.getView() def execJS(self, js): \"\"\"Execute the given Javascript code(provided as a string) in the context of this HTML document.\"\"\" try: self.web.execJS(js) except AttributeError: print \"Couldn't exec javascript! Web view not initialized\" def navigateToFragment(self, fragment): self.web.navigateToFragment(fragment) def addItemAtEnd(self, xml, id): return self.web.addItemAtEnd(xml, id) def addItemBefore(self, xml, id): return self.web.addItemBefore(xml, id) def removeItem(self, id): return self.web.removeItem(id) def removeItems(self, ids): return self.web.removeItems(ids) def changeItem(self, id, xml, changeHint): return self.web.changeItem(id, xml, changeHint) def changeItems(self, args): newArgs=[] for id, xml, changeHint in args: newArgs.append((id, xml, changeHint)) return self.web.changeItems(newArgs) def hideItem(self, id): return self.web.hideItem(id) def showItem(self, id): return self.web.showItem(id) def onURLLoad(self, url): \"\"\"Called when this HTML browser attempts to load a URL(either through user action or Javascript.) The URL is provided as a string. Return true to allow the URL to load, or false to cancel the load(for example, because it was a magic URL that marks an item to be downloaded.) Implementation in HTMLDisplay always returns true; override in a subclass to implement special behavior.\"\"\" pass def callWhenReadyToDisplay(self, hook): self.get_web() if self.readyToDisplay: hook() else: assert self.readyToDisplayHook==None self.readyToDisplayHook=hook def nowReadyToDisplay(self): self.readyToDisplay=True if self.readyToDisplayHook: hook=self.readyToDisplayHook self.readyToDisplayHook=None hook() def unlink(self): webView=self.web.getView() if webView is not nil: threads.warnIfNotOnMainThread('HTMLDisplay.unlink') webView.setHostWindow_(self.currentFrame.obj.window()) @threads.onMainThreadWaitingUntilDone def cancel(self): logging.debug(\"DTV: Canceling load of WebView %s\" % self.web.getView()) self.web.getView().stopLoading_(nil) self.readyToDisplay=False self.readyToDisplayHook=None class ManagedWebHTMLView(WebHTMLView): def keyDown_(self, event): key=mapKey(event) if key in(keyboard.UP, keyboard.DOWN): handleKey(event) else: super(ManagedWebHTMLView, self).keyDown_(event) def rightMouseDown_(self, event): threads.callOnMainThread(self.mouseDown_, event) threads.callOnMainThreadAfterDelay(0.2, WebHTMLView.rightMouseDown_, self, event) class JSOpened(NSObject): def webView_willPerformClientRedirectToURL_delay_fireDate_forFrame_(self, webView, url, delay, fireDate, frame): webView.stopLoading_(nil) NSWorkspace.sharedWorkspace().openURL_(url) jsOpened=JSOpened.alloc().init() class ManagedWebView(NSObject): WebView.registerViewClass_representationClass_forMIMEType_(ManagedWebHTMLView, WebHTMLRepresentation, u'text\/html') def initWithInitialHTML_existinView_loadFinished_loadURL_sizeHint_baseURL_( self, initialHTML, existingView=nil, onInitialLoadFinished=None, onLoadURL=None, sizeHint=None, baseURL=None): self.onInitialLoadFinished=onInitialLoadFinished self.onLoadURL=onLoadURL self.initialLoadFinished=False self.view=existingView self.openPanelContextID=1 self.openPanelContext=dict() threads.callOnMainThreadAndWaitUntilDone(self.initWebView, initialHTML, sizeHint, baseURL) return self def initWebView(self, initialHTML, sizeHint, baseURL): threads.warnIfNotOnMainThread('ManagedWebView.initWebView') if not self.view: self.view=WebView.alloc().init() if sizeHint: self.view.setFrame_(sizeHint) self.view.setCustomUserAgent_(u\"%s\/%s(%s)\" % \\ (config.get(prefs.SHORT_APP_NAME), config.get(prefs.APP_VERSION), config.get(prefs.PROJECT_URL),)) else: if sizeHint: self.view.setFrame_(sizeHint) self.execQueue=[] self.view.setPolicyDelegate_(self) self.view.setResourceLoadDelegate_(self) self.view.setFrameLoadDelegate_(self) self.view.setUIDelegate_(self) html=NSString.stringWithString_(unicode(initialHTML)) data=html.dataUsingEncoding_(NSUTF8StringEncoding) if baseURL is not None: baseURL=NSURL.URLWithString_(unicode(baseURL)) self.view.mainFrame().loadData_MIMEType_textEncodingName_baseURL_(data, u'text\/html', u'utf-8', baseURL) def isKeyExcludedFromWebScript_(self,key): return YES def isSelectorExcludedFromWebScript_(self, sel): return(str(sel) !='eventURL') def eventURL(self,url): self.onLoadURL(url) def webView_contextMenuItemsForElement_defaultMenuItems_(self,webView,contextMenu,defaultMenuItems): event=NSApp().currentEvent() if event.type()==NSLeftMouseDown and(event.modifierFlags() & NSControlKeyMask): fake=NSEvent.mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure_( NSRightMouseDown, event.locationInWindow(), 0, 0, event.windowNumber(), nil, 0, 1, 0) NSApp().postEvent_atStart_(fake, YES) return nil def webView_didFinishLoadForFrame_(self, webview, frame): if(not self.initialLoadFinished) and(frame is self.view.mainFrame()): threads.warnIfNotOnMainThread('ManagedWebView.webView_didFinishLoadForFrame_') self.initialLoadFinished=True for func in self.execQueue: func() self.execQueue=[] if self.onInitialLoadFinished: self.onInitialLoadFinished() scriptObj=self.view.windowScriptObject() scriptObj.setValue_forKey_(self, u'frontend') def webView_didFailProvisionalLoadWithError_forFrame_(self, webview, error, frame): urlError=(error.domain()==NSURLErrorDomain) certError=(error.code() in(NSURLErrorServerCertificateHasBadDate, NSURLErrorServerCertificateHasUnknownRoot, NSURLErrorServerCertificateUntrusted)) if urlError and certError: request=frame.provisionalDataSource().request() if request is nil: request=frame.dataSource().request() url=request.URL() allowed=[config.get(prefs.CHANNEL_GUIDE_URL), config.get(prefs.CHANNEL_GUIDE_FIRST_TIME_URL)] if url.absoluteString() in allowed: NSURLRequest.setAllowsAnyHTTPSCertificate_forHost_(YES, url.host()) frame.loadRequest_(request) def webView_decidePolicyForNavigationAction_request_frame_decisionListener_(self, webview, action, request, frame, listener): threads.warnIfNotOnMainThread('ManagedWebView.webView_decidePolicyForNavigationAction_request_frame_decisionListener_') method=request.HTTPMethod() url=unicode(request.URL()) body=request.HTTPBody() ntype=action['WebActionNavigationTypeKey'] if ntype in(WebNavigationTypeLinkClicked, WebNavigationTypeFormSubmitted, WebNavigationTypeOther): if(not self.onLoadURL) or self.onLoadURL(url): listener.use() else: listener.ignore() else: listener.use() def webView_decidePolicyForNewWindowAction_request_newFrameName_decisionListener_(self, webView, info, request, name, listener): url=info[\"WebActionOriginalURLKey\"] NSWorkspace.sharedWorkspace().openURL_(url) listener.ignore() def webView_createWebViewWithRequest_(self, webView, request): global jsOpened webView=WebView.alloc().init() webView.setFrameLoadDelegate_(jsOpened) webView.mainFrame().loadRequest_(request) return webView def webView_resource_willSendRequest_redirectResponse_fromDataSource_(self, webview, resourceCookie, request, redirectResponse, dataSource): threads.warnIfNotOnMainThread('ManagedWebView.webView_resource_willSendRequest_redirectResponse_fromDataSource_') url=request.URL().absoluteString() match=templatehelper.resourcePattern.match(url) if match is not None: url=resources.url(match.group(1)) urlObject=NSURL.URLWithString_(url) return NSURLRequest.requestWithURL_cachePolicy_timeoutInterval_(urlObject, NSURLRequestReloadIgnoringCacheData, 60) if isinstance(request, NSMutableURLRequest): language=os.environ['LANGUAGE'].split(':')[0].replace('_', '-') request.setValue_forHTTPHeaderField_(language, u'Accept-Language') request.setValue_forHTTPHeaderField_(u'1', u'X-Miro') return request def webView_runOpenPanelForFileButtonWithResultListener_(self, webview, listener): self.openPanelContextID +=1 self.openPanelContext[self.openPanelContextID]=listener panel=NSOpenPanel.openPanel() panel.beginSheetForDirectory_file_types_modalForWindow_modalDelegate_didEndSelector_contextInfo_( NSHomeDirectory(), nil, nil, self.view.window(), self, 'openPanelDidEnd:returnCode:contextInfo:', self.openPanelContextID) @AppHelper.endSheetMethod def openPanelDidEnd_returnCode_contextInfo_(self, panel, result, contextID): listener=self.openPanelContext[contextID] del self.openPanelContext[contextID] if result==NSOKButton: filenames=panel.filenames() listener.chooseFilename_(filenames[0]) def webView_runJavaScriptAlertPanelWithMessage_(self, webview, message): logging.jsalert(message) def getView(self): return self.view def execAfterLoad(self, func): if not self.initialLoadFinished: self.execQueue.append(func) else: threads.callOnMainThreadAndWaitUntilDone(func) def deferUntilAfterLoad(func): def runFunc(*args, **kwargs): func(*args, **kwargs) def schedFunc(self, *args, **kwargs): rf=lambda: runFunc(self, *args, **kwargs) self.execAfterLoad(rf) return schedFunc @deferUntilAfterLoad def execJS(self, js): self.view.stringByEvaluatingJavaScriptFromString_(js) def navigateToFragment(self, fragment): command=\"var tab=document.getElementById(\\\"%s\\\"); tab.scrollIntoView(true);\" % fragment self.execJS(command) def findElt(self, id): doc=self.view.mainFrame().DOMDocument() elt=doc.getElementById_(unicode(id)) return elt def createElts(self, xml): parent=self.view.mainFrame().DOMDocument().createElement_(u\"div\") if len(xml)==0: parent.setInnerHTML_(\"&nbsp;\") else: parent.setInnerHTML_(xml) eltlist=[] for child in range(parent.childNodes().length()): eltlist.append(parent.childNodes().item_(child)) return eltlist @deferUntilAfterLoad def addItemAtEnd(self, xml, id): elt=self.findElt(id) if not elt: print \"warning: addItemAtEnd: missing element %s\" % id else: newElts=self.createElts(xml) for newElt in newElts: elt.insertBefore__(newElt, None) @deferUntilAfterLoad def addItemBefore(self, xml, id): elt=self.findElt(id) if not elt: print \"warning: addItemBefore: missing element %s\" % id else: newElts=self.createElts(xml) for newElt in newElts: elt.parentNode().insertBefore__(newElt, elt) @deferUntilAfterLoad def removeItem(self, id): self._removeElement(id) @deferUntilAfterLoad def removeItems(self, ids): for id in ids: self._removeElement(id) def _removeElement(self, id): elt=self.findElt(id) if not elt: print \"warning: removeItem: missing element %s\" % id else: elt.parentNode().removeChild_(elt) @deferUntilAfterLoad def changeItem(self, id, xml, changeHint): self._changeElement(id, xml, changeHint) @deferUntilAfterLoad def changeItems(self, args): for id, xml, changeHint in args: self._changeElement(id, xml, changeHint) def _changeElement(self, id, xml, changeHint): elt=self.findElt(id) if not elt: print \"warning: changeItem: missing element %s\" % id else: elt.setOuterHTML_(xml) @deferUntilAfterLoad def hideItem(self, id): elt=self.findElt(id) if not elt: print \"warning: hideItem: missing element %s\" % id else: elt.setAttribute__(\"style\", \"display:none\") @deferUntilAfterLoad def showItem(self, id): elt=self.findElt(id) if not elt: print \"warning: showItem: missing element %s\" % id else: elt.setAttribute__(\"style\", \"\") ","sourceWithComments":"# Miro - an RSS based video player application\n# Copyright (C) 2005-2008 Participatory Culture Foundation\n#\n# This program is free software; you can redistribute it and\/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n#\n# In addition, as a special exception, the copyright holders give\n# permission to link the code of portions of this program with the OpenSSL\n# library.\n#\n# You must obey the GNU General Public License in all respects for all of\n# the code used other than OpenSSL. If you modify file(s) with this\n# exception, you may extend this exception to your version of the file(s),\n# but you are not obligated to do so. If you do not wish to do so, delete\n# this exception statement from your version. If you delete this exception\n# statement from all source files in the program, then also delete it here.\n\nimport os\nimport re\nimport urllib\nimport logging\n\nfrom objc import YES, NO, nil\nfrom AppKit import *\nfrom WebKit import *\nfrom Foundation import *\nfrom PyObjCTools import AppHelper\n\nfrom miro import config\nfrom miro import prefs\nfrom miro.frontends.html import templatehelper\nfrom miro.frontends.html import keyboard\nfrom miro.frontends.html.displaybase import Display\nfrom miro.platform import resources\nfrom miro.platform.frontends.html.MainFrame import mapKey, handleKey\nfrom miro.platform.frontends.html import threads\n\n###############################################################################\n# These are used by the channel guide. This platform uses the\n# old-style 'magic URL' guide API, so we just return None. See\n# ChannelGuideToDtvApi in the Trac wiki for the full writeup.\n###############################################################################\n\ndef getDTVAPICookie():\n    return None\n\ndef getDTVAPIURL():\n    return None\n\n###############################################################################\n\nclass HTMLDisplay (Display):\n    \"HTML browser that can be shown in a MainFrame's right-hand pane.\"\n\n    # We don't need to override onSelected, onDeselected\n\n    def __init__(self, html, existingView=None, frameHint=None, areaHint=None, baseURL=None):\n        \"\"\"'html' is the initial contents of the display, as a string. If\n        frameHint is provided, it is used to guess the initial size the HTML\n        display will be rendered at, which might reduce flicker when the\n        display is installed.\"\"\"\n        self.readyToDisplayHook = None\n        self.readyToDisplay = False\n        self.html = html\n        self.baseURL = baseURL\n        if frameHint and areaHint:\n            self.displaySizeHint = frameHint.getDisplaySizeHint(areaHint)\n        else:\n            self.displaySizeHint = None\n        Display.__init__(self)\n \n    # make web a lazily loaded property.  This is useful for the channel\n    # guides because it makes the load happen after setGuideURL\n    def get_web(self):\n        try:\n            return self._web\n        except AttributeError:\n            self._web = ManagedWebView.alloc().initWithInitialHTML_existinView_loadFinished_loadURL_sizeHint_baseURL_(\n                            self.html, None, self.nowReadyToDisplay, lambda x:self.onURLLoad(unicode(x)), self.displaySizeHint, self.baseURL)\n            return self._web\n    web = property(get_web)\n\n    def getEventCookie(self):\n        return ''\n\n    def getDTVPlatformName(self):\n        return 'webkit'\n\n    def getBodyTagExtra(self):\n        return 'ondragstart=\"handleDragStart(event);\" ondragover=\"return handleDragOver(event);\" ondragleave=\"return handleDragLeave(event);\" ondrop=\"return handleDrop(event);\" '\n\n    def getView(self):\n        return self.web.getView()\n\n    def execJS(self, js):\n        \"\"\"Execute the given Javascript code (provided as a string) in the\n        context of this HTML document.\"\"\"\n        try:\n            self.web.execJS(js)\n        except AttributeError:\n            print \"Couldn't exec javascript! Web view not initialized\"\n        #print \"DISP: %s with %s\" % (self.view, js)\n\n    def navigateToFragment(self, fragment):\n        self.web.navigateToFragment(fragment)\n\n    # DOM hooks used by the dynamic template code -- do they need a \n    # try..except wrapper like the above?\n    def addItemAtEnd(self, xml, id):\n        return self.web.addItemAtEnd(xml, id)\n\n    def addItemBefore(self, xml, id):\n        return self.web.addItemBefore(xml, id)\n\n    def removeItem(self, id):\n        return self.web.removeItem(id)\n\n    def removeItems(self, ids):\n        return self.web.removeItems(ids)\n\n    def changeItem(self, id, xml, changeHint):\n        return self.web.changeItem(id, xml, changeHint)\n\n    def changeItems(self, args):\n        newArgs = []\n        for id, xml, changeHint in args:\n            newArgs.append((id, xml, changeHint))\n        return self.web.changeItems(newArgs)\n\n    def hideItem(self, id):\n        return self.web.hideItem(id)\n\n    def showItem(self, id):\n        return self.web.showItem(id)\n\n    def onURLLoad(self, url):\n        \"\"\"Called when this HTML browser attempts to load a URL (either\n        through user action or Javascript.) The URL is provided as a\n        string. Return true to allow the URL to load, or false to cancel\n        the load (for example, because it was a magic URL that marks\n        an item to be downloaded.) Implementation in HTMLDisplay always\n        returns true; override in a subclass to implement special\n        behavior.\"\"\"\n        # For overriding\n        pass\n\n    def callWhenReadyToDisplay(self, hook):\n        self.get_web() # make sure our ManagedWebView is loaded\n        if self.readyToDisplay:\n            hook()\n        else:\n            assert self.readyToDisplayHook == None\n            self.readyToDisplayHook = hook\n\n    # Called (via callback established in constructor)\n    def nowReadyToDisplay(self):\n        self.readyToDisplay = True\n        if self.readyToDisplayHook:\n            hook = self.readyToDisplayHook\n            self.readyToDisplayHook = None\n            hook()\n\n    def unlink(self):\n        webView = self.web.getView()\n        if webView is not nil:\n            threads.warnIfNotOnMainThread('HTMLDisplay.unlink')\n            webView.setHostWindow_(self.currentFrame.obj.window()) # not very pretty\n    \n    @threads.onMainThreadWaitingUntilDone\n    def cancel(self):\n        logging.debug(\"DTV: Canceling load of WebView %s\" % self.web.getView())\n        self.web.getView().stopLoading_(nil)\n        self.readyToDisplay = False\n        self.readyToDisplayHook = None\n\n###############################################################################\n\nclass ManagedWebHTMLView (WebHTMLView):\n\n    def keyDown_(self, event):\n        key = mapKey(event)\n        if key in (keyboard.UP, keyboard.DOWN):\n            handleKey(event)\n        else:\n            super(ManagedWebHTMLView, self).keyDown_(event)\n\n    def rightMouseDown_(self, event):\n        # We want a right click to also select what's underneath so we intercept\n        # the event here, force the left click handler first and reschedule the\n        # right click handler.\n        threads.callOnMainThread(self.mouseDown_, event)\n        threads.callOnMainThreadAfterDelay(0.2, WebHTMLView.rightMouseDown_, self, event)\n\n###############################################################################\n\nclass JSOpened (NSObject):\n    \n    def webView_willPerformClientRedirectToURL_delay_fireDate_forFrame_(self, webView, url, delay, fireDate, frame):\n        webView.stopLoading_(nil)\n        NSWorkspace.sharedWorkspace().openURL_(url)\n\njsOpened = JSOpened.alloc().init()\n\n###############################################################################\n\nclass ManagedWebView (NSObject):\n\n    WebView.registerViewClass_representationClass_forMIMEType_(ManagedWebHTMLView, WebHTMLRepresentation, u'text\/html')\n\n    def initWithInitialHTML_existinView_loadFinished_loadURL_sizeHint_baseURL_(\n        self, initialHTML, existingView=nil, onInitialLoadFinished=None, onLoadURL=None, sizeHint=None, baseURL=None):\n        self.onInitialLoadFinished = onInitialLoadFinished\n        self.onLoadURL = onLoadURL\n        self.initialLoadFinished = False\n        self.view = existingView\n        self.openPanelContextID = 1\n        self.openPanelContext = dict()\n        threads.callOnMainThreadAndWaitUntilDone(self.initWebView, initialHTML, sizeHint, baseURL)        \n        return self\n\n    def initWebView(self, initialHTML, sizeHint, baseURL):\n        threads.warnIfNotOnMainThread('ManagedWebView.initWebView')\n        if not self.view:\n            self.view = WebView.alloc().init()\n            #print \"***** Creating new WebView %s\" % self.view\n            if sizeHint:\n                # We have an estimate of the size that will be assigned to\n                # the view when it is actually inserted in the MainFrame.\n                # Use this to size the view we just created so the HTML\n                # is hopefully rendered to the correct dimensions, instead\n                # of having to be corrected after being displayed.\n                self.view.setFrame_(sizeHint)\n            self.view.setCustomUserAgent_(u\"%s\/%s (%s)\" % \\\n                                          (config.get(prefs.SHORT_APP_NAME),\n                                           config.get(prefs.APP_VERSION),\n                                           config.get(prefs.PROJECT_URL),))\n        else:\n            #print \"***** Using existing WebView %s\" % self.view\n            if sizeHint:\n                self.view.setFrame_(sizeHint)\n        self.execQueue = []\n        self.view.setPolicyDelegate_(self)\n        self.view.setResourceLoadDelegate_(self)\n        self.view.setFrameLoadDelegate_(self)\n        self.view.setUIDelegate_(self)\n\n        html = NSString.stringWithString_(unicode(initialHTML))\n        data = html.dataUsingEncoding_(NSUTF8StringEncoding)\n        if baseURL is not None:\n            baseURL = NSURL.URLWithString_(unicode(baseURL))\n\n        self.view.mainFrame().loadData_MIMEType_textEncodingName_baseURL_(data, u'text\/html', u'utf-8', baseURL)        \n\n    def isKeyExcludedFromWebScript_(self,key):\n        return YES\n\n    def isSelectorExcludedFromWebScript_(self, sel):\n        return (str(sel) != 'eventURL')\n\n    def eventURL(self,url):\n        self.onLoadURL(url)\n\n    def webView_contextMenuItemsForElement_defaultMenuItems_(self,webView,contextMenu,defaultMenuItems):\n        event = NSApp().currentEvent()\n        if event.type() == NSLeftMouseDown and (event.modifierFlags() & NSControlKeyMask):\n            fake = NSEvent.mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure_(\n                           NSRightMouseDown, event.locationInWindow(), 0, 0, event.windowNumber(), nil, 0, 1, 0)\n            NSApp().postEvent_atStart_(fake, YES)\n        return nil\n\n    # Generate callbacks when the initial HTML (passed in the constructor)\n    # has been loaded\n    def webView_didFinishLoadForFrame_(self, webview, frame):\n        if (not self.initialLoadFinished) and (frame is self.view.mainFrame()):\n            threads.warnIfNotOnMainThread('ManagedWebView.webView_didFinishLoadForFrame_')\n            # Execute any function calls we queued because the page load\n            # hadn't completed\n            self.initialLoadFinished = True\n            for func in self.execQueue:\n                func()\n            self.execQueue = []\n\n            if self.onInitialLoadFinished:\n                self.onInitialLoadFinished()\n\n            scriptObj = self.view.windowScriptObject()\n            scriptObj.setValue_forKey_(self, u'frontend')\n\n    def webView_didFailProvisionalLoadWithError_forFrame_(self, webview, error, frame):\n        urlError = (error.domain() == NSURLErrorDomain)\n        certError = (error.code() in (NSURLErrorServerCertificateHasBadDate, \n                                      NSURLErrorServerCertificateHasUnknownRoot, \n                                      NSURLErrorServerCertificateUntrusted))\n\n        if urlError and certError:\n            request = frame.provisionalDataSource().request()\n            if request is nil:\n                request = frame.dataSource().request()\n            url = request.URL()            \n            allowed = [config.get(prefs.CHANNEL_GUIDE_URL), \n                       config.get(prefs.CHANNEL_GUIDE_FIRST_TIME_URL)]\n            if url.absoluteString() in allowed:\n                # The [NSURLRequest setAllowsAnyHTTPSCertificate:forHost:] selector is\n                # not documented anywhere, so I assume it is not public. It is however \n                # a very clean and easy way to allow us to load our channel guide from\n                # https, so let's use it here anyway :)\n                NSURLRequest.setAllowsAnyHTTPSCertificate_forHost_(YES, url.host())\n                # Now reload\n                frame.loadRequest_(request)\n\n    # Intercept navigation actions and give program a chance to respond\n    def webView_decidePolicyForNavigationAction_request_frame_decisionListener_(self, webview, action, request, frame, listener):\n        threads.warnIfNotOnMainThread('ManagedWebView.webView_decidePolicyForNavigationAction_request_frame_decisionListener_')\n        method = request.HTTPMethod()\n        url = unicode(request.URL())\n        body = request.HTTPBody()\n        ntype = action['WebActionNavigationTypeKey']\n        #print \"policy %d for url %s\" % (ntype, url)\n        # setting document.location.href in Javascript (our preferred\n        # method of triggering an action) comes out as an\n        # WebNavigationTypeOther.\n        if ntype in (WebNavigationTypeLinkClicked, WebNavigationTypeFormSubmitted, WebNavigationTypeOther):\n            # Make sure we have a real, bona fide Python string, not an\n            # NSString. Unfortunately, == can tell the difference.\n            if (not self.onLoadURL) or self.onLoadURL(url):\n                listener.use()\n            else:\n                listener.ignore()\n        else:\n            listener.use()\n\n    # Intercept external links requests\n    def webView_decidePolicyForNewWindowAction_request_newFrameName_decisionListener_(self, webView, info, request, name, listener):\n        url = info[\"WebActionOriginalURLKey\"]\n        NSWorkspace.sharedWorkspace().openURL_(url)\n        listener.ignore()\n\n    def webView_createWebViewWithRequest_(self, webView, request):\n        global jsOpened\n        webView = WebView.alloc().init()\n        webView.setFrameLoadDelegate_(jsOpened)\n        webView.mainFrame().loadRequest_(request)\n        return webView\n\n    # Redirect resource: links to files in resource bundle\n    def webView_resource_willSendRequest_redirectResponse_fromDataSource_(self, webview, resourceCookie, request, redirectResponse, dataSource):\n        threads.warnIfNotOnMainThread('ManagedWebView.webView_resource_willSendRequest_redirectResponse_fromDataSource_')\n        url = request.URL().absoluteString()\n\n        match = templatehelper.resourcePattern.match(url)\n        if match is not None:\n            url = resources.url(match.group(1))\n            urlObject = NSURL.URLWithString_(url)\n            return NSURLRequest.requestWithURL_cachePolicy_timeoutInterval_(urlObject, NSURLRequestReloadIgnoringCacheData, 60)\n\n        if isinstance(request, NSMutableURLRequest):\n            language = os.environ['LANGUAGE'].split(':')[0].replace('_', '-')\n            request.setValue_forHTTPHeaderField_(language, u'Accept-Language')\n            request.setValue_forHTTPHeaderField_(u'1', u'X-Miro')\n        \n        return request\n\n    def webView_runOpenPanelForFileButtonWithResultListener_(self, webview, listener):\n        self.openPanelContextID += 1\n        self.openPanelContext[self.openPanelContextID] = listener\n        panel = NSOpenPanel.openPanel()\n        panel.beginSheetForDirectory_file_types_modalForWindow_modalDelegate_didEndSelector_contextInfo_(\n            NSHomeDirectory(),\n            nil,\n            nil,\n            self.view.window(),\n            self,\n            'openPanelDidEnd:returnCode:contextInfo:',\n            self.openPanelContextID)\n\n    @AppHelper.endSheetMethod\n    def openPanelDidEnd_returnCode_contextInfo_(self, panel, result, contextID):\n        listener = self.openPanelContext[contextID]\n        del self.openPanelContext[contextID]\n        if result == NSOKButton:\n            filenames = panel.filenames()\n            listener.chooseFilename_(filenames[0])\n\n    def webView_runJavaScriptAlertPanelWithMessage_(self, webview, message):\n        logging.jsalert(message)\n\n    # Return the actual WebView that we're managing\n    def getView(self):\n        return self.view\n\n    # Call func() once the document has finished loading. If the\n    # document has already finished loading, call it right away. But\n    # in either case, the call is executed on the main thread, by\n    # queueing an event, since WebViews are not documented to be\n    # thread-safe, and we have seen crashes.\n    def execAfterLoad(self, func):\n        if not self.initialLoadFinished:\n            self.execQueue.append(func)\n        else:\n            threads.callOnMainThreadAndWaitUntilDone(func)\n\n    # Decorator to make using execAfterLoad easier\n    def deferUntilAfterLoad(func):\n        def runFunc(*args, **kwargs):\n            func(*args, **kwargs)\n        def schedFunc(self, *args, **kwargs):\n            rf = lambda: runFunc(self, *args, **kwargs)\n            self.execAfterLoad(rf)\n        return schedFunc\n\n    # Execute given Javascript string in context of the HTML document\n    @deferUntilAfterLoad\n    def execJS(self, js):\n        self.view.stringByEvaluatingJavaScriptFromString_(js)\n\n    def navigateToFragment(self, fragment):\n        command = \"var tab = document.getElementById(\\\"%s\\\"); tab.scrollIntoView(true);\" % fragment\n        self.execJS(command)\n\n    ## DOM mutators called, ultimately, by dynamic template system ##\n\n    def findElt(self, id):\n        doc = self.view.mainFrame().DOMDocument()\n        elt = doc.getElementById_(unicode(id))\n        return elt\n\n    def createElts(self, xml):\n        parent = self.view.mainFrame().DOMDocument().createElement_(u\"div\")\n        if len(xml) == 0:\n            parent.setInnerHTML_(\"&nbsp;\")\n        else:\n            parent.setInnerHTML_(xml)\n        eltlist = []\n        for child in range(parent.childNodes().length()):\n            eltlist.append(parent.childNodes().item_(child))\n        return eltlist\n        \n    @deferUntilAfterLoad\n    def addItemAtEnd(self, xml, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: addItemAtEnd: missing element %s\" % id\n        else:\n            #print \"add item %s at end of %s\" % (elt.getAttribute_(\"id\"), id)\n            #print xml[0:79]\n            newElts = self.createElts(xml)\n            for newElt in newElts:\n                elt.insertBefore__(newElt, None)\n\n    @deferUntilAfterLoad\n    def addItemBefore(self, xml, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: addItemBefore: missing element %s\" % id\n        else:\n            newElts = self.createElts(xml)\n            for newElt in newElts:\n                #print \"add item %s before %s\" % (newelt.getAttribute_(\"id\"), id)\n                elt.parentNode().insertBefore__(newElt, elt)\n\n    @deferUntilAfterLoad\n    def removeItem(self, id):\n        self._removeElement(id)\n\n    @deferUntilAfterLoad\n    def removeItems(self, ids):\n        for id in ids:\n            self._removeElement(id)\n\n    def _removeElement(self, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: removeItem: missing element %s\" % id\n        else:\n            #print \"remove item %s\" % id\n            elt.parentNode().removeChild_(elt)\n\n    @deferUntilAfterLoad\n    def changeItem(self, id, xml, changeHint):\n        self._changeElement(id, xml, changeHint)\n\n    @deferUntilAfterLoad\n    def changeItems(self, args):\n        for id, xml, changeHint in args:\n            self._changeElement(id, xml, changeHint)\n\n    def _changeElement(self, id, xml, changeHint):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: changeItem: missing element %s\" % id\n        else:\n            #print \"change item %s (new id %s)\" % (id, elt.getAttribute_(\"id\"))\n            #print xml[0:79]\n            #if id != elt.getAttribute_(\"id\"):\n            #    raise Exception\n            #elt = self.findElt(id)\n            #if not elt:\n            #    print \"ERROR ELEMENT LOST %s\" % id\n            elt.setOuterHTML_(xml)\n\n    @deferUntilAfterLoad\n    def hideItem(self, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: hideItem: missing element %s\" % id\n        else:\n            #print \"hide item %s (new style '%s')\" % (id, elt.getAttribute_(\"style\"))\n            elt.setAttribute__(\"style\", \"display:none\")\n\n    @deferUntilAfterLoad\n    def showItem(self, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: showItem: missing element %s\" % id\n        else:\n            #print \"show item %s (new style '%s')\" % (id, elt.getAttribute_(\"style\"))\n            elt.setAttribute__(\"style\", \"\")\n\n###############################################################################\n"}},"msg":"- When a HTMLDisplay is created without a baseURL on OS X, now forcing a \"dummy\" one to avoid cross-frame scripting errors (fixes #9423).\n- Added an undocumented delegate method of WebView allowing to log (and therefore debug) javascript runtime errors.\n- Minor layout change of the guide-loading frameset.\n\n\ngit-svn-id: https:\/\/svn.participatoryculture.org\/svn\/dtv\/trunk@6510 bce20531-a64c-4166-8316-56baf4a01729\n\nOriginal sha1: a3a71d8a28eaf44016caab736f3adca048bf0c25"}},"https:\/\/github.com\/cool-RR\/Miro":{"97d7a92ed0cfa7d01a2bcd73ffd1cc346a6c9fa1":{"url":"https:\/\/api.github.com\/repos\/cool-RR\/Miro\/commits\/97d7a92ed0cfa7d01a2bcd73ffd1cc346a6c9fa1","html_url":"https:\/\/github.com\/cool-RR\/Miro\/commit\/97d7a92ed0cfa7d01a2bcd73ffd1cc346a6c9fa1","message":"- When a HTMLDisplay is created without a baseURL on OS X, now forcing a \"dummy\" one to avoid cross-frame scripting errors (fixes #9423).\n- Added an undocumented delegate method of WebView allowing to log (and therefore debug) javascript runtime errors.\n- Minor layout change of the guide-loading frameset.\n\n\ngit-svn-id: https:\/\/svn.participatoryculture.org\/svn\/dtv\/trunk@6510 bce20531-a64c-4166-8316-56baf4a01729\n\nOriginal sha1: a3a71d8a28eaf44016caab736f3adca048bf0c25","sha":"97d7a92ed0cfa7d01a2bcd73ffd1cc346a6c9fa1","keyword":"cross frame scripting fix","diff":"diff --git a\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py b\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py\nindex eb6a57fca..68184ce65 100644\n--- a\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py\n+++ b\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py\n@@ -257,8 +257,9 @@ def initWebView(self, initialHTML, sizeHint, baseURL):\n \n         html = NSString.stringWithString_(unicode(initialHTML))\n         data = html.dataUsingEncoding_(NSUTF8StringEncoding)\n-        if baseURL is not None:\n-            baseURL = NSURL.URLWithString_(unicode(baseURL))\n+        if baseURL is None:\n+            baseURL = os.path.join(NSBundle.mainBundle().resourcePath(), \"resources\")\n+        baseURL = NSURL.URLWithString_(unicode(baseURL))\n \n         self.view.mainFrame().loadData_MIMEType_textEncodingName_baseURL_(data, u'text\/html', u'utf-8', baseURL)        \n \n@@ -392,6 +393,9 @@ def openPanelDidEnd_returnCode_contextInfo_(self, panel, result, contextID):\n             filenames = panel.filenames()\n             listener.chooseFilename_(filenames[0])\n \n+    def webView_addMessageToConsole_(self, webview, message):\n+        logging.jsalert(message)\n+\n     def webView_runJavaScriptAlertPanelWithMessage_(self, webview, message):\n         logging.jsalert(message)\n \ndiff --git a\/tv\/resources\/templates\/guide-loading b\/tv\/resources\/templates\/guide-loading\nindex 439476c4e..ae8630bd1 100644\n--- a\/tv\/resources\/templates\/guide-loading\n+++ b\/tv\/resources\/templates\/guide-loading\n@@ -13,7 +13,7 @@ guide = views.guides.getObjectByID(int(kargs['id']))\n <link rel=\"stylesheet\" type=\"text\/css\" href=\"resource:css\/sidebar.css\" \/>\n <t:include filename=\"guide-loading.js\" \/>\n <\/head>\n-<frameset rows=\"25, *\" border=\"0\" frameborder=\"0\" framespacing=\"0\" >\n+<frameset rows=\"26, *\" border=\"0\" frameborder=\"0\" framespacing=\"0\" >\n     <frame onload=\"navBarLoaded()\" name=\"miro_navigation_frame\" src=\"resource:html\/guide-navigation.html\" frameborder=\"0\" noresize=\"noresize\" marginheight=\"0\" scrolling=\"no\" marginwidth=\"0\"\/>\n     <frame onload=\"guideLoaded()\" name=\"miro_guide_frame\" frameborder=\"0\" marginheight=\"0\" marginwidth=\"0\"\/>\n <\/frameset>\ndiff --git a\/tv\/resources\/templates\/guide-loading.js b\/tv\/resources\/templates\/guide-loading.js\nindex 8ad77f648..4366867c5 100644\n--- a\/tv\/resources\/templates\/guide-loading.js\n+++ b\/tv\/resources\/templates\/guide-loading.js\n@@ -22,7 +22,11 @@\n         }\n         catch (e) {}\n         \n-        miro_navigation_frame.document.getElementById('load-indicator').style.display = 'none';\n+        var loadIndicator = miro_navigation_frame.document.getElementById('load-indicator');\n+        if (loadIndicator !== null)\n+        {\n+            loadIndicator.style.display = 'none';\n+        }\n     }\n \n     function guideUnloaded() \n@@ -34,6 +38,7 @@\n         }\n         catch (e) {}\n         \n-        miro_navigation_frame.document.getElementById('load-indicator').style.display = 'block';    \n+        miro_navigation_frame.document.getElementById('load-indicator').style.display = 'block';\n     }\n <\/script>\n+\n","files":{"\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py":{"changes":[{"diff":"\n \n         html = NSString.stringWithString_(unicode(initialHTML))\n         data = html.dataUsingEncoding_(NSUTF8StringEncoding)\n-        if baseURL is not None:\n-            baseURL = NSURL.URLWithString_(unicode(baseURL))\n+        if baseURL is None:\n+            baseURL = os.path.join(NSBundle.mainBundle().resourcePath(), \"resources\")\n+        baseURL = NSURL.URLWithString_(unicode(baseURL))\n \n         self.view.mainFrame().loadData_MIMEType_textEncodingName_baseURL_(data, u'text\/html', u'utf-8', baseURL)        \n \n","add":3,"remove":2,"filename":"\/tv\/platform\/osx\/platform\/frontends\/html\/HTMLDisplay.py","badparts":["        if baseURL is not None:","            baseURL = NSURL.URLWithString_(unicode(baseURL))"],"goodparts":["        if baseURL is None:","            baseURL = os.path.join(NSBundle.mainBundle().resourcePath(), \"resources\")","        baseURL = NSURL.URLWithString_(unicode(baseURL))"]}],"source":"\n import os import re import urllib import logging from objc import YES, NO, nil from AppKit import * from WebKit import * from Foundation import * from PyObjCTools import AppHelper from miro import config from miro import prefs from miro.frontends.html import templatehelper from miro.frontends.html import keyboard from miro.frontends.html.displaybase import Display from miro.platform import resources from miro.platform.frontends.html.MainFrame import mapKey, handleKey from miro.platform.frontends.html import threads def getDTVAPICookie(): return None def getDTVAPIURL(): return None class HTMLDisplay(Display): \"HTML browser that can be shown in a MainFrame's right-hand pane.\" def __init__(self, html, existingView=None, frameHint=None, areaHint=None, baseURL=None): \"\"\"'html' is the initial contents of the display, as a string. If frameHint is provided, it is used to guess the initial size the HTML display will be rendered at, which might reduce flicker when the display is installed.\"\"\" self.readyToDisplayHook=None self.readyToDisplay=False self.html=html self.baseURL=baseURL if frameHint and areaHint: self.displaySizeHint=frameHint.getDisplaySizeHint(areaHint) else: self.displaySizeHint=None Display.__init__(self) def get_web(self): try: return self._web except AttributeError: self._web=ManagedWebView.alloc().initWithInitialHTML_existinView_loadFinished_loadURL_sizeHint_baseURL_( self.html, None, self.nowReadyToDisplay, lambda x:self.onURLLoad(unicode(x)), self.displaySizeHint, self.baseURL) return self._web web=property(get_web) def getEventCookie(self): return '' def getDTVPlatformName(self): return 'webkit' def getBodyTagExtra(self): return 'ondragstart=\"handleDragStart(event);\" ondragover=\"return handleDragOver(event);\" ondragleave=\"return handleDragLeave(event);\" ondrop=\"return handleDrop(event);\" ' def getView(self): return self.web.getView() def execJS(self, js): \"\"\"Execute the given Javascript code(provided as a string) in the context of this HTML document.\"\"\" try: self.web.execJS(js) except AttributeError: print \"Couldn't exec javascript! Web view not initialized\" def navigateToFragment(self, fragment): self.web.navigateToFragment(fragment) def addItemAtEnd(self, xml, id): return self.web.addItemAtEnd(xml, id) def addItemBefore(self, xml, id): return self.web.addItemBefore(xml, id) def removeItem(self, id): return self.web.removeItem(id) def removeItems(self, ids): return self.web.removeItems(ids) def changeItem(self, id, xml, changeHint): return self.web.changeItem(id, xml, changeHint) def changeItems(self, args): newArgs=[] for id, xml, changeHint in args: newArgs.append((id, xml, changeHint)) return self.web.changeItems(newArgs) def hideItem(self, id): return self.web.hideItem(id) def showItem(self, id): return self.web.showItem(id) def onURLLoad(self, url): \"\"\"Called when this HTML browser attempts to load a URL(either through user action or Javascript.) The URL is provided as a string. Return true to allow the URL to load, or false to cancel the load(for example, because it was a magic URL that marks an item to be downloaded.) Implementation in HTMLDisplay always returns true; override in a subclass to implement special behavior.\"\"\" pass def callWhenReadyToDisplay(self, hook): self.get_web() if self.readyToDisplay: hook() else: assert self.readyToDisplayHook==None self.readyToDisplayHook=hook def nowReadyToDisplay(self): self.readyToDisplay=True if self.readyToDisplayHook: hook=self.readyToDisplayHook self.readyToDisplayHook=None hook() def unlink(self): webView=self.web.getView() if webView is not nil: threads.warnIfNotOnMainThread('HTMLDisplay.unlink') webView.setHostWindow_(self.currentFrame.obj.window()) @threads.onMainThreadWaitingUntilDone def cancel(self): logging.debug(\"DTV: Canceling load of WebView %s\" % self.web.getView()) self.web.getView().stopLoading_(nil) self.readyToDisplay=False self.readyToDisplayHook=None class ManagedWebHTMLView(WebHTMLView): def keyDown_(self, event): key=mapKey(event) if key in(keyboard.UP, keyboard.DOWN): handleKey(event) else: super(ManagedWebHTMLView, self).keyDown_(event) def rightMouseDown_(self, event): threads.callOnMainThread(self.mouseDown_, event) threads.callOnMainThreadAfterDelay(0.2, WebHTMLView.rightMouseDown_, self, event) class JSOpened(NSObject): def webView_willPerformClientRedirectToURL_delay_fireDate_forFrame_(self, webView, url, delay, fireDate, frame): webView.stopLoading_(nil) NSWorkspace.sharedWorkspace().openURL_(url) jsOpened=JSOpened.alloc().init() class ManagedWebView(NSObject): WebView.registerViewClass_representationClass_forMIMEType_(ManagedWebHTMLView, WebHTMLRepresentation, u'text\/html') def initWithInitialHTML_existinView_loadFinished_loadURL_sizeHint_baseURL_( self, initialHTML, existingView=nil, onInitialLoadFinished=None, onLoadURL=None, sizeHint=None, baseURL=None): self.onInitialLoadFinished=onInitialLoadFinished self.onLoadURL=onLoadURL self.initialLoadFinished=False self.view=existingView self.openPanelContextID=1 self.openPanelContext=dict() threads.callOnMainThreadAndWaitUntilDone(self.initWebView, initialHTML, sizeHint, baseURL) return self def initWebView(self, initialHTML, sizeHint, baseURL): threads.warnIfNotOnMainThread('ManagedWebView.initWebView') if not self.view: self.view=WebView.alloc().init() if sizeHint: self.view.setFrame_(sizeHint) self.view.setCustomUserAgent_(u\"%s\/%s(%s)\" % \\ (config.get(prefs.SHORT_APP_NAME), config.get(prefs.APP_VERSION), config.get(prefs.PROJECT_URL),)) else: if sizeHint: self.view.setFrame_(sizeHint) self.execQueue=[] self.view.setPolicyDelegate_(self) self.view.setResourceLoadDelegate_(self) self.view.setFrameLoadDelegate_(self) self.view.setUIDelegate_(self) html=NSString.stringWithString_(unicode(initialHTML)) data=html.dataUsingEncoding_(NSUTF8StringEncoding) if baseURL is not None: baseURL=NSURL.URLWithString_(unicode(baseURL)) self.view.mainFrame().loadData_MIMEType_textEncodingName_baseURL_(data, u'text\/html', u'utf-8', baseURL) def isKeyExcludedFromWebScript_(self,key): return YES def isSelectorExcludedFromWebScript_(self, sel): return(str(sel) !='eventURL') def eventURL(self,url): self.onLoadURL(url) def webView_contextMenuItemsForElement_defaultMenuItems_(self,webView,contextMenu,defaultMenuItems): event=NSApp().currentEvent() if event.type()==NSLeftMouseDown and(event.modifierFlags() & NSControlKeyMask): fake=NSEvent.mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure_( NSRightMouseDown, event.locationInWindow(), 0, 0, event.windowNumber(), nil, 0, 1, 0) NSApp().postEvent_atStart_(fake, YES) return nil def webView_didFinishLoadForFrame_(self, webview, frame): if(not self.initialLoadFinished) and(frame is self.view.mainFrame()): threads.warnIfNotOnMainThread('ManagedWebView.webView_didFinishLoadForFrame_') self.initialLoadFinished=True for func in self.execQueue: func() self.execQueue=[] if self.onInitialLoadFinished: self.onInitialLoadFinished() scriptObj=self.view.windowScriptObject() scriptObj.setValue_forKey_(self, u'frontend') def webView_didFailProvisionalLoadWithError_forFrame_(self, webview, error, frame): urlError=(error.domain()==NSURLErrorDomain) certError=(error.code() in(NSURLErrorServerCertificateHasBadDate, NSURLErrorServerCertificateHasUnknownRoot, NSURLErrorServerCertificateUntrusted)) if urlError and certError: request=frame.provisionalDataSource().request() if request is nil: request=frame.dataSource().request() url=request.URL() allowed=[config.get(prefs.CHANNEL_GUIDE_URL), config.get(prefs.CHANNEL_GUIDE_FIRST_TIME_URL)] if url.absoluteString() in allowed: NSURLRequest.setAllowsAnyHTTPSCertificate_forHost_(YES, url.host()) frame.loadRequest_(request) def webView_decidePolicyForNavigationAction_request_frame_decisionListener_(self, webview, action, request, frame, listener): threads.warnIfNotOnMainThread('ManagedWebView.webView_decidePolicyForNavigationAction_request_frame_decisionListener_') method=request.HTTPMethod() url=unicode(request.URL()) body=request.HTTPBody() ntype=action['WebActionNavigationTypeKey'] if ntype in(WebNavigationTypeLinkClicked, WebNavigationTypeFormSubmitted, WebNavigationTypeOther): if(not self.onLoadURL) or self.onLoadURL(url): listener.use() else: listener.ignore() else: listener.use() def webView_decidePolicyForNewWindowAction_request_newFrameName_decisionListener_(self, webView, info, request, name, listener): url=info[\"WebActionOriginalURLKey\"] NSWorkspace.sharedWorkspace().openURL_(url) listener.ignore() def webView_createWebViewWithRequest_(self, webView, request): global jsOpened webView=WebView.alloc().init() webView.setFrameLoadDelegate_(jsOpened) webView.mainFrame().loadRequest_(request) return webView def webView_resource_willSendRequest_redirectResponse_fromDataSource_(self, webview, resourceCookie, request, redirectResponse, dataSource): threads.warnIfNotOnMainThread('ManagedWebView.webView_resource_willSendRequest_redirectResponse_fromDataSource_') url=request.URL().absoluteString() match=templatehelper.resourcePattern.match(url) if match is not None: url=resources.url(match.group(1)) urlObject=NSURL.URLWithString_(url) return NSURLRequest.requestWithURL_cachePolicy_timeoutInterval_(urlObject, NSURLRequestReloadIgnoringCacheData, 60) if isinstance(request, NSMutableURLRequest): language=os.environ['LANGUAGE'].split(':')[0].replace('_', '-') request.setValue_forHTTPHeaderField_(language, u'Accept-Language') request.setValue_forHTTPHeaderField_(u'1', u'X-Miro') return request def webView_runOpenPanelForFileButtonWithResultListener_(self, webview, listener): self.openPanelContextID +=1 self.openPanelContext[self.openPanelContextID]=listener panel=NSOpenPanel.openPanel() panel.beginSheetForDirectory_file_types_modalForWindow_modalDelegate_didEndSelector_contextInfo_( NSHomeDirectory(), nil, nil, self.view.window(), self, 'openPanelDidEnd:returnCode:contextInfo:', self.openPanelContextID) @AppHelper.endSheetMethod def openPanelDidEnd_returnCode_contextInfo_(self, panel, result, contextID): listener=self.openPanelContext[contextID] del self.openPanelContext[contextID] if result==NSOKButton: filenames=panel.filenames() listener.chooseFilename_(filenames[0]) def webView_runJavaScriptAlertPanelWithMessage_(self, webview, message): logging.jsalert(message) def getView(self): return self.view def execAfterLoad(self, func): if not self.initialLoadFinished: self.execQueue.append(func) else: threads.callOnMainThreadAndWaitUntilDone(func) def deferUntilAfterLoad(func): def runFunc(*args, **kwargs): func(*args, **kwargs) def schedFunc(self, *args, **kwargs): rf=lambda: runFunc(self, *args, **kwargs) self.execAfterLoad(rf) return schedFunc @deferUntilAfterLoad def execJS(self, js): self.view.stringByEvaluatingJavaScriptFromString_(js) def navigateToFragment(self, fragment): command=\"var tab=document.getElementById(\\\"%s\\\"); tab.scrollIntoView(true);\" % fragment self.execJS(command) def findElt(self, id): doc=self.view.mainFrame().DOMDocument() elt=doc.getElementById_(unicode(id)) return elt def createElts(self, xml): parent=self.view.mainFrame().DOMDocument().createElement_(u\"div\") if len(xml)==0: parent.setInnerHTML_(\"&nbsp;\") else: parent.setInnerHTML_(xml) eltlist=[] for child in range(parent.childNodes().length()): eltlist.append(parent.childNodes().item_(child)) return eltlist @deferUntilAfterLoad def addItemAtEnd(self, xml, id): elt=self.findElt(id) if not elt: print \"warning: addItemAtEnd: missing element %s\" % id else: newElts=self.createElts(xml) for newElt in newElts: elt.insertBefore__(newElt, None) @deferUntilAfterLoad def addItemBefore(self, xml, id): elt=self.findElt(id) if not elt: print \"warning: addItemBefore: missing element %s\" % id else: newElts=self.createElts(xml) for newElt in newElts: elt.parentNode().insertBefore__(newElt, elt) @deferUntilAfterLoad def removeItem(self, id): self._removeElement(id) @deferUntilAfterLoad def removeItems(self, ids): for id in ids: self._removeElement(id) def _removeElement(self, id): elt=self.findElt(id) if not elt: print \"warning: removeItem: missing element %s\" % id else: elt.parentNode().removeChild_(elt) @deferUntilAfterLoad def changeItem(self, id, xml, changeHint): self._changeElement(id, xml, changeHint) @deferUntilAfterLoad def changeItems(self, args): for id, xml, changeHint in args: self._changeElement(id, xml, changeHint) def _changeElement(self, id, xml, changeHint): elt=self.findElt(id) if not elt: print \"warning: changeItem: missing element %s\" % id else: elt.setOuterHTML_(xml) @deferUntilAfterLoad def hideItem(self, id): elt=self.findElt(id) if not elt: print \"warning: hideItem: missing element %s\" % id else: elt.setAttribute__(\"style\", \"display:none\") @deferUntilAfterLoad def showItem(self, id): elt=self.findElt(id) if not elt: print \"warning: showItem: missing element %s\" % id else: elt.setAttribute__(\"style\", \"\") ","sourceWithComments":"# Miro - an RSS based video player application\n# Copyright (C) 2005-2008 Participatory Culture Foundation\n#\n# This program is free software; you can redistribute it and\/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n#\n# In addition, as a special exception, the copyright holders give\n# permission to link the code of portions of this program with the OpenSSL\n# library.\n#\n# You must obey the GNU General Public License in all respects for all of\n# the code used other than OpenSSL. If you modify file(s) with this\n# exception, you may extend this exception to your version of the file(s),\n# but you are not obligated to do so. If you do not wish to do so, delete\n# this exception statement from your version. If you delete this exception\n# statement from all source files in the program, then also delete it here.\n\nimport os\nimport re\nimport urllib\nimport logging\n\nfrom objc import YES, NO, nil\nfrom AppKit import *\nfrom WebKit import *\nfrom Foundation import *\nfrom PyObjCTools import AppHelper\n\nfrom miro import config\nfrom miro import prefs\nfrom miro.frontends.html import templatehelper\nfrom miro.frontends.html import keyboard\nfrom miro.frontends.html.displaybase import Display\nfrom miro.platform import resources\nfrom miro.platform.frontends.html.MainFrame import mapKey, handleKey\nfrom miro.platform.frontends.html import threads\n\n###############################################################################\n# These are used by the channel guide. This platform uses the\n# old-style 'magic URL' guide API, so we just return None. See\n# ChannelGuideToDtvApi in the Trac wiki for the full writeup.\n###############################################################################\n\ndef getDTVAPICookie():\n    return None\n\ndef getDTVAPIURL():\n    return None\n\n###############################################################################\n\nclass HTMLDisplay (Display):\n    \"HTML browser that can be shown in a MainFrame's right-hand pane.\"\n\n    # We don't need to override onSelected, onDeselected\n\n    def __init__(self, html, existingView=None, frameHint=None, areaHint=None, baseURL=None):\n        \"\"\"'html' is the initial contents of the display, as a string. If\n        frameHint is provided, it is used to guess the initial size the HTML\n        display will be rendered at, which might reduce flicker when the\n        display is installed.\"\"\"\n        self.readyToDisplayHook = None\n        self.readyToDisplay = False\n        self.html = html\n        self.baseURL = baseURL\n        if frameHint and areaHint:\n            self.displaySizeHint = frameHint.getDisplaySizeHint(areaHint)\n        else:\n            self.displaySizeHint = None\n        Display.__init__(self)\n \n    # make web a lazily loaded property.  This is useful for the channel\n    # guides because it makes the load happen after setGuideURL\n    def get_web(self):\n        try:\n            return self._web\n        except AttributeError:\n            self._web = ManagedWebView.alloc().initWithInitialHTML_existinView_loadFinished_loadURL_sizeHint_baseURL_(\n                            self.html, None, self.nowReadyToDisplay, lambda x:self.onURLLoad(unicode(x)), self.displaySizeHint, self.baseURL)\n            return self._web\n    web = property(get_web)\n\n    def getEventCookie(self):\n        return ''\n\n    def getDTVPlatformName(self):\n        return 'webkit'\n\n    def getBodyTagExtra(self):\n        return 'ondragstart=\"handleDragStart(event);\" ondragover=\"return handleDragOver(event);\" ondragleave=\"return handleDragLeave(event);\" ondrop=\"return handleDrop(event);\" '\n\n    def getView(self):\n        return self.web.getView()\n\n    def execJS(self, js):\n        \"\"\"Execute the given Javascript code (provided as a string) in the\n        context of this HTML document.\"\"\"\n        try:\n            self.web.execJS(js)\n        except AttributeError:\n            print \"Couldn't exec javascript! Web view not initialized\"\n        #print \"DISP: %s with %s\" % (self.view, js)\n\n    def navigateToFragment(self, fragment):\n        self.web.navigateToFragment(fragment)\n\n    # DOM hooks used by the dynamic template code -- do they need a \n    # try..except wrapper like the above?\n    def addItemAtEnd(self, xml, id):\n        return self.web.addItemAtEnd(xml, id)\n\n    def addItemBefore(self, xml, id):\n        return self.web.addItemBefore(xml, id)\n\n    def removeItem(self, id):\n        return self.web.removeItem(id)\n\n    def removeItems(self, ids):\n        return self.web.removeItems(ids)\n\n    def changeItem(self, id, xml, changeHint):\n        return self.web.changeItem(id, xml, changeHint)\n\n    def changeItems(self, args):\n        newArgs = []\n        for id, xml, changeHint in args:\n            newArgs.append((id, xml, changeHint))\n        return self.web.changeItems(newArgs)\n\n    def hideItem(self, id):\n        return self.web.hideItem(id)\n\n    def showItem(self, id):\n        return self.web.showItem(id)\n\n    def onURLLoad(self, url):\n        \"\"\"Called when this HTML browser attempts to load a URL (either\n        through user action or Javascript.) The URL is provided as a\n        string. Return true to allow the URL to load, or false to cancel\n        the load (for example, because it was a magic URL that marks\n        an item to be downloaded.) Implementation in HTMLDisplay always\n        returns true; override in a subclass to implement special\n        behavior.\"\"\"\n        # For overriding\n        pass\n\n    def callWhenReadyToDisplay(self, hook):\n        self.get_web() # make sure our ManagedWebView is loaded\n        if self.readyToDisplay:\n            hook()\n        else:\n            assert self.readyToDisplayHook == None\n            self.readyToDisplayHook = hook\n\n    # Called (via callback established in constructor)\n    def nowReadyToDisplay(self):\n        self.readyToDisplay = True\n        if self.readyToDisplayHook:\n            hook = self.readyToDisplayHook\n            self.readyToDisplayHook = None\n            hook()\n\n    def unlink(self):\n        webView = self.web.getView()\n        if webView is not nil:\n            threads.warnIfNotOnMainThread('HTMLDisplay.unlink')\n            webView.setHostWindow_(self.currentFrame.obj.window()) # not very pretty\n    \n    @threads.onMainThreadWaitingUntilDone\n    def cancel(self):\n        logging.debug(\"DTV: Canceling load of WebView %s\" % self.web.getView())\n        self.web.getView().stopLoading_(nil)\n        self.readyToDisplay = False\n        self.readyToDisplayHook = None\n\n###############################################################################\n\nclass ManagedWebHTMLView (WebHTMLView):\n\n    def keyDown_(self, event):\n        key = mapKey(event)\n        if key in (keyboard.UP, keyboard.DOWN):\n            handleKey(event)\n        else:\n            super(ManagedWebHTMLView, self).keyDown_(event)\n\n    def rightMouseDown_(self, event):\n        # We want a right click to also select what's underneath so we intercept\n        # the event here, force the left click handler first and reschedule the\n        # right click handler.\n        threads.callOnMainThread(self.mouseDown_, event)\n        threads.callOnMainThreadAfterDelay(0.2, WebHTMLView.rightMouseDown_, self, event)\n\n###############################################################################\n\nclass JSOpened (NSObject):\n    \n    def webView_willPerformClientRedirectToURL_delay_fireDate_forFrame_(self, webView, url, delay, fireDate, frame):\n        webView.stopLoading_(nil)\n        NSWorkspace.sharedWorkspace().openURL_(url)\n\njsOpened = JSOpened.alloc().init()\n\n###############################################################################\n\nclass ManagedWebView (NSObject):\n\n    WebView.registerViewClass_representationClass_forMIMEType_(ManagedWebHTMLView, WebHTMLRepresentation, u'text\/html')\n\n    def initWithInitialHTML_existinView_loadFinished_loadURL_sizeHint_baseURL_(\n        self, initialHTML, existingView=nil, onInitialLoadFinished=None, onLoadURL=None, sizeHint=None, baseURL=None):\n        self.onInitialLoadFinished = onInitialLoadFinished\n        self.onLoadURL = onLoadURL\n        self.initialLoadFinished = False\n        self.view = existingView\n        self.openPanelContextID = 1\n        self.openPanelContext = dict()\n        threads.callOnMainThreadAndWaitUntilDone(self.initWebView, initialHTML, sizeHint, baseURL)        \n        return self\n\n    def initWebView(self, initialHTML, sizeHint, baseURL):\n        threads.warnIfNotOnMainThread('ManagedWebView.initWebView')\n        if not self.view:\n            self.view = WebView.alloc().init()\n            #print \"***** Creating new WebView %s\" % self.view\n            if sizeHint:\n                # We have an estimate of the size that will be assigned to\n                # the view when it is actually inserted in the MainFrame.\n                # Use this to size the view we just created so the HTML\n                # is hopefully rendered to the correct dimensions, instead\n                # of having to be corrected after being displayed.\n                self.view.setFrame_(sizeHint)\n            self.view.setCustomUserAgent_(u\"%s\/%s (%s)\" % \\\n                                          (config.get(prefs.SHORT_APP_NAME),\n                                           config.get(prefs.APP_VERSION),\n                                           config.get(prefs.PROJECT_URL),))\n        else:\n            #print \"***** Using existing WebView %s\" % self.view\n            if sizeHint:\n                self.view.setFrame_(sizeHint)\n        self.execQueue = []\n        self.view.setPolicyDelegate_(self)\n        self.view.setResourceLoadDelegate_(self)\n        self.view.setFrameLoadDelegate_(self)\n        self.view.setUIDelegate_(self)\n\n        html = NSString.stringWithString_(unicode(initialHTML))\n        data = html.dataUsingEncoding_(NSUTF8StringEncoding)\n        if baseURL is not None:\n            baseURL = NSURL.URLWithString_(unicode(baseURL))\n\n        self.view.mainFrame().loadData_MIMEType_textEncodingName_baseURL_(data, u'text\/html', u'utf-8', baseURL)        \n\n    def isKeyExcludedFromWebScript_(self,key):\n        return YES\n\n    def isSelectorExcludedFromWebScript_(self, sel):\n        return (str(sel) != 'eventURL')\n\n    def eventURL(self,url):\n        self.onLoadURL(url)\n\n    def webView_contextMenuItemsForElement_defaultMenuItems_(self,webView,contextMenu,defaultMenuItems):\n        event = NSApp().currentEvent()\n        if event.type() == NSLeftMouseDown and (event.modifierFlags() & NSControlKeyMask):\n            fake = NSEvent.mouseEventWithType_location_modifierFlags_timestamp_windowNumber_context_eventNumber_clickCount_pressure_(\n                           NSRightMouseDown, event.locationInWindow(), 0, 0, event.windowNumber(), nil, 0, 1, 0)\n            NSApp().postEvent_atStart_(fake, YES)\n        return nil\n\n    # Generate callbacks when the initial HTML (passed in the constructor)\n    # has been loaded\n    def webView_didFinishLoadForFrame_(self, webview, frame):\n        if (not self.initialLoadFinished) and (frame is self.view.mainFrame()):\n            threads.warnIfNotOnMainThread('ManagedWebView.webView_didFinishLoadForFrame_')\n            # Execute any function calls we queued because the page load\n            # hadn't completed\n            self.initialLoadFinished = True\n            for func in self.execQueue:\n                func()\n            self.execQueue = []\n\n            if self.onInitialLoadFinished:\n                self.onInitialLoadFinished()\n\n            scriptObj = self.view.windowScriptObject()\n            scriptObj.setValue_forKey_(self, u'frontend')\n\n    def webView_didFailProvisionalLoadWithError_forFrame_(self, webview, error, frame):\n        urlError = (error.domain() == NSURLErrorDomain)\n        certError = (error.code() in (NSURLErrorServerCertificateHasBadDate, \n                                      NSURLErrorServerCertificateHasUnknownRoot, \n                                      NSURLErrorServerCertificateUntrusted))\n\n        if urlError and certError:\n            request = frame.provisionalDataSource().request()\n            if request is nil:\n                request = frame.dataSource().request()\n            url = request.URL()            \n            allowed = [config.get(prefs.CHANNEL_GUIDE_URL), \n                       config.get(prefs.CHANNEL_GUIDE_FIRST_TIME_URL)]\n            if url.absoluteString() in allowed:\n                # The [NSURLRequest setAllowsAnyHTTPSCertificate:forHost:] selector is\n                # not documented anywhere, so I assume it is not public. It is however \n                # a very clean and easy way to allow us to load our channel guide from\n                # https, so let's use it here anyway :)\n                NSURLRequest.setAllowsAnyHTTPSCertificate_forHost_(YES, url.host())\n                # Now reload\n                frame.loadRequest_(request)\n\n    # Intercept navigation actions and give program a chance to respond\n    def webView_decidePolicyForNavigationAction_request_frame_decisionListener_(self, webview, action, request, frame, listener):\n        threads.warnIfNotOnMainThread('ManagedWebView.webView_decidePolicyForNavigationAction_request_frame_decisionListener_')\n        method = request.HTTPMethod()\n        url = unicode(request.URL())\n        body = request.HTTPBody()\n        ntype = action['WebActionNavigationTypeKey']\n        #print \"policy %d for url %s\" % (ntype, url)\n        # setting document.location.href in Javascript (our preferred\n        # method of triggering an action) comes out as an\n        # WebNavigationTypeOther.\n        if ntype in (WebNavigationTypeLinkClicked, WebNavigationTypeFormSubmitted, WebNavigationTypeOther):\n            # Make sure we have a real, bona fide Python string, not an\n            # NSString. Unfortunately, == can tell the difference.\n            if (not self.onLoadURL) or self.onLoadURL(url):\n                listener.use()\n            else:\n                listener.ignore()\n        else:\n            listener.use()\n\n    # Intercept external links requests\n    def webView_decidePolicyForNewWindowAction_request_newFrameName_decisionListener_(self, webView, info, request, name, listener):\n        url = info[\"WebActionOriginalURLKey\"]\n        NSWorkspace.sharedWorkspace().openURL_(url)\n        listener.ignore()\n\n    def webView_createWebViewWithRequest_(self, webView, request):\n        global jsOpened\n        webView = WebView.alloc().init()\n        webView.setFrameLoadDelegate_(jsOpened)\n        webView.mainFrame().loadRequest_(request)\n        return webView\n\n    # Redirect resource: links to files in resource bundle\n    def webView_resource_willSendRequest_redirectResponse_fromDataSource_(self, webview, resourceCookie, request, redirectResponse, dataSource):\n        threads.warnIfNotOnMainThread('ManagedWebView.webView_resource_willSendRequest_redirectResponse_fromDataSource_')\n        url = request.URL().absoluteString()\n\n        match = templatehelper.resourcePattern.match(url)\n        if match is not None:\n            url = resources.url(match.group(1))\n            urlObject = NSURL.URLWithString_(url)\n            return NSURLRequest.requestWithURL_cachePolicy_timeoutInterval_(urlObject, NSURLRequestReloadIgnoringCacheData, 60)\n\n        if isinstance(request, NSMutableURLRequest):\n            language = os.environ['LANGUAGE'].split(':')[0].replace('_', '-')\n            request.setValue_forHTTPHeaderField_(language, u'Accept-Language')\n            request.setValue_forHTTPHeaderField_(u'1', u'X-Miro')\n        \n        return request\n\n    def webView_runOpenPanelForFileButtonWithResultListener_(self, webview, listener):\n        self.openPanelContextID += 1\n        self.openPanelContext[self.openPanelContextID] = listener\n        panel = NSOpenPanel.openPanel()\n        panel.beginSheetForDirectory_file_types_modalForWindow_modalDelegate_didEndSelector_contextInfo_(\n            NSHomeDirectory(),\n            nil,\n            nil,\n            self.view.window(),\n            self,\n            'openPanelDidEnd:returnCode:contextInfo:',\n            self.openPanelContextID)\n\n    @AppHelper.endSheetMethod\n    def openPanelDidEnd_returnCode_contextInfo_(self, panel, result, contextID):\n        listener = self.openPanelContext[contextID]\n        del self.openPanelContext[contextID]\n        if result == NSOKButton:\n            filenames = panel.filenames()\n            listener.chooseFilename_(filenames[0])\n\n    def webView_runJavaScriptAlertPanelWithMessage_(self, webview, message):\n        logging.jsalert(message)\n\n    # Return the actual WebView that we're managing\n    def getView(self):\n        return self.view\n\n    # Call func() once the document has finished loading. If the\n    # document has already finished loading, call it right away. But\n    # in either case, the call is executed on the main thread, by\n    # queueing an event, since WebViews are not documented to be\n    # thread-safe, and we have seen crashes.\n    def execAfterLoad(self, func):\n        if not self.initialLoadFinished:\n            self.execQueue.append(func)\n        else:\n            threads.callOnMainThreadAndWaitUntilDone(func)\n\n    # Decorator to make using execAfterLoad easier\n    def deferUntilAfterLoad(func):\n        def runFunc(*args, **kwargs):\n            func(*args, **kwargs)\n        def schedFunc(self, *args, **kwargs):\n            rf = lambda: runFunc(self, *args, **kwargs)\n            self.execAfterLoad(rf)\n        return schedFunc\n\n    # Execute given Javascript string in context of the HTML document\n    @deferUntilAfterLoad\n    def execJS(self, js):\n        self.view.stringByEvaluatingJavaScriptFromString_(js)\n\n    def navigateToFragment(self, fragment):\n        command = \"var tab = document.getElementById(\\\"%s\\\"); tab.scrollIntoView(true);\" % fragment\n        self.execJS(command)\n\n    ## DOM mutators called, ultimately, by dynamic template system ##\n\n    def findElt(self, id):\n        doc = self.view.mainFrame().DOMDocument()\n        elt = doc.getElementById_(unicode(id))\n        return elt\n\n    def createElts(self, xml):\n        parent = self.view.mainFrame().DOMDocument().createElement_(u\"div\")\n        if len(xml) == 0:\n            parent.setInnerHTML_(\"&nbsp;\")\n        else:\n            parent.setInnerHTML_(xml)\n        eltlist = []\n        for child in range(parent.childNodes().length()):\n            eltlist.append(parent.childNodes().item_(child))\n        return eltlist\n        \n    @deferUntilAfterLoad\n    def addItemAtEnd(self, xml, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: addItemAtEnd: missing element %s\" % id\n        else:\n            #print \"add item %s at end of %s\" % (elt.getAttribute_(\"id\"), id)\n            #print xml[0:79]\n            newElts = self.createElts(xml)\n            for newElt in newElts:\n                elt.insertBefore__(newElt, None)\n\n    @deferUntilAfterLoad\n    def addItemBefore(self, xml, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: addItemBefore: missing element %s\" % id\n        else:\n            newElts = self.createElts(xml)\n            for newElt in newElts:\n                #print \"add item %s before %s\" % (newelt.getAttribute_(\"id\"), id)\n                elt.parentNode().insertBefore__(newElt, elt)\n\n    @deferUntilAfterLoad\n    def removeItem(self, id):\n        self._removeElement(id)\n\n    @deferUntilAfterLoad\n    def removeItems(self, ids):\n        for id in ids:\n            self._removeElement(id)\n\n    def _removeElement(self, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: removeItem: missing element %s\" % id\n        else:\n            #print \"remove item %s\" % id\n            elt.parentNode().removeChild_(elt)\n\n    @deferUntilAfterLoad\n    def changeItem(self, id, xml, changeHint):\n        self._changeElement(id, xml, changeHint)\n\n    @deferUntilAfterLoad\n    def changeItems(self, args):\n        for id, xml, changeHint in args:\n            self._changeElement(id, xml, changeHint)\n\n    def _changeElement(self, id, xml, changeHint):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: changeItem: missing element %s\" % id\n        else:\n            #print \"change item %s (new id %s)\" % (id, elt.getAttribute_(\"id\"))\n            #print xml[0:79]\n            #if id != elt.getAttribute_(\"id\"):\n            #    raise Exception\n            #elt = self.findElt(id)\n            #if not elt:\n            #    print \"ERROR ELEMENT LOST %s\" % id\n            elt.setOuterHTML_(xml)\n\n    @deferUntilAfterLoad\n    def hideItem(self, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: hideItem: missing element %s\" % id\n        else:\n            #print \"hide item %s (new style '%s')\" % (id, elt.getAttribute_(\"style\"))\n            elt.setAttribute__(\"style\", \"display:none\")\n\n    @deferUntilAfterLoad\n    def showItem(self, id):\n        elt = self.findElt(id)\n        if not elt:\n            print \"warning: showItem: missing element %s\" % id\n        else:\n            #print \"show item %s (new style '%s')\" % (id, elt.getAttribute_(\"style\"))\n            elt.setAttribute__(\"style\", \"\")\n\n###############################################################################\n"}},"msg":"- When a HTMLDisplay is created without a baseURL on OS X, now forcing a \"dummy\" one to avoid cross-frame scripting errors (fixes #9423).\n- Added an undocumented delegate method of WebView allowing to log (and therefore debug) javascript runtime errors.\n- Minor layout change of the guide-loading frameset.\n\n\ngit-svn-id: https:\/\/svn.participatoryculture.org\/svn\/dtv\/trunk@6510 bce20531-a64c-4166-8316-56baf4a01729\n\nOriginal sha1: a3a71d8a28eaf44016caab736f3adca048bf0c25"}}}