
  """SSL Module."""  import binascii, sha import M2Crypto.RSA, M2Crypto.BIO import pyopenspime.xmpp, pyopenspime.util   class EnDec(): """ Encrypter-Decrypted object. This object is used to encrypt, descrypt and sign OpenSpime stanzas. It includes RSA and AES support as defined in the OpenSpime Core Protocol v0.9. """  def __init__(self): """ Initialize an EnDec object. """  self.rsa_pub_key_path='' self.rsa_pub_key=None  self.rsa_priv_key_path='' self.rsa_priv_key_pass='' self.rsa_priv_key=None  def load_rsa_key_bio(self, rsa_pub_key_path, rsa_priv_key_path, rsa_priv_key_pass): """ Load public and private RSA key from.pem files.  @type rsa_pub_key_path: unicode @param rsa_pub_key_path: The path to the RSA public key.pem file. @type rsa_priv_key_path: unicode @param rsa_priv_key_path: The path to the RSA private key.pem file. @type rsa_priv_key_pass: unicode @param rsa_priv_key_pass: The RSA private key.pem file password. """  self.load_rsa_pub_key(rsa_pub_key_path) self.load_rsa_priv_key(rsa_priv_key_path, rsa_priv_key_pass)  def load_rsa_pub_key(self, rsa_pub_key_path): """ Load public RSA key from.pem file.  @type rsa_pub_key_path: unicode @param rsa_pub_key_path: The path to the RSA public key.pem file. """  self.rsa_pub_key_path=rsa_pub_key_path self.rsa_pub_key=M2Crypto.RSA.load_pub_key(rsa_pub_key_path)  def load_rsa_priv_key(self, rsa_priv_key_path, rsa_priv_key_pass):  """ Load private RSA key from.pem file.  @type rsa_priv_key_path: unicode @param rsa_priv_key_path: The path to the RSA private key.pem file. @type rsa_priv_key_pass: unicode @param rsa_priv_key_pass: The RSA private key.pem file password. """   self.rsa_priv_key_path=rsa_priv_key_path self.rsa_priv_key_pass=pyopenspime.util.to_utf8(rsa_priv_key_pass) self.rsa_priv_key=M2Crypto.RSA.load_key(rsa_priv_key_path, callback=self.__rsa_callback_get_passphrase)  def __rsa_callback_get_passphrase(self, v):  return self.rsa_priv_key_pass  def __aes_encrypt_base64(self, plaintext, aes_key, aes_vint):  mem=M2Crypto.BIO.MemoryBuffer() cf=M2Crypto.BIO.CipherStream(mem) cf.set_cipher('aes_256_cbc', aes_key, aes_vint, 1) cf.write(plaintext) cf.flush() cf.write_close() cf.close() return binascii.b2a_base64(mem.read())  def __aes_decrypt_base64(self, encrypted, aes_key, aes_vint):  mem=M2Crypto.BIO.MemoryBuffer(binascii.a2b_base64(encrypted)) cf=M2Crypto.BIO.CipherStream(mem) cf.set_cipher('aes_256_cbc', aes_key, aes_vint, 0) cf.write_close() decrypted=cf.read() cf.close() return decrypted  def __rsa_public_encrypt_base64(self, plaintext):   s=int(( self.rsa_pub_key.__len__()) / 8) -11 encrypted=[] for i in range(0, len(plaintext), s): encrypted.append(self.rsa_pub_key.public_encrypt(plaintext[i:i+s], M2Crypto.RSA.pkcs1_padding)) return binascii.b2a_base64(''.join(encrypted))  def __rsa_private_decrypt_base64(self, encrypted):   encrypted=binascii.a2b_base64(encrypted) s=int(self.rsa_priv_key.__len__() / 8) decrypted=[] for i in range(0, len(encrypted), s): decrypted.append(self.rsa_priv_key.private_decrypt(encrypted[i:i+s], M2Crypto.RSA.pkcs1_padding)) return ''.join(decrypted)  def __rsa_private_encrypt_base64(self, plaintext):   s=int(( self.rsa_priv_key.__len__()) / 8) -11 encrypted=[] for i in range(0, len(plaintext), s): encrypted.append(self.rsa_priv_key.private_encrypt(plaintext[i:i+s], M2Crypto.RSA.pkcs1_padding)) return binascii.b2a_base64(''.join(encrypted))  def __rsa_public_decrypt_base64(self, encrypted):   encrypted=binascii.a2b_base64(encrypted) s=int(self.rsa_pub_key.__len__() / 8) decrypted=[] for i in range(0, len(encrypted), s): decrypted.append(self.rsa_pub_key.public_decrypt(encrypted[i:i+s], M2Crypto.RSA.pkcs1_padding)) return ''.join(decrypted)  def private_encrypt_text(self, plaintext): """ Encrypts plaintext with the RSA private key of entity.  @type plaintext: str @param plaintext: The string to be encrypted.  @rtype: str @return: The base64 encoded plaintext. """ return self.__rsa_private_encrypt_base64(plaintext)  def public_encrypt(self, transport): """ Encrypts the content of the transport node with public key of recipient.  @type transport: unicode @param transport: The <transport/> node content to be encrypted.  @rtype: tuple @return: Tuple containing:(base64 encrypted transport, base64 encrypted transport-key). """  aes_key=M2Crypto.m2.rand_bytes(32)  aes_vint=M2Crypto.m2.rand_bytes(16)  encrypted=self.__aes_encrypt_base64(transport, aes_key, aes_vint).replace('\r', '').replace('\n', '')  transport_key=u"<transportkey xmlns='openspime:protocol:core:transportkey' version='0.9'> \ <key>%s</key><vint>%s</vint> \ </transportkey>" %( binascii.b2a_base64(aes_key).replace('\r', '').replace('\n', ''), \ binascii.b2a_base64(aes_vint).replace('\r', '').replace('\n', ''))  transport_key=pyopenspime.util.to_utf8(transport_key)  transport_key_enc=self.__rsa_public_encrypt_base64(transport_key).replace('\r', '').replace('\n', '')  return[encrypted, transport_key_enc]   def private_decrypt(self, encrypted, transport_key_enc): """ Decrypts a string encoded with public key of recipient.  @type encrypted: str @param encrypted: The base64 encrypted content of the <transport/> node. @type transport_key_enc: str @param transport_key_enc: The base64 encrypted transport-key.  @rtype: str @return: The decrypted <transport/> node content. """  transport_key=self.__rsa_private_decrypt_base64(transport_key_enc)  n_transport_key=pyopenspime.xmpp.simplexml.Node(node=transport_key) for child in n_transport_key.getChildren(): if child.getName().strip().lower()=='key': aes_key=binascii.a2b_base64(child.getData()) if child.getName().strip().lower()=='vint': aes_vint=binascii.a2b_base64(child.getData())  return self.__aes_decrypt_base64(encrypted, aes_key, aes_vint)  def private_sign(self, content): """ Returns the value of the signature of a the <transport/> node. Reference is OpenSpime protocol v0.9.  @type content: str @param content: The string content of the <transport/> node.  @rtype: str @return: The base64 encoded signature of the <transport/> node. """  content_canonical=pyopenspime.util.convert_to_canonical_xml(content)  s=sha.sha(content_canonical).digest()  return self.__rsa_private_encrypt_base64(s).replace('\r', '').replace('\n', '')  def public_check_sign(self, content, signature): """ Returns the value of the signature of a the <transport/> node. Reference is OpenSpime protocol v0.9.  @type content: str @param content: The string content of the <transport/> node. @type signature: str @param signature: The signature.  @rtype: boolean @return: True if signature is valid, False if it is not. """  content_canonical=pyopenspime.util.convert_to_canonical_xml(content)  s=sha.sha(content_canonical).digest()  try: sha_in_signature=self.__rsa_public_decrypt_base64(signature) except: return False  return s==sha_in_signature   