
import copy import numpy import torch from. import basefaultdescriptor DATA_CONVERSION_MAPPING={numpy.dtype('float16'): numpy.uint16, numpy.dtype('float32'): numpy.uint32, numpy.dtype('float64'): numpy.uint64, numpy.dtype('uint8'): numpy.uint8, numpy.dtype('int8'): numpy.uint8, numpy.dtype('int16'): numpy.uint16, numpy.dtype('int32'): numpy.uint32, numpy.dtype('int64'): numpy.uint64, } DATA_WIDTH_MAPPING={numpy.dtype('float16'): '16', numpy.dtype('float32'): '32', numpy.dtype('float64'): '64', numpy.dtype('uint8'): '8', numpy.dtype('int8'): '8', numpy.dtype('int16'): '16', numpy.dtype('int32'): '32', numpy.dtype('int64'): '64', } TEMPLATE_STRING='{{:0{}b}}' def pytorch_element_to_binary(value: torch.Tensor) -> str: if value.size() !=tuple(): value=value[0] numpy_value=value.cpu().numpy() dtype=numpy_value.dtype new_dtype=DATA_CONVERSION_MAPPING[dtype] width=DATA_WIDTH_MAPPING[dtype] str_bin_value=TEMPLATE_STRING.format(width).format(numpy_value.view(new_dtype)) return str_bin_value def inject_fault_binary(binary: str, fault: basefaultdescriptor.BaseFaultDescriptor, sampler: torch.Generator=None) -> str: injected_binary=copy.deepcopy(binary) for index in fault.bit_index: if fault.bit_value==basefaultdescriptor.BitValue.One: injected_binary[index]="1" elif fault.bit_value==basefaultdescriptor.BitValue.Zero: injected_binary[index]="0" elif fault.bit_value==basefaultdescriptor.BitValue.BitFlip: injected_binary[index]=str(int(injected_binary[index]) ^ 1) elif fault.bit_value==basefaultdescriptor.BitValue.Random: if sampler is None: raise ValueError("A sampler must be passed when using random bit-flips") random_bit=torch.randint(0, 2, size=(), generator=sampler) injected_binary[index]=str(random_bit.item()) return injected_binary def binary_to_pytorch_element(binary: str, original_value: torch.Tensor) -> torch.Tensor: if original_value.size() !=tuple(): original_value=original_value[0] dtype=original_value.cpu().numpy().dtype new_dtype=DATA_CONVERSION_MAPPING[dtype] python_int=int(binary, base=2) new_numpy_value=new_dtype([python_int]).view(dtype) return torch.from_numpy(new_numpy_value).to(original_value)[0] def inject_fault_pytorch(tensor: torch.Tensor, fault: basefaultdescriptor.BaseFaultDescriptor, sampler: torch.Generator=None) -> torch.Tensor: binary=pytorch_to_binary(tensor) injected_binary=inject_fault_binary(binary, fault, sampler) injected_tensor=binary_to_pytorch_element(binary, tensor) return injected_tensor 