
import json import requests from sqlalchemy import insert, select, text from api import db from api.models import Field, Task, Tool from app import app BASE_DIR=app.config["BASE_DIR"] def insert_fields(): """Insert data about annotations fields into the DB""" with open(f"{BASE_DIR}/tests/fixtures/fields.json") as fields: field_data=json.load(fields) db.session.bulk_insert_mappings(Field, field_data) db.session.commit() def check_for_entry(tool): """Receives a dict containing tool information and checks to see if it exists in the DB""" tool_name=tool["name"] result=db.session.execute(select(Tool).where(Tool.name==tool_name)).all() if len(result) > 0: print(f"{tool_name} already exists in database") else: add_tool_entry(tool) check_deprecation(tool) def add_tool_entry(tool): """Receives a dict containing tool information and adds an entry to the tool table""" tool={ "name": tool["name"], "title": tool["title"], "description": tool["description"], "url": tool["url"], } db.session.execute(insert(Tool), tool) db.session.commit() print(f"{tool['name']} inserted into db") def check_deprecation(tool): """Receives a dict containing tool information and checks its deprecation status.""" tool_name=tool["name"] if tool["deprecated"] is True or tool["annotations"]["deprecated"] is True: print(f"{tool_name} is deprecated") fields=[] for field in tool["annotations"]: if field=="replaced_by": if( tool["annotations"]["replaced_by"] is None and tool["replaced_by"] is None ): add_tasks(["replaced_by"], tool_name) continue else: fields.append(field) remove_tasks(fields, tool_name) else: print(f"{tool_name} is not deprecated. Sorting annotations fields.") remove_tasks(["replaced_by"], tool_name) sort_fields(tool) def sort_fields(tool): """Receives a tool dict and checks/sorts the values of the core/annotations fields""" completed_fields=[] empty_fields=[] tool_name=tool["name"] for field in tool["annotations"]: fields_to_skip=[ "replaced_by", "deprecated", "experimental", "developer_docs_url", "user_docs_url", "feedback_url", "privacy_policy_url", "for_wikis", "available_ui_languages", ] if field in fields_to_skip: continue elif field in tool: if(tool[field]==[] or tool[field] is None) and( tool["annotations"][field]==[] or tool["annotations"][field] is None ): empty_fields.append(field) elif tool[field] !=[] or tool[field] is not None: completed_fields.append(field) continue elif tool["annotations"][field]==[] or tool["annotations"][field] is None: empty_fields.append(field) elif tool["annotations"][field] !=[] or tool["annotations"][field] is not None: completed_fields.append(field) print({"Empty": empty_fields, "Completed": completed_fields}) add_tasks(empty_fields, tool_name) remove_tasks(completed_fields, tool_name) def remove_tasks(fields, tool_name): """Receives a list of fields and a tool name and removes matching, incomplete tasks from the task table""" for field in fields: query=text( "DELETE FROM task WHERE field_name=:field_name AND tool_name=:tool AND user IS NULL" ).bindparams(field_name=field, tool=tool_name) db.session.execute(query) db.session.commit() def add_tasks(fields, tool_name): """Receives a list of fields and a tool name and adds tasks to the task table where none exist""" for field in fields: query=text( "SELECT * FROM task WHERE field_name=:field_name AND tool_name=:tool" ).bindparams(field_name=field, tool=tool_name) result=db.session.execute(query).all() if len(result) > 0: print(f"A task for{tool_name},{field} already exists in the database") continue else: task={"tool_name": tool_name, "field_name": field} db.session.execute(insert(Task), task) db.session.commit() print(f"Added{field} task for{tool_name}") REQUEST_LABEL="Toolhunt API" USER_INFO="User: NicoleLBee" headers={"User-Agent": f"{REQUEST_LABEL} -{USER_INFO}"} TOOL_API_ENDPOINT="https://toolhub.wikimedia.org/api/tools/" TOOL_TEST_API_ENDPOINT="https://toolhub-demo.wmcloud.org/api/tools/" def get_tools(): """Getting data on all Toolhub tools""" url=f"{TOOL_TEST_API_ENDPOINT}" response=requests.get(url, headers=headers) if response.status_code==200: api_response=response.json() tools=api_response["results"] while api_response["next"]: api_response=requests.get(api_response["next"], headers=headers).json() tools.extend(api_response["results"]) return tools def get_single_tool(tool): """Gets data on a single tool""" url=f"{TOOL_TEST_API_ENDPOINT}{tool}" response=requests.get(url, headers=headers) if response.status_code==200: api_response=response.json() return api_response def populate_db(data_set): """Accepts a list of dicts and runs each dict through the insertion process""" for tool in data_set: check_for_entry(tool) return "All done." 